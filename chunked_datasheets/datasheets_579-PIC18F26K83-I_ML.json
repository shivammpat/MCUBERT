[
    "Description\nThe PIC18(L)FXXK83 is a full-featured CAN product family that can be used in automotive and industrial applications. The multitude of communication peripherals found on the product family, such as CAN, SPI, two I 2 Cs, two UARTs, LIN, DMX, and DALI can handle a wide range of wired and wireless (using external modules) communication protocols for intelligent applications. This family includes a 12-bit ADC with Computation (ADC 2 ) extensions for automated signal analysis to reduce the complexity of the application. This, combined with the Core Independent Peripherals integration capabilities, enables functions for motor control, power supply, sensor, signal and user interface applications.",
    "Memory\n\u00b7 C Compiler Optimized RISC Architecture\n\u00b7 Operating Speed:\n-Up to 64 MHz clock operation\n-62.5 ns minimum instruction cycle\n\u00b7 Two Direct Memory Access (DMA) Controllers:\n-Data transfers to SFR/GPR spaces from either Program Flash Memory, Data EEPROM or SFR/GPR spaces\n-User-programmable source and destination sizes\n-Hardware and software-triggered data transfers\n\u00b7 System Bus Arbiter with User-Configurable Priorities for Scanner and DMA1/DMA2 with respect to the main line and interrupt execution\n\u00b7 Vectored Interrupt Capability:\n-Selectable high/low priority\n-Fixed interrupt latency\n-Programmable vector table base address\n\u00b7 31-Level Deep Hardware Stack\n\u00b7 Low-Current Power-on Reset (POR)\n\u00b7 Configurable Power-up Timer (PWRT)\n\u00b7 Brown-Out Reset (BOR)\n\u00b7 Low-Power BOR (LPBOR) Option\n\u00b7 Windowed Watchdog Timer (WWDT):\n-Variable prescaler selection\n-Variable window size selection\n-Configurable in hardware or software\n\u00b7 Up to 64 KB Flash Program Memory\n\u00b7 Up to 4 KB Data SRAM Memory\n\u00b7 Up to 1 KB Data EEPROM",
    "Memory\n\u00b7 Memory Access Partition (MAP):\n-Configurable boot and app region sizes with individual write-protections\n\u00b7 Programmable Code Protection\n\u00b7 Device Information Area (DIA) stores:\n-Unique IDs and Device IDs\n-Temp Sensor factory-calibrated data\n-Fixed Voltage Reference calibrated data\n\u00b7 Device Configuration Information (DCI) stores:\n-Erase row size\n-Number of write latches per row\n-Number of user rows\n-Data EEPROM memory size\n-Pin count",
    "Operating Characteristics\n\u00b7 Operating Voltage Range:\n-1.8V to 3.6V (PIC18LF25/26K83)\n-2.3V to 5.5V (PIC18F25/26K83)\n\u00b7 Temperature Range:\n-Industrial: -40\u00b0C to 85\u00b0C\n-Extended: -40\u00b0C to 125\u00b0C",
    "Power-Saving Functionality\n\u00b7 DOZE mode: Ability to run CPU core slower than the system clock\n\u00b7 IDLE mode: Ability to halt CPU core while internal peripherals continue operating\n\u00b7 SLEEP mode: Lowest power consumption\n\u00b7 Peripheral Module Disable (PMD):\n-Ability to disable unused peripherals to minimize power consumption",
    "eXtreme Low-Power (XLP) Features\n\u00b7 Sleep mode: 60 nA @ 1.8V, typical\n\u00b7 Windowed Watchdog Timer: 720 nA @ 1.8V, typical\n\u00b7 Secondary Oscillator: 580 nA @ 32 kHz\n\u00b7 Operating Current:\n-4 uA @ 32 kHz, 1.8V, typical\n-45 uA/MHz @ 1.8V, typical",
    "Digital Peripherals\n\u00b7 Three 8-Bit Timers (TMR2/4/6) with Hardware Limit Timer (HLT):\n-Hardware monitoring and Fault detection\n\u00b7 Four 16-Bit Timers (TMR0/1/3/5)\n\u00b7 Four Configurable Logic Cell (CLC):\n-Integrated combinational and sequential logic\n\u00b7 Three Complementary Waveform Generators (CWGs):\n-Rising and falling edge dead-band control\n-Full-bridge, half-bridge, 1-channel drive\n-Multiple signal sources\n-Programmable dead band\n-Fault-shutdown input\n\u00b7 Four Capture/Compare/PWM (CCP) modules\n\u00b7 Four 10-bit Pulse-Width Modulators (PWMs)\n\u00b7 Numerically Controlled Oscillator (NCO):\n-Generates true linear frequency control\n-High resolution using 20-bit accumulator and 20-bit increment values\n\u00b7 DSM: Data Signal Modulator:\n-Multiplex two carrier clocks, with glitch pre -vention feature\n-Multiple sources for each carrier\n\u00b7 Programmable CRC with Memory Scan:\n-Reliable data/program memory monitoring for fail-safe operation (e.g., Class B)",
    "Digital Peripherals\n-Calculate CRC over any portion of program memory or data EEPROM\n\u00b7 Two UART Modules:\n-Modules are asynchronous and compatible with RS-232 and RS-485\n-Support LIN Master and Slave, DMX mode, DALI Gear and Device protocols\n-Automatic and user-timed BREAK period generation\n-DMA Compatible\n-Automatic checksums\n-Programmable 1, 1.5, and two Stop bits\n-Wake-up on BREAK reception",
    "PIC18(L)F25/26K83\n\u00b7 One SPI module:\n-Configurable length bytes\n-Configurable length data packets\n-Receive-without-transmit option\n-Transmit-without-receive option\n-Transfer byte counter\n-Separate Transmit and Receive Buffers with 2-byte FIFO and DMA capabilities\n\u00b7 CAN module:\n-Conforms to CAN 2.0B Active Specification\n-Three operating modes: Legacy (compatible with existing PIC18CXX8/FXX8 CAN modules), Enhanced mode, and FIFO mode.\n-Message bit rates up to 1 Mbps\n-DeviceNet \uf0e4 data byte filter support\n-Six programmable receive/transmit buffers\n-Three dedicated transmit buffers\n-Two dedicated receive buffers\n-16 Full, 29-bit acceptance filters with dynamic association\n-Three full, 29-bit acceptance masks\n-Automatic remote frame handling\n-Advanced error management features.\n\u00b7 Two I 2 C modules, SMBus, PMBus\u2122 compatible:\n-Dedicated Address, Transmit and Receive buffers\n-Bus Collision Detection with arbitration\n-Bus time-out detection and handling\n-Multi-Master mode\n-Separate Transmit and Receive Buffers with 2-byte FIFO and DMA capabilities",
    "PIC18(L)F25/26K83\n-I 2 C, SMBus 2.0 and SMBus 3.0, and 1.8V input level selections\n-Supports Standard-mode (100 kHz), Fastmode (400 kHz) and Fast-mode plus (1 MHz) modes of operation\n\u00b7 Device I/O Port Features:\n-25 I/O pins\n-One input-only pin (RE3)\n-Individually programmable I/O direction, open-drain, slew rate, weak pull-up control\n-Interrupt-on-change\n-Three External Interrupt Pins\n\u00b7 Peripheral Pin Select (PPS):\n-Enables pin mapping of digital I/O\n\u00b7 Two Signal Measurement Timer (SMT):\n-24-bit timer/counter with prescaler",
    "Analog Peripherals\n\u00b7 Analog-to-Digital Converter with Computation (ADC 2 ):\n-12-bit with up to 24 external channels up to 140 ksps\n-Automated post-processing\n-Automated math functions on input signals: averaging, filter calculations, oversampling and threshold comparison\n-Operates in Sleep\n-Integrated charge pump for improved lowvoltage operation\n\u00b7 Hardware Capacitive Voltage Divider (CVD):\n-Automates touch sampling and reduces soft -ware size and CPU usage when touch or proximity sensing is required\n-Adjustable sample and hold capacitor array\n-Two guard ring output drives\n\u00b7 Temperature Sensor:\n-Internal connection to ADC\n-Can be calibrated for improved accuracy\n\u00b7 Two Comparators:\n-Low-Power/High-Speed mode\n-Fixed Voltage Reference at noninverting input(s)\n-Comparator outputs externally accessible\n\u00b7 5-Bit Digital-to-Analog Converter (DAC):\n-5-bit resolution, rail-to-rail\n-Positive Reference Selection\n-Unbuffered I/O pin output\n-Internal connections to ADCs and comparators\n\u00b7 Voltage Reference:\n-Fixed Voltage Reference with 1.024V, 2.048V and 4.096V output levels",
    "Flexible Oscillator Structure\n\u00b7 High-Precision Internal Oscillator:\n-Selectable frequency range up to 64 MHz\n-\u00b11% at calibration (nominal)\n\u00b7 Low-Power Internal 32 kHz Oscillator (LFINTOSC)\n\u00b7 External 32 kHz Crystal Oscillator (SOCS)\n\u00b7 External Oscillator Block with:\n-x4 PLL with external sources\n-Three crystal/resonator modes up to 20 MHz\n-Three external clock modes up to 20 MHz\n\u00b7 Fail-Safe Clock Monitor\n\u00b7 Oscillator Start-up Timer (OST):\n-Ensures stability of crystal oscillator sources",
    "PIC18(L)F25/26K83\nTABLE 1:\nPIC18(L)FXXK83 FAMILY TYPES",
    "PIC18(L)F25/26K83\nPIC18(L)F25K83, Data Sheet Index = (A). PIC18(L)F25K83, Program Flash Memory (KB) = 32. PIC18(L)F25K83, Data EEPROM (B) = 1024. PIC18(L)F25K83, Data SRAM (bytes) = 2048. PIC18(L)F25K83, I/O Pins = 25. PIC18(L)F25K83, 12-bit ADC 2 (ch) = 24. PIC18(L)F25K83, 5-bit DAC = 1. PIC18(L)F25K83, Comparator = 2. PIC18(L)F25K83, 8-bit/ (with HLT)/16-bit Timer = 3/4. PIC18(L)F25K83, Window Watchdog Timer (WWDT) Signal Measurement Timer (SMT) = Y Y. PIC18(L)F25K83, CCP/10-bit PWM =",
    "PIC18(L)F25/26K83\n4/4. PIC18(L)F25K83, CWG = 3. PIC18(L)F25K83, NCO = 1. PIC18(L)F25K83, CLC = 4. PIC18(L)F25K83, Zero-Cross Detect = Y. PIC18(L)F25K83, Direct Memory Access (DMA) Memory Access Partition = 2 Y. PIC18(L)F25K83, Vectored Interrupts = Y. PIC18(L)F25K83, CAN = Y. PIC18(L)F25K83, UART with Protocols = 2 2/1. PIC18(L)F25K83, I 2 C/SPI = Y. PIC18(L)F25K83, Peripheral Pin Select = Y. PIC18(L)F25K83, Peripheral Module Disable = . PIC18(L)F25K83, Debug (1) = I. PIC18(L)F26K83, Data Sheet Index = (A).",
    "PIC18(L)F25/26K83\nPIC18(L)F26K83, Program Flash Memory (KB) = 64. PIC18(L)F26K83, Data EEPROM (B) = 1024. PIC18(L)F26K83, Data SRAM (bytes) = 4096. PIC18(L)F26K83, I/O Pins = 25. PIC18(L)F26K83, 12-bit ADC 2 (ch) = 24. PIC18(L)F26K83, 5-bit DAC = 1. PIC18(L)F26K83, Comparator = 2. PIC18(L)F26K83, 8-bit/ (with HLT)/16-bit Timer = 3/4. PIC18(L)F26K83, Window Watchdog Timer (WWDT) Signal Measurement Timer (SMT) = Y Y. PIC18(L)F26K83, CCP/10-bit PWM = 4/4. PIC18(L)F26K83, CWG = 3.",
    "PIC18(L)F25/26K83\nPIC18(L)F26K83, NCO = 1. PIC18(L)F26K83, CLC = 4. PIC18(L)F26K83, Zero-Cross Detect = Y. PIC18(L)F26K83, Direct Memory Access (DMA) Memory Access Partition = 2 Y. PIC18(L)F26K83, Vectored Interrupts = . PIC18(L)F26K83, CAN = Y. PIC18(L)F26K83, UART with Protocols = Y 2. PIC18(L)F26K83, I 2 C/SPI = 2/1. PIC18(L)F26K83, Peripheral Pin Select = Y. PIC18(L)F26K83, Peripheral Module Disable = Y. PIC18(L)F26K83, Debug (1) = I\nNote 1: I - Debugging integrated on chip.\nData Sheet Index:\nA: DS40001943 PIC18(L)F25/26K83 Data Sheet, 28-Pin",
    "PIC18(L)F25/26K83\nNote:\nFor other small form-factor package availability and marking information, visit http://www.microchip.com/packaging or contact your local sales office.",
    "TABLE 2: PACKAGES\nNote 1: Pin details are subject to change.\n\nPIC18(L)F25K83, SPDIP = \uf0b7. PIC18(L)F25K83, SOIC = \uf0b7. PIC18(L)F25K83, SSOP = \uf0b7. PIC18(L)F25K83, UQFN = \uf0b7. PIC18(L)F25K83, QFN = \uf0b7. PIC18(L)F26K83, SPDIP = \uf0b7. PIC18(L)F26K83, SOIC = \uf0b7. PIC18(L)F26K83, SSOP = \uf0b7. PIC18(L)F26K83, UQFN = \uf0b7. PIC18(L)F26K83, QFN = \uf0b7",
    "28-pin QFN (6x6x0.9mm), UQFN (4x4x0.5mm)\nNote 1: See Table 3 for location of all peripheral functions.\n- 2: It is recommended that the exposed bottom pad be connected to VSS, however it must not be the only VSS connection to the device.",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\nRA0, 28-Pin SPDIP/SOIC/SSOP = 2. RA0, 28-Pin (U)QFN = 27. RA0, ADC = ANA0. RA0, Voltage Reference = -. RA0, DAC = -. RA0, Comparators = C1IN0- C2IN0-. RA0, Zero Cross Detect = -. RA0, I 2 C = -. RA0, SPI = -. RA0, UART = -. RA0, DSM = -. RA0, Timers/SMT = -. RA0, CCP and PWM = -. RA0, CWG = -. RA0, CLC = CLCIN0 ( 1 ). RA0, NCO = -. RA0, Clock Reference (CLKR) ECAN = - -. RA0, Interrupt-on Change = IOCA0. RA0, Basic = -. RA1, 28-Pin SPDIP/SOIC/SSOP = 3. RA1, 28-Pin (U)QFN = 28.",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\nRA1, ADC = ANA1. RA1, Voltage Reference = -. RA1, DAC = -. RA1, Comparators = C1IN1- C2IN1-. RA1, Zero Cross Detect = - -. RA1, I 2 C = . RA1, SPI = -. RA1, UART = -. RA1, DSM = -. RA1, Timers/SMT = -. RA1, CCP and PWM = -. RA1, CWG = -. RA1, CLC = CLCIN1 ( 1 ). RA1, NCO = -. RA1, Clock Reference (CLKR) ECAN = - -. RA1, Interrupt-on Change = IOCA1. RA1, Basic = -. RA2, 28-Pin SPDIP/SOIC/SSOP = 4. RA2, 28-Pin (U)QFN = 1. RA2, ADC = ANA2. RA2, Voltage Reference = VREF-. RA2, DAC = DAC1OUT1. RA2,",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\nComparators = C1IN0+ C2IN0+ -. RA2, Zero Cross Detect = -. RA2, I 2 C = . RA2, SPI = -. RA2, UART = -. RA2, DSM = -. RA2, Timers/SMT = -. RA2, CCP and PWM = -. RA2, CWG = -. RA2, CLC = -. RA2, NCO = -. RA2, Clock Reference (CLKR) ECAN = - -. RA2, Interrupt-on Change = IOCA2. RA2, Basic = -. RA3, 28-Pin SPDIP/SOIC/SSOP = 5. RA3, 28-Pin (U)QFN = 2. RA3, ADC = ANA3. RA3, Voltage Reference = VREF+. RA3, DAC = -. RA3, Comparators = C1IN1+ -. RA3, Zero Cross Detect = -. RA3, I 2 C = . RA3, SPI = -.",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\nRA3, UART = -. RA3, DSM = MD1CARL ( 1 ). RA3, Timers/SMT = -. RA3, CCP and PWM = -. RA3, CWG = -. RA3, CLC = -. RA3, NCO = -. RA3, Clock Reference (CLKR) ECAN = - -. RA3, Interrupt-on Change = IOCA3. RA3, Basic = -. RA4, 28-Pin SPDIP/SOIC/SSOP = 6. RA4, 28-Pin (U)QFN = 3. RA4, ADC = ANA4. RA4, Voltage Reference = -. RA4, DAC = -. RA4, Comparators = -. RA4, Zero Cross Detect = - -. RA4, I 2 C = . RA4, SPI = -. RA4, UART = -. RA4, DSM = MD1CARH ( 1 ). RA4, Timers/SMT = T0CKI (1).",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\nRA4, CCP and PWM = -. RA4, CWG = -. RA4, CLC = -. RA4, NCO = -. RA4, Clock Reference (CLKR) ECAN = - -. RA4, Interrupt-on Change = IOCA4. RA4, Basic = -. RA5, 28-Pin SPDIP/SOIC/SSOP = 7. RA5, 28-Pin (U)QFN = 4. RA5, ADC = ANA5. RA5, Voltage Reference = -. RA5, DAC = -. RA5, Comparators = -. RA5, Zero Cross Detect = -. RA5, I 2 C = -. RA5, SPI = SS1 ( 1,3 ). RA5, UART = -. RA5, DSM = MD1SRC ( 1 ). RA5, Timers/SMT = -. RA5, CCP and PWM = -. RA5, CWG = -. RA5, CLC = -. RA5, NCO",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\n= -. RA5, Clock Reference (CLKR) ECAN = - -. RA5, Interrupt-on Change = IOCA5. RA5, Basic = -. RA6, 28-Pin SPDIP/SOIC/SSOP = 10. RA6, 28-Pin (U)QFN = 7. RA6, ADC = ANA6. RA6, Voltage Reference = -. RA6, DAC = -. RA6, Comparators = -. RA6, Zero Cross Detect = -. RA6, I 2 C = -. RA6, SPI = -. RA6, UART = -. RA6, DSM = -. RA6, Timers/SMT = -. RA6, CCP and PWM = -. RA6, CWG = -. RA6, CLC = -. RA6, NCO = -. RA6, Clock Reference (CLKR) ECAN = - -. RA6, Interrupt-on Change = IOCA6. RA6, Basic = OSC2 CLKOUT. RA7,",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\n28-Pin SPDIP/SOIC/SSOP = 9. RA7, 28-Pin (U)QFN = 6. RA7, ADC = ANA7. RA7, Voltage Reference = -. RA7, DAC = -. RA7, Comparators = -. RA7, Zero Cross Detect = -. RA7, I 2 C = -. RA7, SPI = -. RA7, UART = -. RA7, DSM = -. RA7, Timers/SMT = -. RA7, CCP and PWM = -. RA7, CWG = -. RA7, CLC = -. RA7, NCO = -. RA7, Clock Reference (CLKR) ECAN = - -. RA7, Interrupt-on Change = IOCA7. RA7, Basic = OSC1 CLKIN. RB0, 28-Pin SPDIP/SOIC/SSOP = 21. RB0, 28-Pin (U)QFN = 18. RB0, ADC = ANB0.",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\nRB0, Voltage Reference = -. RB0, DAC = -. RB0, Comparators = C2IN1+. RB0, Zero Cross Detect = ZCD. RB0, I 2 C = -. RB0, SPI = -. RB0, UART = -. RB0, DSM = -. RB0, Timers/SMT = -. RB0, CCP and PWM = CCP4 ( 1 ). RB0, CWG = CWG1 ( 1 ). RB0, CLC = -. RB0, NCO = -. RB0, Clock Reference (CLKR) ECAN = - -. RB0, Interrupt-on Change = IOCB0 INT0 ( 1 ). RB0, Basic = -. RB1, 28-Pin SPDIP/SOIC/SSOP = 22. RB1, 28-Pin (U)QFN = 19. RB1, ADC = ANB1. RB1, Voltage Reference = -. RB1, DAC = -. RB1, Comparators =",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\nC1IN3- C2IN3-. RB1, Zero Cross Detect = -. RB1, I 2 C = SCL2 ( 1,3,4 ). RB1, SPI = -. RB1, UART = -. RB1, DSM = -. RB1, Timers/SMT = -. RB1, CCP and PWM = -. RB1, CWG = CWG2 ( 1 ). RB1, CLC = -. RB1, NCO = -. RB1, Clock Reference (CLKR) ECAN = - -. RB1, Interrupt-on Change = IOCB1 INT1 ( 1 ). RB1, Basic = -. RB2, 28-Pin SPDIP/SOIC/SSOP = 23. RB2, 28-Pin (U)QFN = 20. RB2, ADC = ANB2. RB2, Voltage Reference = -. RB2, DAC = -. RB2, Comparators = -. RB2, Zero Cross Detect = - SDA2 (",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\n1,3,4. RB2, I 2 C = ). RB2, SPI = -. RB2, UART = -. RB2, DSM = -. RB2, Timers/SMT = -. RB2, CCP and PWM = -. RB2, CWG = CWG3 ( 1 ). RB2, CLC = -. RB2, NCO = -. RB2, Clock Reference (CLKR) ECAN = - -. RB2, Interrupt-on Change = IOCB2 INT2 ( 1 ). RB2, Basic = -. RB3, 28-Pin SPDIP/SOIC/SSOP = 24. RB3, 28-Pin (U)QFN = 21. RB3, ADC = ANB3. RB3, Voltage Reference = -. RB3, DAC = -. RB3, Comparators = C1IN2- C2IN2-. RB3, Zero Cross Detect = -. RB3, I 2 C = -. RB3, SPI = -. RB3,",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\nUART = -. RB3, DSM = -. RB3, Timers/SMT = -. RB3, CCP and PWM = -. RB3, CWG = -. RB3, CLC = -. RB3, NCO = -. RB3, Clock Reference (CLKR) ECAN = - CANRX 1 ). RB3, Interrupt-on Change = IOCB3. RB3, Basic = -. RB4, 28-Pin SPDIP/SOIC/SSOP = 25. RB4, 28-Pin (U)QFN = 22. RB4, ADC = ANB4 ADACT ( 1 ). RB4, Voltage Reference = -. RB4, DAC = -. RB4, Comparators = -. RB4, Zero Cross Detect = - -. RB4, I 2 C = . RB4, SPI = -. RB4, UART = -. RB4, DSM = -. RB4, Timers/SMT = T5G ( 1 ) SMT2WIN ( 1",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\n). RB4, CCP and PWM = -. RB4, CWG = -. RB4, CLC = CLCIN2( 1 ). RB4, NCO = -. RB4, Clock Reference (CLKR) ECAN = - -. RB4, Interrupt-on Change = IOCB4. RB4, Basic = -. RB5, 28-Pin SPDIP/SOIC/SSOP = 26. RB5, 28-Pin (U)QFN = 23. RB5, ADC = ANB5. RB5, Voltage Reference = -. RB5, DAC = -. RB5, Comparators = -. RB5, Zero Cross Detect = - -. RB5, I 2 C = . RB5, SPI = -. RB5, UART = -. RB5, DSM = -. RB5, Timers/SMT = T1G ( 1 ) SMT2SIG ( 1 ). RB5, CCP and PWM = CCP3 ( 1 ). RB5, CWG =",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\n-. RB5, CLC = CLCIN3 ( 1 ). RB5, NCO = -. RB5, Clock Reference (CLKR) ECAN = - -. RB5, Interrupt-on Change = IOCB5. RB5, Basic = -. RB6, 28-Pin SPDIP/SOIC/SSOP = 27. RB6, 28-Pin (U)QFN = 24. RB6, ADC = ANB6. RB6, Voltage Reference = -. RB6, DAC = -. RB6, Comparators = -. RB6, Zero Cross Detect = - -. RB6, I 2 C = . RB6, SPI = -. RB6, UART = CTS2 ( 1 ). RB6, DSM = -. RB6, Timers/SMT = -. RB6, CCP and PWM = -. RB6, CWG = -. RB6, CLC = -. RB6, NCO = -. RB6, Clock Reference (CLKR) ECAN = - -.",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\nRB6, Interrupt-on Change = IOCB6. RB6, Basic = ICSPCLK. RB7 RC0, 28-Pin SPDIP/SOIC/SSOP = 28. RB7 RC0, 28-Pin (U)QFN = 25. RB7 RC0, ADC = ANB7. RB7 RC0, Voltage Reference = -. RB7 RC0, DAC = DAC1OUT2 -. RB7 RC0, Comparators = -. RB7 RC0, Zero Cross Detect = -. RB7 RC0, I 2 C = -. RB7 RC0, SPI = -. RB7 RC0, UART = RX2 ( 1 ). RB7 RC0, DSM = -. RB7 RC0, Timers/SMT = T6IN ( 1 ). RB7 RC0, CCP and PWM = -. RB7 RC0, CWG = -. RB7 RC0, CLC = - -. RB7 RC0, NCO = - -. RB7 RC0, Clock Reference",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\n(CLKR) ECAN = - - - -. RB7 RC0, Interrupt-on Change = IOCB7. RB7 RC0, Basic = ICSPDAT SOSCO. , 28-Pin SPDIP/SOIC/SSOP = 11. , 28-Pin (U)QFN = 8. , ADC = ANC0. , Voltage Reference = -. , DAC = . , Comparators = -. , Zero Cross Detect = -. , I 2 C = -. , SPI = -. , UART = -. , DSM = -. , Timers/SMT = T1CKI ( 1 ) T3CKI ( 1 ) T3G ( 1 ) SMT1WIN ( 1 ). , CCP and PWM = -. , CWG = -. , CLC = . , NCO = . , Clock Reference (CLKR) ECAN = . , Interrupt-on Change = IOCC0. , Basic = . RC1, 28-Pin SPDIP/SOIC/SSOP = 12. RC1, 28-Pin",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\n(U)QFN = 9. RC1, ADC = ANC1. RC1, Voltage Reference = -. RC1, DAC = -. RC1, Comparators = -. RC1, Zero Cross Detect = . RC1, I 2 C = -. RC1, SPI = -. RC1, UART = -. RC1, DSM = -. RC1, Timers/SMT = SMT1SIG ( 1 ). RC1, CCP and PWM = CCP2 ( 1 ). RC1, CWG = -. RC1, CLC = -. RC1, NCO = -. RC1, Clock Reference (CLKR) ECAN = - -. RC1, Interrupt-on Change = IOCC1. RC1, Basic = SOSCI. RC2, 28-Pin SPDIP/SOIC/SSOP = 13. RC2, 28-Pin (U)QFN = 10. RC2, ADC = ANC2. RC2, Voltage Reference = -. RC2,",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\nDAC = -. RC2, Comparators = -. RC2, Zero Cross Detect = - -. RC2, I 2 C = -. RC2, SPI = -. RC2, UART = -. RC2, DSM = -. RC2, Timers/SMT = T5CKI ( 1 ). RC2, CCP and PWM = CCP1 ( 1 ). RC2, CWG = -. RC2, CLC = -. RC2, NCO = -. RC2, Clock Reference (CLKR) ECAN = - - -. RC2, Interrupt-on Change = IOCC2. RC2, Basic = -. RC3, 28-Pin SPDIP/SOIC/SSOP = 14. RC3, 28-Pin (U)QFN = 11. RC3, ADC = ANC3. RC3, Voltage Reference = -. RC3, DAC = -. RC3, Comparators = -. RC3, Zero Cross Detect = -. RC3, I 2 C =",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\nSCL1 ( 1 ). RC3, SPI = SCK1 ( 1,3 ). RC3, UART = -. RC3, DSM = -. RC3, Timers/SMT = T2IN ( 1 ). RC3, CCP and PWM = -. RC3, CWG = -. RC3, CLC = -. RC3, NCO = -. RC3, Clock Reference (CLKR) ECAN = -. RC3, Interrupt-on Change = IOCC3. RC3, Basic = -\nNote",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83)\n1: This is a PPS remappable input signal. The input function may be moved from the default location shown to one of several other PORTx pins.\n2: All output signals shown in this row are PPS remappable.\n3: This is a bidirectional signal. For normal module operation, the firmware should map this signal to the same pin in both the PPS input and PPS output registers.\n4: These pins can be configured for I C and SMBTM 3.0/2.0 logic levels; the SCLx/SDAx signals may be assigned to any of the RB1/RB2/RC3/RC4 pins. PPS assignments to the other pins (e.g., RA5) will operate, but input logic levels 2 will be standard TTL/ST as selected by the INLVL register, instead of the I 2 C specific or SMBUS input buffer thresholds.",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83) (CONTINUED)\nRC4, 28-Pin SPDIP/SOIC/SSOP = 15. RC4, 28-Pin (U)QFN = 12. RC4, ADC = ANC4. RC4, Voltage Reference = -. RC4, DAC = -. RC4, Comparators = - -. RC4, Zero Cross Detect = SDA1 ( 1 ). RC4, I 2 C = SDI1 ( 1. RC4, SPI = ). RC4, UART = -. RC4, DSM = - -. RC4, Timers/SMT = -. RC4, CCP and PWM = -. RC4, CWG = -. RC4, CLC = -. RC4, NCO = -. RC4, Clock Reference (CLKR) = -. RC4, ECAN Interrupt-on Change = IOCC4. RC4, Basic = -. RC5, 28-Pin SPDIP/SOIC/SSOP = 16. RC5, 28-Pin (U)QFN = 13.",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83) (CONTINUED)\nRC5, ADC = ANC5. RC5, Voltage Reference = -. RC5, DAC = -. RC5, Comparators = - -. RC5, Zero Cross Detect = -. RC5, I 2 C = -. RC5, SPI = -. RC5, UART = -. RC5, DSM = T4IN ( 1 ). RC5, Timers/SMT = -. RC5, CCP and PWM = -. RC5, CWG = -. RC5, CLC = -. RC5, NCO = -. RC5, Clock Reference (CLKR) = -. RC5, ECAN Interrupt-on Change = IOCC5. RC5, Basic = -. RC6, 28-Pin SPDIP/SOIC/SSOP = 17. RC6, 28-Pin (U)QFN = 14. RC6, ADC = ANC6. RC6, Voltage Reference = -. RC6, DAC = -. RC6, Comparators = - -.",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83) (CONTINUED)\nRC6, Zero Cross Detect = -. RC6, I 2 C = . RC6, SPI = - CTS1. RC6, UART = ( 1 ) -. RC6, DSM = -. RC6, Timers/SMT = -. RC6, CCP and PWM = -. RC6, CWG = -. RC6, CLC = -. RC6, NCO = -. RC6, Clock Reference (CLKR) = -. RC6, ECAN Interrupt-on Change = IOCC6. RC6, Basic = -. RC7, 28-Pin SPDIP/SOIC/SSOP = 18. RC7, 28-Pin (U)QFN = 15. RC7, ADC = ANC7. RC7, Voltage Reference = -. RC7, DAC = -. RC7, Comparators = - -. RC7, Zero Cross Detect = -. RC7, I 2 C = -. RC7, SPI = RX1 (. RC7, UART = 1",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83) (CONTINUED)\n) -. RC7, DSM = -. RC7, Timers/SMT = -. RC7, CCP and PWM = -. RC7, CWG = -. RC7, CLC = -. RC7, NCO = -. RC7, Clock Reference (CLKR) = -. RC7, ECAN Interrupt-on Change = IOCC7. RC7, Basic = -. RE3, 28-Pin SPDIP/SOIC/SSOP = 1. RE3, 28-Pin (U)QFN = 26. RE3, ADC = -. RE3, Voltage Reference = -. RE3, DAC = -. RE3, Comparators = - -. RE3, Zero Cross Detect = -. RE3, I 2 C = -. RE3, SPI = -. RE3, UART = -. RE3, DSM = -. RE3, Timers/SMT = -. RE3, CCP and PWM = -. RE3, CWG = -.",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83) (CONTINUED)\nRE3, CLC = -. RE3, NCO = -. RE3, Clock Reference (CLKR) = -. RE3, ECAN Interrupt-on Change = IOCE3. RE3, Basic = MCLR VPP. VDD, 28-Pin SPDIP/SOIC/SSOP = 20. VDD, 28-Pin (U)QFN = 17. VDD, ADC = -. VDD, Voltage Reference = -. VDD, DAC = -. VDD, Comparators = - -. VDD, Zero Cross Detect = -. VDD, I 2 C = -. VDD, SPI = -. VDD, UART = -. VDD, DSM = -. VDD, Timers/SMT = -. VDD, CCP and PWM = -. VDD, CWG = -. VDD, CLC = -. VDD, NCO = -. VDD, Clock Reference (CLKR) = -. VDD, ECAN Interrupt-on Change = -.",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83) (CONTINUED)\nVDD, Basic = -. VSS, 28-Pin SPDIP/SOIC/SSOP = 8, 19. VSS, 28-Pin (U)QFN = 5, 16. VSS, ADC = -. VSS, Voltage Reference = -. VSS, DAC = -. VSS, Comparators = - -. VSS, Zero Cross Detect = -. VSS, I 2 C = -. VSS, SPI = -. VSS, UART = -. VSS, DSM = -. VSS, Timers/SMT = -. VSS, CCP and PWM = -. VSS, CWG = -. VSS, CLC = -. VSS, NCO = -. VSS, Clock Reference (CLKR) = -. VSS, ECAN Interrupt-on Change = -. VSS, Basic = -. OUT ( 2 ), 28-Pin SPDIP/SOIC/SSOP = -. OUT ( 2 ), 28-Pin (U)QFN =",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83) (CONTINUED)\n-. OUT ( 2 ), ADC = ADGRDA ADGRDB. OUT ( 2 ), Voltage Reference = -. OUT ( 2 ), DAC = - C1OUT C2OUT. OUT ( 2 ), Comparators = -. OUT ( 2 ), Zero Cross Detect = SDA1 SCL1 SDA2 SCL2. OUT ( 2 ), I 2 C = SS1 SCK1 SDO1. OUT ( 2 ), SPI = DTR1 RTS1 TX1 DTR2 RTS2 TX2. OUT ( 2 ), UART = DSM. OUT ( 2 ), DSM = TMR0. OUT ( 2 ), Timers/SMT = CCP1 CCP2 CCP3 CCP4 PWM5OUT PWM6OUT PWM7OUT PWM8OUT. OUT ( 2 ), CCP and PWM = CWG1A CWG1B CWG1C CWG1D CWG2A CWG2B CWG2C CWG2D",
    "TABLE 3: 28-PIN ALLOCATION TABLE (PIC18(L)F25/26K83) (CONTINUED)\nCWG3A CWG3B CWG3C CWG3D. OUT ( 2 ), CWG = CLC1OUT CLC2OUT CLC3OUT CLC4OUT. OUT ( 2 ), CLC = NCO. OUT ( 2 ), NCO = CLKR. OUT ( 2 ), Clock Reference (CLKR) = CANTX. OUT ( 2 ), ECAN Interrupt-on Change = -. OUT ( 2 ), Basic = -",
    "Note\n1: This is a PPS remappable input signal. The input function may be moved from the default location shown to one of several other PORTx pins.\n2: All output signals shown in this row are PPS remappable.\n3: This is a bidirectional signal. For normal module operation, the firmware should map this signal to the same pin in both the PPS input and PPS output registers.\n4: These pins can be configured for I C and SMBTM 3.0/2.0 logic levels; the SCLx/SDAx signals may be assigned to any of the RB1/RB2/RC3/RC4 pins. PPS assignments to the other pins (e.g., RA5) will operate, but input logic levels 2 will be standard TTL/ST as selected by the INLVL register, instead of the I 2 C specific or SMBUS input buffer thresholds.",
    "Table of Contents\n1.0, 1 = Device Overview ......................................................................................................................................................................... 1.0, 2 = 10. 2.0, 1 = Guidelines for Getting Started with PIC18(L)F25/26K83 Microcontrollers",
    "Table of Contents\n.................................................................................. 2.0, 2 = 13. 3.0, 1 = PIC18",
    "Table of Contents\nCPU.................................................................................................................................................................................. 3.0, 2 = 16. 4.0, 1 = Memory",
    "Table of Contents\nOrganization.................................................................................................................................................................. 4.0, 2 = 23. 5.0, 1 = Device",
    "Table of Contents\nConfiguration................................................................................................................................................................... 5.0, 2 = 55. 6.0, 1 = Resets. 6.0, 2 =",
    "Table of Contents\n........................................................................................................................................................................................ 71. 7.0, 1 = Oscillator Module (with Fail-Safe Clock Monitor)",
    "Table of Contents\n........................................................................................................................ 7.0, 2 = 82. 8.0, 1 = Reference Clock Output Module",
    "Table of Contents\n............................................................................................................................................... 8.0, 2 = 101. 9.0, 1 = Interrupt Controller",
    "Table of Contents\n.................................................................................................................................................................... 9.0, 2 = 105. 10.0, 1 = Power-Saving Operation Modes",
    "Table of Contents\n............................................................................................................................................... 10.0, 2 = 161. 11.0, 1 = Windowed Watchdog Timer",
    "Table of Contents\n(WWDT)....................................................................................................................................... 11.0, 2 = 168. 12.0, 1 = 8x8 Hardware",
    "Table of Contents\nMultiplier............................................................................................................................................................. 12.0, 2 = 177. 13.0, 1 = Nonvolatile Memory (NVM)",
    "Table of Contents\nControl........................................................................................................................................... 13.0, 2 = 179. 14.0, 1 = Cyclic Redundancy Check (CRC) Module with Memory",
    "Table of Contents\nScanner............................................................................................. 14.0, 2 = 203. 15.0, 1 = Direct Memory Access",
    "Table of Contents\n(DMA)................................................................................................................................................... 15.0, 2 = 218. 16.0 I/O Ports, 1 =",
    "Table of Contents\n.................................................................................................................................................................................... 16.0 I/O Ports, 2 = 250. 17.0, 1 = Peripheral Pin Select (PPS) Module",
    "Table of Contents\n......................................................................................................................................... 17.0, 2 = 263. 18.0, 1 =",
    "Table of Contents\nInterrupt-on-Change.................................................................................................................................................................. 18.0, 2 = 271. 19.0, 1 = Peripheral Module Disable",
    "Table of Contents\n(PMD)............................................................................................................................................. 19.0, 2 = 275. 20.0, 1 = Timer0 Module",
    "Table of Contents\n.......................................................................................................................................................................... 20.0, 2 = 284. 21.0, 1 = Timer1/3/5 Module with Gate",
    "Table of Contents\nControl........................................................................................................................................ 21.0, 2 = 290. 22.0, 1 = Timer2/4/6 Module",
    "Table of Contents\n.................................................................................................................................................................... 22.0, 2 = 305. 24.0, 1 = Pulse-Width Modulation",
    "Table of Contents\n(PWM)................................................................................................................................................ 24.0, 2 = 341. 25.0, 1 = Signal Measurement Timer",
    "Table of Contents\n(SMTX).......................................................................................................................................... 25.0, 2 = 348. 26.0, 1 = Complementary Waveform Generator (CWG) Module",
    "Table of Contents\n............................................................................................................. 26.0, 2 = 392. 27.0, 1 = Configurable Logic Cell",
    "Table of Contents\n(CLC)................................................................................................................................................... 27.0, 2 = 420. 28.0, 1 = Numerically Controlled Oscillator (NCO)",
    "Table of Contents\nModule...................................................................................................................... 28.0, 2 = 435. 29.0, 1 = Zero-Cross Detection (ZCD)",
    "Table of Contents\nModule......................................................................................................................................... 29.0, 2 = 445. 30.0, 1 = Data Signal Modulator (DSM)",
    "Table of Contents\nModule....................................................................................................................................... 30.0, 2 = 450. 31.0, 1 = Universal Asynchronous Receiver Transmitter (UART) With Protocol Support........................................................................ 31.0, 2 = 461. 32.0, 1 = Serial",
    "Table of Contents\nPeripheral Interface (SPI) Module................................................................................................................................... 32.0, 2 = 498. 33.0, 1 = I2C",
    "Table of Contents\nModule................................................................................................................................................................................ 33.0, 2 = 530. 34.0, 1 = CAN",
    "Table of Contents\nModule.............................................................................................................................................................................. 34.0, 2 = 583. 35.0, 1 = Fixed Voltage Reference (FVR)",
    "Table of Contents\n............................................................................................................................................... 35.0, 2 = 650. 36.0, 1 = Temperature Indicator Module",
    "Table of Contents\n.................................................................................................................................................. 36.0, 2 = 652. 37.0, 1 = Analog-to-Digital Converter with Computation (ADC2) Module",
    "Table of Contents\n................................................................................................ 37.0, 2 = 654. 38.0, 1 = 5-Bit Digital-to-Analog Converter (DAC) Module....................................................................................................................... 38.0, 2 =",
    "Table of Contents\n692. 39.0, 1 = Comparator Module .................................................................................................................................................................. 39.0, 2 = 696. 40.0, 1 = High/Low-Voltage Detect",
    "Table of Contents\n(HLVD).............................................................................................................................................. 40.0, 2 = 705. 41.0, 1 = In-Circuit Serial Programming\u2122 (ICSP\u2122)",
    "Table of Contents\n................................................................................................................................ 41.0, 2 = 713. 42.0, 1 = Instruction Set",
    "Table of Contents\nSummary........................................................................................................................................................... 42.0, 2 = 715. 43.0, 1 = Register",
    "Table of Contents\nSummary..................................................................................................................................................................... 43.0, 2 = 769. 44.0, 1 = Development",
    "Table of Contents\nSupport................................................................................................................................................................ 44.0, 2 = 790. 45.0, 1 = Electrical",
    "Table of Contents\nSpecifications............................................................................................................................................................. 45.0, 2 = 794. 46.0, 1 = DC and AC Characteristics Graphs and",
    "Table of Contents\nTables........................................................................................................................ 46.0, 2 = 825. 47.0, 1 = Packaging",
    "Table of Contents\nInformation............................................................................................................................................................... 47.0, 2 = 826. The, 1 = Microchip Website",
    "Table of Contents\n...................................................................................................................................................................... The, 2 = 841. Customer Change Notification Service",
    "Table of Contents\n............................................................................................................................................., 1 = Customer Change Notification Service",
    "Table of Contents\n.............................................................................................................................................. Customer Change Notification Service",
    "Table of Contents\n............................................................................................................................................., 2 = 841. Customer Support, 1 =",
    "Table of Contents\n............................................................................................................................................................................. Product Identification System",
    "Table of Contents\n............................................................................................................................................................ Customer Support, 2 = 841 842",
    "TO OUR VALUED CUSTOMERS\nIt is our intention to provide our valued customers with the best documentation possible to ensure successful use of your Microchip products. To this end, we will continue to improve our publications to better suit your needs. Our publications will be refined and enhanced as new volumes and updates are introduced.\nIf you have any questions or comments regarding this publication, please contact the Marketing Communications Department via E-mail at docerrors@microchip.com . We welcome your feedback.",
    "Most Current Data Sheet\nTo obtain the most up-to-date version of this data sheet, please register at our Worldwide Website at:",
    "http://www.microchip.com\nYou can determine the version of a data sheet by examining its literature number found on the bottom outside corner of any page. The last character of the literature number is the version number, (e.g., DS30000000A is version A of document DS30000000).",
    "Errata\nAn errata sheet, describing minor operational differences from the data sheet and recommended workarounds, may exist for current devices. As device/documentation issues become known to us, we will publish an errata sheet. The errata will specify the revision of silicon and revision of document to which it applies.\nTo determine if an errata sheet exists for a particular device, please check with one of the following:\n\u00b7 Microchip's Worldwide Website; http://www.microchip.com\n\u00b7 Your local Microchip sales office (see last page)\nWhen contacting a sales office, please specify which device, revision of silicon and data sheet (include literature number) you are using.",
    "Customer Notification System\nRegister on our website at www.microchip.com to receive the most current information on all of our products.",
    "1.0 DEVICE OVERVIEW\nThis document contains device specific information for the following devices:\n\u2022 PIC18F25K83\n\u2022 PIC18LF25K83\n\u2022 PIC18F26K83\n\u2022 PIC18LF26K83\nThis family offers the advantages of all PIC18 microcontrollers - namely, high computational performance at an economical price - with the addition of high-endurance Program Flash Memory, Universal Asynchronous Receiver Transmitter (UART), Serial Peripheral Interface (SPI), Inter-integrated Circuit (I 2 C), Direct Memory Access (DMA), Configurable Logic Cells (CLC), Signal Measurement Timer (SMT), Numerically Controlled Oscillator (NCO), and Analog-to-Digital Converter with Computation (ADC 2 ).",
    "1.1 New Features\n\u00b7 Direct Memory Access Controller: The Direct Memory Access (DMA) Controller is designed to service data transfers between different memory regions directly without intervention from the CPU. By eliminating the need for CPU-intensive management of handling interrupts intended for data transfers, the CPU now can spend more time on other tasks.\n\u00b7 Vectored Interrupt Controller: The Vectored Interrupt Controller module reduces the numerous peripheral interrupt request signals to a single interrupt request signal to the CPU. It assembles all of the interrupt request signals and resolves the interrupts based on both a fixed natural order priority and a user-assigned priority, thereby eliminating scanning of interrupt sources.\n\u00b7 Universal Asynchronous Receiver Transmitter: The Universal Asynchronous Receiver Transmitter (UART) module is a serial I/O communications peripheral. It contains all the clock generators, shift registers and data buffers necessary to perform an input or output serial data transfer, independent of device program execution. The UART can be configured as a full-duplex asynchronous system or one of several automated protocols. Full-Duplex mode is useful for communications with peripheral systems, with DMX/DALI/LIN support.",
    "1.1 New Features\n\u00b7 Serial Peripheral Interface: The Serial Periph -eral Interface (SPI) module is a synchronous serial data communication bus that operates in Full-Duplex mode. Devices communicate in a master/slave environment where the master device initiates the communication. A slave device is controlled through a Chip Select known as Slave Select. Example slave devices include serial EEPROMs, shift registers, display drivers, A/D converters, or another PIC \u00ae  device.\n\u00b7 I 2 C Module: The I 2 C module provides a synchro -nous interface between the microcontroller and other I 2 C-compatible devices using the two-wire I 2 C serial bus. Devices communicate in a mas -ter/slave environment. The I 2 C bus specifies two signal connections - Serial Clock (SCL) and Serial Data (SDA). Both the SCL and SDA con -nections are bidirectional open-drain lines, each requiring pull-up resistors to the supply voltage.",
    "1.1 New Features\n\u00b7 12-bit A/D Converter with Computation: This module incorporates programmable acquisition time, allowing for a channel to be selected and a conversion to be initiated without waiting for a sampling period and thus, reduce code overhead. It has a new module called ADC 2  with computation features, which provides a digital filter and threshold interrupt functions.",
    "1.2 Details on Individual Family Members\nDevices in the PIC18(L)F25/26K83 family are available in 28-pin packages. The block diagram for this device is shown in Figure 3-1.\nThe similarities and differences among the devices are listed  in  the  PIC18(L)F25/26K83  Family  Types  Table (page  4).  The  pinouts  for  all  devices  are  listed  in Table 3.\n\nTABLE 1-1: DEVICE FEATURES",
    "1.2 Details on Individual Family Members\nProgram Memory (Bytes), PIC18(L)F25K83 = 32768. Program Memory (Bytes), PIC18(L)F26K83 = 65536. Program Memory (Instructions), PIC18(L)F25K83 = 16384. Program Memory (Instructions), PIC18(L)F26K83 = 32768. Data Memory (Bytes), PIC18(L)F25K83 = 2048. Data Memory (Bytes), PIC18(L)F26K83 = 4096. Data EEPROM Memory (Bytes), PIC18(L)F25K83 = 1024. Data EEPROM Memory (Bytes), PIC18(L)F26K83 = 1024. Packages, PIC18(L)F25K83 = 28-pin SPDIP 28-pin SOIC 28-pin SSOP 28-pin QFN 28-pin UQFN. Packages, PIC18(L)F26K83 = 28-pin SPDIP 28-pin SOIC 28-pin SSOP 28-pin QFN",
    "1.2 Details on Individual Family Members\n28-pin UQFN. I/O Ports, PIC18(L)F25K83 = A,B,C,E (1). I/O Ports, PIC18(L)F26K83 = A,B,C,E (1). 12-Bit Analog-to-Digital Conversion Module (ADC 2 ) with Computation Accelerator, PIC18(L)F25K83 = 5 internal 24 external. 12-Bit Analog-to-Digital Conversion Module (ADC 2 ) with Computation Accelerator, PIC18(L)F26K83 = 5 internal 24 external. Capture/Compare/PWM Modules (CCP), PIC18(L)F25K83 = 4. Capture/Compare/PWM Modules (CCP), PIC18(L)F26K83 = 4. 10-Bit Pulse-Width Modulator (PWM), PIC18(L)F25K83 = 4. 10-Bit Pulse-Width Modulator (PWM), PIC18(L)F26K83 = 4. Timers",
    "1.2 Details on Individual Family Members\n(16-/8-bit), PIC18(L)F25K83 = 4/3. Timers (16-/8-bit), PIC18(L)F26K83 = 4/3. Serial Communications, PIC18(L)F25K83 = 2 UARTs with DMX/DALI/LIN, 2 I 2 C, 1 SPI. Serial Communications, PIC18(L)F26K83 = 2 UARTs with DMX/DALI/LIN, 2 I 2 C, 1 SPI. Complementary Waveform Generator (CWG), PIC18(L)F25K83 = 3. Complementary Waveform Generator (CWG), PIC18(L)F26K83 = 3. Zero-Cross Detect (ZCD), PIC18(L)F25K83 = 1. Zero-Cross Detect (ZCD), PIC18(L)F26K83 = 1. Data Signal Modulator (DSM), PIC18(L)F25K83 = 1. Data Signal Modulator (DSM), PIC18(L)F26K83 =",
    "1.2 Details on Individual Family Members\n1. Signal Measurement Timer (SMT), PIC18(L)F25K83 = 2. Signal Measurement Timer (SMT), PIC18(L)F26K83 = 2. 5-bit Digital to Analog Converter (DAC), PIC18(L)F25K83 = 1. 5-bit Digital to Analog Converter (DAC), PIC18(L)F26K83 = 1. Numerically Controlled Oscillator (NCO), PIC18(L)F25K83 = 1. Numerically Controlled Oscillator (NCO), PIC18(L)F26K83 = 1. Comparator Module, PIC18(L)F25K83 = 2. Comparator Module, PIC18(L)F26K83 = 2. Direct Memory Access (DMA), PIC18(L)F25K83 = 2. Direct Memory Access (DMA), PIC18(L)F26K83 = 2. Configurable Logic Cell (CLC), PIC18(L)F25K83 = 4.",
    "1.2 Details on Individual Family Members\nConfigurable Logic Cell (CLC), PIC18(L)F26K83 = 4. Control Area Network (CAN), PIC18(L)F25K83 = Yes. Control Area Network (CAN), PIC18(L)F26K83 = Yes. Peripheral Module Disable (PMD), PIC18(L)F25K83 = Yes. Peripheral Module Disable (PMD), PIC18(L)F26K83 = Yes. 16-bit CRC with Scanner, PIC18(L)F25K83 = Yes. 16-bit CRC with Scanner, PIC18(L)F26K83 = Yes. Programmable High/Low - Voltage Detect (HLVD), PIC18(L)F25K83 = Yes. Programmable High/Low - Voltage Detect (HLVD), PIC18(L)F26K83 = Yes. Resets (and Delays), PIC18(L)F25K83 = POR, Programmable BOR, RESET Instruction, Stack Overflow, Stack Underflow (PWRT, OST),",
    "1.2 Details on Individual Family Members\nMCLR, WDT, MEMV. Resets (and Delays), PIC18(L)F26K83 = POR, Programmable BOR, RESET Instruction, Stack Overflow, Stack Underflow (PWRT, OST), MCLR, WDT, MEMV. Instruction Set, PIC18(L)F25K83 = 81 Instructions; 87 with Extended Instruction Set enabled. Instruction Set, PIC18(L)F26K83 = 81 Instructions; 87 with Extended Instruction Set enabled. Maximum Operating Frequency, PIC18(L)F25K83 = 64 MHz. Maximum Operating Frequency, PIC18(L)F26K83 = 64 MHz\nNote 1: PORTE contains the single RE3 input-only pin.",
    "1.3.1 REGISTER NAMES\nWhen  there are multiple instances of the same peripheral in a device, the peripheral control registers will  be  depicted as  the concatenation of a peripheral identifier,  peripheral  instance,  and  control  identifier. The  control registers section will show  just one instance of all the register names with an 'x' in the place of the peripheral instance number.  This naming convention may also be applied to peripherals when there  is  only  one  instance  of  that  peripheral  in  the device to maintain compatibility with other devices in the family that contain more than one.",
    "1.3.2 BIT NAMES\nThere are two variants for bit names:\n\u00b7 Short name: Bit function abbreviation\n\u00b7 Long name: Peripheral abbreviation + short name",
    "1.3.2.1 Short Bit Names\nShort bit names are an abbreviation for the bit function. For example, some peripherals are enabled with the EN bit. The bit names shown in the registers are the short name variant.\nShort bit names are useful when accessing bits in C programs. The general format for accessing bits by the short name is RegisterName bits. ShortName . For example, the enable bit, EN, in the T0CON0 register can be set in C programs with the instruction T0CON0bits.EN = 1 .\nShort  names  are  generally  not  useful  in  assembly programs because the same name may be used by different peripherals in different bit positions. When this occurs, during the include file generation, all instances of that short bit name are appended with an underscore plus the name of the register in which the bit resides to avoid naming contentions.",
    "1.3.2.2 Long Bit Names\nLong bit names are constructed by adding a peripheral abbreviation  prefix  to  the  short  name.  The  prefix  is unique to the peripheral thereby making every long bit name unique. The long bit name for the Timer0 enable bit is the Timer0 prefix, T0, appended with the enable bit  short  name,  EN,  resulting  in  the  unique  bit  name T0EN.\nLong bit names are useful in both C and assembly pro -grams. For example, in C the T0CON0 enable bit can be set with the T0EN = 1 instruction. In assembly, this bit can be set with the BSF T0CON0,T0EN instruction.\n1.3.2.3",
    "Bit Fields\nBit  fields  are  two  or  more  adjacent  bits  in  the  same register. For example, the four Least Significant bits of the  T0CON0  register  contain  the  output  prescaler select bits. The short name for this field is OUTPS and the  long  name  is  T0OUTPS.  Bit  field  access  is  only possible in C programs. The following example demonstrates a C program instruction for setting the Timer0 output prescaler to the 1:6 Postscaler:\nT0CON0bits.OUTPS = 0x5;\nIndividual bits in a bit field can also be accessed with long and short bit names. Each bit is the field name appended with the number of the bit position within the field. For example, the Most Significant mode bit has the short bit name OUTPS3. The following two exam -ples  demonstrate  assembly  program  sequences  for setting the Timer0 output prescaler to 1:6 Postscaler:",
    "Example 1:\nMOVLW  ~(1<<OUTPS3 | 1<<OUTPS1)\nANDWF  T0CON0,F\nMOVLW  1<<OUTPS2 | 1<<OUTPS0\nIORWF  T0CON0,F",
    "Example 2:\nBCF    T0CON0,OUTPS3\nBSF    T0CON0,OUTPS2\nBCF    T0CON0,OUTPS1\nBSF    T0CON0,OUTPS0",
    "1.3.3.1 Status, Interrupt, and Mirror Bits\nStatus, interrupt enables, interrupt flags, and mirror bits are  contained  in  registers  that  span  more  than  one peripheral.  In  these  cases,  the  bit  name  shown  is unique so there is no prefix or short name variant.",
    "2.1 Basic Connection Requirements\nGetting started with the PIC18(L)F25/26K83 family of 8-bit  microcontrollers  requires  attention  to  a  minimal set of device pin connections before proceeding with development.\nThe following pins must always be connected:\n\u00b7 All VDD and VSS pins (see Section 2.2 'Power Supply Pins' )\n\u00b7 MCLR pin (see Section 2.3 'Master Clear (MCLR) Pin' )\nThese pins must also be connected if they are being used in the end application:\n\u00b7 ICSPCLK/ICSPDAT pins used for In-Circuit Serial Programming\u2122 (ICSP\u2122) and debugging purposes (see Section 2.4 'ICSP\u2122 Pins' )\n\u00b7 OSCI and OSCO pins when an external oscillator source is used (see Section 2.5 'External Oscillator Pins' )\nAdditionally, the following pins may be required:\n- \u00b7 VREF+/VREF- pins are used when external voltage reference for analog modules is implemented\nThe  minimum  mandatory  connections  are  shown  in Figure 2-1.",
    "2.2.1 DECOUPLING CAPACITORS\nThe  use  of  decoupling  capacitors  on  every  pair  of power supply pins (VDD and VSS) is required.\nConsider the following criteria when using decoupling capacitors:\n\u00b7 Value and type of capacitor: A 0.1 \uf06d F (100 nF), 10-20V capacitor is recommended. The capacitor should be a low-ESR device, with a resonance frequency in the range of 200 MHz and higher. Ceramic capacitors are recommended.\n\u00b7 Placement on the printed circuit board: The decoupling capacitors should be placed as close to the pins as possible. It is recommended to place the capacitors on the same side of the board as the device. If space is constricted, the capacitor can be placed on another layer on the PCB using a via; however, ensure that the trace length from the pin to the capacitor is no greater than 0.25 inch (6 mm).",
    "2.2.1 DECOUPLING CAPACITORS\n\u00b7 Handling high-frequency noise: If the board is experiencing high-frequency noise (upward of tens of MHz), add a second ceramic type capaci -tor in parallel to the above described decoupling capacitor. The value of the second capacitor can be in the range of 0.01 \uf06d F to 0.001 \uf06d F. Place this second capacitor next to each primary decoupling capacitor. In high-speed circuit designs, consider implementing a decade pair of capacitances as close to the power and ground pins as possible (e.g., 0.1 \uf06d F in parallel with 0.001 \uf06d F).\n\u00b7 Maximizing performance: On the board layout from the power supply circuit, run the power and return traces to the decoupling capacitors first, and then to the device pins. This ensures that the decoupling capacitors are first in the power chain. Equally important is to keep the trace length between the capacitor and the power pins to a minimum, thereby reducing PCB trace inductance.",
    "2.2.2 TANK CAPACITORS\nOn  boards  with  power  traces  running  longer  than six inches in length, it is suggested to use a tank capac -itor for integrated circuits, including microcontrollers, to supply  a  local  power  source.  The  value  of  the  tank capacitor  should  be  determined  based  on  the  trace resistance  that  connects  the  power  supply  source to the  device,  and  the  maximum  current  drawn  by  the device in the application. In other words, select the tank capacitor so that it meets the acceptable voltage sag at the device. Typical values range from 4.7 \uf06d F to 47 \uf06d F.",
    "2.3 Master Clear (MCLR) Pin\nThe MCLR pin provides two specific device functions:  Device  Reset,  and  Device  Programming and  Debugging.  If  programming  and  debugging  are not required in the end application, a direct connection  to  VDD  may  be  all  that  is  required.  The addition  of  other  components,  to  help  increase  the application's resistance to spurious Resets from voltage sags, may be beneficial. A typical configuration  is  shown  in  Figure 2-1.  Other  circuit designs  may  be  implemented,  depending  on  the application requirements.\nDuring  programming  and  debugging,  the  resistance and  capacitance  that  can  be  added  to  the  pin  must be  considered.  Device  programmers  and  debuggers drive  the  MCLR  pin.  Consequently,  specific  voltage levels  (VIH  and  VIL)  and  fast  signal  transitions  must not  be  adversely  affected.  Therefore,  specific  values of  R1 and C1 will need to be adjusted based on the application and PCB requirements. For example, it is recommended  that  the  capacitor,  C1,  be  isolated from the MCLR pin during programming and debugging operations by using a jumper (Figure 2-2). The jumper is replaced for normal run-time operations.",
    "2.3 Master Clear (MCLR) Pin\nAny components  associated with the MCLR  pin should be placed within 0.25 inch (6 mm) of the pin.",
    "FIGURE 2-2: EXAMPLE OF MCLR PIN CONNECTIONS\nNote 1: R1 \uf0a3\uf020 10 k \uf057 is  recommended. A  suggested starting value  is 10 k \uf057 . Ensure  that  the MCLR pin VIH and VIL specifications are met.\n2: R2 \uf0a3\uf020 470 \uf057 will limit any current flowing into MCLR from the external capacitor, C1, in the event of MCLR  pin  breakdown,  due to Electrostatic  Discharge  (ESD)  or  Electrical Overstress (EOS). Ensure that the MCLR pin VIH and VIL specifications are met.",
    "2.4 ICSP\u2122 Pins\nThe ICSPCLK and ICSPDAT pins are used for In-Cir -cuit  Serial  Programming\u2122  (ICSP\u2122)  and  debugging purposes. It is recommended to keep the trace length between the ICSP connector and the ICSP pins on the device as short as possible. If the ICSP connector is expected to experience an ESD event, a series resistor is recommended, with the value in the range of a few tens of ohms, not to exceed 100 \u03a9 .\nPull-up resistors, series diodes and capacitors on the ICSPCLK and ICSPDAT pins are not recommended as they will interfere with the programmer/debugger com -munications to the device. If such discrete components are an application requirement, they should be removed  from  the  circuit  during  programming  and debugging. Alternatively, refer to the AC/DC character -istics and  timing requirements  information in the respective device Flash programming specification for information on capacitive loading limits, and pin input voltage high (VIH) and input low (VIL) requirements.",
    "2.4 ICSP\u2122 Pins\nFor device emulation, ensure that the 'Communication Channel Select' (i.e., ICSPCLK/ICSPDAT pins), programmed  into  the  device,  matches  the  physical connections for the ICSP to the Microchip debugger/ emulator tool.\nFor more information on available Microchip development  tools  connection  requirements,  refer  to Section 44.0 'Development Support' .",
    "2.5 External Oscillator Pins\nMany  microcontrollers  have  options  for  at  least  two oscillators:  a  high-frequency  primary  oscillator  and  a low-frequency  secondary  oscillator  (refer  to Section 7.0 'Oscillator Module (with Fail-Safe Clock Monitor)' for details).\nThe  oscillator  circuit  should  be  placed  on  the  same side  of  the  board  as  the  device.  Place  the  oscillator circuit  close  to  the  respective  oscillator  pins  with  no more than 0.5 inch (12 mm) between the circuit components and the pins. The load capacitors should be placed next to the oscillator itself, on the same side of the board.\nUse a grounded copper pour around the oscillator cir -cuit to isolate it from surrounding circuits. The grounded copper pour should be routed directly to the MCU ground. Do not run any signal traces or power traces inside the ground pour. Also, if using a two-sided board, avoid any traces on the other side of the board where the crystal is placed.",
    "2.5 External Oscillator Pins\nLayout  suggestions  are  shown  in  Figure 2-3.  In-line packages may be handled with a single-sided layout that completely encompasses the oscillator pins. With fine-pitch packages, it is not always possible to com -pletely surround the pins and components. A suitable solution is to tie the broken guard sections to a mirrored ground layer. In all cases, the guard trace(s) must be returned to ground.\nIn  planning  the  application's  routing  and  I/O  assign -ments,  ensure  that  adjacent  port  pins,  and  other signals in close proximity to the oscillator, are benign (i.e., free of high frequencies, short rise and fall times, and other similar noise).\nFor  additional  information  and  design  guidance  on oscillator circuits, refer to these Microchip Application Notes, available at the corporate website (www.microchip.com):",
    "2.5 External Oscillator Pins\n\u00b7 AN826 ' , Crystal Oscillator Basics and Crystal Selection for rfPIC\u2122 and PICmicro \u00ae  Devices'\n\u00b7 AN849 , 'Basic PICmicro \u00ae Oscillator Design'\n\u00b7 AN943 , 'Practical PICmicro \u00ae  Oscillator Analysis and Design'\n\u00b7 AN949 , 'Making Your Oscillator Work'",
    "2.6 Unused I/Os\nUnused I/O pins should be configured as outputs and driven to a logic low state. Alternatively, connect a 1 k \u03a9 to 10 k \u03a9 resistor to VSS on unused pins and drive the output to logic low.",
    "3.0 PIC18 CPU\nThis family of devices contains a PIC18 8-bit CPU core based on the modified Harvard architecture. The PIC18 CPU supports:\n\u00b7 System Arbitration which decides memory access allocation depending on user priorities\n\u00b7 Vectored Interrupt capability with automatic two level deep context saving\n\u00b7 31-level deep hardware stack with overflow and underflow reset capabilities\n\u00b7 Support Direct, Indirect, and Relative Addressing modes\n\u00b7 8x8 Hardware Multiplier",
    "FIGURE 3-1: PIC18(L)F25/26K83 FAMILY BLOCK DIAGRAM\nNote 1: RE3 is only available when MCLR functionality is disabled.\n2: OSC1/CLKIN and OSC2/CLKOUT are only available in select oscillator modes and when these pins are not being used as digital I/O. Refer to Section 7.0 'Oscillator Module (with Fail-Safe Clock Monitor)' for additional information.",
    "3.1 System Arbitration\nThe System Arbiter resolves memory access between the System Level Selections (i.e., Main, Interrupt Ser -vice Routine) and Peripheral Selection (i.e., DMA and Scanner)  based  on  user-assigned  priorities.  Each  of the system level and peripheral selections has its own priority  selection  registers.  Memory  access  priority  is resolved using the number written to the corresponding Priority registers, 0 being the highest priority and 4 the lowest. The default priorities are listed in Table 3-1.\nIn  case  the  user  wants  to  change  priorities,  ensure each Priority register is written with a unique value from 0 to 4.\nTABLE 3-1: DEFAULT PRIORITIES\n\nSystem Level, Selection = ISR. System Level, Priority register Reset value = 0. System Level, Selection = MAIN. System Level, Priority register Reset value = 1. Peripheral, Selection = DMA1. Peripheral, Priority register Reset value = 2. Peripheral, Selection = DMA2. Peripheral, Priority register Reset value = 3. Peripheral, Selection = SCANNER. Peripheral, Priority register Reset value = 4",
    "3.1.1 PRIORITY LOCK\nThe  System  arbiter  grants  memory  access  to  the peripheral selections (DMAx, Scanner) when  the PRLOCKED bit (PRLOCK Register) is set.\nPriority selections are locked by setting the PRLOCKED bit of the PRLOCK register. Setting and clearing this bit requires a special sequence as an extra precaution against inadvertent changes. Examples of setting and clearing the PRLOCKED bit are shown in Example 3-1 and Example 3-2.",
    "EXAMPLE 3-1: PRIORITY LOCK SEQUENCE\n```\n; Disable interrupts BCF INTCON0,GIE ; Bank to PRLOCK register BANKSEL PRLOCK MOVLW 55h ; Required sequence, next 4 instructions MOVWF PRLOCK MOVLW AAh MOVWF PRLOCK ; Set PRLOCKED bit to grant memory access to peripherals BSF PRLOCK,0 ; Enable Interrupts BSF INTCON0,GIE\n```",
    "EXAMPLE 3-2: PRIORITY UNLOCK SEQUENCE\n```\n; Disable interrupts BCF INTCON0,GIE ; Bank to PRLOCK register BANKSEL PRLOCK MOVLW 55h ; Required sequence, next 4 instructions MOVWF PRLOCK MOVLW AAh MOVWF PRLOCK ; Clear PRLOCKED bit to allow changing priority settings BCF PRLOCK,0 ; Enable Interrupts BSF INTCON0,GIE\n```",
    "3.2 Memory Access Scheme\nThe user can assign priorities to both system level and peripheral  selections based  on  which  the  system arbiter  grants  memory  access.  Let  us  consider  the following  priority  scenarios  between  ISR,  MAIN,  and Peripherals.\nNote:\nIt  is  always required that the ISR priority be higher than Main priority.",
    "3.2.1 ISR PRIORITY > MAIN PRIORITY > PERIPHERAL PRIORITY\nWhen the Peripheral Priority (DMAx, Scanner) is lower than ISR and MAIN  Priority, and the peripheral requires:\n1. Access to the Program Flash Memory, then the peripheral waits for an instruction cycle in which the  CPU  does  not  need  to  access  the  PFM (such  as  a  branch  instruction)  and  uses  that cycle  to  do  its  own  Program  Flash  Memory access, unless a PFM Read/Write operation is in progress.\n2. Access  to  the  SFR/GPR,  then  the  peripheral waits for an instruction cycle in which the CPU does not need to access the SFR/GPR (such as MOVLW CALL NOP , , ) and uses that cycle to do its own SFR/GPR access.\n3. Access to the Data EEPROM, then the peripheral has access to Data EEPROM unless a Data EEPROM Read/Write operation is being performed.\nThis results in the lowest throughput for the peripheral to access the memory, and does so without any impact on execution times.",
    "3.2.2 PERIPHERAL PRIORITY > ISR PRIORITY > MAIN PRIORITY\nWhen the Peripheral Priority (DMAx, Scanner) is higher than  ISR  and  MAIN  Priority,  the  CPU  operation  is stalled when the peripheral requests memory.\nThe CPU is held in its current state until the peripheral completes its operation. Since the peripheral requests access to the bus, the peripheral cannot be disabled until it completes its operation.\nThis results in the highest throughput for the peripheral to access the memory, but has the cost of stalling other execution while it occurs.",
    "3.2.3 ISR PRIORITY > PERIPHERAL PRIORITY > MAIN PRIORITY\nIn this case, interrupt routines and peripheral operation (DMAx,  Scanner)  will  stall  the  CPU.  Interrupt  will preempt  peripheral  operation.  This  results  in  lowest interrupt latency and highest throughput for the peripheral to access the memory.",
    "3.2.4 PERIPHERAL 1 PRIORITY > ISR PRIORITY > MAIN PRIORITY > PERIPHERAL 2 PRIORITY\nIn this case, the Peripheral 1 will stall the execution of the  CPU.  However,  Peripheral  2  can  access  the memory in cycles unused by Peripheral 1.\nThe  operation  of  the  System  Arbiter  is  controlled through the following registers:",
    "REGISTER 3-1: ISRPR: INTERRUPT SERVICE ROUTINE PRIORITY REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = ISRPR<2:0>. -, 6 = ISRPR<2:0>. -, 7 = ISRPR<2:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nu = Bit is unchanged\n1 = bit is set\nW = Writable bit\nx = Bit is unknown\n0 = bit is cleared\nU = Unimplemented bit, read as '0'\n-n/n = Value at POR and BOR/Value at all other Resets\nHS = Hardware set\nbit 7-3\nUnimplemented: Read as ' 0\n'\nbit 2-0\nISRPR<2:0> : Interrupt Service Routine Priority Selection bits",
    "REGISTER 3-2: MAINPR: MAIN ROUTINE PRIORITY REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-1/1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = MAINPR<2:0>. -, 6 = MAINPR<2:0>. -, 7 = MAINPR<2:0>. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nu = Bit is unchanged\n1 = bit is set\nW = Writable bit\nx = Bit is unknown\n0 = bit is cleared\nU = Unimplemented bit, read as '0'\n-n/n = Value at POR and BOR/Value at all other Resets\nHS = Hardware set\nbit 7-3\nUnimplemented: Read as ' 0 '\nbit 2-0\nMAINPR<2:0> : Main Routine Priority Selection bits",
    "REGISTER 3-3: DMA1PR: DMA1 PRIORITY REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-1/1. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = DMA1PR<2:0>. -, 6 = DMA1PR<2:0>. -, 7 = DMA1PR<2:0>. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nu = Bit is unchanged\n1 = bit is set\nW = Writable bit\nx = Bit is unknown\n0 = bit is cleared\nU = Unimplemented bit, read as '0'\n-n/n = Value at POR and BOR/Value at all other Resets\nHS = Hardware set\nbit 7-3\nUnimplemented: Read as ' 0 '\nbit 2-0\nDMA1PR<2:0> : DMA1 Priority Selection bits",
    "REGISTER 3-4: DMA2PR: DMA2 PRIORITY REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-1/1. U-0, 7 = R/W-1/1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = DMA2PR<2:0>. -, 6 = DMA2PR<2:0>. -, 7 = DMA2PR<2:0>. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 3-4: DMA2PR: DMA2 PRIORITY REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit u = Bit is unchanged 1 = bit is set, 1 = W=Writable bit x = Bit is unknown 0 = bit is cleared. R = Readable bit u = Bit is unchanged 1 = bit is set, 2 = U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets HS = Hardware set\nbit 7-3, 1 = Unimplemented: Read as ' 0 '. bit 2-0, 1 = DMA2PR<2:0> : DMA2 Priority Selection bits",
    "REGISTER 3-5: SCANPR: SCANNER PRIORITY REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/W-1/1. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = SCANPR<2:0>. -, 6 = SCANPR<2:0>. -, 7 = SCANPR<2:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 3-5: SCANPR: SCANNER PRIORITY REGISTER\nR = Readable bit u = Bit is unchanged 1 = bit is set,  = W=Writable bit x = Bit is unknown 0 = bit is cleared. R = Readable bit u = Bit is unchanged 1 = bit is set,  = U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets HS = Hardware set\nbit 7-3 Unimplemented: Read as ' 0 '\nbit 2-0\nSCANPR<2:0>\n: Scanner Priority Selection bits",
    "REGISTER 3-6: PRLOCK: PRIORITY LOCK REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = PRLOCKED. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 3-6: PRLOCK: PRIORITY LOCK REGISTER\nLegend:, 1 = . Legend:, 2 = . R = Readable bit u = Bit is unchanged 1 = bit is set, 1 = W=Writable bit x = Bit is unknown 0 = bit is cleared. R = Readable bit u = Bit is unchanged 1 = bit is set, 2 = U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets HS = Hardware set",
    "bit 7-1 Unimplemented: Read as ' 0 '\nbit 0\nPRLOCKED : PR Register Lock bit (1, 2)\n0 = Priority Registers can be modified by write operations; Peripherals do not have access to the memory\n1 = Priority Registers are locked and cannot be written; Peripherals do not have access to the memory\nNote 1: The PRLOCKED bit can only be set or cleared after the unlock sequence.\n2: If PR1WAY = 1 , the PRLOCKED bit cannot be cleared after it has been set. A system Reset will clear the bit and allow one more set.",
    "TABLE 3-2: SUMMARY OF REGISTERS ASSOCIATED WITH CPU\nISRPR, Bit 7 = -. ISRPR, Bit 6 = -. ISRPR, Bit 5 = -. ISRPR, Bit 4 = -. ISRPR, Bit 3 = -. ISRPR, Bit 2 = ISRPR2. ISRPR, Bit 1 = ISRPR1. ISRPR, Bit 0 = ISRPR0. ISRPR, Register on page = 20. MAINPR, Bit 7 = -. MAINPR, Bit 6 = -. MAINPR, Bit 5 = -. MAINPR, Bit 4 = -. MAINPR, Bit 3 = -. MAINPR, Bit 2 = MAINPR2. MAINPR, Bit 1 = MAINPR1. MAINPR, Bit 0 = MAINPR0. MAINPR, Register on page = 20. DMA1PR, Bit 7 = -. DMA1PR, Bit 6 = -. DMA1PR, Bit 5 = -. DMA1PR, Bit 4 = -. DMA1PR, Bit 3 = -. DMA1PR, Bit 2 = DMA1PR2. DMA1PR, Bit 1 =",
    "TABLE 3-2: SUMMARY OF REGISTERS ASSOCIATED WITH CPU\nDMA1PR1. DMA1PR, Bit 0 = DMA1PR0. DMA1PR, Register on page = 20. DMA2PR, Bit 7 = -. DMA2PR, Bit 6 = -. DMA2PR, Bit 5 = -. DMA2PR, Bit 4 = -. DMA2PR, Bit 3 = -. DMA2PR, Bit 2 = DMA2PR2. DMA2PR, Bit 1 = DMA2PR1. DMA2PR, Bit 0 = DMA2PR0. DMA2PR, Register on page = 21. SCANPR, Bit 7 = -. SCANPR, Bit 6 = -. SCANPR, Bit 5 = -. SCANPR, Bit 4 = -. SCANPR, Bit 3 = -. SCANPR, Bit 2 = SCANPR2. SCANPR, Bit 1 = SCANPR1. SCANPR, Bit 0 = SCANPR0. SCANPR, Register on page = 21. PRLOCK, Bit 7 = -. PRLOCK, Bit 6 = -. PRLOCK, Bit 5 = -. PRLOCK, Bit 4 = -.",
    "TABLE 3-2: SUMMARY OF REGISTERS ASSOCIATED WITH CPU\nPRLOCK, Bit 3 = -. PRLOCK, Bit 2 = -. PRLOCK, Bit 1 = -. PRLOCK, Bit 0 = PRLOCKED. PRLOCK, Register on page = 21\nLegend:\n- = Unimplemented location, read as ' 0 '.",
    "4.0 MEMORY ORGANIZATION\nThere are three types of memory in PIC18 enhanced microcontroller devices:\n\u00b7 Program Flash Memory\n\u00b7 Data RAM\n\u00b7 Data EEPROM\nThe Program Memory Flash and data RAM share the same bus, while data EEPROM uses a separate bus. This  allows  for  concurrent  access  of  the  memory spaces.\nAdditional detailed information on the operation of the Program Flash Memory and Data EEPROM Memory is provided in Section 13.0 'Nonvolatile Memory (NVM) Control' .",
    "4.1 Program Flash Memory Organization\nPIC18  microcontrollers  implement  a  21-bit  Program Counter,  which  is  capable  of  addressing  a  2 Mbyte program memory space. Accessing any unimplemented  memory  will  return  all  ' 0 's (a NOP instruction).\nThese devices contains the following:\n\u00b7 PIC18(L)F25K83: 32 Kbytes of Flash memory, up to 16,384 single-word instructions\n\u00b7 PIC18(L)F26K83: 64 Kbytes of Flash memory, up to 32,768 single-word instructions\nThe Reset vector for the device is at address 000000h. PIC18(L)F25/26K83 devices feature a vectored inter -rupt controller with a dedicated interrupt vector table in the program memory, see Section 9.0 'Interrupt Con -troller' .\nNote:\nFor memory information on this family of devices, see Table 4-1 and Table 4-3.",
    "4.2 Memory Access Partition (MAP)\nProgram Flash Memory is partitioned into:\n\u00b7 Application Block\n\u00b7 Boot Block, and\n\u00b7 Storage Area Flash (SAF) Block",
    "4.2.1 APPLICATION BLOCK\nApplication Block is where the user's program resides by  default.  Default  settings  of  the  Configuration  bits (BBEN = 1 and SAFEN = 1 ) assign all memory in the Program Flash Memory area to the Application Block. The WRTAPP Configuration bit is used to protect the Application Block.",
    "4.2.2 BOOT BLOCK\nBoot Block is an area in program memory that is ideal for storing bootloader code. Code placed in this area can be executed by the CPU. The Boot Block can be write-protected,  independent  of  the  main Application Block. The Boot Block is enabled by the BBEN bit and size  is  based  on  the  value  of  the  BBSIZE  bits  of Configuration  word  (Register 5-7),  see  Table 5-1  for Boot Block sizes.\nThe  WRTB Configuration  bit  is  used  to  write-protect the Boot Block.",
    "4.2.3 STORAGE AREA FLASH\nStorage  Area  Flash  (SAF)  is  the  area  in  program memory  that  can  be  used  as  data  storage.  SAF  is enabled by the SAFEN bit of the Configuration word in Register 5-7. If enabled, the code placed in this area cannot  be  executed  by  the  CPU.  The  SAF  block  is placed at the  end  of  memory  and spans  128 words. The WRTSAF Configuration bit is used to write-protect the Storage Area Flash.\nNote:\nIf write-protected locations are written from NVMCON registers, memory is not changed and the WRERR bit defined in Register 13-1 is set.",
    "TABLE 4-1: PROGRAM AND DATA EEPROM MEMORY MAP\nNote 1, PIC18(L)F25K83.PC<21:0> = Stack (31 levels). Note 1, PIC18(L)F26K83.PC<21:0> = Stack (31 levels) Note. , PIC18(L)F25K83.PC<21:0> = . , PIC18(L)F26K83.PC<21:0> = Reset Vector 00. 00 0000h \u2022 \u2022 \u2022, PIC18(L)F25K83.PC<21:0> = Reset Vector \u2022 \u2022 \u2022. 00 0000h \u2022 \u2022 \u2022, PIC18(L)F26K83.PC<21:0> = \u2022 \u2022 \u2022 \u2022. 00 0008h, PIC18(L)F25K83.PC<21:0> = Interrupt Vector High (2). 00 0008h, PIC18(L)F26K83.PC<21:0> = Interrupt Vector High (2) 00. \u2022 \u2022 \u2022, PIC18(L)F25K83.PC<21:0>",
    "TABLE 4-1: PROGRAM AND DATA EEPROM MEMORY MAP\n= \u2022 \u2022 \u2022. \u2022 \u2022 \u2022, PIC18(L)F26K83.PC<21:0> = \u2022 \u2022 \u2022 \u2022. 00 0018h, PIC18(L)F25K83.PC<21:0> = Interrupt Vector Low (2). 00 0018h, PIC18(L)F26K83.PC<21:0> = Interrupt Vector Low (2) 00. 00 001Ah \u2022, PIC18(L)F25K83.PC<21:0> = Program Flash Memory (16 KW) (3). 00 001Ah \u2022, PIC18(L)F26K83.PC<21:0> = (3) 00 \u2022. 00 7FFFh 00 8000h, PIC18(L)F25K83.PC<21:0> = . 00 7FFFh 00 8000h, PIC18(L)F26K83.PC<21:0> = Program Flash Memory (32 KW) 00 00. \u2022 00 FFFFh 01 0000h 1F FFFFh 20 0000h \u2022 \u2022",
    "TABLE 4-1: PROGRAM AND DATA EEPROM MEMORY MAP\n\u2022 20 000Fh 20 0010h \u2022 \u2022 \u2022, PIC18(L)F25K83.PC<21:0> = Not present (4). \u2022 00 FFFFh 01 0000h 1F FFFFh 20 0000h \u2022 \u2022 \u2022 20 000Fh 20 0010h \u2022 \u2022 \u2022, PIC18(L)F26K83.PC<21:0> = \u2022 00 Not present (4) 01 1F (5) 20 \u2022 20 20. 2F FFFFh 30 0000h \u2022 \u2022 \u2022 30 0009h 30 000Ah \u2022 \u2022 \u2022 30 FFFFh 31 0000h \u2022 \u2022 \u2022 31 00FFh 31 0100h \u2022 \u2022 \u2022 31 03FFh, PIC18(L)F25K83.PC<21:0> = User IDs (8 Words) Reserved Configuration Reserved. 2F FFFFh 30 0000h \u2022 \u2022 \u2022 30 0009h 30 000Ah \u2022 \u2022 \u2022 30 FFFFh 31 0000h \u2022 \u2022 \u2022 31 00FFh 31 0100h \u2022 \u2022 \u2022 31 03FFh,",
    "TABLE 4-1: PROGRAM AND DATA EEPROM MEMORY MAP\nPIC18(L)F26K83.PC<21:0> = \u2022 2F Words (5 Words) (5) 30 \u2022 30 30 \u2022 30. , PIC18(L)F25K83.PC<21:0> = Data EEPROM (1024. , PIC18(L)F26K83.PC<21:0> = Bytes) 31 \u2022 31 31 \u2022 31. 31 0400h \u2022 \u2022 \u2022, PIC18(L)F25K83.PC<21:0> = Reserved. 31 0400h \u2022 \u2022 \u2022, PIC18(L)F26K83.PC<21:0> = 31 \u2022. 3E FFFFh, PIC18(L)F25K83.PC<21:0> = . 3E FFFFh, PIC18(L)F26K83.PC<21:0> = 3E Area (5),(7). 3F 0000h \u2022 \u2022 \u2022 3F 003Fh 3F0040h,",
    "TABLE 4-1: PROGRAM AND DATA EEPROM MEMORY MAP\nPIC18(L)F25K83.PC<21:0> = Device Information. 3F 0000h \u2022 \u2022 \u2022 3F 003Fh 3F0040h, PIC18(L)F26K83.PC<21:0> = 3F \u2022 3F 3F0040h. \u2022 \u2022 \u2022 3F FEFFh 3F FF00h \u2022 \u2022 \u2022, PIC18(L)F25K83.PC<21:0> = Reserved Device. \u2022 \u2022 \u2022 3F FEFFh 3F FF00h \u2022 \u2022 \u2022, PIC18(L)F26K83.PC<21:0> = \u2022 3F Configuration Information (5 Words) (5),(6),(7) 3F \u2022 3F. 3F FF09h 3F FF0Ah \u2022 \u2022 \u2022, PIC18(L)F25K83.PC<21:0> = Reserved. 3F FF09h 3F FF0Ah \u2022 \u2022 \u2022, PIC18(L)F26K83.PC<21:0> = 3F. 3F",
    "TABLE 4-1: PROGRAM AND DATA EEPROM MEMORY MAP\nFFFBh, PIC18(L)F25K83.PC<21:0> = . 3F FFFBh, PIC18(L)F26K83.PC<21:0> = . , PIC18(L)F25K83.PC<21:0> = . , PIC18(L)F26K83.PC<21:0> = \u2022 3F. 3F FFFCh \u2022 \u2022 \u2022 3F FFFDh, PIC18(L)F25K83.PC<21:0> = Revision ID (1 Word). 3F FFFCh \u2022 \u2022 \u2022 3F FFFDh, PIC18(L)F26K83.PC<21:0> = (5),(6),(7) 3F \u2022 3F. 3F FFFEh \u2022 \u2022 \u2022, PIC18(L)F25K83.PC<21:0> = Device ID (1 Word) (5),(6),(7). 3F FFFEh \u2022 \u2022 \u2022,",
    "TABLE 4-1: PROGRAM AND DATA EEPROM MEMORY MAP\nPIC18(L)F26K83.PC<21:0> = 3F. , PIC18(L)F25K83.PC<21:0> = . , PIC18(L)F26K83.PC<21:0> = \u2022. 3F FFFFh, PIC18(L)F25K83.PC<21:0> = . 3F FFFFh, PIC18(L)F26K83.PC<21:0> = 3F\nNote\n1: The stack is a separate SRAM panel, apart from all user memory panels.\n2: 00 0008h location is used as the reset default for the IVTBASE register, the vector table can be relocated in the memory by programming the IVTBASE register.\n3: Storage Area Flash is implemented as the last 128 Words of User Flash, if present.\n4: The addresses do not roll over. The region is read as '0'.\n5: Not code-protected.\n6: Hard-coded in silicon.\n7: This region cannot be written by the user and it is not affected by a Bulk Erase.",
    "TABLE 4-2: PROGRAM FLASH MEMORY PARTITION\nProgram Flash Memory, Address = 00 0000h \u2022 \u2022 \u2022 Last Boot Block Memory Address. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 1 = APPLICATION BLOCK. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 0 = APPLICATION BLOCK. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 1 = BOOT BLOCK. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 0 = BOOT BLOCK. Program Flash Memory, Address = Last Boot Block Memory Address (1) + 1 \u2022 \u2022 \u2022 Last Program Memory Address (2) - 100h. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 1 = APPLICATION BLOCK. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 0 = APPLICATION BLOCK. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 1 = APPLICATION BLOCK. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 0 = APPLICATION BLOCK. Program Flash Memory, Address = Last Program Memory Address (2) - FEh (4) \u2022 \u2022 \u2022 Last Program Memory Address (2).",
    "TABLE 4-2: PROGRAM FLASH MEMORY PARTITION\nProgram Flash Memory, Partition (3).BBEN = 1 SAFEN = 1 = APPLICATION BLOCK. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 0 = STORAGE AREA FLASH. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 1 = APPLICATION BLOCK. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 0 = STORAGE AREA FLASH\nNote1: Last Boot Block Memory Address is based on BBSIZE<2:0>, see Table 5-1.\n2: For Last Program Memory Address, see Table 5-1.\n3: Refer to Register 5-7: Configuration Word 4L for BBEN and SAFEN definitions.\n4: Storage Area Flash is implemented as the last 128 Words of User Flash, if present.",
    "4.2.4 PROGRAM COUNTER\nThe Program Counter (PC) specifies the address of the instruction to fetch for execution. The PC is 21-bit wide and is contained in three separate 8-bit registers. The low byte, known as the PCL register, is both readable and writable. The high byte, or PCH register, contains the PC<15:8> bits; it is not directly readable or writable. Updates to the PCH register are performed through the PCLATH register. The upper byte is called PCU. This register  contains  the  PC<20:16>  bits;  it  is  also  not directly  readable  or  writable.  Updates  to  the  PCU register are performed through the PCLATU register.\nThe contents of PCLATH and PCLATU are transferred to  the  Program Counter by any operation that writes PCL.  Similarly,  the  upper  two  bytes  of  the  Program Counter are transferred to PCLATH and PCLATU by any operation that reads PCL. This is useful for com -puted offsets to the PC (see Section 4.3.2.1 'Computed GOTO' ).",
    "4.2.4 PROGRAM COUNTER\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the Least Significant bit of PCL is fixed to a value of ' 0 '.  The PC increments by two to address sequential instructions in the program memory.\nThe CALL , RCALL , GOTO and program branch instructions write to the Program Counter directly. For these instructions, the contents of PCLATH  and PCLATU are not transferred to the Program Counter.",
    "4.2.5 RETURN ADDRESS STACK\nThe return address stack allows any combination of up to 31 program calls and interrupts to occur. The PC is pushed  onto  the  stack  when  a CALL or RCALL instruction is executed or an interrupt is acknowledged. The PC value is  pulled  off  the  stack  on  a RETURN, RETLW or a RETFIE instruction. PCLATU and PCLATH are  not  affected  by  any  of  the RETURN or CALL instructions.\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit Stack Pointer. The stack space is not part of either program or data space. The Stack Pointer is readable and writable and the address on the top of the stack is readable and writable through the Top-of-Stack (TOS) Special File Registers. Data can also be pushed to, or popped from the stack, using these registers.",
    "4.2.5 RETURN ADDRESS STACK\nA CALL  CALLW , or RCALL instruction causes a push onto the stack; the Stack Pointer is first incremented and  the  location  pointed  to  by  the  Stack  Pointer  is written with the contents of the PC (already pointing to the  instruction  following  the CALL ).  A RETURN type instruction causes a pop from the stack; the contents of the location pointed to by the STKPTR are transferred to the PC and then the Stack Pointer is decremented.\nThe  Stack  Pointer  is  initialized  to  ' 00000 ' after  all Resets. There is no RAM associated with the location corresponding to a Stack Pointer value of ' 00000 '; this is only a Reset value. Status bits in the PCON0 register indicate if the stack has overflowed or underflowed.",
    "4.2.5.1 Top-of-Stack Access\nOnly the top of the return address stack (TOS) is readable and writable. A set of three registers, TOSU:TOSH:TOSL, holds the contents of the stack location pointed to by the STKPTR  register  (Figure 4-1).  This  allows  users  to implement a software stack, if necessary. After a CALL, RCALL or  interrupt,  the  software  can  read  the  pushed value by reading the TOSU:TOSH:TOSL registers. These values can be placed on a user-defined software stack. At return  time,  the  software  can  return  these  values  to TOSU:TOSH:TOSL and do a return.\nThe user must disable the Global Interrupt Enable (GIE) bits  while  accessing  the  stack  to  prevent  inadvertent stack corruption.",
    "4.2.5.2 Return Stack Pointer (STKPTR)\nThe STKPTR register (Register 4-4) contains the Stack Pointer value. The STKOVF (Stack Overflow) Status bit and the STKUNF (Stack Underflow) Status bit can be accessed using the PCON0 register. The value of the Stack Pointer can be 0 through 31. On Reset, the Stack Pointer value will be zero. The user may read and write the Stack Pointer value. This feature can be used by a Real-Time Operating System (RTOS) for stack mainte -nance. After the PC is pushed onto the stack 32 times (without popping any values off the stack), the STKOVF bit is set. The STKOVF bit is cleared by soft -ware or by a POR. The action that takes place when the stack  becomes  full  depends  on  the  state  of  the STVREN (Stack Overflow Reset Enable) Configuration bit. (Refer to Section 5.1 'Configuration Words' for a description of the device Configuration bits.)",
    "4.2.5.2 Return Stack Pointer (STKPTR)\nIf STVREN is set (default), a Reset will be generated and a Stack Overflow will be indicated by the STKOVF bit when the 32nd push is initiated. This includes CALL and CALLW instructions, as well as stacking the return address during an interrupt response. The STKOVF bit will remain set and the Stack Pointer will be set to zero.\nIf STVREN is cleared, the STKOVF bit will be set on the 32nd push and the Stack Pointer will remain at 31 but no Reset will occur.  Any additional pushes will overwrite the 31 st push but the STKPTR will remain at 31.\nSetting STKOVF = 1 in software will change the bit, but will not generate a Reset.\nThe  STKUNF bit  is  set  when  a  stack  pop  returns  a value of zero. The STKUNF bit is cleared by software or by POR. The action that takes place when the stack becomes  full  depends  on  the  state  of  the  STVREN (Stack Overflow Reset Enable) Configuration bit. (Refer  to Section  5.1 'Configuration  Words' for  a description of the device Configuration bits).",
    "4.2.5.2 Return Stack Pointer (STKPTR)\nIf  STVREN  is  set  (default)  and  the  stack  has  been popped enough times to unload the stack, the next pop will  return  a  value  of  zero  to  the  PC,  it  will  set  the STKUNF  bit  and  a  Reset  will  be  generated.  This condition can be generated by the RETURN RETLW , and RETFIE instructions.\nWhen STVREN = 0 , STKUNF will be set but no Reset will occur.\nNote:\nReturning a value of zero to the PC on an underflow has the effect of vectoring the program  to  the  Reset  vector,  where  the stack conditions can be verified and appropriate actions can be taken. This is not the same as a Reset, as the contents of the SFRs are not affected.",
    "4.2.5.3 PUSH and POP Instructions\nSince  the  Top-of-Stack  is  readable  and  writable,  the ability to push values onto the stack and pull values off the stack without disturbing normal program execution is a desirable  feature.  The  PIC18  instruction  set includes two instructions, PUSH and POP ,  that  permit the  TOS  to  be  manipulated  under  software  control. TOSU, TOSH and TOSL can be modified to place data or a return address on the stack.\nThe PUSH instruction places the current PC value onto the stack. This increments the Stack Pointer and loads the current PC value onto the stack.\nThe POP instruction  discards  the  current  TOS  by decrementing  the  Stack  Pointer.  The  previous  value pushed onto the stack then becomes the TOS value.",
    "REGISTER 4-1: TOSU: TOP-OF-STACK UPPER BYTE\n-, U-0 = -. -, U-0 = -. -, R/W-0 = . -, R/W-0 = . -, R/W-0 = TOS<20:16>. -, R/W-0 = . -, R/W-0 = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 4-1: TOSU: TOP-OF-STACK UPPER BYTE\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented. R = Readable bit, 3 = C = Clearable only bit. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-5, 1 = Unimplemented: Read as ' 0 '. bit 4-0, 1 = TOS<20:16>: Top-of-Stack Location bits",
    "REGISTER 4-2: TOSH: TOP-OF-STACK HIGH BYTE\nbit 7, R/W-0.TOS<15:8> = . bit 7, R/W-0.TOS<15:8> = . bit 7, R/W-0.TOS<15:8> = . bit 7, R/W-0.TOS<15:8> = . bit 7, R/W-0.TOS<15:8> = . bit 7, R/W-0.TOS<15:8> = . bit 7, R/W-0.TOS<15:8> = bit 0\nR = Readable bit -n = Value,  = W=Writable '1' = Bit is set. R = Readable bit -n = Value, U = Unimplemented = '0' = Bit is cleared. R = Readable bit -n = Value, C = Clearable only bit = x = Bit is unknown\nbit 7-0\nTOS<15:8>:\nTop-of-Stack Location bits",
    "REGISTER 4-3: TOSL: TOP-OF-STACK LOW BYTE\nbit 7, R/W-0. = . bit 7, R/W-0. = . bit 7, R/W-0.TOS<7:0> = . bit 7, R/W-0. = . bit 7, R/W-0. = . bit 7, R/W-0. = . bit 7, R/W-0. = bit 0\n-n = Value at POR,  = '1' = Bit is set. -n = Value at POR, U = Unimplemented = '0' = Bit is cleared. -n = Value at POR, C = Clearable only bit = x = Bit is unknown\nbit 7-0 TOS<7:0>: Top-of-Stack Location bits",
    "REGISTER 4-4: STKPTR: STACK POINTER REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = . -, 4 = . -, 5 = STKPTR<4:0>. -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 4-4: STKPTR: STACK POINTER REGISTER\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented = '0' = Bit is cleared. -n = Value at POR, C = Clearable only bit = x = Bit is unknown\nbit 7-5\nUnimplemented: Read as ' 0 '\nbit 4-0\nSTKPTR<4:0>:\nStack Pointer Location bits",
    "4.3.1 FAST REGISTER STACK\nThere are three levels of fast stack registers available one for CALL type instructions and two for interrupts. A fast  register  stack  is  provided  for  the  Status,  WREG and BSR registers, to provide a 'fast return' option for interrupts. It is loaded with the current value of the cor -responding register when the processor vectors for an interrupt. All interrupt sources will push values into the stack  registers.  The  values  in  the  registers  are  then loaded  back  into  their  associated  registers  if  the RETFIE, FAST instruction is used to return from the interrupt. Refer to Section 4.5.6 'Call Shadow Regis -ter' for interrupt call shadow registers.\nExample 4-1 shows a source code example that uses the  fast  register  stack  during  a  subroutine  call  and return.",
    "EXAMPLE 4-1: FAST REGISTER STACK CODE EXAMPLE\nCALL SUB1, FAST, 1 = ;STATUS, WREG, BSR ;SAVED IN FAST REGISTER ;STACK. SUB1 \uf0b7 \uf0b7, 1 = . RETURN, FAST, 1 = ;RESTORE VALUES SAVED ;IN FAST REGISTER STACK",
    "4.3.2 LOOK-UP TABLES IN PROGRAM MEMORY\nThere may be programming situations that require the creation of data structures, or look-up tables, in program memory. For PIC18 devices, look-up tables can be implemented in two ways:\n\u00b7 Computed GOTO\n\u00b7 Table Reads",
    "4.3.2.1 Computed GOTO\nA computed GOTO is accomplished by adding an offset to  the  Program  Counter.  An  example  is  shown  in Example 4-2.\nA  look-up  table  can  be  formed  with  an ADDWF  PCL instruction and a group of RETLW nn instructions. The W register is loaded with an offset into the table before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction  executed  will  be  one  of  the RETLW  nn instructions  that  returns  the  value  ' nn '  to  the  calling function.\nThe offset  value  (in  WREG)  specifies  the  number  of bytes that the Program Counter should advance and should be multiples of two (LSb = 0 ).\nIn  this  method,  only  one  data  byte  may  be stored  in each  instruction  location  and  room  on  the  return address stack is required.",
    "EXAMPLE 4-2: COMPUTED GOTO USING AN OFFSET VALUE\n, 1 = MOVF CALL. , 2 = OFFSET, W TABLE. ORG, 1 = nn00h. ORG, 2 = . TABLE, 1 = ADDWF. TABLE, 2 = PCL. , 1 = RETLW. , 2 = nnh. , 1 = RETLW. , 2 = nnh. , 1 = RETLW. , 2 = nnh. , 1 = .. , 2 = . , 1 = .. , 2 = . , 1 = .. , 2 = ",
    "4.3.2.2 Table Reads and Table Writes\nA  better  method  of  storing  data  in  program  memory allows two bytes of data to be stored in each instruction location.\nLook-up  table  data  may  be  stored  two  bytes  per program  word  by  using  table  reads  and  writes.  The Table  Pointer  (TBLPTR)  register  specifies  the  byte address and the Table Latch (TABLAT) register contains the data that is read from or written to program memory.\nTable  read  and  table  write  operations  are  discussed further  in Section  13.1.1 'Table  Reads  and  Table Writes' .",
    "4.4.1 CLOCKING SCHEME\nThe  microcontroller clock input, whether  from  an internal or external source, is internally divided by four to  generate  four  quadrature  clocks (Q1, Q2,  Q3  and Q4). Internally, the Program Counter is incremented on every Q1; the instruction is fetched from the program memory and latched into the instruction register during Q4. The instruction is decoded and executed during the following  Q1  through  Q4. The  clocks  and  instruction execution flow are shown in Figure 4-2.",
    "4.4.2 INSTRUCTION FLOW/PIPELINING\nAn  'Instruction  Cycle'  consists  of  four  Q  cycles:  Q1 through  Q4.  The  instruction  fetch  and  execute  are pipelined  in  such  a  manner  that  a  fetch  takes  one instruction  cycle,  while  the  decode  and  execute  take another instruction cycle. However, due to the pipelining, each instruction effectively executes in one cycle. If an instruction causes the Program Counter to change (e.g., GOTO ),  then  two  cycles are required to complete the instruction (Example 4-3).\nA  fetch  cycle  begins  with  the  Program  Counter  (PC) incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched into  the  Instruction  Register  (IR)  in  cycle  Q1.  This instruction  is  then  decoded  and  executed  during  the Q2, Q3 and Q4 cycles. Data memory is read during Q2 (operand  read)  and  written  during  Q4  (destination write).",
    "EXAMPLE 4-3: INSTRUCTION PIPELINE FLOW\nNote:\nThere are some instructions that take multiple cycles to execute. Refer to Section 42.0 'Instruction Set Summary' for details.",
    "4.4.3 INSTRUCTIONS IN PROGRAM MEMORY\nThe program memory is addressed in bytes. Instructions are stored as either two bytes or four bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSb = 0 ). To maintain alignment with instruction boundaries, the PC increments in steps of two and the LSb will always read ' 0 ' (see Section 4.2.4 'Program Counter' ).\nFigure 4-3 shows an example of how instruction words are stored in the program memory.",
    "4.4.3 INSTRUCTIONS IN PROGRAM MEMORY\nThe CALL and GOTO instructions  have  the  absolute program memory address embedded into the instruction. Since instructions are always stored on word boundaries,  the  data  contained  in  the  instruction  is  a word address. The word address is written to PC<20:1>, which  accesses  the  desired  byte  address  in  program memory.  Instruction  #2  in  Figure 4-3  shows  how  the instruction GOTO  0006h is  encoded  in  the  program memory. Program branch instructions, which encode a relative address offset, operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions that the PC will be offset  by. Section 42.0  'Instruction  Set  Summary' provides further details of the instruction set.",
    "4.4.4 MULTI-WORD INSTRUCTIONS\nThe standard PIC18 instruction set has four two-word instructions: CALL , MOVFF , GOTO and LFSR and  two three-word  instructions: MOVFFL and MOVSFL .  In  all cases, the second and the third word of the instruction always has ' 1111 ' as its four Most Significant bits; the other 12 bits are literal  data,  usually  a  data  memory address.\nThe use of ' 1111 '  in  the  four  MSbs of  an  instruction specifies  a  special  form  of NOP .  If  the  instruction  is executed in proper sequence - immediately after the first word - the data in the second word is accessed and used by the instruction sequence. If the first word is  skipped  for  some  reason  and  the  second  or  third word is executed by itself, a NOP is executed instead. This  is  necessary  for  cases  when  the  multi-word instruction is preceded by a conditional instruction that changes the PC. Example 4-4 shows how this works.",
    "FIGURE 4-3: INSTRUCTIONS IN PROGRAM MEMORY\nProgram Memory\nByte Locations\n\uf0ae\uf020\nInstruction 1:\nInstruction 2:\nInstruction 3:\nInstruction 4:\nMOVLW\n055h\nGOTO\nMOVFF\nMOVFFL\n0006h\n123h, 456h\n123h, 456h",
    "FIGURE 4-3: INSTRUCTIONS IN PROGRAM MEMORY\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address \uf0af. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. EFh, 1 = 03h. EFh, 2 = 00000Ah. F0h, 1 = 00h. F0h, 2 = 00000Ch. C1h, 1 = 23h. C1h, 2 = 00000Eh. F4h, 1 = 56h. F4h, 2 = 000010h. 00h, 1 = 60h. 00h, 2 = 000012h. F4h, 1 = 8Ch. F4h, 2 = 000014h. F4h, 1 = 56h. F4h, 2 = 000016h. , 1 = . , 2 = 000018h. , 1 = . , 2 = 00001Ah",
    "EXAMPLE 4-4: TWO-WORD INSTRUCTIONS\n0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ;. 0110, CASE 1:.Source Code = is RAM location 0?. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:.Source Code = ;. 1100, CASE 1:.Source Code = Yes, skip this word. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111,",
    "EXAMPLE 4-4: TWO-WORD INSTRUCTIONS\nCASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; Execute this word as a NOP. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ;. 0010, CASE 1:.Source Code = continue code. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code",
    "EXAMPLE 4-4: TWO-WORD INSTRUCTIONS\n= CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. 0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ;. 0110, CASE 1:.Source Code = is RAM location. 1100, CASE",
    "EXAMPLE 4-4: TWO-WORD INSTRUCTIONS\n1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:.Source Code = ;. 1100, CASE 1:.Source Code = No, execute this word. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ;. 1111, CASE 1:.Source Code = 2nd word of instruction. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code =",
    "EXAMPLE 4-4: TWO-WORD INSTRUCTIONS\nADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ;. 0010, CASE 1:.Source Code = continue code",
    "EXAMPLE 4-5: THREE-WORD INSTRUCTIONS\n0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = ;. 0110, CASE 1:.Source Code = is RAM location 0?. 0000, CASE 1:.Object Code = 0000. 0000, CASE 1:.Object Code = 0110. 0000, CASE 1:.Object Code = 0000. 0000, CASE 1:.Source Code = MOVFFL. 0000, CASE 1:.Source Code = REG1,. 0000, CASE 1:.Source Code = REG2. 0000, CASE 1:.Source Code = ; Yes, skip this word. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 1000. 1111, CASE 1:.Object Code = 1100. 1111, CASE 1:.Source Code = . 1111, CASE",
    "EXAMPLE 4-5: THREE-WORD INSTRUCTIONS\n1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; Execute this word as a NOP. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; Execute this word as a NOP. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = ;. 0010, CASE 1:.Source Code = continue code. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE",
    "EXAMPLE 4-5: THREE-WORD INSTRUCTIONS\n2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. 0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = ;.",
    "EXAMPLE 4-5: THREE-WORD INSTRUCTIONS\n0110, CASE 1:.Source Code = is RAM location. 0000, CASE 1:.Object Code = 0000. 0000, CASE 1:.Object Code = 0110. 0000, CASE 1:.Object Code = 0000. 0000, CASE 1:.Source Code = MOVFFL. 0000, CASE 1:.Source Code = REG1,. 0000, CASE 1:.Source Code = REG2 ;. 0000, CASE 1:.Source Code = No, execute this word. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 1000. 1111, CASE 1:.Object Code = 1100. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ;. 1111, CASE 1:.Source Code = 2nd word of instruction. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code =",
    "EXAMPLE 4-5: THREE-WORD INSTRUCTIONS\n. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ;. 1111, CASE 1:.Source Code = 3rd word of instruction. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = ;. 0010, CASE 1:.Source Code = continue code",
    "4.5 Data Memory Organization\nData memory in PIC18(L)F25/26K83 devices is implemented as static RAM. Each register in the data memory has a 14-bit address,  allowing  up  to  16384 bytes of data memory. The memory space is divided into 64 banks that contain 256 bytes each. Figure 4-5 shows the data memory organization for the PIC18(L)F25/26K83 devices in this data sheet.\nThe data memory contains Special Function Registers (SFRs) and General Purpose Registers (GPRs). The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratchpad operations in the user's application. Any read of an unimplemented location will read as ' 0 's.\nThe instruction  set  and  architecture  allow  operations across  all  banks.  The  entire  data  memory  may  be accessed  by  Direct,  Indirect  or  Indexed  Addressing modes. Addressing modes are discussed later in this subsection.",
    "4.5 Data Memory Organization\nTo ensure that commonly used registers (select SFRs and GPRs) can be accessed in a single cycle, PIC18 devices implement an Access Bank. This is a 256-byte memory space that provides fast access to some SFRs and the lower portion of GPR Bank 0 without using the Bank Select Register (BSR). Section 4.5.4 'Access Bank' provides  a  detailed  description  of  the Access RAM.",
    "4.5.1 BANK SELECT REGISTER (BSR)\nLarge  areas  of  data  memory  require  an  efficient addressing  scheme  to  make  rapid  access  to  any address  possible.  Ideally,  this  means  that  an  entire address does not need to be provided for each read or write  operation.  For  PIC18  devices,  this  is  accom -plished with a RAM banking scheme. This divides the memory space into 64 contiguous banks of 256 bytes. Depending  on  the  instruction,  each  location  can  be addressed directly by its full 14-bit address, or an 8-bit low-order address and a 6-bit Bank Select Register.\nThis SFR holds the six Most Significant bits of a loca -tion address; the instruction itself includes the eight Least Significant bits. Only the six lower bits of the BSR are implemented (BSR<5:0>). The upper two bits are  unused;  they  will  always  read  ' 0 '  and  cannot  be written to. The BSR can be loaded directly by using the MOVLB instruction.",
    "4.5.1 BANK SELECT REGISTER (BSR)\nThe  value  of  the  BSR  indicates  the  bank  in  data memory;  the  eight  bits  in  the  instruction  show  the location in the bank and can be thought of as an offset from  the  bank's  lower  boundary.  The  relationship between the BSR's value and the bank division in data memory is shown in Figure 4-5.\nSince up to 64 registers may share the same low-order address, the user must always be careful to ensure that the proper bank is selected before performing a data read  or  write.  For  example,  writing  what  should  be program data to an 8-bit address of F9h while the BSR is 3Fh will end up corrupting the Program Counter.\nWhile any bank can be selected, only those banks that are  actually  implemented  can  be  read  or  written  to. Writes  to  unimplemented  banks  are  ignored,  while reads from unimplemented banks will return ' 0 's. Even so, the STATUS register will still be affected as if the operation was successful. The data memory maps in Figure 4-5 indicate which banks are implemented.",
    "FIGURE 4-4: DATA MEMORY MAP FOR PIC18(L)F25/26K83 DEVICES\n\nNote 1: Depends on the number of SFRs. Refer subsequent SFR tables.\nBank 0, BSR<5:0> = 00 0000. Bank 0, addr<7:0> = 00h. Bank 0, PIC18(L)F25K83 = Access RAM GPR. Bank 0, PIC18(L)F26K83 = Access RAM GPR. Bank 0, Address addr<13:0> = 0000h 005Fh 0060h. Bank 0,  = . Bank 0,  = . Bank 1, BSR<5:0> = 00 0001. Bank 1, addr<7:0> = 00h FFh. Bank 1, PIC18(L)F25K83 = GPR. Bank 1, PIC18(L)F26K83 = . Bank 1, Address addr<13:0> = 0100h. Bank 1,  = . Bank 1,",
    "FIGURE 4-4: DATA MEMORY MAP FOR PIC18(L)F25/26K83 DEVICES\n= . Bank 2, BSR<5:0> = 00 0010. Bank 2, addr<7:0> = 00h FFh. Bank 2, PIC18(L)F25K83 = . Bank 2, PIC18(L)F26K83 = GPR. Bank 2, Address addr<13:0> = \u2022 \u2022 \u2022. Bank 2,  = . Bank 2,  = . Bank 3, BSR<5:0> = 00 0011. Bank 3, addr<7:0> = 00h FFh 00h. Bank 3, PIC18(L)F25K83 = . Bank 3, PIC18(L)F26K83 = GPR. Bank 3, Address addr<13:0> = 03FFh 0400h \u2022. Bank 3,  = . Bank 3,",
    "FIGURE 4-4: DATA MEMORY MAP FOR PIC18(L)F25/26K83 DEVICES\n= . Banks 4 to 7, BSR<5:0> = 00 0100 - 00 0111. Banks 4 to 7, addr<7:0> = \u2022 \u2022 FFh 00h \u2022. Banks 4 to 7, PIC18(L)F25K83 = GPR. Banks 4 to 7, PIC18(L)F26K83 = . Banks 4 to 7, Address addr<13:0> = \u2022 07FFh 0800h \u2022. Banks 4 to 7,  = . Banks 4 to 7,",
    "FIGURE 4-4: DATA MEMORY MAP FOR PIC18(L)F25/26K83 DEVICES\n= . Banks 8 to 15 Banks, BSR<5:0> = 00 1000 - 00 1111 01 0000. Banks 8 to 15 Banks, addr<7:0> = \u2022 FFh 00h \u2022. Banks 8 to 15 Banks, PIC18(L)F25K83 = Unimplemented. Banks 8 to 15 Banks, PIC18(L)F26K83 = GPR. Banks 8 to 15 Banks, Address addr<13:0> = \u2022 0FFFh 1000h \u2022. Banks 8 to 15 Banks,  = Virtual Bank Access RAM SFR. Banks 8 to 15 Banks,",
    "FIGURE 4-4: DATA MEMORY MAP FOR PIC18(L)F25/26K83 DEVICES\n= 00h 5Fh 60h. 16 to 31 Banks 32 to 53, BSR<5:0> = - 01 1111 10 0000 -. 16 to 31 Banks 32 to 53, addr<7:0> = \u2022 FFh 00h \u2022 \u2022 \u2022. 16 to 31 Banks 32 to 53, PIC18(L)F25K83 = . 16 to 31 Banks 32 to 53, PIC18(L)F26K83 = Unimplemented. 16 to 31 Banks 32 to 53, Address addr<13:0> = \u2022 1FFFh 2000 \u2022 \u2022 \u2022 37FF. 16 to 31 Banks 32 to 53,  = . 16 to 31 Banks 32 to 53,",
    "FIGURE 4-4: DATA MEMORY MAP FOR PIC18(L)F25/26K83 DEVICES\n= FFh. Bank 54, BSR<5:0> = 11 0111 d54. Bank 54, addr<7:0> = FFh 00h \u2022. Bank 54, PIC18(L)F25K83 = CAN Test. Bank 54, PIC18(L)F26K83 = CAN Test. Bank 54, Address addr<13:0> = 3600h \u2022. Bank 54,  = . Bank 54,  = . Bank 55, BSR<5:0> = d55. Bank 55, addr<7:0> = FFh 00h \u2022 FFh. Bank 55, PIC18(L)F25K83 = CAN SFR. Bank 55, PIC18(L)F26K83 = CAN SFR. Bank 55, Address addr<13:0> = 36FFh 3700h \u2022 37FFh. Bank 55,  = . Bank 55,",
    "FIGURE 4-4: DATA MEMORY MAP FOR PIC18(L)F25/26K83 DEVICES\n= . Banks 56 to 62, BSR<5:0> = 11 1000 - 11 1110. Banks 56 to 62, addr<7:0> = 00h \u2022 \u2022. Banks 56 to 62, PIC18(L)F25K83 = SFR. Banks 56 to 62, PIC18(L)F26K83 = SFR. Banks 56 to 62, Address addr<13:0> = 3800h \u2022 \u2022. Banks 56 to 62,  = . Banks 56 to 62,  = . Bank 63, BSR<5:0> = 11 1111. Bank 63, addr<7:0> = FFh 00h. Bank 63, PIC18(L)F25K83 = SFR. Bank 63, PIC18(L)F26K83 = SFR. Bank 63, Address addr<13:0> = 3EFFh 3F00h 3F5Fh 3F60h. Bank 63,  = . Bank 63,  = ",
    "4.5.2 GENERAL PURPOSE REGISTER FILE\nGeneral Purpose RAM is available starting Bank 0 of data memory. GPRs are not initialized by a Power-on Reset and are unchanged on all other Resets.",
    "4.5.3 SPECIAL FUNCTION REGISTERS\nThe Special Function Registers (SFRs) are registers used by the CPU and peripheral modules for controlling the desired operation of the device. These registers are implemented as static RAM. SFRs start at the top of data memory (3FFFh) and extend downward to occupy Bank 56 through 63 (3800h to 3FFFh). A list of these registers is given in Table 4-3 to Table 4-10. A bitwise summary of these registers can be found in Section 43.0 'Register Summary' .",
    "4.5.4 ACCESS BANK\nTo streamline access for the most commonly used data memory locations, the data memory is configured with an  Access  Bank,  which  allows  users  to  access  a mapped block of memory without specifying  a  BSR. The  Access  Bank  consists  of  the  first  96  bytes  of memory (00h 5Fh) in Bank 0 and the last 160 bytes of -memory (60h FFh) in Bank 63. The lower half is known -as the 'Access RAM' and is composed of GPRs. This upper half is also where some of the SFRs of the device are mapped. These two areas are mapped contiguously in the Access Bank and can be addressed linearly by an 8-bit address (Figure 4-5).\nThe Access Bank is used by core PIC18 instructions that include the Access RAM bit (the 'a' parameter in the instruction). When 'a' is equal to ' 1 ', the instruction uses  the  BSR  and  the  8-bit  address  included  in  the opcode for the data memory address. When 'a' is ' 0 ', however, the instruction uses the Access Bank address map; the current value of the BSR is ignored.",
    "4.5.4 ACCESS BANK\nUsing this 'forced' addressing allows the instruction to operate on a data address in a single cycle, without updating the BSR first. For 8-bit addresses of 60h and above, this means that users can evaluate and operate on SFRs more efficiently. The Access RAM below 60h is a good place for data values that the user might need to  access  rapidly,  such  as  immediate  computational results  or  common  program  variables. Access  RAM also  allows  for  faster  and  more  code  efficient  and switching of variables.\nThe mapping of the Access Bank is slightly  different when the extended instruction set is enabled (XINST Configuration bit = 1 ). This is discussed in more detail in Section  4.8.3 'Mapping  the  Access  Bank  in Indexed Literal Offset Mode' .",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3FFEh, TOSU = TOSH 3FDEh. 3FFEh, 3FDFh = POSTINC2. 3FFEh, INDF2 = 3FBEh. 3FFEh, 3FBFh = -. 3FFEh, - = 3F9Eh. 3FFEh, 3F9Fh = T4TMR. 3FFEh, T4PR = 3F7Eh. 3FFEh, 3F7Fh = CCP1CON. 3FFEh, CCP1CAP = 3F5Eh. 3FFEh, 3F5Fh = CCPTMRS0. 3FFEh, CCPTMRS1 = 3F3Eh. 3FFEh, 3F3Fh = NCO1CON. 3FFEh, NCO1CLK = 3F1Eh. 3FFEh, 3F1Fh = . 3FFEh, SMT1CON1 = SMT1CON0. 3FFDh TOSL, TOSU = 3FDDh. 3FFDh TOSL, 3FDFh =",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\nPOSTDEC2. 3FFDh TOSL, INDF2 = 3FBDh. 3FFDh TOSL, 3FBFh = -. 3FFDh TOSL, - = 3F9Dh. 3FFDh TOSL, 3F9Fh = T5CLK. 3FFDh TOSL, T4PR = 3F7Dh. 3FFDh TOSL, 3F7Fh = CCPR1H. 3FFDh TOSL, CCP1CAP = 3F5Dh. 3FFDh TOSL, 3F5Fh = -. 3FFDh TOSL, CCPTMRS1 = 3F3Dh. 3FFDh TOSL, 3F3Fh = NCO1INCU. 3FFDh TOSL, NCO1CLK = 3F1Dh. 3FFDh TOSL, 3F1Fh = . 3FFDh TOSL, SMT1CON1 = SMT1PRU. 3FFCh, TOSU = STKPTR 3FDCh. 3FFCh, 3FDFh",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n= PRECIN2. 3FFCh, INDF2 = 3FBCh. 3FFCh, 3FBFh = LATC. 3FFCh, - = 3F9Ch. 3FFCh, 3F9Fh = T5GATE. 3FFCh, T4PR = 3F7Ch. 3FFCh, 3F7Fh = CCPR1L. 3FFCh, CCP1CAP = 3F5Ch. 3FFCh, 3F5Fh = -. 3FFCh, CCPTMRS1 = 3F3Ch. 3FFCh, 3F3Fh = NCO1INCH. 3FFCh, NCO1CLK = 3F1Ch. 3FFCh, 3F1Fh = . 3FFCh, SMT1CON1 = SMT1PRH. 3FFBh, TOSU = PCLATU 3FDBh. 3FFBh, 3FDFh = PLUSW2. 3FFBh, INDF2 = 3FBBh. 3FFBh, 3FBFh =",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\nLATB. 3FFBh, - = 3F9Bh. 3FFBh, 3F9Fh = T5GCON. 3FFBh, T4PR = 3F7Bh. 3FFBh, 3F7Fh = CCP2CAP. 3FFBh, CCP1CAP = 3F5Bh. 3FFBh, 3F5Fh = -. 3FFBh, CCPTMRS1 = 3F3Bh. 3FFBh, 3F3Fh = NCO1INCL. 3FFBh, NCO1CLK = 3F1Bh. 3FFBh, 3F1Fh = . 3FFBh, SMT1CON1 = SMT1PRL. 3FFAh, TOSU = PCLATH 3FDAh. 3FFAh, 3FDFh = FSR2H. 3FFAh, INDF2 = 3FBAh. 3FFAh, 3FBFh = LATA. 3FFAh, - = 3F9Ah. 3FFAh, 3F9Fh =",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\nT5CON. 3FFAh, T4PR = 3F7Ah. 3FFAh, 3F7Fh = CCP2CON. 3FFAh, CCP1CAP = 3F5Ah. 3FFAh, 3F5Fh = CWG1STR. 3FFAh, CCPTMRS1 = 3F3Ah. 3FFAh, 3F3Fh = NCO1ACCU. 3FFAh, NCO1CLK = 3F1Ah. 3FFAh, 3F1Fh = . 3FFAh, SMT1CON1 = SMT1CPWU. 3FF9h PCL, TOSU = 3FD9h. 3FF9h PCL, 3FDFh = FSR2L. 3FF9h PCL, INDF2 = 3FB9h. 3FF9h PCL, 3FBFh = T0CON1. 3FF9h PCL, - = 3F99h. 3FF9h PCL, 3F9Fh =",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\nTMR5H. 3FF9h PCL, T4PR = 3F79h. 3FF9h PCL, 3F7Fh = CCPR2H. 3FF9h PCL, CCP1CAP = 3F59h. 3FF9h PCL, 3F5Fh = CWG1AS1. 3FF9h PCL, CCPTMRS1 = 3F39h. 3FF9h PCL, 3F3Fh = NCO1ACCH. 3FF9h PCL, NCO1CLK = 3F19h. 3FF9h PCL, 3F1Fh = . 3FF9h PCL, SMT1CON1 = SMT1CPWH. 3FF8h TBLPRTU, TOSU = 3FD8h. 3FF8h TBLPRTU, 3FDFh = STATUS. 3FF8h TBLPRTU, INDF2 = 3FB8h. 3FF8h TBLPRTU, 3FBFh",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n= T0CON0. 3FF8h TBLPRTU, - = 3F98h. 3FF8h TBLPRTU, 3F9Fh = TMR5L. 3FF8h TBLPRTU, T4PR = 3F78h. 3FF8h TBLPRTU, 3F7Fh = CCPR2L. 3FF8h TBLPRTU, CCP1CAP = 3F58h. 3FF8h TBLPRTU, 3F5Fh = CWG1AS0. 3FF8h TBLPRTU, CCPTMRS1 = 3F38h. 3FF8h TBLPRTU, 3F3Fh = NCO1ACCL. 3FF8h TBLPRTU, NCO1CLK = 3F18h. 3FF8h TBLPRTU, 3F1Fh = . 3FF8h TBLPRTU, SMT1CON1 = SMT1CPWL. 3FF7h TBLPTRH,",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\nTOSU = 3FD7h. 3FF7h TBLPTRH, 3FDFh = IVTBASEU. 3FF7h TBLPTRH, INDF2 = 3FB7h. 3FF7h TBLPTRH, 3FBFh = TMR0H. 3FF7h TBLPTRH, - = 3F97h. 3FF7h TBLPTRH, 3F9Fh = T6RST. 3FF7h TBLPTRH, T4PR = 3F77h. 3FF7h TBLPTRH, 3F7Fh = CCP3CAP. 3FF7h TBLPTRH, CCP1CAP = 3F57h. 3FF7h TBLPTRH, 3F5Fh = CWG1CON1. 3FF7h TBLPTRH, CCPTMRS1 = 3F37h. 3FF7h TBLPTRH, 3F3Fh = -. 3FF7h TBLPTRH,",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\nNCO1CLK = 3F17h. 3FF7h TBLPTRH, 3F1Fh = . 3FF7h TBLPTRH, SMT1CON1 = SMT1CPRU. 3FF6h, TOSU = TBLPTRL 3FD6h. 3FF6h, 3FDFh = IVTBASEH. 3FF6h, INDF2 = 3FB6h. 3FF6h, 3FBFh = TMR0L. 3FF6h, - = 3F96h. 3FF6h, 3F9Fh = T6CLK. 3FF6h, T4PR = 3F76h. 3FF6h, 3F7Fh = CCP3CON. 3FF6h, CCP1CAP = 3F56h. 3FF6h, 3F5Fh = CWG1CON0. 3FF6h, CCPTMRS1 = 3F36h. 3FF6h, 3F3Fh =",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n-. 3FF6h, NCO1CLK = 3F16h. 3FF6h, 3F1Fh = . 3FF6h, SMT1CON1 = SMT1CPRH. 3FF5h, TOSU = TABLAT 3FD5h. 3FF5h, 3FDFh = IVTBASEL. 3FF5h, INDF2 = 3FB5h. 3FF5h, 3FBFh = T1CLK. 3FF5h, - = 3F95h. 3FF5h, 3F9Fh = T6HLT. 3FF5h, T4PR = 3F75h. 3FF5h, 3F7Fh = CCPR3H. 3FF5h, CCP1CAP = 3F55h. 3FF5h, 3F5Fh = CWG1DBF. 3FF5h, CCPTMRS1 = 3F35h. 3FF5h, 3F3Fh = -.",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3FF5h, NCO1CLK = . 3FF5h, 3F1Fh = 3F15h. 3FF5h, SMT1CON1 = SMT1CPRL. 3FF4h, TOSU = PRODH 3FD4h. 3FF4h, 3FDFh = IVTLOCK. 3FF4h, INDF2 = 3FB4h. 3FF4h, 3FBFh = T1GATE. 3FF4h, - = 3F94h. 3FF4h, 3F9Fh = T6CON. 3FF4h, T4PR = 3F74h. 3FF4h, 3F7Fh = CCPR3L. 3FF4h, CCP1CAP = 3F54h. 3FF4h, 3F5Fh = CWG1DBR. 3FF4h, CCPTMRS1 = 3F34h. 3FF4h, 3F3Fh = -. 3FF4h,",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\nNCO1CLK = 3F14h. 3FF4h, 3F1Fh = . 3FF4h, SMT1CON1 = SMT1TMRU. 3FF3h, TOSU = PRODL 3FD3h. 3FF3h, 3FDFh = INTCON1. 3FF3h, INDF2 = 3FB3h. 3FF3h, 3FBFh = T1GCON. 3FF3h, - = 3F93h. 3FF3h, 3F9Fh = T6PR. 3FF3h, T4PR = 3F73h. 3FF3h, 3F7Fh = CCP4CAP. 3FF3h, CCP1CAP = 3F53h. 3FF3h, 3F5Fh = CWG1ISM. 3FF3h, CCPTMRS1 = 3F33h. 3FF3h, 3F3Fh = -. 3FF3h, NCO1CLK =",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3F13h. 3FF3h, 3F1Fh = . 3FF3h, SMT1CON1 = SMT1TMRH. 3FF2h, TOSU = - 3FD2h. 3FF2h, 3FDFh = INTCON0. 3FF2h, INDF2 = 3FB2h. 3FF2h, 3FBFh = T1CON. 3FF2h, - = 3F92h. 3FF2h, 3F9Fh = T6TMR. 3FF2h, T4PR = 3F72h. 3FF2h, 3F7Fh = CCP4CON. 3FF2h, CCP1CAP = 3F52h. 3FF2h, 3F5Fh = CWG1CLK. 3FF2h, CCPTMRS1 = 3F32h. 3FF2h, 3F3Fh = -. 3FF2h, NCO1CLK = 3F12h.",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3FF2h, 3F1Fh = . 3FF2h, SMT1CON1 = SMT1TMRL. 3FF1h, TOSU = PCON1. 3FF1h, 3FDFh = -. 3FF1h, INDF2 = 3FB1h. 3FF1h, 3FBFh = TMR1H. 3FF1h, - = 3F91h. 3FF1h, 3F9Fh = -. 3FF1h, T4PR = 3F71h. 3FF1h, 3F7Fh = CCPR4H. 3FF1h, CCP1CAP = 3F51h. 3FF1h, 3F5Fh = CWG2STR. 3FF1h, CCPTMRS1 = 3F31h. 3FF1h, 3F3Fh = -. 3FF1h, NCO1CLK = . 3FF1h, 3F1Fh = 3F11h.",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3FF1h, SMT1CON1 = -. 3FF0h PCON0, TOSU = 3FD1h 3FD0h. 3FF0h PCON0, 3FDFh = -. 3FF0h PCON0, INDF2 = 3FB0h. 3FF0h PCON0, 3FBFh = TMR1L. 3FF0h PCON0, - = 3F90h. 3FF0h PCON0, 3F9Fh = -. 3FF0h PCON0, T4PR = 3F70h. 3FF0h PCON0, 3F7Fh = CCPR4L. 3FF0h PCON0, CCP1CAP = 3F50h. 3FF0h PCON0, 3F5Fh = CWG2AS1. 3FF0h PCON0, CCPTMRS1 = 3F30h. 3FF0h PCON0, 3F3Fh = -. 3FF0h",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\nPCON0, NCO1CLK = 3F10h. 3FF0h PCON0, 3F1Fh = . 3FF0h PCON0, SMT1CON1 = -. 3FEFh, TOSU = INDF0 3FCFh. 3FEFh, 3FDFh = -. 3FEFh, INDF2 = 3FAFh. 3FEFh, 3FBFh = T2RST. 3FEFh, - = 3F8Fh. 3FEFh, 3F9Fh = -. 3FEFh, T4PR = 3F6Fh. 3FEFh, 3F7Fh = -. 3FEFh, CCP1CAP = 3F4Fh. 3FEFh, 3F5Fh = CWG2AS0. 3FEFh, CCPTMRS1 = 3F2Fh. 3FEFh, 3F3Fh = -. 3FEFh, NCO1CLK =",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3F0Fh. 3FEFh, 3F1Fh = . 3FEFh, SMT1CON1 = -. 3FEEh, TOSU = POSTINC0 3FCEh. 3FEEh, 3FDFh = PORTE. 3FEEh, INDF2 = 3FAEh. 3FEEh, 3FBFh = T2CLK. 3FEEh, - = 3F8Eh. 3FEEh, 3F9Fh = -. 3FEEh, T4PR = 3F6Eh. 3FEEh, 3F7Fh = PWM5CON. 3FEEh, CCP1CAP = 3F4Eh. 3FEEh, 3F5Fh = CWG2CON1. 3FEEh, CCPTMRS1 = 3F2Eh. 3FEEh, 3F3Fh = -. 3FEEh, NCO1CLK = 3F0Eh. 3FEEh, 3F1Fh = . 3FEEh, SMT1CON1 = -.",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3FEDh, TOSU = POSTDEC0 3FCDh. 3FEDh, 3FDFh = -. 3FEDh, INDF2 = 3FADh. 3FEDh, 3FBFh = T2HLT. 3FEDh, - = 3F8Dh. 3FEDh, 3F9Fh = -. 3FEDh, T4PR = 3F6Dh. 3FEDh, 3F7Fh = PWM5DCH. 3FEDh, CCP1CAP = . 3FEDh, 3F5Fh = 3F4Dh CWG2CON0. 3FEDh, CCPTMRS1 = 3F2Dh. 3FEDh, 3F3Fh = -. 3FEDh, NCO1CLK = . 3FEDh, 3F1Fh = 3F0Dh. 3FEDh, SMT1CON1 = -. 3FECh, TOSU = PRECIN0 3FCCh. 3FECh, 3FDFh = PORTC. 3FECh,",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\nINDF2 = 3FACh. 3FECh, 3FBFh = T2CON. 3FECh, - = 3F8Ch. 3FECh, 3F9Fh = -. 3FECh, T4PR = 3F6Ch. 3FECh, 3F7Fh = PWM5DCL. 3FECh, CCP1CAP = 3F4Ch. 3FECh, 3F5Fh = CWG2DBF. 3FECh, CCPTMRS1 = 3F2Ch. 3FECh, 3F3Fh = -. 3FECh, NCO1CLK = . 3FECh, 3F1Fh = 3F0Ch. 3FECh, SMT1CON1 = -. 3FEBh, TOSU = PLUSW0 3FCBh. 3FEBh, 3FDFh = PORTB. 3FEBh, INDF2 = 3FABh. 3FEBh, 3FBFh = T2PR. 3FEBh, - = 3F8Bh.",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3FEBh, 3F9Fh = -. 3FEBh, T4PR = 3F6Bh. 3FEBh, 3F7Fh = -. 3FEBh, CCP1CAP = 3F4Bh. 3FEBh, 3F5Fh = CWG2DBR. 3FEBh, CCPTMRS1 = 3F2Bh. 3FEBh, 3F3Fh = -. 3FEBh, NCO1CLK = . 3FEBh, 3F1Fh = 3F0Bh. 3FEBh, SMT1CON1 = -. 3FEAh, TOSU = FSR0H 3FCAh. 3FEAh, 3FDFh = -. 3FEAh, INDF2 = 3FAAh. 3FEAh, 3FBFh = T2TMR. 3FEAh, - = 3F8Ah. 3FEAh, 3F9Fh = -. 3FEAh, T4PR = 3F6Ah. 3FEAh, 3F7Fh =",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\nPWM6CON. 3FEAh, CCP1CAP = 3F4Ah. 3FEAh, 3F5Fh = CWG2ISM. 3FEAh, CCPTMRS1 = . 3FEAh, 3F3Fh = 3F2Ah -. 3FEAh, NCO1CLK = . 3FEAh, 3F1Fh = 3F0Ah. 3FEAh, SMT1CON1 = -. 3FE9h FSR0L, TOSU = 3FC9h. 3FE9h FSR0L, 3FDFh = -. 3FE9h FSR0L, INDF2 = 3FA9h. 3FE9h FSR0L, 3FBFh = T3CLK. 3FE9h FSR0L, - = 3F89h. 3FE9h FSR0L, 3F9Fh = -. 3FE9h FSR0L, T4PR = 3F69h. 3FE9h",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\nFSR0L, 3F7Fh = PWM6DCH. 3FE9h FSR0L, CCP1CAP = 3F49h. 3FE9h FSR0L, 3F5Fh = CWG2CLK. 3FE9h FSR0L, CCPTMRS1 = 3F29h. 3FE9h FSR0L, 3F3Fh = -. 3FE9h FSR0L, NCO1CLK = 3F09h. 3FE9h FSR0L, 3F1Fh = . 3FE9h FSR0L, SMT1CON1 = -. 3FE8h, TOSU = WREG 3FC8h. 3FE8h, 3FDFh = -. 3FE8h, INDF2 = 3FA8h. 3FE8h, 3FBFh = T3GATE. 3FE8h, - = 3F88h. 3FE8h, 3F9Fh = -.",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3FE8h, T4PR = 3F68h. 3FE8h, 3F7Fh = PWM6DCL. 3FE8h, CCP1CAP = 3F48h. 3FE8h, 3F5Fh = CWG3STR. 3FE8h, CCPTMRS1 = . 3FE8h, 3F3Fh = 3F28h -. 3FE8h, NCO1CLK = 3F08h. 3FE8h, 3F1Fh = . 3FE8h, SMT1CON1 = -. 3FE7h INDF1, TOSU = 3FC7h. 3FE7h INDF1, 3FDFh = -. 3FE7h INDF1, INDF2 = 3FA7h. 3FE7h INDF1, 3FBFh = T3GCON. 3FE7h INDF1, - = 3F87h. 3FE7h INDF1, 3F9Fh",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n= -. 3FE7h INDF1, T4PR = 3F67h. 3FE7h INDF1, 3F7Fh = -. 3FE7h INDF1, CCP1CAP = 3F47h. 3FE7h INDF1, 3F5Fh = CWG3AS1. 3FE7h INDF1, CCPTMRS1 = . 3FE7h INDF1, 3F3Fh = 3F27h -. 3FE7h INDF1, NCO1CLK = 3F07h. 3FE7h INDF1, 3F1Fh = . 3FE7h INDF1, SMT1CON1 = -. 3FE6h POSTINC1, TOSU = 3FC6h. 3FE6h POSTINC1, 3FDFh = -. 3FE6h POSTINC1, INDF2 = 3FA6h. 3FE6h POSTINC1, 3FBFh = T3CON.",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3FE6h POSTINC1, - = 3F86h. 3FE6h POSTINC1, 3F9Fh = -. 3FE6h POSTINC1, T4PR = 3F66h. 3FE6h POSTINC1, 3F7Fh = PWM7CON. 3FE6h POSTINC1, CCP1CAP = 3F46h. 3FE6h POSTINC1, 3F5Fh = CWG3AS0. 3FE6h POSTINC1, CCPTMRS1 = . 3FE6h POSTINC1, 3F3Fh = 3F26h -. 3FE6h POSTINC1, NCO1CLK = 3F06h. 3FE6h POSTINC1, 3F1Fh = . 3FE6h POSTINC1, SMT1CON1 = -. 3FE5h, TOSU = POSTDEC1 3FC5h. 3FE5h, 3FDFh =",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n-. 3FE5h, INDF2 = 3FA5h. 3FE5h, 3FBFh = TMR3H. 3FE5h, - = 3F85h. 3FE5h, 3F9Fh = -. 3FE5h, T4PR = 3F65h. 3FE5h, 3F7Fh = PWM7DCH. 3FE5h, CCP1CAP = . 3FE5h, 3F5Fh = 3F45h CWG3CON1. 3FE5h, CCPTMRS1 = 3F25h. 3FE5h, 3F3Fh = -. 3FE5h, NCO1CLK = 3F05h. 3FE5h, 3F1Fh = . 3FE5h, SMT1CON1 = -. 3FE4h, TOSU = PRECIN1 3FC4h. 3FE4h, 3FDFh = TRISC. 3FE4h, INDF2 =",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3FA4h. 3FE4h, 3FBFh = TMR3L. 3FE4h, - = 3F84h. 3FE4h, 3F9Fh = -. 3FE4h, T4PR = 3F64h. 3FE4h, 3F7Fh = PWM7DCL. 3FE4h, CCP1CAP = 3F44h. 3FE4h, 3F5Fh = CWG3CON0. 3FE4h, CCPTMRS1 = 3F24h. 3FE4h, 3F3Fh = -. 3FE4h, NCO1CLK = 3F04h. 3FE4h, 3F1Fh = . 3FE4h, SMT1CON1 = -. 3FE3h, TOSU = PLUSW1 3FC3h. 3FE3h, 3FDFh = TRISB. 3FE3h, INDF2 = 3FA3h. 3FE3h,",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3FBFh = T4RST. 3FE3h, - = 3F83h. 3FE3h, 3F9Fh = -. 3FE3h, T4PR = 3F63h. 3FE3h, 3F7Fh = -. 3FE3h, CCP1CAP = . 3FE3h, 3F5Fh = 3F43h CWG3DBF. 3FE3h, CCPTMRS1 = 3F23h. 3FE3h, 3F3Fh = SMT1WIN. 3FE3h, NCO1CLK = 3F03h. 3FE3h, 3F1Fh = . 3FE3h, SMT1CON1 = -. 3FE2h, TOSU = FSR1H 3FC2h. 3FE2h, 3FDFh = TRISA. 3FE2h, INDF2 = 3FA2h. 3FE2h, 3FBFh = T4CLK.",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3FE2h, - = 3F82h. 3FE2h, 3F9Fh = -. 3FE2h, T4PR = 3F62h. 3FE2h, 3F7Fh = PWM8CON. 3FE2h, CCP1CAP = . 3FE2h, 3F5Fh = 3F42h. 3FE2h, CCPTMRS1 = CWG3DBR. 3FE2h, 3F3Fh = 3F22h. 3FE2h, NCO1CLK = SMT1SIG. 3FE2h, 3F1Fh = 3F02h. 3FE2h, SMT1CON1 = -. 3FE1h, TOSU = FSR1L 3FC1h. 3FE1h, 3FDFh = -. 3FE1h, INDF2 = 3FA1h. 3FE1h, 3FBFh = T4HLT. 3FE1h, - =",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3F81h. 3FE1h, 3F9Fh = -. 3FE1h, T4PR = 3F61h. 3FE1h, 3F7Fh = PWM8DCH. 3FE1h, CCP1CAP = 3F41h. 3FE1h, 3F5Fh = CWG3ISM. 3FE1h, CCPTMRS1 = 3F21h. 3FE1h, 3F3Fh = SMT1CLK. 3FE1h, NCO1CLK = . 3FE1h, 3F1Fh = 3F01h. 3FE1h, SMT1CON1 = -. 3FE0h, TOSU = BSR 3FC0h. 3FE0h, 3FDFh = -. 3FE0h, INDF2 = 3FA0h. 3FE0h, 3FBFh = T4CON. 3FE0h, - = 3F80h. 3FE0h,",
    "TABLE 4-3: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 63\n3F9Fh = -. 3FE0h, T4PR = 3F60h. 3FE0h, 3F7Fh = PWM8DCL. 3FE0h, CCP1CAP = . 3FE0h, 3F5Fh = 3F40h CWG3CLK. 3FE0h, CCPTMRS1 = 3F20h. 3FE0h, 3F3Fh = SMT1STAT. 3FE0h, NCO1CLK = 3F00h. 3FE0h, 3F1Fh = . 3FE0h, SMT1CON1 = -\n- 2: Unimplemented data memory locations and registers, read as ' 0 '.",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EFEh, ADCLK = ADACT. 3EFEh, 3EDFh = 3EDEh. 3EFEh, ADLTHH = ADLTHL 3EBEh. 3EFEh, 3EBFh = CM1NCH. 3EFEh, CM1PCH = . 3EFEh, 3E9Fh = 3E9Eh. 3EFEh, - = DAC1CON0. 3EFEh, 3E7Fh = 3E7Eh -. 3EFEh, - = 3E5Eh. 3EFEh, 3E5Fh = -. 3EFEh, - = 3E3Eh. 3EFEh, 3E3Fh = -. 3EFEh, - = . 3EFEh, 3E1Fh = 3E1Eh. 3EFEh, - = -. 3EFDh, ADCLK = ADREF. 3EFDh, 3EDFh = 3EDDh - -. 3EFDh, ADLTHH = 3EBDh. 3EFDh, 3EBFh =",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\nCM1CON1. 3EFDh, CM1PCH = 3E9Dh. 3EFDh, 3E9Fh = -. 3EFDh, - = 3E7Dh. 3EFDh, 3E7Fh = -. 3EFDh, - = 3E5Dh. 3EFDh, 3E5Fh = -. 3EFDh, - = . 3EFDh, 3E3Fh = 3E3Dh -. 3EFDh, - = 3E1Dh. 3EFDh, 3E1Fh = . 3EFDh, - = -. 3EFCh, ADCLK = ADSTAT. 3EFCh, 3EDFh = 3EDCh. 3EFCh, ADLTHH = 3EBCh. 3EFCh, 3EBFh = CM1CON0. 3EFCh, CM1PCH = 3E9Ch. 3EFCh, 3E9Fh = DAC1CON1. 3EFCh, - = 3E7Ch. 3EFCh, 3E7Fh =",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n-. 3EFCh, - = 3E5Ch. 3EFCh, 3E5Fh = -. 3EFCh, - = . 3EFCh, 3E3Fh = 3E3Ch -. 3EFCh, - = 3E1Ch. 3EFCh, 3E1Fh = . 3EFCh, - = -. 3EFBh, ADCLK = ADCON3. 3EFBh, 3EDFh = 3EDBh. 3EFBh, ADLTHH = - 3EBBh. 3EFBh, 3EBFh = CM2PCH. 3EFBh, CM1PCH = 3E9Bh. 3EFBh, 3E9Fh = -. 3EFBh, - = 3E7Bh. 3EFBh, 3E7Fh = -. 3EFBh, - = 3E5Bh. 3EFBh, 3E5Fh = -. 3EFBh, - = . 3EFBh, 3E3Fh = 3E3Bh -. 3EFBh, - =",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3E1Bh. 3EFBh, 3E1Fh = . 3EFBh, - = -. 3EFAh, ADCLK = ADCON2. 3EFAh, 3EDFh = 3EDAh. 3EFAh, ADLTHH = - 3EBAh. 3EFAh, 3EBFh = CM2NCH. 3EFAh, CM1PCH = 3E9Ah. 3EFAh, 3E9Fh = -. 3EFAh, - = 3E7Ah. 3EFAh, 3E7Fh = -. 3EFAh, - = 3E5Ah. 3EFAh, 3E5Fh = -. 3EFAh, - = . 3EFAh, 3E3Fh = 3E3Ah -. 3EFAh, - = . 3EFAh, 3E1Fh = 3E1Ah. 3EFAh, - = -. 3EF9h, ADCLK = ADCON1. 3EF9h, 3EDFh = 3ED9h.",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EF9h, ADLTHH = -. 3EF9h, 3EBFh = 3EB9h CM2CON1. 3EF9h, CM1PCH = 3E99h. 3EF9h, 3E9Fh = -. 3EF9h, - = 3E79h. 3EF9h, 3E7Fh = -. 3EF9h, - = 3E59h. 3EF9h, 3E5Fh = -. 3EF9h, - = . 3EF9h, 3E3Fh = 3E39h -. 3EF9h, - = . 3EF9h, 3E1Fh = 3E19h. 3EF9h, - = -. 3EF8h, ADCLK = ADCON0. 3EF8h, 3EDFh = 3ED8h. 3EF8h, ADLTHH = -. 3EF8h, 3EBFh = 3EB8h CM2CON0. 3EF8h,",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\nCM1PCH = 3E98h. 3EF8h, 3E9Fh = -. 3EF8h, - = 3E78h. 3EF8h, 3E7Fh = -. 3EF8h, - = . 3EF8h, 3E5Fh = 3E58h. 3EF8h, - = -. 3EF8h, 3E3Fh = 3E38h. 3EF8h, - = -. 3EF8h, 3E1Fh = 3E18h. 3EF8h, - = -. 3EF7h, ADCLK = ADPREH. 3EF7h, 3EDFh = 3ED7h. 3EF7h, ADLTHH = ADCP. 3EF7h, 3EBFh = 3EB7h -. 3EF7h, CM1PCH = 3E97h. 3EF7h, 3E9Fh = -. 3EF7h, - = 3E77h.",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EF7h, 3E7Fh = -. 3EF7h, - = . 3EF7h, 3E5Fh = 3E57h. 3EF7h, - = -. 3EF7h, 3E3Fh = 3E37h. 3EF7h, - = -. 3EF7h, 3E1Fh = 3E17h. 3EF7h, - = -. 3EF6h, ADCLK = ADPREL. 3EF6h, 3EDFh = 3ED6h. 3EF6h, ADLTHH = -. 3EF6h, 3EBFh = 3EB6h -. 3EF6h, CM1PCH = 3E96h. 3EF6h, 3E9Fh = -. 3EF6h, - = . 3EF6h, 3E7Fh = 3E76h. 3EF6h, - = -. 3EF6h, 3E5Fh = 3E56h.",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EF6h, - = -. 3EF6h, 3E3Fh = . 3EF6h, - = -. 3EF6h, 3E1Fh = 3E16h. 3EF6h, - = -. 3EF5h, ADCLK = ADCAP. 3EF5h, 3EDFh = 3ED5h. 3EF5h, ADLTHH = -. 3EF5h, 3EBFh = 3EB5h -. 3EF5h, CM1PCH = 3E95h. 3EF5h, 3E9Fh = -. 3EF5h, - = . 3EF5h, 3E7Fh = 3E75h -. 3EF5h, - = . 3EF5h, 3E5Fh = 3E55h. 3EF5h, - = -. 3EF5h, 3E3Fh = 3E36h 3E35h. 3EF5h, - = -. 3EF5h,",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3E1Fh = 3E15h. 3EF5h, - = -. 3EF4h, ADCLK = ADACQH. 3EF4h, 3EDFh = 3ED4h. 3EF4h, ADLTHH = -. 3EF4h, 3EBFh = 3EB4h -. 3EF4h, CM1PCH = 3E94h. 3EF4h, 3E9Fh = -. 3EF4h, - = 3E74h. 3EF4h, 3E7Fh = . 3EF4h, - = -. 3EF4h, 3E5Fh = 3E54h. 3EF4h, - = -. 3EF4h, 3E3Fh = 3E34h. 3EF4h, - = -. 3EF4h, 3E1Fh = 3E14h. 3EF4h, - = -. 3EF3h, ADCLK = ADACQL.",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EF3h, 3EDFh = 3ED3h. 3EF3h, ADLTHH = -. 3EF3h, 3EBFh = 3EB3h -. 3EF3h, CM1PCH = 3E93h. 3EF3h, 3E9Fh = -. 3EF3h, - = . 3EF3h, 3E7Fh = 3E73h -. 3EF3h, - = . 3EF3h, 3E5Fh = 3E53h. 3EF3h, - = -. 3EF3h, 3E3Fh = 3E33h. 3EF3h, - = -. 3EF3h, 3E1Fh = 3E13h. 3EF3h, - = -. 2EF2h, ADCLK = -. 2EF2h, 3EDFh = 3ED2h. 2EF2h, ADLTHH = -. 2EF2h, 3EBFh =",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EB2h. 2EF2h, CM1PCH = -. 2EF2h, 3E9Fh = 3E92h. 2EF2h, - = -. 2EF2h, 3E7Fh = 3E72h. 2EF2h, - = -. 2EF2h, 3E5Fh = 3E52h. 2EF2h, - = -. 2EF2h, 3E3Fh = -. 2EF2h, - = . 2EF2h, 3E1Fh = 3E12h. 2EF2h, - = -. 3EF1h, ADCLK = ADPCH. 3EF1h, 3EDFh = 3ED1h. 3EF1h, ADLTHH = -. 3EF1h, 3EBFh = 3EB1h -. 3EF1h, CM1PCH = 3E91h. 3EF1h, 3E9Fh = . 3EF1h, - =",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n-. 3EF1h, 3E7Fh = 3E71h. 3EF1h, - = -. 3EF1h, 3E5Fh = 3E51h. 3EF1h, - = -. 3EF1h, 3E3Fh = 3E32h 3E31h. 3EF1h, - = -. 3EF1h, 3E1Fh = 3E11h. 3EF1h, - = -. 3EF0h, ADCLK = ADRESH. 3EF0h, 3EDFh = 3ED0h. 3EF0h, ADLTHH = -. 3EF0h, 3EBFh = 3EB0h -. 3EF0h, CM1PCH = 3E90h. 3EF0h, 3E9Fh = -. 3EF0h, - = 3E70h. 3EF0h, 3E7Fh = -. 3EF0h, - = . 3EF0h,",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3E5Fh = 3E50h. 3EF0h, - = -. 3EF0h, 3E3Fh = 3E30h -. 3EF0h, - = . 3EF0h, 3E1Fh = 3E10h. 3EF0h, - = -. 3EEFh, ADCLK = ADRESL. 3EEFh, 3EDFh = 3ECFh. 3EEFh, ADLTHH = -. 3EEFh, 3EBFh = 3EAFh -. 3EEFh, CM1PCH = 3E8Fh. 3EEFh, 3E9Fh = -. 3EEFh, - = . 3EEFh, 3E7Fh = 3E6Fh. 3EEFh, - = -. 3EEFh, 3E5Fh = 3E4Fh. 3EEFh, - = -. 3EEFh, 3E3Fh = 3E2Fh.",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EEFh, - = -. 3EEFh, 3E1Fh = 3E0Fh. 3EEFh, - = -. 3EEEh, ADCLK = ADPREVH. 3EEEh, 3EDFh = 3ECEh. 3EEEh, ADLTHH = -. 3EEEh, 3EBFh = 3EAEh. 3EEEh, CM1PCH = - 3E8Eh. 3EEEh, 3E9Fh = -. 3EEEh, - = 3E6Eh. 3EEEh, 3E7Fh = . 3EEEh, - = -. 3EEEh, 3E5Fh = 3E4Eh. 3EEEh, - = -. 3EEEh, 3E3Fh = 3E2Eh. 3EEEh, - = -. 3EEEh, 3E1Fh = 3E0Eh. 3EEEh, - = -. 3EEDh, ADCLK = ADPREVL. 3EEDh, 3EDFh",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n= 3ECDh. 3EEDh, ADLTHH = -. 3EEDh, 3EBFh = 3EADh -. 3EEDh, CM1PCH = 3E8Dh. 3EEDh, 3E9Fh = . 3EEDh, - = -. 3EEDh, 3E7Fh = 3E6Dh. 3EEDh, - = -. 3EEDh, 3E5Fh = 3E4Dh. 3EEDh, - = -. 3EEDh, 3E3Fh = 3E2Dh. 3EEDh, - = -. 3EEDh, 3E1Fh = 3E0Dh. 3EEDh, - = -. 3EECh, ADCLK = ADRPT. 3EECh, 3EDFh = 3ECCh. 3EECh, ADLTHH = -. 3EECh, 3EBFh = 3EACh. 3EECh, CM1PCH = - 3E8Ch. 3EECh, 3E9Fh = -.",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EECh, - = . 3EECh, 3E7Fh = 3E6Ch. 3EECh, - = -. 3EECh, 3E5Fh = 3E4Ch. 3EECh, - = -. 3EECh, 3E3Fh = 3E2Ch. 3EECh, - = -. 3EECh, 3E1Fh = 3E0Ch. 3EECh, - = -. 3EEBh, ADCLK = ADCNT. 3EEBh, 3EDFh = 3ECBh. 3EEBh, ADLTHH = -. 3EEBh, 3EBFh = 3EABh -. 3EEBh, CM1PCH = 3E8Bh. 3EEBh, 3E9Fh = -. 3EEBh, - = . 3EEBh, 3E7Fh = 3E6Bh. 3EEBh, - = -. 3EEBh, 3E5Fh = 3E4Bh. 3EEBh, - = -. 3EEBh,",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3E3Fh = 3E2Bh -. 3EEBh, - = . 3EEBh, 3E1Fh = 3E0Bh. 3EEBh, - = -. 3EEAh, ADCLK = ADACCU. 3EEAh, 3EDFh = 3ECAh. 3EEAh, ADLTHH = HLVDCON1. 3EEAh, 3EBFh = 3EAAh -. 3EEAh, CM1PCH = 3E8Ah. 3EEAh, 3E9Fh = . 3EEAh, - = -. 3EEAh, 3E7Fh = 3E6Ah. 3EEAh, - = -. 3EEAh, 3E5Fh = 3E4Ah. 3EEAh, - = -. 3EEAh, 3E3Fh = 3E2Ah. 3EEAh, - = -. 3EEAh, 3E1Fh = 3E0Ah. 3EEAh, - = -. 3EE9h, ADCLK =",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\nADACCH. 3EE9h, 3EDFh = 3EC9h. 3EE9h, ADLTHH = HLVDCON0. 3EE9h, 3EBFh = 3EA9h -. 3EE9h, CM1PCH = 3E89h. 3EE9h, 3E9Fh = . 3EE9h, - = -. 3EE9h, 3E7Fh = 3E69h. 3EE9h, - = -. 3EE9h, 3E5Fh = 3E49h. 3EE9h, - = -. 3EE9h, 3E3Fh = 3E29h. 3EE9h, - = -. 3EE9h, 3E1Fh = 3E09h. 3EE9h, - = -. 3EE8h, ADCLK = ADACCL. 3EE8h, 3EDFh = 3EC8h. 3EE8h, ADLTHH = -.",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EE8h, 3EBFh = 3EA8h -. 3EE8h, CM1PCH = 3E88h. 3EE8h, 3E9Fh = . 3EE8h, - = -. 3EE8h, 3E7Fh = 3E68h. 3EE8h, - = -. 3EE8h, 3E5Fh = 3E48h. 3EE8h, - = -. 3EE8h, 3E3Fh = 3E28h -. 3EE8h, - = . 3EE8h, 3E1Fh = 3E08h. 3EE8h, - = -. 3EE7h, ADCLK = ADFLTRH. 3EE7h, 3EDFh = 3EC7h. 3EE7h, ADLTHH = -. 3EE7h, 3EBFh = 3EA7h -. 3EE7h, CM1PCH = 3E87h.",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EE7h, 3E9Fh = -. 3EE7h, - = . 3EE7h, 3E7Fh = 3E67h. 3EE7h, - = -. 3EE7h, 3E5Fh = 3E47h. 3EE7h, - = -. 3EE7h, 3E3Fh = 3E27h. 3EE7h, - = -. 3EE7h, 3E1Fh = 3E07h. 3EE7h, - = -. 3EE6h, ADCLK = ADFLTRL. 3EE6h, 3EDFh = 3EC6h. 3EE6h, ADLTHH = -. 3EE6h, 3EBFh = 3EA6h -. 3EE6h, CM1PCH = 3E86h. 3EE6h, 3E9Fh = -. 3EE6h, - = 3E66h. 3EE6h, 3E7Fh = .",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EE6h, - = -. 3EE6h, 3E5Fh = 3E46h. 3EE6h, - = -. 3EE6h, 3E3Fh = 3E26h. 3EE6h, - = -. 3EE6h, 3E1Fh = 3E06h. 3EE6h, - = -. 3EE5h, ADCLK = ADSTPTH. 3EE5h, 3EDFh = 3EC5h. 3EE5h, ADLTHH = -. 3EE5h, 3EBFh = 3EA5h. 3EE5h, CM1PCH = -. 3EE5h, 3E9Fh = 3E85h. 3EE5h, - = -. 3EE5h, 3E7Fh = 3E65h. 3EE5h, - = -. 3EE5h, 3E5Fh = 3E45h. 3EE5h, - = -. 3EE5h,",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3E3Fh = 3E25h. 3EE5h, - = -. 3EE5h, 3E1Fh = 3E05h. 3EE5h, - = -. 3EE4h, ADCLK = ADSTPTL. 3EE4h, 3EDFh = 3EC4h. 3EE4h, ADLTHH = -. 3EE4h, 3EBFh = 3EA4h -. 3EE4h, CM1PCH = 3E84h. 3EE4h, 3E9Fh = . 3EE4h, - = -. 3EE4h, 3E7Fh = 3E64h. 3EE4h, - = -. 3EE4h, 3E5Fh = 3E44h. 3EE4h, - = -. 3EE4h, 3E3Fh = 3E24h. 3EE4h, - = -. 3EE4h, 3E1Fh = 3E04h.",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EE4h, - = -. 3EE3h, ADCLK = ADERRH. 3EE3h, 3EDFh = 3EC3h. 3EE3h, ADLTHH = ZCDCON. 3EE3h, 3EBFh = 3EA3h. 3EE3h, CM1PCH = -. 3EE3h, 3E9Fh = 3E83h. 3EE3h, - = -. 3EE3h, 3E7Fh = 3E63h. 3EE3h, - = -. 3EE3h, 3E5Fh = 3E43h. 3EE3h, - = -. 3EE3h, 3E3Fh = 3E23h. 3EE3h, - = -. 3EE3h, 3E1Fh = 3E03h. 3EE3h, - = -. 3EE2h, ADCLK = ADERRL. 3EE2h, 3EDFh =",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EC2h. 3EE2h, ADLTHH = -. 3EE2h, 3EBFh = 3EA2h. 3EE2h, CM1PCH = -. 3EE2h, 3E9Fh = 3E82h. 3EE2h, - = -. 3EE2h, 3E7Fh = 3E62h. 3EE2h, - = -. 3EE2h, 3E5Fh = 3E42h. 3EE2h, - = -. 3EE2h, 3E3Fh = 3E22h. 3EE2h, - = -. 3EE2h, 3E1Fh = 3E02h. 3EE2h, - = -. 3EE1h, ADCLK = ADUTHH. 3EE1h, 3EDFh = 3EC1h. 3EE1h, ADLTHH = FVRCON. 3EE1h, 3EBFh = 3EA1h -.",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n3EE1h, CM1PCH = 3E81h. 3EE1h, 3E9Fh = . 3EE1h, - = -. 3EE1h, 3E7Fh = 3E61h. 3EE1h, - = -. 3EE1h, 3E5Fh = 3E41h. 3EE1h, - = -. 3EE1h, 3E3Fh = 3E21h. 3EE1h, - = -. 3EE1h, 3E1Fh = 3E01h. 3EE1h, - = -. , ADCLK = ADUTHL. , 3EDFh = . , ADLTHH = . , 3EBFh = . , CM1PCH = . , 3E9Fh = . , - = -. , 3E7Fh = . , - = -. , 3E5Fh = . , - = -. , 3E3Fh = . , - = . , 3E1Fh",
    "TABLE 4-4: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 62\n= . , - = -. 3EE0h, ADCLK = . 3EE0h, 3EDFh = 3EC0h. 3EE0h, ADLTHH = CMOUT. 3EE0h, 3EBFh = 3EA0h. 3EE0h, CM1PCH = -. 3EE0h, 3E9Fh = 3E80h. 3EE0h, - = . 3EE0h, 3E7Fh = 3E60h. 3EE0h, - = . 3EE0h, 3E5Fh = 3E40h. 3EE0h, - = . 3EE0h, 3E3Fh = 3E20h. 3EE0h, - = -. 3EE0h, 3E1Fh = 3E00h. 3EE0h, - = \nLegend:\nUnimplemented data memory locations and registers, read as ' 0 '.",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3DFEh, - = -. 3DFEh, 3DDFh = 3DDEh U2BRGH. 3DFEh, U2FIFO = 3DBEh. 3DFEh, 3DBFh = -. 3DFEh, - = 3D9Eh. 3DFEh, 3D9Fh = . 3DFEh, - = -. 3DFEh, 3D7Fh = 3D7Eh -. 3DFEh, - = 3D5Eh. 3DFEh, 3D5Fh = I2C2CON1. 3DFEh, I2C2CON2 = 3D3Eh. 3DFEh, 3D3Fh = . 3DFEh, - = -. 3DFEh, 3D1Fh = 3D1Eh. 3DFEh, - = -. 3DFDh, - = -. 3DFDh, 3DDFh = 3DDDh. 3DFDh, U2FIFO = U2BRGL 3DBDh. 3DFDh, 3DBFh = -. 3DFDh, - = 3D9Dh. 3DFDh, 3D9Fh =",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n-. 3DFDh, - = 3D7Dh. 3DFDh, 3D7Fh = -. 3DFDh, - = 3D5Dh. 3DFDh, 3D5Fh = . 3DFDh, I2C2CON2 = I2C2CON0. 3DFDh, 3D3Fh = 3D3Dh -. 3DFDh, - = . 3DFDh, 3D1Fh = 3D1Dh. 3DFDh, - = -. 3DFCh, - = -. 3DFCh, 3DDFh = 3DDCh. 3DFCh, U2FIFO = U2CON2 3DBCh. 3DFCh, 3DBFh = -. 3DFCh, - = 3D9Ch. 3DFCh, 3D9Fh = -. 3DFCh, - = 3D7Ch. 3DFCh, 3D7Fh = I2C1BTO. 3DFCh, - = . 3DFCh, 3D5Fh = 3D5Ch. 3DFCh, I2C2CON2 =",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\nI2C2ADR3. 3DFCh, 3D3Fh = 3D3Ch -. 3DFCh, - = 3D1Ch. 3DFCh, 3D1Fh = . 3DFCh, - = SPI1CLK. 3DFBh, - = -. 3DFBh, 3DDFh = 3DDBh U2CON1. 3DFBh, U2FIFO = 3DBBh. 3DFBh, 3DBFh = -. 3DFBh, - = 3D9Bh. 3DFBh, 3D9Fh = -. 3DFBh, - = 3D7Bh. 3DFBh, 3D7Fh = I2C1CLK. 3DFBh, - = 3D5Bh. 3DFBh, 3D5Fh = I2C2ADR2. 3DFBh, I2C2CON2 = 3D3Bh. 3DFBh, 3D3Fh = -. 3DFBh, - = 3D1Bh. 3DFBh, 3D1Fh = . 3DFBh, - = SPI1INTE.",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3DFAh, - = U1ERRIE. 3DFAh, 3DDFh = 3DDAh. 3DFAh, U2FIFO = U2CON0 3DBAh. 3DFAh, 3DBFh = -. 3DFAh, - = 3D9Ah. 3DFAh, 3D9Fh = -. 3DFAh, - = 3D7Ah. 3DFAh, 3D7Fh = . 3DFAh, - = I2C1PIE. 3DFAh, 3D5Fh = 3D5Ah. 3DFAh, I2C2CON2 = I2C2ADR1. 3DFAh, 3D3Fh = 3D3Ah -. 3DFAh, - = . 3DFAh, 3D1Fh = 3D1Ah. 3DFAh, - = SPI1INTF. 3DF9h, - = U1ERRIR. 3DF9h, 3DDFh = 3DD9h. 3DF9h, U2FIFO = U2P3H 3DB9h. 3DF9h, 3DBFh =",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n-. 3DF9h, - = 3D99h. 3DF9h, 3D9Fh = -. 3DF9h, - = 3D79h. 3DF9h, 3D7Fh = I2C1PIR. 3DF9h, - = . 3DF9h, 3D5Fh = 3D59h. 3DF9h, I2C2CON2 = I2C2ADR0. 3DF9h, 3D3Fh = 3D39h -. 3DF9h, - = . 3DF9h, 3D1Fh = 3D19h. 3DF9h, - = SPI1BAUD. 3DF8h, - = U1UIR. 3DF8h, 3DDFh = 3DD8h. 3DF8h, U2FIFO = U2P3L. 3DF8h, 3DBFh = 3DB8h -. 3DF8h, - = . 3DF8h, 3D9Fh = 3D98h -. 3DF8h,",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n- = . 3DF8h, 3D7Fh = 3D78h. 3DF8h, - = I2C1STAT1. 3DF8h, 3D5Fh = 3D58h. 3DF8h, I2C2CON2 = I2C2ADB1. 3DF8h, 3D3Fh = 3D38h. 3DF8h, - = -. 3DF8h, 3D1Fh = 3D18h. 3DF8h, - = SPI1TWIDTH. 3DF7h, - = U1FIFO. 3DF7h, 3DDFh = 3DD7h. 3DF7h, U2FIFO = U2P2H. 3DF7h, 3DBFh = 3DB7h -. 3DF7h, - = . 3DF7h, 3D9Fh = 3D97h. 3DF7h, - = -. 3DF7h, 3D7Fh = 3D77h. 3DF7h, - =",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\nI2C1STAT0. 3DF7h, 3D5Fh = 3D57h. 3DF7h, I2C2CON2 = I2C2ADB0. 3DF7h, 3D3Fh = 3D37h. 3DF7h, - = -. 3DF7h, 3D1Fh = 3D17h. 3DF7h, - = SPI1STATUS. 3DF6h, - = U1BRGH. 3DF6h, 3DDFh = 3DD6h. 3DF6h, U2FIFO = U2P2L. 3DF6h, 3DBFh = 3DB6h. 3DF6h, - = -. 3DF6h, 3D9Fh = 3D96h -. 3DF6h, - = . 3DF6h, 3D7Fh = 3D76h. 3DF6h, - = I2C1ERR. 3DF6h, 3D5Fh = 3D56h. 3DF6h,",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\nI2C2CON2 = I2C2CNT. 3DF6h, 3D3Fh = 3D36h. 3DF6h, - = -. 3DF6h, 3D1Fh = 3D16h. 3DF6h, - = SPI1CON2. 3DF5h, - = U1BRGL. 3DF5h, 3DDFh = 3DD5h. 3DF5h, U2FIFO = U2P1H. 3DF5h, 3DBFh = 3DB5h. 3DF5h, - = -. 3DF5h, 3D9Fh = 3D95h -. 3DF5h, - = . 3DF5h, 3D7Fh = 3D75h. 3DF5h, - = I2C1CON2. 3DF5h, 3D5Fh = 3D55h. 3DF5h, I2C2CON2 = I2C2TXB. 3DF5h, 3D3Fh = 3D35h.",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3DF5h, - = -. 3DF5h, 3D1Fh = 3D15h. 3DF5h, - = SPI1CON1. 3DF4h, - = U1CON2. 3DF4h, 3DDFh = 3DD4h. 3DF4h, U2FIFO = U2P1L. 3DF4h, 3DBFh = 3DB4h -. 3DF4h, - = . 3DF4h, 3D9Fh = 3D94h -. 3DF4h, - = . 3DF4h, 3D7Fh = 3D74h. 3DF4h, - = I2C1CON1. 3DF4h, 3D5Fh = 3D54h. 3DF4h, I2C2CON2 = I2C2RXB. 3DF4h, 3D3Fh = 3D34h. 3DF4h, - = -. 3DF4h, 3D1Fh = 3D14h. 3DF4h, - =",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\nSPI1CON0. 3DF3h, - = U1CON1. 3DF3h, 3DDFh = 3DD3h. 3DF3h, U2FIFO = U2TXCHK. 3DF3h, 3DBFh = 3DB3h -. 3DF3h, - = . 3DF3h, 3D9Fh = 3D93h. 3DF3h, - = -. 3DF3h, 3D7Fh = 3D73h. 3DF3h, - = I2C1CON0. 3DF3h, 3D5Fh = 3D53h. 3DF3h, I2C2CON2 = -. 3DF3h, 3D3Fh = 3D33h. 3DF3h, - = -. 3DF3h, 3D1Fh = 3D13h. 3DF3h, - = SPI1TCNTH. 3DF2h, - = U1CON0. 3DF2h, 3DDFh = 3DD2h.",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3DF2h, U2FIFO = U2TXB. 3DF2h, 3DBFh = 3DB2h. 3DF2h, - = -. 3DF2h, 3D9Fh = 3D92h. 3DF2h, - = -. 3DF2h, 3D7Fh = 3D72h. 3DF2h, - = I2C1ADR3. 3DF2h, 3D5Fh = 3D52h. 3DF2h, I2C2CON2 = -. 3DF2h, 3D3Fh = 3D32h. 3DF2h, - = -. 3DF2h, 3D1Fh = 3D12h. 3DF2h, - = SPI1TCNTL. 3DF1h, - = U1P3H. 3DF1h, 3DDFh = 3DD1h. 3DF1h, U2FIFO = U2RXCHK. 3DF1h, 3DBFh = 3DB1h. 3DF1h,",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n- = -. 3DF1h, 3D9Fh = 3D91h. 3DF1h, - = -. 3DF1h, 3D7Fh = 3D71h. 3DF1h, - = I2C1ADR2. 3DF1h, 3D5Fh = 3D51h. 3DF1h, I2C2CON2 = -. 3DF1h, 3D3Fh = 3D31h. 3DF1h, - = -. 3DF1h, 3D1Fh = 3D11h. 3DF1h, - = SPI1TXB. 3DF0h, - = U1P3L. 3DF0h, 3DDFh = 3DD0h. 3DF0h, U2FIFO = U2RXB. 3DF0h, 3DBFh = 3DB0h. 3DF0h, - = -. 3DF0h, 3D9Fh = 3D90h -. 3DF0h, - = . 3DF0h,",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3D7Fh = 3D70h. 3DF0h, - = I2C1ADR1. 3DF0h, 3D5Fh = 3D50h. 3DF0h, I2C2CON2 = -. 3DF0h, 3D3Fh = 3D30h. 3DF0h, - = -. 3DF0h, 3D1Fh = 3D10h. 3DF0h, - = SPI1RXB. 3DEFh, - = U1P2H. 3DEFh, 3DDFh = 3DCFh. 3DEFh, U2FIFO = -. 3DEFh, 3DBFh = 3DAFh. 3DEFh, - = -. 3DEFh, 3D9Fh = 3D8Fh. 3DEFh, - = -. 3DEFh, 3D7Fh = 3D6Fh. 3DEFh, - = I2C1ADR0. 3DEFh, 3D5Fh = 3D4Fh. 3DEFh,",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\nI2C2CON2 = -. 3DEFh, 3D3Fh = 3D2Fh. 3DEFh, - = -. 3DEFh, 3D1Fh = 3D0Fh. 3DEFh, - = -. 3DEEh, - = U1P2L. 3DEEh, 3DDFh = 3DCEh. 3DEEh, U2FIFO = -. 3DEEh, 3DBFh = 3DAEh. 3DEEh, - = - 3D8Eh. 3DEEh, 3D9Fh = . 3DEEh, - = -. 3DEEh, 3D7Fh = 3D6Eh. 3DEEh, - = I2C1ADB1. 3DEEh, 3D5Fh = 3D4Eh. 3DEEh, I2C2CON2 = -. 3DEEh, 3D3Fh = 3D2Eh. 3DEEh, - = -. 3DEEh, 3D1Fh = 3D0Eh. 3DEEh, - = -. 3DEDh, - =",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\nU1P1H. 3DEDh, 3DDFh = 3DCDh. 3DEDh, U2FIFO = -. 3DEDh, 3DBFh = 3DADh. 3DEDh, - = -. 3DEDh, 3D9Fh = 3D8Dh. 3DEDh, - = -. 3DEDh, 3D7Fh = 3D6Dh. 3DEDh, - = I2C1ADB0. 3DEDh, 3D5Fh = 3D4Dh. 3DEDh, I2C2CON2 = -. 3DEDh, 3D3Fh = 3D2Dh. 3DEDh, - = -. 3DEDh, 3D1Fh = 3D0Dh. 3DEDh, - = -. 3DECh, - = U1P1L. 3DECh, 3DDFh = 3DCCh. 3DECh, U2FIFO = -. 3DECh, 3DBFh = 3DACh. 3DECh, - = -. 3DECh, 3D9Fh = 3D8Ch. 3DECh, - = -.",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3DECh, 3D7Fh = 3D6Ch. 3DECh, - = I2C1CNT. 3DECh, 3D5Fh = 3D4Ch. 3DECh, I2C2CON2 = -. 3DECh, 3D3Fh = 3D2Ch. 3DECh, - = -. 3DECh, 3D1Fh = 3D0Ch. 3DECh, - = -. 3DEBh, - = U1TXCHK. 3DEBh, 3DDFh = 3DCBh. 3DEBh, U2FIFO = -. 3DEBh, 3DBFh = 3DABh. 3DEBh, - = - 3D8Bh. 3DEBh, 3D9Fh = . 3DEBh, - = -. 3DEBh, 3D7Fh = 3D6Bh. 3DEBh, - = I2C1TXB. 3DEBh, 3D5Fh = 3D4Bh. 3DEBh, I2C2CON2 = -. 3DEBh, 3D3Fh = 3D2Bh.",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3DEBh, - = -. 3DEBh, 3D1Fh = 3D0Bh. 3DEBh, - = -. 3DEAh, - = U1TXB. 3DEAh, 3DDFh = 3DCAh. 3DEAh, U2FIFO = -. 3DEAh, 3DBFh = 3DAAh. 3DEAh, - = - 3D8Ah. 3DEAh, 3D9Fh = . 3DEAh, - = -. 3DEAh, 3D7Fh = 3D6Ah. 3DEAh, - = I2C1RXB. 3DEAh, 3D5Fh = 3D4Ah. 3DEAh, I2C2CON2 = -. 3DEAh, 3D3Fh = 3D2Ah. 3DEAh, - = -. 3DEAh, 3D1Fh = 3D0Ah. 3DEAh, - = -. 3DE9h, - = U1RXCHK. 3DE9h, 3DDFh = 3DC9h.",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3DE9h, U2FIFO = -. 3DE9h, 3DBFh = 3DA9h. 3DE9h, - = -. 3DE9h, 3D9Fh = 3D89h. 3DE9h, - = -. 3DE9h, 3D7Fh = 3D69h. 3DE9h, - = -. 3DE9h, 3D5Fh = 3D49h. 3DE9h, I2C2CON2 = -. 3DE9h, 3D3Fh = 3D29h. 3DE9h, - = -. 3DE9h, 3D1Fh = 3D09h. 3DE9h, - = -. 3DE8h, - = U1RXB. 3DE8h, 3DDFh = 3DC8h. 3DE8h, U2FIFO = -. 3DE8h, 3DBFh = 3DA8h. 3DE8h, - = -. 3DE8h, 3D9Fh =",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3D88h. 3DE8h, - = -. 3DE8h, 3D7Fh = 3D68h. 3DE8h, - = -. 3DE8h, 3D5Fh = 3D48h. 3DE8h, I2C2CON2 = -. 3DE8h, 3D3Fh = 3D28h. 3DE8h, - = -. 3DE8h, 3D1Fh = 3D08h. 3DE8h, - = -. 3DE7h, - = -. 3DE7h, 3DDFh = 3DC7h. 3DE7h, U2FIFO = -. 3DE7h, 3DBFh = 3DA7h. 3DE7h, - = -. 3DE7h, 3D9Fh = 3D87h. 3DE7h, - = -. 3DE7h, 3D7Fh = 3D67h. 3DE7h, - = -. 3DE7h, 3D5Fh =",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3D47h. 3DE7h, I2C2CON2 = -. 3DE7h, 3D3Fh = 3D27h. 3DE7h, - = -. 3DE7h, 3D1Fh = 3D07h. 3DE7h, - = -. 3DE6h, - = -. 3DE6h, 3DDFh = 3DC6h. 3DE6h, U2FIFO = -. 3DE6h, 3DBFh = 3DA6h. 3DE6h, - = -. 3DE6h, 3D9Fh = 3D86h. 3DE6h, - = -. 3DE6h, 3D7Fh = 3D66h. 3DE6h, - = I2C2BTO. 3DE6h, 3D5Fh = 3D46h. 3DE6h, I2C2CON2 = -. 3DE6h, 3D3Fh = 3D26h. 3DE6h, - = -. 3DE6h,",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3D1Fh = 3D06h. 3DE6h, - = -. 3DE5h, - = -. 3DE5h, 3DDFh = 3DC5h. 3DE5h, U2FIFO = -. 3DE5h, 3DBFh = 3DA5h. 3DE5h, - = -. 3DE5h, 3D9Fh = 3D85h. 3DE5h, - = -. 3DE5h, 3D7Fh = 3D65h. 3DE5h, - = I2C2CLK. 3DE5h, 3D5Fh = 3D45h. 3DE5h, I2C2CON2 = -. 3DE5h, 3D3Fh = 3D25h. 3DE5h, - = -. 3DE5h, 3D1Fh = 3D05h. 3DE5h, - = -. 3DE4h, - = -. 3DE4h, 3DDFh = 3DC4h. 3DE4h,",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\nU2FIFO = -. 3DE4h, 3DBFh = 3DA4h. 3DE4h, - = -. 3DE4h, 3D9Fh = 3D84h. 3DE4h, - = -. 3DE4h, 3D7Fh = 3D64h. 3DE4h, - = I2C2PIE. 3DE4h, 3D5Fh = 3D44h. 3DE4h, I2C2CON2 = -. 3DE4h, 3D3Fh = 3D24h. 3DE4h, - = -. 3DE4h, 3D1Fh = 3D04h. 3DE4h, - = -. 3DE3h, - = -. 3DE3h, 3DDFh = 3DC3h. 3DE3h, U2FIFO = -. 3DE3h, 3DBFh = 3DA3h. 3DE3h, - = -. 3DE3h, 3D9Fh = 3D83h.",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3DE3h, - = -. 3DE3h, 3D7Fh = 3D63h. 3DE3h, - = I2C2PIR. 3DE3h, 3D5Fh = 3D43h. 3DE3h, I2C2CON2 = -. 3DE3h, 3D3Fh = 3D23h. 3DE3h, - = -. 3DE3h, 3D1Fh = 3D03h. 3DE3h, - = -. 3DE2h, - = U2ERRIE. 3DE2h, 3DDFh = 3DC2h. 3DE2h, U2FIFO = -. 3DE2h, 3DBFh = 3DA2h. 3DE2h, - = -. 3DE2h, 3D9Fh = 3D82h. 3DE2h, - = -. 3DE2h, 3D7Fh = 3D62h. 3DE2h, - = I2C2STAT1. 3DE2h,",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3D5Fh = 3D42h. 3DE2h, I2C2CON2 = -. 3DE2h, 3D3Fh = 3D22h. 3DE2h, - = -. 3DE2h, 3D1Fh = 3D02h. 3DE2h, - = -. 3DE1h, - = U2ERRIR. 3DE1h, 3DDFh = 3DC1h. 3DE1h, U2FIFO = -. 3DE1h, 3DBFh = 3DA1h. 3DE1h, - = -. 3DE1h, 3D9Fh = 3D81h. 3DE1h, - = -. 3DE1h, 3D7Fh = 3D61h. 3DE1h, - = I2C2STAT0. 3DE1h, 3D5Fh = 3D41h. 3DE1h, I2C2CON2 = -. 3DE1h, 3D3Fh = 3D21h. 3DE1h, -",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n= -. 3DE1h, 3D1Fh = 3D01h. 3DE1h, - = -. , - = U2UIR. , 3DDFh = 3DC0h. , U2FIFO = -. , 3DBFh = 3DA0h. , - = -. , 3D9Fh = . , - = -. , 3D7Fh = 3D60h. , - = . , 3D5Fh = . , I2C2CON2 = . , 3D3Fh = . , - = . , 3D1Fh = 3D00h. , - = . 3DE0h, - = . 3DE0h, 3DDFh = . 3DE0h, U2FIFO = . 3DE0h, 3DBFh = . 3DE0h, - = . 3DE0h, 3D9Fh = 3D80h. 3DE0h, - = . 3DE0h, 3D7Fh = . 3DE0h, - = I2C2ERR. 3DE0h,",
    "TABLE 4-5: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 61\n3D5Fh = 3D40h. 3DE0h, I2C2CON2 = -. 3DE0h, 3D3Fh = 3D20h. 3DE0h, - = -. 3DE0h, 3D1Fh = . 3DE0h, - = -\nLegend:\nUnimplemented data memory locations and registers, read as ' 0 '.",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CFEh, - = MD1CARH. 3CFEh, 3CDFh = 3CDEh. 3CFEh, - = - 3CBEh. 3CFEh, 3CBFh = . 3CFEh, - = -. 3CFEh, 3C9Fh = 3C9Eh. 3CFEh, - = -. 3CFEh, 3C7Fh = 3C7Eh. 3CFEh, - = CLCDATA0. 3CFEh, 3C5Fh = 3C5Eh. 3CFEh, CLC4GLS3 = CLC4GLS2. 3CFEh, 3C3Fh = 3C3Eh. 3CFEh, - = -. 3CFEh, 3C1Fh = 3C1Eh. 3CFEh, - = -. 3CFDh, - = MD1CARL. 3CFDh, 3CDFh = 3CDDh. 3CFDh, - = -",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CBDh. 3CFDh, 3CBFh = . 3CFDh, - = -. 3CFDh, 3C9Fh = 3C9Dh. 3CFDh, - = -. 3CFDh, 3C7Fh = 3C7Dh CLC1GLS3. 3CFDh, - = . 3CFDh, 3C5Fh = 3C5Dh. 3CFDh, CLC4GLS3 = CLC4GLS1. 3CFDh, 3C3Fh = 3C3Dh. 3CFDh, - = -. 3CFDh, 3C1Fh = 3C1Dh. 3CFDh, - = -. 3CFCh, - = MD1SRC. 3CFCh, 3CDFh = 3CDCh. 3CFCh, - = - 3CBCh. 3CFCh, 3CBFh = -. 3CFCh, - = 3C9Ch. 3CFCh,",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3C9Fh = -. 3CFCh, - = 3C7Ch. 3CFCh, 3C7Fh = CLC1GLS2. 3CFCh, - = . 3CFCh, 3C5Fh = 3C5Ch. 3CFCh, CLC4GLS3 = CLC4GLS0. 3CFCh, 3C3Fh = 3C3Ch. 3CFCh, - = -. 3CFCh, 3C1Fh = 3C1Ch. 3CFCh, - = -. 3CFBh, - = MD1CON1. 3CFBh, 3CDFh = 3CDBh -. 3CFBh, - = 3CBBh. 3CFBh, 3CBFh = -. 3CFBh, - = 3C9Bh. 3CFBh, 3C9Fh = -. 3CFBh, - = 3C7Bh. 3CFBh, 3C7Fh =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\nCLC1GLS1. 3CFBh, - = . 3CFBh, 3C5Fh = 3C5Bh. 3CFBh, CLC4GLS3 = CLC4SEL3. 3CFBh, 3C3Fh = 3C3Bh. 3CFBh, - = -. 3CFBh, 3C1Fh = 3C1Bh. 3CFBh, - = -. 3CFAh, - = MD1CON0. 3CFAh, 3CDFh = 3CDAh. 3CFAh, - = -. 3CFAh, 3CBFh = 3CBAh -. 3CFAh, - = 3C9Ah. 3CFAh, 3C9Fh = . 3CFAh, - = -. 3CFAh, 3C7Fh = 3C7Ah. 3CFAh, - = CLC1GLS0. 3CFAh, 3C5Fh = 3C5Ah.",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CFAh, CLC4GLS3 = CLC4SEL2. 3CFAh, 3C3Fh = 3C3Ah. 3CFAh, - = -. 3CFAh, 3C1Fh = 3C1Ah. 3CFAh, - = -. 3CF9h, - = -. 3CF9h, 3CDFh = 3CD9h -. 3CF9h, - = . 3CF9h, 3CBFh = 3CB9h -. 3CF9h, - = . 3CF9h, 3C9Fh = 3C99h. 3CF9h, - = -. 3CF9h, 3C7Fh = 3C79h. 3CF9h, - = CLC1SEL3. 3CF9h, 3C5Fh = 3C59h. 3CF9h, CLC4GLS3 = CLC4SEL1.",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CF9h, 3C3Fh = 3C39h. 3CF9h, - = -. 3CF9h, 3C1Fh = 3C19h. 3CF9h, - = -. 3CF8h, - = -. 3CF8h, 3CDFh = 3CD8h. 3CF8h, - = -. 3CF8h, 3CBFh = 3CB8h. 3CF8h, - = -. 3CF8h, 3C9Fh = 3C98h. 3CF8h, - = -. 3CF8h, 3C7Fh = 3C78h. 3CF8h, - = CLC1SEL2. 3CF8h, 3C5Fh = 3C58h. 3CF8h, CLC4GLS3 = CLC4SEL0. 3CF8h, 3C3Fh = 3C38h.",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CF8h, - = -. 3CF8h, 3C1Fh = 3C18h. 3CF8h, - = -. 3CF7h, - = -. 3CF7h, 3CDFh = 3CD7h. 3CF7h, - = -. 3CF7h, 3CBFh = 3CB7h. 3CF7h, - = -. 3CF7h, 3C9Fh = 3C97h. 3CF7h, - = -. 3CF7h, 3C7Fh = 3C77h. 3CF7h, - = CLC1SEL1. 3CF7h, 3C5Fh = 3C57h. 3CF7h, CLC4GLS3 = CLC4POL. 3CF7h, 3C3Fh = 3C37h. 3CF7h, - = -. 3CF7h,",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3C1Fh = 3C17h. 3CF7h, - = -. 3CF6h, - = -. 3CF6h, 3CDFh = 3CD6h. 3CF6h, - = -. 3CF6h, 3CBFh = 3CB6h. 3CF6h, - = -. 3CF6h, 3C9Fh = 3C96h. 3CF6h, - = -. 3CF6h, 3C7Fh = 3C76h. 3CF6h, - = CLC1SEL0. 3CF6h, 3C5Fh = 3C56h. 3CF6h, CLC4GLS3 = CLC4CON. 3CF6h, 3C3Fh = 3C36h. 3CF6h, - = -. 3CF6h, 3C1Fh = 3C16h. 3CF6h, - =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n-. 3CF5h, - = -. 3CF5h, 3CDFh = 3CD5h. 3CF5h, - = -. 3CF5h, 3CBFh = 3CB5h. 3CF5h, - = -. 3CF5h, 3C9Fh = 3C95h. 3CF5h, - = -. 3CF5h, 3C7Fh = 3C75h. 3CF5h, - = CLC1POL. 3CF5h, 3C5Fh = 3C55h. 3CF5h, CLC4GLS3 = -. 3CF5h, 3C3Fh = 3C35h. 3CF5h, - = -. 3CF5h, 3C1Fh = 3C15h. 3CF5h, - = -. 3CF4h, - = -. 3CF4h, 3CDFh =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CD4h. 3CF4h, - = -. 3CF4h, 3CBFh = 3CB4h. 3CF4h, - = -. 3CF4h, 3C9Fh = 3C94h. 3CF4h, - = -. 3CF4h, 3C7Fh = 3C74h. 3CF4h, - = CLC1CON. 3CF4h, 3C5Fh = 3C54h. 3CF4h, CLC4GLS3 = -. 3CF4h, 3C3Fh = 3C34h. 3CF4h, - = -. 3CF4h, 3C1Fh = 3C14h. 3CF4h, - = -. 3CF3h, - = -. 3CF3h, 3CDFh = 3CD3h. 3CF3h, - = -. 3CF3h,",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CBFh = 3CB3h. 3CF3h, - = -. 3CF3h, 3C9Fh = 3C93h. 3CF3h, - = -. 3CF3h, 3C7Fh = 3C73h. 3CF3h, - = CLC2GLS3. 3CF3h, 3C5Fh = 3C53h. 3CF3h, CLC4GLS3 = -. 3CF3h, 3C3Fh = 3C33h. 3CF3h, - = -. 3CF3h, 3C1Fh = 3C13h. 3CF3h, - = -. 3CF2h, - = -. 3CF2h, 3CDFh = 3CD2h. 3CF2h, - = -. 3CF2h, 3CBFh = 3CB2h. 3CF2h, - = -.",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CF2h, 3C9Fh = 3C92h. 3CF2h, - = -. 3CF2h, 3C7Fh = 3C72h. 3CF2h, - = CLC2GLS2. 3CF2h, 3C5Fh = 3C52h. 3CF2h, CLC4GLS3 = -. 3CF2h, 3C3Fh = 3C32h. 3CF2h, - = -. 3CF2h, 3C1Fh = 3C12h. 3CF2h, - = -. 3CF1h, - = -. 3CF1h, 3CDFh = 3CD1h. 3CF1h, - = -. 3CF1h, 3CBFh = 3CB1h. 3CF1h, - = -. 3CF1h, 3C9Fh = 3C91h.",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CF1h, - = -. 3CF1h, 3C7Fh = 3C71h. 3CF1h, - = CLC2GLS1. 3CF1h, 3C5Fh = 3C51h. 3CF1h, CLC4GLS3 = -. 3CF1h, 3C3Fh = 3C31h. 3CF1h, - = -. 3CF1h, 3C1Fh = 3C11h. 3CF1h, - = -. 3CF0h, - = -. 3CF0h, 3CDFh = 3CD0h. 3CF0h, - = -. 3CF0h, 3CBFh = 3CB0h. 3CF0h, - = -. 3CF0h, 3C9Fh = 3C90h. 3CF0h, - = -. 3CF0h, 3C7Fh =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3C70h. 3CF0h, - = CLC2GLS0. 3CF0h, 3C5Fh = 3C50h. 3CF0h, CLC4GLS3 = -. 3CF0h, 3C3Fh = 3C30h. 3CF0h, - = -. 3CF0h, 3C1Fh = 3C10h. 3CF0h, - = -. 3CEFh, - = -. 3CEFh, 3CDFh = 3CCFh. 3CEFh, - = -. 3CEFh, 3CBFh = 3CAFh. 3CEFh, - = -. 3CEFh, 3C9Fh = 3C8Fh. 3CEFh, - = -. 3CEFh, 3C7Fh = 3C6Fh. 3CEFh, - = CLC2SEL3. 3CEFh, 3C5Fh =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3C4Fh. 3CEFh, CLC4GLS3 = -. 3CEFh, 3C3Fh = 3C2Fh. 3CEFh, - = -. 3CEFh, 3C1Fh = 3C0Fh. 3CEFh, - = -. 3CEEh, - = -. 3CEEh, 3CDFh = 3CCEh. 3CEEh, - = -. 3CEEh, 3CBFh = 3CAEh. 3CEEh, - = -. 3CEEh, 3C9Fh = 3C8Eh. 3CEEh, - = -. 3CEEh, 3C7Fh = 3C6Eh. 3CEEh, - = CLC2SEL2. 3CEEh, 3C5Fh = 3C4Eh. 3CEEh, CLC4GLS3 = -. 3CEEh, 3C3Fh = 3C2Eh. 3CEEh, - = -. 3CEEh,",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3C1Fh = 3C0Eh. 3CEEh, - = -. 3CEDh, - = -. 3CEDh, 3CDFh = 3CCDh. 3CEDh, - = -. 3CEDh, 3CBFh = 3CADh. 3CEDh, - = -. 3CEDh, 3C9Fh = 3C8Dh. 3CEDh, - = -. 3CEDh, 3C7Fh = 3C6Dh. 3CEDh, - = CLC2SEL1. 3CEDh, 3C5Fh = 3C4Dh. 3CEDh, CLC4GLS3 = -. 3CEDh, 3C3Fh = 3C2Dh. 3CEDh, - = -. 3CEDh, 3C1Fh = 3C0Dh. 3CEDh, - = -. 3CECh, - = -. 3CECh, 3CDFh = 3CCCh. 3CECh, - = -. 3CECh, 3CBFh =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CACh. 3CECh, - = -. 3CECh, 3C9Fh = 3C8Ch. 3CECh, - = -. 3CECh, 3C7Fh = 3C6Ch. 3CECh, - = CLC2SEL0. 3CECh, 3C5Fh = 3C4Ch. 3CECh, CLC4GLS3 = -. 3CECh, 3C3Fh = 3C2Ch. 3CECh, - = -. 3CECh, 3C1Fh = 3C0Ch. 3CECh, - = -. 3CEBh, - = -. 3CEBh, 3CDFh = 3CCBh. 3CEBh, - = -. 3CEBh, 3CBFh = 3CABh. 3CEBh, - = -. 3CEBh, 3C9Fh = 3C8Bh. 3CEBh, - = -. 3CEBh, 3C7Fh = 3C6Bh. 3CEBh, - =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\nCLC2POL. 3CEBh, 3C5Fh = 3C4Bh. 3CEBh, CLC4GLS3 = -. 3CEBh, 3C3Fh = 3C2Bh. 3CEBh, - = -. 3CEBh, 3C1Fh = 3C0Bh. 3CEBh, - = -. 3CEAh, - = -. 3CEAh, 3CDFh = 3CCAh. 3CEAh, - = -. 3CEAh, 3CBFh = 3CAAh. 3CEAh, - = -. 3CEAh, 3C9Fh = 3C8Ah. 3CEAh, - = -. 3CEAh, 3C7Fh = 3C6Ah. 3CEAh, - = CLC2CON. 3CEAh, 3C5Fh = 3C4Ah. 3CEAh, CLC4GLS3 = -. 3CEAh, 3C3Fh = 3C2Ah. 3CEAh, - = -.",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CEAh, 3C1Fh = 3C0Ah. 3CEAh, - = -. 3CE9h, - = -. 3CE9h, 3CDFh = 3CC9h. 3CE9h, - = -. 3CE9h, 3CBFh = 3CA9h. 3CE9h, - = -. 3CE9h, 3C9Fh = 3C89h. 3CE9h, - = -. 3CE9h, 3C7Fh = 3C69h. 3CE9h, - = CLC3GLS3. 3CE9h, 3C5Fh = 3C49h. 3CE9h, CLC4GLS3 = -. 3CE9h, 3C3Fh = 3C29h. 3CE9h, - = -. 3CE9h, 3C1Fh = 3C09h. 3CE9h, - = -. 3CE8h, - = -.",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CE8h, 3CDFh = 3CC8h. 3CE8h, - = -. 3CE8h, 3CBFh = 3CA8h. 3CE8h, - = -. 3CE8h, 3C9Fh = 3C88h. 3CE8h, - = -. 3CE8h, 3C7Fh = 3C68h. 3CE8h, - = CLC3GLS2. 3CE8h, 3C5Fh = 3C48h. 3CE8h, CLC4GLS3 = -. 3CE8h, 3C3Fh = 3C28h. 3CE8h, - = -. 3CE8h, 3C1Fh = 3C08h. 3CE8h, - = -. 3CE7h, - = -. 3CE7h, 3CDFh = 3CC7h. 3CE7h, - = -. 3CE7h, 3CBFh =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CA7h. 3CE7h, - = -. 3CE7h, 3C9Fh = 3C87h. 3CE7h, - = -. 3CE7h, 3C7Fh = 3C67h. 3CE7h, - = CLC3GLS1. 3CE7h, 3C5Fh = 3C47h. 3CE7h, CLC4GLS3 = -. 3CE7h, 3C3Fh = 3C27h. 3CE7h, - = -. 3CE7h, 3C1Fh = 3C07h. 3CE7h, - = -. 3CE6h, - = CLKRCLK. 3CE6h, 3CDFh = 3CC6h. 3CE6h, - = -. 3CE6h, 3CBFh = 3CA6h. 3CE6h, - = -. 3CE6h, 3C9Fh = 3C86h.",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CE6h, - = -. 3CE6h, 3C7Fh = 3C66h. 3CE6h, - = CLC3GLS0. 3CE6h, 3C5Fh = 3C46h. 3CE6h, CLC4GLS3 = -. 3CE6h, 3C3Fh = 3C26h. 3CE6h, - = -. 3CE6h, 3C1Fh = 3C06h. 3CE6h, - = -. 3CE5h, - = CLKRCON. 3CE5h, 3CDFh = 3CC5h. 3CE5h, - = -. 3CE5h, 3CBFh = 3CA5h. 3CE5h, - = -. 3CE5h, 3C9Fh = 3C85h. 3CE5h, - = -. 3CE5h, 3C7Fh = 3C65h. 3CE5h, - =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\nCLC3SEL3. 3CE5h, 3C5Fh = 3C45h. 3CE5h, CLC4GLS3 = -. 3CE5h, 3C3Fh = 3C25h. 3CE5h, - = -. 3CE5h, 3C1Fh = 3C05h. 3CE5h, - = -. 3CE4h, - = -. 3CE4h, 3CDFh = 3CC4h. 3CE4h, - = -. 3CE4h, 3CBFh = 3CA4h. 3CE4h, - = -. 3CE4h, 3C9Fh = 3C84h. 3CE4h, - = -. 3CE4h, 3C7Fh = 3C64h. 3CE4h, - = CLC3SEL2. 3CE4h, 3C5Fh = 3C44h. 3CE4h, CLC4GLS3 = -.",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CE4h, 3C3Fh = 3C24h. 3CE4h, - = -. 3CE4h, 3C1Fh = 3C04h. 3CE4h, - = -. 3CE3h, - = -. 3CE3h, 3CDFh = 3CC3h. 3CE3h, - = -. 3CE3h, 3CBFh = 3CA3h. 3CE3h, - = -. 3CE3h, 3C9Fh = 3C83h. 3CE3h, - = -. 3CE3h, 3C7Fh = 3C63h. 3CE3h, - = CLC3SEL1. 3CE3h, 3C5Fh = 3C43h. 3CE3h, CLC4GLS3 = -. 3CE3h, 3C3Fh = 3C23h. 3CE3h, - = -. 3CE3h, 3C1Fh =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3C03h. 3CE3h, - = -. 3CE2h, - = -. 3CE2h, 3CDFh = 3CC2h. 3CE2h, - = -. 3CE2h, 3CBFh = 3CA2h. 3CE2h, - = -. 3CE2h, 3C9Fh = 3C82h. 3CE2h, - = -. 3CE2h, 3C7Fh = 3C62h. 3CE2h, - = CLC3SEL0. 3CE2h, 3C5Fh = 3C42h. 3CE2h, CLC4GLS3 = -. 3CE2h, 3C3Fh = 3C22h. 3CE2h, - = -. 3CE2h, 3C1Fh = 3C02h. 3CE2h, - = -. 3CE1h, - = -. 3CE1h, 3CDFh =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3CC1h. 3CE1h, - = -. 3CE1h, 3CBFh = 3CA1h. 3CE1h, - = -. 3CE1h, 3C9Fh = 3C81h. 3CE1h, - = -. 3CE1h, 3C7Fh = 3C61h. 3CE1h, - = CLC3POL. 3CE1h, 3C5Fh = 3C41h. 3CE1h, CLC4GLS3 = . 3CE1h, 3C3Fh = 3C21h. 3CE1h, - = -. 3CE1h, 3C1Fh = 3C01h. 3CE1h, - = -. , - = -. , 3CDFh = 3CC0h. , - = . , 3CBFh = 3CA0h. , - = . , 3C9Fh = 3C80h. , - = . , 3C7Fh =",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\n3C60h. , - = . , 3C5Fh = . , CLC4GLS3 = -. , 3C3Fh = 3C20h. , - = -. , 3C1Fh = 3C00h. , - = . 3CE0h, - = . 3CE0h, 3CDFh = . 3CE0h, - = -. 3CE0h, 3CBFh = . 3CE0h, - = -. 3CE0h, 3C9Fh = . 3CE0h, - = -. 3CE0h, 3C7Fh = . 3CE0h, - = CLC3CON. 3CE0h, 3C5Fh = 3C40h. 3CE0h, CLC4GLS3 = -. 3CE0h, 3C3Fh = . 3CE0h, - = . 3CE0h, 3C1Fh = . 3CE0h, - = -\nLegend:",
    "TABLE 4-6: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 60\nUnimplemented data memory locations and registers, read as ' 0 '.",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BFEh, DMA1SIRQ = DMA1AIRQ. 3BFEh, 3BDFh = 3BDEh DMA2AIRQ. 3BFEh, DMA2SIRQ = 3BBEh. 3BFEh, 3BBFh = -. 3BFEh, - = 3B9Eh. 3BFEh, 3B9Fh = -. 3BFEh, - = . 3BFEh, 3B7Fh = 3B7Eh -. 3BFEh, - = 3B5Eh. 3BFEh, 3B5Fh - = -. 3BFEh, 3B3Fh = 3B3Eh -. 3BFEh, - = 3B1Eh. 3BFEh, 3B1Fh = . 3BFEh, - = -. 3BFDh, DMA1SIRQ = DMA1CON1 3BDDh. 3BFDh, 3BDFh = DMA2CON1. 3BFDh, DMA2SIRQ = 3BBDh. 3BFDh,",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BBFh = -. 3BFDh, - = 3B9Dh. 3BFDh, 3B9Fh = -. 3BFDh, - = 3B7Dh. 3BFDh, 3B7Fh = -. 3BFDh, - = 3B5Dh. 3BFDh, 3B5Fh - = -. 3BFDh, 3B3Fh = 3B3Dh -. 3BFDh, - = 3B1Dh. 3BFDh, 3B1Fh = . 3BFDh, - = -. 3BFCh, DMA1SIRQ = DMA1CON0. 3BFCh, 3BDFh = 3BDCh DMA2CON0. 3BFCh, DMA2SIRQ = 3BBCh. 3BFCh, 3BBFh = -. 3BFCh, - = 3B9Ch. 3BFCh, 3B9Fh = -. 3BFCh, - = 3B7Ch. 3BFCh, 3B7Fh = -.",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BFCh, - = 3B5Ch. 3BFCh, 3B5Fh - = -. 3BFCh, 3B3Fh = 3B3Ch -. 3BFCh, - = 3B1Ch. 3BFCh, 3B1Fh = . 3BFCh, - = -. 3BFBh, DMA1SIRQ = DMA1SSAU. 3BFBh, 3BDFh = 3BDBh DMA2SSAU. 3BFBh, DMA2SIRQ = 3BBBh. 3BFBh, 3BBFh = -. 3BFBh, - = 3B9Bh. 3BFBh, 3B9Fh = -. 3BFBh, - = 3B7Bh. 3BFBh, 3B7Fh = -. 3BFBh, - = 3B5Bh. 3BFBh, 3B5Fh - = -. 3BFBh, 3B3Fh = 3B3Bh -. 3BFBh, - = . 3BFBh,",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3B1Fh = 3B1Bh. 3BFBh, - = -. 3BFAh, DMA1SIRQ = DMA1SSAH. 3BFAh, 3BDFh = 3BDAh DMA2SSAH. 3BFAh, DMA2SIRQ = 3BBAh. 3BFAh, 3BBFh = -. 3BFAh, - = 3B9Ah. 3BFAh, 3B9Fh = -. 3BFAh, - = 3B7Ah. 3BFAh, 3B7Fh = -. 3BFAh, - = 3B5Ah. 3BFAh, 3B5Fh - = -. 3BFAh, 3B3Fh = 3B3Ah -. 3BFAh, - = 3B1Ah. 3BFAh, 3B1Fh = . 3BFAh, - = -. 3BF9h, DMA1SIRQ = DMA1SSAL. 3BF9h, 3BDFh = 3BD9h",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\nDMA2SSAL. 3BF9h, DMA2SIRQ = 3BB9h. 3BF9h, 3BBFh = -. 3BF9h, - = 3B99h. 3BF9h, 3B9Fh = -. 3BF9h, - = 3B79h. 3BF9h, 3B7Fh = -. 3BF9h, - = 3B59h. 3BF9h, 3B5Fh - = -. 3BF9h, 3B3Fh = 3B39h -. 3BF9h, - = 3B19h. 3BF9h, 3B1Fh = . 3BF9h, - = -. 3BF8h, DMA1SIRQ = DMA1SSZH. 3BF8h, 3BDFh = 3BD8h DMA2SSZH. 3BF8h, DMA2SIRQ = 3BB8h. 3BF8h, 3BBFh = -.",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BF8h, - = 3B98h. 3BF8h, 3B9Fh = -. 3BF8h, - = 3B78h. 3BF8h, 3B7Fh = -. 3BF8h, - = 3B58h. 3BF8h, 3B5Fh - = -. 3BF8h, 3B3Fh = 3B38h -. 3BF8h, - = . 3BF8h, 3B1Fh = 3B18h. 3BF8h, - = -. 3BF7h, DMA1SIRQ = DMA1SSZL. 3BF7h, 3BDFh = 3BD7h DMA2SSZL. 3BF7h, DMA2SIRQ = 3BB7h. 3BF7h, 3BBFh = -. 3BF7h, - = 3B97h. 3BF7h, 3B9Fh = -. 3BF7h, - =",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3B77h. 3BF7h, 3B7Fh = -. 3BF7h, - = 3B57h. 3BF7h, 3B5Fh - = -. 3BF7h, 3B3Fh = 3B37h -. 3BF7h, - = . 3BF7h, 3B1Fh = 3B17h. 3BF7h, - = -. 3BF6h, DMA1SIRQ = DMA1SPTRU. 3BF6h, 3BDFh = 3BD6h. 3BF6h, DMA2SIRQ = DMA2SPTRU 3BB6h. 3BF6h, 3BBFh = -. 3BF6h, - = 3B96h. 3BF6h, 3B9Fh = -. 3BF6h, - = 3B76h. 3BF6h, 3B7Fh = -. 3BF6h, - = 3B56h.",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BF6h, 3B5Fh - = -. 3BF6h, 3B3Fh = 3B36h -. 3BF6h, - = 3B16h. 3BF6h, 3B1Fh = . 3BF6h, - = -. 3BF5h, DMA1SIRQ = DMA1SPTRH. 3BF5h, 3BDFh = 3BD5h DMA2SPTRH. 3BF5h, DMA2SIRQ = 3BB5h. 3BF5h, 3BBFh = -. 3BF5h, - = 3B95h. 3BF5h, 3B9Fh = -. 3BF5h, - = 3B75h. 3BF5h, 3B7Fh = -. 3BF5h, - = 3B55h. 3BF5h, 3B5Fh - = -. 3BF5h, 3B3Fh = 3B35h -. 3BF5h,",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n- = . 3BF5h, 3B1Fh = 3B15h. 3BF5h, - = -. 3BF4h, DMA1SIRQ = DMA1SPTRL. 3BF4h, 3BDFh = 3BD4h DMA2SPTRL. 3BF4h, DMA2SIRQ = 3BB4h. 3BF4h, 3BBFh = -. 3BF4h, - = 3B94h. 3BF4h, 3B9Fh = -. 3BF4h, - = 3B74h. 3BF4h, 3B7Fh = -. 3BF4h, - = 3B54h. 3BF4h, 3B5Fh - = -. 3BF4h, 3B3Fh = 3B34h -. 3BF4h, - = . 3BF4h, 3B1Fh = 3B14h. 3BF4h, - = -. 3BF3h,",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\nDMA1SIRQ = DMA1SCNTH. 3BF3h, 3BDFh = 3BD3h DMA2SCNTH. 3BF3h, DMA2SIRQ = 3BB3h. 3BF3h, 3BBFh = -. 3BF3h, - = 3B93h. 3BF3h, 3B9Fh = -. 3BF3h, - = 3B73h. 3BF3h, 3B7Fh = -. 3BF3h, - = 3B53h. 3BF3h, 3B5Fh - = -. 3BF3h, 3B3Fh = 3B33h -. 3BF3h, - = . 3BF3h, 3B1Fh = 3B13h. 3BF3h, - = -. 3BF2h, DMA1SIRQ = DMA1SCNTL. 3BF2h, 3BDFh = 3BD2h DMA2SCNTL.",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BF2h, DMA2SIRQ = 3BB2h. 3BF2h, 3BBFh = -. 3BF2h, - = 3B92h. 3BF2h, 3B9Fh = -. 3BF2h, - = 3B72h. 3BF2h, 3B7Fh = -. 3BF2h, - = 3B52h. 3BF2h, 3B5Fh - = -. 3BF2h, 3B3Fh = 3B32h -. 3BF2h, - = . 3BF2h, 3B1Fh = 3B12h. 3BF2h, - = -. 3BF1h, DMA1SIRQ = DMA1DSAH. 3BF1h, 3BDFh = 3BD1h. 3BF1h, DMA2SIRQ = DMA2DSAH 3BB1h. 3BF1h, 3BBFh = -. 3BF1h, - =",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3B91h. 3BF1h, 3B9Fh = -. 3BF1h, - = 3B71h. 3BF1h, 3B7Fh = -. 3BF1h, - = 3B51h. 3BF1h, 3B5Fh - = -. 3BF1h, 3B3Fh = 3B31h -. 3BF1h, - = . 3BF1h, 3B1Fh = 3B11h. 3BF1h, - = -. 3BF0h, DMA1SIRQ = DMA1DSAL. 3BF0h, 3BDFh = 3BD0h DMA2DSAL. 3BF0h, DMA2SIRQ = 3BB0h. 3BF0h, 3BBFh = -. 3BF0h, - = 3B90h. 3BF0h, 3B9Fh = -. 3BF0h, - = 3B70h. 3BF0h,",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3B7Fh = -. 3BF0h, - = 3B50h. 3BF0h, 3B5Fh - = -. 3BF0h, 3B3Fh = 3B30h -. 3BF0h, - = 3B10h. 3BF0h, 3B1Fh = . 3BF0h, - = -. 3BEFh, DMA1SIRQ = DMA1DSZH. 3BEFh, 3BDFh = 3BCFh. 3BEFh, DMA2SIRQ = DMA2DSZH 3BAFh. 3BEFh, 3BBFh = -. 3BEFh, - = 3B8Fh. 3BEFh, 3B9Fh = -. 3BEFh, - = 3B6Fh. 3BEFh, 3B7Fh = -. 3BEFh, - = 3B4Fh. 3BEFh, 3B5Fh - = -.",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BEFh, 3B3Fh = 3B2Fh -. 3BEFh, - = . 3BEFh, 3B1Fh = 3B0Fh. 3BEFh, - = -. 3BEEh, DMA1SIRQ = DMA1DSZL. 3BEEh, 3BDFh = 3BCEh. 3BEEh, DMA2SIRQ = DMA2DSZL. 3BEEh, 3BBFh = 3BAEh -. 3BEEh, - = 3B8Eh. 3BEEh, 3B9Fh = -. 3BEEh, - = 3B6Eh. 3BEEh, 3B7Fh = -. 3BEEh, - = 3B4Eh. 3BEEh, 3B5Fh - = -. 3BEEh, 3B3Fh = 3B2Eh -. 3BEEh, - = . 3BEEh, 3B1Fh = 3B0Eh. 3BEEh, - = -.",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BEDh, DMA1SIRQ = DMA1DPTRH. 3BEDh, 3BDFh = 3BCDh. 3BEDh, DMA2SIRQ = DMA2DPTRH 3BADh. 3BEDh, 3BBFh = -. 3BEDh, - = 3B8Dh. 3BEDh, 3B9Fh = -. 3BEDh, - = 3B6Dh. 3BEDh, 3B7Fh = -. 3BEDh, - = . 3BEDh, 3B5Fh - = 3B4Dh -. 3BEDh, 3B3Fh = 3B2Dh -. 3BEDh, - = . 3BEDh, 3B1Fh = 3B0Dh. 3BEDh, - = -. 3BECh, DMA1SIRQ = DMA1DPTRL. 3BECh, 3BDFh = 3BCCh DMA2DPTRL. 3BECh, DMA2SIRQ = 3BACh. 3BECh,",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BBFh = -. 3BECh, - = 3B8Ch. 3BECh, 3B9Fh = -. 3BECh, - = 3B6Ch. 3BECh, 3B7Fh = -. 3BECh, - = 3B4Ch. 3BECh, 3B5Fh - = -. 3BECh, 3B3Fh = 3B2Ch -. 3BECh, - = . 3BECh, 3B1Fh = 3B0Ch. 3BECh, - = -. 3BEBh, DMA1SIRQ = DMA1DCNTH. 3BEBh, 3BDFh = 3BCBh. 3BEBh, DMA2SIRQ = DMA2DCNTH 3BABh. 3BEBh, 3BBFh = -. 3BEBh, - = 3B8Bh. 3BEBh, 3B9Fh = -. 3BEBh, - = 3B6Bh. 3BEBh, 3B7Fh = -.",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BEBh, - = 3B4Bh. 3BEBh, 3B5Fh - = -. 3BEBh, 3B3Fh = 3B2Bh -. 3BEBh, - = . 3BEBh, 3B1Fh = 3B0Bh. 3BEBh, - = -. 3BEAh, DMA1SIRQ = DMA1DCNTL. 3BEAh, 3BDFh = 3BCAh DMA2DCNTL. 3BEAh, DMA2SIRQ = 3BAAh. 3BEAh, 3BBFh = -. 3BEAh, - = 3B8Ah. 3BEAh, 3B9Fh = -. 3BEAh, - = 3B6Ah. 3BEAh, 3B7Fh = -. 3BEAh, - = . 3BEAh, 3B5Fh - = 3B4Ah -. 3BEAh, 3B3Fh = 3B2Ah. 3BEAh, - = -. 3BEAh,",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3B1Fh = 3B0Ah. 3BEAh, - = -. 3BE9h, DMA1SIRQ = DMA1BUF. 3BE9h, 3BDFh = 3BC9h. 3BE9h, DMA2SIRQ = DMA2BUF 3BA9h. 3BE9h, 3BBFh = -. 3BE9h, - = 3B89h. 3BE9h, 3B9Fh = -. 3BE9h, - = 3B69h. 3BE9h, 3B7Fh = -. 3BE9h, - = . 3BE9h, 3B5Fh - = 3B49h -. 3BE9h, 3B3Fh = 3B29h -. 3BE9h, - = . 3BE9h, 3B1Fh = 3B09h. 3BE9h, - = -. 3BE8h, DMA1SIRQ = -. 3BE8h,",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BDFh = 3BC8h -. 3BE8h, DMA2SIRQ = 3BA8h. 3BE8h, 3BBFh = -. 3BE8h, - = 3B88h. 3BE8h, 3B9Fh = -. 3BE8h, - = 3B68h. 3BE8h, 3B7Fh = -. 3BE8h, - = . 3BE8h, 3B5Fh - = 3B48h -. 3BE8h, 3B3Fh = 3B28h -. 3BE8h, - = . 3BE8h, 3B1Fh = 3B08h. 3BE8h, - = -. 3BE7h, DMA1SIRQ = -. 3BE7h, 3BDFh = 3BC7h. 3BE7h, DMA2SIRQ = - 3BA7h. 3BE7h, 3BBFh = -. 3BE7h, -",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n= 3B87h. 3BE7h, 3B9Fh = -. 3BE7h, - = 3B67h. 3BE7h, 3B7Fh = -. 3BE7h, - = 3B47h. 3BE7h, 3B5Fh - = -. 3BE7h, 3B3Fh = 3B27h -. 3BE7h, - = . 3BE7h, 3B1Fh = 3B07h. 3BE7h, - = -. 3BE6h, DMA1SIRQ = -. 3BE6h, 3BDFh = 3BC6h. 3BE6h, DMA2SIRQ = - 3BA6h. 3BE6h, 3BBFh = -. 3BE6h, - = 3B86h. 3BE6h, 3B9Fh = -. 3BE6h, - = 3B66h. 3BE6h, 3B7Fh = -.",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BE6h, - = . 3BE6h, 3B5Fh - = 3B46h -. 3BE6h, 3B3Fh = 3B26h -. 3BE6h, - = 3B06h. 3BE6h, 3B1Fh = . 3BE6h, - = -. 3BE5h, DMA1SIRQ = -. 3BE5h, 3BDFh = 3BC5h -. 3BE5h, DMA2SIRQ = 3BA5h. 3BE5h, 3BBFh = -. 3BE5h, - = 3B85h. 3BE5h, 3B9Fh = -. 3BE5h, - = 3B65h. 3BE5h, 3B7Fh = -. 3BE5h, - = . 3BE5h, 3B5Fh - = 3B45h -. 3BE5h, 3B3Fh = 3B25h -.",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BE5h, - = . 3BE5h, 3B1Fh = 3B05h. 3BE5h, - = -. 3BE4h, DMA1SIRQ = -. 3BE4h, 3BDFh = 3BC4h -. 3BE4h, DMA2SIRQ = 3BA4h. 3BE4h, 3BBFh = -. 3BE4h, - = 3B84h. 3BE4h, 3B9Fh = -. 3BE4h, - = 3B64h. 3BE4h, 3B7Fh = -. 3BE4h, - = 3B44h. 3BE4h, 3B5Fh - = -. 3BE4h, 3B3Fh = 3B24h -. 3BE4h, - = . 3BE4h, 3B1Fh = 3B04h. 3BE4h, - = -. 3BE3h, DMA1SIRQ =",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n-. 3BE3h, 3BDFh = 3BC3h -. 3BE3h, DMA2SIRQ = 3BA3h. 3BE3h, 3BBFh = -. 3BE3h, - = 3B83h. 3BE3h, 3B9Fh = -. 3BE3h, - = 3B63h. 3BE3h, 3B7Fh = . 3BE3h, - = -. 3BE3h, 3B5Fh - = 3B43h -. 3BE3h, 3B3Fh = 3B23h -. 3BE3h, - = . 3BE3h, 3B1Fh = 3B03h. 3BE3h, - = -. 3BE2h, DMA1SIRQ = -. 3BE2h, 3BDFh = 3BC2h -. 3BE2h, DMA2SIRQ = 3BA2h. 3BE2h, 3BBFh =",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n-. 3BE2h, - = 3B82h. 3BE2h, 3B9Fh = -. 3BE2h, - = 3B62h. 3BE2h, 3B7Fh = -. 3BE2h, - = . 3BE2h, 3B5Fh - = 3B42h -. 3BE2h, 3B3Fh = 3B22h. 3BE2h, - = -. 3BE2h, 3B1Fh = 3B02h. 3BE2h, - = -. 3BE1h, DMA1SIRQ = -. 3BE1h, 3BDFh = 3BC1h. 3BE1h, DMA2SIRQ = - 3BA1h. 3BE1h, 3BBFh = -. 3BE1h, - = 3B81h. 3BE1h, 3B9Fh = -. 3BE1h, - = 3B61h.",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3BE1h, 3B7Fh = -. 3BE1h, - = 3B41h. 3BE1h, 3B5Fh - = -. 3BE1h, 3B3Fh = 3B21h. 3BE1h, - = -. 3BE1h, 3B1Fh = 3B01h. 3BE1h, - = -. 3BE0h, DMA1SIRQ = -. 3BE0h, 3BDFh = 3BC0h. 3BE0h, DMA2SIRQ = -. 3BE0h, 3BBFh = 3BA0h -. 3BE0h, - = 3B80h. 3BE0h, 3B9Fh = -. 3BE0h, - = 3B60h. 3BE0h, 3B7Fh = -. 3BE0h, - = . 3BE0h, 3B5Fh - = 3B40h -. 3BE0h,",
    "TABLE 4-7: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 59\n3B3Fh = 3B20h -. 3BE0h, - = . 3BE0h, 3B1Fh = 3B00h. 3BE0h, - = -\nLegend:\nUnimplemented data memory locations and registers, read as ' 0 '.",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3AFEh, - = -. 3AFEh, 3ADFh = 3ADEh. 3AFEh, ADACTPPS = CLCIN3PPS 3ABEh. 3AFEh, 3ABFh = -. 3AFEh, PPSLOCK = . 3AFEh, 3A9Fh = 3A9Eh. 3AFEh, - 3A7Fh = - 3A7Eh. 3AFEh, - = - 3A5Eh. 3AFEh, 3A5Fh = -. 3AFEh, - = 3A3Eh. 3AFEh, 3A3Fh = -. 3AFEh, - = . 3AFEh, 3A1Fh = 3A1Eh. 3AFEh, - = -. 3AFDh, - = -. 3AFDh, 3ADFh = 3ADDh. 3AFDh, ADACTPPS = CLCIN2PPS 3ABDh. 3AFDh, 3ABFh = -. 3AFDh, PPSLOCK = . 3AFDh, 3A9Fh = 3A9Dh. 3AFDh, - 3A7Fh =",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n- 3A7Dh. 3AFDh, - = - 3A5Dh. 3AFDh, 3A5Fh = -. 3AFDh, - = . 3AFDh, 3A3Fh = 3A3Dh -. 3AFDh, - = 3A1Dh. 3AFDh, 3A1Fh = . 3AFDh, - = -. 3AFCh, - = -. 3AFCh, 3ADFh = 3ADCh. 3AFCh, ADACTPPS = CLCIN1PPS 3ABCh. 3AFCh, 3ABFh = -. 3AFCh, PPSLOCK = 3A9Ch. 3AFCh, 3A9Fh = . 3AFCh, - 3A7Fh = - 3A7Ch. 3AFCh, - = - 3A5Ch. 3AFCh, 3A5Fh = -. 3AFCh, - = . 3AFCh, 3A3Fh = 3A3Ch -. 3AFCh, - = . 3AFCh, 3A1Fh = 3A1Ch. 3AFCh, - = -.",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3AFBh, - = -. 3AFBh, 3ADFh = 3ADBh. 3AFBh, ADACTPPS = CLCIN0PPS 3ABBh. 3AFBh, 3ABFh = -. 3AFBh, PPSLOCK = 3A9Bh. 3AFBh, 3A9Fh = -. 3AFBh, - 3A7Fh = 3A7Bh. 3AFBh, - = - 3A5Bh. 3AFBh, 3A5Fh = RB2I2C. 3AFBh, - = 3A3Bh. 3AFBh, 3A3Fh = -. 3AFBh, - = . 3AFBh, 3A1Fh = 3A1Bh. 3AFBh, - = -. 3AFAh, - = -. 3AFAh, 3ADFh = 3ADAh. 3AFAh, ADACTPPS = MD1SRCPPS. 3AFAh, 3ABFh = 3ABAh -. 3AFAh, PPSLOCK = 3A9Ah. 3AFAh, 3A9Fh = . 3AFAh, -",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3A7Fh = - 3A7Ah. 3AFAh, - = -. 3AFAh, 3A5Fh = 3A5Ah RB1I2C. 3AFAh, - = . 3AFAh, 3A3Fh = 3A3Ah -. 3AFAh, - = . 3AFAh, 3A1Fh = 3A1Ah. 3AFAh, - = -. 3AF9h, - = -. 3AF9h, 3ADFh = 3AD9h. 3AF9h, ADACTPPS = MD1CARHPPS. 3AF9h, 3ABFh = 3AB9h -. 3AF9h, PPSLOCK = 3A99h. 3AF9h, 3A9Fh = -. 3AF9h, - 3A7Fh = 3A79h. 3AF9h, - = -. 3AF9h, 3A5Fh = 3A59h -. 3AF9h, - = . 3AF9h, 3A3Fh = 3A39h -.",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3AF9h, - = . 3AF9h, 3A1Fh = 3A19h. 3AF9h, - = -. 3AF8h, - = -. 3AF8h, 3ADFh = 3AD8h. 3AF8h, ADACTPPS = MD1CARLPPS. 3AF8h, 3ABFh = 3AB8h -. 3AF8h, PPSLOCK = 3A98h. 3AF8h, 3A9Fh = . 3AF8h, - 3A7Fh = - 3A78h. 3AF8h, - = -. 3AF8h, 3A5Fh = 3A58h. 3AF8h, - = -. 3AF8h, 3A3Fh = 3A38h -. 3AF8h, - = . 3AF8h, 3A1Fh = 3A18h. 3AF8h, - = -. 3AF7h, - = -. 3AF7h, 3ADFh = 3AD7h.",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3AF7h, ADACTPPS = CWG3INPPS. 3AF7h, 3ABFh = 3AB7h -. 3AF7h, PPSLOCK = . 3AF7h, 3A9Fh = 3A97h. 3AF7h, - 3A7Fh = - 3A77h. 3AF7h, - = -. 3AF7h, 3A5Fh = 3A57h. 3AF7h, - = IOCBF. 3AF7h, 3A3Fh = 3A37h. 3AF7h, - = -. 3AF7h, 3A1Fh = 3A17h. 3AF7h, - = RC7PPS. 3AF6h, - = -. 3AF6h, 3ADFh = 3AD6h. 3AF6h, ADACTPPS = CWG2INPPS. 3AF6h, 3ABFh = 3AB6h. 3AF6h, PPSLOCK = -. 3AF6h, 3A9Fh = 3A96h.",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3AF6h, - 3A7Fh = - 3A76h. 3AF6h, - = -. 3AF6h, 3A5Fh = 3A56h. 3AF6h, - = IOCBN. 3AF6h, 3A3Fh = 3A36h. 3AF6h, - = -. 3AF6h, 3A1Fh = 3A16h. 3AF6h, - = RC6PPS. 3AF5h, - = -. 3AF5h, 3ADFh = 3AD5h. 3AF5h, ADACTPPS = CWG1INPPS. 3AF5h, 3ABFh = 3AB5h. 3AF5h, PPSLOCK = -. 3AF5h, 3A9Fh = 3A95h. 3AF5h, - 3A7Fh = - 3A75h. 3AF5h, - = -. 3AF5h, 3A5Fh = 3A55h. 3AF5h, - = IOCBP. 3AF5h,",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3A3Fh = 3A35h 3A34h. 3AF5h, - = -. 3AF5h, 3A1Fh = 3A15h. 3AF5h, - = RC5PPS. 3AF4h, - = -. 3AF4h, 3ADFh = 3AD4h. 3AF4h, ADACTPPS = SMT2SIGPPS. 3AF4h, 3ABFh = 3AB4h -. 3AF4h, PPSLOCK = . 3AF4h, 3A9Fh = 3A94h. 3AF4h, - 3A7Fh = - 3A74h. 3AF4h, - = -. 3AF4h, 3A5Fh = 3A54h. 3AF4h, - = INLVLB. 3AF4h, 3A3Fh = . 3AF4h, - = -. 3AF4h, 3A1Fh = 3A14h. 3AF4h, - = RC4PPS. 3AF3h, - = -.",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3AF3h, 3ADFh = 3AD3h. 3AF3h, ADACTPPS = SMT2WINPPS. 3AF3h, 3ABFh = 3AB3h. 3AF3h, PPSLOCK = -. 3AF3h, 3A9Fh = 3A93h. 3AF3h, - 3A7Fh = - 3A73h. 3AF3h, - = -. 3AF3h, 3A5Fh = 3A53h. 3AF3h, - = SLRCONB. 3AF3h, 3A3Fh = 3A33h. 3AF3h, - = -. 3AF3h, 3A1Fh = 3A13h. 3AF3h, - = RC3PPS. 3AF2h, - = -. 3AF2h, 3ADFh = 3AD2h. 3AF2h, ADACTPPS = SMT1SIGPPS. 3AF2h, 3ABFh = 3AB2h. 3AF2h, PPSLOCK =",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n-. 3AF2h, 3A9Fh = 3A92h. 3AF2h, - 3A7Fh = - 3A72h. 3AF2h, - = -. 3AF2h, 3A5Fh = 3A52h. 3AF2h, - = ODCONB. 3AF2h, 3A3Fh = . 3AF2h, - = -. 3AF2h, 3A1Fh = 3A12h. 3AF2h, - = RC2PPS. 3AF1h, - = -. 3AF1h, 3ADFh = 3AD1h. 3AF1h, ADACTPPS = SMT1WINPPS. 3AF1h, 3ABFh = 3AB1h. 3AF1h, PPSLOCK = -. 3AF1h, 3A9Fh = 3A91h. 3AF1h, - 3A7Fh = - 3A71h. 3AF1h, - = -. 3AF1h, 3A5Fh =",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3A51h. 3AF1h, - = WPUB. 3AF1h, 3A3Fh = 3A32h 3A31h. 3AF1h, - = -. 3AF1h, 3A1Fh = 3A11h. 3AF1h, - = RC1PPS. 3AF0h, - = -. 3AF0h, 3ADFh = 3AD0h. 3AF0h, ADACTPPS = CCP4PPS. 3AF0h, 3ABFh = 3AB0h -. 3AF0h, PPSLOCK = 3A90h. 3AF0h, 3A9Fh = -. 3AF0h, - 3A7Fh = 3A70h. 3AF0h, - = -. 3AF0h, 3A5Fh = 3A50h. 3AF0h, - = ANSELB. 3AF0h, 3A3Fh = -. 3AF0h, - = . 3AF0h, 3A1Fh = 3A10h. 3AF0h,",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n- = RC0PPS. 3AEFh, - = -. 3AEFh, 3ADFh = 3ACFh. 3AEFh, ADACTPPS = CCP3PPS. 3AEFh, 3ABFh = 3AAFh. 3AEFh, PPSLOCK = -. 3AEFh, 3A9Fh = 3A8Fh. 3AEFh, - 3A7Fh = - 3A6Fh. 3AEFh, - = -. 3AEFh, 3A5Fh = 3A4Fh. 3AEFh, - = -. 3AEFh, 3A3Fh = 3A30h 3A2Fh. 3AEFh, - = -. 3AEFh, 3A1Fh = 3A0Fh. 3AEFh, - = RB7PPS. 3AEEh, - = -. 3AEEh, 3ADFh = 3ACEh. 3AEEh, ADACTPPS = CCP2PPS. 3AEEh, 3ABFh = 3AAEh. 3AEEh, PPSLOCK = -. 3AEEh,",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3A9Fh = 3A8Eh. 3AEEh, - 3A7Fh = - 3A6Eh. 3AEEh, - = -. 3AEEh, 3A5Fh = 3A4Eh. 3AEEh, - = -. 3AEEh, 3A3Fh = 3A2Eh. 3AEEh, - = -. 3AEEh, 3A1Fh = 3A0Eh. 3AEEh, - = RB6PPS. 3AEDh, - = CANRXPPS. 3AEDh, 3ADFh = 3ACDh. 3AEDh, ADACTPPS = CCP1PPS. 3AEDh, 3ABFh = 3AADh. 3AEDh, PPSLOCK = -. 3AEDh, 3A9Fh = 3A8Dh. 3AEDh, - 3A7Fh = - 3A6Dh. 3AEDh, - = -. 3AEDh, 3A5Fh = 3A4Dh. 3AEDh, - = -. 3AEDh, 3A3Fh = 3A2Dh. 3AEDh, - =",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n-. 3AEDh, 3A1Fh = 3A0Dh. 3AEDh, - = RB5PPS. 3AECh, - = -. 3AECh, 3ADFh = 3ACCh. 3AECh, ADACTPPS = T6INPPS. 3AECh, 3ABFh = 3AACh. 3AECh, PPSLOCK = -. 3AECh, 3A9Fh = 3A8Ch. 3AECh, - 3A7Fh = - 3A6Ch. 3AECh, - = -. 3AECh, 3A5Fh = 3A4Ch. 3AECh, - = -. 3AECh, 3A3Fh = 3A2Ch. 3AECh, - = -. 3AECh, 3A1Fh = 3A0Ch. 3AECh, - = RB4PPS. 3AEBh, - = U2CTSPPS. 3AEBh, 3ADFh = 3ACBh. 3AEBh, ADACTPPS = T4INPPS. 3AEBh, 3ABFh = 3AABh. 3AEBh, PPSLOCK = -. 3AEBh, 3A9Fh",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n= 3A8Bh. 3AEBh, - 3A7Fh = - 3A6Bh. 3AEBh, - = RC4I2C. 3AEBh, 3A5Fh = 3A4Bh. 3AEBh, - = -. 3AEBh, 3A3Fh = 3A2Bh. 3AEBh, - = -. 3AEBh, 3A1Fh = 3A0Bh. 3AEBh, - = RB3PPS. 3AEAh, - = U2RXPPS. 3AEAh, 3ADFh = 3ACAh. 3AEAh, ADACTPPS = T2INPPS. 3AEAh, 3ABFh = 3AAAh. 3AEAh, PPSLOCK = -. 3AEAh, 3A9Fh = 3A8Ah. 3AEAh, - 3A7Fh = - 3A6Ah. 3AEAh, - = RC3I2C. 3AEAh, 3A5Fh = 3A4Ah. 3AEAh, - = -. 3AEAh, 3A3Fh = 3A2Ah.",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3AEAh, - = -. 3AEAh, 3A1Fh = 3A0Ah. 3AEAh, - = RB2PPS. 3AE9h, - = -. 3AE9h, 3ADFh = 3AC9h. 3AE9h, ADACTPPS = T5GPPS. 3AE9h, 3ABFh = 3AA9h. 3AE9h, PPSLOCK = -. 3AE9h, 3A9Fh = 3A89h. 3AE9h, - 3A7Fh = - 3A69h. 3AE9h, - = -. 3AE9h, 3A5Fh = 3A49h. 3AE9h, - = -. 3AE9h, 3A3Fh = 3A29h -. 3AE9h, - = . 3AE9h, 3A1Fh = 3A09h. 3AE9h, - = RB1PPS. 3AE8h, - = U1CTSPPS. 3AE8h, 3ADFh =",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3AC8h. 3AE8h, ADACTPPS = T5CKIPPS. 3AE8h, 3ABFh = 3AA8h. 3AE8h, PPSLOCK = -. 3AE8h, 3A9Fh = 3A88h. 3AE8h, - 3A7Fh = - 3A68h. 3AE8h, - = -. 3AE8h, 3A5Fh = 3A48h. 3AE8h, - = -. 3AE8h, 3A3Fh = 3A28h -. 3AE8h, - = . 3AE8h, 3A1Fh = 3A08h. 3AE8h, - = RB0PPS. 3AE7h, - = U1RXPPS. 3AE7h, 3ADFh = 3AC7h. 3AE7h, ADACTPPS = T3GPPS. 3AE7h, 3ABFh = 3AA7h. 3AE7h, PPSLOCK = -. 3AE7h,",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3A9Fh = 3A87h. 3AE7h, - 3A7Fh = IOCEF 3A67h. 3AE7h, - = IOCCF. 3AE7h, 3A5Fh = 3A47h. 3AE7h, - = IOCAF. 3AE7h, 3A3Fh = 3A27h. 3AE7h, - = -. 3AE7h, 3A1Fh = 3A07h. 3AE7h, - = RA7PPS. 3AE6h, - = I2C2SDAPPS. 3AE6h, 3ADFh = 3AC6h. 3AE6h, ADACTPPS = T3CKIPPS. 3AE6h, 3ABFh = 3AA6h. 3AE6h, PPSLOCK = -. 3AE6h, 3A9Fh = 3A86h. 3AE6h, - 3A7Fh = IOCEN 3A66h. 3AE6h, - = IOCCN. 3AE6h, 3A5Fh",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n= 3A46h. 3AE6h, - = IOCAN. 3AE6h, 3A3Fh = 3A26h. 3AE6h, - = -. 3AE6h, 3A1Fh = 3A06h. 3AE6h, - = RA6PPS. 3AE5h, - = I2C2SCLPPS. 3AE5h, 3ADFh = 3AC5h. 3AE5h, ADACTPPS = T1GPPS. 3AE5h, 3ABFh = 3AA5h. 3AE5h, PPSLOCK = -. 3AE5h, 3A9Fh = 3A85h. 3AE5h, - 3A7Fh = IOCEP 3A65h. 3AE5h, - = IOCCP. 3AE5h, 3A5Fh = 3A45h. 3AE5h, - = IOCAP. 3AE5h, 3A3Fh = 3A25h. 3AE5h, - = -. 3AE5h, 3A1Fh =",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3A05h. 3AE5h, - = RA5PPS. 3AE4h, - = I2C1SDAPPS. 3AE4h, 3ADFh = 3AC4h. 3AE4h, ADACTPPS = T1CKIPPS. 3AE4h, 3ABFh = 3AA4h. 3AE4h, PPSLOCK = -. 3AE4h, 3A9Fh = 3A84h. 3AE4h, - 3A7Fh = INLVLE 3A64h. 3AE4h, - = INLVLC. 3AE4h, 3A5Fh = 3A44h. 3AE4h, - = INLVLA. 3AE4h, 3A3Fh = 3A24h. 3AE4h, - = -. 3AE4h, 3A1Fh = 3A04h. 3AE4h, - = RA4PPS. 3AE3h, - = I2C1SCLPPS. 3AE3h, 3ADFh =",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3AC3h. 3AE3h, ADACTPPS = T0CKIPPS. 3AE3h, 3ABFh = 3AA3h. 3AE3h, PPSLOCK = -. 3AE3h, 3A9Fh = 3A83h. 3AE3h, - 3A7Fh = - 3A63h. 3AE3h, - = SLRCONC. 3AE3h, 3A5Fh = 3A43h. 3AE3h, - = SLRCONA. 3AE3h, 3A3Fh = 3A23h. 3AE3h, - = -. 3AE3h, 3A1Fh = 3A03h. 3AE3h, - = RA3PPS. 3AE2h, - = SPI1SSPPS. 3AE2h, 3ADFh = 3AC2h. 3AE2h, ADACTPPS = INT2PPS. 3AE2h, 3ABFh = 3AA2h. 3AE2h, PPSLOCK = -. 3AE2h,",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3A9Fh = 3A82h. 3AE2h, - 3A7Fh = - 3A62h. 3AE2h, - = ODCONC. 3AE2h, 3A5Fh = 3A42h. 3AE2h, - = ODCONA. 3AE2h, 3A3Fh = 3A22h. 3AE2h, - = -. 3AE2h, 3A1Fh = 3A02h. 3AE2h, - = RA2PPS. 3AE1h, - = SPI1SDIPPS. 3AE1h, 3ADFh = 3AC1h. 3AE1h, ADACTPPS = INT1PPS. 3AE1h, 3ABFh = 3AA1h. 3AE1h, PPSLOCK = -. 3AE1h, 3A9Fh = 3A81h. 3AE1h, - 3A7Fh = WPUE 3A61h. 3AE1h, - = WPUC. 3AE1h,",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3A5Fh = 3A41h. 3AE1h, - = WPUA. 3AE1h, 3A3Fh = 3A21h. 3AE1h, - = -. 3AE1h, 3A1Fh = 3A01h. 3AE1h, - = RA1PPS. , - = SPI1SCKPPS. , 3ADFh = 3AC0h. , ADACTPPS = . , 3ABFh = 3AA0h. , PPSLOCK = -. , 3A9Fh = 3A80h. , - 3A7Fh = - 3A60h. , - = . , 3A5Fh = . , - = ANSELA. , 3A3Fh = . , - = -. , 3A1Fh = 3A00h. , - = . 3AE0h, - = . 3AE0h, 3ADFh = . 3AE0h, ADACTPPS = INT0PPS. 3AE0h, 3ABFh = . 3AE0h, PPSLOCK = .",
    "TABLE 4-8: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 58\n3AE0h, 3A9Fh = . 3AE0h, - 3A7Fh = . 3AE0h, - = ANSELC. 3AE0h, 3A5Fh = 3A40h. 3AE0h, - = . 3AE0h, 3A3Fh = 3A20h. 3AE0h, - = . 3AE0h, 3A1Fh = . 3AE0h, - = RA0PPS\nLegend: Unimplemented data memory locations and registers, read as ' 0 '.",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39FEh, - = -. 39FEh, 39DFh = 39DEh OSCTUNE. 39FEh, OSCFRQ = 39BEh. 39FEh, 39BFh = -. 39FEh, - = 399Eh. 39FEh, 399Fh = -. 39FEh, - = 397Eh. 39FEh, 397Fh = -. 39FEh, - = 395Eh. 39FEh, 395Fh = WDTH. 39FEh, WDTU = 393Eh. 39FEh, 393Fh - = -. 39FEh, 391Fh = 391Eh. 39FEh, - = -. 39FDh, - = -. 39FDh, 39DFh = 39DDh OSCEN. 39FDh, OSCFRQ = 39BDh. 39FDh, 39BFh = -. 39FDh, - = 399Dh. 39FDh, 399Fh = -. 39FDh, - = 397Dh.",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39FDh, 397Fh = SCANTRIG. 39FDh, - = 395Dh. 39FDh, 395Fh = WDTL. 39FDh, WDTU = 393Dh. 39FDh, 393Fh - = -. 39FDh, 391Fh = 391Dh. 39FDh, - = -. 39FCh, - = -. 39FCh, 39DFh = 39DCh OSCSTAT. 39FCh, OSCFRQ = 39BCh. 39FCh, 39BFh = -. 39FCh, - = 399Ch. 39FCh, 399Fh = -. 39FCh, - = 397Ch. 39FCh, 397Fh = SCANCON0. 39FCh, - = 395Ch. 39FCh, 395Fh = WDTCON1. 39FCh, WDTU = 393Ch. 39FCh, 393Fh - = -. 39FCh, 391Fh = 391Ch.",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39FCh, - = -. 39FBh, - = - 39DBh. 39FBh, 39DFh = OSCCON3. 39FBh, OSCFRQ = 39BBh. 39FBh, 39BFh = -. 39FBh, - = 399Bh. 39FBh, 399Fh = -. 39FBh, - = 397Bh. 39FBh, 397Fh = SCANHADRU. 39FBh, - = 395Bh. 39FBh, 395Fh = WDTCON0. 39FBh, WDTU = 393Bh. 39FBh, 393Fh - = -. 39FBh, 391Fh = 391Bh. 39FBh, - = -. 39FAh, - = -. 39FAh, 39DFh = 39DAh OSCCON2. 39FAh, OSCFRQ = 39BAh. 39FAh, 39BFh = -. 39FAh, - = 399Ah. 39FAh, 399Fh =",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n-. 39FAh, - = 397Ah. 39FAh, 397Fh = SCANHADRH. 39FAh, - = 395Ah. 39FAh, 395Fh = -. 39FAh, WDTU = 393Ah. 39FAh, 393Fh - = -. 39FAh, 391Fh = 391Ah. 39FAh, - = -. 39F9h, - = -. 39F9h, 39DFh = 39D9h OSCCON1. 39F9h, OSCFRQ = 39B9h. 39F9h, 39BFh = -. 39F9h, - = 3999h. 39F9h, 399Fh = PIE9. 39F9h, - = 3979h. 39F9h, 397Fh = SCANHADRL. 39F9h, - = 3959h. 39F9h, 395Fh = -. 39F9h, WDTU = 3939h.",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39F9h, 393Fh - = -. 39F9h, 391Fh = 3919h. 39F9h, - = -. 39F8h, - = -. 39F8h, 39DFh = 39D8h CPUDOZE. 39F8h, OSCFRQ = 39B8h. 39F8h, 39BFh = -. 39F8h, - = 3998h. 39F8h, 399Fh = PIE8. 39F8h, - = 3978h. 39F8h, 397Fh = SCANLADRU. 39F8h, - = 3958h. 39F8h, 395Fh = -. 39F8h, WDTU = 3938h. 39F8h, 393Fh - = -. 39F8h, 391Fh = 3918h. 39F8h, - = -. 39F7h, - = SCANPR. 39F7h, 39DFh =",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39D7h -. 39F7h, OSCFRQ = 39B7h. 39F7h, 39BFh = -. 39F7h, - = 3997h. 39F7h, 399Fh = PIE7. 39F7h, - = 3977h. 39F7h, 397Fh = SCANLADRH. 39F7h, - = 3957h. 39F7h, 395Fh = -. 39F7h, WDTU = 3937h. 39F7h, 393Fh - = -. 39F7h, 391Fh = 3917h. 39F7h, - = -. 39F6h, - = -. 39F6h, 39DFh = 39D6h -. 39F6h, OSCFRQ = 39B6h. 39F6h, 39BFh = -. 39F6h, - = 3996h. 39F6h, 399Fh = PIE6.",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39F6h, - = 3976h. 39F6h, 397Fh = SCANLADRL. 39F6h, - = 3956h. 39F6h, 395Fh = -. 39F6h, WDTU = 3936h. 39F6h, 393Fh - = -. 39F6h, 391Fh = 3916h. 39F6h, - = -. 39F5h, - = - 39D5h. 39F5h, 39DFh = -. 39F5h, OSCFRQ = 39B5h. 39F5h, 39BFh = -. 39F5h, - = 3995h. 39F5h, 399Fh = PIE5. 39F5h, - = 3975h. 39F5h, 397Fh = -. 39F5h, - = 3955h. 39F5h, 395Fh = -. 39F5h, WDTU = 3935h.",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39F5h, 393Fh - = -. 39F5h, 391Fh = 3915h. 39F5h, - = -. 39F4h, - = DMA2PR 39D4h. 39F4h, 39DFh = -. 39F4h, OSCFRQ = 39B4h. 39F4h, 39BFh = -. 39F4h, - = 3994h. 39F4h, 399Fh = PIE4. 39F4h, - = 3974h. 39F4h, 397Fh = -. 39F4h, - = 3954h. 39F4h, 395Fh = -. 39F4h, WDTU = 3934h. 39F4h, 393Fh - = -. 39F4h, 391Fh = 3914h. 39F4h, - = -. 39F3h, - = DMA1PR. 39F3h, 39DFh =",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39D3h -. 39F3h, OSCFRQ = 39B3h. 39F3h, 39BFh = -. 39F3h, - = 3993h. 39F3h, 399Fh = PIE3. 39F3h, - = 3973h. 39F3h, 397Fh = -. 39F3h, - = 3953h. 39F3h, 395Fh = -. 39F3h, WDTU = . 39F3h, 393Fh - = 3933h -. 39F3h, 391Fh = 3913h. 39F3h, - = -. 39F2h, - = MAINPR. 39F2h, 39DFh = 39D2h -. 39F2h, OSCFRQ = 39B2h. 39F2h, 39BFh = -. 39F2h, - = 3992h. 39F2h, 399Fh = PIE2.",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39F2h, - = 3972h. 39F2h, 397Fh = -. 39F2h, - = 3952h. 39F2h, 395Fh = -. 39F2h, WDTU = 3932h. 39F2h, 393Fh - = -. 39F2h, 391Fh = 3912h. 39F2h, - = -. 39F1h, - = ISRPR. 39F1h, 39DFh = 39D1h VREGCON (1). 39F1h, OSCFRQ = 39B1h. 39F1h, 39BFh = -. 39F1h, - = 3991h. 39F1h, 399Fh = PIE1. 39F1h, - = 3971h. 39F1h, 397Fh = -. 39F1h, - = 3951h. 39F1h, 395Fh = -. 39F1h, WDTU",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n= 3931h. 39F1h, 393Fh - = -. 39F1h, 391Fh = 3911h. 39F1h, - = -. 39F0h, - = -. 39F0h, 39DFh = 39D0h BORCON. 39F0h, OSCFRQ = 39B0h. 39F0h, 39BFh = -. 39F0h, - = 3990h. 39F0h, 399Fh = PIE0. 39F0h, - = 3970h. 39F0h, 397Fh = -. 39F0h, - = 3950h. 39F0h, 395Fh = -. 39F0h, WDTU = 3930h. 39F0h, 393Fh - = -. 39F0h, 391Fh = 3910h. 39F0h, - = -. 39EFh, - = PRLOCK. 39EFh, 39DFh =",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39CFh -. 39EFh, OSCFRQ = 39AFh. 39EFh, 39BFh = -. 39EFh, - = 398Fh. 39EFh, 399Fh = -. 39EFh, - = 396Fh. 39EFh, 397Fh = -. 39EFh, - = 394Fh. 39EFh, 395Fh = -. 39EFh, WDTU = 392Fh. 39EFh, 393Fh - = -. 39EFh, 391Fh = 390Fh. 39EFh, - = -. 39EEh, - = -. 39EEh, 39DFh = 39CEh -. 39EEh, OSCFRQ = 39AEh. 39EEh, 39BFh = -. 39EEh, - = 398Eh. 39EEh, 399Fh = -. 39EEh, - = 396Eh. 39EEh, 397Fh = -. 39EEh, -",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n= 394Eh. 39EEh, 395Fh = -. 39EEh, WDTU = 392Eh. 39EEh, 393Fh - = -. 39EEh, 391Fh = 390Eh. 39EEh, - = -. 39EDh, - = - 39CDh. 39EDh, 39DFh = -. 39EDh, OSCFRQ = 39ADh. 39EDh, 39BFh = -. 39EDh, - = 398Dh. 39EDh, 399Fh = -. 39EDh, - = 396Dh. 39EDh, 397Fh = -. 39EDh, - = 394Dh. 39EDh, 395Fh = -. 39EDh, WDTU = 392Dh. 39EDh, 393Fh - = -. 39EDh, 391Fh = 390Dh. 39EDh, - = -. 39ECh, - = -. 39ECh, 39DFh = 39CCh -. 39ECh,",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\nOSCFRQ = 39ACh. 39ECh, 39BFh = -. 39ECh, - = 398Ch. 39ECh, 399Fh = -. 39ECh, - = 396Ch. 39ECh, 397Fh = -. 39ECh, - = 394Ch. 39ECh, 395Fh = -. 39ECh, WDTU = 392Ch. 39ECh, 393Fh - = -. 39ECh, 391Fh = 390Ch. 39ECh, - = -. 39EBh, - = -. 39EBh, 39DFh = 39CBh -. 39EBh, OSCFRQ = 39ABh. 39EBh, 39BFh = -. 39EBh, - = 398Bh. 39EBh, 399Fh = -. 39EBh, - = 396Bh. 39EBh, 397Fh = -. 39EBh, - = 394Bh. 39EBh, 395Fh = -. 39EBh, WDTU = 392Bh.",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39EBh, 393Fh - = -. 39EBh, 391Fh = 390Bh. 39EBh, - = -. 39EAh, - = -. 39EAh, 39DFh = 39CAh -. 39EAh, OSCFRQ = 39AAh. 39EAh, 39BFh = -. 39EAh, - = 398Ah. 39EAh, 399Fh = -. 39EAh, - = 396Ah. 39EAh, 397Fh = -. 39EAh, - = 394Ah. 39EAh, 395Fh = -. 39EAh, WDTU = 392Ah. 39EAh, 393Fh - = -. 39EAh, 391Fh = 390Ah. 39EAh, - = -. 39E9h, - = -. 39E9h, 39DFh = 39C9h -. 39E9h, OSCFRQ = 39A9h. 39E9h, 39BFh =",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\nPIR9. 39E9h, - = 3989h. 39E9h, 399Fh = IPR9. 39E9h, - = 3969h. 39E9h, 397Fh = CRCCON1. 39E9h, - = 3949h. 39E9h, 395Fh = . 39E9h, WDTU = -. 39E9h, 393Fh - = 3929h -. 39E9h, 391Fh = 3909h. 39E9h, - = -. 39E8h, - = - 39C8h. 39E8h, 39DFh = -. 39E8h, OSCFRQ = 39A8h. 39E8h, 39BFh = PIR8. 39E8h, - = 3988h. 39E8h, 399Fh = IPR8. 39E8h, - = 3968h. 39E8h, 397Fh =",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\nCRCCON0. 39E8h, - = 3948h. 39E8h, 395Fh = -. 39E8h, WDTU = 3928h. 39E8h, 393Fh - = -. 39E8h, 391Fh = 3908h. 39E8h, - = -. 39E7h, - = -. 39E7h, 39DFh = 39C7h PMD7. 39E7h, OSCFRQ = 39A7h. 39E7h, 39BFh = PIR7. 39E7h, - = 3987h. 39E7h, 399Fh = IPR7. 39E7h, - = 3967h. 39E7h, 397Fh = CRCXORH. 39E7h, - = 3947h. 39E7h, 395Fh = -. 39E7h, WDTU = . 39E7h, 393Fh - = 3927h",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n-. 39E7h, 391Fh = 3907h. 39E7h, - = -. 39E6h, - = NVMCON2. 39E6h, 39DFh = 39C6h PMD6. 39E6h, OSCFRQ = 39A6h. 39E6h, 39BFh = PIR6. 39E6h, - = 3986h. 39E6h, 399Fh = IPR6. 39E6h, - = 3966h. 39E6h, 397Fh = CRCXORL. 39E6h, - = 3946h. 39E6h, 395Fh = -. 39E6h, WDTU = 3926h. 39E6h, 393Fh - = -. 39E6h, 391Fh = 3906h. 39E6h, - = -. 39E5h, - = NVMCON1. 39E5h, 39DFh =",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39C5h PMD5. 39E5h, OSCFRQ = 39A5h. 39E5h, 39BFh = PIR5. 39E5h, - = 3985h. 39E5h, 399Fh = IPR5. 39E5h, - = 3965h. 39E5h, 397Fh = CRCSHIFTH. 39E5h, - = 3945h. 39E5h, 395Fh = -. 39E5h, WDTU = . 39E5h, 393Fh - = 3925h -. 39E5h, 391Fh = 3905h. 39E5h, - = -. 39E4h, - = -. 39E4h, 39DFh = 39C4h PMD4. 39E4h, OSCFRQ = 39A4h. 39E4h, 39BFh = PIR4. 39E4h, - = 3984h. 39E4h,",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n399Fh = IPR4. 39E4h, - = 3964h. 39E4h, 397Fh = CRCSHIFTL. 39E4h, - = 3944h. 39E4h, 395Fh = -. 39E4h, WDTU = 3924h. 39E4h, 393Fh - = -. 39E4h, 391Fh = 3904h. 39E4h, - = -. 39E3h, - = NVMDAT. 39E3h, 39DFh = 39C3h PMD3. 39E3h, OSCFRQ = 39A3h. 39E3h, 39BFh = PIR3. 39E3h, - = 3983h. 39E3h, 399Fh = IPR3. 39E3h, - = 3963h. 39E3h, 397Fh = CRCACCH. 39E3h, - = 3943h.",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39E3h, 395Fh = -. 39E3h, WDTU = 3923h. 39E3h, 393Fh - = -. 39E3h, 391Fh = 3903h. 39E3h, - = -. 39E2h, - = -. 39E2h, 39DFh = 39C2h PMD2. 39E2h, OSCFRQ = 39A2h. 39E2h, 39BFh = PIR2. 39E2h, - = 3982h. 39E2h, 399Fh = IPR2. 39E2h, - = 3962h. 39E2h, 397Fh = CRCACCL. 39E2h, - = 3942h. 39E2h, 395Fh = -. 39E2h, WDTU = . 39E2h, 393Fh - = 3922h -. 39E2h, 391Fh = 3902h.",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n39E2h, - = -. 39E1h, - = -. 39E1h, 39DFh = 39C1h PMD1. 39E1h, OSCFRQ = 39A1h. 39E1h, 39BFh = PIR1. 39E1h, - = . 39E1h, 399Fh = IPR1. 39E1h, - = 3961h. 39E1h, 397Fh = CRCDATH. 39E1h, - = 3941h. 39E1h, 395Fh = -. 39E1h, WDTU = . 39E1h, 393Fh - = -. 39E1h, 391Fh = 3901h. 39E1h, - = -. , - = . , 39DFh = . , OSCFRQ = . , 39BFh = . , - = 3981h. , 399Fh = . , - = . , 397Fh = . , - = .",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\n, 395Fh = . , WDTU = 3921h. , 393Fh - = . , 391Fh = . , - = . 39E0h, - = NVMADRL. 39E0h, 39DFh = 39C0h PMD0. 39E0h, OSCFRQ = 39A0h. 39E0h, 39BFh = PIR0. 39E0h, - = 3980h. 39E0h, 399Fh = IPR0. 39E0h, - = 3960h. 39E0h, 397Fh = CRCDATL. 39E0h, - = 3940h. 39E0h, 395Fh = -. 39E0h, WDTU = 3920h. 39E0h, 393Fh - = -. 39E0h, 391Fh = 3900h. 39E0h, - = -\nLegend:\nUnimplemented data memory locations and registers, read as ' 0 '.",
    "TABLE 4-9: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 57\nNote 1: Unimplemented in LF devices.",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n38FEh, - = -. 38FEh, 38DFh = 38DEh -. 38FEh, - = 38BEh. 38FEh, 38BFh = -. 38FEh, - = 389Eh. 38FEh, 389Fh = IVTADH. 38FEh, IVTADU = 387Eh. 38FEh, 387Fh = -. 38FEh, - = 385Eh. 38FEh, 385Fh - = -. 38FEh, 383Fh - = 383Eh -. 38FEh, 381Fh = 381Eh. 38FEh, - = -. 38FDh, - = -. 38FDh, 38DFh = 38DDh -. 38FDh, - = 38BDh. 38FDh, 38BFh = -. 38FDh, - = 389Dh. 38FDh, 389Fh = IVTADL. 38FDh, IVTADU = 387Dh. 38FDh, 387Fh = -. 38FDh,",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n- = 385Dh. 38FDh, 385Fh - = -. 38FDh, 383Fh - = 383Dh -. 38FDh, 381Fh = 381Dh. 38FDh, - = -. 38FCh, - = -. 38FCh, 38DFh = 38DCh -. 38FCh, - = 38BCh. 38FCh, 38BFh = -. 38FCh, - = 389Ch. 38FCh, 389Fh = -. 38FCh, IVTADU = 387Ch. 38FCh, 387Fh = -. 38FCh, - = 385Ch. 38FCh, 385Fh - = -. 38FCh, 383Fh - = 383Ch -. 38FCh, 381Fh = 381Ch. 38FCh, - = -. 38FBh, - = -. 38FBh, 38DFh = 38DBh -. 38FBh, - = 38BBh. 38FBh, 38BFh = -.",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n38FBh, - = 389Bh. 38FBh, 389Fh = -. 38FBh, IVTADU = 387Bh. 38FBh, 387Fh = -. 38FBh, - = 385Bh. 38FBh, 385Fh - = -. 38FBh, 383Fh - = 383Bh -. 38FBh, 381Fh = 381Bh. 38FBh, - = -. 38FAh, - = -. 38FAh, 38DFh = 38DAh. 38FAh, - = - 38BAh. 38FAh, 38BFh = -. 38FAh, - = 389Ah. 38FAh, 389Fh = -. 38FAh, IVTADU = 387Ah. 38FAh, 387Fh = -. 38FAh, - = 385Ah. 38FAh, 385Fh - = -. 38FAh, 383Fh - = 383Ah -. 38FAh, 381Fh = 381Ah. 38FAh,",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n- = -. 38F9h, - = -. 38F9h, 38DFh = 38D9h -. 38F9h, - = 38B9h. 38F9h, 38BFh = -. 38F9h, - = 3899h. 38F9h, 389Fh = -. 38F9h, IVTADU = 3879h. 38F9h, 387Fh = -. 38F9h, - = 3859h. 38F9h, 385Fh - = -. 38F9h, 383Fh - = 3839h -. 38F9h, 381Fh = 3819h. 38F9h, - = -. 38F8h, - = -. 38F8h, 38DFh = 38D8h. 38F8h, - = -. 38F8h, 38BFh = 38B8h -. 38F8h, - = 3898h. 38F8h, 389Fh =",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n-. 38F8h, IVTADU = 3878h. 38F8h, 387Fh = -. 38F8h, - = 3858h. 38F8h, 385Fh - = -. 38F8h, 383Fh - = 3838h -. 38F8h, 381Fh = 3818h. 38F8h, - = -. 38F7h, - = -. 38F7h, 38DFh = 38D7h -. 38F7h, - = 38B7h. 38F7h, 38BFh = -. 38F7h, - = 3897h. 38F7h, 389Fh = -. 38F7h, IVTADU = 3877h. 38F7h, 387Fh = -. 38F7h, - = 3857h. 38F7h, 385Fh - = -. 38F7h, 383Fh - = 3837h -. 38F7h,",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n381Fh = 3817h. 38F7h, - = -. 38F6h, - = -. 38F6h, 38DFh = 38D6h. 38F6h, - = -. 38F6h, 38BFh = 38B6h -. 38F6h, - = 3896h. 38F6h, 389Fh = -. 38F6h, IVTADU = 3876h. 38F6h, 387Fh = -. 38F6h, - = 3856h. 38F6h, 385Fh - = -. 38F6h, 383Fh - = 3836h -. 38F6h, 381Fh = 3816h. 38F6h, - = -. 38F5h, - = -. 38F5h, 38DFh = 38D5h. 38F5h, - = -. 38F5h, 38BFh = 38B5h -. 38F5h, - =",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n3895h. 38F5h, 389Fh = -. 38F5h, IVTADU = 3875h. 38F5h, 387Fh = -. 38F5h, - = 3855h. 38F5h, 385Fh - = -. 38F5h, 383Fh - = 3835h -. 38F5h, 381Fh = 3815h. 38F5h, - = -. 38F4h, - = -. 38F4h, 38DFh = 38D4h -. 38F4h, - = 38B4h 38B3h. 38F4h, 38BFh = -. 38F4h, - = 3894h. 38F4h, 389Fh = -. 38F4h, IVTADU = 3874h. 38F4h, 387Fh = -. 38F4h, - = 3854h. 38F4h, 385Fh - = -.",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n38F4h, 383Fh - = 3834h -. 38F4h, 381Fh = 3814h. 38F4h, - = -. 38F3h, - = -. 38F3h, 38DFh = 38D3h. 38F3h, - = -. 38F3h, 38BFh = -. 38F3h, - = 3893h. 38F3h, 389Fh = -. 38F3h, IVTADU = 3873h. 38F3h, 387Fh = -. 38F3h, - = 3853h. 38F3h, 385Fh - = -. 38F3h, 383Fh - = 3833h -. 38F3h, 381Fh = 3813h. 38F3h, - = -. 38F2h, - = -. 38F2h, 38DFh = 38D2h. 38F2h, - = -. 38F2h,",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n38BFh = 38B2h -. 38F2h, - = 3892h. 38F2h, 389Fh = -. 38F2h, IVTADU = 3872h. 38F2h, 387Fh = -. 38F2h, - = 3852h. 38F2h, 385Fh - = -. 38F2h, 383Fh - = 3832h -. 38F2h, 381Fh = 3812h. 38F2h, - = -. 38F1h, - = -. 38F1h, 38DFh = 38D1h. 38F1h, - = -. 38F1h, 38BFh = 38B1h -. 38F1h, - = 3891h. 38F1h, 389Fh = -. 38F1h, IVTADU = 3871h. 38F1h, 387Fh = -. 38F1h, - = 3851h.",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n38F1h, 385Fh - = -. 38F1h, 383Fh - = 3831h -. 38F1h, 381Fh = 3811h. 38F1h, - = -. 38F0h, - = -. 38F0h, 38DFh = 38D0h. 38F0h, - = -. 38F0h, 38BFh = 38B0h -. 38F0h, - = 3890h. 38F0h, 389Fh = PRODH_SHAD. 38F0h, IVTADU = 3870h. 38F0h, 387Fh = -. 38F0h, - = 3850h. 38F0h, 385Fh - = -. 38F0h, 383Fh - = 3830h -. 38F0h, 381Fh = 3810h. 38F0h, - = -. 38EFh, - = -. 38EFh, 38DFh = 38CFh.",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n38EFh, - = -. 38EFh, 38BFh = 38AFh -. 38EFh, - = 388Fh. 38EFh, 389Fh = PRODL_SHAD. 38EFh, IVTADU = 386Fh. 38EFh, 387Fh = -. 38EFh, - = 384Fh. 38EFh, 385Fh - = -. 38EFh, 383Fh - = 382Fh -. 38EFh, 381Fh = 380Fh. 38EFh, - = -. 38EEh, - = -. 38EEh, 38DFh = 38CEh. 38EEh, - = -. 38EEh, 38BFh = 38AEh -. 38EEh, - = 388Eh. 38EEh, 389Fh = FSR2H_SHAD. 38EEh, IVTADU = 386Eh. 38EEh, 387Fh = -. 38EEh, - = 384Eh.",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n38EEh, 385Fh - = -. 38EEh, 383Fh - = 382Eh -. 38EEh, 381Fh = 380Eh. 38EEh, - = -. 38EDh, - = -. 38EDh, 38DFh = 38CDh. 38EDh, - = -. 38EDh, 38BFh = 38ADh -. 38EDh, - = 388Dh. 38EDh, 389Fh = FSR2L_SHAD. 38EDh, IVTADU = 386Dh. 38EDh, 387Fh = -. 38EDh, - = . 38EDh, 385Fh - = 384Dh -. 38EDh, 383Fh - = 382Dh -. 38EDh, 381Fh = 380Dh. 38EDh, - = -. 38ECh, - = -. 38ECh, 38DFh = 38CCh. 38ECh, - = -. 38ECh, 38BFh = 38ACh -. 38ECh, -",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n= 388Ch. 38ECh, 389Fh = FSR1H_SHAD. 38ECh, IVTADU = 386Ch. 38ECh, 387Fh = -. 38ECh, - = . 38ECh, 385Fh - = 384Ch -. 38ECh, 383Fh - = 382Ch -. 38ECh, 381Fh = 380Ch. 38ECh, - = -. 38EBh, - = -. 38EBh, 38DFh = 38CBh. 38EBh, - = -. 38EBh, 38BFh = 38ABh -. 38EBh, - = 388Bh. 38EBh, 389Fh = FSR1L_SHAD. 38EBh, IVTADU = 386Bh. 38EBh, 387Fh = -. 38EBh, - = 384Bh. 38EBh, 385Fh - = -. 38EBh, 383Fh - = 382Bh -. 38EBh, 381Fh = 380Bh.",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n38EBh, - = -. 38EAh, - = -. 38EAh, 38DFh = 38CAh. 38EAh, - = -. 38EAh, 38BFh = 38AAh -. 38EAh, - = 388Ah. 38EAh, 389Fh = FSR0H_SHAD. 38EAh, IVTADU = 386Ah. 38EAh, 387Fh = . 38EAh, - = -. 38EAh, 385Fh - = 384Ah -. 38EAh, 383Fh - = 382Ah -. 38EAh, 381Fh = 380Ah. 38EAh, - = -. 38E9h, - = -. 38E9h, 38DFh = 38C9h. 38E9h, - = -. 38E9h, 38BFh = 38A9h -. 38E9h, - = 3889h. 38E9h, 389Fh = FSR0L_SHAD.",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n38E9h, IVTADU = 3869h. 38E9h, 387Fh = -. 38E9h, - = 3849h. 38E9h, 385Fh - = -. 38E9h, 383Fh - = 3829h -. 38E9h, 381Fh = 3809h. 38E9h, - = -. 38E8h, - = -. 38E8h, 38DFh = 38C8h -. 38E8h, - = 38A8h. 38E8h, 38BFh = -. 38E8h, - = 3888h. 38E8h, 389Fh = PCLATU_SHAD. 38E8h, IVTADU = 3868h. 38E8h, 387Fh = -. 38E8h, - = . 38E8h, 385Fh - = 3848h -. 38E8h, 383Fh - = 3828h -.",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n38E8h, 381Fh = 3808h. 38E8h, - = -. 38E7h, - = -. 38E7h, 38DFh = 38C7h. 38E7h, - = -. 38E7h, 38BFh = 38A7h -. 38E7h, - = 3887h. 38E7h, 389Fh = PCLATH_SHAD. 38E7h, IVTADU = 3867h. 38E7h, 387Fh = -. 38E7h, - = 3847h. 38E7h, 385Fh - = -. 38E7h, 383Fh - = 3827h -. 38E7h, 381Fh = 3807h. 38E7h, - = -. 38E6h, - = -. 38E6h, 38DFh = 38C6h. 38E6h, - = -. 38E6h, 38BFh = 38A6h",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n-. 38E6h, - = 3886h. 38E6h, 389Fh = BSR_SHAD. 38E6h, IVTADU = 3866h. 38E6h, 387Fh = -. 38E6h, - = . 38E6h, 385Fh - = 3846h -. 38E6h, 383Fh - = 3826h -. 38E6h, 381Fh = 3806h. 38E6h, - = -. 38E5h, - = -. 38E5h, 38DFh = 38C5h. 38E5h, - = -. 38E5h, 38BFh = 38A5h -. 38E5h, - = 3885h. 38E5h, 389Fh = WREG_SHAD. 38E5h, IVTADU = 3865h. 38E5h, 387Fh = -. 38E5h, - = . 38E5h, 385Fh -",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n= 3845h -. 38E5h, 383Fh - = 3825h -. 38E5h, 381Fh = 3805h. 38E5h, - = -. 38E4h, - = -. 38E4h, 38DFh = 38C4h. 38E4h, - = -. 38E4h, 38BFh = 38A4h -. 38E4h, - = 3884h. 38E4h, 389Fh = STATUS_SHAD. 38E4h, IVTADU = 3864h. 38E4h, 387Fh = -. 38E4h, - = 3844h. 38E4h, 385Fh - = -. 38E4h, 383Fh - = 3824h -. 38E4h, 381Fh = 3804h. 38E4h, - = -. 38E3h, - = -. 38E3h, 38DFh = 38C3h.",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n38E3h, - = -. 38E3h, 38BFh = 38A3h. 38E3h, - = -. 38E3h, 389Fh = 3883h SHADCON. 38E3h, IVTADU = 3863h. 38E3h, 387Fh = -. 38E3h, - = . 38E3h, 385Fh - = 3843h -. 38E3h, 383Fh - = 3823h -. 38E3h, 381Fh = 3803h. 38E3h, - = -. 38E2h, - = -. 38E2h, 38DFh = 38C2h. 38E2h, - = -. 38E2h, 38BFh = 38A2h. 38E2h, - = -. 38E2h, 389Fh = 3882h. 38E2h, IVTADU = BSR_CSHAD 3862h. 38E2h,",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n387Fh = -. 38E2h, - = . 38E2h, 385Fh - = 3842h -. 38E2h, 383Fh - = 3822h -. 38E2h, 381Fh = 3802h. 38E2h, - = -. 38E1h, - = -. 38E1h, 38DFh = 38C1h. 38E1h, - = -. 38E1h, 38BFh = 38A1h -. 38E1h, - = 3881h. 38E1h, 389Fh = WREG_CSHAD. 38E1h, IVTADU = 3861h. 38E1h, 387Fh = -. 38E1h, - = 3841h. 38E1h, 385Fh - = -. 38E1h, 383Fh - = 3821h -. 38E1h, 381Fh = 3801h. 38E1h, - = -. , -",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\n= -. , 38DFh = . , - = . , 38BFh = . , - = . , 389Fh = 3880h STATUS_CSHAD. , IVTADU = 3860h. , 387Fh = . , - = . , 385Fh - = . , 383Fh - = -. , 381Fh = . , - = . 38E0h, - = . 38E0h, 38DFh = 38C0h. 38E0h, - = -. 38E0h, 38BFh = 38A0h. 38E0h, - = -. 38E0h, 389Fh = . 38E0h, IVTADU = . 38E0h, 387Fh = -. 38E0h, - = 3840h. 38E0h, 385Fh - = -. 38E0h, 383Fh - = 3820h. 38E0h, 381Fh = 3800h. 38E0h, - = -",
    "TABLE 4-10: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 56\nLegend: Unimplemented data memory locations and registers, read as ' 0 '.",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n37FEh, CANCON_RO0 = CANSTAT_RO0. 37FEh, 37DFh = 37DEh. 37FEh, CANCON_RO2 37BFh = CANSTAT_RO2 37BEh. 37FEh,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXM1EIDH. 37FEh, RXM1EIDL = 379Eh. 37FEh, 379Fh = CANSTAT_RO4. 37FEh, CANCON_RO4 = 377Eh. 37FEh, 377Fh = CANSTAT_RO6. 37FEh, CANCON_RO6 = 375Eh. 37FEh, 375Fh CANCON_RO8 = CANSTAT_RO8. 37FEh, 373Fh = 373Eh. 37FEh, TXBIE = BIE0. 37FEh, 371Fh = 371Eh. 37FEh, RXF11EIDL = RXF11EIDH. 37FDh, CANCON_RO0 = RXB1D7. 37FDh, 37DFh = 37DDh. 37FDh, CANCON_RO2 37BFh = TXB1D7 37BDh. 37FDh,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXM1SIDL. 37FDh, RXM1EIDL = 379Dh. 37FDh, 379Fh = B5D7. 37FDh, CANCON_RO4 = 377Dh. 37FDh, 377Fh = B3D7. 37FDh, CANCON_RO6 = 375Dh. 37FDh, 375Fh CANCON_RO8 = B1D7. 37FDh, 373Fh = 373Dh. 37FDh, TXBIE = BSEL0. 37FDh, 371Fh = 371Dh. 37FDh, RXF11EIDL = RXF11SIDL. 37FCh, CANCON_RO0 = RXB1D6. 37FCh, 37DFh = 37DCh. 37FCh, CANCON_RO2 37BFh = TXB1D6 37BCh. 37FCh,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXM1SIDH. 37FCh, RXM1EIDL = 379Ch. 37FCh, 379Fh = B5D6. 37FCh, CANCON_RO4 = 377Ch. 37FCh, 377Fh = B3D6. 37FCh, CANCON_RO6 = 375Ch. 37FCh, 375Fh CANCON_RO8 = B1D6. 37FCh, 373Fh = 373Ch. 37FCh, TXBIE = MSEL3. 37FCh, 371Fh = 371Ch. 37FCh, RXF11EIDL = RXF11SIDH. 37FBh, CANCON_RO0 = RXB1D5. 37FBh, 37DFh = 37DBh. 37FBh, CANCON_RO2 37BFh = TXB1D5 37BBh. 37FBh,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXM0EIDL. 37FBh, RXM1EIDL = 379Bh. 37FBh, 379Fh = B5D5. 37FBh, CANCON_RO4 = 377Bh. 37FBh, 377Fh = B3D5. 37FBh, CANCON_RO6 = 375Bh. 37FBh, 375Fh CANCON_RO8 = B1D5. 37FBh, 373Fh = 373Bh. 37FBh, TXBIE = MSEL2. 37FBh, 371Fh = 371Bh. 37FBh, RXF11EIDL = RXF10EIDL. 37FAh, CANCON_RO0 = RXB1D4. 37FAh, 37DFh = 37DAh. 37FAh, CANCON_RO2 37BFh = TXB1D4 37BAh. 37FAh,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXM0EIDH. 37FAh, RXM1EIDL = 379Ah. 37FAh, 379Fh = B5D4. 37FAh, CANCON_RO4 = 377Ah. 37FAh, 377Fh = B3D4. 37FAh, CANCON_RO6 = 375Ah. 37FAh, 375Fh CANCON_RO8 = B1D4. 37FAh, 373Fh = 373Ah. 37FAh, TXBIE = MSEL1. 37FAh, 371Fh = 371Ah. 37FAh, RXF11EIDL = RXF10EIDH. 37F9h, CANCON_RO0 = RXB1D3. 37F9h, 37DFh = 37D9h. 37F9h, CANCON_RO2 37BFh = TXB1D3 37B9h. 37F9h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXM0SIDL. 37F9h, RXM1EIDL = 3799h. 37F9h, 379Fh = B5D3. 37F9h, CANCON_RO4 = 3779h. 37F9h, 377Fh = B3D3. 37F9h, CANCON_RO6 = 3759h. 37F9h, 375Fh CANCON_RO8 = B1D3. 37F9h, 373Fh = 3739h. 37F9h, TXBIE = MSEL0. 37F9h, 371Fh = 3719h. 37F9h, RXF11EIDL = RXF10SIDL. 37F8h, CANCON_RO0 = RXB1D2. 37F8h, 37DFh = 37D8h. 37F8h, CANCON_RO2 37BFh = TXB1D2 37B8h. 37F8h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXM0SIDH. 37F8h, RXM1EIDL = 3798h. 37F8h, 379Fh = B5D2. 37F8h, CANCON_RO4 = 3778h. 37F8h, 377Fh = B3D2. 37F8h, CANCON_RO6 = 3758h. 37F8h, 375Fh CANCON_RO8 = B1D2. 37F8h, 373Fh = 3738h. 37F8h, TXBIE = RXFBCON7. 37F8h, 371Fh = 3718h. 37F8h, RXF11EIDL = RXF10SIDH. 37F7h, CANCON_RO0 = RXB1D1. 37F7h, 37DFh = 37D7h TXB1D1. 37F7h, CANCON_RO2 37BFh = 37B7h. 37F7h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF5EIDL. 37F7h, RXM1EIDL = 3797h. 37F7h, 379Fh = B5D1. 37F7h, CANCON_RO4 = 3777h. 37F7h, 377Fh = B3D1. 37F7h, CANCON_RO6 = 3757h. 37F7h, 375Fh CANCON_RO8 = B1D1. 37F7h, 373Fh = 3737h. 37F7h, TXBIE = RXFBCON6. 37F7h, 371Fh = 3717h. 37F7h, RXF11EIDL = RXF9EIDL. 37F6h, CANCON_RO0 = RXB1D0. 37F6h, 37DFh = 37D6h. 37F6h, CANCON_RO2 37BFh = TXB1D0 37B6h. 37F6h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF5EIDH. 37F6h, RXM1EIDL = 3796h. 37F6h, 379Fh = B5D0. 37F6h, CANCON_RO4 = 3776h. 37F6h, 377Fh = B3D0. 37F6h, CANCON_RO6 = 3756h. 37F6h, 375Fh CANCON_RO8 = B1D0. 37F6h, 373Fh = 3736h. 37F6h, TXBIE = RXFBCON5. 37F6h, 371Fh = 3716h. 37F6h, RXF11EIDL = RXF9EIDH. 37F5h, CANCON_RO0 = RXB1DLC. 37F5h, 37DFh = 37D5h. 37F5h, CANCON_RO2 37BFh = TXB1DLC 37B5h. 37F5h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF5SIDL. 37F5h, RXM1EIDL = 3795h. 37F5h, 379Fh = B5DLC. 37F5h, CANCON_RO4 = 3775h. 37F5h, 377Fh = B3DLC. 37F5h, CANCON_RO6 = 3755h. 37F5h, 375Fh CANCON_RO8 = B1DLC. 37F5h, 373Fh = 3735h. 37F5h, TXBIE = RXFBCON4. 37F5h, 371Fh = 3715h. 37F5h, RXF11EIDL = RXF9SIDL. 37F4h, CANCON_RO0 = RXB1EIDL. 37F4h, 37DFh = 37D4h. 37F4h, CANCON_RO2 37BFh = TXB1EIDL 37B4h. 37F4h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF5SIDH. 37F4h, RXM1EIDL = 3794h. 37F4h, 379Fh = B5EIDL. 37F4h, CANCON_RO4 = 3774h. 37F4h, 377Fh = B3EIDL. 37F4h, CANCON_RO6 = 3754h. 37F4h, 375Fh CANCON_RO8 = B1EIDL. 37F4h, 373Fh = 3734h. 37F4h, TXBIE = RXFBCON3. 37F4h, 371Fh = 3714h. 37F4h, RXF11EIDL = RXF9SIDH. 37F3h, CANCON_RO0 = RXB1EIDH. 37F3h, 37DFh = 37D3h. 37F3h, CANCON_RO2 37BFh = TXB1EIDH 37B3h. 37F3h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF4EIDL. 37F3h, RXM1EIDL = 3793h. 37F3h, 379Fh = B5EIDH. 37F3h, CANCON_RO4 = 3773h. 37F3h, 377Fh = B3EIDH. 37F3h, CANCON_RO6 = 3753h. 37F3h, 375Fh CANCON_RO8 = B1EIDH. 37F3h, 373Fh = 3733h. 37F3h, TXBIE = RXFBCON2. 37F3h, 371Fh = 3713h. 37F3h, RXF11EIDL = RXF8EIDL. 37F2h, CANCON_RO0 = RXB1SIDL. 37F2h, 37DFh = 37D2h. 37F2h, CANCON_RO2 37BFh = TXB1SIDL 37B2h. 37F2h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF4EIDH. 37F2h, RXM1EIDL = 3792h. 37F2h, 379Fh = B5SIDL. 37F2h, CANCON_RO4 = 3772h. 37F2h, 377Fh = B3SIDL. 37F2h, CANCON_RO6 = 3752h. 37F2h, 375Fh CANCON_RO8 = B1SIDL. 37F2h, 373Fh = 3732h. 37F2h, TXBIE = RXFBCON1. 37F2h, 371Fh = 3712h. 37F2h, RXF11EIDL = RXF8EIDH. 37F1h, CANCON_RO0 = RXB1SIDH. 37F1h, 37DFh = 37D1h. 37F1h, CANCON_RO2 37BFh = TXB1SIDH 37B1h. 37F1h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF4SIDL. 37F1h, RXM1EIDL = 3791h. 37F1h, 379Fh = B5SIDH. 37F1h, CANCON_RO4 = 3771h. 37F1h, 377Fh = B3SIDH. 37F1h, CANCON_RO6 = 3751h. 37F1h, 375Fh CANCON_RO8 = B1SIDH. 37F1h, 373Fh = 3731h. 37F1h, TXBIE = RXFBCON0. 37F1h, 371Fh = 3711h. 37F1h, RXF11EIDL = RXF8SIDL. 37F0h, CANCON_RO0 = RXB1CON. 37F0h, 37DFh = 37D0h TXB1CON. 37F0h, CANCON_RO2 37BFh = 37B0h. 37F0h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF4SIDH. 37F0h, RXM1EIDL = 3790h. 37F0h, 379Fh = B5CON. 37F0h, CANCON_RO4 = 3770h. 37F0h, 377Fh = B3CON. 37F0h, CANCON_RO6 = 3750h. 37F0h, 375Fh CANCON_RO8 = B1CON. 37F0h, 373Fh = 3730h. 37F0h, TXBIE = SDFLC. 37F0h, 371Fh = 3710h. 37F0h, RXF11EIDL = RXF8SIDH. 37EFh, CANCON_RO0 = CANCON_RO1. 37EFh, 37DFh = 37CFh. 37EFh, CANCON_RO2 37BFh = CANCON_RO3 37AFh. 37EFh,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF3EIDL. 37EFh, RXM1EIDL = 378Fh. 37EFh, 379Fh = CANCON_RO5. 37EFh, CANCON_RO4 = 376Fh. 37EFh, 377Fh = CANCON_RO7. 37EFh, CANCON_RO6 = 374Fh. 37EFh, 375Fh CANCON_RO8 = CANCON_RO9. 37EFh, 373Fh = 372Fh. 37EFh, TXBIE = RXF15EIDL. 37EFh, 371Fh = 370Fh. 37EFh, RXF11EIDL = RXF7EIDL. 37EEh, CANCON_RO0 = CANSTAT_RO1. 37EEh, 37DFh = 37CEh. 37EEh, CANCON_RO2 37BFh = CANSTAT_RO3 37AEh. 37EEh,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF3EIDH. 37EEh, RXM1EIDL = 378Eh. 37EEh, 379Fh = CANSTAT_RO5. 37EEh, CANCON_RO4 = 376Eh. 37EEh, 377Fh = CANSTAT_RO7. 37EEh, CANCON_RO6 = 374Eh. 37EEh, 375Fh CANCON_RO8 = CANSTAT_RO9. 37EEh, 373Fh = 372Eh. 37EEh, TXBIE = RXF15EIDH. 37EEh, 371Fh = 370Eh. 37EEh, RXF11EIDL = RXF7EIDH. 37EDh, CANCON_RO0 = TXB0D7. 37EDh, 37DFh = 37CDh. 37EDh, CANCON_RO2 37BFh = TXB2D7 37ADh. 37EDh,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF3SIDL. 37EDh, RXM1EIDL = 378Dh. 37EDh, 379Fh = B4D7. 37EDh, CANCON_RO4 = 376Dh. 37EDh, 377Fh = B2D7. 37EDh, CANCON_RO6 = 374Dh. 37EDh, 375Fh CANCON_RO8 = B0D7. 37EDh, 373Fh = 372Dh. 37EDh, TXBIE = RXF15SIDL. 37EDh, 371Fh = 370Dh. 37EDh, RXF11EIDL = RXF7SIDL. 37ECh, CANCON_RO0 = TXB0D6. 37ECh, 37DFh = 37CCh. 37ECh, CANCON_RO2 37BFh = TXB2D6 37ACh. 37ECh,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF3SIDH. 37ECh, RXM1EIDL = 378Ch. 37ECh, 379Fh = B4D6. 37ECh, CANCON_RO4 = 376Ch. 37ECh, 377Fh = B2D6. 37ECh, CANCON_RO6 = 374Ch. 37ECh, 375Fh CANCON_RO8 = B0D6. 37ECh, 373Fh = 372Ch. 37ECh, TXBIE = RXF15SIDH. 37ECh, 371Fh = 370Ch. 37ECh, RXF11EIDL = RXF7SIDH. 37EBh, CANCON_RO0 = TXB0D5. 37EBh, 37DFh = 37CBh. 37EBh, CANCON_RO2 37BFh = TXB2D5 37ABh. 37EBh,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF2EIDL. 37EBh, RXM1EIDL = 378Bh. 37EBh, 379Fh = B4D5. 37EBh, CANCON_RO4 = 376Bh. 37EBh, 377Fh = B2D5. 37EBh, CANCON_RO6 = 374Bh. 37EBh, 375Fh CANCON_RO8 = B0D5. 37EBh, 373Fh = 372Bh. 37EBh, TXBIE = RXF14EIDL. 37EBh, 371Fh = 370Bh. 37EBh, RXF11EIDL = RXF6EIDL. 37EAh, CANCON_RO0 = . 37EAh, 37DFh = 37CAh. 37EAh, CANCON_RO2 37BFh = TXB2D4 37AAh. 37EAh,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF2EIDH. 37EAh, RXM1EIDL = 378Ah. 37EAh, 379Fh = B4D4. 37EAh, CANCON_RO4 = 376Ah. 37EAh, 377Fh = B2D4. 37EAh, CANCON_RO6 = 374Ah. 37EAh, 375Fh CANCON_RO8 = B0D4. 37EAh, 373Fh = 372Ah. 37EAh, TXBIE = RXF14EIDH. 37EAh, 371Fh = 370Ah. 37EAh, RXF11EIDL = RXF6EIDH. 37E9h, CANCON_RO0 = TXB0D4 TXB0D3. 37E9h, 37DFh = 37C9h. 37E9h, CANCON_RO2 37BFh = TXB2D3 37A9h. 37E9h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF2SIDL. 37E9h, RXM1EIDL = 3789h. 37E9h, 379Fh = B4D3. 37E9h, CANCON_RO4 = 3769h. 37E9h, 377Fh = B2D3. 37E9h, CANCON_RO6 = 3749h. 37E9h, 375Fh CANCON_RO8 = B0D3. 37E9h, 373Fh = 3729h. 37E9h, TXBIE = RXF14SIDL. 37E9h, 371Fh = 3709h. 37E9h, RXF11EIDL = RXF6SIDL. 37E8h, CANCON_RO0 = TXB0D2. 37E8h, 37DFh = 37C8h. 37E8h, CANCON_RO2 37BFh = TXB2D2 37A8h. 37E8h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF2SIDH. 37E8h, RXM1EIDL = 3788h. 37E8h, 379Fh = B4D2. 37E8h, CANCON_RO4 = 3768h. 37E8h, 377Fh = B2D2. 37E8h, CANCON_RO6 = 3748h. 37E8h, 375Fh CANCON_RO8 = B0D2. 37E8h, 373Fh = 3728h. 37E8h, TXBIE = RXF14SIDH. 37E8h, 371Fh = 3708h. 37E8h, RXF11EIDL = RXF6SIDH. 37E7h, CANCON_RO0 = TXB0D1. 37E7h, 37DFh = 37C7h. 37E7h, CANCON_RO2 37BFh = TXB2D1 37A7h. 37E7h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF1EIDL. 37E7h, RXM1EIDL = 3787h. 37E7h, 379Fh = B4D1. 37E7h, CANCON_RO4 = 3767h. 37E7h, 377Fh = B2D1. 37E7h, CANCON_RO6 = 3747h. 37E7h, 375Fh CANCON_RO8 = B0D1. 37E7h, 373Fh = 3727h. 37E7h, TXBIE = RXF13EIDL. 37E7h, 371Fh = 3707h. 37E7h, RXF11EIDL = RXFCON1. 37E6h, CANCON_RO0 = TXB0D0. 37E6h, 37DFh = 37C6h TXB2D0. 37E6h, CANCON_RO2 37BFh = 37A6h. 37E6h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF1EIDH. 37E6h, RXM1EIDL = 3786h. 37E6h, 379Fh = B4D0. 37E6h, CANCON_RO4 = 3766h. 37E6h, 377Fh = B2D0. 37E6h, CANCON_RO6 = 3746h. 37E6h, 375Fh CANCON_RO8 = B0D0. 37E6h, 373Fh = 3726h. 37E6h, TXBIE = RXF13EIDH. 37E6h, 371Fh = 3706h. 37E6h, RXF11EIDL = RXFCON0. 37E5h, CANCON_RO0 = TXB0DLC. 37E5h, 37DFh = 37C5h TXB2DLC. 37E5h, CANCON_RO2 37BFh = 37A5h. 37E5h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF1SIDL. 37E5h, RXM1EIDL = 3785h. 37E5h, 379Fh = B4DLC. 37E5h, CANCON_RO4 = 3765h. 37E5h, 377Fh = B2DLC. 37E5h, CANCON_RO6 = 3745h. 37E5h, 375Fh CANCON_RO8 = B0DLC. 37E5h, 373Fh = 3725h. 37E5h, TXBIE = RXF13SIDL. 37E5h, 371Fh = 3705h. 37E5h, RXF11EIDL = BRGCON3. 37E4h, CANCON_RO0 = TXB0EIDL TXB0EIDH. 37E4h, 37DFh = 37C4h TXB2EIDL 37C3h. 37E4h, CANCON_RO2 37BFh = 37A4h TXB2EIDH",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n37A3h. 37E4h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF1SIDH RXF0EIDL. 37E4h, RXM1EIDL = 3784h. 37E4h, 379Fh = B4EIDL. 37E4h, CANCON_RO4 = 3764h. 37E4h, 377Fh = B2EIDL 3763h. 37E4h, CANCON_RO6 = 3744h B2EIDH. 37E4h, 375Fh CANCON_RO8 = B0EIDL 3743h B0EIDH. 37E4h, 373Fh = 3724h 3723h. 37E4h, TXBIE = RXF13SIDH RXF12EIDL. 37E4h, 371Fh = 3704h 3703h. 37E4h, RXF11EIDL = BRGCON2 BRGCON1. 37E3h 37E2h, CANCON_RO0 = TXB0SIDL. 37E3h 37E2h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n37DFh = 37C2h. 37E3h 37E2h, CANCON_RO2 37BFh = 37A2h. 37E3h 37E2h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF0EIDH. 37E3h 37E2h, RXM1EIDL = 3782h. 37E3h 37E2h, 379Fh = B4SIDL. 37E3h 37E2h, CANCON_RO4 = . 37E3h 37E2h, 377Fh = B2SIDL. 37E3h 37E2h, CANCON_RO6 = 3742h. 37E3h 37E2h, 375Fh CANCON_RO8 = B0SIDL. 37E3h 37E2h, 373Fh = 3722h. 37E3h 37E2h, TXBIE = RXF12EIDH. 37E3h 37E2h, 371Fh = 3702h. 37E3h 37E2h, RXF11EIDL = TXERRCNT. 37E1h, CANCON_RO0 = TXB0SIDH. 37E1h, 37DFh =",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n37C1h. 37E1h, CANCON_RO2 37BFh = TXB2SIDL 37A1h. 37E1h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF0SIDL. 37E1h, RXM1EIDL = 3783h. 37E1h, 379Fh = B4EIDH. 37E1h, CANCON_RO4 = 3762h. 37E1h, 377Fh = . 37E1h, CANCON_RO6 = 3741h. 37E1h, 375Fh CANCON_RO8 = B0SIDH. 37E1h, 373Fh = 3721h. 37E1h, TXBIE = . 37E1h, 371Fh = 3701h. 37E1h, RXF11EIDL = RXERRCNT. 37E0h, CANCON_RO0 = TXB0CON. 37E0h, 37DFh = 37C0h. 37E0h, CANCON_RO2 37BFh = TXB2SIDH 37A0h. 37E0h,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= RXF0SIDH. 37E0h, RXM1EIDL = 3780h. 37E0h, 379Fh = 3781h B4CON. 37E0h, CANCON_RO4 = B4SIDH. 37E0h, 377Fh = 3761h B2CON. 37E0h, CANCON_RO6 = B2SIDH 3740h. 37E0h, 375Fh CANCON_RO8 = B0CON. 37E0h, 373Fh = 3720h. 37E0h, TXBIE = RXF12SIDL. 37E0h, 371Fh = 3700h. 37E0h, RXF11EIDL = CIOCON. , CANCON_RO0 = . , 37DFh = . , CANCON_RO2 37BFh = TXB2CON. ,",
    "TABLE 4-11: SPECIAL FUNCTION REGISTER MAP FOR PIC18(L)F25/26K83 DEVICES BANK 55\n= . , RXM1EIDL = . , 379Fh = . , CANCON_RO4 = 3760h. , 377Fh = . , CANCON_RO6 = . , 375Fh CANCON_RO8 = . , 373Fh = . , TXBIE = RXF12SIDH. , 371Fh = . , RXF11EIDL = \nLegend: Unimplemented data memory locations and registers, read as ' 0 '.",
    "4.5.5 STATUS REGISTER\nThe STATUS register, shown in Register 4-2, contains the arithmetic status of the ALU. As with any other SFR, it can be the operand for any instruction.\nIf the STATUS  register  is  the  destination for an instruction that affects the Z, DC, C, OV or N bits, the results  of  the  instruction  are  not  written;  instead,  the STATUS register is updated according to the instruction performed.  Therefore,  the  result  of an instruction with the STATUS register as its destination may be different than intended. As an example, CLRF STATUS will  set  the  Z  bit  and  leave  the  remaining Status bits unchanged (' 0uuu u1uu ').\nIt is recommended that only BCF BSF SWAPF MOVFF , , , , MOVWF and MOVFFL instructions are used to alter the STATUS  register,  because  these  instructions  do  not affect  the  Z,  C,  DC,  OV  or  N  bits  in  the  STATUS register.\nFor other instructions that do not affect Status bits, see the instruction set summaries in Section 42.2 'Extended Instruction Set' and Table 42-3.\nThe C and DC bits operate as the borrow and  digit borrow bits, respectively, in",
    "4.5.5 STATUS REGISTER\nNote: subtraction.",
    "4.5.6 CALL SHADOW REGISTER\nWhen CALL CALLW RCALL , , instructions are used, the WREG, BSR and STATUS are automatically saved in hardware and can be accessed using the WREG_C -SHAD, BSR_CSHAD and STATUS_CSHAD registers.\nNote 1: Changing  the  values  of  these  registers may lead to erroneous code execution.\n2: If the contents of these registers are not handled correctly, it may lead to errone -ous code execution.",
    "REGISTER 4-2: STATUS: STATUS REGISTER\n-, R-1/q = TO. -, R-1/q = PD. -, R/W-0/u = N. -, R/W-0/u = OV. -, R/W-0/u = Z. -, R/W-0/u = DC. -, R/W-0/u = C. bit 7 bit 0, R-1/q = bit 7 bit 0. bit 7 bit 0, R-1/q = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0",
    "REGISTER 4-2: STATUS: STATUS REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6\nTO:\nTime-Out bit\n1 = Set at power-up or by execution of CLRWDT or SLEEP instruction\n0 = A WDT time-out occurred\nbit 5",
    "PD: Power-Down bit\n1 = Set at power-up or by execution of CLRWDT instruction\n0 = Set by execution of the SLEEP instruction",
    "bit 4 N: Negative bit used for signed arithmetic (2's complement); indicates if the result is negative,\n(ALU MSb = 1 ).\n1 = The result is negative\n0 = The result is positive",
    "bit 3 OV: Overflow bit used for signed arithmetic (2's complement); indicates an overflow of the 7-bit\nmagnitude, which causes the sign bit (bit 7) to change state.\n1 = Overflow occurred for current signed arithmetic operation\n0 = No overflow occurred",
    "bit 2 Z: Zero bit\n1 = The result of an arithmetic or logic operation is zero\n0 = The result of an arithmetic or logic operation is not zero\nbit 1\nDC: Digit Carry/Borrow bit ( ADDWF ADDLW SUBLW SUBWF , , , instructions) (1)\n1 = A carry-out from the 4th low-order bit of the result occurred\n0 = No carry-out from the 4th low-order bit of the result\nbit 0\nC: Carry/Borrow bit ( ADDWF ADDLW SUBLW SUBWF , , , instructions) (1,2)\n1 = A carry-out from the Most Significant bit of the result occurred\n0 = No carry-out from the Most Significant bit of the result occurred\nNote1: For Borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand.\n2: For Rotate ( RRF RLF , ) instructions, this bit is loaded with either the high or low-order bit of the Source register.",
    "4.7 Data Addressing Modes\nNote:\nThe execution of some instructions in the core  PIC18  instruction  set  are  changed when the PIC18 extended instruction set is enabled. See Section 4.8 'Data Memory and  the  Extended  Instruction  Set' for more information.\nWhile the program memory can be addressed in only one way - through the Program Counter - information in the data memory space can be addressed in several ways. For most instructions, the addressing mode is fixed. Other instructions may use up to three modes, depending on which operands are used and whether or not the extended instruction set is enabled.\nThe addressing modes are:\n\u00b7 Inherent\n\u00b7 Literal\n\u00b7 Direct\n\u00b7 Indirect\nAn additional addressing mode, Indexed Literal Offset, is available  when  the  extended  instruction  set  is enabled (XINST Configuration bit = 1 ). Its operation is discussed in detail in Section 4.8.1 'Indexed Addressing with Literal Offset' .",
    "4.7.1 INHERENT AND LITERAL ADDRESSING\nMany  PIC18  control  instructions  do  not  need  any argument at all; they either perform an operation that globally affects the device or they operate implicitly on one  register.  This addressing  mode  is  known  as Inherent Addressing. Examples include SLEEP RESET , and DAW .\nOther instructions work in a similar way but require an additional  explicit  argument  in  the  opcode.  This  is known  as  Literal  Addressing  mode  because  they require some literal value as an argument. Examples include ADDLW and MOVLW , which respectively, add or move a literal value to the W register. Other examples include CALL and GOTO , which include a 20-bit program memory address.",
    "4.7.2 DIRECT ADDRESSING\nDirect  addressing  specifies  all  or  part  of  the  source and/or destination address of the operation within the opcode itself. The options are specified by the arguments accompanying the instruction.\nIn the core PIC18 instruction set, bit-oriented and byteoriented instructions use some  version of direct addressing by default. All of these instructions include some  8-bit  literal  address  as  their  Least  Significant Byte. This address specifies either a register address in one of the banks of data RAM ( Section 4.5.2 'General Purpose Register File' )  or  a  location  in  the Access Bank  ( Section  4.5.4 'Access  Bank' ) as  the  data source for the instruction.\nThe Access RAM bit 'a' determines how the address is interpreted.  When  'a'  is  ' 1 ',  the  contents  of  the  BSR ( Section  4.5.1 'Bank  Select  Register  (BSR)' )  are used with the address to determine the complete 14-bit address of the register. When 'a' is ' 0 ', the address is interpreted  as  being  a  register  in  the Access  Bank. Addressing that uses the Access RAM is sometimes also known as Direct Forced Addressing mode.",
    "4.7.2 DIRECT ADDRESSING\nA few instructions, such as MOVFFL , include the entire 14-bit  address  (either  source  or  destination)  in  their opcodes. In these cases, the BSR is ignored entirely.\nThe destination of the operation's results is determined by the destination bit 'd'. When 'd' is ' 1 ', the results are stored back in the source register, overwriting its origi -nal contents. When 'd' is ' 0 ', the results are stored in the  W  register.  Instructions  without  the  'd'  argument have a destination that is implicit in the instruction; their destination is either the target register being operated on or the W register.",
    "4.7.3 INDIRECT ADDRESSING\nIndirect addressing allows the user to access a location in data memory without giving a fixed address in the instruction. This is done by using File Select Registers (FSRs) as pointers to the locations which are to be read or written. Since the FSRs are themselves located in RAM  as  Special  File  Registers,  they  can  also  be directly manipulated under program control. This makes FSRs very useful in implementing data struc -tures, such as tables and arrays in data memory.\nThe registers for indirect addressing are also implemented with Indirect File Operands (INDFs) that permit automatic manipulation of the pointer value with auto-incrementing, auto-decrementing or offsetting with another value. This allows for efficient code, using loops, such as the example of clearing an entire RAM bank in Example 4-6.",
    "EXAMPLE 4-6:\nHOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nNEXT, 1 = LFSR CLRF. NEXT, 2 = F SR0, 10 0h POSTINC0. NEXT, 3 = ; ; Clear INDF ; register then ; inc pointer. , 1 = BTFSS. , 2 = FSR0H, 1. , 3 = ; All done with. , 1 = . , 2 = . , 3 = ; Bank1?. , 1 = BRA. , 2 = NEXT. , 3 = ; NO, clear next. CONTINUE, 1 = CONTINUE. CONTINUE, 2 = CONTINUE. CONTINUE, 3 = ; YES, continue",
    "4.7.3.1 FSR Registers and the INDF Operand\nAt  the  core  of  indirect  addressing  are  three  sets  of registers: FSR0, FSR1 and FSR2. Each represents a pair of 8-bit registers, FSRnH and FSRnL. Each FSR pair holds a 14-bit value, therefore, the two upper bits of  the  FSRnH register are not used. The 14-bit FSR value can address the entire range of the data memory in a linear fashion. The FSR register pairs, then, serve as pointers to data memory locations.",
    "4.7.3.1 FSR Registers and the INDF Operand\nIndirect  addressing  is  accomplished  with  a  set  of Indirect File Operands, INDF0 through INDF2. These can  be  thought  of  as  'virtual'  registers;  they  are mapped  in  the  SFR  space  but  are  not  physically implemented. Reading or writing to a particular INDF register  actually  accesses  the  data  addressed  by  its corresponding FSR register pair. A read from INDF1, for example, reads the data at the address indicated by FSR1H:FSR1L. Instructions that use the INDF registers as operands actually use the contents of their corresponding  FSR  as  a  pointer  to  the  instruction's target. The INDF operand is just a convenient way of using the pointer.\nBecause indirect addressing uses a full 14-bit address, data RAM banking is not necessary. Thus, the current contents of the BSR and the Access RAM bit have no effect on determining the target address.",
    "4.7.3.2 FSR Registers, POSTINC, POSTDEC, PREINC and PLUSW\nIn addition to the INDF operand, each FSR register pair also has four additional indirect operands. Like INDF, these  are  'virtual'  registers  which  cannot  be  directly read  or  written.  Accessing  these  registers  actually accesses  the  location  to  which  the  associated  FSR register pair points, and also performs a specific action on the FSR value. They are:\n\u00b7 POSTDEC: accesses the location to which the FSR points, then automatically decrements the FSR by 1 afterwards\n\u00b7 POSTINC: accesses the location to which the FSR points, then automatically increments the FSR by 1 afterwards\n\u00b7 PREINC: automatically increments the FSR by 1, then uses the location to which the FSR points in the operation\n\u00b7 PLUSW: adds the signed value of the W register (range of -127 to 128) to that of the FSR and uses the location to which the result points in the operation.",
    "FIGURE 4-6: INDIRECT ADDRESSING\nIn  this  context,  accessing  an  INDF  register  uses  the value in the associated FSR register without changing it.  Similarly,  accessing  a  PLUSW  register  gives  the FSR value an offset by that in the W register; however, neither  W  nor  the  FSR  is  actually  changed  in  the operation. Accessing the other virtual registers changes the value of the FSR register.\nOperations  on  the  FSRs  with  POSTDEC,  POSTINC and PREINC affect the entire register pair; that is, roll -overs of the FSRnL register from FFh to 00h carry over to  the  FSRnH register. On the other hand, results of these operations do not change the value of any flags in the STATUS register (e.g., Z, N, OV, etc.).\nThe PLUSW register can be used to implement a form of indexed addressing in the data memory space. By manipulating  the  value  in  the  W  register,  users  can reach  addresses  that  are  fixed  offsets  from  pointer addresses. In some applications, this can be used to implement  some  powerful  program  control  structure, such as software stacks, inside of data memory.",
    "4.7.3.3 Operations by FSRs on FSRs\nIndirect addressing operations that target other FSRs or virtual registers represent special cases. For example, using an FSR to point to one of the virtual registers will not result in successful operations. As a specific  case,  assume  that  FSR0H:FSR0L  contains 3FE7h,  the  address  of  INDF1. Attempts  to  read  the value  of  the  INDF1  using  INDF0  as  an  operand  will return 00h. Attempts to write to INDF1 using INDF0 as the operand will result in a NOP .\nOn the other hand, using the virtual registers to write to an FSR pair may not occur as planned. In these cases, the value will be written to the FSR pair but without any incrementing or decrementing. Thus, writing to either the INDF2 or POSTDEC2 register will write the same value to the FSR2H:FSR2L.\nSince the FSRs are physical registers mapped in the SFR space, they can be manipulated through all direct operations.  Users  should  proceed  cautiously  when working  on  these  registers,  particularly  if  their  code uses indirect addressing.",
    "4.7.3.3 Operations by FSRs on FSRs\nSimilarly, operations by indirect addressing are generally permitted on all other SFRs. Users should exercise the appropriate caution that they do not inadvertently change settings that might affect the operation of the device.",
    "4.8 Data Memory and the Extended Instruction Set\nEnabling  the  PIC18  extended  instruction  set  (XINST Configuration  bit  = 1 ) significantly  changes  certain aspects of data memory and its  addressing. Specifi -cally, the use of the Access Bank for many of the core PIC18 instructions is different; this is due to the intro -duction of a new addressing mode for the data memory space.\nWhat does not change is just as important. The size of the data memory space is unchanged, as well as its linear  addressing. The  SFR  map  remains  the  same. Core PIC18 instructions can still operate in both Direct and  Indirect  Addressing  mode;  inherent  and  literal instructions  do  not  change at all.  Indirect  addressing with FSR0 and FSR1 also remain unchanged.",
    "4.8.1 INDEXED ADDRESSING WITH LITERAL OFFSET\nEnabling the PIC18 extended instruction set changes the  behavior  of  indirect  addressing  using  the  FSR2 register  pair  within  Access  RAM.  Under  the  proper conditions, instructions that use the Access Bank - that is,  most  bit-oriented  and  byte-oriented  instructions  can  invoke  a  form  of  indexed  addressing  using  an offset specified in the instruction. This special addressing mode is known as Indexed Addressing with Literal Offset, or Indexed Literal Offset mode.\nWhen using the extended instruction set, this addressing mode requires the following:\n\u00b7 The use of the Access Bank is forced ('a' = 0 ) and\n\u00b7 The file address argument is less than or equal to 5Fh.\nUnder these conditions, the file address of the instruction  is  not  interpreted  as  the  lower  byte  of  an address (used with the BSR in direct addressing), or as an 8-bit address in the Access Bank. Instead, the value is interpreted as an offset value to an Address Pointer, specified  by  FSR2.  The  offset  and  the  contents  of FSR2 are added to obtain the  target  address  of  the operation.",
    "4.8.2 INSTRUCTIONS AFFECTED BY INDEXED LITERAL OFFSET MODE\nAny of the core PIC18 instructions that can use direct addressing  are  potentially  affected  by  the  Indexed Literal  Offset  Addressing  mode.  This  includes  all byte-oriented and bit-oriented instructions, or almost one-half of the standard PIC18 instruction set. Instructions that only use Inherent or Literal Addressing modes are unaffected.\nAdditionally, byte-oriented and bit-oriented instructions are  not  affected  if  they  do  not  use  the Access  Bank (Access RAM bit is ' 1 '), or include a file address of 60h or above. Instructions meeting these criteria will continue  to  execute  as  before. A  comparison  of  the different possible addressing modes when the extended  instruction set is enabled is shown  in Figure 4-7.\nThose who desire to use byte-oriented or bit-oriented instructions in the Indexed Literal Offset mode should note the changes to assembler syntax for this mode. This is described in more detail in Section 42.2.1 'Extended Instruction Syntax' .\nFIGURE 4-7:",
    "COMPARING ADDRESSING OPTIONS FOR BIT-ORIENTED AND BYTE-ORIENTED INSTRUCTIONS (EXTENDED INSTRUCTION SET ENABLED)\nEXAMPLE INSTRUCTION: ADDWF, f, d, a (Opcode: 0010 01da ffff ffff )",
    "When 'a' = 0 and f \uf0b3 60h:\nThe  instruction executes  in Direct Forced mode. 'f' is inter -preted  as  a  location  in  the Access  RAM  between  060h and 0FFh. This is the same as locations 3F60h to 3FFFh (Bank 63) of data memory.\nLocations  below  60h  are  not available in this  Addressing mode.",
    "When 'a' = 0 and f \uf020\uf0a3\uf020 5Fh:\nThe instruction executes in Indexed Literal Offset mode. 'f' is interpreted as an offset to the address  value  in  FSR2.  The two are added together to obtain the address of the target register for the instruction. The address  can  be  anywhere  in the data memory space.\nNote  that  in  this mode,  the correct syntax is now:\nADDWF [k], d where 'k' is the same as 'f'.",
    "When 'a' = 1 (all values of f):\nThe  instruction executes  in Direct  mode  (also  known  as Direct Long mode). 'f' is inter -preted as a location in one of the 63 banks of the data memory  space.  The  bank  is designated by the Bank Select Register  (BSR). The  address can  be  in  any  implemented bank in the data memory space.",
    "4.8.3 MAPPING THE ACCESS BANK IN INDEXED LITERAL OFFSET MODE\nThe  use  of  Indexed  Literal  Offset Addressing  mode effectively changes how the first 96 locations of Access RAM (00h to 5Fh) are mapped. Rather than containing just the contents of the bottom section of Bank 0, this mode maps the contents from a user defined 'window' that  can  be  located  anywhere  in  the  data  memory space. The value of FSR2 establishes the lower bound -ary of the addresses mapped into the window, while the upper  boundary  is  defined  by  FSR2  plus  95  (5Fh). Addresses in the Access RAM above 5Fh are mapped as previously described (see Section 4.5.4 'Access Bank' ). An example of Access Bank remapping in this addressing mode is shown in Figure 4-8.",
    "4.9 PIC18 Instruction Execution and the Extended Instruction Set\nEnabling the extended instruction set adds eight additional commands to the existing PIC18 instruction set.  These  instructions  are  executed  as  described  in Section 42.2 'Extended Instruction Set' .\nRemapping  of the  Access Bank  applies only to operations  using  the  Indexed  Literal  Offset  mode. Operations that use the BSR (Access RAM bit is ' 1 ') will continue to use direct addressing as before.",
    "5.0 DEVICE CONFIGURATION\nDevice  configuration  consists  of  the  Configuration Words, User ID, Device ID, Rev ID, Device Information Area  (DIA),  (see Section 5.7  'Device  Information Area' ), and  the Device  Configuration  Information (DCI) regions, (see Section 5.8 'Device Configura -tion Information' ).",
    "5.1 Configuration Words\nThere  are  six  Configuration  Word  bits  that  allow  the user  to  setup  the  device  with  several  choices  of oscillators,  Resets  and  memory  protection  options. These  are  implemented  as  Configuration  Word  1 through  Configuration  Word  6  at  300000h  through 300008h.",
    "REGISTER 5-1: CONFIGURATION WORD 1L (30 0000h)\n-, R/W-1 = RSTOSC<2:0>. -, R/W-1 = RSTOSC<2:0>. -, R/W-1 = RSTOSC<2:0>. -, U-1 = -. -, R/W-1 = FEXTOSC<2:0>. -, R/W-1 = FEXTOSC<2:0>. -, R/W-1 = FEXTOSC<2:0>. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, U-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 0",
    "REGISTER 5-1: CONFIGURATION WORD 1L (30 0000h)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '1'. R = Readable bit, 3 = U = Unimplemented bit, read as '1'. -n = Value for blank device, 1 = '1' = Bit is set. -n = Value for blank device, 2 = '0' = Bit is cleared. -n = Value for blank device, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as ' 1 '\nbit 6-4\nRSTOSC<2:0>: Power-up Default Value for COSC bits\n111 = EXTOSC operating per FEXTOSC<2:0> bits\n110 = HFINTOSC with HFFRQ = 4 MHz and CDIV = 4:1\n101 = LFINTOSC\n100 = SOSC\n011 = Reserved\n010 = EXTOSC with 4x PLL, with EXTOSC operating per FEXTOSC<2:0> bits\n001 = Reserved\n000 = HFINTOSC with HFFRQ = 64 MHz and CDIV = 1:1; resets COSC/NOSC to 3'b110",
    "bit 3\nUnimplemented: Read as ' 1 '\nbit 2-0 FEXTOSC<2:0>: FEXTOSC External Oscillator Mode Selection bits\n111 = ECH (External Clock High Power)\n110 = ECM (External Clock Medium Power)\n101 = ECL (External Clock Low Power)\n100 = Oscillator is not enabled\n011 = Reserved (do not use)\n010 = HS (crystal oscillator) above 4 MHz\n001 = XT (crystal oscillator) above 100 kHz, below 4 MHz\n000 = LP (crystal oscillator) optimized for 32.768 kHz",
    "REGISTER 5-2:\nCONFIGURATION WORD 1H (30 0001h)\nU-1, 1 = U-1. U-1, 2 = R/W-1. U-1, 3 = U-1. U-1, 4 = R/W-1. U-1, 5 = U-1. U-1, 6 = R/W-1. U-1, 7 = R/W-1. -, 1 = -. -, 2 = FCMEN. -, 3 = -. -, 4 = CSWEN. -, 5 = -. -, 6 = PR1WAY. -, 7 = CLKOUTEN. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '1'\n-n = Value for blank device\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "bit 7-6 Unimplemented: Read as ' 1 '\nbit 5\nFCMEN: Fail-Safe Clock Monitor Enable bit\n1 = FSCM timer is enabled\n0 = FSCM timer is disabled\nbit 4\nUnimplemented: Read as ' 1 '\nbit 3\nCSWEN:\nClock Switch Enable bit\n1 = Writing to NOSC and NDIV is allowed\n0 = The NOSC and NDIV bits cannot be changed by user software\nbit 2 Unimplemented: Read as ' 1 '\nbit 1\nPR1WAY: PRLOCKED One-Way Set Enable bit\n1 = PRLOCKED bit can be cleared and set only once; Priority registers remain locked after one clear/set cycle\n0 = PRLOCKED bit can be set and cleared multiple times (subject to the unlock sequence)\nbit 0\nCLKOUTEN:\nClock Out Enable bit\nIf FEXTOSC<2:0> = EC (high, mid or low) or Not Enabled:\n1 = CLKOUT function is disabled; I/O or oscillator function on OSC2\n0 = CLKOUT function is enabled; FOSC/4 clock appears at OSC2\nOtherwise:\nThis bit is ignored.",
    "REGISTER 5-3: CONFIGURATION WORD 2L (30 0002h)\nBOREN<1:0>, R/W-1 = BOREN<1:0>. BOREN<1:0>, R/W-1 = LPBOREN. BOREN<1:0>, R/W-1 = IVT1WAY. BOREN<1:0>, R/W-1 = MVECEN. BOREN<1:0>, R/W-1 = PWRTS<1:0>. BOREN<1:0>, R/W-1 = PWRTS<1:0>. BOREN<1:0>, R/W-1 = MCLRE. bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = bit 0",
    "REGISTER 5-3: CONFIGURATION WORD 2L (30 0002h)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '1'. R = Readable bit, 3 = U = Unimplemented bit, read as '1'. -n = Value for blank device, 1 = '1' = Bit is set. -n = Value for blank device, 2 = '0' = Bit is cleared. -n = Value for blank device, 3 = x = Bit is unknown",
    "bit 7-6 BOREN<1:0>: Brown-out Reset Enable bits\nWhen enabled, Brown-out Reset Voltage (VBOR) is set by the BORV bit.\n11 = Brown-out Reset is enabled, SBOREN bit is ignored\n10 = Brown-out Reset is enabled while running, disabled in Sleep; SBOREN is ignored\n01 = Brown-out Reset is enabled according to SBOREN\n00 = Brown-out Reset is disabled\nbit 5\nLPBOREN:\nLow-Power BOR Enable bit\n1 = Low-Power BOR is disabled\n0 = Low-Power BOR is enabled",
    "bit 4\nIVT1WAY: IVTLOCK bit One-Way Set Enable bit\n1 = IVTLOCKED bit can be cleared and set only once; IVT registers remain locked after one clear/set cycle\n0 = IVTLOCK ED bit can be set and cleared multiple times (subject to the unlock sequence)",
    "bit 3 MVECEN: Multi-vector Enable bit\n1 = Multi-vector enabled; Vector table used for interrupts\n0 = Legacy interrupt behavior",
    "bit 2-1\nPWRTS<1:0>: Power-up Timer Selection bits\n11 = PWRT is disabled\n10 = PWRT set at 64 ms\n01 = PWRT set at 16 ms\n00 = PWRT set at 1 ms",
    "bit 0 MCLRE: Master Clear (MCLR) Enable bit\nIf LVP =\n1\n:\nRE3 pin function is MCLR\nIf LVP = 0 :\n1 = MCLR pin is MCLR\n0 = MCLR pin function is a port defined function",
    "REGISTER 5-4: CONFIGURATION WORD 2H (30 0003h)\nXINST, U-1 = -. XINST, R/W-1 = DEBUG. XINST, R/W-1 = STVREN. XINST, R/W-1 = PPS1WAY. XINST, R/W-1 = ZCD. XINST, R/W-1 = BORV<1:0> (1). XINST, R/W-1 = BORV<1:0> (1). bit 7 bit 0, U-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0",
    "REGISTER 5-4: CONFIGURATION WORD 2H (30 0003h)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '1'. R = Readable bit, 3 = U = Unimplemented bit, read as '1'. -n = Value for blank device, 1 = '1' = Bit is set. -n = Value for blank device, 2 = '0' = Bit is cleared. -n = Value for blank device, 3 = x = Bit is unknown\nbit 7\nXINST:\nExtended Instruction Set Enable bit\n1 = Extended instruction set and Indexed Addressing mode are disabled (Legacy mode)\n0 = Extended instruction set and Indexed Addressing mode are enabled",
    "bit 6 Unimplemented: Read as ' 1 '\nbit 5\nDEBUG: Debugger Enable bit\n1 = Background debugger is disabled\n0 = Background debugger is enabled",
    "bit 4\nSTVREN: Stack Overflow/Underflow Reset Enable bit\n1 = Stack Overflow or Underflow will cause a Reset\n0 = Stack Overflow or Underflow will not cause a Reset",
    "bit 3\nPPS1WAY: PPSLOCKED One-Way Set Enable bit\n1 = PPSLOCKED bit can be cleared and set only once; PPS registers remain locked after one clear/set cycle\n0 = PPSLOCKED bit can be set and cleared multiple times (subject to the unlock sequence)\nbit 2\nZCD:\nZero-Cross Detect Enable bit\n1 = ZCD is disabled; ZCD can be enabled by setting the bit SEN of the ZCDCON register\n0 = ZCD is always enabled",
    "bit 1-0\nBORV<1:0>: Brown-out Reset Voltage Selection bits (1)",
    "PIC18F25/26K83 Devices:\n- 11 = Brown-out Reset Voltage (VBOR) is set to 2.45V\n10 = Brown-out Reset Voltage (VBOR) is set to 2.45V\n- 01 = Brown-out Reset Voltage (VBOR) is set to 2.7V\n00 = Brown-out Reset Voltage (VBOR) is set to 2.85V",
    "PIC18LF25/26K83 Device:\n11 = Brown-out Reset Voltage (VBOR) is set to 1.90V\n10 = Brown-out Reset Voltage (VBOR) is set to 2.45V\n01 = Brown-out Reset Voltage (VBOR) is set to 2.7V\n00 = Brown-out Reset Voltage (VBOR) is set to 2.85V\nNote1: The higher voltage setting is recommended for operation at or above 16 MHz.",
    "REGISTER 5-5: CONFIGURATION WORD 3L (30 0004h)\n-, R/W-1 = WDTE<1:0>. -, R/W-1 = . -, R/W-1 = . -, R/W-1 = . -, R/W-1 = WDTCPS<4:0>. -, R/W-1 = . -, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '1'\n-n = Value for blank device\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 7 Unimplemented: Read as ' 1 '\nbit 6-5\nWDTE<1:0>: WDT Operating Mode bits\n00 = WDT is disabled, SWDTEN is ignored\n01 = WDT is enabled/disabled by the SWDTEN bit in WDTCON0\n10 = WDT is enabled while Sleep = 0 , suspended when Sleep = 1 ; SWDTEN is ignored\n11 = WDT is enabled regardless of Sleep; SWDTEN is ignored",
    "bit 4-0 WDTCPS<4:0>: WDT Period Select bits\n00000, WDTPS at POR.Value = 00000. 00000, WDTPS at POR.Divider Ratio = 1:32. 00000, WDTPS at POR.Divider Ratio = 2 5. 00000, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 1 ms. 00000, Software Control.of WDTPS? = No. 00001, WDTPS at POR.Value = 00001. 00001, WDTPS at POR.Divider Ratio = 1:64. 00001, WDTPS at POR.Divider Ratio = 2 6. 00001, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 2 ms. 00001, Software Control.of WDTPS? = No. 00010, WDTPS at POR.Value = 00010. 00010, WDTPS at POR.Divider Ratio = 1:128. 00010, WDTPS at POR.Divider Ratio = 2 7. 00010, WDTPS at POR.Typical Time-out (F IN = 31 kHz)",
    "bit 4-0 WDTCPS<4:0>: WDT Period Select bits\n= 4 ms. 00010, Software Control.of WDTPS? = No. 00011, WDTPS at POR.Value = 00011. 00011, WDTPS at POR.Divider Ratio = 1:256. 00011, WDTPS at POR.Divider Ratio = 2 8. 00011, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 8 ms. 00011, Software Control.of WDTPS? = No. 00100, WDTPS at POR.Value = 00100. 00100, WDTPS at POR.Divider Ratio = 1:512. 00100, WDTPS at POR.Divider Ratio = 2 9. 00100, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 16 ms. 00100, Software Control.of WDTPS? = No. 00101, WDTPS at POR.Value = 00101. 00101, WDTPS at POR.Divider Ratio = 1:1024. 00101, WDTPS at POR.Divider Ratio = 2 10.",
    "bit 4-0 WDTCPS<4:0>: WDT Period Select bits\n00101, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 32 ms. 00101, Software Control.of WDTPS? = No. 00110, WDTPS at POR.Value = 00110. 00110, WDTPS at POR.Divider Ratio = 1:2048. 00110, WDTPS at POR.Divider Ratio = 2 11. 00110, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 64 ms. 00110, Software Control.of WDTPS? = No. 00111, WDTPS at POR.Value = 00111. 00111, WDTPS at POR.Divider Ratio = 1:4096. 00111, WDTPS at POR.Divider Ratio = 2 12. 00111, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 128 ms. 00111, Software Control.of WDTPS? = No. 01000, WDTPS at POR.Value = 01000. 01000, WDTPS at",
    "bit 4-0 WDTCPS<4:0>: WDT Period Select bits\nPOR.Divider Ratio = 1:8192. 01000, WDTPS at POR.Divider Ratio = 2 13. 01000, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 256 ms. 01000, Software Control.of WDTPS? = No. 01001, WDTPS at POR.Value = 01001. 01001, WDTPS at POR.Divider Ratio = 1:16384. 01001, WDTPS at POR.Divider Ratio = 2 14. 01001, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 512 ms. 01001, Software Control.of WDTPS? = No. 01010, WDTPS at POR.Value = 01010. 01010, WDTPS at POR.Divider Ratio = 1:32768. 01010, WDTPS at POR.Divider Ratio = 2 15. 01010, WDTPS at POR.Typical Time-out (F IN = 31 kHz) =",
    "bit 4-0 WDTCPS<4:0>: WDT Period Select bits\n1s. 01010, Software Control.of WDTPS? = No. 01011, WDTPS at POR.Value = 01011. 01011, WDTPS at POR.Divider Ratio = 1:65536. 01011, WDTPS at POR.Divider Ratio = 2 16. 01011, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 2s. 01011, Software Control.of WDTPS? = No. 01100, WDTPS at POR.Value = 01100. 01100, WDTPS at POR.Divider Ratio = 1:131072. 01100, WDTPS at POR.Divider Ratio = 2 17. 01100, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 4s. 01100, Software Control.of WDTPS? = No. 01101, WDTPS at POR.Value = 01101. 01101, WDTPS at POR.Divider Ratio = 1:262144.",
    "bit 4-0 WDTCPS<4:0>: WDT Period Select bits\n01101, WDTPS at POR.Divider Ratio = 2 18. 01101, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 8s. 01101, Software Control.of WDTPS? = No. 01110, WDTPS at POR.Value = 01110. 01110, WDTPS at POR.Divider Ratio = 1:524299. 01110, WDTPS at POR.Divider Ratio = 2 19. 01110, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 16s. 01110, Software Control.of WDTPS? = No. 01111, WDTPS at POR.Value = 01111. 01111, WDTPS at POR.Divider Ratio = 1:1048576. 01111, WDTPS at POR.Divider Ratio = 2 20. 01111, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 32s. 01111, Software",
    "bit 4-0 WDTCPS<4:0>: WDT Period Select bits\nControl.of WDTPS? = No. 10000, WDTPS at POR.Value = 10000. 10000, WDTPS at POR.Divider Ratio = 1:2097152. 10000, WDTPS at POR.Divider Ratio = 2 21. 10000, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 64s. 10000, Software Control.of WDTPS? = No. 10001, WDTPS at POR.Value = 10001. 10001, WDTPS at POR.Divider Ratio = 1:4194304. 10001, WDTPS at POR.Divider Ratio = 2 22. 10001, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 128s. 10001, Software Control.of WDTPS? = No. 10010, WDTPS at POR.Value = 10010. 10010, WDTPS at POR.Divider Ratio = 1:8388608. 10010, WDTPS at POR.Divider Ratio = 2",
    "bit 4-0 WDTCPS<4:0>: WDT Period Select bits\n23. 10010, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 256s. 10010, Software Control.of WDTPS? = . 10011 ... 11110, WDTPS at POR.Value = 10011 ... 11110. 10011 ... 11110, WDTPS at POR.Divider Ratio = 1:32. 10011 ... 11110, WDTPS at POR.Divider Ratio = 2 5. 10011 ... 11110, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 1 ms. 10011 ... 11110, Software Control.of WDTPS? = . 11111, WDTPS at POR.Value = 01011. 11111, WDTPS at POR.Divider Ratio = 1:65536. 11111, WDTPS at POR.Divider Ratio = 2 16. 11111, WDTPS at POR.Typical Time-out (F IN = 31 kHz) = 2s. 11111, Software Control.of",
    "bit 4-0 WDTCPS<4:0>: WDT Period Select bits\nWDTPS? = Yes",
    "REGISTER 5-6: CONFIGURATION WORD 3H (30 0005h)\n-, U-1 = -. -, R/W-1 = WDTCCS<2:0>. -, R/W-1 = WDTCCS<2:0>. -, R/W-1 = WDTCCS<2:0>. -, R/W-1 = WDTCWS<2:0>. -, R/W-1 = WDTCWS<2:0>. -, R/W-1 = WDTCWS<2:0>. bit 7 bit 0, U-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '1'\n-n = Value for blank device\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 7-6 Unimplemented: Read as ' 1 '\nbit 5-3 WDTCCS<2:0>: WDT Input Clock Selector bits\nIf WDTE<1:0> Fuses = 2'b00 :\nThese bits are ignored.",
    "Otherwise:\n000 = WDT reference clock is the 31.0 kHz LFINTOSC\n001 = WDT reference clock is the 31.25 kHz MFINTOSC\n010 = WDT reference clock is SOSC\n011 = Reserved (default to LFINTOSC)\n\u2022\n\u2022\n110 = Reserved (default to LFINTOSC)\n111 = Software control\nbit 2-0 WDTCWS<2:0>:\nWDT Window Select bits",
    "Otherwise:\n000, Window at POR.Value = 000. 000, Window at POR.Window Delay Percent of Time = 87.5. 000, Window at POR.Window Opening Percent of Time = 12.5. 000, Software Control of.Window = No. 000, Keyed Access.Required? = Yes. 001, Window at POR.Value = 001. 001, Window at POR.Window Delay Percent of Time = 75. 001, Window at POR.Window Opening Percent of Time = 25. 001, Software Control of.Window = No. 001, Keyed Access.Required? = Yes. 010, Window at POR.Value = 010. 010, Window at POR.Window Delay Percent of Time = 62.5. 010, Window at POR.Window Opening Percent of Time = 37.5. 010, Software Control of.Window = No. 010, Keyed Access.Required? = Yes. 011, Window at POR.Value = 011. 011, Window at POR.Window Delay Percent of Time = 50. 011, Window at POR.Window Opening Percent of Time = 50. 011, Software Control of.Window = No. 011, Keyed Access.Required? =",
    "Otherwise:\nYes. 100, Window at POR.Value = 100. 100, Window at POR.Window Delay Percent of Time = 37.5. 100, Window at POR.Window Opening Percent of Time = 62.5. 100, Software Control of.Window = No. 100, Keyed Access.Required? = Yes. 101, Window at POR.Value = 101. 101, Window at POR.Window Delay Percent of Time = 25. 101, Window at POR.Window Opening Percent of Time = 75. 101, Software Control of.Window = No. 101, Keyed Access.Required? = Yes. 110, Window at POR.Value = 111. 110, Window at POR.Window Delay Percent of Time = n/a. 110, Window at POR.Window Opening Percent of Time = 100. 110, Software Control of.Window = No. 110, Keyed Access.Required? = Yes. 111, Window at POR.Value = 111. 111, Window at POR.Window Delay Percent of Time = n/a. 111, Window at POR.Window Opening Percent of Time = 100. 111, Software Control of.Window = Yes. 111, Keyed Access.Required? = No",
    "PIC18(L)F25/26K83\nREGISTER 5-7:\nCONFIGURATION WORD 4L (30 0006h)\nWRTAPP (1), U-1 = -. WRTAPP (1), U-1 = -. WRTAPP (1), R/W-1 = SAFEN (1). WRTAPP (1), R/W-1 = BBEN (1). WRTAPP (1), R/W-1 = BBSIZE<2:0> (2). WRTAPP (1), R/W-1 = BBSIZE<2:0> (2). WRTAPP (1), R/W-1 = BBSIZE<2:0> (2). bit 7, U-1 = bit 7. bit 7, U-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 0\nLegend:\nR = Readable bit",
    "PIC18(L)F25/26K83\nW = Writable bit\nU = Unimplemented bit, read as '1'\n-n = Value for blank device\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 7\nWRTAPP: Application Block Write Protection bit\n(1)\n1 =\nApplication Block is NOT write-protected\n0 = Application Block is write-protected\nbit 6-5\nUnimplemented: Read as ' 1 '\nbit 4\nSAFEN:\nStorage Area Flash Enable bit (1)\n1 = SAF is disabled\n0 =   SAF is enabled\nbit 3\nBBEN: Boot Block Enable bit (1)\n1 = Boot Block disabled\n0 =   Boot Block enabled\nbit 2-0\nBBSIZE<2:0>: Boot Block Size Selection bits (2)\nRefer to Table 5-1.\nNote1: Bits are implemented as sticky bits. Once protection is enabled through ICSP\u2122 or a self-write, it can only be reset through a Bulk Erase.\n2: BBSIZE<2:0> bits can only be changed when BBEN = 1 . Once BBEN = 0 , BBSIZE<2:0> can only be changed through a Bulk Erase.",
    "TABLE 5-1: BOOT BLOCK SIZE BITS\n1, BBSIZE[2:0]. = xxx. 1, Boot Block Size.(words) = 0. 1, END_ADDRESS_BOOT. = -. 1, Device Size (1).16k = X. 1, Device Size (1).32k = X. 0, BBSIZE[2:0]. = 111. 0, Boot Block Size.(words) = 512. 0, END_ADDRESS_BOOT. = 00 03FFh. 0, Device Size (1).16k = X. 0, Device Size (1).32k = X. 0, BBSIZE[2:0]. = 110. 0, Boot Block Size.(words) = 1024. 0, END_ADDRESS_BOOT. = 00 07FFh. 0, Device Size (1).16k = X. 0, Device Size (1).32k = X. 0, BBSIZE[2:0]. = 101. 0, Boot Block Size.(words) = 2048. 0, END_ADDRESS_BOOT. = 00 0FFFh. 0, Device Size",
    "TABLE 5-1: BOOT BLOCK SIZE BITS\n(1).16k = X. 0, Device Size (1).32k = X. 0, BBSIZE[2:0]. = 100. 0, Boot Block Size.(words) = 4096. 0, END_ADDRESS_BOOT. = 00 1FFFh. 0, Device Size (1).16k = X. 0, Device Size (1).32k = X. 0, BBSIZE[2:0]. = 011. 0, Boot Block Size.(words) = 8192. 0, END_ADDRESS_BOOT. = 00 3FFFh. 0, Device Size (1).16k = X. 0, Device Size (1).32k = X. 0, BBSIZE[2:0]. = 010. 0, Boot Block Size.(words) = 16384. 0, END_ADDRESS_BOOT. = 00 7FFFh. 0, Device Size (1).16k = -. 0, Device Size (1).32k = X. 0, BBSIZE[2:0]. = 001. 0, Boot",
    "TABLE 5-1: BOOT BLOCK SIZE BITS\nBlock Size.(words) = 32768. 0, END_ADDRESS_BOOT. = 00 FFFFh. 0, Device Size (1).16k = Note 2. 0, Device Size (1).32k = Note 2. 0, BBSIZE[2:0]. = 000. 0, Boot Block Size.(words) = 32768. 0, END_ADDRESS_BOOT. = 00 FFFFh. 0, Device Size (1).16k = -. 0, Device Size (1).32k = -\nNote 1: For each device, the quoted device size specification is listed in Table 4-1.\n2: The maximum Boot Block size is half the user program memory size. All selections higher than the maximum size default to maximum Boot Block size of half PFM. For example, all settings of BBSIZE = 000 through BBSIZE = 010 , default to a Boot Block size of 16 kW on a 32 kW device.",
    "REGISTER 5-8: CONFIGURATION WORD 4H (30 0007h)\n-, U-1 = -. -, R/W-1 = LVP (2). -, U-1 = -. -, R/W-1 = WRTSAF (1,3). -, R/W-1 = WRTD (1,4). -, R/W-1 = WRTC (1). -, R/W-1 = WRTB (1,5). bit 7 bit 0, U-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, U-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0",
    "REGISTER 5-8: CONFIGURATION WORD 4H (30 0007h)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '1'. R = Readable bit, 3 = U = Unimplemented bit, read as '1'. -n = Value for blank device, 1 = '1' = Bit is set. -n = Value for blank device, 2 = '0' = Bit is cleared. -n = Value for blank device, 3 = x = Bit is unknown",
    "bit 7-6 Unimplemented: Read as ' 1 '\nbit 5\nLVP: Low-Voltage Programming Enable bit (2)\n1 = Low-voltage programming enabled. MCLR/VPP pin function is MCLR. MCLRE (Register 5-3) is ignored.\n0 = HV on MCLR/VPP must be used for programming.",
    "bit 4 Unimplemented: Read as ' 1 '\nbit 3\nWRTSAF: Storage Area Flash (SAF) Write Protection bit (1,3)\n1 = SAF is NOT write-protected\n0 = SAF is write-protected\nbit 2\nWRTD: Data EEPROM Write Protection bit (1,4)\n1 = Data EEPROM NOT write-protected\n0 = Data EEPROM write-protected",
    "bit 1\nWRTC: Configuration Register Write Protection bit (1)\n1 = Configuration Register NOT write-protected\n0 = Configuration Register write-protected\nbit 0 WRTB: Boot Block Write Protection bit\n(1,5)\n1 = Boot Block NOT write-protected\n0 = Boot Block write-protected\nNote1: Bits are implemented as sticky bits. Once protection is enabled through ICSP or a self write, it can only be reset through a Bulk Erase.\n2: The LVP bit cannot be written (to zero) while operating from the LVP programming interface. The purpose of this rule is to prevent the user from dropping out of LVP mode while programming from LVP mode, or accidentally eliminating LVP mode from the configuration state.\n3: Unimplemented if SAF is not present and only applicable if SAFEN = 0.\n4: Unimplemented if data EEPROM is not present.\n5: Only applicable if BBEN = 0 .",
    "REGISTER 5-9:\nCONFIGURATION WORD 5L (30 0008h)\nU-1, 1 = U-1. U-1, 2 = U-1. U-1, 3 = U-1. U-1, 4 = U-1. U-1, 5 = U-1. U-1, 6 = U-1. U-1, 7 = R/W-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = CP. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 5-9:\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '1'. R = Readable bit, 3 = U = Unimplemented bit, read as '1'. -n = Value for blank device, 1 = '1' = Bit is set. -n = Value for blank device, 2 = '0' = Bit is cleared. -n = Value for blank device, 3 = x = Bit is unknown",
    "bit 7-1 Unimplemented: Read as ' 1 '\nbit 0\nCP: User Program Flash Memory and Data EEPROM Code Protection bit\n1 = User Program Flash Memory and Data EEPROM code protection is disabled\n0 = User Program Flash Memory and Data EEPROM code protection is enabled",
    "REGISTER 5-10: CONFIGURATION WORD 5H (30 0009h)\nU-1, 1 = U-1. U-1, 2 = U-1. U-1, 3 = U-1. U-1, 4 = U-1. U-1, 5 = U-1. U-1, 6 = U-1. U-1, 7 = U-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = -. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 5-10: CONFIGURATION WORD 5H (30 0009h)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '1'. R = Readable bit, 3 = U = Unimplemented bit, read as '1'. -n = Value for blank device, 1 = '1' = Bit is set. -n = Value for blank device, 2 = '0' = Bit is cleared. -n = Value for blank device, 3 = x = Bit is unknown\nbit 7-0 Unimplemented: Read as ' 1 '",
    "TABLE 5-2: SUMMARY OF CONFIGURATION WORDS\n30 0000h, Name = CONFIG1L. 30 0000h, Bit 7 = -. 30 0000h, Bit 6 = RSTOSC<2:0>. 30 0000h, Bit 5 = RSTOSC<2:0>. 30 0000h, Bit 4 = RSTOSC<2:0>. 30 0000h, Bit 3 = -. 30 0000h, Bit 2 = FEXTOSC<2:0>. 30 0000h, Bit 1 = FEXTOSC<2:0>. 30 0000h, Bit 0 = FEXTOSC<2:0>. 30 0000h, Default/ Unprogrammed Value = 1111 1111. 30 0001h, Name = CONFIG1H. 30 0001h, Bit 7 = -. 30 0001h, Bit 6 = -. 30 0001h, Bit 5 = FCMEN. 30 0001h, Bit 4 = -. 30 0001h, Bit 3 = CSWEN. 30 0001h, Bit 2 = -. 30 0001h, Bit 1 = PR1WAY. 30",
    "TABLE 5-2: SUMMARY OF CONFIGURATION WORDS\n0001h, Bit 0 = CLKOUTEN. 30 0001h, Default/ Unprogrammed Value = 1111 1111. 30 0002h, Name = CONFIG2L. 30 0002h, Bit 7 = BOREN<1:0>. 30 0002h, Bit 6 = BOREN<1:0>. 30 0002h, Bit 5 = LPBOREN. 30 0002h, Bit 4 = IVT1WAY. 30 0002h, Bit 3 = MVECEN. 30 0002h, Bit 2 = PWRTS<1:0>. 30 0002h, Bit 1 = PWRTS<1:0>. 30 0002h, Bit 0 = MCLRE. 30 0002h, Default/ Unprogrammed Value = 1111 1111. 30 0003h, Name = CONFIG2H. 30 0003h, Bit 7 = XINST. 30 0003h, Bit 6 = -. 30 0003h, Bit 5 = DEBUG. 30 0003h, Bit 4 = STVREN. 30 0003h, Bit 3 = PPS1WAY. 30",
    "TABLE 5-2: SUMMARY OF CONFIGURATION WORDS\n0003h, Bit 2 = ZCD. 30 0003h, Bit 1 = BORV<1:0>. 30 0003h, Bit 0 = BORV<1:0>. 30 0003h, Default/ Unprogrammed Value = 1111 1111. 30 0004h, Name = CONFIG3L. 30 0004h, Bit 7 = -. 30 0004h, Bit 6 = WDTE<1:0> WDTCPS<4:0>. 30 0004h, Bit 5 = WDTE<1:0> WDTCPS<4:0>. 30 0004h, Bit 4 = WDTE<1:0> WDTCPS<4:0>. 30 0004h, Bit 3 = WDTE<1:0> WDTCPS<4:0>. 30 0004h, Bit 2 = WDTE<1:0> WDTCPS<4:0>. 30 0004h, Bit 1 = WDTE<1:0> WDTCPS<4:0>. 30 0004h, Bit",
    "TABLE 5-2: SUMMARY OF CONFIGURATION WORDS\n0 = WDTE<1:0> WDTCPS<4:0>. 30 0004h, Default/ Unprogrammed Value = 1111 1111. 30 0005h, Name = CONFIG3H. 30 0005h, Bit 7 = -. 30 0005h, Bit 6 = -. 30 0005h, Bit 5 = WDTCCS<2:0>. 30 0005h, Bit 4 = WDTCCS<2:0>. 30 0005h, Bit 3 = WDTCCS<2:0>. 30 0005h, Bit 2 = WDTCWS<2:0>. 30 0005h, Bit 1 = WDTCWS<2:0>. 30 0005h, Bit 0 = WDTCWS<2:0>. 30 0005h, Default/ Unprogrammed Value = 1111 1111. 30 0006h, Name = CONFIG4L. 30 0006h, Bit 7 = WRTAPP. 30 0006h, Bit 6 = -. 30 0006h, Bit 5 = -. 30 0006h,",
    "TABLE 5-2: SUMMARY OF CONFIGURATION WORDS\nBit 4 = SAFEN. 30 0006h, Bit 3 = BBEN. 30 0006h, Bit 2 = BBSIZE<2:0>. 30 0006h, Bit 1 = BBSIZE<2:0>. 30 0006h, Bit 0 = BBSIZE<2:0>. 30 0006h, Default/ Unprogrammed Value = 1111 1111. 30 0007h, Name = CONFIG4H. 30 0007h, Bit 7 = -. 30 0007h, Bit 6 = -. 30 0007h, Bit 5 = LVP. 30 0007h, Bit 4 = -. 30 0007h, Bit 3 = WRTSAF. 30 0007h, Bit 2 = WRTD. 30 0007h, Bit 1 = WRTC. 30 0007h, Bit 0 = WRTB. 30 0007h, Default/ Unprogrammed Value = 1111 1111. 30 0008h, Name = CONFIG5L. 30 0008h, Bit 7 = -. 30 0008h, Bit 6 = -. 30 0008h, Bit 5 =",
    "TABLE 5-2: SUMMARY OF CONFIGURATION WORDS\n-. 30 0008h, Bit 4 = -. 30 0008h, Bit 3 = -. 30 0008h, Bit 2 = -. 30 0008h, Bit 1 = -. 30 0008h, Bit 0 = CP. 30 0008h, Default/ Unprogrammed Value = 1111 1111. 30 0009h, Name = CONFIG5H. 30 0009h, Bit 7 = -. 30 0009h, Bit 6 = -. 30 0009h, Bit 5 = -. 30 0009h, Bit 4 = -. 30 0009h, Bit 3 = -. 30 0009h, Bit 2 = -. 30 0009h, Bit 1 = -. 30 0009h, Bit 0 = -. 30 0009h, Default/ Unprogrammed Value = 1111 1111",
    "5.3 Code Protection\nCode protection allows the device to be protected from external access. Program memory protection and data memory are controlled through the CP Configuration bit. Internal access to the program memory is unaffected by code protection setting.\nThe entire program memory space and Data EEPROM is protected from external reads and writes by the CP bit in Configuration Words. When CP = 0 , external reads and writes of memory are inhibited and a  read  will  return  all  ' 0 's.  The  CPU  can  continue  to read program memory and data EEPROM, regardless of the protection bit settings. Self-writing the program memory  or  Data  EEPROM  is  dependent  upon  the write protection settings.",
    "5.4 User ID\nEight words in the memory space (200000h-200000Fh) are  designated  as  ID  locations  where  the  user  can store checksum or other code identification numbers. These  locations  are  readable  and  writable  during normal execution. See Section 13.2 'Device Information Area, Device Configuration Area, User ID, Device ID and Configuration Word Access' for more information on accessing these memory locations. For more information on checksum calculation, see the ' PIC18(L)F25/26K83  Memory Programming Specification ' (DS40001927) .",
    "5.5 Device ID and Revision ID\nThe 16-bit device ID word is located at 3F FFFEh and the 16-bit revision ID is located at 3F FFFCh. These locations  are  read-only  and  cannot  be  erased  or modified.\nDevelopment tools, such as device programmers and debuggers,  may  be  used  to  read  the  Device  ID, Revision  ID  and  Configuration  Words.  Refer  to 13.0 'Nonvolatile Memory  (NVM)  Control' for more information on accessing these locations.",
    "REGISTER 5-11: DEVICE ID: DEVICE ID REGISTER\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV<15:8>, 1 = DEV<15:8>. DEV<15:8>, 2 = DEV<15:8>. DEV<15:8>, 3 = DEV<15:8>. DEV<15:8>, 4 = DEV<15:8>. DEV<15:8>, 5 = DEV<15:8>. DEV<15:8>, 6 = DEV<15:8>. DEV<15:8>, 7 = DEV<15:8>. bit 15, 1 = . bit 15, 2 = . bit 15, 3 = . bit 15, 4 = . bit 15, 5 = . bit 15, 6 = . bit 15, 7 = bit 8\nR\nR\nR\nR\nR\nR\nR\nR\nDEV<7:0>\nbit 7\nbit 0",
    "REGISTER 5-11: DEVICE ID: DEVICE ID REGISTER\nLegend:, 1 = . Legend:, 2 = . Legend:, 3 = . R = Readable bit, 1 = '1' = Bit is set. R = Readable bit, 2 = 0' = Bit is cleared. R = Readable bit, 3 = x = Bit is unknown",
    "bit 15-0 DEV<15:0>: Device ID bits\nPIC18F25K83, Device ID = 6EE0h. PIC18F26K83, Device ID = 6EC0h. PIC18LF25K83, Device ID = 6F20h. PIC18LF26K83, Device ID = 6F00h",
    "PIC18(L)F25/26K83\n1, REVISION ID: REVISION ID REGISTER.R = 0. 1, REVISION ID: REVISION ID REGISTER.R = 1. 1, REVISION ID: REVISION ID REGISTER.R = 0. 1, REVISION ID: REVISION ID REGISTER.R = . 1, REVISION ID: REVISION ID REGISTER.R = MJRREV<5:2>. 1, REVISION ID: REVISION ID REGISTER.R = MJRREV<5:2>. 1, REVISION ID: REVISION ID REGISTER.R = . bit 15, REVISION ID: REVISION ID REGISTER.R = . bit 15, REVISION ID: REVISION ID REGISTER.R = . bit 15, REVISION ID: REVISION ID REGISTER.R = . bit 15, REVISION ID: REVISION ID REGISTER.R = . bit 15, REVISION ID: REVISION ID REGISTER.R = . bit 15, REVISION ID: REVISION ID REGISTER.R = . bit 15, REVISION ID: REVISION ID REGISTER.R = bit 8. R, REVISION ID: REVISION ID REGISTER.R = R. R, REVISION ID: REVISION ID REGISTER.R = R. R, REVISION ID: REVISION ID REGISTER.R = R. R, REVISION ID: REVISION ID",
    "PIC18(L)F25/26K83\nREGISTER.R = R. R, REVISION ID: REVISION ID REGISTER.R = R. R, REVISION ID: REVISION ID REGISTER.R = R. R, REVISION ID: REVISION ID REGISTER.R = R. MJRREV<1:0>, REVISION ID: REVISION ID REGISTER.R = MJRREV<1:0>. MJRREV<1:0>, REVISION ID: REVISION ID REGISTER.R = . MJRREV<1:0>, REVISION ID: REVISION ID REGISTER.R = . MJRREV<1:0>, REVISION ID: REVISION ID REGISTER.R = MNRREV<5:0>. MJRREV<1:0>, REVISION ID: REVISION ID REGISTER.R = MNRREV<5:0>. MJRREV<1:0>, REVISION ID: REVISION ID REGISTER.R = . MJRREV<1:0>, REVISION ID: REVISION ID REGISTER.R = . bit 7, REVISION ID: REVISION ID REGISTER.R = . bit 7, REVISION ID: REVISION ID REGISTER.R = . bit 7, REVISION ID: REVISION ID",
    "PIC18(L)F25/26K83\nREGISTER.R = . bit 7, REVISION ID: REVISION ID REGISTER.R = . bit 7, REVISION ID: REVISION ID REGISTER.R = . bit 7, REVISION ID: REVISION ID REGISTER.R = . bit 7, REVISION ID: REVISION ID REGISTER.R = bit 0. Legend: R =, REVISION ID: REVISION ID REGISTER.R = . Legend: R =, REVISION ID: REVISION ID REGISTER.R = . Legend: R =, REVISION ID: REVISION ID REGISTER.R = . Legend: R =, REVISION ID: REVISION ID REGISTER.R = . Legend: R =, REVISION ID: REVISION ID REGISTER.R = . Legend: R =, REVISION ID: REVISION ID REGISTER.R = . Legend: R =, REVISION ID: REVISION ID REGISTER.R = . Readable bit, REVISION ID: REVISION ID REGISTER.R = . Readable bit, REVISION ID: REVISION ID REGISTER.R = '1' = Bit is set. Readable bit, REVISION ID: REVISION ID REGISTER.R = . Readable bit, REVISION ID: REVISION ID REGISTER.R = 0' = Bit is cleared. Readable bit, REVISION ID: REVISION ID",
    "PIC18(L)F25/26K83\nREGISTER.R = . Readable bit, REVISION ID: REVISION ID REGISTER.R = x = Bit is unknown. Readable bit, REVISION ID: REVISION ID REGISTER.R = \nbit 15-12\nRead as ' 1010 '\nThese bits are fixed with value ' 1010 ' for all devices in this family.\nbit 11-6\nMJRREV<5:0>: Major Revision ID bits\nThese bits are used to identify a major revision. A major revision is indicated by revision (A0, B0, C0, etc.)\nRevision A =\n0b00 0000\nbit 5-0\nMNRREV<5:0>: Minor Revision ID bits\nThese bits are used to identify a minor revision.\nRevision A0 = 0b00 0000",
    "5.7 Device Information Area\nThe  Device  Information  Area  (DIA)  is  a  dedicated region in the program memory space. The DIA contains the calibration data for the internal temperature indicator module, stores the Microchip Unique Identifier words and the Fixed Voltage Reference voltage readings measured in mV.\nThe complete DIA table is shown in Table 5-3: Device Information  Area,  followed  by  a  description  of  each region and its functionality. The data is mapped from 3F0000h to 3F003Fh in the PIC18(L)F25/26K83 family. These locations are read-only and cannot be erased or modified by the user. The data is programmed into the device during manufacturing.",
    "TABLE 5-3: DEVICE INFORMATION AREA\n\nNote 1: Value not present on LF devices.",
    "TABLE 5-3: DEVICE INFORMATION AREA\n3F0000h-3F000Bh, Name of Region = MUI0. 3F0000h-3F000Bh, Standard Device Information = Microchip Unique Identifier (6 Words). 3F0000h-3F000Bh, Name of Region = MUI1. 3F0000h-3F000Bh, Standard Device Information = Microchip Unique Identifier (6 Words). 3F0000h-3F000Bh, Name of Region = MUI2. 3F0000h-3F000Bh, Standard Device Information = Microchip Unique Identifier (6 Words). 3F0000h-3F000Bh, Name of Region = MUI3. 3F0000h-3F000Bh, Standard Device Information = Microchip Unique Identifier (6 Words). 3F0000h-3F000Bh, Name of Region = MUI4. 3F0000h-3F000Bh, Standard Device Information = Microchip Unique Identifier (6 Words).",
    "TABLE 5-3: DEVICE INFORMATION AREA\n3F0000h-3F000Bh, Name of Region = MUI5. 3F0000h-3F000Bh, Standard Device Information = Microchip Unique Identifier (6 Words). 3F000Ch-3F000Fh, Name of Region = MUI6. 3F000Ch-3F000Fh, Standard Device Information = Unassigned (2 Words). 3F000Ch-3F000Fh, Name of Region = MUI7. 3F000Ch-3F000Fh, Standard Device Information = Unassigned (2 Words). 3F0010h-3F0023h, Name of Region = EUI0. 3F0010h-3F0023h, Standard Device Information = Optional External Unique Identifier (10 Words). 3F0010h-3F0023h, Name of Region = EUI1. 3F0010h-3F0023h, Standard Device Information = Optional External Unique Identifier (10 Words). 3F0010h-3F0023h, Name of",
    "TABLE 5-3: DEVICE INFORMATION AREA\nRegion = EUI2. 3F0010h-3F0023h, Standard Device Information = Optional External Unique Identifier (10 Words). 3F0010h-3F0023h, Name of Region = EUI3. 3F0010h-3F0023h, Standard Device Information = Optional External Unique Identifier (10 Words). 3F0010h-3F0023h, Name of Region = EUI4. 3F0010h-3F0023h, Standard Device Information = Optional External Unique Identifier (10 Words). 3F0010h-3F0023h, Name of Region = EUI5. 3F0010h-3F0023h, Standard Device Information = Optional External Unique Identifier (10 Words). 3F0010h-3F0023h, Name of Region = EUI6. 3F0010h-3F0023h, Standard Device Information = Optional External Unique Identifier (10 Words). 3F0010h-3F0023h, Name of Region = EUI7.",
    "TABLE 5-3: DEVICE INFORMATION AREA\n3F0010h-3F0023h, Standard Device Information = Optional External Unique Identifier (10 Words). 3F0010h-3F0023h, Name of Region = EUI8. 3F0010h-3F0023h, Standard Device Information = Optional External Unique Identifier (10 Words). 3F0010h-3F0023h, Name of Region = EUI9. 3F0010h-3F0023h, Standard Device Information = Optional External Unique Identifier (10 Words). 3F0024h-3F0025h, Name of Region = TSLR1. 3F0024h-3F0025h, Standard Device Information = Unassigned (1 Word). 3F0026h-3F0027h, Name of Region = TSLR2. 3F0026h-3F0027h, Standard Device Information = Temperature Indicator ADC reading at @90\u00b0C (low range setting). 3F0028h-3F0029h, Name of Region = TSLR3.",
    "TABLE 5-3: DEVICE INFORMATION AREA\n3F0028h-3F0029h, Standard Device Information = Unassigned (1 word). 3F002Ah-3F002Bh, Name of Region = TSHR1. 3F002Ah-3F002Bh, Standard Device Information = Unassigned (1 Word). 3F002Ch-3F002Dh, Name of Region = TSHR2. 3F002Ch-3F002Dh, Standard Device Information = Temperature Indicator ADC reading at @90\u00b0C (high range setting). 3F002Eh-3F002Fh, Name of Region = TSHR3. 3F002Eh-3F002Fh, Standard Device Information = Unassigned (1 Word). 3F0030h-3F0031h, Name of Region = FVRA1X. 3F0030h-3F0031h, Standard Device Information = ADC FVR1 Output voltage for 1x setting (in mV). 3F0032h-3F0033h, Name of Region = FVRA2X.",
    "TABLE 5-3: DEVICE INFORMATION AREA\n3F0032h-3F0033h, Standard Device Information = ADC FVR1 Output Voltage for 2x setting (in mV). 3F0034h-3F0035h, Name of Region = FVRA4X (1). 3F0034h-3F0035h, Standard Device Information = ADC FVR1 Output Voltage for 4x setting (in mV). 3F0036h-3F0037h, Name of Region = FVRC1X. 3F0036h-3F0037h, Standard Device Information = Comparator FVR2 output voltage for 1x setting (in mV). 3F0038h-3F0039h, Name of Region = FVRC2X. 3F0038h-3F0039h, Standard Device Information = Comparator FVR2 output voltage for 2x setting (in mV). 3F003Ah-3F003Bh, Name of Region = FVRC4X. 3F003Ah-3F003Bh, Standard Device Information = Comparator FVR2 output voltage for 4x",
    "TABLE 5-3: DEVICE INFORMATION AREA\nsetting (in mV). 3F003Ch-3F003Fh, Name of Region = . 3F003Ch-3F003Fh, Standard Device Information = Unassigned (2 Words)",
    "5.7.1 MICROCHIP UNIQUE IDENTIFIER (MUI)\nThe PIC18(L)F25/26K83 devices are individually encoded during  final  manufacturing  with  a  Microchip Unique  Identifier,  or  MUI.  The  MUI  cannot  be  usererased. This feature allows for manufacturing traceability of Microchip Technology devices in applications  where  this  is  a  required.  It  may  also  be used by the application manufacturer for a number of functions that require unverified unique identification, such as:\n\u00b7 Tracking the device\n\u00b7 Unique serial number\nThe MUI consists  of  six  program  words.  When  read together, these fields form a unique identifier. The MUI is stored in nine read-only locations, located between 3F0000h to 3F000Fh in the DIA space. Table 5-3 lists the addresses of the identifier words.\nNote:\nFor  applications  that require verified unique identification, contact your Microchip  Technology  sales  office  to create a Serialized Quick Turn Programming SM  option.",
    "5.7.2 EXTERNAL UNIQUE IDENTIFIER (EUI)\nThe  EUI  data  is  stored  at  locations  3F0010h  to 3F0023h in the Program Memory region. This region is an  optional space  for  placing  application specific information. The data is coded per customer requirements during manufacturing.\nNote:\nData  is  stored  in  this  address  range  on receiving  a  request  from  the  customer. The customer may contact the local sales representative, or Field Applications Engineer,  and  provide  them  the  unique identifier  information  that  is  supposed  to be stored in this region.",
    "5.7.3 ANALOG-TO-DIGITAL CONVERSION DATA OF THE TEMPERATURE SENSOR\nThe purpose of the Temperature Sensor module is to provide a temperature-dependent voltage that can be measured by an analog module, see Section 36.0 'Temperature Indicator Module' .\nThe DIA table contains the internal ADC measurement values  of  the  Temperature  sensor  for  Low  and  High range  at  fixed  points  of  reference.  The  values  are measured during test and are unique to each device. The measurement data is stored in the DIA memory region as hexadecimal numbers corresponding to the ADC  conversion  result.  The  calibration  data  can  be used  to  plot  the  approximate  sensor  output  voltage, VTSENSE  vs.  Temperature  curve  without  having  to make calibration measurements in the application. For more information on the operation of the Temperature Sensor, refer to Section 36.0 'Temperature Indicator Module' .",
    "5.7.3 ANALOG-TO-DIGITAL CONVERSION DATA OF THE TEMPERATURE SENSOR\n\u00b7 TSLR2 : Address 3F0026h to 3F0027h store the measurements for the low-range setting of the Temperature Sensor at VDD = 3V.\n\u00b7 TSHR2 : Address 3F002Ch to 3F002Dh store the measurements for the High Range setting of the Temperature Sensor at VDD = 3V.\n\u00b7 The stored measurements are made by the device ADC using the internal VREF = 2.048V.",
    "5.7.4 FIXED VOLTAGE REFERENCE DATA\nThe DIA stores measured FVR voltages for this device in mV for the different buffer settings of 1x, 2x or 4x at Program Memory locations 3F0030h to 3F003Bh. For more  information  on  the  FVR,  refer  to Section 35.0 'Fixed Voltage Reference (FVR)' .\n\u00b7 FVRA1X stores the value of ADC FVR1 Output voltage for 1x setting (in mV)\n\u00b7 FVRA2X stores the value of ADC FVR1 Output Voltage for 2x setting (in mV)\n\u00b7 FVRA4X stores the value of ADC FVR1 Output Voltage for 4x setting (in mV)\n\u00b7 FVRC1X stores the value of Comparator FVR2 output voltage for 2x setting (in mV)\n\u00b7 FVRC2X stores the value of Comparator FVR2 output voltage for 2x setting (in mV)\n\u00b7 FVRC4X stores the value of Comparator FVR2 output voltage for 4x setting (in mV)",
    "TABLE 5-4: DEVICE CONFIGURATION INFORMATION FOR PIC18(L)F25/26K83\n3F FF00h-3F FF01h, Name = ERSIZ. 3F FF00h-3F FF01h, DESCRIPTION = Erase Row Size. 3F FF00h-3F FF01h, VALUE.PIC18(L)F25K83 = 64. 3F FF00h-3F FF01h, VALUE.PIC18(L)F26K83 = 64. 3F FF00h-3F FF01h, UNITS. = Words. 3F FF02h-3F FF03h, Name = WLSIZ. 3F FF02h-3F FF03h, DESCRIPTION = Number of write latches per row. 3F FF02h-3F FF03h, VALUE.PIC18(L)F25K83 = 128. 3F FF02h-3F FF03h, VALUE.PIC18(L)F26K83 = 128. 3F FF02h-3F FF03h, UNITS. = Bytes. 3F",
    "TABLE 5-4: DEVICE CONFIGURATION INFORMATION FOR PIC18(L)F25/26K83\nFF04h-3F FF05h, Name = URSIZ. 3F FF04h-3F FF05h, DESCRIPTION = Number of User Rows. 3F FF04h-3F FF05h, VALUE.PIC18(L)F25K83 = 256. 3F FF04h-3F FF05h, VALUE.PIC18(L)F26K83 = 512. 3F FF04h-3F FF05h, UNITS. = Rows. 3F FF06h-3F FF07h, Name = EESIZ. 3F FF06h-3F FF07h, DESCRIPTION = Data EEPROM memory size. 3F FF06h-3F FF07h, VALUE.PIC18(L)F25K83 = 1024. 3F FF06h-3F FF07h, VALUE.PIC18(L)F26K83 = 1024. 3F FF06h-3F FF07h, UNITS.",
    "TABLE 5-4: DEVICE CONFIGURATION INFORMATION FOR PIC18(L)F25/26K83\n= Bytes. 3F FF08h-3F FF09h, Name = PCNT. 3F FF08h-3F FF09h, DESCRIPTION = Pin Count. 3F FF08h-3F FF09h, VALUE.PIC18(L)F25K83 = 28. 3F FF08h-3F FF09h, VALUE.PIC18(L)F26K83 = 28. 3F FF08h-3F FF09h, UNITS. = Pins",
    "5.8 Device Configuration Information\nThe  Device Configuration Information (DCI) is a dedicated region in the program memory  space mapped from 3FFF00h to 3FFF09h. The data stored in these locations is read-only and cannot be erased.\nRefer  to  Table 5-4:  Device  Configuration  Information for  PIC18(L)F25/26K83  for  the  complete  DCI  table address  and  description.  The  DCI  holds  information about the device which is useful for programming and bootloader applications.\nThe  erase  size  is  the  minimum  erasable  unit  in  the PFM,  expressed  as  rows.  The  total  device  Flash memory capacity is (Row Size * Number of rows)",
    "6.0 RESETS\nThere are multiple ways to reset this device:\n\u00b7 Power-on Reset (POR)\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Low-Power Brown-Out Reset (LPBOR)\n\u00b7 MCLR Reset\n\u00b7 WDT Reset\n\u00b7 RESET instruction\n\u00b7 Stack Overflow\n\u00b7 Stack Underflow\n\u00b7 Programming mode exit\n\u00b7 Memory Execution Violation Reset (MEMV)",
    "FIGURE 6-1: SIMPLIFIED BLOCK DIAGRAM OF ON-CHIP RESET CIRCUIT\nTo allow VDD to stabilize, an optional Power-up Timer can be enabled to extend the Reset time after a BOR or POR event.\nA simplified block diagram of the On-Chip Reset Circuit is shown in Figure 6-1.",
    "PIC18(L)F25/26K83\nFIGURE 6-2:\nLPBOR, BOR, POR RELATIONSHIP",
    "6.1 Power-on Reset (POR)\nThe POR circuit holds the device in Reset until VDD has reached  an  acceptable  level  for  minimum  operation. Slow  rising  VDD,  fast  operating  speeds  or  analog performance may require greater than minimum VDD. The  PWRT,  BOR  or  MCLR  features  can  be  used  to extend  the  start-up  period  until  all  device  operation conditions have been met.",
    "6.2 Brown-out Reset (BOR)\nThe BOR circuit holds the device in Reset when VDD reaches  a  selectable  minimum  level.  Between  the POR and BOR, complete voltage range coverage for execution protection can be implemented.\nThe  Brown-out  Reset  module  has  four  operating modes controlled by the BOREN<1:0> bits in Configuration Words. The four operating modes are:\n\u00b7 BOR is always on\n\u00b7 BOR is off when in Sleep\n\u00b7 BOR is controlled by software\n\u00b7 BOR is always off\nRefer to Table 6-1 for more information.\nThe  Brown-out  Reset  voltage  level  is  selectable  by configuring the BORV<1:0>  bits in Configuration Words.\nA  VDD  noise  rejection  filter  prevents  the  BOR  from triggering on small events. If VDD falls below VBOR for a duration greater than parameter TBORDC, the device will reset. See Table 45-11 for more information.",
    "6.2.1 BOR IS ALWAYS ON\nWhen  the  BOREN  bits  of  Configuration  Words  are programmed to ' 11 ', the BOR is always on. The device start-up will be delayed until the BOR is ready and VDD is higher than the BOR threshold.\nBOR protection is active during Sleep. The BOR does not delay wake-up from Sleep.",
    "6.2.2 BOR IS OFF IN SLEEP\nWhen  the  BOREN  bits  of  Configuration  Words  are programmed to ' 10 ',  the BOR is on, except in Sleep. The device start-up  will  be  delayed  until  the  BOR  is ready and VDD is higher than the BOR threshold.\nBOR protection is not active during Sleep. The device wake-up will be delayed until the BOR is ready.",
    "6.2.3 BOR CONTROLLED BY SOFTWARE\nWhen  the  BOREN  bits  of  Configuration  Words  are programmed  to  ' 01 ', the  BOR  is  controlled  by  the SBOREN bit of the BORCON register. The device startup is not delayed by the BOR ready condition or the VDD level.\nBOR protection begins as soon as the BOR circuit is ready. The status of the BOR circuit is reflected in the BORRDY bit of the BORCON register.\nBOR protection is unchanged by Sleep.",
    "6.2.4 BOR AND BULK ERASE\nBOR is forced ON during PFM Bulk Erase operations to make sure that a safe erase voltage is maintained for a successful erase cycle.\nDuring Bulk Erase, the BOR is enabled at 2.45V for F and LF devices, even if it is configured to some other value. If VDD falls, the erase cycle will be aborted, but the device will not be reset.",
    "TABLE 6-1: BOR OPERATING MODES\n11, SBOREN.SBOREN = X. 11, Device Mode.Device Mode = X. 11, BOR Mode.BOR Mode = Active. 11, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 11, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 10, SBOREN.SBOREN = X. 10, Device Mode.Device Mode = Awake. 10, BOR Mode.BOR Mode = Active. 10, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 10, Instruction Execution upon:.Wake-up from Sleep = N/A. 10, SBOREN.SBOREN = X. 10, Device Mode.Device Mode = Sleep. 10, BOR Mode.BOR Mode = Hibernate. 10, Instruction Execution upon:.Release of POR = N/A. 10, Instruction Execution upon:.Wake-up from Sleep = Wait for release of BOR (BORRDY = 1 ). 01, SBOREN.SBOREN = 1. 01, Device Mode.Device",
    "TABLE 6-1: BOR OPERATING MODES\nMode = X. 01, BOR Mode.BOR Mode = Active. 01, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 01, SBOREN.SBOREN = 0. 01, Device Mode.Device Mode = X. 01, BOR Mode.BOR Mode = Hibernate. 01, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 00, SBOREN.SBOREN = X. 00, Device Mode.Device Mode = X. 00, BOR Mode.BOR Mode = Disabled. 00, Instruction Execution upon:.Release of POR = Begins immediately. 00, Instruction Execution upon:.Wake-up from Sleep = Begins immediately",
    "FIGURE 6-3: BROWN-OUT SITUATIONS\nTPWRT (1)\nVBOR\nVDD\nInternal Reset\nVBOR\nVDD\nInternal Reset\nTPWRT (1)\n< TPWRT\nTPWRT (1)\nVBOR\nVDD\nInternal Reset\nNote 1: TPWRT delay depends on PWRTS<1:0> Configuration bits.",
    "REGISTER 6-1:\nBORCON: BROWN-OUT RESET CONTROL REGISTER\nR/W-1/u, 1 = U-0. R/W-1/u, 2 = U-0. R/W-1/u, 3 = U-0. R/W-1/u, 4 = U-0. R/W-1/u, 5 = U-0. R/W-1/u, 6 = U-0. R/W-1/u, 7 = R-q/u. SBOREN, 1 = -. SBOREN, 2 = -. SBOREN, 3 = -. SBOREN, 4 = -. SBOREN, 5 = -. SBOREN, 6 = -. SBOREN, 7 = BORRDY. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nq = Value depends on condition",
    "bit 7 SBOREN: Software Brown-out Reset Enable bit\nIf BOREN \uf0b9 01 :\nSBOREN is read/write, but has no effect on the BOR.\nIf BOREN = 01 :\n1 = BOR Enabled\n0 = BOR Disabled",
    "bit 6-1\nUnimplemented: Read as ' 0 '\nbit 0\nBORRDY: Brown-out Reset Circuit Ready Status bit\n1 = The Brown-out Reset Circuit is active and armed\n0 = The Brown-out Reset Circuit is disabled or is warming up",
    "6.4 Low-Power Brown-out Reset (LPBOR)\nThe  Low-Power  Brown-out  Reset  (LPBOR)  provides an  additional  BOR  circuit  for  low  power  operation. Refer to Figure 6-2 to see how the BOR interacts with other modules.\nThe LPBOR is used to monitor the external VDD pin. When too low of a voltage is detected, the device is held in Reset.",
    "6.4.1 ENABLING LPBOR\nThe  LPBOR  is  controlled  by  the  LPBOREN  bit  of Configuration Word 2L. When the device is erased, the LPBOR module defaults to disabled.",
    "6.4.1.1 LPBOR Module Output\nThe output of the LPBOR module is a signal indicating whether or not a Reset is to be asserted. This signal is OR'd  together  with  the  Reset  signal  of  the  BOR module to provide the generic BOR signal, which goes to the PCON0 register and to the power control block.",
    "6.5 MCLR\nThe MCLR is an optional external input that can reset the  device.  The  MCLR  function  is  controlled  by  the MCLRE bit of Configuration Words and the LVP bit of Configuration Words (Table 6-2). The RMCLR bit in the PCON0 register will be set to ' 0 ' if a MCLR Reset has occurred.",
    "TABLE 6-2: MCLR CONFIGURATION\nx, LVP = 1. x, MCLR = Enabled. 1, LVP = 0. 1, MCLR = Enabled. 0, LVP = 0. 0, MCLR = Disabled",
    "6.5.1 MCLR ENABLED\nWhen MCLR is enabled and  the  pin  is  held  low,  the device is held in Reset. The MCLR pin is connected to VDD through an internal weak pull-up.\nThe device has a noise filter in the MCLR Reset path. The filter will detect and ignore small pulses.\nNote:\nAn internal Reset event ( RESET instruction,  BOR,  WWDT,  POR  stack), does not drive the MCLR pin low.",
    "6.5.2 MCLR DISABLED\nWhen MCLR is disabled, the MCLR pin becomes inputonly and pin functions such as internal weak pull-ups are  under  software  control.  See Section 16.2  'I/O Priorities' for more information.",
    "6.6 Windowed Watchdog Timer (WWDT) Reset\nThe Windowed Watchdog Timer generates a Reset if the  firmware  does  not  issue  a CLRWDT instruction within the time-out period or window set. The TO and PD bits in the STATUS register and the RWDT bit in the PCON0  register  are  changed  to  indicate  a  WWDT Reset. The WDTWV bit in the PCON0 register indicates if the WDT Reset has occurred due to a time out or a window violation. See Section 11.0 'Windowed Watchdog Timer (WWDT)' for more information.",
    "6.7 RESET Instruction\nA RESET instruction will cause a device Reset. The RI bit in the PCON0 register will be set to ' 0 '. See Table 63 for  default  conditions  after  a RESET instruction  has occurred.",
    "6.8 Stack Overflow/Underflow Reset\nThe  device  can  reset  when  the  Stack  Overflows  or Underflows.  The  STKOVF  or  STKUNF  bits  of  the PCON0  register  indicate  the  Reset  condition.  These Resets  are  enabled  by  setting  the  STVREN  bit  in Configuration Words. See Section 4.2.5 'Return Address Stack' for more information.",
    "6.9 Programming Mode Exit\nUpon  exit  of  Programming  mode,  the  device  will behave as if a POR has just occurred.",
    "6.10 Power-up Timer (PWRT)\nThe  Power-up  Timer  provides  a  selected  time-out duration on POR or Brown-out Reset.\nThe device is held in Reset as long as PWRT is active. The PWRT delay allows additional time for the VDD to rise  to  an  acceptable  level.  The  Power-up  Timer  is selected  by  setting  the  PWRTS<1:0>  Configuration bits, appropriately.\nThe Power-up Timer starts after the release of the POR and BOR/LPBOR if enabled, as shown in Figure 6-1.",
    "6.11 Start-up Sequence\nUpon the release of a POR or BOR, the following must occur before the device will begin executing:\n1. Power-up Timer runs to completion (if enabled).\n2. Oscillator  start-up  timer  runs  to  completion  (if required for selected oscillator source).\n3. MCLR must be released (if enabled).",
    "PIC18(L)F25/26K83\nThe  total time out will vary based  on  oscillator configuration and Power-up Timer configuration. See Section 7.0 'Oscillator Module (with Fail-Safe Clock Monitor)' for more information.\nThe Power-up Timer and oscillator start-up timer run independently  of  MCLR  Reset.  If  MCLR  is  kept  low long enough, the Power-up Timer and oscillator Startup  Timer  will  expire.  Upon  bringing  MCLR  high,  the device will begin execution after 10 FOSC cycles (see Figure 6-4).  This  is  useful  for  testing  purposes  or  to synchronize more than one device operating in parallel.",
    "FIGURE 6-4: RESET START-UP SEQUENCE\nTOST\nTMCLR\nTPWRT\nVDD\nInternal POR\nPower-up Timer\nMCLR\nInternal RESET\nOscillator Modes\nOscillator Start-up Timer\nOscillator\nFOSC",
    "Internal Oscillator\nOscillator\nFOSC\nExternal Clock (EC)\nCLKIN\nFOSC",
    "6.11.1 MEMORY EXECUTION VIOLATION\nIf the CPU executes outside the valid execution area, a memory execution violation Reset occurs.\nThe invalid execution areas are:\n1. Addresses outside implemented program mem -ory (see Table 5-1).\n2. Storage  Area Flash (SAF) inside program memory, if it is enabled.\nWhen a memory execution violation is generated, flag MEMV is cleared in PCON1 (Register 6-3) to signal the cause of Reset. It needs to be set in the user code after a  memory execution violation Reset has occurred to detect further violation Resets.",
    "6.12 Determining the Cause of a Reset\nUpon  any  Reset,  multiple  bits  in  the  STATUS  and PCON0 registers are updated to indicate the cause of the  Reset.  Table 6-3  shows  the  Reset  conditions  of these registers.",
    "TABLE 6-3: RESET CONDITION FOR SPECIAL REGISTERS\nPower-on Reset, Program Counter = 0. Power-on Reset, STATUS Register (1,2) = -110. Power-on Reset, STATUS Register (1,2) = 0000. Power-on Reset, PCON0 Register = 0011. Power-on Reset, PCON0 Register = 110x. Power-on Reset, PCON1 Register = ---- --1-. Brown-out Reset, Program Counter = 0. Brown-out Reset, STATUS Register (1,2) = -110. Brown-out Reset, STATUS Register (1,2) = 0000. Brown-out Reset, PCON0 Register = 0011. Brown-out Reset, PCON0 Register = 11u0. Brown-out Reset, PCON1 Register = ---- --1-. MCLR Reset during normal operation, Program Counter = 0. MCLR Reset during normal operation, STATUS Register (1,2) = -uuu. MCLR Reset during normal operation, STATUS Register (1,2) = uuuu. MCLR Reset during normal operation, PCON0 Register = uuuu. MCLR",
    "TABLE 6-3: RESET CONDITION FOR SPECIAL REGISTERS\nReset during normal operation, PCON0 Register = 0uuu. MCLR Reset during normal operation, PCON1 Register = ---- --u-. MCLR Reset during Sleep, Program Counter = 0. MCLR Reset during Sleep, STATUS Register (1,2) = -10u. MCLR Reset during Sleep, STATUS Register (1,2) = uuuu. MCLR Reset during Sleep, PCON0 Register = uuuu. MCLR Reset during Sleep, PCON0 Register = 0uuu. MCLR Reset during Sleep, PCON1 Register = ---- --u-. WWDTTime-out Reset, Program Counter = 0. WWDTTime-out Reset, STATUS Register (1,2) = -0uu. WWDTTime-out Reset, STATUS Register (1,2) = uuuu. WWDTTime-out Reset, PCON0 Register = uuu0. WWDTTime-out Reset, PCON0 Register = uuuu. WWDTTime-out Reset, PCON1 Register = ----",
    "TABLE 6-3: RESET CONDITION FOR SPECIAL REGISTERS\n--u-. WWDTWindow Violation Reset, Program Counter = 0. WWDTWindow Violation Reset, STATUS Register (1,2) = -uuu. WWDTWindow Violation Reset, STATUS Register (1,2) = uuuu. WWDTWindow Violation Reset, PCON0 Register = uu0u. WWDTWindow Violation Reset, PCON0 Register = uuuu. WWDTWindow Violation Reset, PCON1 Register = ---- --u-. RESET Instruction Executed, Program Counter = 0. RESET Instruction Executed, STATUS Register (1,2) = -uuu. RESET Instruction Executed, STATUS Register (1,2) = uuuu. RESET Instruction Executed, PCON0 Register = uuuu. RESET Instruction Executed, PCON0 Register = u0uu. RESET Instruction Executed, PCON1 Register = ---- --u-. Stack Overflow Reset (STVREN = 1 ), Program Counter = 0. Stack Overflow Reset (STVREN = 1 ), STATUS Register (1,2) =",
    "TABLE 6-3: RESET CONDITION FOR SPECIAL REGISTERS\n-uuu. Stack Overflow Reset (STVREN = 1 ), STATUS Register (1,2) = uuuu. Stack Overflow Reset (STVREN = 1 ), PCON0 Register = 1uuu. Stack Overflow Reset (STVREN = 1 ), PCON0 Register = uuuu. Stack Overflow Reset (STVREN = 1 ), PCON1 Register = ---- --u-. Stack Underflow Reset (STVREN = 1 ), Program Counter = 0. Stack Underflow Reset (STVREN = 1 ), STATUS Register (1,2) = -uuu. Stack Underflow Reset (STVREN = 1 ), STATUS Register (1,2) = uuuu. Stack Underflow Reset (STVREN = 1 ), PCON0 Register = u1uu. Stack Underflow Reset (STVREN = 1 ), PCON0 Register = uuuu. Stack Underflow Reset (STVREN = 1 ), PCON1 Register = ---- --u-. Memory Violation Reset, Program Counter = 0.",
    "TABLE 6-3: RESET CONDITION FOR SPECIAL REGISTERS\nMemory Violation Reset, STATUS Register (1,2) = -uuu. Memory Violation Reset, STATUS Register (1,2) = uuuu. Memory Violation Reset, PCON0 Register = uuuu. Memory Violation Reset, PCON0 Register = uuuu. Memory Violation Reset, PCON1 Register = ---- --0-\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, reads as ' 0 '.\nNote 1: If a Status bit is not implemented, that bit will be read as ' 0 ' .\n- 2: Status bits Z, C, DC are reset by POR/BOR, but not defined by the Resets module (Register 4-2).",
    "6.13 Power Control (PCON0/PCON1) Register\nThe Power Control (PCON0/PCON1) register contains flag bits to differentiate between a:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Power-on Reset (POR)\n\u00b7 Reset Instruction Reset (RI)\n\u00b7 MCLR Reset (RMCLR)\n\u00b7 Watchdog Timer Reset (RWDT)\n\u00b7 Watchdog Window Violation (WDTWV)\n\u00b7 Stack Underflow Reset (STKUNF)\n\u00b7 Stack Overflow Reset (STKOVF)\n\u00b7 Memory Violation Reset (MEMV)",
    "PIC18(L)F25/26K83\nThe PCON0/1 register bits are shown in Register 6-2 and Register 6-3. Hardware will change the corresponding register bit during the Reset process; if the  Reset  was  not  caused  by  the  condition,  the  bit remains unchanged (Table 6-3).\nSoftware should reset the bit to the inactive state after restart (hardware will not reset the bit). Software may also set any PCON0 bit to the active state, so that user code  may  be  tested,  but  no  Reset  action  will  be generated.",
    "REGISTER 6-2: PCON0: POWER CONTROL REGISTER 0\nR/W/HS-0/q, 1 = R/W/HS-0/q. R/W/HS-0/q, 2 = R/W/HC-1/q. R/W/HS-0/q, 3 = R/W/HC-1/q. R/W/HS-0/q, 4 = R/W/HC-1/q. R/W/HS-0/q, 5 = R/W/HC-1/q. R/W/HS-0/q, 6 = R/W/HC-0/u. R/W/HS-0/q, 7 = R/W/HC-q/u. STKOVF, 1 = STKUNF. STKOVF, 2 = WDTWV. STKOVF, 3 = RWDT. STKOVF, 4 = RMCLR. STKOVF, 5 = RI. STKOVF, 6 = POR. STKOVF, 7 = BOR. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit",
    "REGISTER 6-2: PCON0: POWER CONTROL REGISTER 0\n0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. HC = Bit is cleared by hardware, 1 = HC = Bit is cleared by hardware. HC = Bit is cleared by hardware, 2 = HS = Bit is set by hardware. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as ' 0. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -m/n = Value at POR and BOR/Value at all other Resets. ' 1 ' = Bit is set, 1 = ' 0 ' = Bit is cleared. ' 1 ' = Bit is set, 2 = q = Value depends on condition",
    "bit 7 STKOVF: Stack Overflow Flag bit\n1 = A Stack Overflow occurred (more CALL s than fit on the stack)\n0 = A Stack Overflow has not occurred or set to ' 0 ' by firmware",
    "bit 6 STKUNF:\nStack Underflow Flag bit\n1 = A Stack Underflow occurred (more RETURN s than CALL s)\n0 = A Stack Underflow has not occurred or set to ' 0 ' by firmware",
    "bit 5\nWDTWV: Watchdog Window Violation bit\n1 = A WDT window violation has not occurred or set to ' 1 ' by firmware\n0 = A CLRWDT instruction was issued when the WDT Reset window was closed (set to ' 0 ' in hardware when a WDT window violation Reset occurs)",
    "bit 4 RWDT: WDT Reset Flag bit\n1 = A WDT overflow/time-out Reset has not occurred or set to ' 1 ' by firmware\n0 = A WDT overflow/time-out Reset has occurred (set to ' 0 ' in hardware when a WDT Reset occurs)",
    "bit 3 RMCLR: MCLR Reset Flag bit\n1 = A MCLR Reset has not occurred or set to ' 1 ' by firmware\n0 = A MCLR Reset has occurred (set to ' 0 ' in hardware when a MCLR Reset occurs)",
    "bit 2 RI: RESET Instruction Flag bit\n1 = A RESET instruction has not been executed or set to ' 1 ' by firmware\n0 = A RESET instruction  has  been  executed  (set  to  ' 0 ' in  hardware  upon  executing  a RESET instruction)",
    "POR: Power-on Reset Status bit\n1 = No Power-on Reset occurred or set to ' 1 ' by firmware\n0 = A Power-on Reset occurred (set to ' 0 ' in hardware when a Power-on Reset occurs)",
    "bit 0 BOR: Brown-out Reset Status bit\n1 = No Brown-out Reset occurred or set to ' 1 ' by firmware\n0 = A Brown-out Reset occurred (set to ' 0 ' in hardware when a Brown-out Reset occurs)",
    "REGISTER 6-3: PCON1: POWER CONTROL REGISTER 1\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W/HC-1/u = MEMV. -, U-0 = -. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W/HC-1/u = bit 7. bit 7, U-0 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-m/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nq = Value depends on condition\nbit 7-2 Unimplemented: Read as ' 0 '\nbit 1\nMEMV: Memory Violation Flag bit\n1 = No memory violation Reset occurred or set to ' 1 ' by firmware\n0 = A memory violation Reset occurred (set to ' 0 ' in hardware when a memory violation occurs)\nbit 0\nUnimplemented: Read as ' 0 '",
    "TABLE 6-4: SUMMARY OF REGISTERS ASSOCIATED WITH RESETS\nBORCON, Bit 7 = SBOREN. BORCON, Bit 6 = -. BORCON, Bit 5 = -. BORCON, Bit 4 = -. BORCON, Bit 3 = -. BORCON, Bit 2 = -. BORCON, Bit 1 = -. BORCON, Bit 0 = BORRDY. BORCON, Register on Page = 75. PCON0, Bit 7 = STKOVF. PCON0, Bit 6 = STKUNF. PCON0, Bit 5 = WDTWV. PCON0, Bit 4 = RWDT. PCON0, Bit 3 = RMCLR. PCON0, Bit 2 = RI. PCON0, Bit 1 = POR. PCON0, Bit 0 = BOR. PCON0, Register on Page = 80. PCON1, Bit 7 = -. PCON1, Bit 6 = -. PCON1, Bit 5 = -. PCON1, Bit 4 = -. PCON1, Bit 3 = -. PCON1, Bit 2 = -. PCON1, Bit 1 =",
    "TABLE 6-4: SUMMARY OF REGISTERS ASSOCIATED WITH RESETS\nMEMV. PCON1, Bit 0 = -. PCON1, Register on Page = 81\nLegend: - = unimplemented location, read as ' 0 '. Shaded cells are not used by Resets.",
    "7.1 Overview\nThe oscillator module has multiple clock sources and selection  features  that  allow  it  to  be  used  in  a  wide range  of  applications  while  maximizing  performance and minimizing power consumption. Figure 7-1 illustrates a block diagram of the oscillator module.\nClock sources can be supplied from external oscillators, quartz-crystal  resonators  and  ceramic  resonators.  In addition, the system clock source can be supplied from one of two internal oscillators and PLL circuits, with a choice  of  speeds  selectable  via  software.  Additional clock features include:\n\u00b7 Selectable system clock source between external or internal sources via software.\n\u00b7 Fail-Safe Clock Monitor (FSCM) designed to detect a failure of the external clock source (LP, XT, HS, ECH, ECM, ECL) and switch automatically to the internal oscillator.\n\u00b7 Oscillator Start-up Timer (OST) ensures stability of crystal oscillator sources.\nThe RSTOSC bits of Configuration Word 1 (Register 5-\n- 1)  determine  the  type  of  oscillator  that  will  be  used when the device runs after Reset, including when it is first powered up.",
    "7.1 Overview\nIf an external clock source is selected, the FEXTOSC bits of Configuration Word 1 must be used in conjunction with the RSTOSC  bits  to  select the External Clock mode.\nThe external oscillator module can be configured in one of the following clock modes, by setting the FEXTOSC<2:0> Configuration bits:\n1. ECL - External Clock Low-Power mode\n2. ECM - External Clock Medium Power mode\n3. ECH - External Clock High-Power mode\n4. LP - 32 kHz Low-Power Crystal mode.\n5. XT - Medium Gain Crystal or Ceramic Resonator Oscillator mode\n6. HS - High Gain Crystal or Ceramic Resonator mode",
    "7.1 Overview\nThe  ECH,  ECM,  and  ECL  Clock  modes  rely  on  an external logic level signal as the device clock source. The LP, XT, and HS Clock modes require an external crystal  or  resonator  to  be  connected  to  the  device. Each mode is optimized for a different frequency range. The  internal  oscillator  block  produces  low  and  highfrequency clock sources, designated LFINTOSC and HFINTOSC. (see Internal Oscillator Block, Figure 7-1). Multiple device clock frequencies may be derived from these clock sources.",
    "7.2 Clock Source Types\nClock sources can be classified as external or internal.\nExternal clock sources rely on external circuitry for the clock  source  to  function.  Examples  are:  oscillator modules  (ECH,  ECM,  ECL  mode),  quartz  crystal resonators  or  ceramic  resonators  (LP,  XT  and  HS modes).\nInternal clock sources are contained within the oscillator module. The internal oscillator block has two internal  oscillators  that  are  used  to  generate  internal system  clock  sources.  The  High-Frequency  Internal Oscillator (HFINTOSC) can produce 1, 2, 4, 8, 12, 16, 32,  48  and  64  MHz  clock.  The  frequency  can  be controlled  through the OSCFRQ register (Register 75). The Low-Frequency Internal Oscillator (LFINTOSC) generates a fixed 31 kHz frequency.\nA 4x PLL is provided that can be used with an external clock.  When used with the EXTOSC the 4x PLL has input  frequency  limitations.  See Section  7.2.1.4 '4x PLL' for more details.",
    "7.2 Clock Source Types\nThe system clock can be selected between external or internal clock sources  via  the NOSC  bits  in  the OSCCON1 register. See Section 7.3 'Clock Switching' for additional  information.  The  system clock can be made available on the OSC2/CLKOUT pin for any of the modes that do not use the OSC2 pin. The clock out functionality is governed by the CLKOUTEN bit in the CONFIG1H register (Register 5-2). If enabled, the clock out signal is always at a frequency of FOSC/4.",
    "7.2.1 EXTERNAL CLOCK SOURCES\nAn external clock source can be used as the device system  clock  by  performing  one  of  the  following actions:\n\u00b7 Program the RSTOSC<2:0> and FEXTOSC<2:0> bits in the Configuration Words to select an external clock source that will be used as the default system clock upon a device Reset.\n\u00b7 Write the NOSC<2:0> and NDIV<3:0> bits in the OSCCON1 register to switch the system clock source.\nSee Section 7.3 'Clock Switching' for more information.",
    "7.2.1.1 EC Mode\nThe  External  Clock  (EC)  mode  allows  an  externally generated  logic  level  signal  to  be  the  system  clock source. When operating in this mode, an external clock source is connected to the OSC1  input. OSC2/ CLKOUT  is  available  for  general  purpose  I/O  or CLKOUT. Figure 7-2 shows the pin connections for EC mode.\nEC mode has three power modes to select from through Configuration Words:\n\u00b7 ECH - High power\n\u00b7 ECM - Medium power\n\u00b7 ECL - Low power\nThe Oscillator Start-up Timer (OST) is disabled when EC mode is selected. Therefore, there is no delay in operation after a Power-on Reset (POR) or wake-up from  Sleep.  Because  the  PIC \u00ae   MCU  design  is  fully static,  stopping the external clock input will have the effect of halting the device while leaving all data intact. Upon  restarting  the  external  clock,  the  device  will resume operation as if no time had elapsed.",
    "7.2.1.2 LP, XT, HS Modes\nThe LP, XT and HS modes support the use of quartz crystal resonators or ceramic resonators connected to OSC1 and OSC2 (Figure 7-3). The three modes select a  low,  medium  or  high  gain  setting  of  the  internal inverter-amplifier  to  support  various  resonator  types and speed.\nLP Oscillator mode selects the lowest gain setting of the internal inverter-amplifier. LP mode current consumption is the least of the three modes. This mode is designed to drive only 32.768 kHz tuning-fork type crystals (watch crystals).\nXT Oscillator mode  selects  the  intermediate  gain setting  of the  internal inverter-amplifier. XT  mode current consumption is the medium of the three modes. This  mode  is  best  suited  to  drive  resonators  with  a medium  drive  level  specification  (above  100 kHz -\n8 MHz).\nHS Oscillator mode selects the highest gain setting of the internal inverter-amplifier. HS mode current consumption is  the  highest  of  the  three  modes.  This  mode  is  best suited  for  resonators  that  require  a  high  drive  setting (above 8 MHz).",
    "7.2.1.2 LP, XT, HS Modes\nFigure 7-3  and  Figure 7-4  show  typical  circuits  for quartz crystal and ceramic resonators, respectively.",
    "QUARTZ CRYSTAL OPERATION (LP, XT OR HS MODE)\nNote 1: A  series  resistor  (RS)  may  be  required  for quartz crystals with low drive level.\n2: The value of RF varies with the Oscillator mode selected (typically between 2 M \uf057 to 10 M \uf057\uf029 .",
    "CERAMIC RESONATOR OPERATION (XT OR HS MODE)\nNote 1: A  series  resistor  (RS)  may  be  required  for ceramic resonators with low drive level.\n2: The value of RF varies with the Oscillator mode selected (typically between 2 M \uf057 to 10 M \uf057\uf029 .\n3: An  additional  parallel  feedback  resistor  (RP) may be required for proper ceramic resonator operation.",
    "7.2.1.3 Oscillator Start-up Timer (OST)\nIf the oscillator module is configured for LP, XT or HS modes,  the  Oscillator  Start-up  Timer  (OST)  counts 1024 oscillations from OSC1. This occurs following a Power-on Reset (POR), or a wake-up from Sleep. The OST ensures that the oscillator circuit, using a quartz crystal resonator or ceramic resonator, has started and is  providing  a  stable  system  clock  to  the  oscillator module.",
    "7.2.1.4 4x PLL\nThe oscillator module contains a 4x PLL that can be used  with  the  external  clock  sources  to  provide  a system clock source. The input frequency for the PLL must  fall  within  specifications.  See  the  PLL  Clock Timing Specifications in Table 45-9.\nThe  PLL  can  be  enabled  for  use  by  one  of  two methods:\n1. Program the RSTOSC bits in the Configuration Word 1 to 010 (enable EXTOSC with 4x PLL).\n2. Write the NOSC bits in the OSCCON1 register to 010 (enable EXTOSC with 4x PLL).",
    "7.2.1.5 Secondary Oscillator\nThe secondary oscillator is a separate oscillator block that can be used as an alternate system clock source. The secondary oscillator is optimized for 32.768 kHz, and can be used with an external crystal oscillator con -nected to the SOSCI and SOSCO device pins, or an external clock source connected to the SOSCIN pin. The secondary oscillator can be selected during runtime using clock switching. Refer to Section 7.3 'Clock Switching' for more information.\nTwo  power  modes  are  available  for  the  secondary oscillator. These modes are selected with the SOSCPWR (OSCCON3<6>). Clearing this bit selects the  lower  Crystal  Gain  mode  which  provides  lowest microcontroller  power  consumption.  Setting  this  bit enables a higher Gain mode to support faster crystal start-up or crystals with higher ESR.",
    "QUARTZ CRYSTAL OPERATION (SECONDARY OSCILLATOR)\nNote 1: Quartz crystal characteristics vary according to type, package and manufacturer. The user should consult the manufacturer data sheets for specifications and recommended application.\n2: Always verify oscillator performance over the  VDD  and  temperature  range  that  is expected for the application.\n3: For oscillator design assistance, reference the following Microchip Application Notes:\n\u00b7 AN826, ' Crystal Oscillator Basics and Crystal Selection for PIC \u00ae and PIC \u00ae Devices ' (DS00826)\n\u00b7 AN849, ' Basic PIC \u00ae Oscillator Design ' (DS00849)\n\u00b7 AN943, ' Practical PIC \u00ae Oscillator Analysis and Design ' (DS00943)\n\u00b7 AN949, ' Making Your Oscillator Work ' (DS00949)\n\u00b7 TB097, ' Interfacing a Micro Crystal MS1V-T1K 32.768 kHz Tuning Fork Crystal to a PIC16F690/SS ' (DS91097)\n\u00b7 AN1288, ' Design Practices for LowPower External Oscillators ' (DS01288)",
    "7.2.2 INTERNAL CLOCK SOURCES\nThe  device  may  be  configured  to  use  the  internal oscillator block as the system clock by performing one of the following actions:\n\u00b7 Program the RSTOSC<2:0> bits in Configuration Words to select the INTOSC clock source, which will be used as the default system clock upon a device Reset.\n\u00b7 Write the NOSC<2:0> bits in the OSCCON1 register to switch the system clock source to the internal oscillator during run-time. See Section 7.3 'Clock Switching' for more information.\nIn INTOSC mode, OSC1/CLKIN is available for general purpose I/O, provided that FEXTOSC is configured to 'oscillator is not enabled'. OSC2/CLKOUT is available for general purpose I/O or CLKOUT.\nThe function of the OSC2/CLKOUT pin is determined by the CLKOUTEN bit in Configuration Words.\nThe  internal  oscillator  block  has  two  independent oscillators that can produce two internal system clock sources.",
    "7.2.2 INTERNAL CLOCK SOURCES\n1. The HFINTOSC (High-Frequency Internal Oscillator)  is  factory-calibrated  and  operates from 1 to 64 MHz. The frequency of HFINTOSC can be selected through the OSCFRQ Frequency  Selection  register,  and  fine-tuning can be done via the OSCTUNE register.\n2. The LFINTOSC (Low-Frequency Internal Oscillator) is factory-calibrated and operates at 31 kHz.",
    "7.2.2.1 HFINTOSC\nThe High-Frequency Internal Oscillator (HFINTOSC) is a  precision  digitally-controlled  internal  clock  source that  produces  a  stable  clock  up  to  64  MHz.  The HFINTOSC  can  be  enabled  through  one  of  the following methods:\n\u00b7 Programming the RSTOSC<2:0> bits in Configuration Word 1 to ' 110 ' (FOSC = 1 MHz) or ' 000 ' (FOSC = 64 MHz) to set the oscillator upon device Power-up or Reset.\n\u00b7 Write to the NOSC<2:0> bits of the OSCCON1 register during run-time. See Section 7.3 'Clock Switching' for more information.\nThe HFINTOSC frequency can be selected by setting the FRQ<3:0> bits of the OSCFRQ register.\nThe NDIV<3:0> bits of the OSCCON1 register allow for division of the HFINTOSC output from a range between 1:1 and 1:512.",
    "7.2.2.2 MFINTOSC\nThe  module  provides  two  (500  kHz  and  31.25  kHz) constant clock outputs. These clocks are digital divisors of the HFINTOSC clock. Dynamic divider logic is used to provide constant MFINTOSC clock rates for all settings of HFINTOSC.\nThe MFINTOSC cannot be used to drive the system but  it  is  used  to  clock  certain  modules  such  as  the Timers and WWDT.",
    "7.2.2.3 Internal Oscillator Frequency Adjustment\nThe internal oscillator is factory-calibrated. This internal oscillator can be adjusted in software by writing to the OSCTUNE register (Register 7-3).\nThe default value of the OSCTUNE register is 00h. The value is a 6-bit two's complement number. A value of 1Fh  will provide an  adjustment  to the maximum frequency. A value of 20h will provide an adjustment to the minimum frequency.\nWhen the OSCTUNE register is modified, the oscillator frequency will begin shifting to the new frequency. Code execution  continues  during this shift. There  is no indication that the shift has occurred.\nOSCTUNE does not affect the LFINTOSC frequency. Operation  of  features  that  depend  on  the  LFINTOSC clock  source  frequency,  such  as  the  Power-up  Timer (PWRT), WWDT, Fail-Safe Clock Monitor (FSCM) and peripherals, are not affected by the change in frequency.",
    "7.2.2.4 LFINTOSC\nThe Low-Frequency Internal Oscillator (LFINTOSC) is a factory-calibrated 31 kHz internal clock source.\nThe LFINTOSC is the frequency for the Power-up Timer (PWRT), Windowed Watchdog Timer (WWDT) and FailSafe Clock Monitor (FSCM).\nThe LFINTOSC is enabled through one of the following methods:\n\u00b7 Programming the RSTOSC<2:0> bits of Configuration Word 1 to enable LFINTOSC.\n\u00b7 Write to the NOSC<2:0> bits of the OSCCON1 register during run-time. See Section 7.3, Clock Switching for more information.",
    "7.2.2.5 ADCRC\nThe ADCRC  is  an  oscillator  dedicated  to  the ADC 2 module.  The  ADCRC  oscillator can be manually enabled using the ADOEN bit of the OSCEN register. The ADCRC  runs  at  a  fixed  frequency  of  600  kHz. ADCRC is automatically enabled if it is selected as the clock source for the ADC 2 module.",
    "7.2.2.6 Oscillator Status and Manual Enable\nThe  Ready  status  of  each  oscillator  (including  the ADCRC oscillator) is displayed in OSCSTAT (Register 7-4). The oscillators (but not the PLL) may be explicitly enabled through OSCEN (Register 7-7).",
    "7.2.2.7 HFOR and MFOR Bits\nThe HFOR and MFOR bits indicate that the HFINTOSC and  MFINTOSC  is  ready.  These  clocks  are  always valid for use at all times, but only accurate after they are ready.\nWhen a new value is loaded into the OSCFRQ register, the  HFOR  and  MFOR  bits  will  clear,  and  set  again when the oscillator is ready. During pending OSCFRQ changes the MFINTOSC clock will stall at a high or a low state, until the HFINTOSC resumes operation.",
    "7.3 Clock Switching\nThe  system  clock  source  can  be  switched  between external and internal clock sources via software using the New Oscillator Source (NOSC) bits of the OSCCON1 register. The following clock sources can be selected using the following:\n\u00b7 External oscillator\n\u00b7 Internal Oscillator Block (INTOSC)\nNote:\nThe Clock Switch Enable bit in Configuration  Word  1  can  be  used  to enable  or  disable  the  clock switching capability. When cleared, the NOSC and NDIV  bits  cannot  be  changed  by  user software. When set, writing to NOSC and NDIV  is  allowed  and  would  switch  the clock frequency.",
    "7.3.1 NEW OSCILLATOR SOURCE (NOSC) AND NEW DIVIDER SELECTION REQUEST (NDIV) BITS\nThe New Oscillator Source (NOSC) and New Divider Selection Request  (NDIV) bits of the OSCCON1 register select the system clock source and frequency that are used for the CPU and peripherals.\nWhen new values of NOSC and NDIV are written to OSCCON1, the current oscillator selection will continue  to  operate  while  waiting  for  the  new  clock source to indicate that it is stable and ready. In some cases, the newly requested source may already be in use, and is ready immediately. In the case of a divideronly change, the new and old sources are the same, so the old source will be ready immediately. The device may  enter  Sleep  while  waiting  for  the  switch  as described in Section 7.3.2 'Clock Switch and Sleep' .",
    "7.3.1 NEW OSCILLATOR SOURCE (NOSC) AND NEW DIVIDER SELECTION REQUEST (NDIV) BITS\nWhen the new oscillator is ready, the New Oscillator Ready  (NOSCR)  bit  of  OSCCON3  and  the  Clock Switch Interrupt Flag (CSWIF) bit of the respective PIR register are set. If Clock Switch Interrupts are enabled (CSWIE = 1 ), an interrupt will be generated at that time. The  Oscillator  Ready  (ORDY)  bit  of  OSCCON3  can also be polled to determine when the oscillator is ready in lieu of an interrupt.\nNote:\nThe  CSWIF  interrupt  will  not  wake  the system from Sleep.\nIf the Clock Switch Hold (CSWHOLD) bit of OSCCON3 is clear, the oscillator switch will occur when the New Oscillator is Ready  bit  (NOSCR)  is  set,  and  the interrupt  (if enabled)  will  be  serviced  at  the  new oscillator setting.\nIf CSWHOLD is set, the oscillator switch is suspended, while execution continues using the current (old) clock source. When the NOSCR bit is set, software should:",
    "7.3.1 NEW OSCILLATOR SOURCE (NOSC) AND NEW DIVIDER SELECTION REQUEST (NDIV) BITS\n\u00b7 Set CSWHOLD = 0 so the switch can complete, or\n\u00b7 Copy COSC into NOSC to abandon the switch.\nIf DOZE is in effect, the switch occurs on the next clock cycle, whether or not the CPU is operating during that cycle.\nChanging the clock post-divider without changing the clock  source  (i.e.,  changing  FOSC  from  1 MHz  to 2 MHz)  is  handled  in  the  same  manner  as  a  clock source  change,  as  described  previously.  The  clock source will already be active, so the switch is relatively quick. CSWHOLD must be clear (CSWHOLD = 0 ) for the switch to complete.\nThe  current  COSC  and  CDIV  are  indicated  in  the OSCCON2 register up to the moment when the switch actually occurs, at which time OSCCON2 is updated and ORDY is set. NOSCR is cleared by hardware to indicate that the switch is complete.",
    "7.3.2 CLOCK SWITCH AND SLEEP\nIf OSCCON1 is written with a new value and the device is put to Sleep before the switch completes, the switch will  not  take  place  and  the  device  will  enter  Sleep mode.\nWhen the device wakes from Sleep and the CSWHOLD bit is clear, the device will wake with the 'new' clock active, and the Clock Switch Interrupt flag bit (CSWIF) will be set.\nWhen the device wakes from Sleep and the CSWHOLD bit is set, the device will wake with the 'old' clock active and the new clock will be requested again.",
    "FIGURE 7-6: CLOCK SWITCH (CSWHOLD =  ) 0\nNote 1: CSWIF is asserted coincident with NOSCR; interrupt is serviced at OSC#2 speed.\n- 2: The assertion of NOSCR is hidden from the user because it appears only for the duration of the switch.",
    "FIGURE 7-8: CLOCK SWITCH ABANDONED\nNote 1: CSWIF may be cleared before or after rewriting OSCCON1; CSWIF is not automatically cleared.\n2: ORDY = 0 if OSCCON1 does not match OSCCON2; a new switch will begin.",
    "7.4 Fail-Safe Clock Monitor\nThe Fail-Safe Clock Monitor (FSCM) allows the device to continue operating should the external oscillator fail. The FSCM is enabled by setting the FCMEN bit in the Configuration  Words.  The  FSCM  is  applicable  to  all external Oscillator modes (LP, XT, HS, ECL/M/H and Secondary Oscillator).",
    "7.4.1 FAIL-SAFE DETECTION\nThe  FSCM  module  detects  a  failed  oscillator  by comparing the external oscillator to the FSCM sample clock. The sample clock is generated by dividing the LFINTOSC  by  64.  See  Figure 7-9.  Inside  the  fail detector block is a latch. The external clock sets the latch  on  each  falling  edge  of  the  external  clock. The sample clock clears the latch on each rising edge of the sample clock. A failure is detected when an entire halfcycle of the sample clock elapses before the external clock goes low.",
    "7.4.2 FAIL-SAFE OPERATION\nWhen the external clock fails, the FSCM overwrites the COSC  bits to select HFINTOSC  ( 3'b110 ). The frequency of HFINTOSC would be determined by the previous state of the FRQ bits and the NDIV/CDIV bits. The bit flag OSFIF of the respective PIR register is set. Setting this flag will generate an interrupt if the OSFIE bit of the respective PIR register is also set. The device firmware can then take steps to mitigate the problems that may arise from a failed clock. The system clock will continue to be sourced from the internal clock source until the  device  firmware  successfully  restarts  the external oscillator and  switches back  to external operation, by writing to the NOSC and NDIV bits of the OSCCON1 register.",
    "7.4.3 FAIL-SAFE CONDITION CLEARING\nThe  Fail-Safe  condition  is  cleared  after  a  Reset, executing a SLEEP instruction or changing the NOSC and  NDIV  bits of the OSCCON1  register.  When switching to the external oscillator or PLL, the OST is restarted. While the OST  is  running, the device continues  to  operate  from  the  INTOSC  selected  in OSCCON1.  When  the  OST  times  out,  the  Fail-Safe condition is cleared after successfully switching to the external  clock  source.  The  OSCFIF  bit  should  be cleared prior to switching to the external clock source. If  the  Fail-Safe condition still exists, the OSCFIF flag will again become set by hardware.",
    "7.4.4 RESET OR WAKE-UP FROM SLEEP\nThe FSCM is designed to detect an oscillator failure after the Oscillator Start-up Timer (OST) has expired. The OST is used after waking up from Sleep and after any type of Reset. The OST is not used with the EC Clock modes so that the FSCM will be active as soon as the Reset or wake-up has completed.",
    "TABLE 7-1: NOSC/COSC AND NDIV/CDIV BIT SETTINGS\n111, Clock Source = EXTOSC (1). 110, Clock Source = HFINTOSC (2). 101, Clock Source = LFINTOSC. 100, Clock Source = SOSC. 011, Clock Source = Reserved. 010, Clock Source = EXTOSC + 4x PLL (3). 001, Clock Source = Reserved. 000, Clock Source = Reserved\n1111-1010, Clock Divider = Reserved. 1001, Clock Divider = 512. 1000, Clock Divider = 256. 0111, Clock Divider = 128. 0110, Clock Divider = 64. 0101, Clock Divider = 32. 0100, Clock Divider = 16. 0011, Clock Divider = 8. 0010, Clock Divider = 4. 0001, Clock Divider = 2. 0000, Clock Divider = 1",
    "TABLE 7-1: NOSC/COSC AND NDIV/CDIV BIT SETTINGS\nNote 1: EXTOSC configured by the FEXTOSC bits of Configuration Word 1 (Register 5-1).\n2: HFINTOSC frequency is set with the FRQ bits of the OSCFRQ register (Register 7-5).\n3: EXTOSC must meet the PLL specifications (Table 45-9).",
    "REGISTER 7-1: OSCCON1: OSCILLATOR CONTROL REGISTER 1\n-, R/W-f/f = NOSC<2:0>. -, R/W-f/f = NOSC<2:0>. -, R/W-f/f = NOSC<2:0>. -, R/W-q/q = NDIV<3:0>. -, R/W-q/q = NDIV<3:0>. -, R/W-q/q = NDIV<3:0>. -, R/W-q/q = NDIV<3:0>. bit 7 bit 0, R/W-f/f = bit 7 bit 0. bit 7 bit 0, R/W-f/f = bit 7 bit 0. bit 7 bit 0, R/W-f/f = bit 7 bit 0. bit 7 bit 0, R/W-q/q = bit 7 bit 0. bit 7 bit 0, R/W-q/q = bit 7 bit 0. bit 7 bit 0, R/W-q/q = bit 7 bit 0. bit",
    "REGISTER 7-1: OSCCON1: OSCILLATOR CONTROL REGISTER 1\n7 bit 0, R/W-q/q = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit u = Bit is '1' = Bit is set, 1 = W=Writable bit. R = Readable bit u = Bit is '1' = Bit is set, 2 = U = Unimplemented bit, read as '0'. unchanged, 1 = x = Bit is unknown. unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. , 1 = '0' = Bit is cleared. , 2 = f = determined by Configuration bit setting q = Reset value is determined by hardware",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6-4\nNOSC<2:0>: New Oscillator Source Request bits (1,2,3)\nThe setting requests a source oscillator and PLL combination per Table 7-1.\nPOR value = RSTOSC (Register 5-1).\nbit 3-0\nNDIV<3:0>:\nNew Divider Selection Request bits (2,3)\nThe setting determines the new postscaler division ratio per Table 7-1.\nNote1:\nThe default value (f/f) is determined by the RSTOSC Configuration bits. See Table 7-2 below.\n2: If NOSC is written with a reserved value (Table 7-1), the operation is ignored and neither NOSC nor NDIV is written.\n3: When CSWEN = 0 , this register is read-only and cannot be changed from the POR value.",
    "TABLE 7-2: DEFAULT OSCILLATOR SETTINGS\n111, SFR Reset Values.NOSC/COSC = 111. 111, SFR Reset Values.CDIV = 1:1. 111, SFR Reset Values.OSCFRQ = 4 MHz. 111, Initial FOSC Frequency.Initial FOSC Frequency = EXTOSC per FEXTOSC. 110, SFR Reset Values.NOSC/COSC = 110. 110, SFR Reset Values.CDIV = 4:1. 110, SFR Reset Values.OSCFRQ = 4 MHz. 110, Initial FOSC Frequency.Initial FOSC Frequency = FOSC = 1 MHz (4 MHz/4). 101, SFR Reset Values.NOSC/COSC = 101. 101, SFR Reset Values.CDIV = 1:1. 101, SFR Reset Values.OSCFRQ = 4 MHz. 101, Initial FOSC Frequency.Initial FOSC Frequency = LFINTOSC. 100, SFR Reset Values.NOSC/COSC = 100. 100, SFR Reset Values.CDIV = 1:1. 100, SFR Reset Values.OSCFRQ = 4 MHz.",
    "TABLE 7-2: DEFAULT OSCILLATOR SETTINGS\n100, Initial FOSC Frequency.Initial FOSC Frequency = SOSC. 011, SFR Reset Values.NOSC/COSC = Reserved. 011, SFR Reset Values.CDIV = Reserved. 011, SFR Reset Values.OSCFRQ = Reserved. 011, Initial FOSC Frequency.Initial FOSC Frequency = Reserved. 010, SFR Reset Values.NOSC/COSC = 010. 010, SFR Reset Values.CDIV = 1:1. 010, SFR Reset Values.OSCFRQ = 4 MHz. 010, Initial FOSC Frequency.Initial FOSC Frequency = EXTOSC + 4xPLL (1). 001, SFR Reset Values.NOSC/COSC = Reserved. 001, SFR Reset Values.CDIV = Reserved. 001, SFR Reset Values.OSCFRQ = Reserved. 001, Initial FOSC Frequency.Initial FOSC Frequency = Reserved. 000, SFR Reset Values.NOSC/COSC = 110. 000, SFR Reset Values.CDIV = 1:1. 000, SFR Reset",
    "TABLE 7-2: DEFAULT OSCILLATOR SETTINGS\nValues.OSCFRQ = 64 MHz. 000, Initial FOSC Frequency.Initial FOSC Frequency = FOSC = 64 MHZ\nNote 1: EXTOSC must meet the PLL specifications (Table 45-9).",
    "PIC18(L)F25/26K83\nREGISTER 7-2:",
    "OSCCON2: OSCILLATOR CONTROL REGISTER 2\n-, R-f/f = COSC<2:0>. -, R-f/f = COSC<2:0>. -, R-f/f = COSC<2:0>. -, R-f/f = CDIV<3:0>. -, R-f/f = CDIV<3:0>. -, R-f/f = CDIV<3:0>. -, R-f/f = CDIV<3:0>. bit 7 bit 0, R-f/f = bit 7 bit 0. bit 7 bit 0, R-f/f = bit 7 bit 0. bit 7 bit 0, R-f/f = bit 7 bit 0. bit 7 bit 0, R-f/f = bit 7 bit 0. bit 7 bit 0, R-f/f = bit 7 bit 0. bit 7 bit 0, R-f/f = bit 7 bit 0. bit 7 bit 0, R-f/f = bit 7 bit 0",
    "OSCCON2: OSCILLATOR CONTROL REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = \nbit 7\nUnimplemented: Read as ' 0 '\nbit 6-4\nCOSC<2:0>: Current Oscillator Source Select bits (read-only) (1)\nIndicates the current source oscillator and PLL combination per Table 7-1.\nbit 3-0\nCDIV<3:0>: Current Divider Select bits (read-only) (1)\nIndicates the current postscaler division ratio per Table 7-1.\nNote1: The POR value is the value present when user code execution begins.",
    "REGISTER 7-3: OSCCON3: OSCILLATOR CONTROL REGISTER 3\nR/W/HC-0/0, 1 = R/W-0/0. R/W/HC-0/0, 2 = U-0. R/W/HC-0/0, 3 = R-0/0. R/W/HC-0/0, 4 = R-0/0. R/W/HC-0/0, 5 = U-0. R/W/HC-0/0, 6 = U-0. R/W/HC-0/0, 7 = U-0. CSWHOLD, 1 = SOSCPWR. CSWHOLD, 2 = -. CSWHOLD, 3 = ORDY. CSWHOLD, 4 = NOSCR. CSWHOLD, 5 = -. CSWHOLD, 6 = -. CSWHOLD, 7 = -. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 7-3: OSCCON3: OSCILLATOR CONTROL REGISTER 3\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HC = Bit is cleared by hardware",
    "bit 7\nCSWHOLD: Clock Switch Hold bit\n1 = Clock switch will hold (with interrupt) when the oscillator selected by NOSC is ready\n0 = Clock switch may proceed when the oscillator selected by NOSC is ready; NOSCR\nbecomes ' 1 ', the switch will occur\nbit 6\nSOSCPWR: Secondary Oscillator Power Mode Select bit\n1 = Secondary oscillator operating in High-Power mode\n0 = Secondary oscillator operating in Low-Power mode\nbit 5\nUnimplemented: Read as ' 0 '\nbit 4\nORDY: Oscillator Ready bit (read-only)\n1 = OSCCON1 = OSCCON2; the current system clock is the clock specified by NOSC\n0 = A clock switch is in progress\nbit 3\nNOSCR: New Oscillator is Ready bit (read-only) (1)\n1 = A clock switch is in progress and the oscillator selected by NOSC indicates a 'ready' condition\n0 = A clock switch is not in progress, or the NOSC-selected oscillator is not yet ready",
    "bit 2-0 Unimplemented: Read as ' 0 '\nNote 1: If CSWHOLD = 0 , the user may not see this bit set because, when the oscillator becomes ready there may be a delay of one instruction clock before this bit is set. The clock switch occurs in the next instruction cycle and this bit is cleared.",
    "REGISTER 7-4: OSCSTAT: OSCILLATOR STATUS REGISTER 1\nEXTOR, R-q/q = HFOR. EXTOR, R-q/q = MFOR. EXTOR, R-q/q = LFOR. EXTOR, R-q/q = SOR. EXTOR, R-q/q = ADOR. EXTOR, U-0 = -. EXTOR, R-q/q = PLLR. bit 7 bit 0, R-q/q = bit 7 bit 0. bit 7 bit 0, R-q/q = bit 7 bit 0. bit 7 bit 0, R-q/q = bit 7 bit 0. bit 7 bit 0, R-q/q = bit 7 bit 0. bit 7 bit 0, R-q/q = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R-q/q = bit 7 bit 0",
    "REGISTER 7-4: OSCSTAT: OSCILLATOR STATUS REGISTER 1\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = q = Reset value is determined by hardware",
    "bit 7\nEXTOR: EXTOSC (external) Oscillator Ready bit\n1 = The oscillator is ready to be used\n0 = The oscillator is not enabled, or is not yet ready to be used",
    "bit 6\nHFOR: HFINTOSC Oscillator Ready bit\n1 = The oscillator is ready to be used\n0 = The oscillator is not enabled, or is not yet ready to be used",
    "bit 5\nMFOR: MFINTOSC Oscillator Ready bit\n1 = The oscillator is ready to be used\n0 = The oscillator is not enabled, or is not yet ready to be used",
    "bit 4\nLFOR: LFINTOSC Oscillator Ready bit\n1 = The oscillator is ready to be used\n0 =   The oscillator is not enabled, or is not yet ready to be used",
    "SOR: Secondary (Timer1) Oscillator Ready bit\n1 = The oscillator is ready to be used\n0 =    The oscillator is not enabled, or is not yet ready to be used",
    "bit 2\nADOR: ADC Oscillator Ready bit\n1 = The oscillator is ready to be used\n0 =    The oscillator is not enabled, or is not yet ready to be used",
    "bit 1\nUnimplemented: Read as ' 0 '",
    "bit 0\nPLLR: PLL is Ready bit\n1 = The PLL is ready to be used\n0 = The PLL is not enabled, the required input source is not ready, or the PLL is not locked.",
    "REGISTER 7-5: OSCFRQ: HFINTOSC FREQUENCY SELECTION REGISTER\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-q/q = . -, R/W-q/q = FRQ<3:0>. -, R/W-q/q = . -, R/W-q/q = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-q/q = bit 7. bit 7, R/W-q/q = bit 7. bit 7, R/W-q/q = bit 7. bit 7, R/W-q/q = bit 0",
    "REGISTER 7-5: OSCFRQ: HFINTOSC FREQUENCY SELECTION REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = q = Reset value is determined by hardware",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3-0 FRQ<3:0>: HFINTOSC Frequency Selection bits (1)\nNote 1: Refer to Table 7-2 for more information.\n\n1001, Nominal Freq (MHz) = . 1010, Nominal Freq (MHz) = . 1111, Nominal Freq (MHz) = . 1110, Nominal Freq (MHz) = Reserved. 1101, Nominal Freq (MHz) = . 1100, Nominal Freq (MHz) = . 1011, Nominal Freq (MHz) = . 1000, Nominal Freq (MHz) = 64. 0111, Nominal Freq (MHz) = 48. 0110, Nominal Freq (MHz) = 32. 0101, Nominal Freq (MHz) = 16. 0100, Nominal Freq (MHz) = 12. 0011, Nominal Freq (MHz) = 8. 0010, Nominal Freq (MHz) = 4. 0001, Nominal Freq (MHz) = 2. 0000, Nominal Freq (MHz) = 1",
    "REGISTER 7-6: OSCTUNE: HFINTOSC TUNING REGISTER\n-, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = TUN<5:0>. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 7-6: OSCTUNE: HFINTOSC TUNING REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = \nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-0\nTUN<5:0>: HFINTOSC Frequency Tuning bits\n01 1111 = Maximum frequency\n\u2022\n\u2022\n\u2022\n00 0000 = Center frequency. Oscillator module is running at the calibrated frequency (default value).\n\u2022\n\u2022\n\u2022\n10 0000 = Minimum frequency",
    "REGISTER 7-7: OSCEN: OSCILLATOR MANUAL ENABLE REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = U-0. R/W-0/0, 7 = U-0. EXTOEN, 1 = HFOEN. EXTOEN, 2 = MFOEN. EXTOEN, 3 = LFOEN. EXTOEN, 4 = SOSCEN. EXTOEN, 5 = ADOEN. EXTOEN, 6 = -. EXTOEN, 7 = -",
    "REGISTER 7-7: OSCEN: OSCILLATOR MANUAL ENABLE REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7\nEXTOEN: External Oscillator Manual Request Enable bit\n1 = EXTOSC is explicitly enabled, operating as specified by FEXTOSC\n0 = EXTOSC could be enabled by requesting peripheral\nbit 6\nHFOEN: HFINTOSC Oscillator Manual Request Enable bit\n1 = HFINTOSC is explicitly enabled, operating as specified by OSCFRQ (Register 7-5)\n0 = HFINTOSC could be enabled by requesting peripheral\nbit 5\nMFOEN: MFINTOSC  (500 kHz/31.25 kHz)  Oscillator  Manual  Request  Enable  bit  (Derived  from HFINTOSC)\n1 = MFINTOSC is explicitly enabled\n0 = MFINTOSC could be enabled by requesting peripheral",
    "bit 4\nLFOEN: LFINTOSC (31 kHz) Oscillator Manual Request Enable bit\n1 = LFINTOSC is explicitly enabled\n0 = LFINTOSC could be enabled by requesting peripheral",
    "bit 3\nSOSCEN: Secondary Oscillator Manual Request Enable bit\n1 = Secondary Oscillator is explicitly enabled, operating as specified by SOSCPWR\n0 = Secondary Oscillator could be enabled by requesting peripheral",
    "bit 2\nADOEN: ADC Oscillator Manual Request Enable bit\n1 = ADC oscillator is explicitly enabled\n0 = ADC oscillator could be enabled by requesting peripheral\nbit 1-0\nUnimplemented: Read as ' 0 '",
    "TABLE 7-3: SUMMARY OF REGISTERS ASSOCIATED WITH CLOCK SOURCES\nOSCCON1, Bit 7 = -. OSCCON1, Bit 6 = NOSC<2:0>. OSCCON1, Bit 5 = NOSC<2:0>. OSCCON1, Bit 4 = NOSC<2:0>. OSCCON1, Bit 3 = NDIV<3:0>. OSCCON1, Bit 2 = NDIV<3:0>. OSCCON1, Bit 1 = NDIV<3:0>. OSCCON1, Bit 0 = NDIV<3:0>. OSCCON1, Register on Page = 94. OSCCON2, Bit 7 = -. OSCCON2, Bit 6 = COSC<2:0>. OSCCON2, Bit 5 = COSC<2:0>. OSCCON2, Bit 4 = COSC<2:0>. OSCCON2, Bit 3 = CDIV<3:0>. OSCCON2, Bit 2 = CDIV<3:0>. OSCCON2, Bit 1 = CDIV<3:0>.",
    "TABLE 7-3: SUMMARY OF REGISTERS ASSOCIATED WITH CLOCK SOURCES\nOSCCON2, Bit 0 = CDIV<3:0>. OSCCON2, Register on Page = 95. OSCCON3, Bit 7 = CSWHOLD. OSCCON3, Bit 6 = SOSCPWR. OSCCON3, Bit 5 = -. OSCCON3, Bit 4 = ORDY. OSCCON3, Bit 3 = NOSCR. OSCCON3, Bit 2 = -. OSCCON3, Bit 1 = -. OSCCON3, Bit 0 = -. OSCCON3, Register on Page = 95. OSCSTAT, Bit 7 = EXTOR. OSCSTAT, Bit 6 = HFOR. OSCSTAT, Bit 5 = MFOR. OSCSTAT, Bit 4 = LFOR. OSCSTAT, Bit 3 = SOR. OSCSTAT, Bit 2 = ADOR. OSCSTAT, Bit 1 = -. OSCSTAT, Bit 0 = PLLR. OSCSTAT, Register on Page = 96. OSCTUNE, Bit 7 = -. OSCTUNE, Bit 6 = -. OSCTUNE, Bit 5 =",
    "TABLE 7-3: SUMMARY OF REGISTERS ASSOCIATED WITH CLOCK SOURCES\nTUN<5:0>. OSCTUNE, Bit 4 = TUN<5:0>. OSCTUNE, Bit 3 = TUN<5:0>. OSCTUNE, Bit 2 = TUN<5:0>. OSCTUNE, Bit 1 = TUN<5:0>. OSCTUNE, Bit 0 = TUN<5:0>. OSCTUNE, Register on Page = 98. OSCFRQ, Bit 7 = -. OSCFRQ, Bit 6 = -. OSCFRQ, Bit 5 = -. OSCFRQ, Bit 4 = -. OSCFRQ, Bit 3 = FRQ<3:0>. OSCFRQ, Bit 2 = FRQ<3:0>. OSCFRQ, Bit 1 = FRQ<3:0>. OSCFRQ, Bit 0 = FRQ<3:0>. OSCFRQ, Register on Page = 97. OSCEN, Bit 7 = EXTOEN. OSCEN, Bit 6 = HFOEN. OSCEN, Bit 5 = MFOEN. OSCEN, Bit 4 = LFOEN.",
    "TABLE 7-3: SUMMARY OF REGISTERS ASSOCIATED WITH CLOCK SOURCES\nOSCEN, Bit 3 = SOSCEN. OSCEN, Bit 2 = ADOEN. OSCEN, Bit 1 = -. OSCEN, Bit 0 = -. OSCEN, Register on Page = 99\nLegend:\n- = unimplemented location, read as ' 0 '. Shaded cells are not used by clock sources.",
    "8.0 REFERENCE CLOCK OUTPUT MODULE\nThe reference clock output module provides the ability to send a clock signal to the clock reference output pin (CLKR). The reference clock output can also be used as  a  signal  for  other  peripherals,  such  as  the  Data Signal Modulator (DSM), Memory Scanner and Timer module.\nThe reference clock output module has the following features:\n\u00b7 Selectable clock source using the CLKRCLK register\n\u00b7 Programmable clock divider\n\u00b7 Selectable duty cycle",
    "8.1 Clock Source\nThe input to the reference clock output can be selected using the CLKRCLK register.",
    "8.1.1 CLOCK SYNCHRONIZATION\nOnce the reference clock enable (EN) is set, the mod -ule is ensured to be glitch-free at start-up.\nWhen the reference clock output is disabled, the output signal will be disabled immediately.\nClock dividers and clock duty cycles can be changed while the module is enabled, but glitches may occur on the  output.  To  avoid  possible  glitches,  clock  dividers and clock duty cycles should be changed only when the CLKREN is clear.",
    "8.2 Programmable Clock Divider\nThe module takes the clock input and divides it based on  the  value  of  the  DIV<2:0>  bits  of  the  CLKRCON register (Register 8-1).\nThe following configurations can be made based on the DIV<2:0> bits:\n\u00b7 Base FOSC value\n\u00b7 FOSC   divided by 2\n\u00b7 FOSC divided by 4\n\u00b7 FOSC   divided by 16\n\u00b7 FOSC divided by 8\n\u00b7 FOSC divided by 32\n\u00b7 FOSC   divided by 128\n\u00b7 FOSC divided by 64\nThe  clock  divider  values  can  be  changed  while  the module  is  enabled;  however,  in  order  to  prevent glitches on the output, the DIV<2:0> bits should only be changed when the module is disabled (EN = 0 ).",
    "8.3 Selectable Duty Cycle\nThe DC<1:0> bits  of  the  CLKRCON  register  can  be used to modify the duty cycle of the output clock. A duty cycle of 25%, 50%, or 75% can be selected for all clock rates, with the exception of the undivided base FOSC value.\nThe duty  cycle  can  be  changed  while  the  module  is enabled; however, in order to prevent glitches on the output, the DC<1:0> bits should only be changed when the module is disabled (EN = 0 ).\nNote:\nThe DC1 bit is reset to ' 1 '. This makes the default duty cycle 50% and not 0%.",
    "8.4 Operation in Sleep Mode\nThe reference clock output module clock is based on the system clock. When the device goes to Sleep, the module outputs will remain in their current state. This will have  a  direct  effect  on  peripherals  using  the reference clock output as an input signal. No change should  occur  in  the  module  from  entering  or  exiting from Sleep.",
    "8.5 Register Definitions: Reference Clock\nLong bit name prefixes for the Reference Clock periph -erals are shown below. Refer to Section 1.3.2.2 'Long Bit Names' for more information.\nCLKR, Bit Name Prefix = CLKR",
    "REGISTER 8-1: CLKRCON: REFERENCE CLOCK CONTROL REGISTER\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = U-0. R/W-0/0, 3 = R/W-1/1. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. EN, 1 = -. EN, 2 = -. EN, 3 = DC<1:0>. EN, 4 = . EN, 5 = . EN, 6 = DIV<2:0>. EN, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 8-1: CLKRCON: REFERENCE CLOCK CONTROL REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7\nEN: Reference Clock Module Enable bit\n1 = Reference clock module enabled\n0 = Reference clock module is disabled\nbit 6-5\nUnimplemented: Read as ' 0 '\nbit 4-3\nDC<1:0>: Reference Clock Duty Cycle bits (1)\n11 = Clock outputs duty cycle of 75%\n10 = Clock outputs duty cycle of 50%\n01 = Clock outputs duty cycle of 25%\n00 = Clock outputs duty cycle of 0%",
    "bit 2-0 DIV<2:0>: Reference Clock Divider bits\n111 = Base clock value divided by 128\n110 = Base clock value divided by 64\n101 = Base clock value divided by 32\n100 = Base clock value divided by 16\n011 = Base clock value divided by 8\n010 = Base clock value divided by 4\n001 = Base clock value divided by 2\n000 = Base clock value\nNote 1: Bits are valid for reference clock divider values of two or larger, the base clock cannot be further divided.",
    "CLKRCLK: CLOCK REFERENCE CLOCK SELECTION MUX\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = . -, 5 = CLK<3:0>. -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7-4 Unimplemented: Read as ' 0 '\nbit 3-0\nCLK<3:0>: CLKR Clock Selection bits\n1111 = Reserved\n\uf0b7\n\uf0b7\n\uf0b7\n1011 = Reserved\n1010 = CLC4 Output\n1001 = CLC3 Output\n1000 = CLC2 Output\n0111 = CLC1 Output\n0110 = NCO1 Output\n0101 = SOSC\n0100 = MFINTOSC (31.25 kHz)\n0011 = MFINTOSC (500 kHz)\n0010 = LFINTOSC (31 kHz)\n0001 = HFINTOSC\n0000 = FOSC",
    "TABLE 8-1: SUMMARY OF REGISTERS ASSOCIATED WITH CLOCK REFERENCE OUTPUT\nCLKRCON, Bit 7 = EN. CLKRCON, Bit 6 = -. CLKRCON, Bit 5 = -. CLKRCON, Bit 4 = DC<1:0>. CLKRCON, Bit 3 = DC<1:0>. CLKRCON, Bit 2 = DIV<2:0>. CLKRCON, Bit 1 = DIV<2:0>. CLKRCON, Bit 0 = DIV<2:0>. CLKRCON, Register on Page = 103. CLKRCLK, Bit 7 = -. CLKRCLK, Bit 6 = -. CLKRCLK, Bit 5 = -. CLKRCLK, Bit 4 = -. CLKRCLK, Bit 3 = -. CLKRCLK, Bit 2 = CLK<2:0>. CLKRCLK, Bit 1 = CLK<2:0>. CLKRCLK, Bit 0 = CLK<2:0>. CLKRCLK, Register on Page = 104\nLegend:",
    "TABLE 8-1: SUMMARY OF REGISTERS ASSOCIATED WITH CLOCK REFERENCE OUTPUT\n- = unimplemented, read as ' 0 '. Shaded cells are not used by the CLKR module.",
    "9.0 INTERRUPT CONTROLLER\nThe vectored interrupt controller module reduces the numerous  peripheral  interrupt  request  signals  to  a single interrupt request signal to the CPU. This module includes the following major features:\n\u00b7 Interrupt Vector Table (IVT) with a unique vector for each interrupt source\n\u00b7 Fixed and ensured interrupt latency\n\u00b7 Programmable base address for Interrupt Vector Table (IVT) with lock\n\u00b7 Two user-selectable priority levels - High priority and Low priority\n\u00b7 Two levels of context saving\n\u00b7 Interrupt state Status bits to indicate the current execution status of the CPU\nThe  interrupt  controller  module  assembles  all  of  the interrupt  request  signals  and  resolves  the  interrupts based on both a fixed natural order priority (i.e., deter -mined  by  the  Interrupt  Vector  Table),  and  a  userassigned priority  (i.e.,  determined  by  the  IPRx  regis -ters), thereby eliminating scanning of interrupt sources.",
    "9.1 Interrupt Control and Status Registers\nThe  devices  in  this  family  implement  the  following registers for the interrupt controller:\n\u00b7 INTCON0, INTCON1 Control Registers\n\u00b7 PIRx - Peripheral Interrupt Status Registers\n\u00b7 PIEx - Peripheral Interrupt Enable Registers\n\u00b7 IPRx - Peripheral Interrupt Priority Registers\n\u00b7 IVTBASE<20:0> Address Registers\n\u00b7 IVTLOCK Register\nGlobal interrupt control functions and external interrupts  are  controlled  from  the  INTCON0  register. The INTCON1 register contains the status flags for the Interrupt controller.\nThe PIRx registers contain all of the interrupt request flags. Each source of interrupt has a Status bit, which is set by the respective peripherals or an external signal and is cleared via software.\nThe PIEx registers contain all of the interrupt enable bits. These control bits are used to individually enable interrupts from the peripherals or external signals.\nThe IPRx registers are used to set the Interrupt Priority Level for each source of interrupt. Each user interrupt source can be assigned to either a high or low priority.\nThe  IVTBASE  register  is  user  programmable  and  is used  to  determine  the  start  address  of  the  Interrupt Vector  Table  and  the  IVTLOCK  register  is  used  to prevent any unintended writes to the IVTBASE register.",
    "9.1 Interrupt Control and Status Registers\nThere are two other Configuration bits that control the way the interrupt controller can be configured.\n\u00b7 CONFIG2L<3>, MVECEN bit\n\u00b7 CONFIG2L<4>, IVT1WAY bit\nThe  MVECEN  bit  in  CONFIG2L  determines  whether the  Vector  table  is  used  to  determine  the  interrupt priorities.\n- \u00b7 When the IVT1WAY determines the number of times the IVTLOCKED bit can be cleared and set after a device Reset. See Section 9.2.3 'Interrupt Vector Table (IVT) address cal -culation' for details.",
    "9.2 Interrupt Vector Table (IVT)\nThe  interrupt  controller  supports  an  Interrupt  Vector Table (IVT) that contains the vector address location for each interrupt request source.\nThe  Interrupt  Vector  Table  (IVT)  resides  in  program memory, starting at address location determined by the IVTBASE registers; refer to Registers 9-33 through 935  for  details.  The  IVT  contains  68  vectors,  one  for each source of interrupt. Each interrupt vector location contains the starting address of the associated Interrupt Service Routine (ISR).\nThe MVECEN bit in Configuration Word 2L controls the availability of the vector table.",
    "9.2.1 INTERRUPT VECTOR TABLE BASE ADDRESS (IVTBASE)\nThe start address of the vector table is user programmable  through  the  IVTBASE  registers.  The user must ensure the start address is such that it can encompass the entire vector table inside the program memory.\nEach vector address is a 16-bit word (or two address locations on PIC18 devices). So for n interrupt sources, there are 2n address locations necessary to hold the table starting from IVTBASE as the first location. So the staring  address  of  IVTBASE  should  be  chosen  such that  the  address  range  form  IVTBASE  to  (IVTBASE +2n-1) can be encompassed inside the program flash memory.\nFor example, the PIC18F26K83 devices have the high -est vector number: 81. So IVTBASE should be chosen such that (IVTBASE + 0xA1) is less than the last mem -ory location in program flash memory.\nA programmable vector table base address is useful in situations  to  switch  between  different  sets  of  vector tables,  depending  on  the  application.  It  can  also  be used when the application program needs to update the existing vector table (vector address values).\nNote:",
    "9.2.1 INTERRUPT VECTOR TABLE BASE ADDRESS (IVTBASE)\nIt is required that the user assign an even address to the IVTBASE  register for correct operation.",
    "MVECEN = 0\nWhen MVECEN = 0 ,  the address location pointed by the  IVTBASE  registers  has  a GOTO instruction  for  a high priority interrupt. Similarly, the corresponding low priority  vector  location  also  has  a GOTO instruction, which is executed in case of a low priority interrupt.",
    "MVECEN = 1\nWhen MVECEN = 1 ,  the  value  in  the  vector  table  of each interrupt, points to the address location of the first instruction of the interrupt service routine.\nISR Location = Interrupt Vector Table entry << 2.",
    "MVECEN = 0\nWhen  the  MVECEN  bit  in  Configuration  Word  2L (Register 5-3) is cleared, the address  pointed  by IVTBASE registers is used as the high priority interrupt vector address. The low priority interrupt vector address  is  offset  eight  instruction  words  from  the address in IVTBASE registers.\nFor PIC18 devices the IVTBASE registers default to 00 0008h, the high priority interrupt vector address will be  00  0008h  and  the  low  priority  interrupt  vector address will be 00 0018h.",
    "MVECEN = 1\nEach interrupt has a unique vector number associated with it  as defined in Table 9-2. This vector number is used for calculating the location of the interrupt vector for a particular interrupt source.\nInterrupt Vector  Address  = IVTBASE  +  (2*Vector Number).\nThis calculated Interrupt Vector Address value is stored in  the  IVTAD<20:0>  registers  when  an  interrupt  is received (Registers 9-36 through 9-38).\nUser-assigned  software  priority  assigned  using  the IPRx registers does not affect address calculation and is only used to resolve concurrent interrupts.\nIf for any reason the address of the ISR could not be fetched from the vector table, it will cause the system to reset and clear the memory execution violation flag (MEMV bit)  in  PCON1  register  (Register 6-3).  This occurs due to any one of the following:\n\u00b7 The entry for the interrupt in the vector table lies outside the executable PFM area (SAF area is non-executable when SAFEN = 1 ).\n\u00b7 ISR pointed by the vector table lies outside the executable PFM area (SAF area is non-execut -able when SAFEN = 1 ).",
    "MVECEN = 1\nTABLE 9-1: IVT ADDRESS CALCULATION SUMMARY\n\nMulti-Vector Enable CONFIG 2L register MVECEN bit,  = 0. Multi-Vector Enable CONFIG 2L register MVECEN bit, Interrupt Priority INTCON0 Register, IPEN bit.0 = IVTBASE. Multi-Vector Enable CONFIG 2L register MVECEN bit, Interrupt Priority INTCON0 Register, IPEN bit.1 = High Priority IVTBASE Low Priority. Multi-Vector Enable CONFIG 2L register MVECEN bit,  = 1. Multi-Vector Enable CONFIG 2L register MVECEN bit, Interrupt Priority INTCON0 Register, IPEN bit.0 = IVTBASE + 2*(Vector Number). Multi-Vector Enable CONFIG 2L register MVECEN bit, Interrupt Priority INTCON0 Register, IPEN bit.1 = IVTBASE + 2*(Vector Number)",
    "9.2.4 ACCESS CONTROL FOR IVTBASE REGISTERS\nThe user must follow the sequence shown in Example 9-2 to set the IVTLOCKED bit.\nThe Interrupt controller has an IVTLOCKED bit which can be  set  to  avoid  inadvertent  changes  to  the  IVT -BASE registers contents. Setting and clearing this bit requires  a  special  sequence  as  an  extra  precaution against inadvertent changes.\nTo  allow  writes  to  IVTBASE  registers,  the  interrupts must be disabled (GIEH = 0 ) and the IVTLOCKED bit must be cleared. The user must follow the sequence shown in Example 9-1 to clear the IVTLOCKED bit.",
    "EXAMPLE 9-1: IVT UNLOCK SEQUENCE\n;, 1 = Disable Interrupts: BCF. ;, 1 = Bank to IVTLOCK register IVTLOCK; 55h; sequence, next 4 instructions. ;, 1 = Required MOVWF IVTLOCK; AAh; IVTLOCK;. ; Clear IVTLOCKED bit BCF, 1 = to enable writes IVTLOCK, IVTLOCKED;. ; Enable Interrupts BSF, 1 = INTCON0, GIE;",
    "EXAMPLE 9-2: IVT LOCK SEQUENCE\n;, 1 = Disable Interrupts:. ;, 1 = Required sequence, next 4 instructions IVTLOCK;. ; Set, 1 = MOVLW AAh; MOVWF IVTLOCK; IVTLOCKED bit to enable writes. ; Enable Interrupts BSF, 1 = BSF IVTLOCK, IVTLOCKED; INTCON0, GIE;\nWhen  the  IVT1WAY  Configuration  bit  is  set,  the IVTLOCKED bit can be cleared and set only once after a device Reset. The unlock operation in Example 9-1 will have no effect after the lock sequence in Example 9-2 is used to set the IVTLOCK. Unlocking is inhibited until a system Reset occurs.",
    "9.3 Interrupt Priority\nThe final priority level for any pending source of interrupt is  determined first  by  the  user-assigned  priority  of  that source  in  the  IPRx  register,  then  by  the  natural  order priority  within  the  IVT .  The  sections  below  detail  the operation of Interrupt priorities.",
    "9.3.1 USER (SOFTWARE) PRIORITY\nUser-assigned interrupt  priority  is  enabled  by  setting the  IPEN bit  in  the  INTCON0  register  (Register 9-1). Each  peripheral  interrupt  source  can  be  assigned  a high  or  low  priority level by  the  user.  The  userassignable interrupt priority control bits for each interrupt are located in the IPRx registers (Registers 923 through 9-32).\nThe  interrupts are serviced based  on  predefined interrupt priority scheme defined below.",
    "9.3.1 USER (SOFTWARE) PRIORITY\n1. Interrupts set by the user as high-priority interrupt have higher precedence of execution. High-priority interrupts will override a low-priority request when:\na) A low priority interrupt has been requested or its request is already pending.\nb) A  low-  and  high-priority  interrupt  are  triggered concurrently, i.e., on the same instruction cycle (1) .\nc) A low-priority interrupt was requested and the corresponding Interrupt Service Routine is currently  executing.  In  this  case,  the  lower priority interrupt routine will complete executing after the high-priority interrupt has been serviced (2) .\n2. Interrupts set by the user as a low priority have the lower priority of execution and are preempted by any high-priority interrupt.\n3. Interrupts defined with the same software priority cannot preempt or interrupt each other. Concurrent pending interrupts with the same user priority are resolved using the natural order priority. (when MVECEN = ON) or in the order the interrupt flag bits are polled in the ISR (when MVECEN = OFF).",
    "9.3.1 USER (SOFTWARE) PRIORITY\nNote 1: When a high priority interrupt preempts a concurrent low priority interrupt, the GIEL bit  may  be  cleared  in  the  high  priority Interrupt Service Routine. If the GIEL bit is  cleared,  the  low  priority  interrupt  will NOT be serviced even if it was originally requested.  The  corresponding  interrupt flag needs to be cleared in user code.\n2: When a high priority interrupt is requested  while  a  low  priority  Interrupt Service Routine is executing, the GIEL bit may be cleared in the high priority Inter -rupt  Service  Routine.  The  pending  low priority  interrupt  will  resume  even  if  the GIEL bit is cleared.",
    "9.3.2 NATURAL ORDER (HARDWARE) PRIORITY\nWhen  more  than  one  interrupt  with  the  same  user specified priority level are requested, the priority conflict is resolved by using a method called 'Natural Order Priority'. Natural order priority is a fixed priority scheme  that  is  based  on  the  Interrupt  Vector  Table. Table 9-2  shows  the  natural  order  priority  and  the interrupt vector number assigned for each source.",
    "TABLE 9-2: INTERRUPT VECTOR PRIORITY TABLE\n0, Interrupt Source = Software Interrupt. 1, Interrupt Source = HLVD. 2, Interrupt Source = OSF. 3, Interrupt Source = CSW. 4, Interrupt Source = NVM. 5, Interrupt Source = SCAN. 6, Interrupt Source = CRC. 7, Interrupt Source = IOC. 8, Interrupt Source = INT0. 9, Interrupt Source = ZCD. 10, Interrupt Source = AD. 11, Interrupt Source = ADT. 12, Interrupt Source = C1. 13, Interrupt Source = SMT1. 14, Interrupt Source = SMT1PRA. 15, Interrupt Source = SMT1PWA. 16, Interrupt Source = DMA1SCNT. 17, Interrupt Source = DMA1DCNT. 18, Interrupt Source = DMA1OR. 19, Interrupt Source = DMA1A. 20, Interrupt Source = SPI1RX. 21, Interrupt Source = SPI1TX. 22, Interrupt Source = SPI1. 23, Interrupt Source = I2C1RX. 24, Interrupt Source = I2C1TX. 25, Interrupt Source = I2C1. 26, Interrupt Source =",
    "TABLE 9-2: INTERRUPT VECTOR PRIORITY TABLE\nI2C1E. 27, Interrupt Source = U1RX. 28, Interrupt Source = U1TX. 29, Interrupt Source = U1E. 30, Interrupt Source = U1. 31, Interrupt Source = TMR0. 32, Interrupt Source = TMR1. 33, Interrupt Source = TMR1G. 34, Interrupt Source = TMR2. 35, Interrupt Source = CCP1. 36, Interrupt Source = NCO. 37, Interrupt Source = CWG1. 38, Interrupt Source = CLC1. 39, Interrupt Source = INT1. 40, Interrupt Source = RXB0IF/FIFOIF. 41, Interrupt Source = RXB1IF/RXBnIF",
    "TABLE 9-2: INTERRUPT VECTOR PRIORITY TABLE\n42, Interrupt Source = TXB0IF. 43, Interrupt Source = TXB1IF. 44, Interrupt Source = TXB2IF/TXBnIF. 45, Interrupt Source = ERRIF. 46, Interrupt Source = WAKIF. 47, Interrupt Source = IRXIF. 48, Interrupt Source = C2. 49, Interrupt Source = SMT2. 50, Interrupt Source = SMT2PRA. 51, Interrupt Source = SMT2PWA. 52, Interrupt Source = DMA2SCNT. 53, Interrupt Source = DMA2DCNT. 54, Interrupt Source = DMA2OR. 55, Interrupt Source = DMA2A. 56, Interrupt Source = I2C2RX. 57, Interrupt Source = I2C2TX. 58, Interrupt Source = I2C2. 59, Interrupt Source = I2C2E. 60, Interrupt Source = U2RX. 61, Interrupt Source = U2TX. 62, Interrupt Source = U2E. 63, Interrupt Source = U2. 64, Interrupt Source = TMR3. 65, Interrupt Source = TMR3G. 66, Interrupt Source =",
    "TABLE 9-2: INTERRUPT VECTOR PRIORITY TABLE\nTMR4. 67, Interrupt Source = CCP2. 68, Interrupt Source = CWG2. 69, Interrupt Source = CLC2. 70, Interrupt Source = INT2. 71, Interrupt Source = TMR5. 72, Interrupt Source = TMR5G. 74, Interrupt Source = . , Interrupt Source = CCP3. 75, Interrupt Source = CWG3. 78, Interrupt Source = CCP4 CLC4. 77, Interrupt Source = . 80, Interrupt Source = -. 81, Interrupt Source = -\nThe natural order priority scheme has vector interrupt 0 as the highest priority and vector interrupt 81  as the lowest priority.\nFor example, when two concurrently occurring interrupt sources that are both designated high priority using the IPRx register will be resolved using the natural order priority  (i.e.,  the  interrupt  with  a  lower  corresponding vector number will preempt the interrupt with the higher vector number).\nThe ability for the user to assign every interrupt source to  high  or  low  priority  levels  means  that  the  user program can give an interrupt with a low natural order priority a higher overall priority level.",
    "9.4 Interrupt Operation\nAll pending interrupts are indicated by the flag bit being equal to a ' 1 ' in the PIRx register. All pending interrupts are  resolved  using  the  priority  scheme  explained  in Section 9.3 'Interrupt Priority' .\nOnce the interrupt source to be serviced is resolved, the program execution vectors to the resolved interrupt vector addresses, as explained in Section 9.2 'Interrupt Vector Table (IVT)' . The vector number is also stored in the WREG register. Most of the flag bits are required to be cleared by the application software, but in some cases, device hardware clears the interrupt automatically. Some flag bits are read-only in the PIRx registers,  these  flags  are  a  summary  of  the  source interrupts and the corresponding interrupt flags of the source must be cleared.\nA  valid  interrupt  can  be  either  a  high  or  low  priority interrupt when in main routine or a high priority interrupt when in low priority Interrupt Service Routine. Depending on order of interrupt requests received and their  relative  timing,  the  CPU  will  be  in  the  state  of execution indicated by the STAT bits of the INTCON1 register (Register 9-2).\nThe  State  machine  shown  in  Figure 9-1  and  the subsequent sections detail the execution of interrupts when received in different orders.",
    "Note:\nThe state of GIEH/L is not changed by the hardware when servicing an interrupt. The internal  state  machine  is  used  to  keep track of execution states. These bits can be manipulated in the user code resulting in transferring execution to the main routine and ignoring existing interrupts.",
    "9.4.1 SERVING A HIGH OR LOW PRIORITY INTERRUPT WHEN MAIN ROUTINE CODE IS EXECUTING\nWhen a high or low priority interrupt is requested when the main routine code is executing, the main routine execution is halted and the ISR is addressed, see Figure 9-2. Upon a return from the ISR (by executing the RETFIE instruction), the main routine resumes execution.",
    "9.4.2 SERVING A HIGH PRIORITY INTERRUPT WHILE A LOW PRIORITY INTERRUPT PENDING\nA high priority interrupt request will always take precedence over any interrupt of a lower priority. The high priority interrupt is acknowledged first, then the lowpriority interrupt is acknowledged. Upon a return from the high priority ISR (by executing the RETFIE instruction),  the  low  priority  interrupt  is  serviced,  see Figure 9-3.\nIf  any  other  high  priority  interrupts  are  pending  and  enabled,  then  they  are serviced  before  servicing  the  pending  low  priority  interrupt.  If  no  other  high priority interrupt requests are active, the low priority interrupt is serviced.",
    "FIGURE 9-3: INTERRUPT EXECUTION: HIGH PRIORITY INTERRUPT WITH A LOW PRIORITY INTERRUPT PENDING\nRev. 10-000267C 9/12/2016\nLow Priority\nInterrupt\nMain Code\nMain Code Execution Halted\nLow Interrupt\nreceived\nLow ISR\nHigh ISR\nHigh ISR\nMain routine\nMain routine\nLow ISR\nHigh Priority Interrupt\nHigh Interrupt\nreceived\nRETFIE Executed\nRETFIE Executed\nHigh Interrupt\ncleared\nLow Interrupt\ncleared",
    "PREEMPTING LOW PRIORITY INTERRUPTS\nLow-priority interrupts can be preempted by high priority interrupts. While in the low  priority  ISR,  if  a  high-priority  interrupt  arrives,  the  high  priority  interrupt request is generated and the low priority ISR is suspended, while the high pri -ority ISR is executed, see Figure 9-4.\n- Note 1: The  high  priority  interrupt  flag  must  be cleared to avoid recursive interrupts.\nAfter the high priority ISR is complete and if any other high priority interrupt requests are not active, the execution returns to the preempted low priority ISR.\n- 2: If a low-priority ISR was already serviced halfway  before  moving  on  to  a  high priority  ISR, then  the  low  priority ISR  is completely  serviced  even  if  user  code clears GIEL.",
    "9.4.4 SIMULTANEOUS LOW AND HIGH PRIORITY INTERRUPTS\nWhen both high and low interrupts are active in the same instruction cycle (i.e., simultaneous interrupt events), both the high and the low priority requests are generated. The high priority ISR is serviced first before servicing the low priority interrupt see Figure 9-5.",
    "FIGURE 9-5: INTERRUPT EXECUTION: SIMULTANEOUS LOW AND HIGH PRIORITY INTERRUPTS\nRev. 10-000267D 9/12/2016\nLow Priority\nInterrupt\nMain Code\nMain Code Execution Halted\nLow Interrupt\nreceived\nLow ISR\nHigh ISR\nHigh ISR\nMain routine\nMain routine\nLow ISR\nHigh Priority Interrupt\nHigh Interrupt\nreceived\nRETFIE Executed\nRETFIE Executed\nHigh Interrupt\ncleared\nLow Interrupt\ncleared",
    "9.5 Context Saving\nThe  Interrupt  controller  supports  a  two-level  deep context  saving  (Main  routine  context  and  Low  ISR context). Refer to state machine shown in Figure 9-6 for details.\nThe Program Counter (PC) is saved on the dedicated device PC stack. CPU registers saved include STATUS, WREG, BSR, FSR0/1/2, PRODL/H and PCLATH/U.\nAfter WREG has been saved to the context registers, the resolved vector number of the interrupt source to be serviced  is  copied  into  WREG.  Context  save  and restore operation is completed by the interrupt controller based on current state of the interrupts and the order in which they were sent to the CPU.\nContext  save/restore  works  the  same  way  in  both states of MVECEN. When IPEN = 0 , there is only one level interrupt active. Hence, only the main context is saved when an interrupt is received.",
    "9.5.1 ACCESSING SHADOW REGISTERS\nThe Interrupt controller automatically saves the context information in the shadow registers available in Bank 56. Both the saved context values (i.e., main routine and low ISR) can be accessed using the same set of shadow registers. By clearing the SHADLO bit in the SHADCON register (Register 9-40), the CPU register values saved for main routine context can accessed, and by  setting  the  SHADLO bit  of  the  CPU  register, values saved for low ISR context can accessed. Low ISR  context  is  automatically  restored  to  the  CPU registers upon exiting the high ISR. Similarly, the main context is automatically restored to the CPU registers upon exiting the low ISR.\nThe  Shadow  registers  in  Bank  56  are  readable  and writable,  so  if  the  user  desires  to  modify  the  context then  the  corresponding  shadow  register  should  be modified and the value will be restored when exiting the ISR. Depending  on the user's application, other registers may also need to be saved.",
    "9.6 Returning from Interrupt Service Routine (ISR)\nThe  'Return  from  Interrupt'  instruction  ( RETFIE) is used to mark the end of an ISR.\nWhen RETFIE  1 instruction  is  executed,  the  PC  is loaded with the saved PC value from the top of the PC stack. Saved context is also restored with the execution of this instruction. Thus, execution returns to the previ -ous state of operation that existed before the interrupt occurred.\nWhen RETFIE  0 instruction  is  executed,  the  saved context is not restored back to the registers.",
    "9.7 Interrupt Latency\nBy assigning each interrupt with a vector address/num -ber (MVECEN = 1 ), scanning of all interrupts is not nec -essary to determine the source of the interrupt.\nWhen  MVECEN  = 1 , Vectored  interrupt  controller requires three clock cycles to vector to the ISR from main routine, thereby removing dependency of interrupt timing on compiled code.\nThere  is  a  fixed  latency  of  three  instruction  cycles between the completion of the instruction active when the interrupt occurred and the first instruction of the Inter -rupt Service Routine. Figure 9-7, Figure 9-8 and Figure 9-9  illustrates  the  sequence  of  events  when  a peripheral interrupt is asserted when the last executed instruction is one-cycle, two-cycle and three-cycle respectively, when MVECEN = 1 .",
    "9.7 Interrupt Latency\nAfter  the  Interrupt  Flag  Status  bit  is  set,  the  current instruction  completes  executing.  In  the  first  latency cycle, the contents of the PC, STATUS, WREG, BSR, FSR0/1/2,  PRODL/H  and  PCLATH/U  registers  are context  saved  and  the  IVTBASE+  Vector  number  is calculated.  In  the  second  latency  cycle,  the  PC  is loaded with the calculated vector table address for the interrupt source and the starting address of the ISR is fetched. In the third latency cycle, the PC is loaded with the ISR address. All the latency cycles are executed as a FNOP instruction.\nWhen  MVECEN  = 0 , Vectored  interrupt  controller requires two clock cycles to vector to the ISR from main routine. There is a latency of two instruction cycles plus the  software  latency  between  the  completion  of  the instruction active when the interrupt occurred and the first instruction of the Interrupt Service Routine.",
    "FIGURE 9-7: INTERRUPT TIMING DIAGRAM - ONE CYCLE INSTRUCTION\nRev. 10-000269A\n9/12/2016\nSystem Clock\nProgram Counter\nX\nX+2\nX+2\n0x82\n0x218\n0x21A\n0x21C\nInst @ X (1)\nFNOP\nFNOP\nFNOP\nInst @ 0x218\nInst @ 0x21A\nInstruction Register\nInterrupt\nX+2\nFNOP\nRETFIE\nX+4\nInst @ X+2\nX+6\nInst @ X+4\nVector Number\n1\nIVTBASE\n0x80\nProgram Memory\n0x82\n0x86\nInterrupt Location = Interrupt vector table entry << 2 = 0x86 << 2 = 0x218\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nRoutine\nMAIN\nMAIN\nISR\nFNOP\nFNOP\nBCF\nNote 1: Instruction @ X is a one-cycle Instruction",
    "FIGURE 9-8: INTERRUPT TIMING DIAGRAM - TWO WORD INSTRUCTION\nRev. 10-000269B\n9/12/2016\nSystem Clock\nProgram Counter\nY\nY+2\nY+2\n0x82\n0x218\n0x21A\n0x21C\nInst @ Y (1)\nFNOP\nFNOP\nFNOP\nInst @ 0x218\nInst @ 0x21A\nInstruction Register\nInterrupt\nY+2\nFNOP\nRETFIE\nY+4\nInst @ Y+2\nY+6\nInst @ Y+4\nVector Number\n1\nIVTBASE\n0x80\nProgram Memory\n0x82\n0x86\nInterrupt Location = Interrupt vector table entry << 2 = 0x86 << 2 = 0x218\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nY+2\n11\nInst @ Y (1)\nRoutine\nMAIN\nMAIN\nISR\nFNOP\nFNOP\nBCF\nNote 1:\nInstruction @ Y is a two-cycle instruction.",
    "FIGURE 9-9: INTERRUPT TIMING DIAGRAM - THREE CYCLE INSTRUCTION\nRev. 10-000269C 9/12/2016\nSystem Clock\nProgram Counter\nZ\nZ+2\nZ+2\n0x82\n0x218\n0x21A\n0x21C\nInst @ Z\n(1)\nFNOP\nFNOP\nFNOP\nInst @ 0x218\nInst @\n0x21A\nInstruction Register\nInterrupt\nZ+2\nFNOP\nRETFIE\nZ+4\nInst @ Z+2 Inst @ Z+4\nZ+6\nRoutine\nMAIN\nMAIN\nISR\nVector Number\n1\nIVTBASE\n0x80\nProgram Memory 0x82\n0x86\nInterrupt Location = Interrupt vector table entry << 2 = 0x86 << 2 = 0x218\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nZ+2\n11\nInst @ Z\n(1)\nZ+2\nInst @ Z\n(1)\n12\nFNOP\nFNOP\nBCF\nNote 1:\nInstruction @ Z is a three-cycle instruction.",
    "9.7.1 ABORTING INTERRUPTS\nIf the last instruction before the interrupt controller vectors to the ISR from main routine clears the GIE, PIE or PIR bit associated with the interrupt, the controller executes one force NOP cycle before it returns to the main routine.\nFigure 9-10 illustrates the sequence of events when a peripheral interrupt is asserted and then cleared on the last executed instruction cycle.\nIf  the  GIE,  PIE  or  PIR  bit  associated  with  the  interrupt  is  cleared  prior  to vectoring to the ISR, then the controller continues executing the main routine.",
    "FIGURE 9-10: INTERRUPT TIMING DIAGRAM - ABORTING INTERRUPTS\nRev. 10-000269D 7/6/2016\nInstruction Clock\nProgram Counter\nX\nX+2\nX+2\nInst @ X (1)\nFNOP\nInstruction Register\nInterrupt\nX+4\nInst @ X+2\nX+6\nInst @ X+4\nRoutine\nMAIN\nFNOP\n1\n2\n3\n4\n5\nMAIN\nNote 1: Inst @ X clears the interrupt flag, Example BCF INTCON0, GIE.",
    "9.8 Interrupt Setup Procedure\n- 1. When using interrupt priority levels, set the IPEN bit  in  INTCON0  register  and  then  select  the user-assigned  priority  level  for the  interrupt source by writing the control bits in the appropri -ate IPRx Control register.\nNote:\nAt a device Reset, the IPRx registers are initialized, such  that  all user  interrupt sources are assigned to high priority.\n2. Clear  the  Interrupt  Flag  Status  bit  associated with the peripheral in the associated PIRx Status register.\n3. Enable the interrupt source by setting the inter -rupt enable  control  bit associated  with  the source in the appropriate PIEx Control register.\n4. If the vector table is used (MVECEN = 1 ), then setup the start address for the Interrupt Vector Table using the IVTBASE register. See Section 9.2.2 'Interrupt Vector Table Contents' .\n5. Once the IVTBASE is written to, set the Interrupt enable bits in INTCON0 register.\n6. An  example  of  setting  up  interrupts  and  ISRs using assembly and C can be found in Examples  9-3 and  9-4.",
    "9.9 External Interrupt Pins\nThe PIC18(L)F25/26K83 devices have three external interrupt sources which can be assigned to any pin on different ports based  on  the  PPS  settings.  Refer Section 17.0 'Peripheral Pin Select (PPS) Module' for  possible  rerouting  options.  The  external  interrupt sources are edge-triggered. If the corresponding INTxEDG bit in the INTCON0 register is set (= 1 ), the interrupt is triggered by a rising edge. If the bit is clear, the trigger is on the falling edge.\nWhen  a  valid  edge  appears  on  the  INTx  pin,  the corresponding flag bit, INTxF in the PIRx registers, is set.  This  interrupt  can  be  disabled  by  clearing  the corresponding enable bit, INTxE. Flag bit, INTxF, must be cleared by software in the Interrupt Service Routine before re-enabling the interrupt.",
    "9.9 External Interrupt Pins\nAll external interrupts (INT0, INT1 and INT2) can wakeup the processor from Idle or Sleep modes if bit INTxE was set prior to going into those modes. If the Global Interrupt  Enable  bit,  GIE/GIEH,  is  set,  the  processor will  branch  to  the  interrupt  vector  following  wake-up. Interrupt priority is determined by the value contained in the interrupt priority bits, INT0IP, INT1IP and INT2IP of the IPRx registers.",
    "9.10 Wake-up from Sleep\nThe interrupt controller provides a wake-up request to the  CPU  whenever  an  interrupt  event  occurs,  if  the interrupt  event  is  enabled.  This  occurs  regardless  of whether the part is in Run, Idle/Doze or Sleep modes. The status of the GIEH/GIEL bits has no effect on the wake-up request. The wake-up request will be asyn -chronous to all clocks.",
    "9.11 Interrupt Compatibility\nWhen  the  MVECEN  bit  in  Configuration  Word  2L  is cleared (Register 5-3), the Interrupt Vector Table feature is disabled and interrupts are compatible with previous high performance 8-bit PIC18 microcontroller devices. In this mode, the Interrupt Vector Table priority has no effect.\nWhen the IPEN bit is also cleared, the interrupt priority feature is disabled and interrupts are compatible with PIC16 microcontroller mid-range devices. All interrupts branch to address 0008h since the interrupt priority is disabled.",
    "EXAMPLE 9-3: SETTING UP VECTORED INTERRUPTS USING MPASM\n- ; Each ISR routine must have a predetermined origin otherwise there will be\n; an assembly error because the address is not determined until link time\n; which is too late to do the divide by 4 math on the address.\n; Predetermined addresses must be evenly divisible by 4.\nISRCLC2\nCODE\n0x7E00\n; CLC2\ninterrupt service code here.\nBANKSEL\nPIR7\nBCF\nPIR7, CLC2IF\nRETFIE\nFAST\nISRTMR0 CODE\n0x7E40\n; Timer0 interrupt service code here.\nBANKSEL\nPIR3\nBCF\nPIR3, TMR0IF\nRETFIE\nFAST\nISRTMR4 CODE    0x7E60\n; Timer4 interrupt service code here.\nBANKSEL PIR7\nBCF\nPIR7, TMR4IF\nRETFIE FAST",
    "IntInit:\n; Disable all interrupts\nBCF\nINTCON0, GIE, ACCESS\n; Set IVTBASE (optional - default is 0x000008)\nCLRF\nIVTBASEU, ACCESS\nMOVLW\n0x7F\nMOVWF\nIVTBASEH, ACCESS\nCLRF\nIVTBASEL, ACCESS\n; Clear any interrupt flags before enabling interrupts BANKSEL PIR7\nBCF\nPIR7, CLC2IF\nBCF\nPIR3, TMR0IF\nBCF\nPIR7, TMR4IF\n; Enable interrupts\nBANKSEL\nPIE7\nBSF\nPIE7, CLC2IE\nBSF\nPIE3, TMR0IE\nBSF\nPIE7, TMR4IE\n; Set interrupt priorities if necessary\nBANKSEL IPR7\nBSF INTCON0, IPEN_INTCON0, ACCESS; Enable interrupt priority BCF IPR7, CLC2IP ; Make CLC2 interrupt low priority\n; Enable interrupts\nBSF\nINTCON0, GIEH, ACCESS\nBSF\nINTCON0, GIEL, ACCESS",
    "RETURN 1\n; Save TMR0ISR in vector table (IVTBASE+31*2)\nISR1\nCODE\n0x7F3E\nDW\n0x7E40>>2)\n; (TMR0ISR/4)\n; Save TMR4ISR in vector table (IVTBASE+56*2)\nISR2\nCODE\n0x7F70\nDW\n0x7E60>>2)\n; (TMR4ISR/4)\n; Save CLC2ISR in vector table (IVTBASE+60*2)\nISR3\nCODE\n0x7F78\nDW\n(0x7E00>>2)\n; (CLC2ISR/4)",
    "EXAMPLE 9-4: SETTING UP VECTORED INTERRUPTS USING XC8\n```",
    "EXAMPLE 9-4: SETTING UP VECTORED INTERRUPTS USING XC8\n// NOTE 1: If IVTBASE is changed from its default value of 0x000008, then the // \"base(...)\" argument must be provided in the ISR. Otherwise the vector // table will be placed at 0x0008 by default regardless of the IVTBASE value. // NOTE 2: When MVECEN=0 and IPEN=1, a separate argument as \"high_priority\" // or \"low_priority\" can be used to distinguish between the two ISRs. // If the argument is not provided, the ISR is considered high priority // by default. // NOTE 3: Multiple interrupts can be handled by the same ISR if they are // specified in the \"irq(...)\" argument. Ex: irq(IRQ_TMR0, IRQ_CCP1) void __interrupt(irq(IRQ_TMR0), base(0x4008)) TMR0_ISR(void) { PIR3bits.TMR0IF = 0;",
    "EXAMPLE 9-4: SETTING UP VECTORED INTERRUPTS USING XC8\n// Clear the interrupt flag LATCbits.LC0 ^= 1; // ISR code goes here } void __interrupt(irq(default), base(0x4008)) DEFAULT_ISR(void) { // Unhandled interrupts go here } void INTERRUPT_Initialize (void) { INTCON0bits.GIEH = 1; // Enable high priority interrupts INTCON0bits.GIEL = 1; // Enable low priority interrupts INTCON0bits.IPEN = 1; // Enable interrupt priority PIE3bits.TMR0IE = 1; // Enable TMR0 interrupt PIE4bits.TMR1IE = 1; // Enable TMR1 interrupt IPR3bits.TMR0IP = 0; // Make TMR0 interrupt low priority // Change IVTBASE if required IVTBASEU = 0x00; // Optional IVTBASEH = 0x40; // Default is 0x0008 IVTBASEL = 0x08; }\n```",
    "REGISTER 9-1: INTCON0: INTERRUPT CONTROL REGISTER 0\nGIE/GIEH, R/W-0/0 = GIEL. GIE/GIEH, R/W-0/0 = IPEN. GIE/GIEH, U-0 = -. GIE/GIEH, U-0 = -. GIE/GIEH, R/W-1/1 = INT2EDG. GIE/GIEH, R/W-1/1 = INT1EDG. GIE/GIEH, R/W-1/1 = INT0EDG. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-1/1 = bit 7 bit 0. bit 7 bit 0, R/W-1/1 = bit 7 bit 0. bit 7 bit 0, R/W-1/1 = bit 7 bit 0",
    "REGISTER 9-1: INTCON0: INTERRUPT CONTROL REGISTER 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nGIE/GIEH: Global Interrupt Enable bits\nIf IPEN = 0 :",
    "GIE:\n1 = Enables all unmasked interrupts\n0 = Disables all interrupts",
    "GIEH:\n- 1 =  Enables  all  unmasked  high  priority  interrupts:  bit  also  needs  to  be  set  for  enabling  low  priority interrupts\n0 =  Disables all interrupts\nGIEL: Global Low Priority Interrupt Enable bit\nIf IPEN = 0 :\nReserved, read as '0'",
    "GIEL:\n1 =   Enables all unmasked low priority interrupts, GIEH also needs to be set for low priority interrupts\n0 =   Disables all low priority\nIPEN: Interrupt Priority Enable bit\n- 1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts; all interrupts are treated as high priority interrupts",
    "bit 2\nINT2EDG: External Interrupt 2 Edge Select bit\n1 = Interrupt on rising edge of INT2 pin\n0 = Interrupt on falling edge of INT2 pin\nINT1EDG: External Interrupt 1 Edge Select bit\n1 = Interrupt on rising edge of INT1 pin\n0 = Interrupt on falling edge of INT1 pin",
    "bit 0 INT0EDG: External Interrupt 0 Edge Select bit\n1 = Interrupt on rising edge of INT0 pin\n0 = Interrupt on falling edge of INT0 pin",
    "REGISTER 9-2: INTCON1: INTERRUPT CONTROL REGISTER 1\nR-0/0, 1 = R-0/0. R-0/0, 2 = U-0. R-0/0, 3 = U-0. R-0/0, 4 = U-0. R-0/0, 5 = U-0. R-0/0, 6 = U-0. R-0/0, 7 = U-0. STAT<1:0>, 1 = STAT<1:0>. STAT<1:0>, 2 = -. STAT<1:0>, 3 = -. STAT<1:0>, 4 = -. STAT<1:0>, 5 = -. STAT<1:0>, 6 = -. STAT<1:0>, 7 = -. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "Legend:\nHC = Bit is cleared by hardware\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition",
    "bit 7-6\nSTAT<1:0>: Interrupt State Status bits\n11 =  High  priority  ISR  executing,  high  priority  interrupt  was  received  while a  low  priority  ISR  was executing\n10 = High priority ISR executing, high priority interrupt was received in main routine\n01 = Low priority ISR executing, low priority interrupt was received in main routine\n00 = Main routine executing\nbit 5-0\nUnimplemented : Read as ' 0 '",
    "REGISTER 9-3: PIR0: PERIPHERAL INTERRUPT REQUEST REGISTER 0\nR-0/0, 1 = R/W/HS-0/0. R-0/0, 2 = R/W/HS-0/0. R-0/0, 3 = R/W/HS-0/0. R-0/0, 4 = R/W/HS-0/0. R-0/0, 5 = R/W/HS-0/0. R-0/0, 6 = R/W/HS-0/0. R-0/0, 7 = R/W/HS-0/0. IOCIF (2), 1 = CRCIF. IOCIF (2), 2 = SCANIF. IOCIF (2), 3 = NVMIF. IOCIF (2), 4 = CSWIF (3). IOCIF (2), 5 = OSFIF. IOCIF (2), 6 = HLVDIF. IOCIF (2), 7 = SWIF. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 =",
    "REGISTER 9-3: PIR0: PERIPHERAL INTERRUPT REQUEST REGISTER 0\nbit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nR = Readable bit u = Bit is unchanged,  = W=Writable x = Bit is unknown. R = Readable bit u = Bit is unchanged,  = U = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HS = Bit is set in hardware",
    "bit 7\nIOCIF: Interrupt-on-Change Interrupt Flag bit (2)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred",
    "bit 6\nCRCIF: CRC Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 5\nSCANIF: Memory Scanner Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 4 NVMIF: NVM Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 3\nCSWIF: Clock Switch Interrupt Flag bit (3)\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 2\nOSFIF: Oscillator Fail Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 1\nHLVDIF: HLVD Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 0\nSWIF: Software Interrupt Flag bit\n1 = Software Interrupt Flag Enable\n0 = Software Interrupt Flag Disable\nNote 1: Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2: IOCIF is a read-only bit. To clear the interrupt condition, all bits in the IOCxF registers must be cleared.\n3: The CSWIF interrupt will not wake the system from Sleep. The system will sleep until another interrupt causes the wake-up.",
    "REGISTER 9-4: PIR1: PERIPHERAL INTERRUPT REQUEST REGISTER 1\nR/W/HS-0/0, 1 = R/W/HS-0/0. R/W/HS-0/0, 2 = R/W/HS-0/0. R/W/HS-0/0, 3 = R/W/HS-0/0. R/W/HS-0/0, 4 = R/W/HS-0/0. R/W/HS-0/0, 5 = R/W/HS-0/0. R/W/HS-0/0, 6 = R/W/HS-0/0. R/W/HS-0/0, 7 = R/W/HS-0/0. SMT1PWAIF, 1 = SMT1PRAIF. SMT1PWAIF, 2 = SMT1IF. SMT1PWAIF, 3 = C1IF. SMT1PWAIF, 4 = ADTIF. SMT1PWAIF, 5 = ADIF. SMT1PWAIF, 6 = ZCDIF. SMT1PWAIF, 7",
    "REGISTER 9-4: PIR1: PERIPHERAL INTERRUPT REQUEST REGISTER 1\n= INT0IF (2). bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nR = Readable bit u = Bit is unchanged,  = W=Writable x = Bit is unknown. R = Readable bit u = Bit is unchanged,  = U = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HS = Bit is set in hardware\nbit 7\nSMT1PWAIF: SMT1 Pulse-Width Acquisition Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 6\nSMT1PRAIF: SMT1 Period Acquisition Interrupt Flag bit",
    "REGISTER 9-4: PIR1: PERIPHERAL INTERRUPT REQUEST REGISTER 1\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 5 SMT1IF: SMT1 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 4\nC1IF: CMP1 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 3 ADTIF: ADC Threshold Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 2 ADIF: ADC Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 1\nZCDIF: ZCD Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 0\nINT0IF: External Interrupt 0 Interrupt Flag bit (2)\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nNote 1: Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n- 2: The external interrupt GPIO pin is selected by the INTxPPS register.",
    "REGISTER 9-5: PIR2: PERIPHERAL INTERRUPT REGISTER 2 (1)\nI2C1RXIF (2), R-0/0 = SPI1IF (3). I2C1RXIF (2), R-0/0 = SPI1TXIF (4). I2C1RXIF (2), R-0/0 = SPI1RXIF (4). I2C1RXIF (2), R/W/HS-0/0 = DMA1AIF. I2C1RXIF (2), R/W/HS-0/0 = DMA1ORIF. I2C1RXIF (2), R/W/HS-0/0 = DMA1DCNTIF. I2C1RXIF (2), R/W/HS-0/0 = DMA1SCNTIF. bit 7 bit 0, R-0/0 = bit 7 bit 0. bit 7 bit 0, R-0/0 = bit 7 bit 0. bit 7 bit 0, R-0/0 = bit 7 bit 0. bit 7 bit",
    "REGISTER 9-5: PIR2: PERIPHERAL INTERRUPT REGISTER 2 (1)\n0, R/W/HS-0/0 = bit 7 bit 0. bit 7 bit 0, R/W/HS-0/0 = bit 7 bit 0. bit 7 bit 0, R/W/HS-0/0 = bit 7 bit 0. bit 7 bit 0, R/W/HS-0/0 = bit 7 bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HS = Hardware set",
    "bit 7 I2C1RXIF:\nI 2 C1 Receive Interrupt Flag bit (2)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred",
    "bit 6\nSPI1IF: SPI1 Interrupt Flag bit (3)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 5\nSPI1TXIF: SPI1 Transmit Interrupt Flag bit (4)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 4 SPI1RXIF: SPI1 Receive Interrupt Flag bit (4)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred",
    "bit 3 DMA1AIF: DMA1 Abort Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 2\nDMA1ORIF: DMA1 Overrun Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 1\nDMA1DCNTIF: DMA1 Destination Count Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 0 DMA1SCNTIF: DMA1 Source Count Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nNote 1: Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2: I2CxTXIF and I2CxRXIF are read-only bits. To clear the interrupt condition, the CLRBF bit in I2CxSTAT1 register must be set.\n3: SPIxIF is a read-only bit. To clear the interrupt condition, all bits in the SPIxINTF register must be cleared.\n4: SPIxTXIF and SPIxRXIF are read-only bits and cannot be set/cleared by the software.",
    "PIR3: PERIPHERAL INTERRUPT REGISTER 3 (1)\nR/W/HS-0/0, 1 = R-0/0. R/W/HS-0/0, 2 = R-0/0. R/W/HS-0/0, 3 = R-0/0. R/W/HS-0/0, 4 = R-0/0. R/W/HS-0/0, 5 = R-0/0. R/W/HS-0/0, 6 = R-0/0. R/W/HS-0/0, 7 = R-0/0. TMR0IF, 1 = U1IF (2). TMR0IF, 2 = U1EIF (3). TMR0IF, 3 = U1TXIF (4). TMR0IF, 4 = U1RXIF (4). TMR0IF, 5 = I2C1EIF (5). TMR0IF, 6 = I2C1IF (6). TMR0IF, 7 = I2C1TXIF (7).",
    "PIR3: PERIPHERAL INTERRUPT REGISTER 3 (1)\nbit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = HS = Bit is set in hardware",
    "bit 7 TMR0IF: TMR0 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 6\nU1IF: UART1 Interrupt Flag bit (2)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 5\nU1EIF: UART1 Framing Error Interrupt Flag bit (3)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 4\nU1TXIF: UART1 Transmit Interrupt Flag bit (4)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 3\nU1RXIF: UART1 Receive Interrupt Flag bit (4)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred",
    "bit 2\nI2C1EIF: I 2 C1 Error Interrupt Flag bit (5)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred",
    "bit 1\nI2C1IF: I 2 C1 Interrupt Flag bit (6)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 0\nI2C1TXIF: I 2 C1 Transmit Interrupt Flag bit (7)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred",
    "bit 1\nNote 1: Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2: UxIF is a read-only bit. To clear the interrupt condition, all bits in the UxUIR register must be cleared.\n3: UxEIF is a read-only bit. To clear the interrupt condition, all bits in the UxERRIR register must be cleared.\n4: UxTXIF and UxRXIF are read-only bits and cannot be set/cleared by the software.\n5: I2CxEIF is a read-only bit. To clear the interrupt condition, all bits in the I2CxERR register must be cleared.\n6: I2CxIF is a read-only bit. To clear the interrupt condition, all bits in the I2CxPIR register must be cleared.",
    "bit 1\n7: I2CxTXIF and I2CxRXIF are read-only bits. To clear the interrupt condition, the CLRBF bit in I2CxSTAT1 register must be set.",
    "REGISTER 9-7: PIR4: PERIPHERAL INTERRUPT REGISTER 4 (1)\nR/W/HS-0/0, 1 = R/W/HS-0/0. R/W/HS-0/0, 2 = R/W/HS-0/0. R/W/HS-0/0, 3 = R/W/HS-0/0. R/W/HS-0/0, 4 = R/W/HS-0/0. R/W/HS-0/0, 5 = R/W/HS-0/0. R/W/HS-0/0, 6 = R/W/HS-0/0. R/W/HS-0/0, 7 = R/W/HS-0/0. INT1IF (2), 1 = CLC1IF. INT1IF (2), 2 = CWG1IF. INT1IF (2), 3 = NCO1IF. INT1IF (2), 4 = CCP1IF. INT1IF (2), 5 = TMR2IF. INT1IF (2), 6 =",
    "REGISTER 9-7: PIR4: PERIPHERAL INTERRUPT REGISTER 4 (1)\nTMR1GIF. INT1IF (2), 7 = TMR1IF. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nR = Readable bit u = Bit is unchanged,  = W=Writable x = Bit is unknown. R = Readable bit u = Bit is unchanged,  = U = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HS = Bit is set in hardware\nbit 7\nINT1IF: External Interrupt 1 Interrupt Flag bit (2)\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 6\nCLC1IF: CLC1 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 5 CWG1IF: CWG1 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 4\nNCO1IF: NCO1 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 3 CCP1IF: CCP1 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 2 TMR2IF: TMR2 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 1\nTMR1GIF: TMR1 Gate Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 0\nTMR1IF: TMR1 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nNote 1: Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2: The external interrupt GPIO pin is selected by the INTxPPS register.",
    "REGISTER 9-8: PIR5: PERIPHERAL INTERRUPT REGISTER 5 (1)\nR/W/HS-0/0, 1 = R/W/HS-0/0. R/W/HS-0/0, 2 = R/W/HS-0/0. R/W/HS-0/0, 3 = R/W/HS-0/0. R/W/HS-0/0, 4 = R/W/HS-0/0. R/W/HS-0/0, 5 = R/W/HS-0/0. R/W/HS-0/0, 6 = R/W/HS-0/0. R/W/HS-0/0, 7 = R/W/HS-0/0. IRXIF, 1 = WAKIF. IRXIF, 2 = ERRIF. IRXIF, 3 = TXB2IF/TXBnIF. IRXIF, 4 = TXB1IF. IRXIF, 5 = TXB0IF. IRXIF, 6 = RXB1IF/RXBnIF. IRXIF, 7 =",
    "REGISTER 9-8: PIR5: PERIPHERAL INTERRUPT REGISTER 5 (1)\nRXB0IF/FIFOFIF. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HS = Bit is set in hardware\nbit 7\nIRXIF: CAN Invalid Message Received Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 6 WAKIF: CAN Bus Wake-Up Activity Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 5",
    "REGISTER 9-8: PIR5: PERIPHERAL INTERRUPT REGISTER 5 (1)\nERRIF: CAN Error Interrupt Flag bit (Multiple sources in the COMSTAT register)\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 4\nTXB2IF/TXBnIF: CAN Transmit Buffer 2/Transmit Buffer n Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 3 TXB1IF: CAN Transmit Buffer 1 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 2\nTXB0IF: CAN Transmit Buffer 0 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 1 RXB1IF/RXBnIF: CAN Receive Buffer 1/ Receive Buffer n Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 0\nRXB0IF/FIFOWMIF: CAN Receive Buffer 0/FIFO Watermark Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nNote 1: Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.",
    "REGISTER 9-9: PIR6: PERIPHERAL INTERRUPT REGISTER 6 (1)\nR/W/HS-0/0, 1 = R/W/HS-0/0. R/W/HS-0/0, 2 = R/W/HS-0/0. R/W/HS-0/0, 3 = R/W/HS-0/0. R/W/HS-0/0, 4 = R/W/HS-0/0. R/W/HS-0/0, 5 = R/W/HS-0/0. R/W/HS-0/0, 6 = R/W/HS-0/0. R/W/HS-0/0, 7 = R/W/HS-0/0. DMA2AIF, 1 = DMA2ORIF. DMA2AIF, 2 = DMA2DCNTIF. DMA2AIF, 3 = DMA2SCNTIF. DMA2AIF, 4 = SMT2PWAIF. DMA2AIF, 5 = SMT2PRAIF. DMA2AIF, 6 =",
    "REGISTER 9-9: PIR6: PERIPHERAL INTERRUPT REGISTER 6 (1)\nSMT2IF. DMA2AIF, 7 = C2IF. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HS = Bit is set in hardware",
    "bit 7 DMA2AIF: DMA2 Abort Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 6\nDMA2ORIF: DMA2 Overrun Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 5 DMA2DCNTIF: DMA2 Destination Count Interrupt Flag bit\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 4\nDMA2SCNTIF: DMA2 Source Count Interrupt Flag bit\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred",
    "bit 3\nSMT2PWAIF: SMT2 Pulse-Width Acquisition Interrupt Flag bit\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred",
    "bit 2 SMT2PRAIF: SMT2 Period Acquisition Interrupt Flag bit\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred",
    "bit 1\nSMT2IF: SMT2 Interrupt Flag bit\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 0\nC2IF: C2 Interrupt Flag bit\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nNote 1: Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an inter -rupt.",
    "REGISTER 9-10: PIR7: PERIPHERAL INTERRUPT REGISTER 7 (1)\nU2IF (2), R-0/0 = U2EIF (3). U2IF (2), R-0/0 = U2TXIF (4). U2IF (2), R-0/0 = U2RXIF (4). U2IF (2), R-0/0 = I2C2EIF (5). U2IF (2), R-0/0 = I2C2IF (6). U2IF (2), R-0/0 = I2C2TXIF (7). U2IF (2), R-0/0 = I2C2RXIF (7). bit 7, R-0/0 = bit 7. bit 7, R-0/0 = bit 7. bit 7, R-0/0 = bit 7. bit 7, R-0/0 = bit 7. bit 7, R-0/0 = bit 7. bit 7, R-0/0 = bit 7. bit 7, R-0/0 = bit 0",
    "REGISTER 9-10: PIR7: PERIPHERAL INTERRUPT REGISTER 7 (1)\nR = Readable bit u = Bit is unchanged,  = W=Writable x = Bit is unknown. R = Readable bit u = Bit is unchanged,  = U = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HS = Bit is set in hardware\nbit 7 U2IF: UART2 Interrupt Flag bit (2)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 6\nU2EIF: UART2 Framing Error Interrupt Flag bit (3)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 5\nU2TXIF: UART2 Transmit Interrupt Flag bit (4)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 4\nU2RXIF: UART2 Receive Interrupt Flag bit (4)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 3\nI2C2EIF: I 2 C2 Error Interrupt Flag bit (5)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred",
    "bit 2\nI2C2IF: I 2 C2 Interrupt Flag bit (6)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 1\nI2C2TXIF: I 2 C2 Transmit Interrupt Flag bit (7)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred\nbit 0\nI2C2RXIF: I 2 C2 Receive Interrupt Flag bit (7)\n1 = Interrupt has occurred\n0 = Interrupt event has not occurred",
    "bit 2\nNote 1: Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2: UxIF is a read-only bit. To clear the interrupt condition, all bits in the UxUIR register must be cleared.\n3: UxEIF is a read-only bit. To clear the interrupt condition, all bits in the UxERRIR register must be cleared.\n4: UxTXIF and UxRXIF are read-only bits and cannot be set/cleared by the software.\n5: I2CxEIF is a read-only bit. To clear the interrupt condition, all bits in the I2CxERR register must be cleared.\n6: I2CxIF is a read-only bit. To clear the interrupt condition, all bits in the I2CxPIR register must be cleared.",
    "bit 2\n7: I2CxTXIF and I2CxRXIF are read-only bits. To clear the interrupt condition, the CLRBF bit in I2CxSTAT1 register must be set.",
    "REGISTER 9-11: PIR8: PERIPHERAL INTERRUPT REGISTER 8 (1)\nR/W/HS-0/0, 1 = R/W/HS-0/0. R/W/HS-0/0, 2 = R/W/HS-0/0. R/W/HS-0/0, 3 = R/W/HS-0/0. R/W/HS-0/0, 4 = R/W/HS-0/0. R/W/HS-0/0, 5 = R/W/HS-0/0. R/W/HS-0/0, 6 = R/W/HS-0/0. R/W/HS-0/0, 7 = R/W/HS-0/0. TMR5IF, 1 = INT2IF (2). TMR5IF, 2 = CLC2IF. TMR5IF, 3 = CWG2IF. TMR5IF, 4 = CCP2IF. TMR5IF, 5 = TMR4IF. TMR5IF, 6 = TMR3GIF.",
    "REGISTER 9-11: PIR8: PERIPHERAL INTERRUPT REGISTER 8 (1)\nTMR5IF, 7 = TMR3IF. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nHS = Bit is set in hardware",
    "bit 7 TMR5IF: TMR5 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 6\nINT2IF: External Interrupt 2 Interrupt Flag bit (2)\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nbit 5\nCLC2IF: CLC2 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 4\nCWG2IF: CWG2 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 3\nCCP2IF: CCP2 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 2 TMR4IF: TMR4 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 1\nTMR3GIF: TMR3G Gate Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 0 TMR3IF: TMR3 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nNote 1: Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n- 2: The external interrupt GPIO pin is selected by the INTxPPS register.",
    "REGISTER 9-12: PIR9: PERIPHERAL INTERRUPT REGISTER 9 (1)\nU-0, 1 = R/W/HS-0/0. U-0, 2 = R/W/HS-0/0. U-0, 3 = R/W/HS-0/0. U-0, 4 = R/W/HS-0/0. U-0, 5 = R/W/HS-0/0. U-0, 6 = R/W/HS-0/0. U-0, 7 = R/W/HS-0/0. -, 1 = CLC4IF. -, 2 = CCP4IF. -, 3 = CLC3IF. -, 4 = CWG3IF. -, 5 = CCP3IF. -, 6 = TMR6IF. -, 7 = TMR5GIF. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7",
    "REGISTER 9-12: PIR9: PERIPHERAL INTERRUPT REGISTER 9 (1)\nbit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "bit 6 CLC4IF: CLC4 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 5\nCCP4IF: CCP4 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 4\nCLC3IF: CLC3 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 3 CWG3IF: CWG3 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 2\nCCP3IF: CCP3 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 1\nTMR6IF: TMR6 Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred",
    "bit 0\nTMR5GIF: TMR5 Gate Interrupt Flag bit\n1 = Interrupt has occurred (must be cleared by software)\n0 = Interrupt event has not occurred\nNote 1: Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.",
    "REGISTER 9-13: PIE0: PERIPHERAL INTERRUPT ENABLE REGISTER 0\nIOCIE, R/W-0/0 = CRCIE. IOCIE, R/W-0/0 = SCANIE. IOCIE, R/W-0/0 = NVMIE. IOCIE, R/W-0/0 = CSWIE. IOCIE, R/W-0/0 = OSFIE. IOCIE, R/W-0/0 = HLVDIE. IOCIE, R/W-0/0 = SWIE. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 9-13: PIE0: PERIPHERAL INTERRUPT ENABLE REGISTER 0\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7\nIOCIE:\nInterrupt-on-Change Enable bit\n1 = Enabled\n0 = Disabled\nbit 6\nCRCIE: CRC Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 5\nSCANIE: Memory Scanner Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 4\nNVMIE: NVM Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 3\nCSWIE: Clock Switch Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 2\nOSFIE: Oscillator Fail Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 1",
    "REGISTER 9-13: PIE0: PERIPHERAL INTERRUPT ENABLE REGISTER 0\nHLVDIE: HLVD Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 0\nSWIE: Software Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "REGISTER 9-14: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nSMT1PWAIE, R/W-0/0 = SMT1PRAIE. SMT1PWAIE, R/W-0/0 = SMT1IE. SMT1PWAIE, R/W-0/0 = C1IE. SMT1PWAIE, R/W-0/0 = ADTIE. SMT1PWAIE, R/W-0/0 = ADIE. SMT1PWAIE, R/W-0/0 = ZCDIE. SMT1PWAIE, R/W-0/0 = INT0IE. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 9-14: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7\nSMT1PWAIE:\nSMT1 Pulse Width Acquisition Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 6\nSMT1PRAIE: SMT1 Period Acquisition Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 5\nSMT1IE: SMT1 Interrupt Enable bit\n1 = Enabled\n0\n=\nDisabled",
    "bit 4\nC1IE: C1 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 3\nADTIE: ADC Threshold Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 2\nADIE: ADC Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 1\nZCDIE: ZCD Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 0\nINT0IE: External Interrupt 0 Enable bit\n1 = Enabled\n0 = Disabled",
    "REGISTER 9-15: PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. I2C1RXIE, 1 = SPI1IE. I2C1RXIE, 2 = SPI1TXIE. I2C1RXIE, 3 = SPI1RXIE. I2C1RXIE, 4 = DMA1AIE. I2C1RXIE, 5 = DMA1ORIE. I2C1RXIE, 6 = DMA1DCNTIE. I2C1RXIE, 7 = DMA1SCNTIE. bit 7 bit 0, 1 = bit 7 bit",
    "REGISTER 9-15: PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\n0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7 I2C1RXIE: I\n2 C1 Receive Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 6\nSPI1IE: SPI1 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 5\nSPI1TXIE: SPI1 Transmit Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 4\nSPI1RXIE: SPI1 Receive Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 3\nDMA1AIE: DMA1 Abort Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 2\nDMA1ORIE: DMA1 Overrun Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 1\nDMA1DCNTIE: DMA1 Destination Count Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 0\nDMA1SCNTIE: DMA1 Source Count Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "REGISTER 9-16: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\nTMR0IE, R/W-0/0 = U1IE. TMR0IE, R/W-0/0 = U1EIE. TMR0IE, R/W-0/0 = U1TXIE. TMR0IE, R/W-0/0 = U1RXIE. TMR0IE, R/W-0/0 = I2C1EIE. TMR0IE, R/W-0/0 = I2C1IE. TMR0IE, R/W-0/0 = I2C1TXIE. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit",
    "REGISTER 9-16: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\n0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7\nTMR0IE:\nTMR0 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 6\nU1IE: UART1 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 5\nU1EIE: UART1 Framing Error Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 4\nU1TXIE: UART1 Transmit Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 3",
    "REGISTER 9-16: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\nU1RXIE: UART1 Receive Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 2\nI2C1EIE: I 2 C1 Error Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 1\nI2C1IE: I 2 C1 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 0\nI2C1TXIE: I 2 C1 Transmit Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "REGISTER 9-17: PIE4: PERIPHERAL INTERRUPT ENABLE REGISTER 4\nINT1IE, R/W-0/0 = CLC1IE. INT1IE, R/W-0/0 = CWG1IE. INT1IE, R/W-0/0 = NCO1IE. INT1IE, R/W-0/0 = CCP1IE. INT1IE, R/W-0/0 = TMR2IE. INT1IE, R/W-0/0 = TMR1GIE. INT1IE, R/W-0/0 = TMR1IE. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 =",
    "REGISTER 9-17: PIE4: PERIPHERAL INTERRUPT ENABLE REGISTER 4\nbit 7 bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = \nbit 7\nINT1IE: External Interrupt 1 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 6\nCLC1IE: CLC1 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 5\nCWG1IE: CWG1 Interrupt Enable bit\n1 = Enabled\n0\n=\nDisabled\nbit 4\nNCO1IE: NCO1 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 3\nCCP1IE: CCP1 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 2",
    "REGISTER 9-17: PIE4: PERIPHERAL INTERRUPT ENABLE REGISTER 4\nTMR2IE: TMR2 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 1\nTMR1GIE: TMR1 Gate Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 0\nTMR1IE: TMR1 Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "REGISTER 9-18: PIE5: PERIPHERAL INTERRUPT ENABLE REGISTER 5\nIRXIE, R/W-0/0 = WAKIE. IRXIE, R/W-0/0 = ERRIE. IRXIE, R/W-0/0 = TXB2IE/TXBnIE. IRXIE, R/W-0/0 = TXB1IE. IRXIE, R/W-0/0 = TXB0IE. IRXIE, R/W-0/0 = RXB1IE/RXBnIE. IRXIE, R/W-0/0 = RXB0IE/FIFOFIE. bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "REGISTER 9-18: PIE5: PERIPHERAL INTERRUPT ENABLE REGISTER 5\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7 IRXIE: CAN Invalid Message Received Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 6 WAKIE: CAN Bus Wake-up Activity Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 5\nERRIE: CAN Error Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 4\nTXB2IE/TXBnIE: CAN Transmit Buffer 2/Transmit Buffer n Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 3\nTXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 2\nTXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 1\nRXB1IE/RXBnIE: CAN Receive Buffer 1/ Receive Buffer n Interrupt Flag Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 0 RXB0IE/FIFOFIE: CAN Receive Buffer 0/FIFO Full Interrupt Enable bit\n1 = Enabled\n- 0 = Disabled",
    "REGISTER 9-19: PIE6: PERIPHERAL INTERRUPT ENABLE REGISTER 6\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. DMA2AIE, 1 = DMA2ORIE. DMA2AIE, 2 = DMA2DCNTIE. DMA2AIE, 3 = DMA2SCNTIE. DMA2AIE, 4 = SMT2PWAIE. DMA2AIE, 5 = SMT2PRAIE. DMA2AIE, 6 = SMT2IE. DMA2AIE, 7 = C2IE. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7,",
    "REGISTER 9-19: PIE6: PERIPHERAL INTERRUPT ENABLE REGISTER 6\n3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = ",
    "bit 7 DMA2AIE: DMA Abort Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 6\nDMA2ORIE: DMA2 Overrun Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 5\nDMA2DCNTIE: DMA2 Destination Count Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 4\nDMA2SCNTIE: DMA2 Source Count Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 3\nSMT2PWAIE: SMT2 Pulse-Width Acquisition Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 2\nSMT2PRAIE: SMT2 Period Acquisition Receive Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 1\nSMT2IE: SMT2 Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 0 C2IE: C2 Interrupt Enable bit\n1 = Enabled\n- 0 = Disabled",
    "REGISTER 9-20: PIE7: PERIPHERAL INTERRUPT ENABLE REGISTER 7\nU2IE, R/W-0/0 = U2EIE. U2IE, R/W-0/0 = U2TXIE. U2IE, R/W-0/0 = U2RXIE. U2IE, R/W-0/0 = I2C2EIE. U2IE, R/W-0/0 = I2C2IE. U2IE, R/W-0/0 = I2C2TXIE. U2IE, R/W-0/0 = I2C2RXIE. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 9-20: PIE7: PERIPHERAL INTERRUPT ENABLE REGISTER 7\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7\nU2IE: UART2 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 6\nU2EIE: UART2 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 5\nU2TXIE: UART2 Transmit Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 4\nU2RXIE: UART2 Receive Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 3\nI2C2EIE: I 2 C2 Error Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 2",
    "REGISTER 9-20: PIE7: PERIPHERAL INTERRUPT ENABLE REGISTER 7\nI2C2IE: I 2 C2 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 1\nI2C2TXIE: I 2 C2 Transmit Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 0\nI2C2RXIE: I 2 C2 Receive Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "REGISTER 9-21: PIE8: PERIPHERAL INTERRUPT ENABLE REGISTER 8\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. TMR5IE, 1 = INT2IE. TMR5IE, 2 = CLC2IE. TMR5IE, 3 = CWG2IE. TMR5IE, 4 = CCP2IE. TMR5IE, 5 = TMR4IE. TMR5IE, 6 = TMR3GIE. TMR5IE, 7 = TMR3IE. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7.",
    "REGISTER 9-21: PIE8: PERIPHERAL INTERRUPT ENABLE REGISTER 8\nbit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = ",
    "bit 7\nTMR5IE:\nTMR5 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 6\nINT2IE: External Interrupt 2 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 5\nCLC2IE: CLC2 Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 4\nCWG2IE: CWG2 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 3\nCCP2IE: CCP2 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 2\nTMR4IE: TMR4 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 1\nTMR3GIE: TMR3 Gate Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 0\nTMR3IE: TMR3 Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "REGISTER 9-22: PIE9: PERIPHERAL INTERRUPT ENABLE REGISTER 9\nU-0, 1 = R/W-0/0. U-0, 2 = R/W-0/0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = CLC4IE. -, 2 = CCP4IE. -, 3 = CLC3IE. -, 4 = CWG3IE. -, 5 = CCP3IE. -, 6 = TMR6IE. -, 7 = TMR5GIE. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 9-22: PIE9: PERIPHERAL INTERRUPT ENABLE REGISTER 9\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nCLC4IE: CLC4 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 5\nCCP4IE: CCP4 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 4\nCLC3IE: CLC3 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 3\nCWG3IE: CWG3 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 2\nCCP3IE: CCP3 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 1\nTMR6IE: TMR6 Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 0",
    "REGISTER 9-22: PIE9: PERIPHERAL INTERRUPT ENABLE REGISTER 9\nTMR5GIE: TMR5 Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "REGISTER 9-23: IPR0: PERIPHERAL INTERRUPT PRIORITY REGISTER 0\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. IOCIP, 1 = CRCIP. IOCIP, 2 = SCANIP. IOCIP, 3 = NVMIP. IOCIP, 4 = CSWIP. IOCIP, 5 = OSFIP. IOCIP, 6 = HLVDIP. IOCIP, 7 = SWIP. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 =",
    "REGISTER 9-23: IPR0: PERIPHERAL INTERRUPT PRIORITY REGISTER 0\nbit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7\nIOCIP: Interrupt-on-Change Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nCRCIP: CRC Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nSCANIP: Memory Scanner Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 4\nNVMIP: NVM Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nCSWIP: Clock Switch Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nOSFIP: Oscillator Fail Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nHLVDIP: HLVD Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nSWIP: Software Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-24: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nSMT1PWAIP, R/W-1/1 = SMT1PRAIP. SMT1PWAIP, R/W-1/1 = SMT1IP. SMT1PWAIP, R/W-1/1 = C1IP. SMT1PWAIP, R/W-1/1 = ADTIP. SMT1PWAIP, R/W-1/1 = ADIP. SMT1PWAIP, R/W-1/1 = ZCDIP. SMT1PWAIP, R/W-1/1 = INT0IP. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 0",
    "REGISTER 9-24: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, = Unimplemented bit, read as '0' = U. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets\nbit 7\nSMT1PWAIP: SMT1 Pulse Width Acquisition Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nSMT1PRAIP: SMT1 Period Acquisition Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nSMT1IP: SMT1 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 4\nC1IP: C1 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 3 ADTIP: ADC Threshold Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 2\nADIP: ADC Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nZCDIP: ZCD Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nINT0IP: External Interrupt 0 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-25: IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. I2C1RXIP, 1 = SPI1IP. I2C1RXIP, 2 = SPI1TXIP. I2C1RXIP, 3 = SPI1RXIP. I2C1RXIP, 4 = DMA1AIP. I2C1RXIP, 5 = DMA1ORIP. I2C1RXIP, 6 = DMA1DCNTIP. I2C1RXIP, 7 = DMA1SCNTIP. bit",
    "REGISTER 9-25: IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\n7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7\nI2C1RXIP: I 2 C1 Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nSPI1IP: SPI1 Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5",
    "REGISTER 9-25: IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nSPI1TXIP: I 2 C1 Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4\nSPI1RXIP: SPI1 Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nDMA1AIP: DMA1 Abort Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nDMA1ORIP: DMA1 Overrun Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nDMA1DCNTIP: DMA1 Destination Count Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nDMA1SCNTIP: DMA1 Source Count Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-26: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. TMR0IP, 1 = U1IP. TMR0IP, 2 = U1EIP. TMR0IP, 3 = U1TXIP. TMR0IP, 4 = U1RXIP. TMR0IP, 5 = I2C1EIP. TMR0IP, 6 = I2C1IP. TMR0IP, 7 = I2C1TXIP. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit",
    "REGISTER 9-26: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\n7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7\nTMR0IP: TMR0 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nU1IP: UART1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nU1EIP: UART1 Framing Error Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4",
    "REGISTER 9-26: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nU1TXIP: UART1 Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nU1RXIP: UART1 Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nI2C1EIP: I 2 C1 Error Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nI2C1IP: I 2 C1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nI2C1TXIP: I 2 C1 Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-27: IPR4: PERIPHERAL INTERRUPT PRIORITY REGISTER 4\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. INT1IP, 1 = CLC1IP. INT1IP, 2 = CWG1IP. INT1IP, 3 = NCO1IP. INT1IP, 4 = CCP1IP. INT1IP, 5 = TMR2IP. INT1IP, 6 = TMR1GIP. INT1IP, 7 = TMR1IP. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7,",
    "REGISTER 9-27: IPR4: PERIPHERAL INTERRUPT PRIORITY REGISTER 4\n5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7\nINT1IP: External Interrupt 1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nCLC1IP: CLC1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nCWG1IP: CWG1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4\nNCO1IP: NCO1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3",
    "REGISTER 9-27: IPR4: PERIPHERAL INTERRUPT PRIORITY REGISTER 4\nCCP1IP: CCP1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nTMR2IP: TMR2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR1GIP: TMR1 Gate Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nTMR1IP: TMR1 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-28: IPR5: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nIRXIP, R/W-1/1 = WAKIP. IRXIP, R/W-1/1 = ERRIP. IRXIP, R/W-1/1 = TXB2IP/TXBnIP. IRXIP, R/W-1/1 = TXB1IP. IRXIP, R/W-1/1 = TXB0IP. IRXIP, R/W-1/1 = RXB1IP/RXBnIP. IRXIP, R/W-1/1 = RXB0IP/FIFOFIP. bit 7 bit 0, R/W-1/1 = bit 7 bit 0. bit 7 bit 0, R/W-1/1 = bit 7 bit 0. bit 7 bit 0, R/W-1/1 = bit 7 bit 0. bit 7 bit 0, R/W-1/1 = bit 7 bit 0. bit 7 bit 0, R/W-1/1 = bit 7 bit 0. bit 7 bit 0, R/W-1/1 = bit 7 bit 0. bit 7",
    "REGISTER 9-28: IPR5: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nbit 0, R/W-1/1 = bit 7 bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7\nIRXIP: CAN Invalid Message Received Interrupt Priority bit\n1\n=\nHigh priority\n0 = Low priority\nbit 6\nWAKIP: CAN Bus Wake-Up Activity Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nERRIP: CAN Error Interrupt Priority bit (Multiple Sources in the COMSTAT Register)\n1 = High priority\n0 = Low priority\nbit 4 TXB2IP/TXBnIP: CAN Transmit Buffer 2/Transmit Buffer n Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nTXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2",
    "REGISTER 9-28: IPR5: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nTXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nRXB1IP/RXBnIP: CAN Receive Buffer 1/Receive Buffer n Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nRXB0IP/FIFOFIP: CAN Receive Buffer 0/FIFO Full Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-29: IPR6: PERIPHERAL INTERRUPT PRIORITY REGISTER 6\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. DMA2AIP, 1 = DMA2ORIP. DMA2AIP, 2 = DMA2DCNTIP. DMA2AIP, 3 = DMA2SCNTIP. DMA2AIP, 4 = SMT2PWAIP. DMA2AIP, 5 = SMT2PRAIP. DMA2AIP, 6 = SMT2IP. DMA2AIP, 7 = C2IP. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit",
    "REGISTER 9-29: IPR6: PERIPHERAL INTERRUPT PRIORITY REGISTER 6\n7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7\nDMA2AIP: DMA2 Abort Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 6\nDMA2ORIP: DMA2 Overrun Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nDMA2DCNTIP: DMA2 Destination Count Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4\nDMA2SCNTIP: DMA2 Source Count Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nSMT2PWAIP: SMT2 Pulse-Width Acquisition Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nSMT2PRAIP: SMT2 Period Acquisition Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nSMT2IP: SMT2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nC2IP: C2 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-30: IPR7: PERIPHERAL INTERRUPT PRIORITY REGISTER 7\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. U2IP, 1 = U2EIP. U2IP, 2 = U2TXIP. U2IP, 3 = U2RXIP. U2IP, 4 = I2C2EIP. U2IP, 5 = I2C2IP. U2IP, 6 = I2C2TXIP. U2IP, 7 = I2C2RXIP. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit",
    "REGISTER 9-30: IPR7: PERIPHERAL INTERRUPT PRIORITY REGISTER 7\n7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7\nU2IP: UART2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nU2EIP: UART2 Framing Error Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nU2TXIP: UART2 Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4\nU2RXIP: UART2 Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3",
    "REGISTER 9-30: IPR7: PERIPHERAL INTERRUPT PRIORITY REGISTER 7\nI2C2EIP: I 2 C2 Error Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nI2C2IP: I 2 C2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nI2C2TXIP: I 2 C2 Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nI2C2RXIP: TMR4 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-31: IPR8: PERIPHERAL INTERRUPT PRIORITY REGISTER 8\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. TMR5IP, 1 = INT2IP. TMR5IP, 2 = CLC2IP. TMR5IP, 3 = CWG2IP. TMR5IP, 4 = CCP2IP. TMR5IP, 5 = TMR4IP. TMR5IP, 6 = TMR3GIP. TMR5IP, 7 = TMR3IP. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit",
    "REGISTER 9-31: IPR8: PERIPHERAL INTERRUPT PRIORITY REGISTER 8\n7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7\nTMR5IP:\nTMR5 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nINT2IP: External Interrupt 2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nCLC2IP: CLC2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4",
    "REGISTER 9-31: IPR8: PERIPHERAL INTERRUPT PRIORITY REGISTER 8\nCWG2IP: CWG2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nCCP2IP: CCP2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nTMR4IP: TMR4 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 1\nTMR3GIP: TMR3 Gate Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nTMR3IP: TMR3 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-32: IPR9: PERIPHERAL INTERRUPT PRIORITY REGISTER 9\n-, R/W-1/1 = CLC4IP. -, R/W-1/1 = CCP4IP. -, R/W-1/1 = CLC3IP. -, R/W-1/1 = CWG3IP. -, R/W-1/1 = CCP3IP. -, R/W-1/1 = TMR6IP. -, R/W-1/1 = TMR5GIP. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 0",
    "REGISTER 9-32: IPR9: PERIPHERAL INTERRUPT PRIORITY REGISTER 9\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7\nUnimplemented: Read as ' 0 '\nbit 6\nCLC4IP: CLC4 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nCCP4IP: CCP4 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4\nCLC3IP: CLC3 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nCWG3IP: CWG3 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2",
    "REGISTER 9-32: IPR9: PERIPHERAL INTERRUPT PRIORITY REGISTER 9\nCCP3IP: CCP3 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR6IP: TMR6IP Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nTMR5GIP: TMR5 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-33: IVTBASEU: INTERRUPT VECTOR TABLE BASE ADDRESS UPPER REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = . -, 4 = . -, 5 = BASE<20:16>. -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 9-33: IVTBASEU: INTERRUPT VECTOR TABLE BASE ADDRESS UPPER REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-5, 1 = Unimplemented: Read as ' 0. bit 4-0, 1 = BASE<20:16> : Interrupt Vector Table Base Address bits",
    "REGISTER 9-34: IVTBASEH: INTERRUPT VECTOR TABLE BASE ADDRESS HIGH REGISTER\nbit 7, R/W-0/0.BASE<15:8> = . bit 7, R/W-0/0.BASE<15:8> = . bit 7, R/W-0/0.BASE<15:8> = . bit 7, R/W-0/0.BASE<15:8> = . bit 7, R/W-0/0.BASE<15:8> = . bit 7, R/W-0/0.BASE<15:8> = . bit 7, R/W-0/0.BASE<15:8> = bit 0",
    "REGISTER 9-34: IVTBASEH: INTERRUPT VECTOR TABLE BASE ADDRESS HIGH REGISTER\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = \nbit 7-0\nBASE<15:8> : Interrupt Vector Table Base Address bits",
    "REGISTER 9-35: IVTBASEL: INTERRUPT VECTOR TABLE BASE ADDRESS LOW REGISTER\nbit 7, R/W-0/0.BASE<7:0> = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-1/1. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-0\nBASE<7:0> : Interrupt Vector Table Base Address bits",
    "REGISTER 9-36: IVTADU: INTERRUPT VECTOR TABLE ADDRESS UPPER REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R-0/0. U-0, 4 = R-0/0. U-0, 5 = R-0/0. U-0, 6 = R-0/0. U-0, 7 = R-0/0. -, 1 = -. -, 2 = -. -, 3 = . -, 4 = . -, 5 = AD<20:16>. -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 9-36: IVTADU: INTERRUPT VECTOR TABLE ADDRESS UPPER REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-5, 1 = Unimplemented: Read as ' 0 '. bit 4-0, 1 = AD<20:16> : Interrupt Vector Table Address bits",
    "REGISTER 9-37: IVTADH: INTERRUPT VECTOR TABLE ADDRESS HIGH REGISTER\nbit 7, R-0/0.AD<15:8> = . bit 7, R-0/0.AD<15:8> = . bit 7, R-0/0.AD<15:8> = . bit 7, R-0/0.AD<15:8> = . bit 7, R-0/0.AD<15:8> = . bit 7, R-0/0.AD<15:8> = . bit 7, R-0/0.AD<15:8> = bit 0",
    "REGISTER 9-37: IVTADH: INTERRUPT VECTOR TABLE ADDRESS HIGH REGISTER\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = Resets. u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = \nbit 7-0\nAD<15:8> : Interrupt Vector Table Address bits",
    "REGISTER 9-38: IVTADL: INTERRUPT VECTOR TABLE ADDRESS LOW REGISTER\nbit 7, R-0/0. = . bit 7, R-0/0. = . bit 7, R-0/0.AD<7:0> = . bit 7, R-1/1. = . bit 7, R-0/0. = . bit 7, R-0/0. = . bit 7, R-0/0. = bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-0\nAD<7:0> : Interrupt Vector Table Address bits",
    "REGISTER 9-39: IVTLOCK: INTERRUPT VECTOR TABLE LOCK REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = IVTLOCKED (1,2). bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 9-39: IVTLOCK: INTERRUPT VECTOR TABLE LOCK REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = \nbit 7-1 Unimplemented: Read as ' 0 '\nbit 0\nIVTLOCKED : IVT Registers Lock bits (1,2)\n1 = IVTBASE Registers are locked and cannot be written\n0 = IVTBASE Registers can be modified by write operations\nNote 1: The IVTLOCK bit can only be set or cleared after the unlock sequence in Example 9-1.\n- 2: If IVT1WAY = 1 , the IVTLOCK bit cannot be cleared after it has been set. See Register 5-3.",
    "REGISTER 9-40: SHADCON: SHADOW CONTROL REGISTER\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-0/0 = SHADLO. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0",
    "REGISTER 9-40: SHADCON: SHADOW CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-1 Unimplemented: Read as ' 0 '\nbit 0\nSHADLO: Interrupt Shadow Register Access Switch bit\n0 = Access Main Context for Interrupt Shadow Registers\n1 = Access Low-Priority Interrupt Context for Interrupt Shadow Registers",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nINTCON0, Bit 7 = GIE/GIEH GIEL. INTCON0, Bit 6 = GIE/GIEH GIEL. INTCON0, Bit 5 = IPEN. INTCON0, Bit 4 = -. INTCON0, Bit 3 = -. INTCON0, Bit 2 = INT2EDG. INTCON0, Bit 1 = INT1EDG. INTCON0, Bit 0 = INT0EDG. INTCON0, Register on Page = 125. INTCON1, Bit 7 = STAT<1:0>. INTCON1, Bit 6 = STAT<1:0>. INTCON1, Bit 5 = -. INTCON1, Bit 4 = -. INTCON1, Bit 3 = -. INTCON1, Bit 2 = -. INTCON1, Bit 1 = -. INTCON1, Bit 0 = -. INTCON1, Register on Page = 126. PIE0, Bit 7 = IOCIE. PIE0, Bit 6 = CRCIE. PIE0, Bit 5 = SCANIE. PIE0, Bit 4 = NVMIE. PIE0, Bit 3 = CSWIE.",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nPIE0, Bit 2 = OSFIE. PIE0, Bit 1 = HLVDIE. PIE0, Bit 0 = SWIE. PIE0, Register on Page = 137. PIE1, Bit 7 = SMT1PWAIE. PIE1, Bit 6 = SMT1PRAIE. PIE1, Bit 5 = SMT1IE. PIE1, Bit 4 = C1IE. PIE1, Bit 3 = ADTIE. PIE1, Bit 2 = ADIE. PIE1, Bit 1 = ZCDIE. PIE1, Bit 0 = INT0IE. PIE1, Register on Page = 138. PIE2, Bit 7 = I2C1RXIE. PIE2, Bit 6 = SPI1IE. PIE2, Bit 5 = SPI1TXIE. PIE2, Bit 4 = SPI1RXIE. PIE2, Bit 3 = DMA1AIE. PIE2, Bit 2 = DMA1ORIE. PIE2, Bit 1 = DMA1DCNTIE. PIE2, Bit 0 = DMA1SCNTIE. PIE2, Register on Page = 139. PIE3, Bit 7",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\n= TMR0IE. PIE3, Bit 6 = U1IE. PIE3, Bit 5 = U1EIE. PIE3, Bit 4 = U1TXIE. PIE3, Bit 3 = U1RXIE. PIE3, Bit 2 = I2C1EIE. PIE3, Bit 1 = I2C1IE. PIE3, Bit 0 = I2C1TXIE. PIE3, Register on Page = 140. PIE4, Bit 7 = INT1IE. PIE4, Bit 6 = CLC1IE. PIE4, Bit 5 = CWG1IE. PIE4, Bit 4 = NCO1IE. PIE4, Bit 3 = CCP1IE. PIE4, Bit 2 = TMR2IE. PIE4, Bit 1 = TMR1GIE. PIE4, Bit 0 = TMR1IFE. PIE4, Register on Page = 141. PIE5, Bit 7 = IRXIE. PIE5, Bit 6 = WAKIE. PIE5, Bit 5 = ERRIE. PIE5, Bit 4 = TXB2IE/TXBnIE. PIE5, Bit 3 =",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nTXB1IE. PIE5, Bit 2 = TXB0IE. PIE5, Bit 1 = RXB1IE/RXBnIE. PIE5, Bit 0 = RXB0IE/FIFOFIE. PIE5, Register on Page = 142. PIE6, Bit 7 = DMA2AIE. PIE6, Bit 6 = DMA2ORIE. PIE6, Bit 5 = DMA2DCNTIE. PIE6, Bit 4 = DMA2SCNTIE. PIE6, Bit 3 = SMT2PWAIE. PIE6, Bit 2 = SMT2PRAIE. PIE6, Bit 1 = SMT2IE. PIE6, Bit 0 = C2IE. PIE6, Register on Page = 143. PIE7, Bit 7 = U2IE. PIE7, Bit 6 = U2EIE. PIE7, Bit 5 = U2TXIE. PIE7, Bit 4 = U2RXIE. PIE7, Bit 3 = I2C2EIE. PIE7, Bit 2 = I2C2IE. PIE7, Bit 1 = I2C2TXIE. PIE7,",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nBit 0 = I2C2RXIE. PIE7, Register on Page = 144. PIE8, Bit 7 = TMR5IE. PIE8, Bit 6 = INT2IE. PIE8, Bit 5 = CLC2IE. PIE8, Bit 4 = CWG2IE. PIE8, Bit 3 = CCP2IE. PIE8, Bit 2 = TMR4IE. PIE8, Bit 1 = TMR3GIE. PIE8, Bit 0 = TMR3IE. PIE8, Register on Page = 145. PIE9, Bit 7 = -. PIE9, Bit 6 = CLC4IE. PIE9, Bit 5 = CCP4IE. PIE9, Bit 4 = CLC3IE. PIE9, Bit 3 = CWG3IE. PIE9, Bit 2 = CCP3IE. PIE9, Bit 1 = TMR6IE. PIE9, Bit 0 = TMR5IE. PIE9, Register on Page = 146. PIR0, Bit 7 = IOCIF. PIR0, Bit 6 = CRCIF. PIR0, Bit 5 =",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nSCANIF. PIR0, Bit 4 = NVMIF. PIR0, Bit 3 = CSWIF. PIR0, Bit 2 = OSFIF. PIR0, Bit 1 = HLVDIF. PIR0, Bit 0 = SWIF. PIR0, Register on Page = 127. PIR1, Bit 7 = SMT1PWAIF. PIR1, Bit 6 = SMT1PRAIF. PIR1, Bit 5 = SMT1IF. PIR1, Bit 4 = C1IF. PIR1, Bit 3 = ADTIF. PIR1, Bit 2 = ADIF. PIR1, Bit 1 = ZCDIF. PIR1, Bit 0 = INT0IF. PIR1, Register on Page = 128. PIR2, Bit 7 = I2C1RXIF. PIR2, Bit 6 = SPI1IF. PIR2, Bit 5 = SPI1TXIF. PIR2, Bit 4 = SPI1RXIF. PIR2, Bit 3 = DMA1AIF. PIR2,",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nBit 2 = DMA1ORIF. PIR2, Bit 1 = DMA1DCNTIF. PIR2, Bit 0 = DMA1SCNTIF. PIR2, Register on Page = 129. PIR3, Bit 7 = TMR0IF. PIR3, Bit 6 = U1IF. PIR3, Bit 5 = U1EIF. PIR3, Bit 4 = U1TXIF. PIR3, Bit 3 = U1RXIF. PIR3, Bit 2 = I2C1EIF. PIR3, Bit 1 = I2C1IF. PIR3, Bit 0 = I2C1TXIF. PIR3, Register on Page = 130. PIR4, Bit 7 = INT1IF. PIR4, Bit 6 = CLC1IF. PIR4, Bit 5 = CWG1IF. PIR4, Bit 4 = NCO1IF. PIR4, Bit 3 = CCP1IF. PIR4, Bit 2 = TMR2IF. PIR4, Bit 1 =",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nTMR1GIF. PIR4, Bit 0 = TMR1IF. PIR4, Register on Page = 131. PIR5, Bit 7 = IRXIF. PIR5, Bit 6 = WAKIF. PIR5, Bit 5 = ERRIF. PIR5, Bit 4 = TXB2IF/TXBnIF. PIR5, Bit 3 = TXB1IF. PIR5, Bit 2 = TXB0IF. PIR5, Bit 1 = RXB1IF/RXBnIF. PIR5, Bit 0 = RXB0IF/FIFOFIF. PIR5, Register on Page = 132. PIR6, Bit 7 = DMA2AIF. PIR6, Bit 6 = DMA2ORIF. PIR6, Bit 5 = DMA2DCNTIF. PIR6, Bit 4 = DMA2SCNTIF. PIR6, Bit 3 = SMT2PWAIF. PIR6, Bit 2 = SMT2PRAIF. PIR6, Bit 1 = SMT2IF.",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nPIR6, Bit 0 = C2IF. PIR6, Register on Page = 133. PIR7, Bit 7 = U2IF. PIR7, Bit 6 = U2EIF. PIR7, Bit 5 = U2TXIF. PIR7, Bit 4 = U2RXIF. PIR7, Bit 3 = I2C2EIF. PIR7, Bit 2 = I2C2IF. PIR7, Bit 1 = I2C2TXIF. PIR7, Bit 0 = I2C2RXIF. PIR7, Register on Page = 134. PIR8, Bit 7 = TMR5IF. PIR8, Bit 6 = INT2IF. PIR8, Bit 5 = CLC2IF. PIR8, Bit 4 = CWG2IF. PIR8, Bit 3 = CCP2IF. PIR8, Bit 2 = TMR4IF. PIR8, Bit 1 = TMR3GIF. PIR8, Bit 0 = TMR3IF. PIR8, Register on Page = 135.",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nPIR9, Bit 7 = -. PIR9, Bit 6 = CLC4IF. PIR9, Bit 5 = CCP4IF. PIR9, Bit 4 = CLC3IF. PIR9, Bit 3 = CWG3IF. PIR9, Bit 2 = CCP3IF. PIR9, Bit 1 = TMR6IF. PIR9, Bit 0 = TMR5IF. PIR9, Register on Page = 136. IPR0, Bit 7 = IOCIP. IPR0, Bit 6 = CRCIP. IPR0, Bit 5 = SCANIP. IPR0, Bit 4 = NVMIP. IPR0, Bit 3 = CSWIP. IPR0, Bit 2 = OSFIP. IPR0, Bit 1 = HLVDIP. IPR0, Bit 0 = SWIP. IPR0, Register on Page = 147. IPR1, Bit 7 = SMT1PWAIP. IPR1, Bit 6 = SMT1PRAIP. IPR1, Bit 5 = SMT1IP.",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nIPR1, Bit 4 = C1IP. IPR1, Bit 3 = ADTIP. IPR1, Bit 2 = ADIP. IPR1, Bit 1 = ZCDIP. IPR1, Bit 0 = INT0IP. IPR1, Register on Page = 148. IPR2, Bit 7 = I2C1RIP. IPR2, Bit 6 = SPI1IP. IPR2, Bit 5 = SPI1TIP. IPR2, Bit 4 = SPI1RIP. IPR2, Bit 3 = DMA1AIP. IPR2, Bit 2 = DMA1ORIP. IPR2, Bit 1 = DMA1DCNTIP. IPR2, Bit 0 = DMA1SCNTIP. IPR2, Register on Page = 149. IPR3, Bit 7 = TMR0IP. IPR3, Bit 6 = U1IP. IPR3, Bit 5 = U1EIP. IPR3, Bit 4 = U1TXIP. IPR3, Bit 3 = U1RXIP. IPR3, Bit 2 =",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nI2C1EIP. IPR3, Bit 1 = I2C1IP. IPR3, Bit 0 = I2C1TXIP. IPR3, Register on Page = 150. IPR4, Bit 7 = INT1IP. IPR4, Bit 6 = CLC1IP. IPR4, Bit 5 = CWG1IP. IPR4, Bit 4 = NCO1IP. IPR4, Bit 3 = CCP1IP. IPR4, Bit 2 = TMR2IP. IPR4, Bit 1 = TMR1GIP. IPR4, Bit 0 = TMR1IP. IPR4, Register on Page = 151. IPR5, Bit 7 = IRXIP. IPR5, Bit 6 = WAKIP. IPR5, Bit 5 = ERRIP. IPR5, Bit 4 = TXB2IP/TXBnIP. IPR5, Bit 3 = TXB1IP. IPR5, Bit 2 = TXB0IP. IPR5, Bit 1 = RXB1IP/RXBnIP.",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nIPR5, Bit 0 = RXB0IP/FIFOFIP. IPR5, Register on Page = 152. IPR6, Bit 7 = DMA2AIP. IPR6, Bit 6 = DMA2ORIP. IPR6, Bit 5 = DMA2DCNTIP. IPR6, Bit 4 = DMA2SCNTIP. IPR6, Bit 3 = SMT2PWAIP. IPR6, Bit 2 = SMT2PRAIP. IPR6, Bit 1 = SMT2IP. IPR6, Bit 0 = C2IP. IPR6, Register on Page = 153. IPR7, Bit 7 = U2IP. IPR7, Bit 6 = U2EIP. IPR7, Bit 5 = U2TXIP. IPR7, Bit 4 = U2RXIP. IPR7, Bit 3 = I2C2EIP. IPR7, Bit 2 = I2C2IP. IPR7, Bit 1 = I2C2TXIP. IPR7, Bit 0 = I2C2RXIP.",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nIPR7, Register on Page = 154. IPR8, Bit 7 = TMR5IP. IPR8, Bit 6 = INT2IP. IPR8, Bit 5 = CLC2IP. IPR8, Bit 4 = CWG2IP. IPR8, Bit 3 = CCP2IP. IPR8, Bit 2 = TMR4IP. IPR8, Bit 1 = TMR3GIP. IPR8, Bit 0 = TMR3IP. IPR8, Register on Page = 155. IPR9, Bit 7 = -. IPR9, Bit 6 = CLC4IP. IPR9, Bit 5 = CCP4IP. IPR9, Bit 4 = CLC3IP. IPR9, Bit 3 = CWG3IP. IPR9, Bit 2 = CCP3IP. IPR9, Bit 1 = TMR6IP. IPR9, Bit 0 = TMR5IP. IPR9, Register on Page = 156. IVTBASEU, Bit 7 = -. IVTBASEU, Bit 6 =",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\n-. IVTBASEU, Bit 5 = -. IVTBASEU, Bit 4 = . IVTBASEU, Bit 3 = . IVTBASEU, Bit 2 = BASE<20:16>. IVTBASEU, Bit 1 = . IVTBASEU, Bit 0 = . IVTBASEU, Register on Page = 157. IVTBASEH, Bit 7 = BASE<15:8>. IVTBASEH, Bit 6 = BASE<15:8>. IVTBASEH, Bit 5 = BASE<15:8>. IVTBASEH, Bit 4 = BASE<15:8>. IVTBASEH, Bit 3 = BASE<15:8>. IVTBASEH, Bit 2 = BASE<15:8>. IVTBASEH, Bit 1 = BASE<15:8>. IVTBASEH, Bit 0 = BASE<15:8>. IVTBASEH, Register on Page = 157. IVTBASEL, Bit 7 = BASE<7:0>. IVTBASEL, Bit 6 = BASE<7:0>. IVTBASEL, Bit 5 =",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nBASE<7:0>. IVTBASEL, Bit 4 = BASE<7:0>. IVTBASEL, Bit 3 = BASE<7:0>. IVTBASEL, Bit 2 = BASE<7:0>. IVTBASEL, Bit 1 = BASE<7:0>. IVTBASEL, Bit 0 = BASE<7:0>. IVTBASEL, Register on Page = 157. IVTADU, Bit 7 = - AD<20:16>. IVTADU, Bit 6 = -. IVTADU, Bit 5 = -. IVTADU, Bit 4 = - AD<20:16>. IVTADU, Bit 3 = - AD<20:16>. IVTADU, Bit 2 = - AD<20:16>. IVTADU, Bit 1 = - AD<20:16>. IVTADU, Bit 0 = - AD<20:16>. IVTADU, Register on Page = 158. IVTADH, Bit 7 = AD<15:8> AD<7:0>. IVTADH, Bit 6 = AD<15:8>",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\nAD<7:0>. IVTADH, Bit 5 = AD<15:8> AD<7:0>. IVTADH, Bit 4 = AD<15:8> AD<7:0>. IVTADH, Bit 3 = AD<15:8> AD<7:0>. IVTADH, Bit 2 = AD<15:8> AD<7:0>. IVTADH, Bit 1 = AD<15:8> AD<7:0>. IVTADH, Bit 0 = AD<15:8> AD<7:0>. IVTADH, Register on Page = 158. IVTADL, Bit 7 = . IVTADL, Bit 6 = . IVTADL, Bit 5 = . IVTADL, Bit 4 = . IVTADL, Bit 3 = . IVTADL, Bit 2 = . IVTADL, Bit 1 = . IVTADL, Bit 0 = . IVTADL, Register on Page = 158. IVTLOCK, Bit 7 = -. IVTLOCK, Bit 6 = -. IVTLOCK, Bit 5 = -. IVTLOCK, Bit 4",
    "TABLE 9-3: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPTS\n= -. IVTLOCK, Bit 3 = -. IVTLOCK, Bit 2 = -. IVTLOCK, Bit 1 = -. IVTLOCK, Bit 0 = IVTLOCKED. IVTLOCK, Register on Page = 159\nLegend:\n- = unimplemented locations, read as ' 0 '. Shaded bits are not used for interrupts.",
    "10.0 POWER-SAVING OPERATION MODES\nThe purpose of the Power-Down modes is to reduce power  consumption.  There  are  three  Power-Down modes:\n\u00b7 Doze mode\n\u00b7 Sleep mode\n\u00b7 Idle mode",
    "10.1 Doze Mode\nDoze mode allows for power saving by reducing CPU operation and program memory (PFM) access, without affecting peripheral operation. Doze mode differs from Sleep mode because the bandgap and system oscillators continue to operate, while only the CPU and PFM are affected. The reduced execution saves power by eliminating unnecessary operations within the CPU and memory.\nratio  is  1:4.  The  CPU  and  memory  execute  for  one instruction cycle and then lay idle for three instruction cycles.  During  the  unused  cycles,  the  peripherals continue to operate at the system clock speed.",
    "10.1.1 DOZE OPERATION\nThe Doze  operation  is  illustrated  in  Figure 10-1.  For this example:\n\u00b7 Doze enable (DOZEN) bit set (DOZEN = 1 )\n\u00b7 DOZE<2:0> = 001 (1:4) ratio\n\u00b7 Recover-on-Interrupt (ROI) bit set (ROI = 1 )\nAs with normal operation, the PFM fetches for the next instruction cycle.  The  Q-clocks  to  the  peripherals continue throughout.\nWhen the Doze Enable (DOZEN) bit is set (DOZEN = 1 ),  the CPU executes only one instruction cycle out of every N  cycles as defined by the DOZE<2:0>  bits of the CPUDOZE  register. For example,  if  DOZE<2:0>  = 001 ,  the  instruction  cycle",
    "FIGURE 10-1: DOZE MODE OPERATION EXAMPLE (DOZE<2:0> = 001 , 1:4)\nNote 1: Multicycle instructions are executed to completion before fetching the interrupt vector.\n- 2: If the prefetched instruction clears the interrupt enable or GIEx, ISR vectoring will not occur, but DOZEN is cleared and the CPU will resume execution at full speed.",
    "10.1.2 INTERRUPTS DURING DOZE\nIf an interrupt occurs and the Recover-On-Interrupt bit is  clear  (ROI = 0 ) at  the  time  of  the  interrupt,  the Interrupt Service Routine (ISR) continues to execute at the rate selected by  DOZE<2:0>. Interrupt latency is extended by the DOZE<2:0> ratio.\nIf an interrupt occurs and the ROI bit is set (ROI = 1 ) at the time of the interrupt, the DOZEN bit is cleared and the CPU executes at full speed. The prefetched instruc -tion is executed and then the interrupt vector sequence is executed. In Figure 10-1, the interrupt occurs during the 2 nd  instruction cycle of the Doze period, and imme -diately brings the CPU out of Doze. If the Doze-On-Exit (DOE) bit is set (DOE = 1 ) when the RETFIE operation is executed, DOZEN is set, and the CPU executes at the reduced rate based on the DOZE<2:0> ratio.",
    "EXAMPLE 10-1: DOZE SOFTWARE EXAMPLE\n```\n//Mainline operation bool somethingToDo = FALSE: void main() { initializeSystem(); // DOZE = 64:1 (for example) // ROI = 1; GIE = 1; // enable interrupts while (1) { // If ADC completed, process data if (somethingToDo) { doSomething(); DOZEN = 1; // resume low-power } } } // Data interrupt handler void interrupt() { // DOZEN = 0 because ROI = 1 if (ADIF) { somethingToDo = TRUE; DOE = 0; // make main() go fast ADIF = 0; } // else check other interrupts... if (TMR0IF) { timerTick++; DOE = 1; // make main() go slow TMR0IF = 0; } }\n```",
    "10.2 Sleep Mode\nSleep  mode  is  entered  by  executing  the SLEEP instruction,  while  the  Idle  Enable  (IDLEN)  bit  of  the CPUDOZE register is clear (IDLEN = 0 ).\nUpon  entering  Sleep  mode,  the  following  conditions exist:\n1. WDT  will  be  cleared  but  keeps  running  if enabled for operation during Sleep\n2. The PD bit of  the  STATUS  register  is  cleared (Register 4-2)\n3. The  TO  bit  of  the  STATUS  register  is  set (Register 4-2)\n4. The CPU clock is disabled\n5. LFINTOSC,  SOSC,  HFINTOSC  and  ADCRC are unaffected and peripherals using them may continue operation in Sleep.\n6. I/O  ports  maintain  the  status  they  had  before Sleep was executed (driving high, low, or highimpedance)\n7. Resets  other  than  WDT  are  not  affected  by Sleep mode\nRefer to individual chapters for more  details on peripheral operation during Sleep.\nTo minimize current consumption, the following conditions should be considered:\n-I/O pins should not be floating\n-External circuitry sinking current from I/O pins\n-Internal circuitry sourcing current from I/O pins\n-Current draw from pins with internal weak pull-ups\n-Modules using any oscillator",
    "10.2 Sleep Mode\nI/O  pins  that  are  high-impedance  inputs  should  be pulled  to  VDD  or  VSS  externally  to  avoid  switching currents caused by floating inputs.\nExamples of internal  circuitry  that  might  be  sourcing current  include  modules  such  as  the  DAC  and  FVR modules. See Section 38.0 '5-Bit Digital-to-Analog Converter (DAC) Module' and Section 35.0 'Fixed Voltage  Reference  (FVR)' for  more  information  on these modules.",
    "10.2.1 WAKE-UP FROM SLEEP\nThe device can wake up from Sleep through one of the following events:\n1. External Reset input on MCLR pin, if enabled\n2. BOR Reset, if enabled\n3. Low-Power Brown-Out Reset (LPBOR), if enabled\n4. POR Reset\n5. Windowed Watchdog Timer, if enabled\n6. All interrupt sources except clock switch interrupt can wake up the part.\nThe first five events will cause a device Reset. The last one  event  is  considered  a  continuation  of  program execution.  To  determine  whether  a  device  Reset  or wake-up event occurred, refer to Section 6.13 'Power Control (PCON0/PCON1) Register' .",
    "10.2.1 WAKE-UP FROM SLEEP\nWhen the SLEEP instruction is being executed, the next instruction  (PC  +  2)  is  prefetched.  For  the  device  to wake-up through an interrupt event, the corresponding Interrupt  Enable  bit  must  be  enabled.  Wake-up  will occur regardless of the state of the GIE bit. If the GIE bit  is  disabled,  the  device continues execution at the instruction after the SLEEP instruction. If the GIE bit is enabled, the device executes the instruction after the SLEEP instruction, the device will then call the Interrupt Service Routine. In cases where the execution of the instruction following SLEEP is  not  desirable,  the  user should have a NOP after the SLEEP instruction.\nThe WDT is cleared when the device wakes-up from Sleep, regardless of the source of wake-up.\nUpon a wake from a Sleep event, the core will wait for a  combination  of  three  conditions  before  beginning execution. The conditions are:\n\u00b7 PFM Ready\n\u00b7 COSC-Selected Oscillator Ready\n\u00b7 BOR Ready (unless BOR is disabled)",
    "10.2.2 WAKE-UP USING INTERRUPTS\nWhen any interrupt source, with the exception of the clock switch interrupt, has both its interrupt enable bit and interrupt flag bit set, one of the following will occur:\n\u00b7 If the interrupt occurs before the execution of a SLEEP instruction\n-SLEEP instruction will execute as a NOP\n-WDT and WDT prescaler will not be cleared\n-TO bit of the STATUS register will not be set\n-PD bit of the STATUS register will not be cleared\n\u00b7 If the interrupt occurs during or after the execution of a SLEEP instruction\n-SLEEP instruction will be completely executed\n-Device will immediately wake-up from Sleep\n-WDT and WDT prescaler will be cleared\n-TO bit of the STATUS register will be set\n-PD bit of the STATUS register will be cleared\nEven if the flag bits were checked before executing a SLEEP instruction,  it  may  be  possible  for  flag  bits  to become set before the SLEEP instruction completes. To determine whether a SLEEP instruction executed, test the PD bit. If the PD bit is set, the SLEEP instruction was executed as a NOP .",
    "10.2.3.1 Sleep Current vs. Wake-up Time\nThe PIC18F25/26K83 device family contains an internal  Low  Dropout  (LDO)  voltage  regulator,  which allows the device I/O pins to operate at voltages up to 5.5V while the internal device logic operates at a lower voltage. The LDO and its associated reference circuitry must remain active when the device is in Sleep mode.\nThe  PIC18F25/26K83  devices  allows  the  user  to optimize the operating current in Sleep, depending on the application requirements.\nLow-Power Sleep mode can be selected by setting the VREGPM bit of the VREGCON register.\nIn the default operating mode, the LDO and reference circuitry  remain  in  the  normal  configuration  while  in Sleep. The device is able to exit Sleep mode quickly since  all  circuits  remain  active.  In  Low-Power  Sleep mode, when waking-up from Sleep, an extra delay time is  required  for  these  circuits  to  return  to  the  normal configuration and stabilize.\nThe Low-Power Sleep mode is beneficial for applications that stay in Sleep mode for long periods of time.  The  Normal  mode  is  beneficial  for  applications that need to wake from Sleep quickly and frequently.",
    "10.2.3.2 Peripheral Usage in Sleep\nSome peripherals that can operate in Sleep mode will not operate properly with the Low-Power Sleep mode selected. The Low-Power Sleep mode is intended for use with these peripherals:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Windowed Watchdog Timer (WWDT)\n\u00b7 External interrupt pin/Interrupt-On-Change pins\n\u00b7 Peripherals that run off external secondary clock source\nIt is the responsibility of the end user to determine what is  acceptable  for  their  application  when  setting  the VREGPM  settings  in  order  to  ensure  operation  in Sleep.",
    "Note:\nThe  PIC18LF25/26K83  devices  do  not have  a  configurable  Low-Power  Sleep mode. PIC18LF25/26K83 devices are unregulated and are always in the lowest power state when in Sleep, with no wakeup  time  penalty.  These  devices  have  a lower maximum VDD and I/O voltage than the  PIC18F25/26K83  devices.  See Sec -tion 45.0 'Electrical Specifications' for more information.",
    "10.2.4 IDLE MODE\nWhen IDLEN is set (IDLEN = 1 ), the SLEEP instruction will  put  the  device  into  Idle  mode.  In  Idle  mode,  the CPU  and  memory  operations  are  halted,  but  the peripheral clocks continue to run. This mode is similar to Doze mode, except that in IDLE both the CPU and PFM are shut off.\nNote:\nIf CLKOUTEN is enabled (CLKOUTEN = 0 , Configuration Word 1H), the output will con -tinue operating while in Idle.",
    "10.2.4.1 Idle and Interrupts\nIDLE mode ends when an interrupt occurs (even if GIE = 0 ),  but  IDLEN  is  not  changed. The device  can reenter IDLE by executing the SLEEP instruction.\n- If Recover-On-Interrupt  is  enabled  (ROI  = 1 ), the interrupt that brings the device out of Idle also restores full-speed CPU execution when doze is also enabled.",
    "10.2.4.2 Idle and WWDT\nWhen  in  Idle,  the  WWDT  Reset  is  blocked  and  will instead wake the device. The WWDT wake-up is not an interrupt, therefore ROI does not apply.",
    "Note:\nThe WDT can bring the device out of Idle, in the same way it brings the device out of Sleep. The DOZEN bit is not affected.",
    "10.3 Peripheral Operation in Power Saving Modes\nAll selected clock sources and the peripherals running off them are active in both IDLE and DOZE mode. Only in Sleep mode, both the FOSC and FOSC/4 clocks are unavailable. All  the  other  clock  sources  are  active,  if enabled manually or through peripheral clock selection before the part enters Sleep.",
    "REGISTER 10-1: VREGCON: VOLTAGE REGULATOR CONTROL REGISTER (1)\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-0/0 = VREGPM. -, R/W-1/1 = Reserved. bit 7, U-0 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, R/W-0/0 = . bit 7, R/W-1/1 = bit 0",
    "REGISTER 10-1: VREGCON: VOLTAGE REGULATOR CONTROL REGISTER (1)\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "bit 7-2 Unimplemented: Read as ' 0 '\nbit 1\nVREGPM: Voltage Regulator Power Mode Selection bit\n1 = Low-Power Sleep mode enabled in Sleep (2)\nDraws lowest current in Sleep, slower wake-up\n0 = Normal Power mode enabled in Sleep (2) Draws higher current in Sleep, faster wake-up\nbit 0 Reserved: Read as ' 1 '. Maintain this bit set.\nNote 1: Not present in LF parts.\n- 2: See Section 45.0 'Electrical Specifications' .",
    "REGISTER 10-2: CPUDOZE: DOZE AND IDLE REGISTER\nIDLEN, R/W/HC/HS-0/0 = DOZEN. IDLEN, R/W-0/0 = ROI. IDLEN, R/W-0/0 = DOE. IDLEN, U-0 = -. IDLEN, R/W-0/0 = DOZE<2:0>. IDLEN, R/W-0/0 = DOZE<2:0>. IDLEN, R/W-0/0 = DOZE<2:0>. bit 7, R/W/HC/HS-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 10-2: CPUDOZE: DOZE AND IDLE REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = HC = Bit is cleared by hardware",
    "bit 7 IDLEN: Idle Enable bit\n1 = A SLEEP instruction inhibits the CPU clock, but not the peripheral clock(s)\n0 = A SLEEP instruction places the device into full Sleep mode",
    "bit 6\nDOZEN: Doze Enable bit (1,2)\n1 = The CPU executes instruction cycles according to DOZE setting\n0 = The CPU executes all instruction cycles (fastest, highest power operation)",
    "bit 5 ROI: Recover-On-Interrupt bit\n1 = Entering the Interrupt Service Routine (ISR) makes DOZEN = 0 bit, bringing the CPU to full-speed operation\n0 = Interrupt entry does not change DOZEN",
    "bit 4\nDOE: Doze-On-Exit bit\n1 = Executing RETFIE makes DOZEN = 1 , bringing the CPU to reduced speed operation\n0 = RETFIE does not change DOZEN",
    "bit 3 Unimplemented: Read as ' 0 '\nbit 2-0\nDOZE<2:0>: Ratio of CPU Instruction Cycles to Peripheral Instruction Cycles\n111 =1:256\n110 =1:128\n101 =1:64\n100 =1:32\n011 =1:16\n010 =1:8\n001 =1:4\n000 =1:2\nNote 1: When ROI = 1 or DOE = 1 , DOZEN is changed by hardware interrupt entry and/or exit.\n2: Entering ICD overrides DOZEN, returning the CPU to full execution speed; this bit is not affected.",
    "TABLE 10-1: SUMMARY OF REGISTERS ASSOCIATED WITH POWER-DOWN MODE\nVREGCON (1), Bit 7 = -. VREGCON (1), Bit 6 = -. VREGCON (1), Bit 5 = -. VREGCON (1), Bit 4 = -. VREGCON (1), Bit 3 = -. VREGCON (1), Bit 2 = -. VREGCON (1), Bit 1 = VREGPM. VREGCON (1), Bit 0 = Reserved. VREGCON (1), Register on Page = 166. CPUDOZE, Bit 7 = IDLEN. CPUDOZE, Bit 6 = DOZEN. CPUDOZE, Bit 5 = ROI. CPUDOZE, Bit 4 = DOE. CPUDOZE, Bit 3 = -. CPUDOZE, Bit 2 = DOZE<2:0>. CPUDOZE, Bit 1 = DOZE<2:0>. CPUDOZE, Bit 0 = DOZE<2:0>. CPUDOZE, Register on Page = 167\nLegend:\n- = unimplemented location, read as ' 0 '. Shaded cells are not used in Power-Down mode.",
    "TABLE 10-1: SUMMARY OF REGISTERS ASSOCIATED WITH POWER-DOWN MODE\nNote 1: Not present in LF parts.",
    "11.0 WINDOWED WATCHDOG TIMER (WWDT)\nThe  Watchdog  Timer  (WDT)  is  a  system  timer  that generates  a  Reset  if  the  firmware  does  not  issue  a CLRWDT instruction  within  the  time-out  period.  The Watchdog Timer is typically used to recover the system from  unexpected  events.  The  Windowed  Watchdog Timer (WWDT) differs in that CLRWDT instructions are only  accepted  when  they  are  performed  within  a specific window during the time-out period.\nThe WWDT has the following features:\n\u00b7 Selectable clock source\n\u00b7 Multiple operating modes\n-WWDT is always On\n-WWDT is off when in Sleep\n-WWDT is controlled by software\n-WWDT is always Off\n\u00b7 Configurable time-out period is from 1 ms to 256s (nominal)\n\u00b7 Configurable window size from 12.5% to 100% of the time-out period\n\u00b7 Multiple Reset conditions",
    "11.1 Independent Clock Source\nThe WWDT can derive its time base from either the 31 kHz LFINTOSC or 31.25 kHz MFINTOSC internal oscillators,  depending  on  the  value  of  WDTE<1:0> Configuration bits.\nIf WDTE = 0b1x , then the clock source will be enabled depending on the WDTCCS<2:0> Configuration bits.\nIf WDTE = 0b01 , the SEN bit should be set by software to enable WWDT, and the clock source is enabled by the CS bits in the WDTCON1 register.\nTime intervals in this chapter are based on a minimum nominal interval of 1 ms. See Section 45.0 'Electrical Specifications' for LFINTOSC and MFINTOSC tolerances.",
    "11.2 WWDT Operating Modes\nThe  Windowed  Watchdog  Timer  module  has  four operating modes controlled by the WDTE<1:0> bits in Configuration Words. See Table 11-1.",
    "11.2.1 WWDT IS ALWAYS ON\nWhen the WDTE bits of Configuration Words are set to ' 11 ', the WWDT is always on.\nWWDT protection is active during Sleep.",
    "11.2.2 WWDT IS OFF IN SLEEP\nWhen the WDTE bits of Configuration Words are set to ' 10 ', the WWDT is on, except in Sleep.\nWWDT protection is not active during Sleep.",
    "11.2.3 WWDT CONTROLLED BY SOFTWARE\nWhen the WDTE bits of Configuration Words are set to ' 01 ',  the  WWDT  is  controlled  by  the  SEN  bit  of  the WDTCON0 register.\nWWDT  protection is unchanged by Sleep. See Table 11-1 for more details.",
    "TABLE 11-1: WWDT OPERATING MODES\n11, SEN = X. 11, Device Mode = X. 11, WWDT Mode = Active. 10, SEN = X. 10, Device Mode = Awake. 10, WWDT Mode = Active. 10, SEN = X. 10, Device Mode = Sleep. 10, WWDT Mode = Disabled. 01, SEN = 1. 01, Device Mode = X. 01, WWDT Mode = Active. 01, SEN = 0. 01, Device Mode = X. 01, WWDT Mode = Disabled. 00, SEN = X. 00, Device Mode = X. 00, WWDT Mode = Disabled",
    "11.3 Time-out Period\nIf the  WDTCPS<4:0>  Configuration  bits  default  to 0b11111 , then the PS bits of the WDTCON0 register set  the  time-out  period  from  1 ms  to  256 seconds (nominal). If any value other than the default value is assigned  to  WDTCPS<4:0>  Configuration  bits,  then the timer period will be based on the WDTCPS<4:0> bits  in  the  CONFIG3L  register.  After  a  Reset,  the default time-out period is 2s.",
    "11.4 Watchdog Window\nThe Windowed  Watchdog  Timer  has an optional Windowed mode that is controlled by the WDTCWS<2:0> Configuration bits and WINDOW<2:0> bits of the WDTCON1 register. In the Windowed mode, the CLRWDT instruction  must  occur  within  the  allowed window of the WDT period. Any CLRWDT instruction that occurs  outside  of  this  window  will  trigger  a  window violation  and  will  cause  a  WWDT  Reset,  similar  to  a WWDT time out. See Figure 11-2 for an example.\nThe window size is controlled by the WINDOW<2:0> Configuration bits, or the WINDOW<2:0>  bits  of WDTCON1, if WDTCWS<2:0> = 111 .\nThe five Most Significant bits of the WDTTMR register are used to determine whether the window is open, as defined by the WINDOW<2:0> bits of the WDTCON1 register.\nIn  the  event  of  a  window  violation,  a  Reset  will  be generated and the WDTWV bit of the PCON0 register will be cleared. This bit is set by a POR or can be set in firmware.",
    "11.5 Clearing the WWDT\nThe  WWDT  is  cleared  when  any  of  the  following conditions occur:\n\u00b7 Any Reset\n\u00b7 Valid CLRWDT instruction is executed\n\u00b7 Device enters Sleep\n\u00b7 Exit Sleep by Interrupt\n\u00b7 WWDT is disabled\n\u00b7 Oscillator Start-up Timer (OST) is running\n\u00b7 Any write to the WDTCON0 or WDTCON1 registers",
    "11.5.1 CLRWDT CONSIDERATIONS (WINDOWED MODE)\nWhen in Windowed mode, the WWDT must be armed before a CLRWDT instruction will clear the timer. This is performed by reading the WDTCON0 register. Executing  a CLRWDT instruction  without  performing such an arming action will trigger a window violation regardless of whether the window is open or not.\nSee Table 11-2 for more information.",
    "11.6 Operation During Sleep\nWhen the device enters Sleep, the WWDT is cleared. If  the  WWDT  is  enabled  during  Sleep,  the  WWDT resumes counting. When the device exits Sleep, the WWDT is cleared again.\nThe WWDT remains clear until the Oscillator Start-up Timer  (OST)  completes,  if  enabled.  See Section 7.2.1.3 'Oscillator  Start-up  Timer  (OST)' for  more information on the OST.\nWhen a WWDT time-out occurs while the device is in Sleep,  no  Reset  is  generated.  Instead,  the  device wakes up and resumes operation. The TO and PD bits in  the  STATUS  register  are  changed  to  indicate  the event. The RWDT bit in the PCON0 register can also be used.  See Section  4.0 'Memory  Organization' for more information.",
    "TABLE 11-2: WWDT CLEARING CONDITIONS\nWDTE<1:0> = 00, WWDT = Cleared. WDTE<1:0> = 01 and SEN = 0, WWDT = Cleared. WDTE<1:0> = 10 and enter Sleep, WWDT = Cleared. CLRWDT Command, WWDT = Cleared. Oscillator Fail Detected, WWDT = Cleared. Exit Sleep + System Clock = SOSC, EXTRC, INTOSC, EXTCLK, WWDT = Cleared. Exit Sleep + System Clock = XT, HS, LP, WWDT = Cleared until the end of OST. Change INTOSC divider (IRCF bits), WWDT = Unaffected",
    "REGISTER 11-1: WDTCON0: WATCHDOG TIMER CONTROL REGISTER 0\n-, U-0 = -. -, R/W (3) -q/q (2) = . -, R/W (3) -q/q (2) = . -, R/W (3) -q/q (2) = PS<4:0>. -, R/W (3) -q/q (2) = . -, R/W (3) -q/q (2) = . -, R/W-0/0 = SEN. bit 7, U-0 = . bit 7, R/W (3) -q/q (2) = . bit 7, R/W (3) -q/q (2) = . bit 7, R/W (3) -q/q (2) = . bit 7, R/W (3) -q/q (2) = . bit 7, R/W (3) -q/q (2) = . bit 7, R/W-0/0 = bit 0",
    "REGISTER 11-1: WDTCON0: WATCHDOG TIMER CONTROL REGISTER 0\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = q = Value depends on condition",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5-1\nPS<4:0>:\nWatchdog Timer Prescale Select bits\nBit Value\n= Prescale Rate\n11111 =\nReserved. Results in minimum interval (1:32)\n\u2022\n\u2022\n\u2022\n10011 =\nReserved. Results in minimum interval (1:32)\n10010 =\n1:8388608 (2 23 ) (Interval 256s nominal)\n10001 =\n1:4194304 (2 22 ) (Interval 128s nominal)\n10000 =\n1:2097152 (2 21 ) (Interval 64s nominal)\n01111 =\n1:1048576 (2 20 ) (Interval 32s nominal)\n01110 =\n1:524288 (2 19 ) (Interval 16s nominal)\n01101 =\n1:262144 (2 18 ) (Interval 8s nominal)\n01100 =\n1:131072 (2 17 ) (Interval 4s nominal)\n01011 =\n1:65536 (Interval 2s nominal) (Reset value)\n01010\n=\n1:32768 (Interval 1s nominal)\n01001 =",
    "bit 7-6 Unimplemented: Read as ' 0 '\n1:16384 (Interval 512 ms nominal)\n01000 = 1:8192 (Interval 256 ms nominal)\n00111 = 1:4096 (Interval 128 ms nominal)\n00110 = 1:2048 (Interval 64 ms nominal)\n00101 = 1:1024 (Interval 32 ms nominal)\n00100 = 1:512 (Interval 16 ms nominal)\n00011 = 1:256 (Interval 8 ms nominal)\n00010 =\n1:128 (Interval 4 ms nominal)\n00001\n= 1:64 (Interval 2 ms nominal)\n00000 =\n1:32 (Interval 1 ms nominal)",
    "bit 0\nNote\n(1)\nSEN: Software Enable/Disable for Watchdog Timer bit\nIf WDTE<1:0> = 1x :\nThis bit is ignored.\nIf WDTE<1:0> = 01 :\n1 = WDT is turned on\n0 = WDT is turned off\nIf WDTE<1:0> = 00 :\nThis bit is ignored.\n1: Times are approximate. WDT time is based on 31 kHz LFINTOSC.\n2: When WDTCPS <4:0> in CONFIG3L = 11111 , the Reset value of PS<4:0> is 01011 . Otherwise, the Reset value of PS<4:0> is equal to WDTCPS<4:0> in CONFIG3L.\n3: When WDTCPS <4:0> in CONFIG3L \u2260 11111 , these bits are read-only.",
    "bit 0\n4: When the WWDT is configured to run using the SOSC as a clock source and the device is allowed to undergo a Reset, as triggered by a WDT time-out, the SOSC would also undergo a Reset. That means the SOSC will execute its start-up sequence which requires 1024 SOSC clock counts before it is made available for peripherals to use. So for example, if the WDT is set for a 1 ms time-out and the device is allowed to undergo a WDT Reset, then the actual WDT Reset period will be: WDT_PERIOD = (1/(SOSC_FREQUENCY) * 1024) + 1 ms.",
    "REGISTER 11-2: WDTCON1: WATCHDOG TIMER CONTROL REGISTER 1\nU-0, 1 = R/W (3) -q/q (1) R/W (3) -q/q (1) R/W (3) -q/q (1). U-0, 2 = U-0. U-0, 3 = R/W (4) -q/q (2). U-0, 4 = R/W (4) -q/q (2). U-0, 5 = R/W (4) -q/q (2). -, 1 = CS<2:0>. -, 2 = -. -, 3 = WINDOW<2:0>. -, 4 = WINDOW<2:0>. -, 5 = WINDOW<2:0>. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 0",
    "REGISTER 11-2: WDTCON1: WATCHDOG TIMER CONTROL REGISTER 1\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = q = Value depends on condition",
    "bit 6-4 CS<2:0>: Watchdog Timer Clock Select bits\n111 = Reserved\n\u2022\n\u2022\n\u2022\n011 = Reserved\n010\n= SOSC\n001 = MFINTOSC 31.25 kHz\n000 = LFINTOSC 31 kHz",
    "bit 2-0 WINDOW<2:0>: Watchdog Timer Window Select bits\n111, Window delay Percent of time = N/A. 111, Window opening Percent of time = 100. 110, Window delay Percent of time = 12.5. 110, Window opening Percent of time = 87.5. 101, Window delay Percent of time = 25. 101, Window opening Percent of time = 75. 100, Window delay Percent of time = 37.5. 100, Window opening Percent of time = 62.5. 011, Window delay Percent of time = 50. 011, Window opening Percent of time = 50. 010, Window delay Percent of time = 62.5. 010, Window opening Percent of time = 37.5. 001, Window delay Percent of time = 75. 001, Window opening Percent of time = 25. 000, Window delay Percent of time = 87.5. 000, Window opening Percent of time = 12.5\nNote 1: If WDTCCS <2:0> in CONFIG3H = 111 , the Reset value of CS<2:0> is 000 .",
    "bit 2-0 WINDOW<2:0>: Watchdog Timer Window Select bits\n2: The Reset value of WINDOW<2:0> is determined by the value of WDTCWS<2:0> in the CONFIG3H register.\n3: If WDTCCS<2:0> in CONFIG3H \u2260 111 , these bits are read-only.\n4: If WDTCWS<2:0> in CONFIG3H \u2260 111 , these bits are read-only.",
    "REGISTER 11-3: WDTPSL: WWDT PRESCALE SELECT LOW BYTE REGISTER (READ-ONLY)\nbit 7, R-0/0.PSCNT<7:0> = . bit 7, R-0/0.PSCNT<7:0> = . bit 7, R-0/0.PSCNT<7:0> = . bit 7, R-0/0.PSCNT<7:0> = . bit 7, R-0/0.PSCNT<7:0> = . bit 7, R-0/0.PSCNT<7:0> = . bit 7, R-0/0.PSCNT<7:0> = bit 0",
    "REGISTER 11-3: WDTPSL: WWDT PRESCALE SELECT LOW BYTE REGISTER (READ-ONLY)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = \nbit 7-0 PSCNT<7:0>: Prescale Select Low Byte bits (1)\nNote 1: The 18-bit WDT prescale value, PSCNT<17:0> includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT<17:0> is intended for debug operations and should not be read during normal operation.",
    "REGISTER 11-4: WDTPSH: WWDT PRESCALE SELECT HIGH BYTE REGISTER (READ-ONLY)\nbit 7, R-0/0.PSCNT<15:8> = . bit 7, R-0/0.PSCNT<15:8> = . bit 7, R-0/0.PSCNT<15:8> = . bit 7, R-0/0.PSCNT<15:8> = . bit 7, R-0/0.PSCNT<15:8> = . bit 7, R-0/0.PSCNT<15:8> = . bit 7, R-0/0.PSCNT<15:8> = bit 0",
    "REGISTER 11-4: WDTPSH: WWDT PRESCALE SELECT HIGH BYTE REGISTER (READ-ONLY)\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = \nbit 7-0\nPSCNT<15:8>: Prescale Select High Byte bits (1)\nNote 1: The 18-bit WDT prescale value, PSCNT<17:0> includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT<17:0> is intended for debug operations and should not be read during normal operation.",
    "REGISTER 11-5: WDTTMR: WDT TIMER REGISTER (READ-ONLY)\nbit 7, R-0/0.WDTTMR<4:0> = . bit 7, R-0/0.WDTTMR<4:0> = . bit 7, R-0/0.WDTTMR<4:0> = . bit 7, R-0/0.WDTTMR<4:0> = . bit 7, R-0/0.STATE = . bit 7, R-0/0.PSCNT<17:16> = . bit 7, R-0/0.PSCNT<17:16> = bit 0",
    "REGISTER 11-5: WDTTMR: WDT TIMER REGISTER (READ-ONLY)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = ",
    "bit 7-3 WDTTMR<4:0>: Watchdog Window Value bits\n111, WDT Window State.Closed = N/A. 111, WDT Window State.Open = 00000-11111. 111, Open Percent. = 100. 110, WDT Window State.Closed = 00000-00011. 110, WDT Window State.Open = 00100-11111. 110, Open Percent. = 87.5. 101, WDT Window State.Closed = 00000-00111. 101, WDT Window State.Open = 01000-11111. 101, Open Percent. = 75. 100, WDT Window State.Closed = 00000-01011. 100, WDT Window State.Open = 01100-11111. 100, Open Percent. = 62.5. 011, WDT Window State.Closed = 00000-01111. 011, WDT Window State.Open = 10000-11111. 011, Open Percent. = 50. 010, WDT Window State.Closed = 00000-10011. 010, WDT Window State.Open = 10100-11111. 010, Open Percent. =",
    "bit 7-3 WDTTMR<4:0>: Watchdog Window Value bits\n37.5. 001, WDT Window State.Closed = 00000-10111. 001, WDT Window State.Open = 11000-11111. 001, Open Percent. = 25. 000, WDT Window State.Closed = 00000-11011. 000, WDT Window State.Open = 11100-11111. 000, Open Percent. = 12.5",
    "bit 2\nSTATE: WDT Armed Status bit\n1 = WDT is armed\n0 = WDT is not armed\nbit 1-0\nPSCNT<17:16>: Prescale Select Upper Byte bits\n(1)\nNote 1: The 18-bit WDT prescale value, PSCNT<17:0> includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT<17:0> is intended for debug operations and should not be read during normal operation.",
    "TABLE 11-3: SUMMARY OF REGISTERS ASSOCIATED WITH WINDOWED WATCHDOG TIMER\nWDTCON0, Bit 7 = -. WDTCON0, Bit 6 = -. WDTCON0, Bit 5 = PS<4:0>. WDTCON0, Bit 4 = PS<4:0>. WDTCON0, Bit 3 = PS<4:0>. WDTCON0, Bit 2 = PS<4:0>. WDTCON0, Bit 1 = PS<4:0>. WDTCON0, Bit 0 = SEN. WDTCON0, Register on Page = 172. WDTCON1, Bit 7 = -. WDTCON1, Bit 6 = CS<2:0>. WDTCON1, Bit 5 = CS<2:0>. WDTCON1, Bit 4 = CS<2:0>. WDTCON1, Bit 3 = -. WDTCON1, Bit 2 = WINDOW<2:0>. WDTCON1, Bit 1 = WINDOW<2:0>. WDTCON1, Bit 0 = WINDOW<2:0>. WDTCON1, Register on Page = 173.",
    "TABLE 11-3: SUMMARY OF REGISTERS ASSOCIATED WITH WINDOWED WATCHDOG TIMER\nWDTPSL, Bit 7 = PSCNT<7:0>. WDTPSL, Bit 6 = PSCNT<7:0>. WDTPSL, Bit 5 = PSCNT<7:0>. WDTPSL, Bit 4 = PSCNT<7:0>. WDTPSL, Bit 3 = PSCNT<7:0>. WDTPSL, Bit 2 = PSCNT<7:0>. WDTPSL, Bit 1 = PSCNT<7:0>. WDTPSL, Bit 0 = PSCNT<7:0>. WDTPSL, Register on Page = 174. WDTPSH, Bit 7 = PSCNT<15:8>. WDTPSH, Bit 6 = PSCNT<15:8>. WDTPSH, Bit 5 = PSCNT<15:8>. WDTPSH, Bit 4 = PSCNT<15:8>. WDTPSH, Bit 3 = PSCNT<15:8>. WDTPSH, Bit 2 =",
    "TABLE 11-3: SUMMARY OF REGISTERS ASSOCIATED WITH WINDOWED WATCHDOG TIMER\nPSCNT<15:8>. WDTPSH, Bit 1 = PSCNT<15:8>. WDTPSH, Bit 0 = PSCNT<15:8>. WDTPSH, Register on Page = 174. WDTTMR, Bit 7 = WDTTMR<4:0>. WDTTMR, Bit 6 = WDTTMR<4:0>. WDTTMR, Bit 5 = WDTTMR<4:0>. WDTTMR, Bit 4 = WDTTMR<4:0>. WDTTMR, Bit 3 = WDTTMR<4:0>. WDTTMR, Bit 2 = STATE. WDTTMR, Bit 1 = PSCNT<17:16>. WDTTMR, Bit 0 = PSCNT<17:16>. WDTTMR, Register on Page = 175\nLegend:\nx = unknown, u = unchanged, - = unimplemented locations read as ' 0 '. Shaded cells are not used by Windowed Watchdog Timer.",
    "12.1 Introduction\nAll PIC18 devices include an 8x8 hardware multiplier as part of the ALU. The multiplier performs an unsigned operation and yields a 16-bit result that is stored in the product register pair, PRODH:PRODL. The multiplier's operation  does  not  affect  any  flags  in  the  STATUS register.\nMaking multiplication a hardware operation allows it to be completed in a single instruction cycle. This has the advantages  of  higher  computational  throughput  and reduced  code  size  for  multiplication  algorithms  and allows the PIC18 devices to be used in many applica -tions previously reserved for digital signal processors. A comparison  of various hardware and  software multiply operations, along with the savings in memory and execution time, is shown in Table 12-1.",
    "12.2 Operation\nExample 12-1  shows  the  instruction  sequence  for  an 8x8  unsigned  multiplication.  Only  one  instruction  is required when one of the arguments is already loaded in the WREG register.\nExample 12-2 shows the sequence to do an 8x8 signed multiplication.  To  account  for  the  sign  bits  of  the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "TABLE 12-1: PERFORMANCE COMPARISON FOR VARIOUS MULTIPLY OPERATIONS\n8x8 unsigned, Multiply Method = Without hardware multiply. 8x8 unsigned, Program Memory (Words). = 13. 8x8 unsigned, Cycles (Max). = 69. 8x8 unsigned, Time.@64 MHz = 4.3 \uf06d s. 8x8 unsigned, Time.@40 MHz = 6.9 \uf06d s. 8x8 unsigned, Time.@10 MHz = 27.6 \uf06d s. 8x8 unsigned, Time.@4MHz = 69 \uf06d s. 8x8 unsigned, Multiply Method = Hardware multiply. 8x8 unsigned, Program Memory (Words). = 1. 8x8 unsigned, Cycles (Max). = 1. 8x8 unsigned, Time.@64 MHz = 62.5 ns. 8x8 unsigned, Time.@40 MHz = 100 ns. 8x8 unsigned, Time.@10 MHz = 400 ns. 8x8 unsigned, Time.@4MHz = 1 \uf06d s. 8x8 signed, Multiply Method = Without hardware multiply. 8x8 signed, Program Memory (Words). = 33. 8x8 signed, Cycles (Max). =",
    "TABLE 12-1: PERFORMANCE COMPARISON FOR VARIOUS MULTIPLY OPERATIONS\n91. 8x8 signed, Time.@64 MHz = 5.7 \uf06d s. 8x8 signed, Time.@40 MHz = 9.1 \uf06d s. 8x8 signed, Time.@10 MHz = 36.4 \uf06d s. 8x8 signed, Time.@4MHz = 91 \uf06d s. 8x8 signed, Multiply Method = Hardware multiply. 8x8 signed, Program Memory (Words). = 6. 8x8 signed, Cycles (Max). = 6. 8x8 signed, Time.@64 MHz = 375 ns. 8x8 signed, Time.@40 MHz = 600 ns. 8x8 signed, Time.@10 MHz = 2.4 \uf06d s. 8x8 signed, Time.@4MHz = 6 \uf06d s. 16x16 unsigned, Multiply Method = Without hardware multiply. 16x16 unsigned, Program Memory (Words). = 21. 16x16 unsigned, Cycles (Max). = 242. 16x16 unsigned, Time.@64 MHz = 15.1 \uf06d s. 16x16 unsigned, Time.@40 MHz = 24.2 \uf06d s. 16x16 unsigned,",
    "TABLE 12-1: PERFORMANCE COMPARISON FOR VARIOUS MULTIPLY OPERATIONS\nTime.@10 MHz = 96.8 \uf06d s. 16x16 unsigned, Time.@4MHz = 242 \uf06d s. 16x16 unsigned, Multiply Method = Hardware multiply. 16x16 unsigned, Program Memory (Words). = 28. 16x16 unsigned, Cycles (Max). = 28. 16x16 unsigned, Time.@64 MHz = 1.8 \uf06d s. 16x16 unsigned, Time.@40 MHz = 2.8 \uf06d s. 16x16 unsigned, Time.@10 MHz = 11.2 \uf06d s. 16x16 unsigned, Time.@4MHz = 28 \uf06d s. 16x16 signed, Multiply Method = Without hardware multiply. 16x16 signed, Program Memory (Words). = 52. 16x16 signed, Cycles (Max). = 254. 16x16 signed, Time.@64 MHz = 15.9 \uf06d s. 16x16 signed, Time.@40 MHz = 25.4 \uf06d s. 16x16 signed, Time.@10 MHz = 102.6 \uf06d s. 16x16 signed, Time.@4MHz = 254 \uf06d s. 16x16 signed, Multiply Method",
    "TABLE 12-1: PERFORMANCE COMPARISON FOR VARIOUS MULTIPLY OPERATIONS\n= Hardware multiply. 16x16 signed, Program Memory (Words). = 35. 16x16 signed, Cycles (Max). = 40. 16x16 signed, Time.@64 MHz = 2.5 \uf06d s. 16x16 signed, Time.@40 MHz = 4.0 \uf06d s. 16x16 signed, Time.@10 MHz = 16.0 \uf06d s. 16x16 signed, Time.@4MHz = 40 \uf06d s\nEXAMPLE 12-1:\n8x8 UNSIGNED MULTIPLY ROUTINE\nMOVF\nARG1, W\n;\nMULWF\nARG2\n; ARG1 * ARG2 ->\n; PRODH:PRODL",
    "EXAMPLE 12-2: 8x8 SIGNED MULTIPLY ROUTINE\nMOVF MULWF BTFSC SUBWF MOVF BTFSC SUBWF, 1 = ARG1, W ARG2. MOVF MULWF BTFSC SUBWF MOVF BTFSC SUBWF, 2 = ; ARG1 * ARG2 -> ; PRODH:PRODL ; Test Sign Bit\nExample 12-3  shows  the  sequence  to  do  a  16  x  16 unsigned multiplication. Equation 12-1 shows the algorithm that is used. The 32-bit result is stored in four registers (RES<3:0>).",
    "MULTIPLICATION ALGORITHM\nRES3:RES0, 1 = =. RES3:RES0, 2 = ARG1H:ARG1L \uf0b7 ARG2H:ARG2L (ARG1H \uf0b7 ARG2H \uf0b7 2 16 ) +",
    "EXAMPLE 12-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF MULWF, 1 = ARG1L, ARG2L. MOVF MULWF, 2 = W. MOVF MULWF, 3 = ; ARG1L * ARG2L-> ; PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES1. MOVFF, 3 = ;. MOVFF, 1 = PRODL,. MOVFF, 2 = RES0. MOVFF, 3 = ;. MOVF MULWF, 1 = ARG1H, ARG2H. MOVF MULWF, 2 = W. MOVF MULWF, 3 = ; ARG1H * ARG2H-> ; PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES3. MOVFF, 3 = ;. MOVFF, 1 = PRODL,. MOVFF, 2 = RES2. MOVFF, 3 = ;. MOVF MULWF, 1 =",
    "EXAMPLE 12-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nARG1L, ARG2H. MOVF MULWF, 2 = W. MOVF MULWF, 3 = ; ARG1L * ARG2H-> ; PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. ADDWF, 1 = RES1, F. ADDWF, 2 = . ADDWF, 3 = ; Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ; products. ADDWFC, 1 = RES2, F. ADDWFC, 2 = . ADDWFC, 3 = ;. CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. ADDWFC, 1 = RES3, F. ADDWFC, 2 = . ADDWFC, 3 = ;. MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = ;. MULWF, 1 =",
    "EXAMPLE 12-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nARG2L. MULWF, 2 = . MULWF, 3 = ; ARG1H * ARG2L-> ; PRODH:PRODL. MOVF, 1 = RES1, F. MOVF, 2 = W. MOVF, 3 = ;. ADDWF, 1 = PRODL,. ADDWF, 2 = . ADDWF, 3 = ; Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ; products. ADDWFC, 1 = RES2,. ADDWFC, 2 = F. ADDWFC, 3 = ;. CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;",
    "EXAMPLE 12-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nExample 12-4  shows  the  sequence  to  do  a  16  x  16 signed  multiply.  Equation 12-2  shows  the  algorithm used.  The  32-bit  result  is  stored  in  four  registers (RES<3:0>). To account for the sign bits of the argu -ments, the MSb for each argument pair is tested and the appropriate subtractions are done.",
    "EQUATION 12-2: 16 x 16 SIGNED MULTIPLICATION ALGORITHM\nRES3:RES0, 1 = =. RES3:RES0, 2 = ARG1H:ARG1L \uf0b7 ARG2H:ARG2L. , 1 = =. , 2 = (ARG1H \uf0b7 ARG2H \uf0b7 2 16 ) +. , 1 = . , 2 = (ARG1H \uf0b7 ARG2L \uf0b7 2 8 ) +. , 1 = . , 2 = (ARG1L \uf0b7 ARG2H \uf0b7 2 8 ) +. , 1 = . , 2 = (ARG1L \uf0b7 ARG2L) +. , 1 = . , 2 = (-1 \uf0b7 ARG2H<7> \uf0b7 ARG1H:ARG1L \uf0b7 2 16 ) +. , 1 = . , 2 = (-1 \uf0b7 ARG1H<7> \uf0b7 ARG2H:ARG2L \uf0b7 2 16 )",
    "EXAMPLE 12-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nMOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1L * ARG2L -> PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES1. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES0. MOVFF, 3 = ;. MOVFF, 4 = . MOVF MULWF, 1 = ARG1H, ARG2H. MOVF MULWF, 2 = W. MOVF MULWF, 3 = ;. MOVF MULWF, 4 = ARG1H * ARG2H -> PRODH:PRODL. MOVFF MOVFF, 1 = PRODH,. MOVFF",
    "EXAMPLE 12-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nMOVFF, 2 = RES3. MOVFF MOVFF, 3 = ; ;. MOVFF MOVFF, 4 = . ; MOVF MULWF, 1 = PRODL, ARG1L,. ; MOVF MULWF, 2 = RES2 W. ; MOVF MULWF, 3 = ;. ; MOVF MULWF, 4 = . MOVF ADDWF MOVF ADDWFC CLRF ADDWFC, 1 = ARG2H PRODL, RES1, PRODH, RES2,. MOVF ADDWF MOVF ADDWFC CLRF ADDWFC, 2 = W F W. MOVF ADDWF MOVF ADDWFC CLRF ADDWFC, 3 = ; ; ; ;. MOVF ADDWF MOVF ADDWFC CLRF ADDWFC, 4 = ARG1L * ARG2H -> PRODH:PRODL. ; MOVF MULWF MOVF, 1 = WREG RES3, ARG1H, ARG2L. ;",
    "EXAMPLE 12-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nMOVF MULWF MOVF, 2 = F F. ; MOVF MULWF MOVF, 3 = ; ; ; ;. ; MOVF MULWF MOVF, 4 = Add cross products. ADDWF, 1 = PRODL,. ADDWF, 2 = W. ADDWF, 3 = ; ; ;. ADDWF, 4 = ARG1H * ARG2L. MOVF, 1 = RES1, F PRODH,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = -> PRODH:PRODL. , 1 = . , 2 = W. , 3 = ; ;. , 4 = Add cross. ADDWFC CLRF ADDWFC, 1 = WREG RES3, F. ADDWFC CLRF ADDWFC, 2 = . ADDWFC CLRF ADDWFC, 3 = . ADDWFC CLRF ADDWFC, 4 = products. , 1 = RES2, F. , 2 = . , 3 = ;. , 4 = . ; BTFSS, 1",
    "EXAMPLE 12-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . ; BTFSS, 2 = . ; BTFSS, 3 = ;. ; BTFSS, 4 = . SUBWF MOVF SUBWFB, 1 = ARG2H, ARG1L,. SUBWF MOVF SUBWFB, 2 = W. SUBWF MOVF SUBWFB, 3 = ; ;. SUBWF MOVF SUBWFB, 4 = no, check ARG1. ; SIGN_ARG1 BTFSS BRA MOVF, 1 = RES2 ARG1H,. ; SIGN_ARG1 BTFSS BRA MOVF, 2 = W. ; SIGN_ARG1 BTFSS BRA MOVF, 3 = ; ; ;. ; SIGN_ARG1 BTFSS BRA MOVF, 4 = ARG2H:ARG2L neg?. BRA, 1 = SIGN_ARG1. BRA, 2 = 7. BRA, 3 = . BRA, 4 = . MOVF, 1 = . MOVF, 2 = . MOVF, 3 = . MOVF, 4 = . ,",
    "EXAMPLE 12-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n1 = RES3. , 2 = . , 3 = . , 4 = . , 1 = . , 2 = . , 3 = . , 4 = ARG1H:ARG1L neg? no, done. , 1 = ARG1H,. , 2 = 7. , 3 = ; ; ;. , 4 = . , 1 = RES3. , 2 = . , 3 = . , 4 = . MOVF SUBWFB, 1 = ARG2H,. MOVF SUBWFB, 2 = W W. MOVF SUBWFB, 3 = ;. MOVF SUBWFB, 4 = . SUBWF, 1 = ARG2L, RES2. SUBWF, 2 = . SUBWF, 3 = ;. SUBWF, 4 = . ;, 1 = . ;, 2 = . ;, 3 = . ;, 4 = . CONT_CODE, 1 = . CONT_CODE, 2 = . CONT_CODE, 3 = . CONT_CODE, 4 = . :, 1 = . :, 2 = . :, 3 = . :,",
    "EXAMPLE 12-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n4 = ",
    "13.0 NONVOLATILE MEMORY (NVM) CONTROL\nNonvolatile Memory (NVM) is separated into two types: Program  Flash  Memory  (PFM)  and  Data  EEPROM Memory.\nPFM, Data EEPROM, User IDs and Configuration bits can all  be  accessed  using the  REG<1:0>  bits of  the NVMCON1 register.\nThe write time is controlled by an on-chip timer. The write/erase  voltages  are  generated  by  an  on-chip charge  pump  rated  to  operate  over  the  operating voltage range of the device.\nNVM can  be  protected  in  two  ways,  by  either  code protection or write protection. Code protection (CP and CPD bits in Configuration Word 5L) disables access, reading and writing to both PFM and Data EEPROM Memory  via external device programmers. Code protection  does  not  affect  the  self-write  and  erase functionality.  Code  protection  can  only  be  reset  by  a device  programmer  performing  a  Bulk  Erase  to  the device, clearing all nonvolatile memory, Configuration bits and User IDs.",
    "13.0 NONVOLATILE MEMORY (NVM) CONTROL\nWrite  protection  prohibits  self-write  and  erase  to  a portion or all of the PFM, as defined by the WRT bits of Configuration Word 4H. Write protection does not affect a device programmer's ability to read, write or erase the device.2017-2020",
    "TABLE 13-1: NVM ORGANIZATION AND ACCESS INFORMATION\nProgram Flash Memory (PFM), PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 00 0000h \u2022 \u2022 \u2022 01 FFFFh. Program Flash Memory (PFM), Execution.CPU Execution = Read. Program Flash Memory (PFM), User Access.REG = 10. Program Flash Memory (PFM), User Access.TABLAT = Read/ Write (1). Program Flash Memory (PFM), User Access.NVMDAT = - (3). User IDs (2), PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 20 0000h \u2022 \u2022 \u2022 20 000Fh. User IDs (2), Execution.CPU Execution = No Access. User IDs (2), User Access.REG = x1. User IDs (2), User Access.TABLAT = Read/ Write. User IDs (2), User Access.NVMDAT = -",
    "TABLE 13-1: NVM ORGANIZATION AND ACCESS INFORMATION\n(3). Reserved, PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 20 0010h 2F FFFFh. Reserved, Execution.CPU Execution = No Access. Reserved, User Access.REG = - (3). Reserved, User Access.TABLAT = - (3). Reserved, User Access.NVMDAT = - (3). Configuration, PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 30 0000h \u2022 \u2022 \u2022 30 0009h. Configuration, Execution.CPU Execution = No Access. Configuration, User Access.REG = x1. Configuration, User Access.TABLAT = Read/ Write (1). Configuration, User Access.NVMDAT = - (3). Reserved, PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 30 000Ah 30",
    "TABLE 13-1: NVM ORGANIZATION AND ACCESS INFORMATION\nFFFFh. Reserved, Execution.CPU Execution = No Access. Reserved, User Access.REG = - (3). Reserved, User Access.TABLAT = - (3). Reserved, User Access.NVMDAT = - (3). User Data Memory (Data EEPROM), PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 31 0000h \u2022 \u2022 \u2022 31 03FFh. User Data Memory (Data EEPROM), Execution.CPU Execution = No Access. User Data Memory (Data EEPROM), User Access.REG = 00. User Data Memory (Data EEPROM), User Access.TABLAT = - (3). User Data Memory (Data EEPROM), User Access.NVMDAT = Read/ Write (1). Reserved, PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 31 0400h 3E FFFFh. Reserved, Execution.CPU",
    "TABLE 13-1: NVM ORGANIZATION AND ACCESS INFORMATION\nExecution = No Access. Reserved, User Access.REG = - (3). Reserved, User Access.TABLAT = - (3). Reserved, User Access.NVMDAT = - (3). Device Information Area (DIA), PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 3F 0000h \u2022 \u2022 \u2022 3F 003Fh. Device Information Area (DIA), Execution.CPU Execution = No Access. Device Information Area (DIA), User Access.REG = x1. Device Information Area (DIA), User Access.TABLAT = Read. Device Information Area (DIA), User Access.NVMDAT = - (3). Reserved, PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 3F 0040h 3F FF09h. Reserved, Execution.CPU Execution = No Access. Reserved, User Access.REG = - (3). Reserved, User",
    "TABLE 13-1: NVM ORGANIZATION AND ACCESS INFORMATION\nAccess.TABLAT = - (3). Reserved, User Access.NVMDAT = - (3). Device Configuration Information (DCI), PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 3F FF00h \u2022 \u2022 \u2022 3F FF09h. Device Configuration Information (DCI), Execution.CPU Execution = No Access. Device Configuration Information (DCI), User Access.REG = x1. Device Configuration Information (DCI), User Access.TABLAT = Read. Device Configuration Information (DCI), User Access.NVMDAT = - (3). Reserved, PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 3F FF0Ah 3F. Reserved, Execution.CPU Execution = No Access. Reserved, User Access.REG = - (3). Reserved, User Access.TABLAT = - (3). Reserved, User Access.NVMDAT = -",
    "TABLE 13-1: NVM ORGANIZATION AND ACCESS INFORMATION\n(3). Revision ID/ Device ID, PC<20:0>.ICSP\u2122 Addr<21:0> TBLPTR<21:0> NVMADDR<9:0> = 3F FFFCh \u2022 \u2022 \u2022 3F FFFFh. Revision ID/ Device ID, Execution.CPU Execution = No Access. Revision ID/ Device ID, User Access.REG = x1. Revision ID/ Device ID, User Access.TABLAT = Read. Revision ID/ Device ID, User Access.NVMDAT = - (3)\nNote 1: Subject to Memory Write Protection settings.\n2: User IDs are eight words ONLY. There is no code protection, table read protection or write protection implemented for this region.\n3: Reads as ' 0 ', writes clear the WR bit and WRERR bit is set.",
    "13.1 Program Flash Memory\nThe Program Flash Memory is readable, writable and erasable during normal operation over the entire VDD range.\nA read from program memory is executed one byte at a time. A write to program memory or program memory erase is executed on blocks of n bytes at a time. Refer to  Table 5-4  for  write  and  erase  block  sizes. A  Bulk Erase operation cannot be issued from user code.\nWriting or erasing program memory will cease instruction fetches until the operation is complete. The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming timer terminates program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing  a  program  memory location  that  forms  an  invalid  instruction  results  in  a NOP .\nIt is important to understand the PFM memory structure for erase and programming operations. Program memory word size is 16 bits wide. PFM is arranged in rows. A row is the minimum size that can be erased by user software. Refer to Table 5-4 for the row sizes for the these devices.",
    "13.1 Program Flash Memory\nAfter a row has been erased, all or a portion of this row can  be  programmed.  Data  to  be  written  into  the program memory row is written to 8-bit wide data write latches by means of 6 address lines. These latches are not directly accessible, but may be loaded via sequential writes to the TABLAT register.\nNote:\nTo modify only a portion of a previously programmed row, then the contents of the entire  row  must  be  read  and  saved  in RAM prior  to  the  erase.  Then,  the  new data and retained data can be written into the write latches to reprogram the row of PFM. However, any unprogrammed locations can be written without first erasing  the  row.  In  this  case,  it  is  not necessary to save and rewrite the other previously programmed locations",
    "TABLE 13-2: FLASH MEMORY ORGANIZATION BY DEVICE\nPIC18(L)F25K83, Row Erase Size (Words) = 64. PIC18(L)F25K83, Write Latches (Bytes) = 128. PIC18(L)F25K83, Program Flash Memory (Words) = 16384. PIC18(L)F25K83, Data Memory (Bytes) = 1024. PIC18(L)F26K83, Row Erase Size (Words) = 64. PIC18(L)F26K83, Write Latches (Bytes) = 128. PIC18(L)F26K83, Program Flash Memory (Words) = 32768. PIC18(L)F26K83, Data Memory (Bytes) = 1024",
    "13.1.1 TABLE READS AND TABLE WRITES\nIn order to read and write program memory, there are two operations that allow the processor to move bytes between the program memory space and the data RAM:\n\u00b7 Table Read ( TBLRD )\n\u00b7 Table Write ( TBLWT )\nThe program memory space is 16 bits wide, while the data  RAM  space  is  eight  bits  wide. Table  reads  and table  writes  move  data  between  these  two  memory spaces through an 8-bit register (TABLAT).\nThe  table  read  operation  retrieves  one  byte  of  data directly  from  program  memory  and  places  it  into  the TABLAT register. Figure 13-1 shows the operation of a table read.\nThe table write operation stores one byte of data from the TABLAT register into a write block holding register. The  procedure  to  write  the  contents  of  the  holding registers into program memory is detailed in Section 13.1.6 'Writing to Program Flash Memory' . Figure 13-2 shows the operation of a table write with program memory and data RAM.",
    "13.1.1 TABLE READS AND TABLE WRITES\nTable operations work with byte entities. Tables containing  data,  rather  than  program  instructions,  are not required to be word aligned. Therefore, a table can start and end at any byte address. If a table write is being used  to  write  executable  code  into  program  memory, program instructions will need to be word aligned.",
    "13.1.2 CONTROL REGISTERS\nSeveral control registers are used in conjunction with the TBLRD and TBLWT instructions. These include the following registers:\n\u00b7 NVMCON1 register\n\u00b7 NVMCON2 register\n\u00b7 TABLAT register\n\u00b7 TBLPTR registers",
    "13.1.2.1 NVMCON1 and NVMCON2 Registers\nThe NVMCON1 register (Register 13-1) is the control register for memory accesses. The NVMCON2 register is not a physical register; it is used exclusively in the memory write and erase sequences. Reading NVMCON2 will read all ' 0 's.\nThe REG<1:0> control bits determine if the access will be to Data EEPROM Memory locations. PFM locations or User IDs, Configuration bits, Rev ID and Device ID. When REG<1:0> = 00 , any subsequent operations will operate on the Data EEPROM  Memory. When REG<1:0>  = 10 , any  subsequent  operations  will operate on the program memory. When REG<1:0> = x1 ,  any  subsequent  operations  will  operate  on  the Configuration bits, User IDs, Rev ID and Device ID.\nThe  FREE  bit  allows  the  program  memory  erase operation. When  the  FREE  bit  is set, an erase operation is initiated on the next WR command. When FREE  is  clear,  only  writes  are  enabled.  This  bit  is applicable only to the PFM and not to data EEPROM.",
    "13.1.2.1 NVMCON1 and NVMCON2 Registers\nWhen set, the  WREN bit  will  allow  a  program/erase operation. The WREN bit is cleared on power-up.\nThe WRERR bit is set by hardware when the WR bit is set and is cleared when the internal programming timer expires and the write operation is successfully complete.\nThe WR control bit initiates erase/write cycle operation when the REG<1:0> bits point to the Data EEPROM Memory location, and it initiates a write operation when the REG<1:0> bits point to the PFM location. The WR bit cannot be cleared by firmware; it can only be set by firmware. Then the WR bit is cleared by hardware at the completion of the write operation.\nThe NVMIF Interrupt Flag bit is set when the write is complete. The NVMIF flag stays set until cleared by firmware.",
    "13.1.2.2 TABLAT - Table Latch Register\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch register is used to hold 8-bit data during data transfers between program memory and data RAM.",
    "13.1.2.3 TBLPTR - Table Pointer Register\nThe Table Pointer (TBLPTR) register addresses a byte within the program memory. The TBLPTR is comprised of three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL). These three registers  join  to  form  a  22-bit  wide  pointer. The  loworder 21 bits allow the device to address up to 2 Mbytes of program memory space. The 22 nd  bit allows access to the Device ID, the User ID and the Configuration bits.\nThe Table  Pointer  register,  TBLPTR,  is  used  by  the TBLRD and TBLWT instructions. These instructions can update the TBLPTR in one of four ways based on the table  operation.  These  operations  on  the  TBLPTR affect only the low-order 21 bits.",
    "13.1.2.4 Table Pointer Boundaries\nTBLPTR is  used  in  reads,  writes  and  erases  of  the Program Flash Memory.\nWhen a TBLRD is executed, all 22 bits of the TBLPTR determine  which  byte  is  read  from  program  memory directly into the TABLAT register.\nWhen a TBLWT is  executed  the  byte  in  the  TABLAT register  is  written,  not  to  memory  but,  to  a  holding register in preparation for a program memory write. The holding registers constitute a write block which varies depending on the device (see Table 5-4).The 6 LSbs of the TBLPTRL register determine which specific address within the holding register block is written to. The MSBs of the Table Pointer have no effect during TBLWT operations.\nWhen a program memory write is executed the entire holding register block is written to the memory at the address determined by the MSbs of the TBLPTR. The 6 LSBs are ignored during memory writes. For more detail, see Section 13.1.6 'Writing to Program Flash Memory' .\nFigure 13-3 describes the relevant boundaries of TBLPTR based on Program Flash Memory operations.",
    "TABLE 13-3: TABLE POINTER OPERATIONS WITH TBLRD AND TBLWT INSTRUCTIONS\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "13.1.3 READING THE PROGRAM FLASH MEMORY\nThe TBLRD instruction  retrieves  data  from  program memory and places it into data RAM. Table reads from program memory are performed one byte at a time.\nThe CPU operation is suspended during the read, and it  resumes  immediately  after.  From  the  user  point  of view, TABLAT is valid in the next instruction cycle.\nTBLPTR points to a byte address in program space. Executing TBLRD places  the  byte  pointed  to  into TABLAT. In addition, TBLPTR can be modified automatically for the next table read operation.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word.\nFigure 13-4  shows  the  interface  between  the  internal program memory and the TABLAT.",
    "EXAMPLE 13-1: READING A PROGRAM FLASH MEMORY WORD\n, 1 = BCF BSF MOVLW MOVWF MOVLW MOVWF MOVLW. , 2 = NVMCON1, REG0 NVMCON1, REG1 CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL. , 3 = ; ; ; ;. , 4 = point to Program Flash Memory access Program Flash Memory Load TBLPTR with the base address of the word. READ_WORD, 1 = . READ_WORD, 2 = . READ_WORD, 3 = . READ_WORD, 4 = . , 1 = TBLRD*+ MOVF MOVWF TBLRD*+ MOVFW. , 2 = . , 3 = ;. , 4 = read into TABLAT and increment. , 1 = . , 2 = TABLAT, W. , 3 = ;. , 4 = get data. , 1 = . , 2 = WORD_EVEN TABLAT, W. , 3 = ; ;. , 4 = read into get data. , 1 = MOVF. , 2",
    "EXAMPLE 13-1: READING A PROGRAM FLASH MEMORY WORD\n= WORD_ODD. , 3 = . , 4 = ",
    "13.1.4 NVM UNLOCK SEQUENCE\nThe unlock sequence is a mechanism that protects the NVM  from unintended self-write programming or erasing. The sequence must be executed and completed without interruption to successfully complete any of the following operations:\n\u00b7 PFM Row Erase\n\u00b7 Write of PFM write latches to PFM memory\n\u00b7 Write of PFM write latches to User IDs\n\u00b7 Write to Data EEPROM Memory\n\u00b7 Write to Configuration Words\nThe unlock sequence consists of the following steps and must be completed in order:\n\u00b7 Write 55h to NVMCON2\n\u00b7 Write AAh to NMVCON2\n\u00b7 Set the WR bit of NVMCON1\nOnce the WR bit is set, the processor will stall internal operations  until  the  operation  is  complete  and  then resume with the next instruction.\nSince  the  unlock  sequence  must  not  be  interrupted, global interrupts should be disabled prior to the unlock sequence and re-enabled after the unlock sequence is completed.",
    "EXAMPLE 13-2: NVM UNLOCK SEQUENCE\nBCF, 1 = INTCON0,GIE NVMCON1. BCF, 2 = ; Recommended so sequence is not interrupted. BANKSEL BSF, 1 = NVMCON1,WREN. BANKSEL BSF, 2 = ; Enable write/erase. MOVLW, 1 = 55h. MOVLW, 2 = ; Load 55h. MOVWF, 1 = NVMCON2. MOVWF, 2 = ; Step 1: Load 55h into NVMCON2. MOVLW, 1 = AAh. MOVLW, 2 = ; Step 2: Load W with AAh. MOVWF, 1 = NVMCON2. MOVWF, 2 = ; Step 3: Load AAh into NVMCON2. BSF, 1 = INTCON1,WR. BSF, 2 = ; Step 4: Set WR bit to begin write/erase. BSF, 1 = INTCON0,GIE. BSF, 2 = ; Re-enable interrupts. Note 1: Sequence begins when NVMCON2 is written; steps 1-4",
    "EXAMPLE 13-2: NVM UNLOCK SEQUENCE\nmust occur in the cycle-accurate order shown. If the timing of the steps 1 to 4 is corrupted by an interrupt or a debugger Halt, the action will not take place., 1 = Note 1: Sequence begins when NVMCON2 is written; steps 1-4 must occur in the cycle-accurate order shown. If the timing of the steps 1 to 4 is corrupted by an interrupt or a debugger Halt, the action will not take place.. Note 1: Sequence begins when NVMCON2 is written; steps 1-4 must occur in the cycle-accurate order shown. If the timing of the steps 1 to 4 is corrupted by an interrupt or a debugger Halt, the action will not take place., 2 = Note 1: Sequence begins when NVMCON2 is written; steps 1-4 must occur in the cycle-accurate order shown. If the timing of the steps 1 to 4 is corrupted by an interrupt or a debugger Halt, the action will not take place.. 2: Opcodes shown are illustrative; any instruction that has the indicated effect may be used., 1 = 2: Opcodes shown are",
    "EXAMPLE 13-2: NVM UNLOCK SEQUENCE\nillustrative; any instruction that has the indicated effect may be used.. 2: Opcodes shown are illustrative; any instruction that has the indicated effect may be used., 2 = 2: Opcodes shown are illustrative; any instruction that has the indicated effect may be used.",
    "13.1.5 ERASING PROGRAM FLASH MEMORY\nThe minimum erase block is 64 words (refer to Table 5-\n4). Only through the use of an external programmer, or through ICSP\u2122 control, can larger blocks of program memory be bulk erased. Word erase in the program memory array is not supported.\nFor example, when initiating an erase sequence from a microcontroller with erase row size of 64 words, a block of 64 words (128 bytes) of program memory is erased. The  Most  Significant  16  bits  of  the  TBLPTR<21:6> point to the block being erased. The TBLPTR<5:0> bits are ignored.\nThe NVMCON1 register commands the erase operation. The REG<1:0> bits must be set to point to the Program Flash Memory. The WREN bit must be set to enable write operations. The FREE bit is set to select an erase operation.\nThe  NVM  unlock  sequence  described  in Section 13.1.4 'NVM Unlock Sequence' should  be  used  to guard  against  accidental  writes.  This  is  sometimes referred to as a long write.",
    "13.1.5 ERASING PROGRAM FLASH MEMORY\nA long write is necessary for erasing program memory. Instruction  execution  is  halted  during  the  long  write cycle.  The  long  write  is  terminated  by  the  internal programming timer.",
    "13.1.5.1 Program Flash Memory Erase Sequence\nThe sequence of events for erasing a block of internal program memory is:\n1. REG  bits  of  the  NVMCON1  register  point  to PFM\n2. Set the FREE and WREN bits of the NVMCON1 register\n3. Perform  the  unlock  sequence  as  described  in Section 13.1.4 'NVM Unlock Sequence'\nIf the PFM address is write-protected, the WR bit will be cleared  and  the  erase  operation  will  not  take  place, WRERR is signaled in this scenario.\nThe  operation  erases  the  memory  row  indicated  by masking the LSBs of the current TBLPTR.\nWhile erasing PFM, CPU operation is suspended and it resumes  when  the  operation  is  complete.  Upon completion  the  WR  bit  is  cleared  in  hardware,  the NVMIF is set and an interrupt will occur if the NVMIE bit is also set.\nWrite latch data is not affected by erase operations and WREN will remain unchanged.",
    "13.1.5.1 Program Flash Memory Erase Sequence\nNote 1: If a write or erase operation is terminated by an unexpected event, WRERR bit will be set which the user can check to decide whether  a  rewrite  of  the  location(s)  is needed.\n2: WRERR is set if WR is written to ' 1 ' while TBLPTR points to a write-protected address.\n3: WRERR is set if WR is written to ' 1 ' while TBLPTR  points  to  an  invalid  address location (Table 13-1).",
    "EXAMPLE 13-3: ERASING A PROGRAM FLASH MEMORY BLOCK\n; 1. A valid, 1 = address CLRF MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. ; 1. A valid, 2 = within the erase row is NVMCON1 ; CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL. ERASE_BLOCK, 1 = BCF BSF. ERASE_BLOCK, 2 = NVMCON1, REG0 ; point to Program Flash Memory ; access Program Flash Memory ; enable write to memory. Required Sequence, 1 = BCF MOVLW MOVWF MOVLW MOVWF BSF BSF. Required Sequence, 2 = INTCON0, GIE ; disable interrupts 55h NVMCON2 ; write 55h ; write AAh",
    "13.1.6 WRITING TO PROGRAM FLASH MEMORY\nThe  programming  write  block  size  is  described  in Table 5-4. Word or byte programming is not supported. Table  writes  are  used  internally  to  load  the  holding registers  needed  to  program  the  memory.  There  are only as many holding registers as there are bytes in a write block. Refer to Table 5-4 for write latch size.\nSince the table latch (TABLAT) is only a single byte, the TBLWT instruction needs to be executed multiple times for  each programming operation. The write protection state is ignored for this operation. All of the table write operations will essentially be short writes because only the holding registers are written. NVMIF is not affected while writing to the holding registers.\nAfter  all  the  holding  registers  have  been  written,  the programming  operation  of  that  block  of  memory  is started  by  configuring  the  NVMCON1  register  for  a program memory write and performing the long write sequence.\nIf the PFM address in the TBLPTR is write-protected or if TBLPTR points to an invalid location, the WR bit is cleared without any effect and the WRERR is signaled.",
    "13.1.6 WRITING TO PROGRAM FLASH MEMORY\nThe  long  write  is  necessary  for  programming  the program memory. CPU operation is suspended during a long write cycle and resumes when the operation is complete. The long  write  operation  completes  in  one instruction  cycle.  When  complete,  WR  is  cleared  in hardware and NVMIF is set and an interrupt will occur if NVMIE is also set. The latched data is reset to all ' 1 s'. WREN is not changed.\nThe internal programming timer controls the write time. The write/erase voltages are generated by an on-chip charge pump, rated to operate over the voltage range of the device.",
    "Note:\nThe default value of the holding registers on device Resets and after write operations is FFh. A  write  of  FFh  to  a  holding  register does not modify that byte. This means that individual  bytes  of  program  memory  may be modified, provided that the change does not attempt to change any bit from a ' 0 ' to a ' 1 '.  When  modifying  individual  bytes,  it  is not necessary to load all holding registers before executing a long write operation.",
    "13.1.6.1 Program Flash Memory Write Sequence\nThe sequence of events for programming an internal program memory location should be:\n1. Read  appropriate  number  of  bytes  into  RAM. Refer to Table 5-4 for Write latch size.\n2. Update data values in RAM as necessary.\n3. Load Table Pointer register with address being erased.\n4. Execute the block erase procedure.\n5. Load Table Pointer register with address of first byte being written.\n6. Write the n-byte block into the holding registers with auto-increment. Refer to Table 5-4 for Write latch size.\n7. Set REG<1:0> bits to point to program memory.\n8. Clear FREE bit and set WREN bit in NVMCON1 register.\n9. Disable interrupts.\n10. Execute  the  unlock  sequence  (see Section 13.1.4 'NVM Unlock Sequence' ).\n11. WR bit is set in NVMCON1 register.\n12. The CPU will stall for the duration of the write (about 2 ms using internal timer).\n13. Re-enable interrupts.\n14. Verify the memory (table read).",
    "13.1.6.1 Program Flash Memory Write Sequence\nThis procedure will require about 6 ms to update each write block of memory. An example of the required code is given in Example 13-4.",
    "Note:\nBefore  setting the WR  bit,  the  Table Pointer  address  needs  to  be  within  the intended address range of the bytes in the holding registers.",
    "EXAMPLE 13-4: WRITING TO PROGRAM FLASH MEMORY\n, 1 = MOVLW. , 2 = D'64'. , 3 = ; number of bytes in erase block. , 1 = MOVWF. , 2 = COUNTER. , 3 = . , 1 = MOVLW. , 2 = BUFFER_ADDR_HIGH. , 3 = ; point to buffer. , 1 = MOVWF. , 2 = FSR0H. , 3 = . , 1 = MOVLW. , 2 = BUFFER_ADDR_LOW. , 3 = . , 1 = MOVWF. , 2 = FSR0L. , 3 = . , 1 = MOVLW. , 2 = CODE_ADDR_UPPER. , 3 = ; Load TBLPTR with the base. , 1 = MOVWF. , 2 = TBLPTRU. , 3 = ; address of the memory block. , 1 = MOVLW. , 2 = CODE_ADDR_HIGH. , 3 = . , 1 = MOVWF. , 2 = TBLPTRH. , 3 = . , 1 = MOVLW. , 2 =",
    "EXAMPLE 13-4: WRITING TO PROGRAM FLASH MEMORY\nCODE_ADDR_LOW. , 3 = . , 1 = MOVWF. , 2 = TBLPTRL. , 3 = . READ_BLOCK, 1 = READ_BLOCK. READ_BLOCK, 2 = READ_BLOCK. READ_BLOCK, 3 = READ_BLOCK. , 1 = TBLRD*+. , 2 = . , 3 = ; read into TABLAT, and inc. , 1 = MOVF. , 2 = TABLAT, W. , 3 = ; get data. , 1 = MOVWF. , 2 = POSTINC0. , 3 = ; store data. , 1 = DECFSZ. , 2 = COUNTER. , 3 = ; done?. , 1 = BRA. , 2 = READ_BLOCK. , 3 = ; repeat. MODIFY_WORD, 1 = MODIFY_WORD. MODIFY_WORD, 2 = MODIFY_WORD. MODIFY_WORD, 3 = MODIFY_WORD. , 1 = MOVLW. , 2 = BUFFER_ADDR_HIGH. , 3 = ; point to buffer. , 1 = MOVWF. , 2 = FSR0H. , 3 = . , 1",
    "EXAMPLE 13-4: WRITING TO PROGRAM FLASH MEMORY\n= MOVLW. , 2 = BUFFER_ADDR_LOW. , 3 = . , 1 = MOVWF. , 2 = FSR0L. , 3 = . , 1 = MOVLW. , 2 = NEW_DATA_LOW. , 3 = ; update buffer word. , 1 = MOVWF. , 2 = POSTINC0. , 3 = . , 1 = MOVLW. , 2 = NEW_DATA_HIGH. , 3 = . , 1 = MOVWF. , 2 = INDF0. , 3 = . ERASE_BLOCK, 1 = ERASE_BLOCK. ERASE_BLOCK, 2 = ERASE_BLOCK. ERASE_BLOCK, 3 = ERASE_BLOCK. , 1 = MOVLW. , 2 = CODE_ADDR_UPPER. , 3 = ; load TBLPTR with the base. , 1 = MOVWF. , 2 = TBLPTRU. , 3 = ; address of the memory block. , 1 = MOVLW. , 2 = CODE_ADDR_HIGH. , 3 = . , 1 = MOVWF. , 2 =",
    "EXAMPLE 13-4: WRITING TO PROGRAM FLASH MEMORY\nTBLPTRH. , 3 = . , 1 = MOVLW. , 2 = CODE_ADDR_LOW. , 3 = . , 1 = MOVWF. , 2 = TBLPTRL. , 3 = . , 1 = BCF. , 2 = NVMCON1, REG0. , 3 = ; point to Program Flash Memory. , 1 = BSF. , 2 = NVMCON1, REG1. , 3 = ; point to Program Flash Memory. , 1 = BSF. , 2 = NVMCON1, WREN. , 3 = ; enable write to memory. , 1 = BSF. , 2 = NVMCON1, FREE. , 3 = ; enable Erase operation. , 1 = BCF. , 2 = INTCON0, GIE. , 3 = ; disable interrupts. , 1 = MOVLW. , 2 = 55h. , 3 = . Required, 1 = MOVWF. Required, 2 = NVMCON2. Required, 3 = ; write 55h. Sequence, 1 = MOVLW. Sequence, 2 = AAh.",
    "EXAMPLE 13-4: WRITING TO PROGRAM FLASH MEMORY\nSequence, 3 = . , 1 = MOVWF. , 2 = NVMCON2. , 3 = ; write 0AAh. , 1 = BSF. , 2 = NVMCON1,. , 3 = ; start erase (CPU. , 1 = BSF. , 2 = WR INTCON0,. , 3 = stall) ; re-enable interrupts. , 1 = . , 2 = GIE. , 3 = . , 1 = TBLRD*-. , 2 = . , 3 = ; dummy read decrement. , 1 = MOVLW. , 2 = BUFFER_ADDR_HIGH. , 3 = ; point to buffer. , 1 = MOVWF. , 2 = FSR0H BUFFER_ADDR_LOW. , 3 = . , 1 = MOVLW MOVWF. , 2 = FSR0L. , 3 = . WRITE_BUFFER_BACK, 1 = WRITE_BUFFER_BACK. WRITE_BUFFER_BACK, 2 = WRITE_BUFFER_BACK. WRITE_BUFFER_BACK, 3 = WRITE_BUFFER_BACK. , 1 = MOVLW.",
    "EXAMPLE 13-4: WRITING TO PROGRAM FLASH MEMORY\n, 2 = BlockSize. , 3 = ; number of bytes in holding register. , 1 = MOVWF. , 2 = COUNTER. , 3 = . , 1 = MOVLW. , 2 = D'64'/BlockSize. , 3 = ; number of write blocks in 64 bytes. , 1 = MOVWF. , 2 = COUNTER2. , 3 = ",
    "WRITING TO PROGRAM FLASH MEMORY (CONTINUED)\nWRITE_BYTE_TO_HREGS, 1 = WRITE_BYTE_TO_HREGS. WRITE_BYTE_TO_HREGS, 2 = WRITE_BYTE_TO_HREGS. WRITE_BYTE_TO_HREGS, 3 = WRITE_BYTE_TO_HREGS. , 1 = MOVF MOVWF TBLWT+*. , 2 = POSTINC0, W TABLAT. , 3 = ; get low byte of buffer data ; present data to table latch ; write data, perform a short write ; to internal TBLWT holding register.. , 1 = DECFSZ. , 2 = COUNTER. , 3 = ; loop until holding registers are. , 1 = BRA. , 2 = WRITE_WORD_TO_HREGS. , 3 = full. PROGRAM_MEMORY, 1 = PROGRAM_MEMORY. PROGRAM_MEMORY, 2 = PROGRAM_MEMORY. PROGRAM_MEMORY, 3 = PROGRAM_MEMORY. , 1 = BCF. , 2 = NVMCON1, REG0. , 3 = ; point to Program Flash Memory. , 1 = BSF. , 2 = NVMCON1,",
    "WRITING TO PROGRAM FLASH MEMORY (CONTINUED)\nREG1. , 3 = ; point to Program Flash Memory. , 1 = BSF. , 2 = NVMCON1, WREN. , 3 = ; enable write to memory. , 1 = BCF. , 2 = NVMCON1, FREE. , 3 = ; enable write to memory. , 1 = BCF. , 2 = INTCON0, GIE. , 3 = ; disable interrupts. , 1 = MOVLW. , 2 = 55h. , 3 = . Required, 1 = MOVWF. Required, 2 = NVMCON2. Required, 3 = ; write 55h. Sequence, 1 = MOVLW. Sequence, 2 = 0AAh. Sequence, 3 = . , 1 = MOVWF. , 2 = NVMCON2. , 3 = ; write 0AAh. , 1 = BSF. , 2 = NVMCON1, WR. , 3 = ; start program (CPU stall). , 1 = DCFSZ. , 2 = COUNTER2. , 3 = ; repeat for remaining write blocks. , 1 = BRA. , 2 =",
    "WRITING TO PROGRAM FLASH MEMORY (CONTINUED)\nWRITE_BYTE_TO_HREGS. , 3 = . , 1 = BSF. , 2 = INTCON0, GIE. , 3 = ; re-enable interrupts. , 1 = BCF. , 2 = NVMCON1, WREN. , 3 = ; disable write to memory\nFIGURE 13-9: PROGRAM FLASH MEMORY (PFM) WRITE FLOWCHART",
    "13.1.6.2 Write Verify\nDepending  on  the  application,  good  programming practice  may  dictate  that  the  value  written  to  the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit. Since program memory is stored as a full page, the stored program  memory  contents  are  compared  with  the intended  data  stored  in  RAM  after  the  last  write  is complete.",
    "13.1.6.3 Unexpected Termination of Write Operation\nIf a write is terminated by an unplanned event, such as loss  of  power  or  an  unexpected  Reset,  the  memory location just programmed  should  be  verified  and reprogrammed  if  needed.  If  the  write  operation  is interrupted by a MCLR Reset or a WDT Time-out Reset during  normal  operation,  the  WRERR  bit  will  be  set which the user can check to decide whether a rewrite of the location(s) is needed.",
    "13.1.6.4 Protection Against Spurious Writes\nA write sequence is valid only when both the following conditions are met, this prevents spurious writes which might lead to data corruption.\n1. The WR bit is gated through the WREN bit. It is suggested to have the WREN bit cleared at all times except during memory writes. This prevents memory writes if the WR bit gets set accidentally.\n2. The NVM unlock sequence must be performed each time before a write operation.",
    "13.2 Device Information Area, Device Configuration Area, User ID, Device ID and Configuration Word Access\nWhen REG<1:0> = 0b01 or 0b11 in  the  NVMCON1 register, the Device  Information  Area,  the Device Configuration Area, the User ID's, Device ID/ Revision ID and Configuration Words can be accessed.  Different  access  may  exist  for  reads  and writes (see Table 13-1).",
    "13.2.1 Reading Access\nThe  user  can  read  from  these  blocks  by  setting  the REG bits to 0b01 or 0b11 . The user needs to load the address into the TBLPTR  registers. Executing a TBLRD  after  that  moves  the  byte  pointed  to  the TABLAT  register.  The  CPU  operation  is  suspended during the read and resumes after. When read access is initiated on an address outside the parameters listed in Table 13-1, the TABLAT register is cleared, reading back '0's.",
    "13.2.2 Writing Access\nThe WREN bit in NVMCON1 must be set to enable writes. This prevents accidental writes to the CONFIG words due to errant (unexpected) code execution. The WREN bit  should  be  kept  clear  at  all  times,  except when updating the CONFIG words. The WREN bit is not cleared by hardware. The WR bit will be inhibited from being set unless the WREN bit is set.\nThe user needs to load the TBLPTR and TABLAT reg -ister with the address and data byte respectively before executing  the  Write  command. An  unlock  sequence needs  to  be  followed  for  writing  to  the  USER  IDs/ DEVICE IDs/CONFIG words (Section 13.1.4,  NVM Unlock Sequence). If WRTC = 0 or if TBLPTR points an invalid address location (see Table 13-1), WR bit is cleared without any effect and WRERR is set.",
    "13.2.2 Writing Access\nA single CONFIG word byte is written at once and the operation includes an implicit erase cycle for that byte (it  is  not  necessary  to  set  FREE).  CPU  execution  is stalled and at the completion of the write cycle, the WR bit is cleared in hardware and the NVM Interrupt Flag bit (NVMIF) is set. The new CONFIG value takes effect when the CPU resumes operation.\n\nTABLE 13-4: DIA, DCI, USER ID, DEV/REV ID AND CONFIGURATION WORD ACCESS (REG<1:0> = X1 )",
    "13.2.2 Writing Access\n20 0000h-20 000Fh, Function = User IDs. 20 0000h-20 000Fh, Read Access = Yes. 20 0000h-20 000Fh, Write Access = Yes. 30 0000h-30 0009h, Function = Configuration Words. 30 0000h-30 0009h, Read Access = Yes. 30 0000h-30 0009h, Write Access = Yes. 3F 0000h-3F 003Fh, Function = DIA. 3F 0000h-3F 003Fh, Read Access = Yes. 3F 0000h-3F 003Fh, Write Access = No. 3F FF00h-3F FF09h, Function = DCI. 3F FF00h-3F FF09h, Read Access = Yes. 3F FF00h-3F FF09h, Write Access = No. 3F FFFCh-3F FFFFh, Function = Revision ID/Device ID. 3F FFFCh-3F FFFFh, Read Access = Yes. 3F FFFCh-3F FFFFh, Write Access",
    "13.2.2 Writing Access\n= No",
    "13.3 Data EEPROM Memory\nThe  data  EEPROM  is  a  nonvolatile  memory  array, separate  from  the  data  RAM  and  program  memory, which is used for long-term storage of program data. It is  not  directly  mapped  in  either  the  register  file  or program  memory  space  but  is  indirectly  addressed through  the  Special  Function  Registers  (SFRs).  The EEPROM  is  readable  and  writable  during  normal operation over the entire VDD range.\nFour  SFRs  are  used  to  read  and  write  to  the  data EEPROM as well as the program memory. They are:\n\u00b7 NVMCON1\n\u00b7 NVMCON2\n\u00b7 NVMDAT\n\u00b7 NVMADRL\n\u00b7 NVMADRH\nThe data EEPROM allows byte read and write. When interfacing to the data memory block, NVMDAT holds the 8-bit data for read/write and the NVMADRH:NVMADRL register pair holds the address of the EEPROM location being accessed.",
    "13.3 Data EEPROM Memory\nThe EEPROM data memory is rated for high erase/write cycle endurance. A byte write automatically erases the location  and  writes  the  new  data  (erase-before-write). The write time is controlled by an internal programming timer; it will vary with voltage and temperature as well as from chip-to-chip. Refer to the Data EEPROM Memory parameters in Section 45.0 'Electrical Specifications' for limits.",
    "13.3.1 NVMADRL AND NVMADRH REGISTERS\nThe  NVMADRH:NVMADRL  registers  are  used  to address the data EEPROM  for read and write operations.",
    "13.3.2 NVMCON1 AND NVMCON2 REGISTERS\nAccess  to  the  data  EEPROM  is  controlled  by  two registers: NVMCON1 and NVMCON2. These are the same registers  which  control  access  to  the  program memory and are used in a similar manner for the data EEPROM.\nThe NVMCON1 register (Register 13-1) is the control register for data and program memory access. Control bits  REG<1:0>  determine  if  the  access  will  be  to program,  Data  EEPROM  Memory  or  the  User  IDs, Configuration bits, Revision ID and Device ID.\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear.\nThe WRERR bit is set by hardware when the WR bit is set and cleared when the internal programming timer expires and the write operation is complete.\nThe WR control bit initiates  write  operations. The  bit can be set but not cleared by software. It is cleared only by hardware at the completion of the write operation.\nThe NVMIF Interrupt Flag bit of the PIR0 register is set when  the  write  is  complete.  It  must  be  cleared  by software.",
    "13.3.2 NVMCON1 AND NVMCON2 REGISTERS\nControl  bits,  RD  and  WR,  start  read  and  erase/write operations, respectively. These bits are set by firmware and  cleared  by  hardware  at  the  completion  of  the operation.\nThe  RD  bit  cannot  be  set  when  accessing  program memory (REG<1:0> = 0x10). Program memory is read using table read instructions. See Section 13.1.1 'Table  Reads  and  Table  Writes' regarding table reads.",
    "13.3.3 READING THE DATA EEPROM MEMORY\nTo read a data memory location, the user must write the address  to  the  NVMADRL  and  NVMADRH  register pair, clear REG<1:0> control bit in NVMCON1 register to access Data EEPROM locations and then set control bit, RD.  The  data  is  available  on  the very  next instruction cycle; therefore, the NVMDAT register can be read by the next instruction. NVMDAT will hold this value until another read operation, or until it is written to by the user (during a write operation).\nThe basic process is shown in Example 13-5.",
    "13.3.4 WRITING TO THE DATA EEPROM MEMORY\nTo write an EEPROM data location, the address must first be  written  to  the  NVMADRL  and  NVMADRH register  pair  and  the  data  written  to  the  NVMDAT register. The  sequence  in  Example 13-6  must  be followed to initiate the write cycle.\nThe  write  will  not  begin  if  NVM  Unlock  sequence, described in Section 13.1.4 'NVM Unlock Sequence' , is not exactly followed for each byte. It is strongly  recommended  that  interrupts  be  disabled during this code segment.\nAdditionally, the WREN bit in NVMCON1 must be set to enable  writes.  This  mechanism  prevents  accidental writes  to  data  EEPROM  due  to  unexpected  code execution  (i.e.,  runaway  programs).  The  WREN  bit should be kept clear at all times, except when updating the EEPROM.  The  WREN  bit  is  not  cleared  by hardware.\nAfter a write sequence has been initiated, NVMCON1, NVMADRL,  NVMADRH  and  NVMDAT  cannot  be modified. The WR bit will be inhibited from being set unless  the  WREN  bit  is  set.  Both  WR  and  WREN cannot be set with the same instruction.",
    "13.3.4 WRITING TO THE DATA EEPROM MEMORY\nAfter a write sequence has been initiated, clearing the WREN bit will not affect this write cycle. A single Data EEPROM word is written and the operation includes an implicit erase cycle for that word (it is not necessary to set FREE). CPU execution continues in parallel and at the completion of the write cycle, the WR bit is cleared in hardware and the NVM Interrupt Flag bit (NVMIF) is set. The user can either enable this interrupt or poll this bit. NVMIF must be cleared by software.",
    "13.3.5 WRITE VERIFY\nDepending  on  the  application,  good  programming practice  may  dictate  that  the  value  written  to  the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "EXAMPLE 13-5: DATA EEPROM READ\n; Data Memory Address to read, 1 = ; Data Memory Address to read. ; Data Memory Address to read, 2 = ; Data Memory Address to read. ; Data Memory Address to read, 3 = ; Data Memory Address to read. CLRF, 1 = NVMCON1. CLRF, 2 = . CLRF, 3 = ; Setup Data EEPROM Access. MOVF, 1 = EE_ADDRL,. MOVF, 2 = W. MOVF, 3 = ;. MOVWF, 1 = NVMADRL. MOVWF, 2 = . MOVWF, 3 = ; Setup Address. BSF, 1 = NVMCON1,. BSF, 2 = RD. BSF, 3 = ; Issue EE Read. MOVF, 1 = NVMDAT,. MOVF, 2 = W. MOVF, 3 = ; W = EE_DATA",
    "EXAMPLE 13-6: DATA EEPROM WRITE\n;, 1 = Data. ;, 2 = Memory Address to write. ;, 3 = Memory Address to write. ;, 4 = Memory Address to write. ;, 5 = Memory Address to write. ;, 6 = Memory Address to write. , 1 = . , 2 = CLRF. , 3 = NVMCON1. , 4 = . , 5 = ;. , 6 = Setup Data EEPROM Access. , 1 = . , 2 = MOVF. , 3 = EE_ADDRL,. , 4 = W. , 5 = ;. , 6 = . , 1 = . , 2 = MOVWF. , 3 = NVMADRL. , 4 = . , 5 = ;. , 6 = Setup Address. ;, 1 = Data. ;, 2 = Memory Value to write. ;, 3 = Memory Value to write. ;, 4 = Memory Value to write. ;, 5 = Memory Value to write. ;, 6 = Memory Value to write. , 1 = . , 2 = MOVF. , 3 = EE_DATA,. , 4 = W. , 5 = ;. , 6 = . , 1 = .",
    "EXAMPLE 13-6: DATA EEPROM WRITE\n, 2 = MOVWF. , 3 = NVMDAT. , 4 = . , 5 = ;. , 6 = . ;, 1 = Enable. ;, 2 = writes. ;, 3 = writes. ;, 4 = writes. ;, 5 = writes. ;, 6 = writes. , 1 = . , 2 = BSF. , 3 = NVMCON1,. , 4 = WREN. , 5 = ;. , 6 = . ;, 1 = Disable interrupts. ;, 2 = Disable interrupts. ;, 3 = Disable interrupts. ;, 4 = Disable interrupts. ;, 5 = Disable interrupts. ;, 6 = Disable interrupts. , 1 = . , 2 = BCF. , 3 = INTCON0,. , 4 = GIE. , 5 = ;. , 6 = . ;, 1 = Required. ;, 2 = unlock. ;, 3 = sequence. ;, 4 = . ;, 5 = . ;, 6 = . , 1 = . , 2 = MOVLW. , 3 = 55h. , 4 = . , 5 = ;.",
    "EXAMPLE 13-6: DATA EEPROM WRITE\n, 6 = . , 1 = . , 2 = MOVWF. , 3 = NVMCON2. , 4 = . , 5 = ;. , 6 = . , 1 = . , 2 = MOVLW. , 3 = AAh. , 4 = . , 5 = ;. , 6 = . , 1 = . , 2 = MOVWF. , 3 = NVMCON2. , 4 = . , 5 = ;. , 6 = . ;, 1 = Set. ;, 2 = WR bit to begin write. ;, 3 = WR bit to begin write. ;, 4 = WR bit to begin write. ;, 5 = WR bit to begin write. ;, 6 = WR bit to begin write. , 1 = . , 2 = BSF. , 3 = NVMCON1,. , 4 = WR. , 5 = ;. , 6 = . ;, 1 = Enable INT. ;, 2 = Enable INT. ;, 3 = Enable INT. ;, 4 = Enable INT. ;, 5 = Enable INT. ;, 6 = Enable INT. , 1 = . , 2 = BSF. ,",
    "EXAMPLE 13-6: DATA EEPROM WRITE\n3 = INTCON0,. , 4 = GIE. , 5 = ;. , 6 = . ;, 1 = Wait. ;, 2 = . ;, 3 = . ;, 4 = . ;, 5 = . ;, 6 = . ;, 1 = . ;, 2 = for interrupt, write done SLEEP ; Disable writes. ;, 3 = for interrupt, write done SLEEP ; Disable writes. ;, 4 = for interrupt, write done SLEEP ; Disable writes. ;, 5 = for interrupt, write done SLEEP ; Disable writes. ;, 6 = for interrupt, write done SLEEP ; Disable writes. , 1 = . , 2 = BCF. , 3 = NVMCON1,. , 4 = WREN. , 5 = ;. , 6 = ",
    "13.3.7 PROTECTION AGAINST SPURIOUS WRITE\nData EEPROM Memory has its own code-protect bits in Configuration Words. External read and write operations are disabled if code protection is enabled.\nIf the Data EEPROM is write-protected or if NVMADR points an invalid address location, the WR bit is cleared without any effect. WRERR is signaled in this scenario.\nThere are conditions when the user may not want to write to the Data EEPROM Memory. To protect against spurious EEPROM writes, various mechanisms have been  implemented.  On  power-up,  the  WREN  bit  is cleared. In addition, writes to the EEPROM are blocked during the Power-up Timer period (TPWRT).\nThe unlock sequence and the WREN bit together help prevent  an  accidental  write  during  brown-out,  power glitch or software malfunction.",
    "13.3.8 ERASING THE DATA EEPROM MEMORY\nData EEPROM Memory can be erased by writing 0xFF to  all  locations  in  the  Data  EEPROM  Memory  that needs to be erased.",
    "EXAMPLE 13-7: DATA EEPROM REFRESH ROUTINE\n, 1 = CLRF BCF BCF BCF BSF. , 2 = NVMADRL NVMCON1, CFGS NVMCON1, EEPGD INTCON0, GIE NVMCON1, WREN. , 3 = ; ; ; ; ;. , 4 = Start at address 0 Set for memory. Loop, 1 = . Loop, 2 = . Loop, 3 = ;. Loop, 4 = Loop to refresh array. , 1 = BSF. , 2 = NVMCON1, RD. , 3 = ;. , 4 = Read current address. , 1 = MOVLW. , 2 = 55h. , 3 = ;. , 4 = . , 1 = MOVWF. , 2 = NVMCON2. , 3 = ;. , 4 = Write 55h. , 1 = MOVLW. , 2 = 0AAh. , 3 = ;. , 4 = . , 1 = MOVWF. , 2 = NVMCOM2. , 3 = ;. , 4 = Write 0AAh. , 1 = . , 2 =",
    "EXAMPLE 13-7: DATA EEPROM REFRESH ROUTINE\nNVMCON1,. , 3 = ;. , 4 = Set WR bit to begin. , 1 = BSF. , 2 = WR WR. , 3 = . , 4 = write. , 1 = BTFSC. , 2 = NVMCON1,. , 3 = ;. , 4 = Wait for write to complete. , 1 = . , 2 = LOOP. , 3 = ; ;. , 4 = Increment address Not zero, do it again. , 1 = INCFSZ BRA. , 2 = NVMADRL, F. , 3 = . , 4 = . , 1 = BCF. , 2 = NVMCON1, WREN INTCON0, GIE. , 3 = . , 4 = Enable interrupts. , 1 = BSF. , 2 = . , 3 = ;. , 4 = ; Disable writes",
    "REGISTER 13-1: NVMCON1: NONVOLATILE MEMORY CONTROL 1 REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = U-0. R/W-0/0, 3 = R/S/HC-0/0. R/W-0/0, 4 = R/W/HS-x/q. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/S/HC-0/0. R/W-0/0, 7 = R/S/HC-0/0. REG<1:0>, 1 = REG<1:0>. REG<1:0>, 2 = -. REG<1:0>, 3 = FREE. REG<1:0>, 4 = WRERR. REG<1:0>, 5 = WREN. REG<1:0>, 6 = WR. REG<1:0>, 7 = RD. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 =",
    "REGISTER 13-1: NVMCON1: NONVOLATILE MEMORY CONTROL 1 REGISTER\n. bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = HC = Bit is cleared by hardware. x = Bit is unknown, 1 = -n = Value at POR. x = Bit is unknown, 2 = S = Bit can be set by software, but not cleared. '0' = Bit is cleared, 1 = '1' = Bit is set. '0' = Bit is cleared, 2 = U = Unimplemented bit, read as '0'",
    "bit 7-6 REG<1:0>: NVM Region Selection bit\n10 =Access PFM Locations\nx1 = Access User IDs, Configuration Bits, DIA, DCI, Rev ID and Device ID\n00 = Access Data EEPROM Memory Locations",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nFREE: Program Flash Memory Erase Enable bit (1)\n1 = Performs an erase operation on the next WR command\n0 = The next WR command performs a write operation",
    "bit 3 WRERR: Write-Reset Error Flag bit (2,3,4)\n1 = A write operation was interrupted by a Reset (hardware set),\nor WR was written to 1'b1 when an invalid address is accessed (Table 4-1, Table 13-1)\nor WR was written to 1'b1 when REG<1:0> and address do not point to the same region\nor WR was written to 1'b1 when a write-protected address is accessed (Table 4-2).\n0 = All write operations have completed normally",
    "bit 2 WREN: Program/Erase Enable bit\n1 = Allows program/erase and refresh cycles\n0 = Inhibits programming/erasing and user refresh of NVM",
    "(5,6,7)\nWhen REG points to a Data EEPROM Memory location:\n1 = Initiates an erase/program cycle at the corresponding Data EEPROM Memory location",
    "When REG points to a PFM location:\n1 = Initiates the PFM write operation with data from the holding registers\n0 = NVM program/erase operation is complete and inactive",
    "(8)\n1 = Initiates a read at address pointed by REG and NVMADR, and loads data into NVMDAT\n0 = NVM read operation is complete and inactive",
    "Note 1: This can only be used with PFM.\n2: This bit is set when WR = 1 and clears when the internal programming timer expires or the write is completed successfully.\n3: Bit must be cleared by the user; hardware will not clear this bit.\n4: Bit may be written to ' 1 ' by the user in order to implement test sequences.\n5: This bit can only be set by following the unlock sequence of Section 13.1.4 'NVM Unlock Sequence' .\n6: Operations are self-timed and the WR bit is cleared by hardware when complete.\n7: Once a write operation is initiated, setting this bit to zero will have no effect.\n8: The bit can only be set in software. The bit is cleared by hardware when the operation is complete.",
    "REGISTER 13-2: NVMCON2: NONVOLATILE MEMORY CONTROL 2 REGISTER\nbit 7, R/W-0.NVMCON2<7:0> = . bit 7, R/W-0.NVMCON2<7:0> = . bit 7, R/W-0.NVMCON2<7:0> = . bit 7, R/W-0.NVMCON2<7:0> = . bit 7, R/W-0.NVMCON2<7:0> = . bit 7, R/W-0.NVMCON2<7:0> = . bit 7, R/W-0.NVMCON2<7:0> = bit 0",
    "bit 7-0 NVMCON2<7:0>:\nRefer to Section 13.1.4 'NVM Unlock Sequence' .\nNote 1: This register always reads zeros, regardless of data written.",
    "Register 13-3: NVMADRL: Data EEPROM Memory Address Low\nbit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0\nR = Readable bit x = Bit is unknown -n = Value at POR, W=Writable bit = . R = Readable bit x = Bit is unknown -n = Value at POR, U = Unimplemented bit, read as = . , W=Writable bit = '0' = Bit is cleared. , U = Unimplemented bit, read as = '1' = Bit is set\nbit 7-0 ADR<7:0>: EEPROM Read Address bits",
    "REGISTER 13-4: NVMADRH: DATA EEPROM MEMORY ADDRESS HIGH\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = ADR<9:8>. -, 7 = ADR<9:8>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nbit 7-2 Unimplemented: Read as ' 0 '",
    "REGISTER 13-4: NVMADRH: DATA EEPROM MEMORY ADDRESS HIGH\nbit 1-0 ADR<9:8>: EEPROM Read Address bits",
    "REGISTER 13-5: NVMDAT: DATA EEPROM MEMORY DATA\nbit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0.DAT<7:0> = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0\nbit 7-0 DAT<7:0>: The value of the data memory word returned from NVMADR after a Read command, or the data written by a Write command.",
    "TABLE 13-5: SUMMARY OF REGISTERS ASSOCIATED WITH NONVOLATILE MEMORY CONTROL\nNVMCON1, Bit 7 = REG<1:0>. NVMCON1, Bit 6 = REG<1:0>. NVMCON1, Bit 5 = -. NVMCON1, Bit 4 = FREE. NVMCON1, Bit 3 = WRERR. NVMCON1, Bit 2 = WREN. NVMCON1, Bit 1 = WR. NVMCON1, Bit 0 = RD. NVMCON1, Register on Page = 200. NVMCON2, Bit 7 = Unlock Pattern. NVMCON2, Bit 6 = Unlock Pattern. NVMCON2, Bit 5 = Unlock Pattern. NVMCON2, Bit 4 = Unlock Pattern. NVMCON2, Bit 3 = Unlock Pattern. NVMCON2, Bit 2 = Unlock Pattern. NVMCON2, Bit 1 = Unlock Pattern. NVMCON2, Bit 0 = Unlock Pattern. NVMCON2, Register on Page = 201. NVMADRL, Bit 7 = NVMADR<7:0>.",
    "TABLE 13-5: SUMMARY OF REGISTERS ASSOCIATED WITH NONVOLATILE MEMORY CONTROL\nNVMADRL, Bit 6 = NVMADR<7:0>. NVMADRL, Bit 5 = NVMADR<7:0>. NVMADRL, Bit 4 = NVMADR<7:0>. NVMADRL, Bit 3 = NVMADR<7:0>. NVMADRL, Bit 2 = NVMADR<7:0>. NVMADRL, Bit 1 = NVMADR<7:0>. NVMADRL, Bit 0 = NVMADR<7:0>. NVMADRL, Register on Page = 201. NVMADRH, Bit 7 = -. NVMADRH, Bit 6 = -. NVMADRH, Bit 5 = -. NVMADRH, Bit 4 = -. NVMADRH, Bit 3 = -. NVMADRH, Bit 2 = -. NVMADRH, Bit 1 = NVMADR<9:8>. NVMADRH, Bit 0 = NVMADR<9:8>. NVMADRH, Register on",
    "TABLE 13-5: SUMMARY OF REGISTERS ASSOCIATED WITH NONVOLATILE MEMORY CONTROL\nPage = 201. NVMDAT, Bit 7 = NVMDAT<7:0>. NVMDAT, Bit 6 = NVMDAT<7:0>. NVMDAT, Bit 5 = NVMDAT<7:0>. NVMDAT, Bit 4 = NVMDAT<7:0>. NVMDAT, Bit 3 = NVMDAT<7:0>. NVMDAT, Bit 2 = NVMDAT<7:0>. NVMDAT, Bit 1 = NVMDAT<7:0>. NVMDAT, Bit 0 = NVMDAT<7:0>. NVMDAT, Register on Page = 202\nLegend:\n- = unimplemented, read as ' 0 '. Shaded bits are not used during EEPROM access.\n- *Page provides register information.",
    "14.0 CYCLIC REDUNDANCY CHECK (CRC) MODULE WITH MEMORY SCANNER\nThe Cyclic Redundancy Check (CRC) module provides a  software-configurable  hardware-implemented  CRC checksum generator. This module includes the following features:\n\u00b7 Any standard CRC up to 16 bits can be used\n\u00b7 Configurable Polynomial\n\u00b7 Any seed value up to 16 bits can be used\n\u00b7 Standard and reversed bit order available\n\u00b7 Augmented zeros can be added automatically or by the user\n\u00b7 Memory scanner for fast CRC calculations on program/Data EEPROM memory user data\n\u00b7 Software loadable data registers for communication CRC's",
    "14.1 CRC Module Overview\nThe CRC module provides a means for calculating a check value of program/Data EEPROM memory. The CRC module  is  coupled  with  a  memory  scanner  for faster  CRC  calculations.  The  memory  scanner  can automatically  provide  data  to  the  CRC  module.  The CRC module can also be operated by directly writing data to SFRs, without using a scanner.",
    "14.2 CRC Functional Overview\nThe CRC module can be used to detect bit errors in the program memory using the built-in memory scanner or through user input RAM memory. The CRC module can accept up to a 16-bit polynomial with up to a 16-bit seed value. A  CRC  calculated  check  value  (or  checksum) will then be generated into the CRCACC<15:0> registers for user storage. The CRC module uses an XOR  shift  register  implementation  to  perform  the polynomial division required for the CRC calculation.",
    "EXAMPLE 14-1: CRC EXAMPLE\nRev. 10-000206A 1/8/2014\nCRC-16-ANSI\nx 16 + x 15 + x 2 + 1 (17 bits)\nCRCXORH = 0b10000000 CRCXORL = 0b0000010- (1)\nStandard 16-bit representation = 0x8005\nData Sequence:\n0x55, 0x66, 0x77, 0x88\nCheck Value (ACCM = 1) :\nSHIFTM = 0 : 0x32D6\nCRCACCH = 0b00110010\nCRCACCL = 0b11010110\nSHIFTM = 1 : 0x6BA2\nCRCACCH = 0b01101011\nCRCACCL = 0b10100010\nDLEN = 0b0111\nPLEN = 0b1111\nData entered into the CRC: SHIFTM = 0:\n01010101 01100110 01110111 10001000\nSHIFTM = 1:\n10101010 01100110 11101110 00010001",
    "EXAMPLE 14-1: CRC EXAMPLE\nNote  1:    Bit 0  is unimplemented. The LSb of any CRC polynomial is always '1' and will always be treated as a '1' by the CRC for calculating the CRC check value. This bit will be read in software as a '0'.",
    "14.3 CRC Polynomial Implementation\nAny  polynomial  can  be  used.  The  polynomial  and accumulator sizes are determined by the PLEN<3:0> bits.  For  an  n-bit  accumulator,  PLEN  = n-1 and  the corresponding  polynomial  is  n+1  bits.  Therefore  the accumulator  can  be  any  size  up  to  16  bits  with  a corresponding polynomial up to 17 bits. The MSb and LSb of the polynomial are always ' 1 ' which is forced by hardware. All  polynomial  bits  between  the  MSb  and LSb  are  specified  by  the  CRCXOR  registers.  For example, when using CRC-16-ANSI, the polynomial is defined as X 16 +X 15 +X 2 +1.",
    "14.3 CRC Polynomial Implementation\nThe  X 16 and  X 0   = 1 terms  are  the  MSb  and  LSb controlled  by  hardware.  The  X 15   and  X 2   terms  are specified by setting the corresponding CRCXOR<15:0> bits with the value of ' 0x8004 '.  The actual  value  is  ' 0x8005 '  because  the  hardware  sets the  LSb  to  1.  However,  the  LSb  of  the  CRCXORL register  is  unimplemented  and  always  reads  as  ' 0 '. Refer to Example 14-1.",
    "14.4.1 CRC FROM USER DATA\nData can be input to the CRC module in two ways:\n-User data using the CRCDAT registers (CRCDATH and CRCDATL)\n-Program memory using the Program Memory Scanner\nTo  set  the  number  of  bits  of  data,  up  to  16  bits,  the DLEN bits of CRCCON1 must be set accordingly. Only data bits in CRCDAT registers up to DLEN will be used, other data bits in CRCDAT registers will be ignored.\nData is moved into the CRCSHIFT as an intermediate to  calculate the check value located in the CRCACC registers.\nThe SHIFTM bit is used to determine the bit order of the data being shifted into the accumulator. If SHIFTM is not set, the data will be shifted in MSb first (Big Endian). The value of DLEN will determine the MSb. If SHIFTM bit is set, the data will be shifted into the accumulator in reversed order, LSb first (Little Endian).\nThe CRC module can be seeded with an initial value by setting the CRCACC<15:0> registers to the appropriate value before beginning the CRC.",
    "14.4.1 CRC FROM USER DATA\nTo use the CRC module on data input from the user, the user must write the data to the CRCDAT registers. The data from the CRCDAT registers will be latched into the shift registers on any write to the CRCDATL register.",
    "14.4.2 CRC FROM FLASH\nTo use the CRC module on data located in Program memory, the user can initialize the Program Memory Scanner as defined in Section 14.8, Scanner Module Overview .",
    "14.5 CRC Check Value\nThe CRC check value will be located in the CRCACC registers  after  the  CRC  calculation  has  finished. The check value will depend on two mode settings of the CRCCON0  register: ACCM  and  SHIFTM.  When  the ACCM bit is set, the CRC module augments the data with  a  number  of  zeros  equal  to  the  length  of  the polynomial  to  align  the  final  check  value.  When  the ACCM bit is not set, the CRC will stop at the end of the data. A  number  of  zeros  equal  to  the  length  of  the polynomial can then be entered into CRCDAT to find the same check value as augmented mode. Alternatively the expected check value can be entered at this point to make the final result equal ' 0 '.",
    "14.5 CRC Check Value\nWhen  the  CRC  check  value  is  computed  with  the SHIFTM bit set, selecting LSb first, and the ACCM bit is also set then the final value in the CRCACC registers will be reversed such that the LSb will be in the MSb position  and  vice  versa.  This  is  the  expected  check value in bit reversed form. If you are creating a check value  to  be  appended  to  a  data  stream  then  a  bit reversal  must  be  performed  on  the  final  value  to achieve the correct checksum. You can use the CRC to do this reversal by the following method:\n\u00b7 Save the CRCACC value in user RAM space\n\u00b7 Clear the CRCACC registers\n\u00b7 Clear the CRCXOR registers\n\u00b7 Write the saved CRCACC value to the CRCDAT input.\nThe  properly  oriented  check  value  will  be  in  the CRCACC registers as the result.",
    "14.6 CRC Interrupt\nThe CRC will generate an interrupt when the BUSY bit transitions from 1 to 0 . The CRCIF Interrupt Flag is set every  time  the  BUSY  bit  transitions,  regardless  of whether  or  not  the  CRC  interrupt  is  enabled.  The CRCIF bit can only be cleared in software.",
    "14.7 Configuring the CRC\nThe following steps illustrate how to properly configure the CRC.",
    "14.7 Configuring the CRC\n1. Determine  if  the  automatic  program  memory scan will  be  used with the scanner or manual calculation through the SFR  interface and perform the actions specified in Section 14.4 'CRC Data Sources' , depending on which decision was made.\n2. If  desired,  seed  a  starting  CRC  value  into  the CRCACCH/L registers.\n3. Program  the  CRCXORH/L  registers  with  the desired generator polynomial.\n4. Program the DLEN<3:0> bits of the CRCCON1 register with the length of the data word - 1 (refer to  Example 14-1).  This  determines  how  many times the shifter will shift into the accumulator for each data word.\n5. Program the PLEN<3:0> bits of the CRCCON1 register  with  the  length  of  the  polynomial  -2 (refer to Example 14-1).\n6. Determine  whether  shifting  in  trailing  zeros  is desired and set the ACCM bit of the CRCCON0 register appropriately.\n7. Likewise,  determine  whether  the  MSb  or  LSb should be shifted first and write the SHIFTM bit of the CRCCON0 register appropriately.",
    "14.7 Configuring the CRC\n8. Write  the  GO  bit  of  the  CRCCON0 register to begin the shifting process.\n9a. If manual SFR entry is used, monitor the FULL bit of the CRCCON0  register.  When  FULL = 0 , another  word  of  data  can  be  written  to  the CRCDATH/L  registers,  keeping  in  mind  that CRCDATH should be written first if the data has more than eight bits, as the shifter will begin upon the CRCDATL register being written.\n9b. If the scanner is used, the scanner will automatically load words into the CRCDATH/L registers as needed, as long as the GO bit is set.\n10a.If manual entry is used, monitor the CRCIF (and BUSY  bit  to  determine  when  the  completed CRC calculation can be read from CRCACCH/L registers.",
    "14.7 Configuring the CRC\n10b.If using the memory  scanner,  monitor the SCANIF (or the GO bit) for the scanner to finish pushing information into the CRCDAT registers. After  the  scanner  is  completed,  monitor  the BUSY bit to determine that the CRC has been completed  and  the  check  value  can  be  read from the CRCACC registers. If both the interrupt flags  are  set  and  the  BUSY  and  GO  bits  are cleared, the completed CRC calculation can be read from the CRCACCH/L registers.",
    "14.8 Scanner Module Overview\nThe Scanner allows segments of the Program Flash Memory or Data EEPROM, to be read out (scanned) to the  CRC  Peripheral.  The  Scanner  module  interacts with the CRC module and supplies it data one word at a time. Data is fetched from the address range defined by SCANLADR  registers up to the SCANHADR registers.\nThe Scanner begins operation when the SGO bit is set (SCANCON0 Register) and ends when either SGO is cleared by the user or when SCANLADR increments past  SCANHADR.  The  SGO  bit  is  also  cleared  by clearing the EN bit (CRCCON0 register).",
    "14.9 Configuring the Scanner\nThe scanner module may be used in conjunction with the CRC module to perform a CRC calculation over a range of program memory or Data EEPROM addresses. In order to set up the scanner to work with the CRC, perform the following steps:",
    "14.9 Configuring the Scanner\n1. Set  up  the  CRC  module  (See Section 14.7 'Configuring the CRC' ) and enable the Scanner  module  by  setting  the  EN  bit  in  the SCANCON0 register.\n2. Choose  which  memory  region  the  Scanner module should operate on and set the MREG bit of the SCANCON0 register appropriately.\n3. If trigger is used for scanner operation, set the TRIGEN  bit  of  the  SCANCON0  register  and select the trigger source  using  SCANTRIG register. Select the trigger source using SCANTRIG register and then set the TRIGEN bit of the SCANCON0 register. See Table 14-1 for Scanner Operation.\n4. If  Burst  mode  of  operation  is  desired,  set  the BURSTMD  bit (SCANCON0  register). See Table 14-1 for Scanner Operation.\n5. Set the SCANLADRL/H/U and SCANHADRL/H/ U  registers with the beginning  and  ending locations in memory that are to be scanned.\n6. Select the priority level for the Scanner module (See Section 3.1  'System  Arbitration' )  and lock the priorities (See Section 3.1.1 'Priority Lock' ).",
    "14.9 Configuring the Scanner\n7. Both CRCEN and CRCGO bits must be enabled to use the scanner. Setting the SGO bit will start the scanner operation.",
    "14.10 Scanner Interrupt\nThe scanner will trigger an interrupt when the SCANLADR increments past SCANHADR. The SCANIF bit can only be cleared in software.",
    "14.11 Scanning Modes\nThe interaction of the scanner with the system operation is controlled by the priority selection in the System  Arbiter  (see Section  3.2 'Memory  Access Scheme' ). Additionally, BURSTMD and TRIGEN also determine the operation of the Scanner.",
    "14.11.1 TRIGEN = 0 , BURSTMD = 0\nIn this case, the memory access request is granted to the scanner  if no  other  higher priority source  is requesting access.\nAll sources with lower priority than the scanner will get the memory access cycles that are not utilized by the scanner.",
    "14.11.2 TRIGEN = 1 , BURSTMD = 0\nIn this case, the memory access request is generated when the CRC module is ready to accept.\nThe memory access request is granted to the scanner if no other higher priority source is requesting access. All sources with lower priority than the scanner will get the memory access cycles that are not utilized by the scanner.\nThe memory access request is granted to the scanner if no other higher priority source is requesting access. All sources with lower priority than the scanner will get the memory access cycles that are not utilized by the scanner.",
    "14.11.3 TRIGEN = x , BURSTMD = 1\nIn this case, the memory access is always requested by the scanner.\nThe memory access request is granted to the scanner if no other higher priority source is requesting access. The memory access cycles will not be granted to lower priority  sources  than  the  scanner  until  it  completes operation i.e., SGO = 0 (SCANCON0 register)\nNote:\nIf  TRIGEN  = 1 and  BURSTMD = 1 ,  the user should ensure that the trigger source is active  for  the  Scanner  operation  to complete.",
    "14.12 Register Definitions: CRC and Scanner Control\nLong bit name prefixes for the CRC and Scanner periph - erals are shown below. Refer to Section 1.3.2.2 'Long Bit Names' for more information.\nCRC, Bit Name Prefix = CRC",
    "REGISTER 14-1: CRCCON0: CRC CONTROL REGISTER 0\nEN, R/W-0/0 = GO. EN, R-0 = BUSY. EN, R/W-0/0 = ACCM. EN, U-0 = -. EN, U-0 = -. EN, R/W-0/0 = SHIFTM. EN, R-0 = FULL. bit 7, R/W-0/0 = . bit 7, R-0 = . bit 7, R/W-0/0 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, R/W-0/0 = . bit 7, R-0 = bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7 EN: CRC Enable bit\n1 = CRC module is enabled\n0 = CRC is disabled\nbit 6\nGO: CRC Go bit\n1 = Start CRC serial shifter\n0 = CRC serial shifter turned off\nbit 5\nBUSY: CRC Busy bit\n1 = Shifting in progress or pending\n0 = All valid bits in shifter have been shifted into accumulator\nbit 4\nACCM: Accumulator Mode bit\n1 = Data is concatenated with zeros\n0 = Data is not concatenated with zeros\nbit 3-2\nUnimplemented: Read as ' 0 '\nbit 1\nSHIFTM: Shift Mode bit\n1 = Shift right (LSb)\n0 = Shift left (MSb)\nbit 0\nFULL: Data Path Full Indicator bit\n1 = CRCDATH/L registers are full\n0 = CRCDATH/L registers have shifted their data into the shifter",
    "REGISTER 14-2: CRCCON1: CRC CONTROL REGISTER 1\nbit 7, R/W-0/0.DLEN<3:0> = . bit 7, R/W-0/0.DLEN<3:0> = . bit 7, R/W-0/0. = . bit 7, R/W-0/0.PLEN<3:0> = . bit 7, R/W-0/0.PLEN<3:0> = . bit 7, R/W-0/0.PLEN<3:0> = . bit 7, R/W-0/0. = bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-4",
    "REGISTER 14-2: CRCCON1: CRC CONTROL REGISTER 1\nDLEN<3:0>: Data Length bits\nDenotes the length of the data word -1 (See Example 14-1)\nbit 3-0\nPLEN<3:0>: Polynomial Length bits\nDenotes the length of the polynomial -1 (See Example 14-1)",
    "REGISTER 14-3: CRCDATH: CRC DATA HIGH BYTE REGISTER\nbit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x.DATA<15:8> = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = bit 0\nR = Readable bit, W=Writable bit = x = Bit is. R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = ",
    "REGISTER 14-3: CRCDATH: CRC DATA HIGH BYTE REGISTER\nbit 7-0 DATA<15:8> : CRC Input/Output Data bits",
    "REGISTER 14-4: CRCDATL: CRC DATA LOW BYTE REGISTER\nbit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x.DATA<7:0> = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = bit 0\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, U = Unimplemented bit, read as '0' = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = \nbit 7-0",
    "REGISTER 14-4: CRCDATL: CRC DATA LOW BYTE REGISTER\nDATA<7:0> : CRC Input/Output Data bits\nWriting to this register fills the shifter.",
    "REGISTER 14-5: CRCACCH: CRC ACCUMULATOR HIGH BYTE REGISTER\nbit 7, R/W-0/0.ACC<15:8> = . bit 7, R/W-0/0.ACC<15:8> = . bit 7, R/W-0/0.ACC<15:8> = . bit 7, R/W-0/0.ACC<15:8> = . bit 7, R/W-0/0.ACC<15:8> = . bit 7, R/W-0/0.ACC<15:8> = . bit 7, R/W-0/0.ACC<15:8> = bit 0",
    "REGISTER 14-5: CRCACCH: CRC ACCUMULATOR HIGH BYTE REGISTER\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = Resets. u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = \nbit 7-0 ACC<15:8> : CRC Accumulator Register bits",
    "REGISTER 14-6: CRCACCL: CRC ACCUMULATOR LOW BYTE REGISTER\nbit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0.ACC<7:0> = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0",
    "REGISTER 14-6: CRCACCL: CRC ACCUMULATOR LOW BYTE REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = \nbit 7-0 ACC<7:0> : CRC Accumulator Register bits",
    "REGISTER 14-7: CRCSHIFTH: CRC SHIFT HIGH BYTE REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. SHIFT<15:8>, 1 = SHIFT<15:8>. SHIFT<15:8>, 2 = SHIFT<15:8>. SHIFT<15:8>, 3 = SHIFT<15:8>. SHIFT<15:8>, 4 = SHIFT<15:8>. SHIFT<15:8>, 5 = SHIFT<15:8>. SHIFT<15:8>, 6 = SHIFT<15:8>. SHIFT<15:8>, 7 = SHIFT<15:8>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 14-7: CRCSHIFTH: CRC SHIFT HIGH BYTE REGISTER\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, U = Unimplemented bit, read as '0' = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "bit 7-0 SHIFT<15:8> : CRC Shifter Register bits\nReading from this register reads the CRC Shifter.",
    "REGISTER 14-8: CRCSHIFTL: CRC SHIFT LOW BYTE REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. SHIFT<7:0>, 1 = SHIFT<7:0>. SHIFT<7:0>, 2 = SHIFT<7:0>. SHIFT<7:0>, 3 = SHIFT<7:0>. SHIFT<7:0>, 4 = SHIFT<7:0>. SHIFT<7:0>, 5 = SHIFT<7:0>. SHIFT<7:0>, 6 = SHIFT<7:0>. SHIFT<7:0>, 7 = SHIFT<7:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 14-8: CRCSHIFTL: CRC SHIFT LOW BYTE REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = \nbit 7-0\nSHIFT<7:0> : CRC Shifter Register bits\nReading from this register reads the CRC Shifter.",
    "REGISTER 14-9: CRCXORH: CRC XOR HIGH BYTE REGISTER\nbit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x.X<15:8> = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = ",
    "REGISTER 14-9: CRCXORH: CRC XOR HIGH BYTE REGISTER\nbit 7-0 X<15:8> : XOR of Polynomial Term X n  Enable bits",
    "REGISTER 14-10: CRCXORL: CRC XOR LOW BYTE REGISTER\nbit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x.X<7:1> = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, U-1.- = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit = \nbit 7-1\nX<7:1> : XOR of Polynomial Term X n  Enable bits\nbit 0",
    "REGISTER 14-10: CRCXORL: CRC XOR LOW BYTE REGISTER\nUnimplemented: Read as ' 1 '",
    "REGISTER 14-11: SCANCON0: SCANNER ACCESS CONTROL REGISTER 0\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W/HC-0/0. R/W-0/0, 3 = U-0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R-0/0. EN, 1 = TRIGEN. EN, 2 = SGO. EN, 3 = -. EN, 4 = -. EN, 5 = MREG. EN, 6 = BURSTMD. EN, 7 = BUSY. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nHC = Bit is cleared by hardware\nbit 7 EN: Scanner Enable bit (1)\n1 = Scanner is enabled\n0 = Scanner is disabled\nbit 6\nTRIGEN: Scanner Trigger Enable bit (2)\n1 = Scanner trigger is enabled\n0 = Scanner trigger is disabled\nRefer Table 14-1.\nbit 5\nSGO: Scanner GO bit (3, 4)\n1 = When the CRC is ready, the Memory region set by the MREG bit will be accessed and data is passed to the CRC peripheral.\n0 = Scanner operations will not occur",
    "bit 4-3 Unimplemented: Read as ' 0 '\nbit 2\nMREG: Scanner Memory Region Select bit (2)\n1 = Scanner address points to Data EEPROM\n0 = Scanner address points to Program Flash Memory",
    "bit 1\nBURSTMD: Scanner Burst Mode bit\n1 = Memory access request to the CPU Arbiter is always true\n0 = Memory access request to the CPU Arbiter is dependent on the CRC request and Trigger\nRefer Table 14-1.",
    "bit 0 BUSY: Scanner Busy Indicator bit\n1 = Scanner cycle is in process\n- 0 = Scanner cycle is compete (or never started)\nNote\n1: Setting EN = 1 (SCANCON0 register) does not affect any other register content.\n2: Scanner trigger selection can be set using the SCANTRIG register.\n3: This bit can be cleared in software. It is cleared in hardware when LADR>HADR (and a data cycle is not occurring) or when CRCGO = 0 (CRCCON0 register).\n4: CRCEN and CRCGO bits (CRCCON0 register) must be set before setting the SGO bit.",
    "TABLE 14-1: SCANNER OPERATING MODES (1)\nNote 1: See Section 3.1 'System Arbitration' for Priority selection and Section 3.2 'Memory Access Scheme' for Memory Access Scheme.\n\n0, BURSTMD = 0. 0, Scanner Operation = Memory access is requested when the CRC module is ready to accept data; the request is granted if no other higher priority source request is pending.. 1, BURSTMD = 0. 1, Scanner Operation = Memory access is requested when the CRC module is ready to accept data and trigger selection is true; the request is granted if no other higher priority source request is pending.. x, BURSTMD = 1. x, Scanner Operation = Memory access is always requested, the request is granted if no other higher priority source request is pending.",
    "REGISTER 14-12: SCANLADRU: SCAN LOW ADDRESS UPPER BYTE REGISTER\n-, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = LADR<21:16>. -, R/W-0/0 = (1,2). -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "REGISTER 14-12: SCANLADRU: SCAN LOW ADDRESS UPPER BYTE REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-0\nLADR<21:16>:\nScan Start/Current Address bits (1,2)\nUpper bits of the current address to be fetched from, value increments on each fetch of memory.",
    "REGISTER 14-12: SCANLADRU: SCAN LOW ADDRESS UPPER BYTE REGISTER\nNote 1: Registers SCANLADRU/H/L form a 22-bit value, but are not guarded for atomic or asynchronous access; registers should only be read or written while SGO = 0 (SCANCON0 register).\n2: While SGO = 1 (SCANCON0 register), writing to this register is ignored.",
    "REGISTER 14-13: SCANLADRH: SCAN LOW ADDRESS HIGH BYTE REGISTER\nbit 7, R/W-0/0.LADR<15:8> (1, 2) = . bit 7, R/W-0/0.LADR<15:8> (1, 2) = . bit 7, R/W-0/0.LADR<15:8> (1, 2) = . bit 7, R/W-0/0.LADR<15:8> (1, 2) = . bit 7, R/W-0/0.LADR<15:8> (1, 2) = . bit 7, R/W-0/0.LADR<15:8> (1, 2) = . bit 7, R/W-0/0.LADR<15:8> (1, 2) = bit 0",
    "REGISTER 14-13: SCANLADRH: SCAN LOW ADDRESS HIGH BYTE REGISTER\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7-0\nLADR<15:8> : Scan Start/Current Address bits (1, 2)\nMost Significant bits of the current address to be fetched from, value increments on each fetch of memory.\nNote 1: Registers SCANLADRU/H/L form a 22-bit value, but are not guarded for atomic or asynchronous access; registers should only be read or written while SGO = 0 (SCANCON0 register).\n2: While SGO = 1 (SCANCON0 register), writing to this register is ignored.",
    "REGISTER 14-14: SCANLADRL: SCAN LOW ADDRESS LOW BYTE REGISTER\nbit 7, R/W-0/0. = . bit 7, R/W-0/0.LADR<7:0> (1, 2) = . bit 7, R/W-0/0.LADR<7:0> (1, 2) = . bit 7, R/W-0/0.LADR<7:0> (1, 2) = . bit 7, R/W-0/0.LADR<7:0> (1, 2) = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0",
    "REGISTER 14-14: SCANLADRL: SCAN LOW ADDRESS LOW BYTE REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, = Unimplemented bit, read as '0' = U -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = ",
    "bit 7-0\nLADR<7:0> : Scan Start/Current Address bits (1, 2)\nLeast Significant bits of the current address to be fetched from, value increments on each fetch of memory\nNote 1: Registers SCANLADRU/H/L form a 22-bit value, but are not guarded for atomic or asynchronous access; registers should only be read or written while SGO = 0 (SCANCON0 register).\n2: While SGO = 1 (SCANCON0 register), writing to this register is ignored.",
    "REGISTER 14-15: SCANHADRU: SCAN HIGH ADDRESS UPPER BYTE REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-1/1. U-0, 3 = R/W-1/1. U-0, 4 = R/W-1/1. U-0, 5 = R/W-1/1. U-0, 6 = R/W-1/1. U-0, 7 = R/W-1/1. -, 1 = -. -, 2 = . -, 3 = . -, 4 = HADR<21:16>. -, 5 = . -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 14-15: SCANHADRU: SCAN HIGH ADDRESS UPPER BYTE REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = \nbit 7-6\nUnimplemented: Read as '0'\nbit 5-0\nHADR<21:16>: Scan End Address bits (1, 2)\nUpper bits of the address at the end of the designated scan\nNote 1: Registers SCANHADRU/H/L form a 22-bit value but are not guarded for atomic or asynchronous access; registers should only be read or written while SGO = 0 (SCANCON0 register).\n2: While SGO = 1 (SCANCON0 register), writing to this register is ignored.",
    "REGISTER 14-16: SCANHADRH: SCAN HIGH ADDRESS HIGH BYTE REGISTER\nbit 7, R/W-1/1.HADR<15:8> (1, 2) = . bit 7, R/W-1/1.HADR<15:8> (1, 2) = . bit 7, R/W-1/1.HADR<15:8> (1, 2) = . bit 7, R/W-1/1.HADR<15:8> (1, 2) = . bit 7, R/W-1/1.HADR<15:8> (1, 2) = . bit 7, R/W-1/1.HADR<15:8> (1, 2) = . bit 7, R/W-1/1.HADR<15:8> (1, 2) = bit 0",
    "REGISTER 14-16: SCANHADRH: SCAN HIGH ADDRESS HIGH BYTE REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, = Unimplemented bit, read as '0' = U. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets",
    "bit 7-0 HADR<15:8> : Scan End Address bits (1, 2)\nMost Significant bits of the address at the end of the designated scan\nNote 1: Registers SCANHADRU/H/L form a 22-bit value, but are not guarded for atomic or asynchronous access; registers should only be read or written while SGO = 0 (SCANCON0 register).\n2: While SGO = 1 (SCANCON0 register), writing to this register is ignored.",
    "REGISTER 14-17: SCANHADRL: SCAN HIGH ADDRESS LOW BYTE REGISTER\nbit 7, R/W-1/1.HADR<7:0> (1, 2) = . bit 7, R/W-1/1.HADR<7:0> (1, 2) = . bit 7, R/W-1/1.HADR<7:0> (1, 2) = . bit 7, R/W-1/1.HADR<7:0> (1, 2) = . bit 7, R/W-1/1.HADR<7:0> (1, 2) = . bit 7, R/W-1/1.HADR<7:0> (1, 2) = . bit 7, R/W-1/1.HADR<7:0> (1, 2) = bit 0",
    "REGISTER 14-17: SCANHADRL: SCAN HIGH ADDRESS LOW BYTE REGISTER\nR = Readable bit u = Bit is,  = W=Writable x = Bit is unknown. R = Readable bit u = Bit is,  = U = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7-0 HADR<7:0> : Scan End Address bits (1, 2)\nLeast Significant bits of the address at the end of the designated scan\nNote 1: Registers SCANHADRU/H/L form a 22-bit value, but are not guarded for atomic or asynchronous access; registers should only be read or written while SGO = 0 (SCANCON0 register).\n2: While SGO = 1 (SCANCON0 register), writing to this register is ignored.",
    "REGISTER 14-18: SCANTRIG: SCAN TRIGGER SELECTION REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = . -, 5 = TSEL<3:0>. -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3-0 TSEL<3:0> : Scanner Data Trigger Input Selection bits\n1111 = Reserved\n\u2022\n\u2022\n\u2022\n1010 =\nReserved\n1001 = SMT1_output\n1000 =\nTMR6_postscaled\n0111 = TMR5_output\n0110 = TMR4_postscaled\n0101 =    TMR3_output\n0100 =    TMR2_postscaled\n0011 =    TMR1_output\n0010 =    TMR0_output\n0001\n=    CLKREF_output\n0000 =    LFINTOSC",
    "TABLE 14-2: SUMMARY OF REGISTERS ASSOCIATED WITH CRC\nCRCACCH, Bit 7 = ACC<15:8>. CRCACCH, Bit 6 = ACC<15:8>. CRCACCH, Bit 5 = ACC<15:8>. CRCACCH, Bit 4 = ACC<15:8>. CRCACCH, Bit 3 = ACC<15:8>. CRCACCH, Bit 2 = ACC<15:8>. CRCACCH, Bit 1 = ACC<15:8>. CRCACCH, Bit 0 = ACC<15:8>. CRCACCH, Register on Page = 209. CRCACCL, Bit 7 = ACC<7:0>. CRCACCL, Bit 6 = ACC<7:0>. CRCACCL, Bit 5 = ACC<7:0>. CRCACCL, Bit 4 = ACC<7:0>. CRCACCL, Bit 3 = ACC<7:0>. CRCACCL, Bit 2 = ACC<7:0>. CRCACCL, Bit 1 = ACC<7:0>. CRCACCL, Bit 0 =",
    "TABLE 14-2: SUMMARY OF REGISTERS ASSOCIATED WITH CRC\nACC<7:0>. CRCACCL, Register on Page = 210. CRCCON0, Bit 7 = EN. CRCCON0, Bit 6 = GO. CRCCON0, Bit 5 = BUSY. CRCCON0, Bit 4 = ACCM. CRCCON0, Bit 3 = -. CRCCON0, Bit 2 = -. CRCCON0, Bit 1 = SHIFTM. CRCCON0, Bit 0 = FULL. CRCCON0, Register on Page = 208. CRCCON1, Bit 7 = DLEN<3:0>. CRCCON1, Bit 6 = DLEN<3:0>. CRCCON1, Bit 5 = DLEN<3:0>. CRCCON1, Bit 4 = DLEN<3:0>. CRCCON1, Bit 3 = PLEN<3:0>. CRCCON1, Bit 2 = PLEN<3:0>. CRCCON1, Bit 1 = PLEN<3:0>. CRCCON1, Bit 0 = PLEN<3:0>. CRCCON1,",
    "TABLE 14-2: SUMMARY OF REGISTERS ASSOCIATED WITH CRC\nRegister on Page = 208. CRCDATH, Bit 7 = DATA<15:8>. CRCDATH, Bit 6 = DATA<15:8>. CRCDATH, Bit 5 = DATA<15:8>. CRCDATH, Bit 4 = DATA<15:8>. CRCDATH, Bit 3 = DATA<15:8>. CRCDATH, Bit 2 = DATA<15:8>. CRCDATH, Bit 1 = DATA<15:8>. CRCDATH, Bit 0 = DATA<15:8>. CRCDATH, Register on Page = 209. CRCDATL, Bit 7 = DATA<7:0>. CRCDATL, Bit 6 = DATA<7:0>. CRCDATL, Bit 5 = DATA<7:0>. CRCDATL, Bit 4 = DATA<7:0>. CRCDATL, Bit 3 = DATA<7:0>. CRCDATL, Bit 2 = DATA<7:0>. CRCDATL, Bit 1 = DATA<7:0>. CRCDATL, Bit 0 =",
    "TABLE 14-2: SUMMARY OF REGISTERS ASSOCIATED WITH CRC\nDATA<7:0>. CRCDATL, Register on Page = 209. CRCSHIFTH, Bit 7 = SHIFT<15:8>. CRCSHIFTH, Bit 6 = SHIFT<15:8>. CRCSHIFTH, Bit 5 = SHIFT<15:8>. CRCSHIFTH, Bit 4 = SHIFT<15:8>. CRCSHIFTH, Bit 3 = SHIFT<15:8>. CRCSHIFTH, Bit 2 = SHIFT<15:8>. CRCSHIFTH, Bit 1 = SHIFT<15:8>. CRCSHIFTH, Bit 0 = SHIFT<15:8>. CRCSHIFTH, Register on Page = 210. CRCSHIFTL, Bit 7 = SHIFT<7:0>. CRCSHIFTL, Bit 6 = SHIFT<7:0>. CRCSHIFTL, Bit 5 = SHIFT<7:0>. CRCSHIFTL, Bit 4 = SHIFT<7:0>. CRCSHIFTL, Bit 3 = SHIFT<7:0>. CRCSHIFTL,",
    "TABLE 14-2: SUMMARY OF REGISTERS ASSOCIATED WITH CRC\nBit 2 = SHIFT<7:0>. CRCSHIFTL, Bit 1 = SHIFT<7:0>. CRCSHIFTL, Bit 0 = SHIFT<7:0>. CRCSHIFTL, Register on Page = 210. CRCXORH, Bit 7 = X<15:8>. CRCXORH, Bit 6 = X<15:8>. CRCXORH, Bit 5 = X<15:8>. CRCXORH, Bit 4 = X<15:8>. CRCXORH, Bit 3 = X<15:8>. CRCXORH, Bit 2 = X<15:8>. CRCXORH, Bit 1 = X<15:8>. CRCXORH, Bit 0 = X<15:8>. CRCXORH, Register on Page = 211. CRCXORL, Bit 7 = X<7:1>. CRCXORL, Bit 6 = X<7:1>. CRCXORL, Bit 5 = X<7:1>.",
    "TABLE 14-2: SUMMARY OF REGISTERS ASSOCIATED WITH CRC\nCRCXORL, Bit 4 = X<7:1>. CRCXORL, Bit 3 = X<7:1>. CRCXORL, Bit 2 = X<7:1>. CRCXORL, Bit 1 = X<7:1>. CRCXORL, Bit 0 = -. CRCXORL, Register on Page = 211. SCANCON0, Bit 7 = EN. SCANCON0, Bit 6 = TRIGEN. SCANCON0, Bit 5 = SGO. SCANCON0, Bit 4 = -. SCANCON0, Bit 3 = -. SCANCON0, Bit 2 = MREG. SCANCON0, Bit 1 = BURSTMD. SCANCON0, Bit 0 = BUSY. SCANCON0, Register on Page = 212. SCANHADRU, Bit 7 = -. SCANHADRU, Bit 6 = -. SCANHADRU, Bit 5 = HADR<21:16>. SCANHADRU, Bit 4 = HADR<21:16>. SCANHADRU, Bit 3 = HADR<21:16>. SCANHADRU, Bit 2 =",
    "TABLE 14-2: SUMMARY OF REGISTERS ASSOCIATED WITH CRC\nHADR<21:16>. SCANHADRU, Bit 1 = HADR<21:16>. SCANHADRU, Bit 0 = HADR<21:16>. SCANHADRU, Register on Page = 214. SCANHADRH, Bit 7 = HADR<15:8>. SCANHADRH, Bit 6 = HADR<15:8>. SCANHADRH, Bit 5 = HADR<15:8>. SCANHADRH, Bit 4 = HADR<15:8>. SCANHADRH, Bit 3 = HADR<15:8>. SCANHADRH, Bit 2 = HADR<15:8>. SCANHADRH, Bit 1 = HADR<15:8>. SCANHADRH, Bit 0 = HADR<15:8>. SCANHADRH, Register on Page = 215. SCANHADRL, Bit 7 = HADR<7:0>. SCANHADRL, Bit 6 = HADR<7:0>. SCANHADRL, Bit 5 = HADR<7:0>. SCANHADRL, Bit 4 = HADR<7:0>. SCANHADRL, Bit 3",
    "TABLE 14-2: SUMMARY OF REGISTERS ASSOCIATED WITH CRC\n= HADR<7:0>. SCANHADRL, Bit 2 = HADR<7:0>. SCANHADRL, Bit 1 = HADR<7:0>. SCANHADRL, Bit 0 = HADR<7:0>. SCANHADRL, Register on Page = 215. SCANLADRU, Bit 7 = -. SCANLADRU, Bit 6 = -. SCANLADRU, Bit 5 = LADR<21:16>. SCANLADRU, Bit 4 = LADR<21:16>. SCANLADRU, Bit 3 = LADR<21:16>. SCANLADRU, Bit 2 = LADR<21:16>. SCANLADRU, Bit 1 = LADR<21:16>. SCANLADRU, Bit 0 = LADR<21:16>. SCANLADRU, Register on Page = 213. SCANLADRH, Bit 7 = LADR<15:8>. SCANLADRH, Bit 6 = LADR<15:8>. SCANLADRH, Bit 5 = LADR<15:8>. SCANLADRH, Bit 4 = LADR<15:8>.",
    "TABLE 14-2: SUMMARY OF REGISTERS ASSOCIATED WITH CRC\nSCANLADRH, Bit 3 = LADR<15:8>. SCANLADRH, Bit 2 = LADR<15:8>. SCANLADRH, Bit 1 = LADR<15:8>. SCANLADRH, Bit 0 = LADR<15:8>. SCANLADRH, Register on Page = 213. SCANLADRL, Bit 7 = LADR<7:0>. SCANLADRL, Bit 6 = LADR<7:0>. SCANLADRL, Bit 5 = LADR<7:0>. SCANLADRL, Bit 4 = LADR<7:0>. SCANLADRL, Bit 3 = LADR<7:0>. SCANLADRL, Bit 2 = LADR<7:0>. SCANLADRL, Bit 1 = LADR<7:0>. SCANLADRL, Bit 0 = LADR<7:0>. SCANLADRL, Register on Page = 214. SCANTRIG, Bit 7 = -. SCANTRIG, Bit 6 = -. SCANTRIG, Bit 5 = -. SCANTRIG, Bit 4 = -. SCANTRIG, Bit 3 =",
    "TABLE 14-2: SUMMARY OF REGISTERS ASSOCIATED WITH CRC\nTSEL<3:0>. SCANTRIG, Bit 2 = TSEL<3:0>. SCANTRIG, Bit 1 = TSEL<3:0>. SCANTRIG, Bit 0 = TSEL<3:0>. SCANTRIG, Register on Page = 216\nLegend: - = unimplemented location, read as ' 0 '. Shaded cells are not used for the CRC module.",
    "15.1 Introduction\nThe Direct Memory Access (DMA) module is designed to  service  data  transfers  between  different  memory regions directly without intervention from the CPU. By eliminating the need for CPU-intensive management of handling interrupts intended for data transfers, the CPU now can spend more time on other tasks.\nPIC18(L)F25/26K83  family  has  two  DMA  modules which  can  be  independently  programmed  to  transfer data between different memory locations, move differ -ent data sizes, and use a wide range of hardware trig -gers  to  initiate  transfers. The  two  DMA  registers  can even be programmed to work together, in order to carry out  more  complex  data  transfers  without  CPU  over -head.\nKey features of the DMA module include:",
    "15.1 Introduction\n\u00b7 Support access to the following memory regions:\n-GPR and SFR space (R/W)\n-Program Flash Memory (R only)\n-Data EEPROM Memory (R only)\n\u00b7 Programmable priority between the DMA and CPU Operations. Refer to Section 3.1 'System Arbitration' for details.\n\u00b7 Programmable Source and Destination address modes\n-Fixed address\n-Post-increment address\n-Post-decrement address\n\u00b7 Programmable Source and Destination sizes\n\u00b7 Source and destination pointer register, dynamically updated and reloadable\n\u00b7 Source and destination count register, dynamically updated and reloadable\n\u00b7 Programmable auto-stop based on Source or Destination counter\n\u00b7 Software triggered transfers\n\u00b7 Multiple user selectable sources for hardware triggered transfers\n\u00b7 Multiple user selectable sources for aborting DMA transfers",
    "15.2 DMA Registers\nThe operation  of  the  DMA  module  has  the  following registers:\n\u00b7 Control registers (DMAxCON0, DMAxCON1)\n\u00b7 Data buffer register (DMAxBUF)\n\u00b7 Source Start Address Register (DMAxSSAU:H:L)\n\u00b7 Source Pointer Register (DMAxSPTRU:H:L)\n\u00b7 Source Message Size Register (DMAxSSZH:L)\n\u00b7 Source Count Register (DMAxSCNTH:L)\n\u00b7 Destination Start Address Register (DMAxDSAH:L)\n\u00b7 Destination Pointer Register (DMAxDPTRH:L)\n\u00b7 Destination Message Size Register (DMAxDSZH:L)\n\u00b7 Destination Count Register (DMAxDCNTH:L)\n\u00b7 Start Interrupt Request Source Register (DMAxSIRQ)\n\u00b7 Abort Interrupt Request Source Register (DMAxAIRQ)\nThese registers are detailed in Section 15.13 'Regis -ter definitions: DMA' .",
    "15.3 DMA Organization\nThe  DMA  module  on  the  K83  family  of  devices  is designed to move data by using the existing Instruction Bus<16> and Data Bus<8> without the need for any dual-porting of memory or peripheral systems (Figure 15-1).  The  DMA  accesses  the  required  bus when it has been granted to by the System Arbiter.\nFIGURE 15-1: DMA FUNCTIONAL BLOCK DIAGRAM\nDepending on the priority of the DMA with respect to CPU execution (Refer to Section 3.2 'Memory Access  Scheme' for  more  information),  the  DMA Controller can move data through two methods:\n\u00b7 Stalling the CPU execution until it has completed its transfers (DMA has higher priority over the CPU in this mode of operation)\n\u00b7 Utilizing unused CPU cycles for DMA transfers (CPU has higher priority over the DMA in this mode of operation). Unused CPU cycles are referred to as bubbles which are instruction cycles available for use by the DMA to perform read and write operations. In this way, the effective bandwidth for handling data is increased; at the same time, DMA operations can proceed without causing a processor stall.",
    "15.4 DMA Interface\nThe DMA module transfers data from the source to the destination one byte at a time, this smallest data move -ment is called a DMA data transaction. A DMA Mes -sage refers to one or more DMA data transactions.\nEach DMA data transaction consists of two separate actions:\n\u00b7 Reading the Source Address Memory and storing the value in the DMA Buffer register\n\u00b7 Writing the contents of the DMA Buffer register to the Destination Address Memory\nNote:\nDMA  data movement  is a two-cycle operation.\nThe  XIP  bit  (DMAxCON0  register)  is  a  Status  bit  to indicate  whether  or  not  the  data  in  the  DMAxBUF register has been written to the destination address. If the bit is set then data is waiting to be written to the destination. If clear it means that either data has been written  to  the  destination  or  that  no  source  read  has occurred.\nThe DMA has read access to PFM, Data EEPROM, and SFR/GPR space, and write access to SFR/GPR space.  Based  on  these  memory  access  capabilities, the DMA can support the following memory transactions:",
    "TABLE 15-1: DMA MEMORY ACCESS\nProgram Flash Memory, Write Destination = GPR. Program Flash Memory, Write Destination = SFR. Data EE, Write Destination = GPR. Data EE, Write Destination = SFR. GPR, Write Destination = GPR. SFR, Write Destination = GPR. GPR, Write Destination = SFR. SFR, Write Destination = SFR\nEven  though  the  DMA  module  has  access  to  all memory and peripherals that are also available to the CPU, it is recommended that the DMA does not access any register that is part of the System arbitration. The DMA, as a system arbitration client should not be read or written by itself or by another DMA instantiation.\nThe  following  sections  discuss  the  various  control interfaces required for DMA data transfers.",
    "15.4.1 DMA ADDRESSING\nThe start addresses for the source read and destination write  operations are set using  the DMAxSSA <21:0> and DMAxDSA <15:0> registers, respectively.\nWhen the DMA Message transfers are in progress, the DMAxSPTR <21:0> and DMAxDPTR <15:0> registers contain the current address pointers for each source read  and  destination  write  operation,  these  registers are  modified  after  each  transaction  based  on  the Address mode selection bits.\nThe  SMODE  and  DMODE  bits  in  the  DMAxCON1 control register determine  the address  modes  of operation  by controlling how  the  DMAxSPTR <21:0> and DMAxDPTR <15:0> bits are updated after every DMA data transaction combination (Figure 15-2).\nEach address can be separately configured to:\n\u00b7 Remain unchanged\n\u00b7 Increment by 1\n\u00b7 Decrement by 1",
    "15.4.1 DMA ADDRESSING\nThe  DMA  can  initiate  data  transfers  from  the  PFM, Data  EEPROM or SFR/GPR Space. The SMR<1:0> bits in the DMAxCON1 register are used to select the type  of  memory  being  pointed  to  by  the  Source Address  Pointer.  The  SMR<1.0>  bits  are  required because the PFM and SFR/GPR spaces have overlap -ping addresses that do not allow the specified address to uniquely define the memory location to be accessed.\nregisters count the destination transactions. Both are simultaneously decremented by one after each transaction.\nNote 1: For proper memory read access to occur, the  combination  of  address  and  space selection must be valid.\n2: The  destination  does  not  have  space selection bits because it can only write to the SFR/GPR space.",
    "15.4.2 DMA MESSAGE SIZE/COUNTERS\nA transaction  is  the  transfer  of  one  byte. A  message consists of one or more transactions. A complete DMA process consists of one or more messages. The size registers  determine  how  many  transactions  are  in  a message.  The  DMAxSSZ  registers  determine  the source  size  and  DMAxDSZ  registers  determine  the destination size.\nWhen a DMA transfer is initiated, the size registers are copied to corresponding counter registers that control the duration of the message. The DMAxSCNT registers count  the  source  transactions  and  the  DMAxDCNT\nA  message  is  started  by  setting  the  DGO  bit  of  the DMAxCON0 register and terminates when the smaller of the two counters reaches zero.\nWhen  either  counter  reaches  zero  the  DGO  bit  is cleared  and  the  counter  and  pointer  registers  are immediately reloaded with the corresponding size and address data. If the other counter did not reach zero then the next message will continue with the count and address corresponding to that register.",
    "15.4.2 DMA MESSAGE SIZE/COUNTERS\nWhen the source and destination size registers are not equal then the ratio of the largest to the smallest size determines  how  many  messages  are  in  the  DMA process. For example, when the destination size is 6 and the source size is 2 then each message will consist of two transactions and the complete DMA process will consist of three messages. When the larger size is not an  even  integer  of  the  smaller  size  then  the  last message in the process will terminate early when the larger  count  reaches  zero.  In  that  case,  the  larger counter will reset and the smaller counter will have a remainder skewing any subsequent messages by that amount.\nNote:\nReading the DMAxSCNT or DMAxDCNT registers  will  never  return  zero.  When either register is decremented from ' 1 ' it is immediately reloaded from the corresponding size register.",
    "FIGURE 15-3: DMA COUNTERS BLOCK DIAGRAM\nTable 15-2  has  a  few  examples  of  configuring  DMA Message sizes.",
    "TABLE 15-2: EXAMPLE MESSAGE SIZE TABLE\nRead from single SFR location to RAM, Example = U1RXB. Read from single SFR location to RAM, SCNT = 1. Read from single SFR location to RAM, DCNT = N. Read from single SFR location to RAM, Comments = N equals the number of bytes desired in the destination buffer. N >= 1.. Write to single SFR location from RAM, Example = U1TXB. Write to single SFR location from RAM, SCNT = N. Write to single SFR location from RAM, DCNT = 1. Write to single SFR location from RAM, Comments = N equals the number of bytes desired in the source buffer. N >= 1.. Read from multiple SFR location, Example = ADRES[H:L]. Read from multiple SFR location, SCNT = 2. Read from multiple SFR location, DCNT = 2*N. Read from multiple SFR location, Comments = N equals the number of ADC results to be stored in memory. N>= 1. Read from multiple SFR location, Example = TMR1[H:L]. Read from multiple SFR location, SCNT",
    "TABLE 15-2: EXAMPLE MESSAGE SIZE TABLE\n= 2. Read from multiple SFR location, DCNT = 2*N. Read from multiple SFR location, Comments = N equals the number of TMR1 Acquisition results to be stored in memory. N>= 1. Read from multiple SFR location, Example = SMT1CPR[U:H:L]. Read from multiple SFR location, SCNT = 3. Read from multiple SFR location, DCNT = 3*N. Read from multiple SFR location, Comments = N equals the number of Capture Pulse Width measurements to be stored in memory. N>= 1. Write to Multiple SFR regis - ters, Example = PWMDC[H:L]. Write to Multiple SFR regis - ters, SCNT = 2*N. Write to Multiple SFR regis - ters, DCNT = 2. Write to Multiple SFR regis - ters, Comments = N equals the number of PWM duty cycle val - ues to be loaded from a memory table. N>= 1. Write to Multiple SFR regis - ters, Example = All ADC registers. Write to Multiple SFR regis - ters, SCNT",
    "TABLE 15-2: EXAMPLE MESSAGE SIZE TABLE\n= N*31. Write to Multiple SFR regis - ters, DCNT = 31. Write to Multiple SFR regis - ters, Comments = Using the DMAto transfer a complete ADC context from RAM to the ADC registers.N>= 1",
    "15.5 DMA Message Transfers\nOnce  the  Enable  bit  is  set  to  start  DMA  message transfers, the Source/Destination pointer and counter registers  are  initialized  to  the  conditions  shown  in Table 15-3.",
    "TABLE 15-3: DMA INITIAL CONDITIONS\nDMAxSPTR<21:0>, Value loaded = DMAxSSA<21:0>. DMAxSCNT<11:0>, Value loaded = DMAxSSZ<11:0>. DMAxDPTR<15:0>, Value loaded = DMAxDSA<15:0>. DMAxDCNT<11:0>, Value loaded = DMAxDSZ<11:0>\nDuring  the  DMA  Operation  after  each  transaction, Table 15-4  and  Table 15-5  indicate  how  the  Source/ Destination pointer and counter registers are modified",
    "TABLE 15-4: DMA SOURCE POINTER/COUNTER DURING OPERATION\nDMAxSCNT<11:0> != 1, Modified Source Counter/Pointer Value = DMAxSCNT = DMAxSCNT -1. DMAxSCNT<11:0> != 1, Modified Source Counter/Pointer Value = SMODE = 00: DMAxSPTR = DMAxSPTR. DMAxSCNT<11:0> != 1, Modified Source Counter/Pointer Value = SMODE = 01: DMAxSPTR = DMAxSPTR + 1. DMAxSCNT<11:0> != 1, Modified Source Counter/Pointer Value = SMODE = 10: DMAxSPTR = DMAxSPTR - 1. DMAxSCNT<11:0> == 1, Modified Source Counter/Pointer Value = DMAxSCNT = DMAxSSZ. DMAxSCNT<11:0> == 1, Modified Source Counter/Pointer Value = DMAxSPTR = DMAxSSA",
    "TABLE 15-5: DMA DESTINATION POINTER/COUNTER DURING OPERATION\nDMAxDCNT<11:0>!= 1, Modified Destination Counter/Pointer Value = DMAxDCNT = DMAxDCNT -1. DMAxDCNT<11:0>!= 1, Modified Destination Counter/Pointer Value = DMODE = 00: DMAxDPTR = DMAxDPTR. DMAxDCNT<11:0>!= 1, Modified Destination Counter/Pointer Value = DMODE = 01: DMAxDPTR = DMAxDPTR + 1. DMAxDCNT<11:0>!= 1, Modified Destination Counter/Pointer Value = DMODE = 10: DMAxDPTR = DMAxDPTR - 1. DMAxDCNT<11:0> == 1, Modified Destination Counter/Pointer Value = DMAxDCNT = DMAxDSZ. DMAxDCNT<11:0> == 1, Modified Destination Counter/Pointer Value = DMAxDPTR = DMAxDSA\nThe  following  sections  discuss  how  to  initiate  and terminate DMA transfers.\n15.5.1.1 User Software Control",
    "15.5.1 STARTING DMA MESSAGE TRANSFERS\nThe DMA can initiate data transactions by either of the following two conditions:\n1. User software control\n2. Hardware trigger, SIRQ\nSoftware  starts  or  stops  DMA  transaction  by  setting/ clearing  the  DGO  bit.  The  DGO  bit  is  also  used  to indicate  whether  a  DMA  hardware  trigger  has  been received and a message is in progress.\nNote 1: Software start can only occur if the EN bit (DMAxCON1) is set.\n2: If the CPU writes to the DGO bit while it is already  set,  there  is  no  effect  on  the system, the DMA will continue to operate normally.",
    "15.5.1.2 Hardware Trigger, SIRQ\nA Hardware trigger is an interrupt request from another module sent to the DMA with the purpose of starting a DMA message. The DMA start trigger source is user selectable using the DMAxSIRQ register.\nThe  SIRQEN  bit  (DMAxCON0  register)  is  used  to enable sampling of external interrupt triggers by which a DMA transfer can be started. When set the DMA will sample the selected Interrupt source and when cleared,  the  DMA  will  ignore  the  selected  Interrupt source.  Clearing  SIRQEN  does  not  stop  a  DMA transaction  currently  progress,  it only  stops  more hardware request signals from being received.",
    "15.5.2 STOPPING DMA MESSAGE TRANSFERS\nThe  DMA  controller  can  stop  data  transactions  by either of the following two conditions:\n1. Clearing the DGO bit\n2. Hardware trigger, AIRQ\n3. Source Count reload\n4. Destination Count reload\n5. Clearing the Enable bit",
    "15.5.2.1 User Software Control\nIf  the  user  clears  the  DGO  bit,  the  message  will  be stopped  and  the  DMA  will  remain  in  the  current configuration.\nFor example, if the user clears the DGO bit after source data  has  been  read  but  before  it  is  written  to  the destination, then the data in DMAxBUF will not reach its destination.\nThis is also referred to as a soft-stop as the operation can resume if desired by setting DGO bit again.",
    "15.5.2.2 Hardware Trigger, AIRQ\nThe  AIRQEN  bit  (DMAxCON0  register)  is  used  to enable sampling of external interrupt triggers by which a DMA transaction can be aborted.\nOnce an Abort interrupt request has been received, the DMA will perform a soft-stop by clearing the DGO bit as well  as  clearing  the  SIRQEN  bit  so  overruns  do  not occur.  The  AIRQEN  bit  is  also  cleared  to  prevent additional abort signals from triggering false aborts.\nIf desired, the DGO bit can be set again and the DMA will resume operation from where it left off after the softstop had occurred as none of the DMA  state information is changed in the event of an abort.",
    "15.5.2.3 Source Count Reload\nA DMA message is considered to be complete when the Source count register is decremented from 1 and then reloaded (i.e., once the last byte from either the source read or destination write has occurred). When the  SSTP  bit  is  set  (DMAxCON1  register)  and  the source count register is reloaded then further message transfer is stopped.",
    "15.5.2.4 Destination Count Reload\nA DMA message is considered to be complete when the Destination count register is decremented from 1 and then reloaded (i.e., once the last byte from either the  source  read  or  destination  write  has  occurred). When  the  DSTP  bit  is  set  (DMAxCON1)  and  the destination  count  register  is  reloaded  then  further message transfer is stopped.\nNote:\nReading the DMAxSCNT or DMAxDCNT registers  will  never  return  zero.  When either register is decremented from ' 1 ' it is immediately reloaded from the corresponding size register.",
    "15.5.2.5 Clearing the Enable bit\nIf  the  User  clears  the  EN  bit,  the  message  will  be stopped and the DMA  will return to its default configuration. This is also referred to as a hard-stop as the DMA cannot resume operation from where it was stopped.\nNote:\nAfter the DMA message transfer is stopped,  it  requires  an  extra  instruction cycle  before  the  Stop  condition  takes effect. Thus, after the Stop condition has occurred, a Source read or a Destination write can occur depending on the Source or Destination Bus availability.",
    "15.5.3 DISABLE DMA MESSAGES TRANSFERS UPON COMPLETION\nOnce  the  DMA  message  is  complete  it  may  be desirable  to  disable  the  trigger  source  to  prevent overrun or under run of data. This can be done by either of the following methods:\n1. Clearing the SIRQEN bit\n2. Setting the SSTP bit\n3. Setting the DSTP bit",
    "15.5.3.1 Clearing the SIRQEN bit\nClearing the SIRQEN bit (DMAxCON1 register) stops the sampling of external start interrupt triggers hence preventing further DMA Message transfers.\nAn  example  would  be  a  communications  peripheral with  a  level-triggered  interrupt.  The  peripheral  will continue to request data (because its buffer is empty) even  though  there  is  no  more  data  to  be  moved. Disabling  the  SIRQEN  bit  prevents  the  DMA  from processing these requests",
    "15.5.3.2 Source/Destination Stop\nThe  SSTP  and  DSTP  bits  (DMAxCON0  register) determine  whether  or  not  to  disable  the  hardware triggers  (SIRQEN  = 0 )  once  a  DMA  message  has completed.\nWhen the SSTP bit is set and the DMAxSCNT = 0 , then the  SIRQEN  bit  will  be  cleared.  Similarly,  when  the DSTP bit is set and the DMAxDCNT = 0 , the SIRQEN bit will be cleared.",
    "Note:\nThe SSTP and DSTP bits are independent functions and do not depend on each other. It is possible for a message to be stopped by either counter at message end or both counters at message end.",
    "15.6 Types of Hardware Triggers\nThe DMA has two different trigger inputs namely the Source trigger and the abort trigger. Each of these trig -ger sources is user configurable using the DMAxSIRQ and DMAxAIRQ registers.\nBased on the source selected for each trigger, there are two types of requests that can be sent to the DMA.\n\u00b7 Edge triggers\n\u00b7 Level triggers",
    "15.6.1 EDGE TRIGGER REQUESTS\nEdge triggers are generated by the signal that sets the corresponding interrupt flag. The DMA responds to this event but leaves the interrupt flag set. An Edge request occurs  only  once  when  a  given  module  interrupt requirements are true.",
    "15.6.2 LEVEL TRIGGER REQUESTS\nA level request is asserted as long as the condition that causes  the  interrupt  is  true.  For  example,  the  RXIF interrupt is asserted as long as the UART receive buffer has unread data. The RXIF cannot be cleared except by emptying the receive buffer.",
    "15.7 Types of Data Transfers\nBased on the memory access capabilities of the DMA (See  Table 15-1),  the  following  sections  discuss  the different types of data movement between the Source and Destination Memory regions.\n- \u00b7 N: 1\nThis type of transfer is common  when  sending predefined  data  packets  (such  as  strings)  through  a single interface point (such as communications modules transmit registers).\n- \u00b7 N: N\nThis type of transfer is useful for moving information out of the Program Flash or Data EEPROM to SRAM for manipulation by the CPU or other peripherals.\n- \u00b7 1: N\nThis  type  of  transfer  is  common  when  bridging  two different modules data streams together (communications bridge).\n- \u00b7 1: N\nThis type of transfer is useful for moving information from  a  single  data  source  into  a  memory  buffer (communications receive registers).",
    "15.8 DMA Interrupts\nEach DMA has its own set of four interrupt flags, used to indicate a range of conditions during data transfers. The interrupt flag bits can be accessed using the corre -sponding PIR registers (Refer to the Interrupt Section).",
    "15.8.1 DMA SOURCE COUNT INTERRUPT\nThe  DMAxSCNTIF  source  count  interrupt  flag  is  set every time the DMAxSCNT<11:0> reaches zero and is reloaded to its starting value.",
    "15.8.2 DMA DESTINATION COUNT INTERRUPT\nThe DMAxDCNTIF destination count interrupt  flag  is set  every  time  the  DMAxDCNT<11:0>  reaches  zero and is reloaded to its starting value.\nThe DMA Source Count zero and Destination Count zero  interrupts  are  used  in  conjunction  to  determine when to signal the CPU when the DMA Messages are completed.",
    "15.8.3 ABORT INTERRUPT\nThe DMAxAIF abort interrupt flag is used to signal that the DMA has halted activity due to an abort signal from one of the abort sources. This is used to indicate that the transaction has been halted for some reason.",
    "15.8.4 OVERRUN INTERRUPT\nWhen  the  DMA  receives  a  trigger  to  start  a  new message  before  the  current  message  is  completed, then the DMAxORIF Overrun interrupt flag is set.\nThis condition indicates that the DMA  is being requested  before  its  current  transaction  is  finished. This implies that the active DMA may not be able to keep up with the demands from the peripheral module being serviced, which may result in data loss.\nThe  DMAxORIF  flag  being  set  does  not  cause  the current DMA transfer to terminate.\nThe  Overrun  interrupt  is  only  available  for  trigger sources  that  are  edge  based  and  not  available  for sources that are level-based. Therefore a level-based interrupt source does not trigger a DMA overrun error due to the potential latency issues in the system.\nAn example of an interrupt that could use the overrun interrupt would be a timer overflow (or period match) interrupt. This event only happens every time the timer rolls  over and is not dependent on any other system conditions.",
    "15.8.4 OVERRUN INTERRUPT\nAn  example  of  an  interrupt  that  does  not  allow  the overrun  interrupt  would  be  the  UARTTX  buffer.  The UART will continue to assert the interrupt until the DMA is able to process the MSG. Due to latency issues, the DMA  may  not  be  able  to  service  an  empty  buffer immediately,  but  the  UART  continues  to  assert  its transmit  interrupt  until  it  is  serviced.  If  overrun  was allowed in this case, the overrun would occur almost immediately  as  the  module  samples  the  interrupt sources every instruction cycle.",
    "15.9 DMA Setup and Operation\nThe following steps illustrate how to configure the DMA for data transfer:\n1. Program the appropriate Source and Destination  addresses  for  the  transaction  into the DMAxSSA and DMAxDSA registers\n2. Select the source memory region that is being addressed  by  DMAxSSA  register,  using  the SMR<1:0> bits.\n3. Program the SMODE and DMODE bits to select the addressing mode.\n4. Program the Source size DMAxSSZ and Destination  size  DMAxDSZ  registers  with  the number of bytes to be transferred. It is recommended for proper operation that the size registers be a multiple of each other.\n5. If the user desires to disable data transfers once the message has completed, then the SSTP and DSTP bits  in  DMAxCON0 register  need  to  be set.(see Section 15.5.3.2 'Source/Destina -tion Stop' ).\n6. If using  hardware  triggers  for  data  transfer, setup the hardware trigger interrupt sources for the starting and aborting DMA transfers (DMAxSIRQ  and  DMAxAIRQ),  and  set  the corresponding interrupt request enable bits (SIRQEN and AIRQEN).",
    "15.9 DMA Setup and Operation\n7. Select the priority level for the DMA  (see Section 3.1  'System  Arbitration' ) and  lock the priorities (see Section 3.1.1 'Priority Lock' )\n8. Enable the DMA (DMAxCON1bits. EN = 1 )\n9. If using software control for data transfer, set the DGO bit, else this bit will be set by the hardware trigger.\nOnce  the  DMA  is  set  up,  the  following  flow  chart describes  the  sequence  of  operation  when  the  DMA uses hardware triggers and utilizes the unused CPU cycles (bubble) for DMA transfers.\nFIGURE 15-4:\nDMA OPERATION WITH HARDWARE TRIGGER\nThe following sections describe with visual reference the sequence of events for different configurations of the DMA module",
    "15.9.1 SOURCE STOP\nWhen the Source Stop bit is set (SSTP = 1 ) and the DMAxSCNT  register  reloads,  the  DMA  clears  the SIRQEN  bit  to  stop  receiving  new  start  interrupt request signals and sets the DMAxSCNTIF flag.",
    "15.9.2 DESTINATION STOP\nWhen the Destination Stop bit is set (DSTP = 1 ) and the DMAxDCNT register reloads, the DMA clears the SIRQEN  bit  to  stop  receiving  new  start  interrupt request signals and sets the DMAxDCNTIF flag.",
    "15.9.3 CONTINUOUS TRANSFER\nWhen the Source or the Destination Stop bit is cleared (SSTP, DSTP = 0 ),  the  transactions  continue  unless cleared by the user. The DMAxSCNTIF and DMAxDCNTIF flags are set whenever the respective counter registers are reloaded.",
    "15.9.4 TRANSFER FROM SFR TO GPR\nThe following visual reference describes the sequence of events when copying ADC results to a GPR location. The ADC Interrupt Flag can be chosen as the Source\nHardware  trigger,  the  Source  address  can  be  set  to point to the  ADC  Result registers at 3EEF,  the Destination address can be set to point to any GPR location of our choice (Example 0x100).",
    "15.9.5 OVERRUN INTERRUPT\nThe Overrun Interrupt flag is set if the DMA receives a trigger to start a new message before the current mes -sage is completed.",
    "15.9.6 ABORT TRIGGER, MESSAGE COMPLETE\nThe AIRQEN needs to be set in order for the DMA to sample  Abort Interrupt sources. When  an abort interrupt is received the SIRQEN bit is cleared and the AIRQEN bit is cleared to avoid receiving further abort triggers.",
    "15.9.7 ABORT TRIGGER, MESSAGE IN PROGRESS\nThe SIREQEN bit is cleared to prevent any overrun and the AIRQEN bit is cleared to prevent any false aborts.\nWhen  an  abort  interrupt  request  is  received  in  the between a DMA transaction, the DMA will perform a soft-stop  by  clearing  the  DGO  (i.e.,  if  the  DMA  was reading the source register,  it  will  complete  the  read operation and then clear the DGO bit)\nWhen the DGO bit is set again the DMA will resume operation from where it left off after the soft-stop.",
    "FIGURE 15-11: ABORT DURING MESSAGE TRANSFER\nThe following table contains some of the cases in which the DMA module can be configured to.",
    "TABLE 15-6: EXAMPLE DMA USE CASE TABLE\nSignal Measurement Timer, Source Register(s) = SMTxCPW[U:H:L]. Signal Measurement Timer, Destination Module = GPR. Signal Measurement Timer, Destination Register(s) = GPR[x,y,z]. Signal Measurement Timer, DCHxSIRQ = SMTxPWAIF. Signal Measurement Timer, Comment = Store Captured Pulse-width values. (SMT), Source Register(s) = SMTxCPR[U:H:L]. (SMT), Destination Module = . (SMT), Destination Register(s) = . (SMT), DCHxSIRQ = SMTxPRAIF. (SMT), Comment = Store Captured Period values. GPR/SFR/Program Flash/Data EEPROM, Source Register(s) = MEMORY[x,y]. GPR/SFR/Program Flash/Data EEPROM, Destination Module = TMR0. GPR/SFR/Program Flash/Data EEPROM, Destination Register(s) = TMR0[H:L]. GPR/SFR/Program",
    "TABLE 15-6: EXAMPLE DMA USE CASE TABLE\nFlash/Data EEPROM, DCHxSIRQ = TMR0IF. GPR/SFR/Program Flash/Data EEPROM, Comment = Use as a Timer0 reload for custom 16-bit value. GPR/SFR/Program Flash/Data EEPROM, Source Register(s) = MEMORY[x]. GPR/SFR/Program Flash/Data EEPROM, Destination Module = TMR0. GPR/SFR/Program Flash/Data EEPROM, Destination Register(s) = PR0. GPR/SFR/Program Flash/Data EEPROM, DCHxSIRQ = ANY. GPR/SFR/Program Flash/Data EEPROM, Comment = Update TMR0 frequency based on a specific trigger. GPR/SFR/Program Flash/Data EEPROM, Source Register(s) = MEMORY[x,y]. GPR/SFR/Program Flash/Data EEPROM, Destination Module = TMR1. GPR/SFR/Program Flash/Data EEPROM, Destination Register(s) =",
    "TABLE 15-6: EXAMPLE DMA USE CASE TABLE\nTMR1[H:L]. GPR/SFR/Program Flash/Data EEPROM, DCHxSIRQ = TMR1IF. GPR/SFR/Program Flash/Data EEPROM, Comment = Use as a Timer1 reload for custom 16-bit value. TMR1, Source Register(s) = TMR1[H:L]. TMR1, Destination Module = GPR. TMR1, Destination Register(s) = GPR[x,y]. TMR1, DCHxSIRQ = TMR1GIF. TMR1, Comment = Use TMR1 Gate interrupt flag to read data out of TMR1 register. GPR/SFR/Program Flash/Data EEPROM, Source Register(s) = MEMORY[x]. GPR/SFR/Program Flash/Data EEPROM, Destination Module = TMR2. GPR/SFR/Program Flash/Data EEPROM, Destination Register(s) = PR2. GPR/SFR/Program Flash/Data EEPROM,",
    "TABLE 15-6: EXAMPLE DMA USE CASE TABLE\nDCHxSIRQ = TMR2IF. GPR/SFR/Program Flash/Data EEPROM, Comment = . GPR/SFR/Program Flash/Data EEPROM, Source Register(s) = MEMORY[x,y,z]. GPR/SFR/Program Flash/Data EEPROM, Destination Module = TMR2 CCP or PWM. GPR/SFR/Program Flash/Data EEPROM, Destination Register(s) = PR2 CCPR[H:L] or PWMDC[H:L]. GPR/SFR/Program Flash/Data EEPROM, DCHxSIRQ = ANY. GPR/SFR/Program Flash/Data EEPROM, Comment = Frequency generator with 50% duty cycle look up table. CCP, Source Register(s) = CCPR[H:L]. CCP, Destination Module = GPR. CCP, Destination Register(s) = GPR[x,y]. CCP, DCHxSIRQ = CCPxIF. CCP, Comment = Move data from CCP 16b",
    "TABLE 15-6: EXAMPLE DMA USE CASE TABLE\nCapture. GPR/SFR/Program Flash/Data EEPROM, Source Register(s) = MEMORY[x,y]. GPR/SFR/Program Flash/Data EEPROM, Destination Module = CCP. GPR/SFR/Program Flash/Data EEPROM, Destination Register(s) = CCPR[H:L]. GPR/SFR/Program Flash/Data EEPROM, DCHxSIRQ = ANY. GPR/SFR/Program Flash/Data EEPROM, Comment = Load Compare value or PWM values into the CCP. GPR/SFR/Program Flash/Data EEPROM, Source Register(s) = MEMORY [x,y,z,u,v,w]. GPR/SFR/Program Flash/Data EEPROM, Destination Module = CCPx CCPy CCPz. GPR/SFR/Program Flash/Data EEPROM, Destination Register(s) = CCPxR[H:L] CCPyR[H:L] CCPzR[H:L]. GPR/SFR/Program",
    "TABLE 15-6: EXAMPLE DMA USE CASE TABLE\nFlash/Data EEPROM, DCHxSIRQ = ANY. GPR/SFR/Program Flash/Data EEPROM, Comment = Update multiple PWM values at the same time (e.g., 3-phase motor control). GPR/SFR/Program Flash/Data EEPROM, Source Register(s) = MEMORY[x,y,z]. GPR/SFR/Program Flash/Data EEPROM, Destination Module = NCO. GPR/SFR/Program Flash/Data EEPROM, Destination Register(s) = NCOxINC[U:H:L]. GPR/SFR/Program Flash/Data EEPROM, DCHxSIRQ = ANY. GPR/SFR/Program Flash/Data EEPROM, Comment = Frequency Generator look-up table. GPR/SFR/Program Flash/Data EEPROM, Source Register(s) = MEMORY[x]. GPR/SFR/Program Flash/Data EEPROM, Destination Module = DAC. GPR/SFR/Program Flash/Data EEPROM, Destination Register(s) =",
    "TABLE 15-6: EXAMPLE DMA USE CASE TABLE\nDACxCON0. GPR/SFR/Program Flash/Data EEPROM, DCHxSIRQ = ANY. GPR/SFR/Program Flash/Data EEPROM, Comment = Update DAC values. GPR/SFR/Program Flash/Data EEPROM, Source Register(s) = MEMORY[x]. GPR/SFR/Program Flash/Data EEPROM, Destination Module = OSCTUNE. GPR/SFR/Program Flash/Data EEPROM, Destination Register(s) = OSCTUNE. GPR/SFR/Program Flash/Data EEPROM, DCHxSIRQ = ANY. GPR/SFR/Program Flash/Data EEPROM, Comment = Automated Frequency dithering",
    "15.10 Reset\nThe DMA registers are set to the default state on any Reset. The registers are also reset to the default state when the enable bit is cleared (DMA1CON1bits.EN= 0 ).",
    "15.11 Power Saving Mode Operation\nThe DMA utilizes system clocks and it is treated as a peripheral when it comes to power-saving operations. Like other peripherals, the DMA also uses Peripheral Module Disable bits to further tailor its operation in lowpower states.",
    "15.11.1 SLEEP MODE\nWhen the device enters Sleep mode, the system clock to the module  is shut down,  therefore no  DMA operation is supported in Sleep. Once the system clock is disabled, the requisite read and write clocks are also disabled without which the DMA cannot perform any of its tasks.\nAny transfers that may be in progress are resumed on exiting  from  Sleep  mode.  Register  contents  are  not affected by the device entering or leaving Sleep mode. It is recommended that DMA transactions be allowed to finish before entering Sleep mode.",
    "15.11.2 IDLE MODE\nIn IDLE mode, all of the system clocks (including the read and write clocks) are still operating but the CPU is not using them to save power.\nTherefore,  every  instruction  cycle  is  available  to  the system arbiter and if the bubble is granted to the DMA, it may be utilized to move data.",
    "15.11.3 DOZE MODE\nSimilar to the Idle mode, the CPU does not utilize all of the available instruction cycles slots that are available to it in order to save power. It only executes instructions based on its settings from the Doze settings.\nTherefore,  every  instruction  not  used  by  the  CPU  is available for system arbitration and may be utilized by the DMA if granted by the arbiter.",
    "15.11.4 PERIPHERAL MODULE DISABLE\nThe Peripheral Module Disable (PMD) registers provide a method to disable DMA by gating all clock sources  supplied  to  it.  The  respective  DMAxMD  bit needs to be set in order to disable the DMA.",
    "15.12 DMA Register Interfaces\nThe  DMA  can  transfer  data  to  any  GPR  or  SFR location. For better user accessibility some of the more commonly used SFR spaces have their Mirror registers placed in a separate data memory location (0x40000x40FF), these Mirror registers can be only accessed through  the  DMA  Source  and  Destination  Address registers.  Refer  to  Table 4-3  for  details  about  these mirror registers.",
    "EXAMPLE 15-1: SETUP DMA1 TO MOVE DATA FROM PROGRAM FLASH MEMORY TO UART1 TRANSMIT BUFFER USING HARDWARE TRIGGERS\n```",
    "EXAMPLE 15-1: SETUP DMA1 TO MOVE DATA FROM PROGRAM FLASH MEMORY TO UART1 TRANSMIT BUFFER USING HARDWARE TRIGGERS\n//This code example illustrates using DMA1 to transfer //10 bytes of data from 0x1000 in PFM to U1TXB 0x3DEA void main() { //System Initialize initializeSystem(); //Setup UART1 initializeUART1(); //Setup DMA1 //DMA1CON1 - DPTR remains, Source Memory Region PFM, SPTR increments, SSTP DMA1CON1 = 0x0B; //Source registers //Source size DMA1SSZH = 0x00; DMA1SSZL = 0x0A; //Source start address, 0x1000 DMA1SSAU = 0x00; DMA1SSAH = 0x10; DMA1SSAL = 0x00; //Destination registers //Destination size DMA1DSZH = 0x00; DMA1DSZL = 0x01; //Destination start address, 0x3DEA DMA1DSAH = 0x3D;",
    "EXAMPLE 15-1: SETUP DMA1 TO MOVE DATA FROM PROGRAM FLASH MEMORY TO UART1 TRANSMIT BUFFER USING HARDWARE TRIGGERS\nDMA1DSAL = 0xEA; //Start trigger source U1TX DMA1SIRQ = 0x1C; //Enable & Start DMA transfer DMA1CON0 = 0xC0; while (1) { doSomething(); } }\n```",
    "15.13 Register definitions: DMA\nLong  bit  name  prefixes  for  the  DMA  peripherals  are shown in Table 15-7. Refer to Section 1.3 'Register and Bit naming conventions' for more information.",
    "TABLE 15-7: REGISTER AND BIT NAMING\nDMA1, Bit Name Prefix = DMA1. DMA2, Bit Name Prefix = DMA2",
    "REGISTER 15-1: DMAxCON0: DMAx CONTROL REGISTER 0\nR/W-0/0\nR/W/HC-0/0\nR/W/HS/HC-0/0\nU-0\nU-0\nR/W/HC-0/0\nU-0\nR/HS/HC-0/0\nEN\nSIRQEN\nDGO\n-\n-\nAIRQEN\n-\nXIP\nbit 7\nbit 0\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n/n = Value at POR and BOR/Value at all other Resets\n0 = bit is cleared                        x = bit is unknown\nu = bit is unchanged",
    "bit 7\nEN: DMA Module Enable bit\n1 = Enables module\n0 = Disables module\nbit 6 SIRQEN: Start of Transfer Interrupt Request Enable bits\n1 = Hardware triggers are allowed to start DMA transfers\n0 = Hardware triggers are not allowed to start DMA transfers\nDGO: DMA transaction bit\n1 = DMA transaction is in progress\n0 = DMA transaction is not in progress",
    "bit 4-3 Unimplemented: Read as ' 0 '\nbit 2 AIRQEN: Abort of Transfer Interrupt Request Enable bits\n1 = Hardware triggers are allowed to abort DMA transfers\n0 = Hardware triggers are not allowed to abort DMA transfers",
    "bit 0 XIP: Transfer in Progress Status bit\n1 = The DMAxBUF register currently holds contents from a read operation and has not transferred data to the destination.\n0 = The DMAxBUF register is empty or has successfully transferred data to the destination address",
    "REGISTER 15-2: DMAxCON1: DMAx CONTROL REGISTER1\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0 R/W-0/0. DMODE<1:0>, 1 = DMODE<1:0>. DMODE<1:0>, 2 = DSTP. DMODE<1:0>, 3 = SMR<1:0>. DMODE<1:0>, 4 = SMR<1:0>. DMODE<1:0>, 5 = SMODE<1:0>. DMODE<1:0>, 6 = SSTP. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 =",
    "REGISTER 15-2: DMAxCON1: DMAx CONTROL REGISTER1\nbit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets",
    "bit 7-6 DMODE<1:0>: Destination Address Mode Selection bits\n11 = Reserved, Do not use\n10 = DMAxDPTR<15:0> is decremented after each transfer completion\n01 = DMAxDPTR<15:0> is incremented after each transfer completion\n00 = DMAxDPTR<15:0> remains unchanged after each transfer completion",
    "bit 5 DSTP: Destination Counter Reload Stop bit\n1 = SIRQEN bit is cleared when Destination Counter reloads\n0 = SIRQEN bit is not cleared when Destination Counter reloads",
    "bit 4-3 SMR[1:0]: Source Memory Region Select bits\n1x = DMAxSSA<21:0> points to Data EEPROM\n01 = DMAxSSA<21:0> points to Program Flash Memory\n00 = DMAxSSA<21:0> points to SFR/GPR Data Space",
    "bit 2-1 SMODE[1:0]: Source Address Mode Selection bits\n11 = Reserved, Do not use\n10 = DMAxSPTR<21:0> is decremented after each transfer completion\n01 = DMAxSPTR<21:0> is incremented after each transfer completion\n00 = DMAxSPTR<21:0> remains unchanged after each transfer completion",
    "bit 0 SSTP: Source Counter Reload Stop bit\n1 = SIRQEN bit is cleared when Source Counter reloads\n0 = SIRQEN bit is not cleared when Source Counter reloads",
    "REGISTER 15-3: DMAxBUF: DMAx DATA BUFFER REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. BUF7, 1 = BUF6. BUF7, 2 = BUF5. BUF7, 3 = BUF4. BUF7, 4 = BUF3. BUF7, 5 = BUF2. BUF7, 6 = BUF1. BUF7, 7 = BUF0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n/n = Value at POR and BOR/Value at all other Resets\n1 = bit is set\n0 = bit is cleared                        x = bit is unknown\nu = bit is unchanged",
    "bit 7-0 BUF<7:0>: DMA Internal Data Buffer bits\nDMABUF<7:0>\nThese bits reflect the content of the internal data buffer the DMA peripheral uses to hold the data being moved from the source to destination.",
    "REGISTER 15-4: DMAxSSAL: DMAx SOURCE START ADDRESS LOW REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. , 1 = . , 2 = . , 3 = SSA<7:0>. , 4 = . , 5 = . , 6 = . , 7 = . bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 15-4: DMAxSSAL: DMAx SOURCE START ADDRESS LOW REGISTER\nR = Readable bit -n/n = Value at POR and BOR/Value at all other Resets,  = W=Writable 1 = bit is set. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets, U = Unimplemented bit, read as '0' = 0 = bit is cleared. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets,  = x = bit is unknown u = bit is unchanged\nbit 7-0 SSA<7:0>: Source Start Address bits",
    "REGISTER 15-5: DMAxSSAH: DMAx SOURCE START ADDRESS HIGH REGISTER\nbit 7, R/W-0/0.SSA<15:8> = . bit 7, R/W-0/0.SSA<15:8> = . bit 7, R/W-0/0.SSA<15:8> = . bit 7, R/W-0/0.SSA<15:8> = . bit 7, R/W-0/0.SSA<15:8> = . bit 7, R/W-0/0.SSA<15:8> = . bit 7, R/W-0/0.SSA<15:8> = bit 0\nbit 7-0 SSA<15:8>: Source Start Address bits",
    "REGISTER 15-6: DMAxSSAU: DMAx SOURCE START ADDRESS UPPER REGISTER\n-, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = SSA<21:16>. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 15-6: DMAxSSAU: DMAx SOURCE START ADDRESS UPPER REGISTER\nR = Readable bit -n/n = Value at POR and BOR/Value at all other Resets, W=Writable bit = 1 = bit is set. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets,  = U 0 = bit is cleared. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets, as '0' = x = bit is unknown u = bit is unchanged\nbit 7-0 SSA<21:16>: Source Start Address bits",
    "REGISTER 15-7: DMAxSPTRL: DMAx SOURCE POINTER LOW REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. SPTR<7:0>, 1 = SPTR<7:0>. SPTR<7:0>, 2 = SPTR<7:0>. SPTR<7:0>, 3 = SPTR<7:0>. SPTR<7:0>, 4 = SPTR<7:0>. SPTR<7:0>, 5 = SPTR<7:0>. SPTR<7:0>, 6 = SPTR<7:0>. SPTR<7:0>, 7 = SPTR<7:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 15-7: DMAxSPTRL: DMAx SOURCE POINTER LOW REGISTER\nR = Readable bit -n/n = Value at POR and BOR/Value at all other Resets,  = W=Writable 1 = bit is set. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets,  = U 0 = bit is cleared. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets, as '0' = x = bit is unknown u = bit is unchanged\nbit 15-0 SPTR<7:0>: Current Source Address Pointer",
    "REGISTER 15-8: DMAxSPTRH: DMAx SOURCE POINTER HIGH REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. SPTR<15:8>, 1 = SPTR<15:8>. SPTR<15:8>, 2 = SPTR<15:8>. SPTR<15:8>, 3 = SPTR<15:8>. SPTR<15:8>, 4 = SPTR<15:8>. SPTR<15:8>, 5 = SPTR<15:8>. SPTR<15:8>, 6 = SPTR<15:8>. SPTR<15:8>, 7 = SPTR<15:8>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 15-8: DMAxSPTRH: DMAx SOURCE POINTER HIGH REGISTER\n-n/n = Value at POR and BOR/Value at all other Resets, W=Writable bit = 1 = bit is set. -n/n = Value at POR and BOR/Value at all other Resets,  = 0 = bit is cleared. -n/n = Value at POR and BOR/Value at all other Resets,  = x = bit is unknown u = bit is unchanged\nbit 5-0 SPTR<15:8>: Current Source Address Pointer",
    "REGISTER 15-9: DMAxSPTRU: DMAx SOURCE POINTER UPPER REGISTER\nU-0, 1 = U-0. U-0, 2 = R-0. U-0, 3 = R-0. U-0, 4 = R-0. U-0, 5 = R-0. U-0, 6 = R-0. U-0, 7 = R-0. -, 1 = -. -, 2 = SPTR<21:16>. -, 3 = SPTR<21:16>. -, 4 = SPTR<21:16>. -, 5 = SPTR<21:16>. -, 6 = SPTR<21:16>. -, 7 = SPTR<21:16>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 15-9: DMAxSPTRU: DMAx SOURCE POINTER UPPER REGISTER\n-n/n = Value at POR and BOR/Value at all other Resets, W=Writable bit = 1 = bit is set. -n/n = Value at POR and BOR/Value at all other Resets,  = 0 = bit is cleared. -n/n = Value at POR and BOR/Value at all other Resets,  = x = bit is unknown u = bit is unchanged\nbit 7-6\nUnimplemented: Read as ' 0 '\nbit 5-0 SPTR<21:16>: Current Source Address Pointer",
    "REGISTER 15-10: DMAxSSZL: DMAx SOURCE SIZE LOW REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. SSZ<7:0>, 1 = SSZ<7:0>. SSZ<7:0>, 2 = SSZ<7:0>. SSZ<7:0>, 3 = SSZ<7:0>. SSZ<7:0>, 4 = SSZ<7:0>. SSZ<7:0>, 5 = SSZ<7:0>. SSZ<7:0>, 6 = SSZ<7:0>.",
    "REGISTER 15-10: DMAxSSZL: DMAx SOURCE SIZE LOW REGISTER\nSSZ<7:0>, 7 = SSZ<7:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\n-n/n = Value at POR and BOR/Value at all other Resets, W=Writable bit = 1 = bit is set. -n/n = Value at POR and BOR/Value at all other Resets,  = 0 = bit is cleared. -n/n = Value at POR and BOR/Value at all other Resets,  = x = bit is unknown u = bit is unchanged\nbit 7-0 SSZ<7:0>: Source Message Size bits",
    "REGISTER 15-11: DMAxSSZH: DMAx SOURCE SIZE HIGH REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = SSZ<11:8>. -, 5 = SSZ<11:8>. -, 6 = SSZ<11:8>. -, 7 = SSZ<11:8>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nbit 7-4",
    "REGISTER 15-11: DMAxSSZH: DMAx SOURCE SIZE HIGH REGISTER\nUnimplemented: Read as ' 0 '\nbit 3-0\nSSZ<11:8>: Source Message Size bits",
    "REGISTER 15-12: DMAxSCNTL: DMAx SOURCE COUNT LOW REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. SCNT<7:0>, 1 = SCNT<7:0>. SCNT<7:0>, 2 = SCNT<7:0>. SCNT<7:0>, 3 = SCNT<7:0>. SCNT<7:0>, 4 = SCNT<7:0>. SCNT<7:0>, 5 = SCNT<7:0>. SCNT<7:0>, 6 = SCNT<7:0>. SCNT<7:0>, 7 = SCNT<7:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 15-12: DMAxSCNTL: DMAx SOURCE COUNT LOW REGISTER\n-n/n = Value at POR and BOR/Value at all other Resets, W=Writable bit = 1 = bit is set. -n/n = Value at POR and BOR/Value at all other Resets,  = 0 = bit is cleared. -n/n = Value at POR and BOR/Value at all other Resets,  = x = bit is unknown u = bit is unchanged\nbit 7-0 SCNT<7:0>: Current Source Byte Count",
    "REGISTER 15-13: DMAxSCNTH: DMAx SOURCE COUNT HIGH REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R-0. U-0, 5 = R-0. U-0, 6 = R-0. U-0, 7 = R-0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = . -, 5 = SCNT<11:8>. -, 6 = . -, 7 = . bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 15-13: DMAxSCNTH: DMAx SOURCE COUNT HIGH REGISTER\nLegend:, 1 = . Legend:, 2 = . Legend:, 3 = . R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets, 1 = W=Writable 1 = bit is set. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets, 2 = U 0 = bit is cleared. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets, 3 = as '0' x = bit is unknown u = bit is unchanged\nbit 7-4 Unimplemented : Read as ' 0 '\nbit 3-0 SCNT<11:8>: Current Source Byte Count",
    "REGISTER 15-14: DMAxDSAL: DMAx DESTINATION START ADDRESS LOW REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = DSA<7:0>. bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 15-14: DMAxDSAL: DMAx DESTINATION START ADDRESS LOW REGISTER\n-n/n = Value at POR and BOR/Value at all other Resets, W=Writable bit = 1 = bit is set. -n/n = Value at POR and BOR/Value at all other Resets,  = 0 = bit is cleared. -n/n = Value at POR and BOR/Value at all other Resets,  = x = bit is unknown u = bit is unchanged\nbit 7-0 DSA<7:0>: Destination Start Address bits",
    "REGISTER 15-15: DMAxDSAH: DMAx DESTINATION START ADDRESS HIGH REGISTER\nbit 7, R/W-0/0.DSA<15:8> = . bit 7, R/W-0/0.DSA<15:8> = . bit 7, R/W-0/0.DSA<15:8> = . bit 7, R/W-0/0.DSA<15:8> = . bit 7, R/W-0/0.DSA<15:8> = . bit 7, R/W-0/0.DSA<15:8> = . bit 7, R/W-0/0.DSA<15:8> = bit 0",
    "REGISTER 15-15: DMAxDSAH: DMAx DESTINATION START ADDRESS HIGH REGISTER\n-n/n = Value at POR and BOR/Value at all other Resets, W=Writable bit = 1 = bit is set. -n/n = Value at POR and BOR/Value at all other Resets, U = Unimplemented bit, read as = 0 = bit is cleared. -n/n = Value at POR and BOR/Value at all other Resets, '0' = x = bit is unknown u = bit is unchanged\nbit 7-0 DSA<15:8>: Destination Start Address bits",
    "REGISTER 15-16: DMAxDPTRL: DMAx DESTINATION POINTER LOW REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. DPTR<7:0>, 1 = DPTR<7:0>. DPTR<7:0>, 2 = DPTR<7:0>. DPTR<7:0>, 3 = DPTR<7:0>. DPTR<7:0>, 4 = DPTR<7:0>. DPTR<7:0>, 5 = DPTR<7:0>. DPTR<7:0>, 6 = DPTR<7:0>. DPTR<7:0>, 7 = DPTR<7:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 =",
    "REGISTER 15-16: DMAxDPTRL: DMAx DESTINATION POINTER LOW REGISTER\n. bit 7, 6 = . bit 7, 7 = bit 0\nR = Readable bit -n/n = Value at POR and BOR/Value at all other Resets,  = W=Writable 1 = bit is set. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets,  = U 0 = bit is cleared. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets, as '0' = x = bit is unknown u = bit is unchanged\nbit 7-0 DPTR<7:0>: Current Destination Address Pointer",
    "REGISTER 15-17: DMAxDPTRH: DMAx DESTINATION POINTER HIGH REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. DPTR<15:8>, 1 = DPTR<15:8>. DPTR<15:8>, 2 = DPTR<15:8>. DPTR<15:8>, 3 = DPTR<15:8>. DPTR<15:8>, 4 = DPTR<15:8>. DPTR<15:8>, 5 = DPTR<15:8>. DPTR<15:8>, 6 = DPTR<15:8>. DPTR<15:8>, 7 = DPTR<15:8>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 =",
    "REGISTER 15-17: DMAxDPTRH: DMAx DESTINATION POINTER HIGH REGISTER\n. bit 7, 6 = . bit 7, 7 = bit 0\n-n/n = Value at POR and BOR/Value at all other Resets, W=Writable bit = 1 = bit is set. -n/n = Value at POR and BOR/Value at all other Resets,  = 0 = bit is cleared. -n/n = Value at POR and BOR/Value at all other Resets,  = x = bit is unknown u = bit is unchanged\nbit 7-0 DPTR<15:8>: Current Destination Address Pointer",
    "REGISTER 15-18: DMAxDSZL: DMAx DESTINATION SIZE LOW REGISTER\nbit 7, R/W-0/0.DSZ<7:0> = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0\n-n/n = Value at POR and BOR/Value at all other Resets, W=Writable bit = 1 = bit is set. -n/n = Value at POR and BOR/Value at all other Resets, U = Unimplemented bit, read as = 0 = bit is cleared. -n/n = Value at POR and BOR/Value at all other Resets, '0' = x = bit is unknown u = bit is unchanged\nbit 7-0 DSZ<7:0>: Destination Message Size bits",
    "REGISTER 15-19: DMAxDSZH: DMAx DESTINATION SIZE HIGH REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = . -, 5 = DSZ<11:8>. -, 6 = . -, 7 = . bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 15-19: DMAxDSZH: DMAx DESTINATION SIZE HIGH REGISTER\nR = Readable bit -n/n = Value at POR and BOR/Value at all other Resets,  = W=Writable 1 = bit is set. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets,  = U 0 = bit is cleared. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets, as '0' = x = bit is unknown u = bit is unchanged\nbit 7-4, 1 = Unimplemented: Read as ' 0 '. bit 3-0, 1 = DSZ<11:8>: Destination Message Size bits",
    "REGISTER 15-20: DMAxDCNTL: DMAx DESTINATION COUNT LOW REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. DCNT<7:0>, 1 = DCNT<7:0>. DCNT<7:0>, 2 = DCNT<7:0>. DCNT<7:0>, 3 = DCNT<7:0>. DCNT<7:0>, 4 = DCNT<7:0>. DCNT<7:0>, 5 = DCNT<7:0>. DCNT<7:0>, 6 = DCNT<7:0>. DCNT<7:0>, 7 = DCNT<7:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 15-20: DMAxDCNTL: DMAx DESTINATION COUNT LOW REGISTER\nbit 7-0 DCNT<7:0>: Current Destination Byte Count",
    "REGISTER 15-21: DMAxDCNTH: DMAx DESTINATION COUNT HIGH REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R-0. U-0, 5 = R-0. U-0, 6 = R-0. U-0, 7 = R-0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = . -, 5 = DCNT<11:8>. -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 15-21: DMAxDCNTH: DMAx DESTINATION COUNT HIGH REGISTER\n-n/n = Value at POR and BOR/Value at all other Resets, W=Writable bit = 1 = bit is set. -n/n = Value at POR and BOR/Value at all other Resets, U = Unimplemented bit, read as = 0 = bit is cleared. -n/n = Value at POR and BOR/Value at all other Resets, '0' = x = bit is unknown u = bit is unchanged\nbit 7-4\nUnimplemented: Read as ' 0 '\nbit 3-0 DCNT<11:8>: Current Destination Byte Count",
    "REGISTER 15-22: DMAxSIRQ: DMAx START INTERRUPT REQUEST SOURCE SELECTION REGISTER\nU-0, 1 = R/W-0/0. U-0, 2 = R/W-0/0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = . -, 2 = . -, 3 = . -, 4 = SIRQ<6:0>. -, 5 = . -, 6 = . -, 7 = . bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 15-22: DMAxSIRQ: DMAx START INTERRUPT REQUEST SOURCE SELECTION REGISTER\nR = Readable bit -n/n = Value at POR and BOR/Value at all other Resets, W=Writable bit = 1 = bit is set. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets,  = U 0 = bit is cleared. R = Readable bit -n/n = Value at POR and BOR/Value at all other Resets, as '0' = x = bit is unknown u = bit is unchanged\nbit 7 Unimplemented : Read as ' 0 '\nbit 6-0\nSIRQ<6:0>: DMAx Start Interrupt Request Source Selection bits\nPlease refer to Table 15-8 for more information.",
    "REGISTER 15-23: DMAxAIRQ: DMAx ABORT INTERRUPT REQUEST SOURCE SELECTION REGISTER\n-, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = AIRQ<6:0>. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0\nbit 7 Unimplemented : Read as ' 0 '\nbit 6-0\nAIRQ<6:0>: DMAx Interrupt Request Source Selection bits\nPlease refer to Table 15-8 for more information.",
    "TABLE 15-8: DMAxSIRQ AND DMAxAIRQ TRIGGER SOURCES\n0x2A, Trigger Source = TXB0IF. 0x2A, Level Triggered = No. 0x2B, Trigger Source = TXB1IF. 0x2B, Level Triggered = No. 0x2C, Trigger Source = TXB2IF/TXBnIF. 0x2C, Level Triggered = No. 0x2D, Trigger Source = ERRIF. 0x2D, Level Triggered = No. 0x2E, Trigger Source = WAKIF. 0x2E, Level Triggered = No. 0x2F, Trigger Source = IRXIF. 0x2F, Level Triggered = No. 0x30, Trigger Source = CMP2IF. 0x30, Level Triggered = No. 0x31, Trigger Source = SMT2IF. 0x31, Level Triggered = No. 0x32, Trigger Source = SMT2PRAIF. 0x32, Level Triggered = No. 0x33, Trigger Source = SMT2PWAIF. 0x33, Level Triggered = No. 0x34, Trigger Source =",
    "TABLE 15-8: DMAxSIRQ AND DMAxAIRQ TRIGGER SOURCES\nDMA2SCNTIF. 0x34, Level Triggered = No. 0x35, Trigger Source = DMA2DCNTIF. 0x35, Level Triggered = No. 0x36, Trigger Source = DMA2ORIF. 0x36, Level Triggered = No. 0x37, Trigger Source = DMA2AIF. 0x37, Level Triggered = No. 0x38, Trigger Source = I2C2RXIF. 0x38, Level Triggered = Yes. 0x39, Trigger Source = I2C2TXIF. 0x39, Level Triggered = Yes. 0x3A, Trigger Source = I2C2IF. 0x3A, Level Triggered = Yes. 0x3B, Trigger Source = I2C2EIF. 0x3B, Level Triggered = Yes. 0x3C, Trigger Source = U2RXIF. 0x3C, Level Triggered = Yes. 0x3D, Trigger Source = U2TXIF. 0x3D, Level Triggered = Yes. 0x3E, Trigger Source = U2EIF.",
    "TABLE 15-8: DMAxSIRQ AND DMAxAIRQ TRIGGER SOURCES\n0x3E, Level Triggered = Yes. 0x3F, Trigger Source = U2IF. 0x3F, Level Triggered = Yes. 0x40, Trigger Source = TMR3IF. 0x40, Level Triggered = No. 0x41, Trigger Source = TMR3GIF. 0x41, Level Triggered = No. 0x42, Trigger Source = TMR4IF. 0x42, Level Triggered = No. 0x43, Trigger Source = CCP2IF. 0x43, Level Triggered = No. 0x44, Trigger Source = CWG2IF. 0x44, Level Triggered = No. 0x45, Trigger Source = CLC2IF. 0x45, Level Triggered = No. 0x46, Trigger Source = INT2IF. 0x46, Level Triggered = No. 0x47, Trigger Source = TMR5IF. 0x47, Level Triggered = No. 0x48, Trigger Source = TMR5GIF. 0x48, Level Triggered = No. 0x49, Trigger Source = TMR6IF.",
    "TABLE 15-8: DMAxSIRQ AND DMAxAIRQ TRIGGER SOURCES\n0x49, Level Triggered = No. 0x4A, Trigger Source = CCP3IF. 0x4A, Level Triggered = No. 0x4B, Trigger Source = CWG3IF. 0x4B, Level Triggered = No. 0x4C, Trigger Source = CLC3IF. 0x4C, Level Triggered = No. 0x4D, Trigger Source = CCP4IF. 0x4D, Level Triggered = No. 0x4E, Trigger Source = CLC4IF. 0x4E, Level Triggered = No. 0x4F -, Trigger Source = Reserved. 0x4F -, Level Triggered = \nNote 1: All trigger sources that are not Level-triggered are Edge-triggered.\n2: The event that sets the flag is the interrupt trigger, not the flag itself. The flag remains set.",
    "TABLE 15-8: DMAxSIRQ AND DMAxAIRQ TRIGGER SOURCES\n0x0, Trigger Source (2) = Reserved. 0x0, Level Triggered (1) = Reserved. 0x1, Trigger Source (2) = HLVDIF. 0x1, Level Triggered (1) = No. 0x2, Trigger Source (2) = OSFIF. 0x2, Level Triggered (1) = No. 0x3, Trigger Source (2) = CSWIF. 0x3, Level Triggered (1) = No. 0x4, Trigger Source (2) = NVMIF. 0x4, Level Triggered (1) = No. 0x5, Trigger Source (2) = SCANIF. 0x5, Level Triggered (1) = No. 0x6, Trigger Source (2) = CRCIF. 0x6, Level Triggered (1) = No. 0x7, Trigger Source (2) = IOCIF. 0x7, Level Triggered (1) = Yes. 0x8, Trigger Source (2) = INT0IF. 0x8, Level Triggered (1) = No. 0x9, Trigger Source",
    "TABLE 15-8: DMAxSIRQ AND DMAxAIRQ TRIGGER SOURCES\n(2) = ZCDIF. 0x9, Level Triggered (1) = No. 0xA, Trigger Source (2) = ADIF. 0xA, Level Triggered (1) = No. 0xB, Trigger Source (2) = ADTIF. 0xB, Level Triggered (1) = No. 0xC, Trigger Source (2) = CMP1IF. 0xC, Level Triggered (1) = No. 0xD, Trigger Source (2) = SMT1IF. 0xD, Level Triggered (1) = No. 0xE, Trigger Source (2) = SMT1PRAIF. 0xE, Level Triggered (1) = No. 0xF, Trigger Source (2) = SMT1PWAIF. 0xF, Level Triggered (1) = No. 0x10, Trigger Source (2) = DMA1SCNTIF. 0x10, Level Triggered (1) = No. 0x11, Trigger Source (2) = DMA1DCNTIF. 0x11, Level Triggered (1) = No.",
    "TABLE 15-8: DMAxSIRQ AND DMAxAIRQ TRIGGER SOURCES\n0x12, Trigger Source (2) = DMA1ORIF. 0x12, Level Triggered (1) = No. 0x13, Trigger Source (2) = DMA1AIF. 0x13, Level Triggered (1) = No. 0x14, Trigger Source (2) = SPI1RXIF. 0x14, Level Triggered (1) = Yes. 0x15, Trigger Source (2) = SPI1TXIF. 0x15, Level Triggered (1) = Yes. 0x16, Trigger Source (2) = SPI1IF. 0x16, Level Triggered (1) = Yes. 0x17, Trigger Source (2) = I2C1RXIF. 0x17, Level Triggered (1) = Yes. 0x18, Trigger Source (2) = I2C1TXIF. 0x18, Level Triggered (1) = Yes. 0x19, Trigger Source (2) = I2C1IF. 0x19, Level Triggered (1) = Yes. 0x1A, Trigger Source (2) =",
    "TABLE 15-8: DMAxSIRQ AND DMAxAIRQ TRIGGER SOURCES\nI2C1EIF. 0x1A, Level Triggered (1) = Yes. 0x1B, Trigger Source (2) = U1RXIF. 0x1B, Level Triggered (1) = Yes. 0x1C, Trigger Source (2) = U1TXIF. 0x1C, Level Triggered (1) = Yes. 0x1D, Trigger Source (2) = U1EIF. 0x1D, Level Triggered (1) = Yes. 0x1E, Trigger Source (2) = U1IF. 0x1E, Level Triggered (1) = No. 0x1F, Trigger Source (2) = TMR0IF. 0x1F, Level Triggered (1) = No. 0x20, Trigger Source (2) = TMR1IF. 0x20, Level Triggered (1) = No. 0x21, Trigger Source (2) = TMR1GIF. 0x21, Level Triggered (1) = No. 0x22, Trigger Source (2) = TMR2IF.",
    "TABLE 15-8: DMAxSIRQ AND DMAxAIRQ TRIGGER SOURCES\n0x22, Level Triggered (1) = No. 0x23, Trigger Source (2) = CCP1IF. 0x23, Level Triggered (1) = No. 0x24, Trigger Source (2) = NCOIF. 0x24, Level Triggered (1) = Yes. 0x25, Trigger Source (2) = CWG1IF. 0x25, Level Triggered (1) = No. 0x26, Trigger Source (2) = CLC1IF. 0x26, Level Triggered (1) = No. 0x27, Trigger Source (2) = INT1IF. 0x27, Level Triggered (1) = No. 0x28, Trigger Source (2) = RXB0IF/FIF0IF. 0x28, Level Triggered (1) = No",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\nDMAxCON0, Bit 7 = EN. DMAxCON0, Bit 6 = SIRQEN. DMAxCON0, Bit 5 = DGO. DMAxCON0, Bit 4 = -. DMAxCON0, Bit 3 = -. DMAxCON0, Bit 2 = AIRQEN. DMAxCON0, Bit 1 = -. DMAxCON0, Bit 0 = XIP. DMAxCON0, Register on Page = 239. DMAxCON1, Bit 7 = DMODE<1:0>. DMAxCON1, Bit 6 = DMODE<1:0>. DMAxCON1, Bit 5 = DSTP. DMAxCON1, Bit 4 = SMR<1:0>. DMAxCON1, Bit 3 = SMR<1:0>. DMAxCON1, Bit 2 = SMODE<1:0>. DMAxCON1, Bit 1 = SMODE<1:0>. DMAxCON1, Bit 0 = SSTP. DMAxCON1, Register on Page = 240. DMAxBUF, Bit 7 = DBUF7.",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\nDMAxBUF, Bit 6 = DBUF6. DMAxBUF, Bit 5 = DBUF5. DMAxBUF, Bit 4 = DBUF4. DMAxBUF, Bit 3 = DBUF3. DMAxBUF, Bit 2 = DBUF2. DMAxBUF, Bit 1 = DBUF1. DMAxBUF, Bit 0 = DBUF0. DMAxBUF, Register on Page = 241. DMAxSSAL, Bit 7 = SSA<7:0>. DMAxSSAL, Bit 6 = SSA<7:0>. DMAxSSAL, Bit 5 = SSA<7:0>. DMAxSSAL, Bit 4 = SSA<7:0>. DMAxSSAL, Bit 3 = SSA<7:0>. DMAxSSAL, Bit 2 = SSA<7:0>. DMAxSSAL, Bit 1 = SSA<7:0>. DMAxSSAL, Bit 0 = SSA<7:0>. DMAxSSAL, Register on Page = 241. DMAxSSAH, Bit 7 =",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\nSSA<15:8>. DMAxSSAH, Bit 6 = SSA<15:8>. DMAxSSAH, Bit 5 = SSA<15:8>. DMAxSSAH, Bit 4 = SSA<15:8>. DMAxSSAH, Bit 3 = SSA<15:8>. DMAxSSAH, Bit 2 = SSA<15:8>. DMAxSSAH, Bit 1 = SSA<15:8>. DMAxSSAH, Bit 0 = SSA<15:8>. DMAxSSAH, Register on Page = 241. DMAxSSAU, Bit 7 = -. DMAxSSAU, Bit 6 = -. DMAxSSAU, Bit 5 = SSA<21:16>. DMAxSSAU, Bit 4 = SSA<21:16>. DMAxSSAU, Bit 3 = SSA<21:16>. DMAxSSAU, Bit 2 = SSA<21:16>. DMAxSSAU, Bit 1 = SSA<21:16>. DMAxSSAU, Bit 0 =",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\nSSA<21:16>. DMAxSSAU, Register on Page = 242. DMAxSPTRL, Bit 7 = SPTR<7:0>. DMAxSPTRL, Bit 6 = SPTR<7:0>. DMAxSPTRL, Bit 5 = SPTR<7:0>. DMAxSPTRL, Bit 4 = SPTR<7:0>. DMAxSPTRL, Bit 3 = SPTR<7:0>. DMAxSPTRL, Bit 2 = SPTR<7:0>. DMAxSPTRL, Bit 1 = SPTR<7:0>. DMAxSPTRL, Bit 0 = SPTR<7:0>. DMAxSPTRL, Register on Page = 242. DMAxSPTRH, Bit 7 = SPTR<15:8>. DMAxSPTRH, Bit 6 = SPTR<15:8>. DMAxSPTRH, Bit 5 = SPTR<15:8>. DMAxSPTRH, Bit 4 = SPTR<15:8>. DMAxSPTRH, Bit 3 =",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\nSPTR<15:8>. DMAxSPTRH, Bit 2 = SPTR<15:8>. DMAxSPTRH, Bit 1 = SPTR<15:8>. DMAxSPTRH, Bit 0 = SPTR<15:8>. DMAxSPTRH, Register on Page = 242. DMAxSPTRU, Bit 7 = -. DMAxSPTRU, Bit 6 = -. DMAxSPTRU, Bit 5 = SPTR<21:16>. DMAxSPTRU, Bit 4 = SPTR<21:16>. DMAxSPTRU, Bit 3 = SPTR<21:16>. DMAxSPTRU, Bit 2 = SPTR<21:16>. DMAxSPTRU, Bit 1 = SPTR<21:16>. DMAxSPTRU, Bit 0 = SPTR<21:16>. DMAxSPTRU, Register on Page = 243. DMAxSSZL, Bit 7 = SSZ<7:0>. DMAxSSZL, Bit 6 = SSZ<7:0>.",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\nDMAxSSZL, Bit 5 = SSZ<7:0>. DMAxSSZL, Bit 4 = SSZ<7:0>. DMAxSSZL, Bit 3 = SSZ<7:0>. DMAxSSZL, Bit 2 = SSZ<7:0>. DMAxSSZL, Bit 1 = SSZ<7:0>. DMAxSSZL, Bit 0 = SSZ<7:0>. DMAxSSZL, Register on Page = 243. DMAxSSZH, Bit 7 = -. DMAxSSZH, Bit 6 = -. DMAxSSZH, Bit 5 = -. DMAxSSZH, Bit 4 = -. DMAxSSZH, Bit 3 = SSZ<11:8>. DMAxSSZH, Bit 2 = SSZ<11:8>. DMAxSSZH, Bit 1 = SSZ<11:8>. DMAxSSZH, Bit 0 = SSZ<11:8>. DMAxSSZH, Register on Page = 243. DMAxSCNTL, Bit 7 =",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\nSCNT<7:0>. DMAxSCNTL, Bit 6 = SCNT<7:0>. DMAxSCNTL, Bit 5 = SCNT<7:0>. DMAxSCNTL, Bit 4 = SCNT<7:0>. DMAxSCNTL, Bit 3 = SCNT<7:0>. DMAxSCNTL, Bit 2 = SCNT<7:0>. DMAxSCNTL, Bit 1 = SCNT<7:0>. DMAxSCNTL, Bit 0 = SCNT<7:0>. DMAxSCNTL, Register on Page = 244. DMAxSCNTH, Bit 7 = -. DMAxSCNTH, Bit 6 = -. DMAxSCNTH, Bit 5 = -. DMAxSCNTH, Bit 4 = -. DMAxSCNTH, Bit 3 = SCNT<11:8>. DMAxSCNTH, Bit 2 = SCNT<11:8>. DMAxSCNTH, Bit 1 = SCNT<11:8>. DMAxSCNTH, Bit 0 =",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\nSCNT<11:8>. DMAxSCNTH, Register on Page = 244. DMAxDSAL, Bit 7 = DSA<7:0>. DMAxDSAL, Bit 6 = DSA<7:0>. DMAxDSAL, Bit 5 = DSA<7:0>. DMAxDSAL, Bit 4 = DSA<7:0>. DMAxDSAL, Bit 3 = DSA<7:0>. DMAxDSAL, Bit 2 = DSA<7:0>. DMAxDSAL, Bit 1 = DSA<7:0>. DMAxDSAL, Bit 0 = DSA<7:0>. DMAxDSAL, Register on Page = 244. DMAxDSAH, Bit 7 = DSA<15:8>. DMAxDSAH, Bit 6 = DSA<15:8>. DMAxDSAH, Bit 5 = DSA<15:8>. DMAxDSAH, Bit 4 = DSA<15:8>. DMAxDSAH, Bit 3 = DSA<15:8>. DMAxDSAH,",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\nBit 2 = DSA<15:8>. DMAxDSAH, Bit 1 = DSA<15:8>. DMAxDSAH, Bit 0 = DSA<15:8>. DMAxDSAH, Register on Page = 245. DMAxDPTRL, Bit 7 = DPTR<7:0>. DMAxDPTRL, Bit 6 = DPTR<7:0>. DMAxDPTRL, Bit 5 = DPTR<7:0>. DMAxDPTRL, Bit 4 = DPTR<7:0>. DMAxDPTRL, Bit 3 = DPTR<7:0>. DMAxDPTRL, Bit 2 = DPTR<7:0>. DMAxDPTRL, Bit 1 = DPTR<7:0>. DMAxDPTRL, Bit 0 = DPTR<7:0>. DMAxDPTRL, Register on Page = 245. DMAxDPTRH, Bit 7 = DPTR<15:8>. DMAxDPTRH, Bit 6 =",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\nDPTR<15:8>. DMAxDPTRH, Bit 5 = DPTR<15:8>. DMAxDPTRH, Bit 4 = DPTR<15:8>. DMAxDPTRH, Bit 3 = DPTR<15:8>. DMAxDPTRH, Bit 2 = DPTR<15:8>. DMAxDPTRH, Bit 1 = DPTR<15:8>. DMAxDPTRH, Bit 0 = DPTR<15:8>. DMAxDPTRH, Register on Page = 245. DMAxDSZL, Bit 7 = DSZ<7:0>. DMAxDSZL, Bit 6 = DSZ<7:0>. DMAxDSZL, Bit 5 = DSZ<7:0>. DMAxDSZL, Bit 4 = DSZ<7:0>. DMAxDSZL, Bit 3 = DSZ<7:0>. DMAxDSZL, Bit 2 = DSZ<7:0>. DMAxDSZL, Bit 1 =",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\nDSZ<7:0>. DMAxDSZL, Bit 0 = DSZ<7:0>. DMAxDSZL, Register on Page = 246. DMAxDSZH, Bit 7 = -. DMAxDSZH, Bit 6 = -. DMAxDSZH, Bit 5 = -. DMAxDSZH, Bit 4 = -. DMAxDSZH, Bit 3 = DSZ<11:8>. DMAxDSZH, Bit 2 = DSZ<11:8>. DMAxDSZH, Bit 1 = DSZ<11:8>. DMAxDSZH, Bit 0 = DSZ<11:8>. DMAxDSZH, Register on Page = 246. DMAxDCNTL, Bit 7 = DCNT<7:0>. DMAxDCNTL, Bit 6 = DCNT<7:0>. DMAxDCNTL, Bit 5 = DCNT<7:0>. DMAxDCNTL, Bit 4 = DCNT<7:0>. DMAxDCNTL, Bit 3 = DCNT<7:0>. DMAxDCNTL, Bit",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\n2 = DCNT<7:0>. DMAxDCNTL, Bit 1 = DCNT<7:0>. DMAxDCNTL, Bit 0 = DCNT<7:0>. DMAxDCNTL, Register on Page = 246. DMAxDCNTH, Bit 7 = -. DMAxDCNTH, Bit 6 = -. DMAxDCNTH, Bit 5 = -. DMAxDCNTH, Bit 4 = -. DMAxDCNTH, Bit 3 = DCNT<11:8>. DMAxDCNTH, Bit 2 = DCNT<11:8>. DMAxDCNTH, Bit 1 = DCNT<11:8>. DMAxDCNTH, Bit 0 = DCNT<11:8>. DMAxDCNTH, Register on Page = 247. DMAxSIRQ, Bit 7 = -. DMAxSIRQ, Bit 6 = SIRQ<6:0>. DMAxSIRQ, Bit 5 = SIRQ<6:0>. DMAxSIRQ, Bit 4 = SIRQ<6:0>. DMAxSIRQ, Bit",
    "TABLE 15-9: SUMMARY OF REGISTERS ASSOCIATED WITH DMA\n3 = SIRQ<6:0>. DMAxSIRQ, Bit 2 = SIRQ<6:0>. DMAxSIRQ, Bit 1 = SIRQ<6:0>. DMAxSIRQ, Bit 0 = SIRQ<6:0>. DMAxSIRQ, Register on Page = 247. DMAxAIRQ, Bit 7 = -. DMAxAIRQ, Bit 6 = AIRQ<6:0>. DMAxAIRQ, Bit 5 = AIRQ<6:0>. DMAxAIRQ, Bit 4 = AIRQ<6:0>. DMAxAIRQ, Bit 3 = AIRQ<6:0>. DMAxAIRQ, Bit 2 = AIRQ<6:0>. DMAxAIRQ, Bit 1 = AIRQ<6:0>. DMAxAIRQ, Bit 0 = AIRQ<6:0>. DMAxAIRQ, Register on Page = 247\nLegend:\n- = unimplemented location, read as ' 0 '. Shaded cells are not used by DMA.",
    "16.0 I/O PORTS\nThe PIC18(L)F25/26K83 devices have four I/O ports, allocated as shown in Table 16-1.\nTABLE 16-1:\nPORT ALLOCATION TABLE FOR PIC18(L)F25/26K83 DEVICES\nNote 1: Pin RE3 only.\n\nPIC18(L)F25K83, PORTA = \uf0b7. PIC18(L)F25K83, PORTB = \uf0b7. PIC18(L)F25K83, PORTC = \uf0b7. PIC18(L)F25K83, PORTE = \uf0b7 (1). PIC18(L)F26K83, PORTA = \uf0b7. PIC18(L)F26K83, PORTB = \uf0b7. PIC18(L)F26K83, PORTC = \uf0b7. PIC18(L)F26K83, PORTE = \uf0b7 (1)\nEach port  has  ten  registers  to  control  the  operation. These registers are:",
    "16.0 I/O PORTS\n\u00b7 PORTx registers (reads the levels on the pins of the device)\n\u00b7 LATx registers (output latch)\n\u00b7 TRISx registers (data direction)\n\u00b7 ANSELx registers (analog select)\n\u00b7 WPUx registers (weak pull-up)\n\u00b7 INLVLx (input level control)\n\u00b7 SLRCONx registers (slew rate control)\n\u00b7 ODCONx registers (open-drain control)\nOutside of registers to control bits of all the ports, the two following registers are also present:\n- \u00b7 RxyI2C (I 2 C pad control)\nMost port pins share functions with device peripherals, both analog and digital. In general, when a peripheral is enabled on a port pin, that pin cannot be used as a general purpose output; however, the pin can still be read.\nThe Data Latch (LATx registers) is useful for read modify-write operations on the value that the I/O -pins are driving.",
    "16.0 I/O PORTS\nA  write  operation  to  the  LATx  register  has  the  same effect as a write to the corresponding PORTx register. A read of the LATx register reads of the values held in the  I/O  PORT  latches,  while  a  read  of  the  PORTx register reads the actual I/O pin value.\nPorts that  support  analog  inputs  have  an  associated ANSELx  register.  When  an  ANSELx  bit  is  set,  the digital input buffer associated with that bit is disabled.\nDisabling the input buffer prevents analog signal levels on the pin between a logic high and low from causing excessive current in the logic input circuitry. A simplified  model  of  a  generic  I/O  port,  without  the interfaces to other peripherals, is shown in Figure 16.1.",
    "16.2 I/O Priorities\nEach pin defaults to the PORT data latch after Reset. Other  functions  are  selected  with  the  peripheral  pin select logic. See Section 17.0 'Peripheral Pin Select (PPS) Module' for more information.\nAnalog input functions, such as ADC and comparator inputs, are not shown in the peripheral pin select lists. These  inputs  are  active  when  the  I/O  pin  is  set  for Analog mode using the ANSELx register. Digital output functions may continue to control the pin when it is in Analog mode.\nAnalog outputs, when enabled, take priority over digital outputs  and  force  the  digital  output  driver  into  a high impedance state. -\nThe pin function priorities are as follows:\n1. Configuration bits\n2. Analog outputs (disable the input buffers)\n3. Analog inputs\n4. Port inputs and outputs from PPS",
    "16.3 PORTx Registers\nIn  this  section  the  generic  names  such  as  PORTx, LATx,  TRISx,  etc.  can  be  associated  with  PORTA, PORTB,  and  PORTC  ports.  The functionality of PORTE  is  different  compared  to  other  ports  and  is explained in a separate section.",
    "16.3.1 DATA REGISTER\nPORTx  is an 8-bit wide, bidirectional port. The corresponding data direction register is TRISx (Register 16-2). Setting a TRISx bit (' 1 ') will make the corresponding  PORTA  pin  an  input  (i.e.,  disable  the output driver). Clearing a TRISx bit (' 0 ') will make the corresponding  PORTx  pin  an  output  (i.e.,  it  enables output driver and puts the contents of the output latch on  the  selected  pin).  Example 16-1  shows  how  to initialize PORTx.\nReading the PORTx register (Register 16-1) reads the status of the pins, whereas writing to it will write to the PORT latch. All write operations are read-modify-write operations. Therefore, a write to a port implies that the port  pins  are  read,  this  value  is  modified  and  then written to the PORT data latch (LATx).\nThe PORT data latch LATx (Register 16-3) holds the output port data and contains the latest value of a LATx or PORTx write.",
    "EXAMPLE 16-1: INITIALIZING PORTA\n; This code example illustrates\n; initializing the PORTA register. The\n; other ports are initialized in the same ; manner.\nBANKSEL\nPORTA ;\nCLRF\nPORTA\n;Init PORTA\nBANKSEL\nLATA\n;Data Latch\nCLRF\nLATA\n;\nBANKSEL\nANSELA\n;\nCLRF\nANSELA\n;digital I/O\nBANKSEL\nTRISA\n;\nMOVLW\nB'11111000'\n;Set RA<7:3> as inputs ;and set RA<2:0> as ;outputs\nMOVWF\nTRISA",
    "16.3.2 DIRECTION CONTROL\nThe TRISx register (Register 16-2) controls the PORTx pin output drivers, even when they are being used as analog inputs. The user should ensure the bits in the TRISx register are maintained set when using them as analog  inputs.  I/O  pins  configured  as  analog  inputs always read ' 0 '.",
    "16.3.3 ANALOG CONTROL\nThe  ANSELx register (Register 16-4) is used to configure  the  Input  mode  of  an  I/O  pin  to  analog. Setting the appropriate ANSELx bit high will cause all digital  reads  on  the  pin  to  be  read  as  ' 0 '  and  allow analog functions on the pin to operate correctly.\nThe state of the ANSELx bits has no effect on digital output functions. A pin with TRIS clear and ANSEL set will still operate as a digital output, but the Input mode will  be  analog.  This  can  cause  unexpected  behavior when executing read-modify-write instructions on the affected port.\nNote:\nThe ANSELx  bits  default  to  the  Analog mode  after  Reset.  To  use  any  pins  as digital general purpose or peripheral inputs, the corresponding  ANSEL  bits must be initialized to ' 0 ' by user software.",
    "16.3.4 OPEN-DRAIN CONTROL\nThe  ODCONx  register  (Register 16-6)  controls  the open-drain feature of the port. Open-drain operation is independently selected for each pin. When an ODCONx  bit  is  set,  the  corresponding  port  output becomes  an  open-drain  driver  capable  of  sinking current  only.  When  an  ODCONx  bit  is  cleared,  the corresponding port output pin is the standard push-pull drive capable of sourcing and sinking current.\nNote:\nIt  is  necessary  to  set  open-drain  control when using the pin for I 2 C.",
    "16.3.5 SLEW RATE CONTROL\nThe  SLRCONx  register  (Register 16-7)  controls  the slew rate option for each port pin. Slew rate for each port  pin  can  be  controlled  independently.  When  an SLRCONx bit is set, the corresponding port pin drive is slew rate  limited.  When  an  SLRCONx bit  is  cleared, The corresponding port pin drive slews at the maximum rate possible.",
    "16.3.6 INPUT THRESHOLD CONTROL\nThe INLVLx register (Register 16-8) controls the input voltage threshold for each of the available PORTx input pins. A selection between the Schmitt Trigger CMOS or the TTL compatible thresholds is available. The input threshold is important in determining the value of a read of  the  PORTx register and also the level at which an interrupt-on-change occurs, if that feature is  enabled. See  Table 45-4  for  more  information  on  threshold levels.\nNote:\nChanging  the  input  threshold  selection should be performed while all peripheral modules are disabled. Changing the threshold level during the time a module is active may inadvertently generate a transition  associated  with  an  input  pin, regardless of the actual voltage level on that pin.",
    "16.3.7 WEAK PULL-UP CONTROL\nThe WPUx register (Register 16-5) controls the individual weak pull-ups for each port pin.",
    "16.3.8 EDGE SELECTABLE INTERRUPT ON-CHANGE -\nAn interrupt can be generated by detecting a signal at the port pin that  has either a rising edge  or a falling edge. Any individual pin can be configured to generate an interrupt. The interrupt-on-change module is pres -ent on all the pins of Ports B, C, E and on pin RG5. For further details about the IOC module refer to Section 18.0 'Interrupt-on-Change' .",
    "16.3.9 I 2 C PAD CONTROL\nFor the PIC18(L)F25/26K83 devices, the I 2 C specific pads are available on RB1, RB2, RC3, RC4, RD0 (1) and  RD1 (1) pins.  The  I 2 C  characteristics  of  each  of these pins is controlled by the RxyI2C registers (see Register 16-9). These characteristics include enabling I 2 C specific slew rate (over standard GPIO slew rate), selecting  internal  pull-ups  for  I 2 C  pins,  and  selecting appropriate input threshold as per SMBus specifications.\nNote 1: RD0 and RD1 I 2 C pads are not available in PIC18(L)F25K83 parts.\n2: Any  peripheral  using  the  I 2 C  pins  read the  I 2 C ST  inputs  when  enabled  via RxyI2C.\n.",
    "16.4.1 MASTER CLEAR INPUT (MCLR)\nFor PIC18(L)F2xK83 devices, PORTE is only available when Master Clear functionality is disabled (MCLRE = 0 ). In this case, PORTE is a single bit, input-only port comprised of RE3 only. The pin operates as previously described.  RE3 in  PORTE  register  is  a  read-only  bit and will read ' 1 ' when MCLRE = 1 (i.e., Master Clear enabled).",
    "16.4.2 RE3 WEAK PULL-UP\nThe port RE3 pin has an individually controlled weak internal pull-up. When set, the WPUE3 bit enables the RE3 pin pull-up. When the RE3 port pin is configured as MCLR, (CONFIG2L, MCLRE = 1 and CONFIG4H, LVP = 0 ), or configured for Low-Voltage Programming, (MCLRE = x and LVP = 1 ), the pull-up is always enabled and the WPUE3 bit has no effect.",
    "16.4.3 INTERRUPT-ON-CHANGE\nThe interrupt-on-change feature is available only on the RE3 pin of PORTE for all devices. If MCLRE = 1 or LVP  = 1 , RE3  port  functionality is disabled  and interrupt-on-change on RE3 is not available. For further details refer to Section 18.0 'Interrupt-on-Change' .",
    "REGISTER 16-1: PORTx: PORTx REGISTER (1)\nRx7, R/W-x/u = Rx6. Rx7, R/W-x/u = Rx5. Rx7, R/W-x/u = Rx4. Rx7, R/W-x/u = Rx3. Rx7, R/W-x/u = Rx2. Rx7, R/W-x/u = Rx1. Rx7, R/W-x/u = Rx0. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 0",
    "bit 7-0\nRx<7:0>: Rx7:Rx0 Port I/O Value bits\n1 = Port pin is \uf0b3 VIH\n0 = Port pin is \uf0a3 VIL\nNote 1: Writes to PORTx are actually written to the corresponding LATx register.\nReads from PORTx register return actual I/O pin values.",
    "TABLE 16-2: PORT REGISTERS\nPORTA, Bit 7 = RA7. PORTA, Bit 6 = RA6. PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTB, Bit 7 = RB7 (1). PORTB, Bit 6 = RB6 (1). PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 = RB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTC, Bit 7 = RC7. PORTC, Bit 6 = RC6. PORTC, Bit 5 = RC5. PORTC, Bit 4 = RC4. PORTC, Bit 3 = RC3. PORTC, Bit 2 = RC2. PORTC, Bit 1 = RC1. PORTC, Bit 0 = RC0. PORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 =",
    "TABLE 16-2: PORT REGISTERS\n-. PORTE, Bit 3 = RE3 (2). PORTE, Bit 2 = -. PORTE, Bit 1 = -. PORTE, Bit 0 = -\nNote 1: Bits RB6 and RB7 read ' 1 ' while in Debug mode.\n2: Bit PORTE3 is read-only, and will read ' 1 ' when MCLRE = 1 (Master Clear enabled).",
    "REGISTER 16-2: TRISx: TRI-STATE CONTROL REGISTER\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. TRISx7, 1 = TRISx6. TRISx7, 2 = TRISx5. TRISx7, 3 = TRISx4. TRISx7, 4 = TRISx3. TRISx7, 5 = TRISx2. TRISx7, 6 = TRISx1. TRISx7, 7 = TRISx0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7.",
    "REGISTER 16-2: TRISx: TRI-STATE CONTROL REGISTER\nbit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\nbit 7-0\nTRISx<7:0>:\nTRISx Port I/O Tri-state Control bits\n1 = Port output driver is disabled\n0 = Port output driver is enabled",
    "TABLE 16-3: TRIS REGISTERS\nTRISA, Bit 7 = TRISA7. TRISA, Bit 6 = TRISA6. TRISA, Bit 5 = TRISA5. TRISA, Bit 4 = TRISA4. TRISA, Bit 3 = TRISA3. TRISA, Bit 2 = TRISA2. TRISA, Bit 1 = TRISA1. TRISA, Bit 0 = TRISA0. TRISB, Bit 7 = TRISB7 (1). TRISB, Bit 6 = TRISB6 (1). TRISB, Bit 5 = TRISB5. TRISB, Bit 4 = TRISB4. TRISB, Bit 3 = TRISB3. TRISB, Bit 2 = TRISB2. TRISB, Bit 1 = TRISB1. TRISB, Bit 0 = TRISB0. TRISC, Bit 7 = TRISC7. TRISC, Bit 6 = TRISC6. TRISC, Bit 5 = TRISC5. TRISC, Bit 4 = TRISC4. TRISC, Bit 3 = TRISC3. TRISC, Bit 2 = TRISC2. TRISC, Bit 1 = TRISC1. TRISC, Bit 0 = TRISC0",
    "TABLE 16-3: TRIS REGISTERS\nNote 1: Bits RB6 and RB7 read ' 1 ' while in Debug mode.",
    "REGISTER 16-3: LATx: LATx REGISTER (1)\nLATx7, R/W-x/u = LATx6. LATx7, R/W-x/u = LATx5. LATx7, R/W-x/u = LATx4. LATx7, R/W-x/u = LATx3. LATx7, R/W-x/u = LATx2. LATx7, R/W-x/u = LATx1. LATx7, R/W-x/u = LATx0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0,",
    "REGISTER 16-3: LATx: LATx REGISTER (1)\nR/W-x/u = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets",
    "bit 7-0 LATx<7:0>: Rx7:Rx0 Output Latch Value bits\nNote1: Writes to LATx are equivalent with writes to the corresponding PORTx register. Reads from LATx register return register values, not I/O pin values.",
    "TABLE 16-4: LAT REGISTERS\nLATA, Bit 7 = LATA7. LATA, Bit 6 = LATA6. LATA, Bit 5 = LATA5. LATA, Bit 4 = LATA4. LATA, Bit 3 = LATA3. LATA, Bit 2 = LATA2. LATA, Bit 1 = LATA1. LATA, Bit 0 = LATA0. LATB, Bit 7 = LATB7. LATB, Bit 6 = LATB6. LATB, Bit 5 = LATB5. LATB, Bit 4 = LATB4. LATB, Bit 3 = LATB3. LATB, Bit 2 = LATB2. LATB, Bit 1 = LATB1. LATB, Bit 0 = LATB0. LATC, Bit 7 = LATC7. LATC, Bit 6 = LATC6. LATC, Bit 5 = LATC5. LATC, Bit 4 = LATC4. LATC, Bit 3 = LATC3. LATC, Bit 2 = LATC2. LATC, Bit 1 = LATC1.",
    "TABLE 16-4: LAT REGISTERS\nLATC, Bit 0 = LATC0",
    "REGISTER 16-4: ANSELx: ANALOG SELECT REGISTER\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. ANSELx7, 1 = ANSELx6. ANSELx7, 2 = ANSELx5. ANSELx7, 3 = ANSELx4. ANSELx7, 4 = ANSELx3. ANSELx7, 5 = ANSELx2. ANSELx7, 6 = ANSELx1. ANSELx7, 7 = ANSELx0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit",
    "REGISTER 16-4: ANSELx: ANALOG SELECT REGISTER\n7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\nbit 7-0 ANSELx<7:0> : Analog Select on Pins Rx<7:0>\n1 = Digital Input buffers are disabled.\n0 = ST and TTL input devices are enabled",
    "TABLE 16-5: ANALOG SELECT PORT REGISTERS\nANSELA, Bit 7 = ANSELA7. ANSELA, Bit 6 = ANSELA6. ANSELA, Bit 5 = ANSELA5. ANSELA, Bit 4 = ANSELA4. ANSELA, Bit 3 = ANSELA3. ANSELA, Bit 2 = ANSELA2. ANSELA, Bit 1 = ANSELA1. ANSELA, Bit 0 = ANSELA0. ANSELB, Bit 7 = ANSELB7. ANSELB, Bit 6 = ANSELB6. ANSELB, Bit 5 = ANSELB5. ANSELB, Bit 4 = ANSELB4. ANSELB, Bit 3 = ANSELB3. ANSELB, Bit 2 = ANSELB2. ANSELB, Bit 1 = ANSELB1. ANSELB, Bit 0 = ANSELB0. ANSELC, Bit 7 = ANSELC7. ANSELC, Bit 6 = ANSELC6. ANSELC, Bit 5 = ANSELC5. ANSELC, Bit 4 = ANSELC4. ANSELC, Bit 3 =",
    "TABLE 16-5: ANALOG SELECT PORT REGISTERS\nANSELC3. ANSELC, Bit 2 = ANSELC2. ANSELC, Bit 1 = ANSELC1. ANSELC, Bit 0 = ANSELC0",
    "REGISTER 16-5: WPUx: WEAK PULL-UP REGISTER\nWPUx7, R/W-0/0 = WPUx6. WPUx7, R/W-0/0 = WPUx5. WPUx7, R/W-0/0 = WPUx4. WPUx7, R/W-0/0 = WPUx3. WPUx7, R/W-0/0 = WPUx2. WPUx7, R/W-0/0 = WPUx1. WPUx7, R/W-0/0 = WPUx0. bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\nbit 7-0\nWPUx<7:0>: Weak Pull-up PORTx Control bits\n1 = Weak Pull-up enabled\n0 = Weak Pull-up disabled",
    "TABLE 16-6: WEAK PULL-UP PORT REGISTERS\nWPUA, Bit 7 = WPUA7. WPUA, Bit 6 = WPUA6. WPUA, Bit 5 = WPUA5. WPUA, Bit 4 = WPUA4. WPUA, Bit 3 = WPUA3. WPUA, Bit 2 = WPUA2. WPUA, Bit 1 = WPUA1. WPUA, Bit 0 = WPUA0. WPUB, Bit 7 = WPUB7. WPUB, Bit 6 = WPUB6. WPUB, Bit 5 = WPUB5. WPUB, Bit 4 = WPUB4. WPUB, Bit 3 = WPUB3. WPUB, Bit 2 = WPUB2. WPUB, Bit 1 = WPUB1. WPUB, Bit 0 = WPUB0. WPUC, Bit 7 = WPUC7. WPUC, Bit 6 = WPUC6. WPUC, Bit 5 = WPUC5. WPUC, Bit 4 = WPUC4. WPUC, Bit 3",
    "TABLE 16-6: WEAK PULL-UP PORT REGISTERS\n= WPUC3. WPUC, Bit 2 = WPUC2. WPUC, Bit 1 = WPUC1. WPUC, Bit 0 = WPUC0. WPUE, Bit 7 = -. WPUE, Bit 6 = -. WPUE, Bit 5 = -. WPUE, Bit 4 = -. WPUE, Bit 3 = WPUE3 (1). WPUE, Bit 2 = -. WPUE, Bit 1 = -. WPUE, Bit 0 = -\nNote 1: If MCLRE = 1 , the weak pull-up in RE3 is always enabled; bit WPUE3 is not affected.",
    "REGISTER 16-6: ODCONx: OPEN-DRAIN CONTROL REGISTER\nODCx7, R/W-0/0 = ODCx6. ODCx7, R/W-0/0 = ODCx5. ODCx7, R/W-0/0 = ODCx4. ODCx7, R/W-0/0 = ODCx3. ODCx7, R/W-0/0 = ODCx2. ODCx7, R/W-0/0 = ODCx1. ODCx7, R/W-0/0 = ODCx0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0,",
    "REGISTER 16-6: ODCONx: OPEN-DRAIN CONTROL REGISTER\nR/W-0/0 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\nbit 7-0\nODCx<7:0> : Open-Drain Configuration on Pins Rx<7:0>\n1 = Output drives only low-going signals (sink current only)\n0 = Output drives both high-going and low-going signals (source and sink current)",
    "TABLE 16-7: OPEN-DRAIN CONTROL REGISTERS\nODCONA, Bit 7 = ODCA7. ODCONA, Bit 6 = ODCA6. ODCONA, Bit 5 = ODCA5. ODCONA, Bit 4 = ODCA4. ODCONA, Bit 3 = ODCA3. ODCONA, Bit 2 = ODCA2. ODCONA, Bit 1 = ODCA1. ODCONA, Bit 0 = ODCA0. ODCONB, Bit 7 = ODCB7. ODCONB, Bit 6 = ODCB6. ODCONB, Bit 5 = ODCB5. ODCONB, Bit 4 = ODCB4. ODCONB, Bit 3 = ODCB3. ODCONB, Bit 2 = ODCB2. ODCONB, Bit 1 = ODCB1. ODCONB, Bit 0 = ODCB0. ODCONC, Bit 7 = ODCC7. ODCONC, Bit 6 = ODCC6. ODCONC, Bit 5 = ODCC5. ODCONC, Bit 4 =",
    "TABLE 16-7: OPEN-DRAIN CONTROL REGISTERS\nODCC4. ODCONC, Bit 3 = ODCC3. ODCONC, Bit 2 = ODCC2. ODCONC, Bit 1 = ODCC1. ODCONC, Bit 0 = ODCC0",
    "REGISTER 16-7: SLRCONx: SLEW RATE CONTROL REGISTER\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. SLRx7, 1 = SLRx6. SLRx7, 2 = SLRx5. SLRx7, 3 = SLRx4. SLRx7, 4 = SLRx3. SLRx7, 5 = SLRx2. SLRx7, 6 = SLRx1. SLRx7, 7 = SLRx0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7.",
    "REGISTER 16-7: SLRCONx: SLEW RATE CONTROL REGISTER\nbit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\nbit 7-0\nSLRx<7:0> : Slew Rate Control on Pins Rx<7:0>, respectively\n1 = Port pin slew rate is limited\n0 = Port pin slews at maximum rate",
    "TABLE 16-8: SLEW RATE CONTROL REGISTERS\nSLRCONA, Bit 7 = SLRA7. SLRCONA, Bit 6 = SLRA6. SLRCONA, Bit 5 = SLRA5. SLRCONA, Bit 4 = SLRA4. SLRCONA, Bit 3 = SLRA3. SLRCONA, Bit 2 = SLRA2. SLRCONA, Bit 1 = SLRA1. SLRCONA, Bit 0 = SLRA0. SLRCONB, Bit 7 = SLRB7. SLRCONB, Bit 6 = SLRB6. SLRCONB, Bit 5 = SLRB5. SLRCONB, Bit 4 = SLRB4. SLRCONB, Bit 3 = SLRB3. SLRCONB, Bit 2 = SLRB2. SLRCONB, Bit 1 = SLRB1. SLRCONB, Bit 0 = SLRB0. SLRCONC, Bit 7 = SLRC7. SLRCONC, Bit 6 = SLRC6. SLRCONC, Bit 5 = SLRC5. SLRCONC, Bit 4 = SLRC4. SLRCONC, Bit 3 = SLRC3. SLRCONC, Bit 2 = SLRC2. SLRCONC,",
    "TABLE 16-8: SLEW RATE CONTROL REGISTERS\nBit 1 = SLRC1. SLRCONC, Bit 0 = SLRC0",
    "REGISTER 16-8: INLVLx: INPUT LEVEL CONTROL REGISTER\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. INLVLx7, 1 = INLVLx6. INLVLx7, 2 = INLVLx5. INLVLx7, 3 = INLVLx4. INLVLx7, 4 = INLVLx3. INLVLx7, 5 = INLVLx2. INLVLx7, 6 = INLVLx1. INLVLx7, 7 = INLVLx0. bit 7,",
    "REGISTER 16-8: INLVLx: INPUT LEVEL CONTROL REGISTER\n1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = x = Bit is unknown. -n/n = Value at POR and BOR/Value at all other Resets, 1 = -n/n = Value at POR and BOR/Value at all other Resets. -n/n = Value at POR and BOR/Value at all other Resets, 2 = -n/n = Value at POR and BOR/Value at all other Resets\nbit 7-0",
    "REGISTER 16-8: INLVLx: INPUT LEVEL CONTROL REGISTER\nINLVLx<7:0> : Input Level Select on Pins Rx<7:0>, respectively\n1 = ST input used for port reads and interrupt-on-change\n0 = TTL input used for port reads and interrupt-on-change",
    "TABLE 16-9: INPUT LEVEL PORT REGISTERS\nINLVLA, Bit 7 = INLVLA7. INLVLA, Bit 6 = INLVLA6. INLVLA, Bit 5 = INLVLA5. INLVLA, Bit 4 = INLVLA4. INLVLA, Bit 3 = INLVLA3. INLVLA, Bit 2 = INLVLA2. INLVLA, Bit 1 = INLVLA1. INLVLA, Bit 0 = INLVLA0. INLVLB, Bit 7 = INLVLB7. INLVLB, Bit 6 = INLVLB6. INLVLB, Bit 5 = INLVLB5. INLVLB, Bit 4 = INLVLB4. INLVLB, Bit 3 = INLVLB3. INLVLB, Bit 2 = INLVLB2 (1). INLVLB, Bit 1 = INLVLB1 (1). INLVLB, Bit 0 = INLVLB0. INLVLC, Bit 7 = INLVLC7.",
    "TABLE 16-9: INPUT LEVEL PORT REGISTERS\nINLVLC, Bit 6 = INLVLC6. INLVLC, Bit 5 = INLVLC5. INLVLC, Bit 4 = INLVLC4 (1). INLVLC, Bit 3 = INLVLC3 (1). INLVLC, Bit 2 = INLVLC2. INLVLC, Bit 1 = INLVLC1. INLVLC, Bit 0 = INLVLC0. INLVLE, Bit 7 = -. INLVLE, Bit 6 = -. INLVLE, Bit 5 = -. INLVLE, Bit 4 = -. INLVLE, Bit 3 = INLVLE3. INLVLE, Bit 2 = -. INLVLE, Bit 1 = -. INLVLE, Bit 0 = -\nNote1: Any peripheral using the I 2 C pins read the I 2 C ST inputs when enabled via RxyI2C.\n- 2: Unimplemented in PIC18(L)F25K83.",
    "REGISTER 16-9: RxyI2C: I 2 C PAD Rxy CONTROL REGISTER\nU-0, 1 = R/W-0/0. U-0, 2 = R/W-0/0. U-0, 3 = R/W-0/0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = SLEW. -, 2 = PU<1:0>. -, 3 = . -, 4 = -. -, 5 = -. -, 6 = TH<1:0>. -, 7 = . bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 16-9: RxyI2C: I 2 C PAD Rxy CONTROL REGISTER\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HS = Hardware set",
    "bit 7 Unimplemented : Read as ' 0 '\nbit 6\nSLEW : I 2 C Specific Slew Rate Limiting is Enabled\n1 = I 2 C specific slew rate limiting is enabled. Standard pad slew limiting is disabled. The SLRxy bit is ignored.\n0 =   Standard GPIO Slew Rate; enabled/disabled via SLRxy bit.\nbit 5-4\nPU<1:0>\n: I 2 C Pull-up Selection bits\n11 =   Reserved\n10 =   10x current of standard weak pull-up\n01 =   2x current of standard weak pull-up\n00 =   Standard GPIO weak pull-up, enabled via WPUxy bit",
    "bit 3-2\nUnimplemented : Read as ' 0 '\nbit 1-0\nTH<1:0> : I 2 C Input Threshold Selection bits\n11 =   SMBus 3.0 (1.35 V) input threshold\n10 =   SMBus 2.0 (2.1 V) input threshold\n01 =   I 2 C specific input thresholds\n00 =   Standard GPIO Input pull-up, enabled via INLVLxy registers",
    "TABLE 16-10: I2C PAD CONTROL REGISTERS\nRB1I2C, Bit 7 = -. RB1I2C, Bit 6 = SLEW. RB1I2C, Bit 5 = PU<1:0>. RB1I2C, Bit 4 = PU<1:0>. RB1I2C, Bit 3 = -. RB1I2C, Bit 2 = -. RB1I2C, Bit 1 = TH<1:0>. RB1I2C, Bit 0 = TH<1:0>. RB2I2C, Bit 7 = -. RB2I2C, Bit 6 = SLEW. RB2I2C, Bit 5 = PU<1:0>. RB2I2C, Bit 4 = PU<1:0>. RB2I2C, Bit 3 = -. RB2I2C, Bit 2 = -. RB2I2C, Bit 1 = TH<1:0>. RB2I2C, Bit 0 = TH<1:0>. RC3I2C, Bit 7 = -. RC3I2C, Bit 6 = SLEW.",
    "TABLE 16-10: I2C PAD CONTROL REGISTERS\nRC3I2C, Bit 5 = PU<1:0>. RC3I2C, Bit 4 = PU<1:0>. RC3I2C, Bit 3 = -. RC3I2C, Bit 2 = -. RC3I2C, Bit 1 = TH<1:0>. RC3I2C, Bit 0 = TH<1:0>. RC4I2C, Bit 7 = -. RC4I2C, Bit 6 = SLEW. RC4I2C, Bit 5 = PU<1:0>. RC4I2C, Bit 4 = PU<1:0>. RC4I2C, Bit 3 = -. RC4I2C, Bit 2 = -. RC4I2C, Bit 1 = TH<1:0>. RC4I2C, Bit 0 = TH<1:0>",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\nPORTA, Bit 7 = RA7. PORTA, Bit 6 = RA6. PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Register on Page = 253. PORTB, Bit 7 = RB7 (1). PORTB, Bit 6 = RB6 (1). PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 = RB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTB, Register on Page = 253. PORTC, Bit 7 = RC7. PORTC, Bit 6 = RC6. PORTC, Bit 5 = RC5. PORTC, Bit 4 = RC4. PORTC, Bit 3 = RC3. PORTC, Bit 2 = RC2. PORTC, Bit 1 = RC1. PORTC, Bit 0 = RC0. PORTC,",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\nRegister on Page = 253. PORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = RE3 (2). PORTE, Bit 2 = -. PORTE, Bit 1 = -. PORTE, Bit 0 = -. PORTE, Register on Page = 253. TRISA, Bit 7 = TRISA7. TRISA, Bit 6 = TRISA6. TRISA, Bit 5 = TRISA5. TRISA, Bit 4 = TRISA4. TRISA, Bit 3 = TRISA3. TRISA, Bit 2 = TRISA2. TRISA, Bit 1 = TRISA1. TRISA, Bit 0 = TRISA0. TRISA, Register on Page = 254. TRISB, Bit 7 = TRISB7 (3). TRISB, Bit 6 = TRISB6 (3). TRISB, Bit 5 = TRISB5. TRISB, Bit 4 = TRISB4. TRISB, Bit 3 = TRISB3. TRISB, Bit 2 = TRISB2. TRISB, Bit 1 = TRISB1. TRISB, Bit",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\n0 = TRISB0. TRISB, Register on Page = 254. TRISC, Bit 7 = TRISC7. TRISC, Bit 6 = TRISC6. TRISC, Bit 5 = TRISC5. TRISC, Bit 4 = TRISC4. TRISC, Bit 3 = TRISC3. TRISC, Bit 2 = TRISC2. TRISC, Bit 1 = TRISC1. TRISC, Bit 0 = TRISC0. TRISC, Register on Page = 254. LATA, Bit 7 = LATA7. LATA, Bit 6 = LATA6. LATA, Bit 5 = LATA5. LATA, Bit 4 = LATA4. LATA, Bit 3 = LATA3. LATA, Bit 2 = LATA2. LATA, Bit 1 = LATA1. LATA, Bit 0 = LATA0. LATA, Register on Page = 255. LATB, Bit 7 = LATB7. LATB, Bit 6 = LATB6. LATB, Bit 5 = LATB5. LATB, Bit 4 = LATB4.",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\nLATB, Bit 3 = LATB3. LATB, Bit 2 = LATB2. LATB, Bit 1 = LATB1. LATB, Bit 0 = LATB0. LATB, Register on Page = 255. LATC, Bit 7 = LATC7. LATC, Bit 6 = LATC6. LATC, Bit 5 = LATC5. LATC, Bit 4 = LATC4. LATC, Bit 3 = LATC3. LATC, Bit 2 = LATC2. LATC, Bit 1 = LATC1. LATC, Bit 0 = LATC0. LATC, Register on Page = 255. ANSELA, Bit 7 = ANSELA7. ANSELA, Bit 6 = ANSELA6. ANSELA, Bit 5 = ANSELA5. ANSELA, Bit 4 = ANSELA4. ANSELA, Bit 3 = ANSELA3. ANSELA, Bit 2 = ANSELA2. ANSELA, Bit 1 = ANSELA1. ANSELA, Bit 0 = ANSELA0.",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\nANSELA, Register on Page = 256. ANSELB, Bit 7 = ANSELB7. ANSELB, Bit 6 = ANSELB6. ANSELB, Bit 5 = ANSELB5. ANSELB, Bit 4 = ANSELB4. ANSELB, Bit 3 = ANSELB3. ANSELB, Bit 2 = ANSELB2. ANSELB, Bit 1 = ANSELB1. ANSELB, Bit 0 = ANSELB0. ANSELB, Register on Page = 256. ANSELC, Bit 7 = ANSELC7. ANSELC, Bit 6 = ANSELC6. ANSELC, Bit 5 = ANSELC5. ANSELC, Bit 4 = ANSELC4. ANSELC, Bit 3 = ANSELC3. ANSELC, Bit 2 = ANSELC2. ANSELC, Bit 1 = ANSELC1. ANSELC, Bit 0 = ANSELC0. ANSELC, Register on Page = 256. WPUA, Bit 7 = WPUA7. WPUA, Bit 6 =",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\nWPUA6. WPUA, Bit 5 = WPUA5. WPUA, Bit 4 = WPUA4. WPUA, Bit 3 = WPUA3. WPUA, Bit 2 = WPUA2. WPUA, Bit 1 = WPUA1. WPUA, Bit 0 = WPUA0. WPUA, Register on Page = 257. WPUB, Bit 7 = WPUB7. WPUB, Bit 6 = WPUB6. WPUB, Bit 5 = WPUB5. WPUB, Bit 4 = WPUB4. WPUB, Bit 3 = WPUB3. WPUB, Bit 2 = WPUB2. WPUB, Bit 1 = WPUB1. WPUB, Bit 0 = WPUB0. WPUB, Register on Page = 257. WPUC, Bit 7 = WPUC7. WPUC, Bit 6 = WPUC6. WPUC, Bit 5 = WPUC5. WPUC, Bit 4 = WPUC4.",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\nWPUC, Bit 3 = WPUC3. WPUC, Bit 2 = WPUC2. WPUC, Bit 1 = WPUC1. WPUC, Bit 0 = WPUC0. WPUC, Register on Page = 257. WPUE, Bit 7 = -. WPUE, Bit 6 = -. WPUE, Bit 5 = -. WPUE, Bit 4 = -. WPUE, Bit 3 = WPUE3 (4). WPUE, Bit 2 = -. WPUE, Bit 1 = -. WPUE, Bit 0 = -. WPUE, Register on Page = 257. ODCONA, Bit 7 = ODCA7. ODCONA, Bit 6 = ODCA6. ODCONA, Bit 5 = ODCA5. ODCONA, Bit 4 = ODCA4. ODCONA, Bit 3 = ODCA3. ODCONA, Bit 2 = ODCA2. ODCONA, Bit 1 = ODCA1. ODCONA, Bit 0 = ODCA0.",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\nODCONA, Register on Page = 258. ODCONB, Bit 7 = ODCB7. ODCONB, Bit 6 = ODCB6. ODCONB, Bit 5 = ODCB5. ODCONB, Bit 4 = ODCB4. ODCONB, Bit 3 = ODCB3. ODCONB, Bit 2 = ODCB2. ODCONB, Bit 1 = ODCB1. ODCONB, Bit 0 = ODCB0. ODCONB, Register on Page = 258. ODCONC, Bit 7 = ODCC7. ODCONC, Bit 6 = ODCC6. ODCONC, Bit 5 = ODCC5. ODCONC, Bit 4 = ODCC4. ODCONC, Bit 3 = ODCC3. ODCONC, Bit 2 = ODCC2. ODCONC, Bit 1 = ODCC1. ODCONC, Bit 0 = ODCC0. ODCONC, Register on Page = 258.",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\nSLRCONA, Bit 7 = SLRA7. SLRCONA, Bit 6 = SLRA6. SLRCONA, Bit 5 = SLRA5. SLRCONA, Bit 4 = SLRA4. SLRCONA, Bit 3 = SLRA3. SLRCONA, Bit 2 = SLRA2. SLRCONA, Bit 1 = SLRA1. SLRCONA, Bit 0 = SLRA0. SLRCONA, Register on Page = 259. SLRCONB, Bit 7 = SLRB7. SLRCONB, Bit 6 = SLRB6. SLRCONB, Bit 5 = SLRB5. SLRCONB, Bit 4 = SLRB4. SLRCONB, Bit 3 = SLRB3. SLRCONB, Bit 2 = SLRB2. SLRCONB, Bit 1 = SLRB1. SLRCONB, Bit 0 = SLRB0. SLRCONB, Register on Page = 259. SLRCONC, Bit 7 = SLRC7. SLRCONC, Bit 6 = SLRC6. SLRCONC, Bit 5 = SLRC5. SLRCONC, Bit 4 = SLRC4.",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\nSLRCONC, Bit 3 = SLRC3. SLRCONC, Bit 2 = SLRC2. SLRCONC, Bit 1 = SLRC1. SLRCONC, Bit 0 = SLRC0. SLRCONC, Register on Page = 259. INLVLA, Bit 7 = INLVLA7. INLVLA, Bit 6 = INLVLA6. INLVLA, Bit 5 = INLVLA5. INLVLA, Bit 4 = INLVLA4. INLVLA, Bit 3 = INLVLA3. INLVLA, Bit 2 = INLVLA2. INLVLA, Bit 1 = INLVLA1. INLVLA, Bit 0 = INLVLA0. INLVLA, Register on Page = 260. INLVLB, Bit 7 = INLVLB7. INLVLB, Bit 6 = INLVLB6. INLVLB, Bit 5 = INLVLB5. INLVLB, Bit 4 = INLVLB4. INLVLB, Bit 3 =",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\nINLVLB3. INLVLB, Bit 2 = INLVLB2 (5). INLVLB, Bit 1 = INLVLB1 (5). INLVLB, Bit 0 = INLVLB0. INLVLB, Register on Page = 260. INLVLC, Bit 7 = INLVLC7. INLVLC, Bit 6 = INLVLC6. INLVLC, Bit 5 = INLVLC5. INLVLC, Bit 4 = INLVLC4 (5). INLVLC, Bit 3 = INLVLC3 (5). INLVLC, Bit 2 = INLVLC2. INLVLC, Bit 1 = INLVLC1. INLVLC, Bit 0 = INLVLC0. INLVLC, Register on Page = 260. INLVLE, Bit 7 = -. INLVLE, Bit 6 = -. INLVLE, Bit 5 = -. INLVLE, Bit 4 = -. INLVLE, Bit 3 =",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\nINLVLE3. INLVLE, Bit 2 = -. INLVLE, Bit 1 = -. INLVLE, Bit 0 = -. INLVLE, Register on Page = 260. RB1I2C, Bit 7 = -. RB1I2C, Bit 6 = SLEW. RB1I2C, Bit 5 = PU<1:0>. RB1I2C, Bit 4 = PU<1:0>. RB1I2C, Bit 3 = -. RB1I2C, Bit 2 = -. RB1I2C, Bit 1 = TH<1:0>. RB1I2C, Bit 0 = TH<1:0>. RB1I2C, Register on Page = 261. RB2I2C, Bit 7 = -. RB2I2C, Bit 6 = SLEW. RB2I2C, Bit 5 = PU<1:0>. RB2I2C, Bit 4 = PU<1:0>. RB2I2C, Bit 3 = -. RB2I2C, Bit 2 =",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\n-. RB2I2C, Bit 1 = TH<1:0>. RB2I2C, Bit 0 = TH<1:0>. RB2I2C, Register on Page = 261. RC3I2C, Bit 7 = -. RC3I2C, Bit 6 = SLEW. RC3I2C, Bit 5 = PU<1:0>. RC3I2C, Bit 4 = PU<1:0>. RC3I2C, Bit 3 = -. RC3I2C, Bit 2 = -. RC3I2C, Bit 1 = TH<1:0>. RC3I2C, Bit 0 = TH<1:0>. RC3I2C, Register on Page = 261. RC4I2C, Bit 7 = -. RC4I2C, Bit 6 = SLEW. RC4I2C, Bit 5 = PU<1:0>. RC4I2C, Bit 4 = PU<1:0>. RC4I2C, Bit 3 = -. RC4I2C, Bit 2 =",
    "TABLE 16-11: SUMMARY OF REGISTERS ASSOCIATED WITH I/O\n-. RC4I2C, Bit 1 = TH<1:0>. RC4I2C, Bit 0 = TH<1:0>. RC4I2C, Register on Page = 261\nLegend:\n- = unimplemented location, read as ' 0 '. Shaded cells are not used by I/O Ports.\nNote\n1: Bits RB6 and RB7 read ' 1 ' while in Debug mode.\n2: Bit PORTE3 is read-only, and will read ' 1 ' when MCLRE = 1 (Master Clear enabled).\n3: Bits RB6 and RB7 read ' 1 ' while in Debug mode.\n4: If MCLRE = 1 , the weak pull-up in RE3 is always enabled; bit WPUE3 is not affected.\n5: Any peripheral using the I C pins read the I C ST inputs when enabled via RxyI2C. 2 2",
    "17.0 PERIPHERAL PIN SELECT (PPS) MODULE\nThe  Peripheral  Pin  Select  (PPS)  module  connects peripheral inputs and outputs to the device I/O pins. Only digital signals are included in the selections. All analog inputs and outputs remain fixed to their assigned pins. Input and output selections are independent as shown in the simplified block diagram Figure 17-1.\nThe  peripheral  input  is  selected  with  the  peripheral xxxPPS  register  (Register 17-1),  and  the  peripheral output  is  selected  with  the  PORT  RxyPPS  register (Register 17-2). For example, to select PORTC<7> as the UART1 RX input, set U1RXPPS to 0b1 0111 , and to  select  PORTC<6>  as  the  UART1  TX  output  set RC6PPS to 0b01 0011 .",
    "17.1 PPS Inputs\nEach  peripheral  has  a  PPS  register  with  which  the inputs to the peripheral are selected. Inputs include the device pins.\nMultiple peripherals can operate from the same source simultaneously. Port reads always return the pin level regardless of peripheral PPS selection. If a pin also has analog functions associated, the ANSEL bit for that pin must be cleared to enable the digital input buffer.\nAlthough every peripheral has its own PPS input selec -tion  register,  the  selections  are  identical  for  every peripheral as shown in Register 17-1.\nNote:\nThe notation 'xxx' in the register name is a place holder for the peripheral identifier. For example, INT0PPS.",
    "17.2 PPS Outputs\nEach I/O  pin  has  a  PPS  register  with  which  the  pin output source is selected. With few exceptions, the port TRIS  control  associated  with  that  pin  retains  control over the pin output driver. Peripherals that control the pin output driver as part of the peripheral operation will override the TRIS control as needed. These peripherals include:",
    "\u00b7 UART\nAlthough every pin has its own  PPS  peripheral selection register, the selections are identical for every pin as shown in Register 17-2.\nNote:\nThe notation 'Rxy' is a place holder for the pin identifier. For example, RA0PPS.\nFIGURE 17-1: SIMPLIFIED PPS BLOCK DIAGRAM",
    "17.3 Bidirectional Pins\nPPS selections for peripherals with bidirectional signals on a single pin must be made so that the PPS input and PPS output select the same pin. Peripherals that have bidirectional signals include:\n\u00b7 I 2 C\nNote:\nRefer to Table 17-1 for pins that are I 2 C compatible. Clock and data signals can be routed  to  any  pin,  however  pins  without I 2 C compatibility will operate at standard TTL/ST  logic  levels  as  selected  by  the INVLV register.",
    "17.4 PPS Lock\nThe PPS includes a mode in which all input and output selections can be locked to prevent inadvertent changes.  PPS  selections  are  locked  by  setting  the PPSLOCKED bit of the PPSLOCK register. Setting and clearing this bit requires a special sequence as an extra precaution against inadvertent changes. Examples of setting and clearing the PPSLOCKED bit are shown in Example 17-1.",
    "EXAMPLE 17-1: PPS LOCK SEQUENCE\n; Disable BCF, 1 = interrupts: INTCON0,GIE. ; Bank to BANKSEL MOVLB, 1 = PPSLOCK register PPSLOCK PPSLOCK 55h. ; Required MOVWF MOVLW MOVWF, 1 = sequence, next 4 instructions PPSLOCK AAh PPSLOCK. ; Set PPSLOCKED bit to disable writes ; Only a BSF instruction will work BSF PPSLOCK,0, 1 = ; Set PPSLOCKED bit to disable writes ; Only a BSF instruction will work BSF PPSLOCK,0. ; Enable BSF, 1 = Interrupts INTCON0,GIE",
    "EXAMPLE 17-2: PPS UNLOCK SEQUENCE\n; Disable interrupts:\nBCF\nINTCON0,GIE\n; Bank to PPSLOCK register\nBANKSEL\nPPSLOCK\nMOVLB\nPPSLOCK\nMOVLW\n55h\n; Required sequence, next 4 instructions\nMOVWF\nPPSLOCK\nMOVLW\nAAh\nMOVWF\nPPSLOCK\n; Clear PPSLOCKED bit to enable writes\n; Only a BCF instruction will work\nBCF\nPPSLOCK,0\n; Enable Interrupts\nBSF\nINTCON0,GIE",
    "17.5 PPS One-way Lock\nWhen this bit is set, the PPSLOCKED bit can only be cleared  and  set  one  time  after  a  device  Reset.  This allows  for  clearing  the  PPSLOCKED  bit  so  that  the input and output selections can be made during initial -ization. When the PPSLOCKED bit is set after all selec -tions have been made, it will remain set and cannot be cleared until after the next device Reset event.",
    "17.6 Operation During Sleep\nPPS  input  and  output  selections  are  unaffected  by Sleep.",
    "17.7 Effects of a Reset\nA  device  Power-on-Reset  (POR)  clears  all  PPS  input and output selections to  their default values. All  other Resets  leave  the  selections  unchanged.  Default  input selections are shown in pin allocation Table 3. The PPS one-way lock is also removed.\nbit 2-0",
    "REGISTER 17-1: xxxPPS: PERIPHERAL xxx INPUT SELECTION\n-, U-0 = -. -, R/W-m/u (1) = xxxPPS<5:0>. -, R/W-m/u (1) = xxxPPS<5:0>. -, R/W-m/u (1) = xxxPPS<5:0>. -, R/W-m/u (1) = xxxPPS<5:0>. -, R/W-m/u (1) = xxxPPS<5:0>. -, R/W-m/u (1) = xxxPPS<5:0>. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-m/u (1) = bit 7 bit 0. bit 7 bit 0, R/W-m/u (1) = bit 7 bit 0. bit 7 bit 0, R/W-m/u (1) = bit 7 bit 0. bit 7 bit 0, R/W-m/u (1) = bit 7 bit 0. bit 7 bit",
    "REGISTER 17-1: xxxPPS: PERIPHERAL xxx INPUT SELECTION\n0, R/W-m/u (1) = bit 7 bit 0. bit 7 bit 0, R/W-m/u (1) = bit 7 bit 0\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, -n/n = Value at POR and BOR/Value at all other Resets q = value depends on peripheral m= value depends on default location for that input = . '1' = Bit is set, W=Writable bit = U = Unimplemented bit, read as '0'. '1' = Bit is set, -n/n = Value at POR and BOR/Value at all other Resets q = value depends on peripheral m= value depends on default location for that input = . '0' = Bit is cleared, W=Writable bit = . '0' = Bit is cleared, -n/n = Value at POR and BOR/Value at all other Resets q = value depends on peripheral m= value depends on default location for that input = ",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5-3\nxxxPPS<5:3>: Peripheral xxx Input PORTx Pin Selection bits\nSee Table 17-1 for the list of available ports and default pin locations.\n101 = Reserved\n100 = Reserved\n011 = Reserved\n010 = PORTC\n001 = PORTB\n000 = PORTA\nxxxPPS<2:0>: Peripheral xxx Input PORTx Pin Selection bits\n111 = Peripheral input is from PORTx Pin 7 (Rx7)\n110 = Peripheral input is from PORTx Pin 6 (Rx6)\n101 = Peripheral input is from PORTx Pin 5 (Rx5)\n100 = Peripheral input is from PORTx Pin 4 (Rx4)\n011 = Peripheral input is from PORTx Pin 3 (Rx3)\n010 = Peripheral input is from PORTx Pin 2 (Rx2)\n001 = Peripheral input is from PORTx Pin 1 (Rx1)\n000 = Peripheral input is from PORTx Pin 0 (Rx0)\nNote 1: The Reset value 'm' of this register is determined by device default locations for that input.",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nInterrupt 0, PPS Input Register = INT0PPS. Interrupt 0, Default Pin Selection at POR = RB0. Interrupt 0, Register Reset Value at POR = 0b0 1000. Interrupt 0, Input Available from Selected PORTx = A. Interrupt 0, PIC18(L)F2xK83 = B. Interrupt 0, Input Available from Selected PORTx = -. Interrupt 1, PPS Input Register = INT1PPS. Interrupt 1, Default Pin Selection at POR = RB1. Interrupt 1, Register Reset Value at POR = 0b0 1001. Interrupt 1, Input Available from Selected PORTx = A. Interrupt 1, PIC18(L)F2xK83 = B. Interrupt 1, Input Available from Selected PORTx = -. Interrupt 2, PPS Input Register = INT2PPS. Interrupt 2, Default Pin Selection at POR = RB2. Interrupt 2, Register Reset Value at POR = 0b0 1010. Interrupt 2, Input Available from Selected PORTx = A. Interrupt 2, PIC18(L)F2xK83 = B. Interrupt 2, Input Available from Selected PORTx = -. Timer0 Clock, PPS Input",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nRegister = T0CKIPPS. Timer0 Clock, Default Pin Selection at POR = RA4. Timer0 Clock, Register Reset Value at POR = 0b0 0100. Timer0 Clock, Input Available from Selected PORTx = A. Timer0 Clock, PIC18(L)F2xK83 = B. Timer0 Clock, Input Available from Selected PORTx = -. Timer1 Clock, PPS Input Register = T1CKIPPS. Timer1 Clock, Default Pin Selection at POR = RC0. Timer1 Clock, Register Reset Value at POR = 0b1 0000. Timer1 Clock, Input Available from Selected PORTx = A. Timer1 Clock, PIC18(L)F2xK83 = -. Timer1 Clock, Input Available from Selected PORTx = C. Timer1 Gate, PPS Input Register = T1GPPS. Timer1 Gate, Default Pin Selection at POR = RB5. Timer1 Gate, Register Reset Value at POR = 0b0 1101. Timer1 Gate, Input Available from Selected PORTx = -. Timer1 Gate, PIC18(L)F2xK83 = B. Timer1 Gate, Input",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nAvailable from Selected PORTx = C. Timer3 Clock, PPS Input Register = T3CKIPPS. Timer3 Clock, Default Pin Selection at POR = RC0. Timer3 Clock, Register Reset Value at POR = 0b1 0000. Timer3 Clock, Input Available from Selected PORTx = -. Timer3 Clock, PIC18(L)F2xK83 = B. Timer3 Clock, Input Available from Selected PORTx = C. Timer3 Gate, PPS Input Register = T3GPPS. Timer3 Gate, Default Pin Selection at POR = RC0. Timer3 Gate, Register Reset Value at POR = 0b1 0000. Timer3 Gate, Input Available from Selected PORTx = A. Timer3 Gate, PIC18(L)F2xK83 = -. Timer3 Gate, Input Available from Selected PORTx = C. Timer5 Clock, PPS Input Register = T5CKIPPS. Timer5 Clock, Default Pin Selection at POR = RC2. Timer5 Clock, Register Reset Value at POR = 0b1 0010. Timer5 Clock, Input Available from Selected PORTx = A. Timer5 Clock,",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nPIC18(L)F2xK83 = -. Timer5 Clock, Input Available from Selected PORTx = C. Timer5 Gate, PPS Input Register = T5GPPS. Timer5 Gate, Default Pin Selection at POR = RB4. Timer5 Gate, Register Reset Value at POR = 0b0 1100. Timer5 Gate, Input Available from Selected PORTx = -. Timer5 Gate, PIC18(L)F2xK83 = B. Timer5 Gate, Input Available from Selected PORTx = C. Timer2 Clock, PPS Input Register = T2INPPS. Timer2 Clock, Default Pin Selection at POR = RC3. Timer2 Clock, Register Reset Value at POR = 0b1 0011. Timer2 Clock, Input Available from Selected PORTx = A. Timer2 Clock, PIC18(L)F2xK83 = -. Timer2 Clock, Input Available from Selected PORTx = C. Timer4 Clock, PPS Input Register = T4INPPS. Timer4 Clock, Default Pin Selection at POR = RC5. Timer4 Clock, Register Reset Value at POR = 0b1 0101. Timer4",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nClock, Input Available from Selected PORTx = -. Timer4 Clock, PIC18(L)F2xK83 = B. Timer4 Clock, Input Available from Selected PORTx = C. Timer6 Clock, PPS Input Register = T6INPPS. Timer6 Clock, Default Pin Selection at POR = RB7. Timer6 Clock, Register Reset Value at POR = 0b0 1111. Timer6 Clock, Input Available from Selected PORTx = -. Timer6 Clock, PIC18(L)F2xK83 = B. Timer6 Clock, Input Available from Selected PORTx = C. CCP1, PPS Input Register = CCP1PPS. CCP1, Default Pin Selection at POR = RC2. CCP1, Register Reset Value at POR = 0b1 0010. CCP1, Input Available from Selected PORTx = -. CCP1, PIC18(L)F2xK83 = B. CCP1, Input Available from Selected PORTx = C. CCP2, PPS Input Register = CCP2PPS. CCP2, Default Pin Selection at POR = RC1.",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nCCP2, Register Reset Value at POR = 0b1 0001. CCP2, Input Available from Selected PORTx = -. CCP2, PIC18(L)F2xK83 = B. CCP2, Input Available from Selected PORTx = C. CCP3, PPS Input Register = CCP3PPS. CCP3, Default Pin Selection at POR = RB5. CCP3, Register Reset Value at POR = 0b0 1101. CCP3, Input Available from Selected PORTx = -. CCP3, PIC18(L)F2xK83 = B. CCP3, Input Available from Selected PORTx = C. CCP4, PPS Input Register = CCP4PPS. CCP4, Default Pin Selection at POR = RB0. CCP4, Register Reset Value at POR = 0b0 1000. CCP4, Input Available from Selected PORTx = -. CCP4, PIC18(L)F2xK83 = B. CCP4, Input Available from Selected PORTx = C. SMT1 Window, PPS Input Register =",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nSMT1WINPPS. SMT1 Window, Default Pin Selection at POR = RC0. SMT1 Window, Register Reset Value at POR = 0b1 0000. SMT1 Window, Input Available from Selected PORTx = -. SMT1 Window, PIC18(L)F2xK83 = B. SMT1 Window, Input Available from Selected PORTx = C. SMT1 Signal, PPS Input Register = SMT1SIGPPS. SMT1 Signal, Default Pin Selection at POR = RB4. SMT1 Signal, Register Reset Value at POR = 0b0 1100. SMT1 Signal, Input Available from Selected PORTx = -. SMT1 Signal, PIC18(L)F2xK83 = B. SMT1 Signal, Input Available from Selected PORTx = C. SMT2 Window, PPS Input Register = SMT2WINPPS. SMT2 Window, Default Pin Selection at POR = RB5. SMT2 Window, Register Reset Value at POR = 0b0 1101. SMT2 Window, Input Available from Selected PORTx = -. SMT2 Window,",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nPIC18(L)F2xK83 = B. SMT2 Window, Input Available from Selected PORTx = C. SMT2 Signal, PPS Input Register = SMT2SIGPPS. SMT2 Signal, Default Pin Selection at POR = RC1. SMT2 Signal, Register Reset Value at POR = 0b1 0001. SMT2 Signal, Input Available from Selected PORTx = -. SMT2 Signal, PIC18(L)F2xK83 = B. SMT2 Signal, Input Available from Selected PORTx = C. CWG1, PPS Input Register = CWG1PPS. CWG1, Default Pin Selection at POR = RB0. CWG1, Register Reset Value at POR = 0b0 1000. CWG1, Input Available from Selected PORTx = -. CWG1, PIC18(L)F2xK83 = B. CWG1, Input Available from Selected PORTx = C. CWG2, PPS Input Register = CWG2PPS. CWG2, Default Pin Selection at POR = RB1. CWG2, Register Reset Value at POR =",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\n0b0 1001. CWG2, Input Available from Selected PORTx = -. CWG2, PIC18(L)F2xK83 = B. CWG2, Input Available from Selected PORTx = C. CWG3, PPS Input Register = CWG3PPS. CWG3, Default Pin Selection at POR = RB2. CWG3, Register Reset Value at POR = 0b0 1010. CWG3, Input Available from Selected PORTx = -. CWG3, PIC18(L)F2xK83 = B. CWG3, Input Available from Selected PORTx = C. DSM1 Carrier Low, PPS Input Register = MD1CARLPPS. DSM1 Carrier Low, Default Pin Selection at POR = RA3. DSM1 Carrier Low, Register Reset Value at POR = 0b0 0011. DSM1 Carrier Low, Input Available from Selected PORTx = A. DSM1 Carrier Low, PIC18(L)F2xK83 = -. DSM1 Carrier Low, Input Available from Selected PORTx = C. DSM1 Carrier High, PPS Input",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nRegister = MD1CARHPPS. DSM1 Carrier High, Default Pin Selection at POR = RA4. DSM1 Carrier High, Register Reset Value at POR = 0b0 0100. DSM1 Carrier High, Input Available from Selected PORTx = A. DSM1 Carrier High, PIC18(L)F2xK83 = -. DSM1 Carrier High, Input Available from Selected PORTx = C. DSM1 Source, PPS Input Register = MD1SRCPPS. DSM1 Source, Default Pin Selection at POR = RA5. DSM1 Source, Register Reset Value at POR = 0b0 0101. DSM1 Source, Input Available from Selected PORTx = A. DSM1 Source, PIC18(L)F2xK83 = -. DSM1 Source, Input Available from Selected PORTx = C. CLCx Input 1, PPS Input Register = CLCIN0PPS. CLCx Input 1, Default Pin Selection at POR = RA0. CLCx Input 1, Register Reset Value at POR = 0b0 0000. CLCx Input 1, Input Available from Selected PORTx",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\n= A. CLCx Input 1, PIC18(L)F2xK83 = -. CLCx Input 1, Input Available from Selected PORTx = C. CLCx Input 2, PPS Input Register = CLCIN1PPS. CLCx Input 2, Default Pin Selection at POR = RA1. CLCx Input 2, Register Reset Value at POR = 0b0 0001. CLCx Input 2, Input Available from Selected PORTx = A. CLCx Input 2, PIC18(L)F2xK83 = -. CLCx Input 2, Input Available from Selected PORTx = C. CLCx Input 3, PPS Input Register = CLCIN2PPS. CLCx Input 3, Default Pin Selection at POR = RB6. CLCx Input 3, Register Reset Value at POR = 0b0 1110. CLCx Input 3, Input Available from Selected PORTx = -. CLCx Input 3, PIC18(L)F2xK83 = B. CLCx Input 3, Input Available from Selected PORTx = C. CLCx Input 4, PPS Input Register",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\n= CLCIN3PPS. CLCx Input 4, Default Pin Selection at POR = RB7. CLCx Input 4, Register Reset Value at POR = 0b0 1111. CLCx Input 4, Input Available from Selected PORTx = -. CLCx Input 4, PIC18(L)F2xK83 = B. CLCx Input 4, Input Available from Selected PORTx = C. ADC Conversion Trigger, PPS Input Register = ADACTPPS. ADC Conversion Trigger, Default Pin Selection at POR = RB4. ADC Conversion Trigger, Register Reset Value at POR = 0b0 1100. ADC Conversion Trigger, Input Available from Selected PORTx = -. ADC Conversion Trigger, PIC18(L)F2xK83 = B. ADC Conversion Trigger, Input Available from Selected PORTx = C. SPI1 Clock, PPS Input Register = SPI1SCKPPS. SPI1 Clock, Default Pin Selection at POR = RC3. SPI1 Clock, Register Reset Value at POR = 0b1 0011. SPI1 Clock, Input Available from Selected PORTx = -. SPI1",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nClock, PIC18(L)F2xK83 = B. SPI1 Clock, Input Available from Selected PORTx = C. SPI1 Data, PPS Input Register = SPI1SDIPPS. SPI1 Data, Default Pin Selection at POR = RC4. SPI1 Data, Register Reset Value at POR = 0b1 0100. SPI1 Data, Input Available from Selected PORTx = -. SPI1 Data, PIC18(L)F2xK83 = B. SPI1 Data, Input Available from Selected PORTx = C. SPI1 Slave Select, PPS Input Register = SPI1SSPPS. SPI1 Slave Select, Default Pin Selection at POR = RA5. SPI1 Slave Select, Register Reset Value at POR = 0b0 0101. SPI1 Slave Select, Input Available from Selected PORTx = A. SPI1 Slave Select, PIC18(L)F2xK83 = -. SPI1 Slave Select, Input Available from Selected PORTx = C. I 2 C1 Clock, PPS Input Register = I2C1SCLPPS. I 2 C1",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nClock, Default Pin Selection at POR = RC3. I 2 C1 Clock, Register Reset Value at POR = 0b1 0011. I 2 C1 Clock, Input Available from Selected PORTx = -. I 2 C1 Clock, PIC18(L)F2xK83 = B. I 2 C1 Clock, Input Available from Selected PORTx = C. I 2 C1 Data, PPS Input Register = I2C1SDAPPS. I 2 C1 Data, Default Pin Selection at POR = RC4. I 2 C1 Data, Register Reset Value at POR = 0b1 0100. I 2 C1 Data, Input Available from Selected PORTx = -. I 2 C1 Data, PIC18(L)F2xK83 = B. I 2 C1 Data, Input Available from Selected PORTx = C. I 2 C2 Clock, PPS Input Register = I2C2SCLPPS. I 2 C2 Clock, Default Pin Selection at POR = RB1. I 2 C2 Clock, Register Reset Value at POR = 0b0 1001. I 2 C2 Clock, Input Available from Selected PORTx = -. I 2 C2 Clock,",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nPIC18(L)F2xK83 = B. I 2 C2 Clock, Input Available from Selected PORTx = C. I 2 C2 Data, PPS Input Register = I2C2SDAPPS. I 2 C2 Data, Default Pin Selection at POR = RB2. I 2 C2 Data, Register Reset Value at POR = 0b0 1010. I 2 C2 Data, Input Available from Selected PORTx = -. I 2 C2 Data, PIC18(L)F2xK83 = B. I 2 C2 Data, Input Available from Selected PORTx = C. UART1 Receive, PPS Input Register = U1RXPPS. UART1 Receive, Default Pin Selection at POR = RC7. UART1 Receive, Register Reset Value at POR = 0b1 0111. UART1 Receive, Input Available from Selected PORTx = -. UART1 Receive, PIC18(L)F2xK83 = B. UART1 Receive, Input Available from Selected PORTx = C. UART1 Clear To Send, PPS Input Register = U1CTSPPS. UART1 Clear To Send, Default Pin Selection at",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nPOR = RC6. UART1 Clear To Send, Register Reset Value at POR = 0b1 0110. UART1 Clear To Send, Input Available from Selected PORTx = -. UART1 Clear To Send, PIC18(L)F2xK83 = B. UART1 Clear To Send, Input Available from Selected PORTx = C. UART2 Receive, PPS Input Register = U2RXPPS. UART2 Receive, Default Pin Selection at POR = RB7. UART2 Receive, Register Reset Value at POR = 0b0 1111. UART2 Receive, Input Available from Selected PORTx = -. UART2 Receive, PIC18(L)F2xK83 = B. UART2 Receive, Input Available from Selected PORTx = C. UART2 Clear To Send, PPS Input Register = U2CTSPPS. UART2 Clear To Send, Default Pin Selection at POR = RB6. UART2 Clear To Send, Register Reset Value at POR = 0b0 1110. UART2 Clear To Send, Input Available from Selected PORTx = -. UART2 Clear To Send,",
    "TABLE 17-1: PPS INPUT REGISTER DETAILS\nPIC18(L)F2xK83 = B. UART2 Clear To Send, Input Available from Selected PORTx = C. CAN Receive, PPS Input Register = CANRXPPS. CAN Receive, Default Pin Selection at POR = RB3. CAN Receive, Register Reset Value at POR = 0b0 1011. CAN Receive, Input Available from Selected PORTx = -. CAN Receive, PIC18(L)F2xK83 = B. CAN Receive, Input Available from Selected PORTx = C",
    "REGISTER 17-2: RxyPPS: PIN Rxy OUTPUT SOURCE SELECTION REGISTER\n-, U-0 = -. -, R/W-0/u = RxyPPS<5:0>. -, R/W-0/u = RxyPPS<5:0>. -, R/W-0/u = RxyPPS<5:0>. -, R/W-0/u = RxyPPS<5:0>. -, R/W-0/u = RxyPPS<5:0>. -, R/W-0/u = RxyPPS<5:0>. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit",
    "REGISTER 17-2: RxyPPS: PIN Rxy OUTPUT SOURCE SELECTION REGISTER\n7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7-6 Unimplemented: Read as ' 0\n'\nbit 5-0\nRxyPPS<5:0>:\nPin Rxy Output Source Selection bits\nSee Table 17-2 for the list of available ports.",
    "DETAILS\n0b11, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0100. 0b11, Pin Rxy Output Source.Reserved = CANTX1. 0b11, Device Configuration.Reserved = -. 0b11, Device Configuration.Reserved = B. 0b11, Device Configuration.Reserved = C. 0b11, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0011. 0b11, Pin Rxy Output Source.Reserved = CANTX0. 0b11, Device Configuration.Reserved = -. 0b11, Device Configuration.Reserved = B. 0b11, Device Configuration.Reserved = C. 0b11, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0010. 0b11, Pin Rxy Output Source.Reserved = ADGRDB. 0b11, Device Configuration.Reserved = A. 0b11, Device Configuration.Reserved = -. 0b11, Device Configuration.Reserved = C. 0b11, RxyPPS<5:0>.0b11 1111 - 0b11",
    "DETAILS\n0101 = 0001. 0b11, Pin Rxy Output Source.Reserved = ADGRDA. 0b11, Device Configuration.Reserved = A. 0b11, Device Configuration.Reserved = -. 0b11, Device Configuration.Reserved = C. 0b11, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0000. 0b11, Pin Rxy Output Source.Reserved = CWG3D. 0b11, Device Configuration.Reserved = A. 0b11, Device Configuration.Reserved = -. 0b11, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1111. 0b10, Pin Rxy Output Source.Reserved = CWG3C. 0b10, Device Configuration.Reserved = A. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1110. 0b10, Pin Rxy Output Source.Reserved = CWG3B.",
    "DETAILS\n0b10, Device Configuration.Reserved = A. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1101. 0b10, Pin Rxy Output Source.Reserved = CWG3A. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = B. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1100. 0b10, Pin Rxy Output Source.Reserved = CWG2D. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = B. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1011. 0b10, Pin Rxy Output Source.Reserved = CWG2C. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = B.",
    "DETAILS\n0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1010. 0b10, Pin Rxy Output Source.Reserved = CWG2B. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = B. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1001. 0b10, Pin Rxy Output Source.Reserved = CWG2A. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = B. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1000. 0b10, Pin Rxy Output Source.Reserved = DSM1. 0b10, Device Configuration.Reserved = A. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = C. 0b10,",
    "DETAILS\nRxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0111. 0b10, Pin Rxy Output Source.Reserved = CLKR. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = B. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0110. 0b10, Pin Rxy Output Source.Reserved = NCO1. 0b10, Device Configuration.Reserved = A. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0101. 0b10, Pin Rxy Output Source.Reserved = TMR0. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = B. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0100.",
    "DETAILS\n0b10, Pin Rxy Output Source.Reserved = I 2 C2 (SDA). 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = B. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0011. 0b10, Pin Rxy Output Source.Reserved = I 2 C2 (SCL). 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = B. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0010. 0b10, Pin Rxy Output Source.Reserved = I 2 C1 (SDA). 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = B. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0001. 0b10, Pin Rxy Output Source.Reserved =",
    "DETAILS\nI 2 C1 (SCL). 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = B. 0b10, Device Configuration.Reserved = C. 0b10, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0000. 0b10, Pin Rxy Output Source.Reserved = SPI1 (SS). 0b10, Device Configuration.Reserved = A. 0b10, Device Configuration.Reserved = -. 0b10, Device Configuration.Reserved = C. 0b01, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1111. 0b01, Pin Rxy Output Source.Reserved = SPI1 (SDO). 0b01, Device Configuration.Reserved = -. 0b01, Device Configuration.Reserved = B. 0b01, Device Configuration.Reserved = C. 0b01, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1110. 0b01, Pin Rxy Output Source.Reserved = SPI1 (SCK). 0b01, Device",
    "DETAILS\nConfiguration.Reserved = -. 0b01, Device Configuration.Reserved = B. 0b01, Device Configuration.Reserved = C. 0b01, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1101. 0b01, Pin Rxy Output Source.Reserved = C2OUT. 0b01, Device Configuration.Reserved = A. 0b01, Device Configuration.Reserved = -. 0b01, Device Configuration.Reserved = C. 0b01, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1100. 0b01, Pin Rxy Output Source.Reserved = C1OUT. 0b01, Device Configuration.Reserved = A. 0b01, Device Configuration.Reserved = -. 0b01, Device Configuration.Reserved = C. 0b01 1011 - 0b01 1001, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0b01 1011 - 0b01 1001. 0b01 1011 - 0b01 1001, Pin Rxy Output Source.Reserved = Reserved. 0b01 1011 - 0b01",
    "DETAILS\n1001, Device Configuration.Reserved = Reserved. 0b01 1011 - 0b01 1001, Device Configuration.Reserved = Reserved. 0b01 1011 - 0b01 1001, Device Configuration.Reserved = Reserved. 0b01, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1000. 0b01, Pin Rxy Output Source.Reserved = UART2 (RTS). 0b01, Device Configuration.Reserved = -. 0b01, Device Configuration.Reserved = B. 0b01, Device Configuration.Reserved = C. 0b01, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0111. 0b01, Pin Rxy Output Source.Reserved = UART2 (TXDE). 0b01, Device Configuration.Reserved = -. 0b01, Device Configuration.Reserved = B. 0b01, Device Configuration.Reserved = C. 0b01, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0110. 0b01, Pin Rxy Output Source.Reserved = UART2",
    "DETAILS\n(TX). 0b01, Device Configuration.Reserved = -. 0b01, Device Configuration.Reserved = B. 0b01, Device Configuration.Reserved = C. 0b01, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0101. 0b01, Pin Rxy Output Source.Reserved = UART1 (RTS). 0b01, Device Configuration.Reserved = -. 0b01, Device Configuration.Reserved = B. 0b01, Device Configuration.Reserved = C. 0b01, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0100. 0b01, Pin Rxy Output Source.Reserved = UART1 (TXDE). 0b01, Device Configuration.Reserved = -. 0b01, Device Configuration.Reserved = B. 0b01, Device Configuration.Reserved = C. 0b01, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0011. 0b01, Pin Rxy Output Source.Reserved = UART1 (TX). 0b01, Device Configuration.Reserved =",
    "DETAILS\n-. 0b01, Device Configuration.Reserved = B. 0b01, Device Configuration.Reserved = C. 0b01 0010 - 0b01 0001, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0b01 0010 - 0b01 0001. 0b01 0010 - 0b01 0001, Pin Rxy Output Source.Reserved = Reserved. 0b01 0010 - 0b01 0001, Device Configuration.Reserved = Reserved. 0b01 0010 - 0b01 0001, Device Configuration.Reserved = Reserved. 0b01 0010 - 0b01 0001, Device Configuration.Reserved = Reserved. 0b01, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0000. 0b01, Pin Rxy Output Source.Reserved = PWM8. 0b01, Device Configuration.Reserved = A. 0b01, Device Configuration.Reserved = -. 0b01, Device Configuration.Reserved = C. 0b00, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1111.",
    "DETAILS\n0b00, Pin Rxy Output Source.Reserved = PWM7. 0b00, Device Configuration.Reserved = A. 0b00, Device Configuration.Reserved = -. 0b00, Device Configuration.Reserved = C. 0b00, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1110. 0b00, Pin Rxy Output Source.Reserved = PWM6. 0b00, Device Configuration.Reserved = A. 0b00, Device Configuration.Reserved = -. 0b00, Device Configuration.Reserved = C. 0b00, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1101. 0b00, Pin Rxy Output Source.Reserved = PWM5. 0b00, Device Configuration.Reserved = A. 0b00, Device Configuration.Reserved = -. 0b00, Device Configuration.Reserved = C. 0b00, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1100. 0b00, Pin Rxy Output Source.Reserved = CCP4. 0b00, Device",
    "DETAILS\nConfiguration.Reserved = -. 0b00, Device Configuration.Reserved = B. 0b00, Device Configuration.Reserved = C. 0b00, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1011. 0b00, Pin Rxy Output Source.Reserved = CCP3. 0b00, Device Configuration.Reserved = -. 0b00, Device Configuration.Reserved = B. 0b00, Device Configuration.Reserved = C. 0b00, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1010. 0b00, Pin Rxy Output Source.Reserved = CCP2. 0b00, Device Configuration.Reserved = -. 0b00, Device Configuration.Reserved = B. 0b00, Device Configuration.Reserved = C. 0b00, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1001. 0b00, Pin Rxy Output Source.Reserved = CCP1. 0b00, Device Configuration.Reserved = -. 0b00, Device Configuration.Reserved = B. 0b00, Device",
    "DETAILS\nConfiguration.Reserved = C. 0b00, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 1000. 0b00, Pin Rxy Output Source.Reserved = CWG1D. 0b00, Device Configuration.Reserved = -. 0b00, Device Configuration.Reserved = B. 0b00, Device Configuration.Reserved = C. 0b00, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0111. 0b00, Pin Rxy Output Source.Reserved = CWG1C. 0b00, Device Configuration.Reserved = -. 0b00, Device Configuration.Reserved = B. 0b00, Device Configuration.Reserved = C. 0b00, RxyPPS<5:0>.0b11 1111 - 0b11 0101 = 0110. 0b00, Pin Rxy Output Source.Reserved = CWG1B. 0b00, Device Configuration.Reserved = -. 0b00, Device Configuration.Reserved = B. 0b00, Device Configuration.Reserved = C",
    "TABLE 17-2: PPS OUTPUT REGISTER DETAILS\n0b00, RxyPPS<5:0>.0101 = 0100. 0b00, Pin Rxy Output Source.CWG1A = CLC4OUT. 0b00, Device Configuration PIC18(L)F2xK83.- = -. 0b00, Device Configuration PIC18(L)F2xK83.B = B. 0b00, Device Configuration PIC18(L)F2xK83.C = C. 0b00, RxyPPS<5:0>.0101 = 0011. 0b00, Pin Rxy Output Source.CWG1A = CLC3OUT. 0b00, Device Configuration PIC18(L)F2xK83.- = -. 0b00, Device Configuration PIC18(L)F2xK83.B = B. 0b00, Device Configuration PIC18(L)F2xK83.C = C. 0b00, RxyPPS<5:0>.0101 = 0010. 0b00, Pin Rxy Output Source.CWG1A =",
    "TABLE 17-2: PPS OUTPUT REGISTER DETAILS\nCLC2OUT. 0b00, Device Configuration PIC18(L)F2xK83.- = A. 0b00, Device Configuration PIC18(L)F2xK83.B = -. 0b00, Device Configuration PIC18(L)F2xK83.C = C. 0b00, RxyPPS<5:0>.0101 = 0001. 0b00, Pin Rxy Output Source.CWG1A = CLC1OUT. 0b00, Device Configuration PIC18(L)F2xK83.- = A. 0b00, Device Configuration PIC18(L)F2xK83.B = -. 0b00, Device Configuration PIC18(L)F2xK83.C = C. 0b00, RxyPPS<5:0>.0101 = 0000. 0b00, Pin Rxy Output Source.CWG1A = LATxy. 0b00, Device Configuration PIC18(L)F2xK83.- = A. 0b00, Device Configuration",
    "TABLE 17-2: PPS OUTPUT REGISTER DETAILS\nPIC18(L)F2xK83.B = B. 0b00, Device Configuration PIC18(L)F2xK83.C = C",
    "REGISTER 17-3: PPSLOCK: PPS LOCK REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = PPSLOCKED. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 17-3: PPSLOCK: PPS LOCK REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = \nbit 7-1 Unimplemented: Read as ' 0 '\nbit 0\nPPSLOCKED:\nPPS Locked bit\n1 = PPS is locked.\n0 = PPS is not locked. PPS selections can be changed.",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\nPPSLOCK, Bit 7 = -. PPSLOCK, Bit 6 = -. PPSLOCK, Bit 5 = -. PPSLOCK, Bit 4 = -. PPSLOCK, Bit 3 = -. PPSLOCK, Bit 2 Bit = - -. PPSLOCK, Bit 0 = PPSLOCKED. PPSLOCK, Register on page = 269. INT0PPS, Bit 7 = -. INT0PPS, Bit 6 = -. INT0PPS, Bit 5 = -. INT0PPS, Bit 4 = . INT0PPS, Bit 3 = . INT0PPS, Bit 2 Bit = INT0PPS<4:0>. INT0PPS, Bit 0 = . INT0PPS, Register on page = 265. INT1PPS, Bit 7 = -. INT1PPS, Bit 6 = -. INT1PPS, Bit 5 = -. INT1PPS, Bit 4 = . INT1PPS, Bit 3 = . INT1PPS, Bit 2 Bit = INT1PPS<4:0>. INT1PPS, Bit 0 = . INT1PPS, Register on page = 265. INT2PPS, Bit 7 =",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\n-. INT2PPS, Bit 6 = -. INT2PPS, Bit 5 = -. INT2PPS, Bit 4 = . INT2PPS, Bit 3 = . INT2PPS, Bit 2 Bit = INT2PPS<4:0>. INT2PPS, Bit 0 = . INT2PPS, Register on page = 265. T0CKIPPS, Bit 7 = -. T0CKIPPS, Bit 6 = -. T0CKIPPS, Bit 5 = -. T0CKIPPS, Bit 4 = . T0CKIPPS, Bit 3 = . T0CKIPPS, Bit 2 Bit = T0CKIPPS<4:0>. T0CKIPPS, Bit 0 = . T0CKIPPS, Register on page = 265. T1CKIPPS, Bit 7 = -. T1CKIPPS, Bit 6 = -. T1CKIPPS, Bit 5 = -. T1CKIPPS, Bit 4 = . T1CKIPPS, Bit 3 = . T1CKIPPS, Bit 2 Bit = T1CKIPPS<4:0>. T1CKIPPS, Bit 0 = . T1CKIPPS, Register on page",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\n= 265. T1GPPS, Bit 7 = -. T1GPPS, Bit 6 = -. T1GPPS, Bit 5 = -. T1GPPS, Bit 4 = . T1GPPS, Bit 3 = . T1GPPS, Bit 2 Bit = T1GPPS<4:0>. T1GPPS, Bit 0 = . T1GPPS, Register on page = 265. T3CKIPPS, Bit 7 = -. T3CKIPPS, Bit 6 = -. T3CKIPPS, Bit 5 = -. T3CKIPPS, Bit 4 = . T3CKIPPS, Bit 3 = . T3CKIPPS, Bit 2 Bit = T3CKIPPS<4:0>. T3CKIPPS, Bit 0 = . T3CKIPPS, Register on page = 265. T3GPPS, Bit 7 = -. T3GPPS, Bit 6 = -. T3GPPS, Bit 5 = -. T3GPPS, Bit 4 = . T3GPPS, Bit 3 = . T3GPPS, Bit 2 Bit =",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\nT3GPPS<4:0>. T3GPPS, Bit 0 = . T3GPPS, Register on page = 265. T5CKIPPS, Bit 7 = -. T5CKIPPS, Bit 6 = -. T5CKIPPS, Bit 5 = -. T5CKIPPS, Bit 4 = . T5CKIPPS, Bit 3 = . T5CKIPPS, Bit 2 Bit = T5CKIPPS<4:0>. T5CKIPPS, Bit 0 = . T5CKIPPS, Register on page = 265. T5GPPS, Bit 7 = -. T5GPPS, Bit 6 = -. T5GPPS, Bit 5 = -. T5GPPS, Bit 4 = . T5GPPS, Bit 3 = . T5GPPS, Bit 2 Bit = T5GPPS<4:0>. T5GPPS, Bit 0 = . T5GPPS, Register on page = 265. T2INPPS, Bit 7 = -. T2INPPS, Bit 6 = -. T2INPPS, Bit 5 = -. T2INPPS, Bit 4 =",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\n. T2INPPS, Bit 3 = . T2INPPS, Bit 2 Bit = T2INPPS<4:0>. T2INPPS, Bit 0 = . T2INPPS, Register on page = 265. T4INPPS, Bit 7 = -. T4INPPS, Bit 6 = -. T4INPPS, Bit 5 = -. T4INPPS, Bit 4 = . T4INPPS, Bit 3 = . T4INPPS, Bit 2 Bit = T4INPPS<4:0>. T4INPPS, Bit 0 = . T4INPPS, Register on page = 265. T6INPPS, Bit 7 = -. T6INPPS, Bit 6 = -. T6INPPS, Bit 5 = -. T6INPPS, Bit 4 = . T6INPPS, Bit 3 = . T6INPPS, Bit 2 Bit = T6INPPS<4:0>. T6INPPS, Bit 0 = . T6INPPS, Register on page = 265. CCP1PPS, Bit 7 = -. CCP1PPS, Bit 6 =",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\n-. CCP1PPS, Bit 5 = -. CCP1PPS, Bit 4 = . CCP1PPS, Bit 3 = . CCP1PPS, Bit 2 Bit = CCP1PPS<4:0>. CCP1PPS, Bit 0 = . CCP1PPS, Register on page = 265. CCP2PPS, Bit 7 = -. CCP2PPS, Bit 6 = -. CCP2PPS, Bit 5 = -. CCP2PPS, Bit 4 = . CCP2PPS, Bit 3 = . CCP2PPS, Bit 2 Bit = CCP2PPS<4:0>. CCP2PPS, Bit 0 = . CCP2PPS, Register on page = 265. CCP3PPS, Bit 7 = -. CCP3PPS, Bit 6 = -. CCP3PPS, Bit 5 = -. CCP3PPS, Bit 4 = . CCP3PPS, Bit 3 = . CCP3PPS, Bit 2 Bit = CCP3PPS<4:0>. CCP3PPS, Bit 0 = . CCP3PPS, Register on page =",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\n265. CCP4PPS, Bit 7 = -. CCP4PPS, Bit 6 = -. CCP4PPS, Bit 5 = -. CCP4PPS, Bit 4 = . CCP4PPS, Bit 3 = . CCP4PPS, Bit 2 Bit = CCP4PPS<4:0>. CCP4PPS, Bit 0 = . CCP4PPS, Register on page = 265. SMT1WINPPS, Bit 7 = -. SMT1WINPPS, Bit 6 = -. SMT1WINPPS, Bit 5 = -. SMT1WINPPS, Bit 4 = . SMT1WINPPS, Bit 3 = . SMT1WINPPS, Bit 2 Bit = SMT1WINPPS<4:0>. SMT1WINPPS, Bit 0 = . SMT1WINPPS, Register on page = 265. SMT1SIGPPS, Bit 7 = -. SMT1SIGPPS, Bit 6 = -. SMT1SIGPPS, Bit 5 = -. SMT1SIGPPS, Bit 4 = . SMT1SIGPPS, Bit 3 =",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\n. SMT1SIGPPS, Bit 2 Bit = SMT1SIGPPS<4:0>. SMT1SIGPPS, Bit 0 = . SMT1SIGPPS, Register on page = 265. SMT2WINPPS, Bit 7 = -. SMT2WINPPS, Bit 6 = -. SMT2WINPPS, Bit 5 = -. SMT2WINPPS, Bit 4 = . SMT2WINPPS, Bit 3 = . SMT2WINPPS, Bit 2 Bit = SMT2WINPPS<4:0>. SMT2WINPPS, Bit 0 = . SMT2WINPPS, Register on page = 265. SMT2SIGPPS, Bit 7 = -. SMT2SIGPPS, Bit 6 = -. SMT2SIGPPS, Bit 5 = -. SMT2SIGPPS, Bit 4 = . SMT2SIGPPS, Bit 3 = . SMT2SIGPPS, Bit 2 Bit = SMT2SIGPPS<4:0>. SMT2SIGPPS, Bit 0 = .",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\nSMT2SIGPPS, Register on page = 265. CWG1PPS, Bit 7 = -. CWG1PPS, Bit 6 = -. CWG1PPS, Bit 5 = -. CWG1PPS, Bit 4 = . CWG1PPS, Bit 3 = . CWG1PPS, Bit 2 Bit = CWG1PPS<4:0>. CWG1PPS, Bit 0 = . CWG1PPS, Register on page = 265. CWG2PPS, Bit 7 = -. CWG2PPS, Bit 6 = -. CWG2PPS, Bit 5 = -. CWG2PPS, Bit 4 = . CWG2PPS, Bit 3 = . CWG2PPS, Bit 2 Bit = CWG2PPS<4:0>. CWG2PPS, Bit 0 = . CWG2PPS, Register on page = 265. CWG3PPS, Bit 7 = -. CWG3PPS, Bit 6 = -. CWG3PPS, Bit 5 = -. CWG3PPS, Bit 4 = . CWG3PPS, Bit 3 = . CWG3PPS, Bit 2",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\nBit = CWG3PPS<4:0>. CWG3PPS, Bit 0 = . CWG3PPS, Register on page = 265. MD1CARLPPS, Bit 7 = -. MD1CARLPPS, Bit 6 = -. MD1CARLPPS, Bit 5 = -. MD1CARLPPS, Bit 4 = . MD1CARLPPS, Bit 3 = . MD1CARLPPS, Bit 2 Bit = MDCARLPPS<4:0>. MD1CARLPPS, Bit 0 = . MD1CARLPPS, Register on page = 265. MD1CARHPPS, Bit 7 = -. MD1CARHPPS, Bit 6 = -. MD1CARHPPS, Bit 5 = -. MD1CARHPPS, Bit 4 = . MD1CARHPPS, Bit 3 = . MD1CARHPPS, Bit 2 Bit = MDCARHPPS<4:0>. MD1CARHPPS, Bit 0 = . MD1CARHPPS, Register on page = 265. MD1SRCPPS, Bit 7 = -. MD1SRCPPS, Bit 6 =",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\n-. MD1SRCPPS, Bit 5 = -. MD1SRCPPS, Bit 4 = . MD1SRCPPS, Bit 3 = . MD1SRCPPS, Bit 2 Bit = MDSRCPPS<4:0>. MD1SRCPPS, Bit 0 = . MD1SRCPPS, Register on page = 265. CLCIN0PPS, Bit 7 = -. CLCIN0PPS, Bit 6 = -. CLCIN0PPS, Bit 5 = -. CLCIN0PPS, Bit 4 = . CLCIN0PPS, Bit 3 = . CLCIN0PPS, Bit 2 Bit = CLCIN0PPS<4:0>. CLCIN0PPS, Bit 0 = . CLCIN0PPS, Register on page = 265. CLCIN1PPS, Bit 7 = -. CLCIN1PPS, Bit 6 = -. CLCIN1PPS, Bit 5 = -. CLCIN1PPS, Bit 4 = . CLCIN1PPS, Bit 3 = . CLCIN1PPS, Bit 2 Bit = CLCIN1PPS<4:0>. CLCIN1PPS, Bit 0 = .",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\nCLCIN1PPS, Register on page = 265. CLCIN2PPS, Bit 7 = -. CLCIN2PPS, Bit 6 = -. CLCIN2PPS, Bit 5 = -. CLCIN2PPS, Bit 4 = . CLCIN2PPS, Bit 3 = . CLCIN2PPS, Bit 2 Bit = CLCIN2PPS<4:0>. CLCIN2PPS, Bit 0 = . CLCIN2PPS, Register on page = 265. CLCIN3PPS, Bit 7 = -. CLCIN3PPS, Bit 6 = -. CLCIN3PPS, Bit 5 = -. CLCIN3PPS, Bit 4 = . CLCIN3PPS, Bit 3 = . CLCIN3PPS, Bit 2 Bit = CLCIN3PPS<4:0>. CLCIN3PPS, Bit 0 = . CLCIN3PPS, Register on page = 265. ADACTPPS, Bit 7 = -. ADACTPPS, Bit 6 = -. ADACTPPS, Bit 5 = -. ADACTPPS, Bit 4 = . ADACTPPS, Bit 3 = . ADACTPPS, Bit 2 Bit =",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\nADACTPPS<4:0>. ADACTPPS, Bit 0 = . ADACTPPS, Register on page = 265. SPI1SCKPPS, Bit 7 = -. SPI1SCKPPS, Bit 6 = -. SPI1SCKPPS, Bit 5 = -. SPI1SCKPPS, Bit 4 = . SPI1SCKPPS, Bit 3 = . SPI1SCKPPS, Bit 2 Bit = SPI1SCKPPS<4:0>. SPI1SCKPPS, Bit 0 = . SPI1SCKPPS, Register on page = 265. SPI1SDIPPS, Bit 7 = -. SPI1SDIPPS, Bit 6 = -. SPI1SDIPPS, Bit 5 = -. SPI1SDIPPS, Bit 4 = . SPI1SDIPPS, Bit 3 = . SPI1SDIPPS, Bit 2 Bit = SPI1SDIPPS<4:0>. SPI1SDIPPS, Bit 0 = . SPI1SDIPPS, Register on page = 265.",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\nSPI1SSPPS, Bit 7 = -. SPI1SSPPS, Bit 6 = -. SPI1SSPPS, Bit 5 = -. SPI1SSPPS, Bit 4 = . SPI1SSPPS, Bit 3 = . SPI1SSPPS, Bit 2 Bit = SPI1SSPPS<4:0>. SPI1SSPPS, Bit 0 = . SPI1SSPPS, Register on page = 265. I2C1SCLPPS, Bit 7 = -. I2C1SCLPPS, Bit 6 = -. I2C1SCLPPS, Bit 5 = -. I2C1SCLPPS, Bit 4 = . I2C1SCLPPS, Bit 3 = . I2C1SCLPPS, Bit 2 Bit = I2C1SCLPPS<4:0>. I2C1SCLPPS, Bit 0 = . I2C1SCLPPS, Register on page = 265. I2C1SDAPPS, Bit 7 = -. I2C1SDAPPS, Bit 6 = -.",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\nI2C1SDAPPS, Bit 5 = -. I2C1SDAPPS, Bit 4 = . I2C1SDAPPS, Bit 3 = . I2C1SDAPPS, Bit 2 Bit = I2C1SDAPPS<4:0>. I2C1SDAPPS, Bit 0 = . I2C1SDAPPS, Register on page = 265. I2C2SCLPPS, Bit 7 = -. I2C2SCLPPS, Bit 6 = -. I2C2SCLPPS, Bit 5 = -. I2C2SCLPPS, Bit 4 = . I2C2SCLPPS, Bit 3 = . I2C2SCLPPS, Bit 2 Bit = I2C2SCLPPS<4:0>. I2C2SCLPPS, Bit 0 = . I2C2SCLPPS, Register on page = 265. I2C2SDAPPS, Bit 7 = -. I2C2SDAPPS, Bit 6 = -. I2C2SDAPPS, Bit 5 = -.",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\nI2C2SDAPPS, Bit 4 = . I2C2SDAPPS, Bit 3 = . I2C2SDAPPS, Bit 2 Bit = I2C2SDAPPS<4:0>. I2C2SDAPPS, Bit 0 = . I2C2SDAPPS, Register on page = 265. U1RXPPS, Bit 7 = -. U1RXPPS, Bit 6 = -. U1RXPPS, Bit 5 = -. U1RXPPS, Bit 4 = . U1RXPPS, Bit 3 = . U1RXPPS, Bit 2 Bit = U1RXPPS<4:0>. U1RXPPS, Bit 0 = . U1RXPPS, Register on page = 265. U1CTSPPS, Bit 7 = -. U1CTSPPS, Bit 6 = -. U1CTSPPS, Bit 5 = -. U1CTSPPS, Bit 4 = . U1CTSPPS, Bit 3 = . U1CTSPPS, Bit 2 Bit = U1CTSPPS<4:0>.",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\nU1CTSPPS, Bit 0 = . U1CTSPPS, Register on page = 265. U2RXPPS, Bit 7 = -. U2RXPPS, Bit 6 = -. U2RXPPS, Bit 5 = -. U2RXPPS, Bit 4 = . U2RXPPS, Bit 3 = . U2RXPPS, Bit 2 Bit = U2RXPPS<4:0>. U2RXPPS, Bit 0 = . U2RXPPS, Register on page = 265. U2CTSPPS, Bit 7 = -. U2CTSPPS, Bit 6 = -. U2CTSPPS, Bit 5 = -. U2CTSPPS, Bit 4 = . U2CTSPPS, Bit 3 = . U2CTSPPS, Bit 2 Bit = U2CTPPS<4:0>. U2CTSPPS, Bit 0 = . U2CTSPPS, Register on page = 265. RxyPPS, Bit 7 = - -. RxyPPS, Bit 6 = - -. RxyPPS, Bit 5 = - -. RxyPPS, Bit 4 = . RxyPPS, Bit 3 = . RxyPPS, Bit 2 Bit =",
    "TABLE 17-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE PPS MODULE\nRxyPPS<4:0>. RxyPPS, Bit 0 = . RxyPPS, Register on page = 265. CANRXPPS, Bit 7 = . CANRXPPS, Bit 6 = . CANRXPPS, Bit 5 = . CANRXPPS, Bit 4 = . CANRXPPS, Bit 3 = . CANRXPPS, Bit 2 Bit = CANRXPPS<4:0>. CANRXPPS, Bit 0 = . CANRXPPS, Register on page = 265\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are unused by the PPS module.",
    "18.0 INTERRUPT-ON-CHANGE\nPORTA, PORTB, PORTC and pin RE3 of PORTE can be configured to operate as Interrupt-on-Change (IOC) pins on PIC18(L)F25/26K83 family devices. An interrupt can be generated by detecting a signal that has either a rising edge or a falling edge. Any individual port pin, or combination of port pins, can be configured to generate an  interrupt.  The  interrupt-on-change  module  has  the following features:\n\u00b7 Interrupt-on-Change enable (Master Switch)\n\u00b7 Individual pin configuration\n\u00b7 Rising and falling edge detection\n\u00b7 Individual pin interrupt flags\nFigure 18-1 is a block diagram of the IOC module.",
    "18.1 Enabling the Module\nTo allow individual port pins to generate an interrupt, the IOCIE bit of the PIE0 register must be set. If the IOCIE bit  is  disabled,  the  edge  detection  on  the  pin  will  still occur, but an interrupt will not be generated.",
    "18.2 Individual Pin Configuration\nFor each port pin, a rising edge detector and a falling edge detector are present. To enable a pin to detect a rising edge, the associated bit of the IOCxP register is set.  T o enable  a  pin  to  detect  a  falling  edge,  the associated bit of the IOCxN register is set.\nA  pin  can  be  configured  to  detect  rising  and  falling edges simultaneously by setting both associated bits of the IOCxP and IOCxN registers, respectively.",
    "18.3 Interrupt Flags\nThe IOCAFx, IOCBFx, IOCCFx and IOCEF3 bits located in  the  IOCAF,  IOCBF,  IOCCF  and  IOCEF  registers respectively,  are  status  flags  that  correspond  to  the interrupt-on-change  pins  of  the  associated  port.  If  an expected edge is detected on an appropriately enabled pin, then the status flag for that pin will be set, and an interrupt  will  be  generated  if  the  IOCIE  bit  is  set. The IOCIF bit of the PIR0 register reflects the status of all IOCAFx, IOCBFx, IOCCFx and IOCEF3 bits.",
    "18.4 Clearing Interrupt Flags\nThe individual status flags, (IOCAFx, IOCBFx, IOCCFx and IOCEF3 bits), can be cleared by resetting them to zero.  If  another  edge  is  detected  during  this  clearing operation, the associated status flag will be set at the end of the sequence, regardless of the value actually being written.\nIn  order to ensure that no detected edge is lost while clearing flags, only AND operations masking out known changed  bits should be performed.  The following sequence is an example of what should be performed.",
    "EXAMPLE 18-1:\nCLEARING INTERRUPT FLAGS (PORTA EXAMPLE)\nMOVLW\n0xff\nXORWF\nIOCAF, W\nANDWF\nIOCAF, F",
    "18.5 Operation in Sleep\nThe  interrupt-on-change  interrupt  sequence  will  wake the device from Sleep mode, if the IOCIE bit is set.\nIf an edge is detected while in Sleep mode, the IOCxF register  will  be  updated  prior  to  the  first  instruction executed out of Sleep.",
    "REGISTER 18-1: IOCxP: INTERRUPT-ON-CHANGE POSITIVE EDGE REGISTER EXAMPLE\nIOCxP7, R/W-0/0 = IOCxP6. IOCxP7, R/W-0/0 = IOCxP5. IOCxP7, R/W-0/0 = IOCxP4. IOCxP7, R/W-0/0 = IOCxP3. IOCxP7, R/W-0/0 = IOCxP2. IOCxP7, R/W-0/0 = IOCxP1. IOCxP7, R/W-0/0 = IOCxP0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit",
    "REGISTER 18-1: IOCxP: INTERRUPT-ON-CHANGE POSITIVE EDGE REGISTER EXAMPLE\n0, R/W-0/0 = bit 7 bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7-0\nIOCxP<7:0>: Interrupt-on-Change Positive Edge Enable bits\n1 = Interrupt-on-Change enabled on the IOCx pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.\n0 = Interrupt-on-Change disabled for the associated pin.",
    "REGISTER 18-2: IOCxN: INTERRUPT-ON-CHANGE NEGATIVE EDGE REGISTER EXAMPLE\nIOCxN7, R/W-0/0 = IOCxN6. IOCxN7, R/W-0/0 = IOCxN5. IOCxN7, R/W-0/0 = IOCxN4. IOCxN7, R/W-0/0 = IOCxN3. IOCxN7, R/W-0/0 = IOCxN2. IOCxN7, R/W-0/0 = IOCxN1. IOCxN7, R/W-0/0 = IOCxN0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit",
    "REGISTER 18-2: IOCxN: INTERRUPT-ON-CHANGE NEGATIVE EDGE REGISTER EXAMPLE\n0, R/W-0/0 = bit 7 bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-0\nIOCxN<7:0>: Interrupt-on-Change Negative Edge Enable bits\n1 = Interrupt-on-Change enabled on the IOCx pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.\n0 = Interrupt-on-Change disabled for the associated pin",
    "REGISTER 18-3: IOCxF: INTERRUPT-ON-CHANGE FLAG REGISTER EXAMPLE\nR/W/HS-0/0, 1 = R/W/HS-0/0. R/W/HS-0/0, 2 = R/W/HS-0/0. R/W/HS-0/0, 3 = R/W/HS-0/0. R/W/HS-0/0, 4 = R/W/HS-0/0. R/W/HS-0/0, 5 = R/W/HS-0/0. R/W/HS-0/0, 6 = R/W/HS-0/0. R/W/HS-0/0, 7 = R/W/HS-0/0. IOCxF7, 1 = IOCxF6. IOCxF7, 2 = IOCxF5. IOCxF7, 3 = IOCxF4. IOCxF7, 4 = IOCxF3. IOCxF7, 5 = IOCxF2. IOCxF7, 6 = IOCxF1. IOCxF7, 7 = IOCxF0. bit",
    "REGISTER 18-3: IOCxF: INTERRUPT-ON-CHANGE FLAG REGISTER EXAMPLE\n7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nR = Readable bit u = Bit is unchanged,  = W=Writable x = Bit is unknown. R = Readable bit u = Bit is unchanged,  = U = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HS - Bit is set in hardware\nbit 7-0\nIOCxF<7:0>: Interrupt-on-Change Flag bits",
    "REGISTER 18-3: IOCxF: INTERRUPT-ON-CHANGE FLAG REGISTER EXAMPLE\n1 = A enabled change was detected on the associated pin. Set when IOCP[n] = 1 and a positive edge was detected on the IOCn pin, or when IOCN[n] = 1 and a negative edge was detected on the IOCn pin\n0 = No change was detected, or the user cleared the detected change",
    "TABLE 18-1: IOC REGISTERS\nIOCAP, Bit 7 = IOCAP7. IOCAP, Bit 6 = IOCAP6. IOCAP, Bit 5 = IOCAP5. IOCAP, Bit 4 = IOCAP4. IOCAP, Bit 3 = IOCAP3. IOCAP, Bit 2 = IOCAP2. IOCAP, Bit 1 = IOCAP1. IOCAP, Bit 0 = IOCAP0. IOCAN, Bit 7 = IOCAN7. IOCAN, Bit 6 = IOCAN6. IOCAN, Bit 5 = IOCAN5. IOCAN, Bit 4 = IOCAN4. IOCAN, Bit 3 = IOCAN3. IOCAN, Bit 2 = IOCAN2. IOCAN, Bit 1 = IOCAN1. IOCAN, Bit 0 = IOCAN0. IOCAF, Bit 7 = IOCAF7. IOCAF, Bit 6 = IOCAF6. IOCAF, Bit 5 = IOCAF5. IOCAF, Bit 4 = IOCAF4. IOCAF, Bit 3 = IOCAF3. IOCAF, Bit 2 = IOCAF2. IOCAF, Bit 1 = IOCAF1. IOCAF, Bit 0 = IOCAF0. IOCBP, Bit 7 =",
    "TABLE 18-1: IOC REGISTERS\nIOCBP7. IOCBP, Bit 6 = IOCBP6. IOCBP, Bit 5 = IOCBP5. IOCBP, Bit 4 = IOCBP4. IOCBP, Bit 3 = IOCBP3. IOCBP, Bit 2 = IOCBP2. IOCBP, Bit 1 = IOCBP1. IOCBP, Bit 0 = IOCBP0. IOCBN, Bit 7 = IOCBN7. IOCBN, Bit 6 = IOCBN6. IOCBN, Bit 5 = IOCBN5. IOCBN, Bit 4 = IOCBN4. IOCBN, Bit 3 = IOCBN3. IOCBN, Bit 2 = IOCBN2. IOCBN, Bit 1 = IOCBN1. IOCBN, Bit 0 = IOCBN0. IOCBF, Bit 7 = IOCBF7. IOCBF, Bit 6 = IOCBF6. IOCBF, Bit 5 = IOCBF5. IOCBF, Bit 4 = IOCBF4. IOCBF, Bit 3 = IOCBF3. IOCBF, Bit 2 = IOCBF2. IOCBF, Bit 1 = IOCBF1. IOCBF, Bit 0 = IOCBF0.",
    "TABLE 18-1: IOC REGISTERS\nIOCCP, Bit 7 = IOCCP7. IOCCP, Bit 6 = IOCCP6. IOCCP, Bit 5 = IOCCP5. IOCCP, Bit 4 = IOCCP4. IOCCP, Bit 3 = IOCCP3. IOCCP, Bit 2 = IOCCP2. IOCCP, Bit 1 = IOCCP1. IOCCP, Bit 0 = IOCCP0. IOCCN, Bit 7 = IOCCN7. IOCCN, Bit 6 = IOCCN6. IOCCN, Bit 5 = IOCCN5. IOCCN, Bit 4 = IOCCN4. IOCCN, Bit 3 = IOCCN3. IOCCN, Bit 2 = IOCCN2. IOCCN, Bit 1 = IOCCN1. IOCCN, Bit 0 = IOCCN0. IOCCF, Bit 7 = IOCCF7. IOCCF, Bit 6 = IOCCF6. IOCCF, Bit 5 = IOCCF5. IOCCF, Bit 4 = IOCCF4. IOCCF, Bit 3 = IOCCF3. IOCCF, Bit 2 = IOCCF2.",
    "TABLE 18-1: IOC REGISTERS\nIOCCF, Bit 1 = IOCCF1. IOCCF, Bit 0 = IOCCF0. IOCEP, Bit 7 = -. IOCEP, Bit 6 = -. IOCEP, Bit 5 = -. IOCEP, Bit 4 = -. IOCEP, Bit 3 = IOCEP3 (1). IOCEP, Bit 2 = -. IOCEP, Bit 1 = -. IOCEP, Bit 0 = -. IOCEN, Bit 7 = -. IOCEN, Bit 6 = -. IOCEN, Bit 5 = -. IOCEN, Bit 4 = -. IOCEN, Bit 3 = IOCEN3 (1). IOCEN, Bit 2 = -. IOCEN, Bit 1 = -. IOCEN, Bit 0 = -. IOCEF, Bit 7 = -. IOCEF, Bit 6 = -. IOCEF, Bit 5 = -. IOCEF, Bit 4 = -. IOCEF, Bit 3 = IOCEF3 (1). IOCEF, Bit 2 = -. IOCEF, Bit 1 = -. IOCEF, Bit 0 = -",
    "TABLE 18-1: IOC REGISTERS\nNote1: If MCLRE = 1 or LVP = 1, RE3 port functionality is disabled and IOC on RE3 is not available.",
    "TABLE 18-2: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPT-ON-CHANGE\nIOCxF, Bit 7 = IOCxF7. IOCxF, Bit 6 = IOCxF6. IOCxF, Bit 5 = IOCxF5. IOCxF, Bit 4 = IOCxF4. IOCxF, Bit 3 = IOCxF3. IOCxF, Bit 2 = IOCxF2. IOCxF, Bit 1 = IOCxF1. IOCxF, Bit 0 = IOCxF0. IOCxF, Register on Page = 273. IOCxN, Bit 7 = IOCxN7. IOCxN, Bit 6 = IOCxN6. IOCxN, Bit 5 = IOCxN5. IOCxN, Bit 4 = IOCxN4. IOCxN, Bit 3 = IOCxN3. IOCxN, Bit 2 = IOCxN2. IOCxN, Bit 1 = IOCxN1. IOCxN, Bit 0 = IOCxN0. IOCxN, Register on Page = 273. IOCxP, Bit 7 = IOCxP7. IOCxP, Bit 6 = IOCxP6. IOCxP, Bit",
    "TABLE 18-2: SUMMARY OF REGISTERS ASSOCIATED WITH INTERRUPT-ON-CHANGE\n5 = IOCxP5. IOCxP, Bit 4 = IOCxP4. IOCxP, Bit 3 = IOCxP3. IOCxP, Bit 2 = IOCxP2. IOCxP, Bit 1 = IOCxP1. IOCxP, Bit 0 = IOCxP0. IOCxP, Register on Page = 273\nLegend: - = unimplemented location, read as ' 0 '. Shaded cells are not used by interrupt-on-change.",
    "19.0 PERIPHERAL MODULE DISABLE (PMD)\nSleep, Idle and Doze modes allow users to substantially reduce power consumption by slowing or stopping the CPU clock. Even so, peripheral modules still remain clocked, and thus, consume some amount of  power. There may be cases where the application needs what these modes do not provide: the ability to allocate  limited  power  resources  to  the  CPU  while eliminating power consumption from the peripherals.\nThe PIC18(L)F25/26K83 family addresses this requirement  by  allowing  peripheral  modules  to  be selectively enabled or disabled, placing them into the lowest possible power mode.\nAll modules are ON by default following any Reset.",
    "19.1 Disabling a Module\nDisabling a module has the following effects:\n\u00b7 All clock and control inputs to the module are suspended; there are no logic transitions, and the module will not function.\n\u00b7 The module is held in Reset.\n\u00b7 Any SFR becomes 'unimplemented'\n-Writing is disabled\n-Reading returns 00h\n\u00b7 I/O functionality is prioritized as per Section 16.2, I/O Priorities\n\u00b7 All associated Input Selection registers are also disabled",
    "19.2 Enabling a Module\nWhen the PMD register bit is cleared, the module is re enabled  and  will  be  in  its  Reset  state  (Power-on -Reset). SFR data will reflect the POR Reset values.\nDepending on the module, it may take up to one full instruction  cycle  for  the  module  to  become  active. There  should  be no interaction with the module (e.g., writing  to  registers)  for  at  least  one  instruction after it has been re-enabled.",
    "19.3 Effects of a Reset\nFollowing  any  Reset,  each  control  bit  is  set  to  ' 0 ', enabling all modules.",
    "19.4 System Clock Disable\nSetting SYSCMD (PMD0, Register 19-1) disables the system clock (FOSC) distribution network to the peripherals. Not all peripherals make use of SYSCLK, so not all peripherals are affected. Refer to the specific peripheral description to see if it will be affected by this bit.",
    "REGISTER 19-1: PMD0: PMD CONTROL REGISTER 0\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. SYSCMD, 1 = FVRMD. SYSCMD, 2 = HLVDMD. SYSCMD, 3 = CRCMD. SYSCMD, 4 = SCANMD. SYSCMD, 5 = NVMMD. SYSCMD, 6 = CLKRMD. SYSCMD, 7 = IOCMD. 7, 1 = 7. 7, 2 = 7. 7, 3 = 7. 7, 4 = 7. 7, 5 = 7. 7, 6 = 7. 7, 7 = 0",
    "REGISTER 19-1: PMD0: PMD CONTROL REGISTER 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = q = Value depends on condition\nbit 7 SYSCMD: Disable Peripheral System Clock Network bit (1)\nSee description in Section 19.4 'System Clock Disable' .\n1 = System clock network disabled (FOSC)\n0 = System clock network enabled",
    "bit 6 FVRMD: Disable Fixed Voltage Reference bit\n1 = FVR module disabled\n0 = FVR module enabled\nbit 5\nHLVDMD: Disable Low-Voltage Detect bit\n1 = HLVD module disabled\n0 = HLVD module enabled\nbit 4\nCRCMD: Disable CRC Engine bit\n1 = CRC module disabled\n0 = CRC module enabled",
    "bit 3\nSCANMD: Disable NVM Memory Scanner bit (2)\n1 = NVM Memory Scan module disabled\n0 = NVM Memory Scan module enabled",
    "bit 2\nNVMMD: NVM Module Disable bit (3)\n1 = All Memory reading and writing is disabled; NVMCON registers cannot be written\n0 = NVM module enabled",
    "bit 1\nCLKRMD: Disable Clock Reference bit\n1 = CLKR module disabled\n0 = CLKR module enabled\nbit 0\nIOCMD: Disable Interrupt-on-Change bit, All Ports\n1 = IOC module(s) disabled\n0 = IOC module(s) enabled\nNote 1: Clearing the SYSCMD bit disables the system clock (FOSC) to peripherals, however peripherals clocked by FOSC/4 are not affected.\n2: Subject to SCANE bit in CONFIG4H.\n3: When enabling NVM, a delay of up to 1 \u00b5s may be required before accessing data.",
    "REGISTER 19-2: PMD1: PMD CONTROL REGISTER 1\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. NCO1MD, 1 = TMR6MD. NCO1MD, 2 = TMR5MD. NCO1MD, 3 = TMR4MD. NCO1MD, 4 = TMR3MD. NCO1MD, 5 = TMR2MD. NCO1MD, 6 = TMR1MD. NCO1MD, 7 = TMR0MD. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit",
    "REGISTER 19-2: PMD1: PMD CONTROL REGISTER 1\n7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = q = Value depends on condition",
    "REGISTER 19-2: PMD1: PMD CONTROL REGISTER 1\nbit 7, 1 = NCO1MD: Disable NCO1 Module bit 1 = NCO1 module disabled 0 = NCO1 module enabled. bit 6, 1 = TMR6MD: Disable Timer TMR6 bit. bit 5, 1 = TMR5MD: Disable Timer TMR5 bit 1 = TMR5 module disabled 0 = TMR5 module enabled. bit 4, 1 = TMR4MD: Disable Timer TMR4 bit 1 = TMR4 module disabled 0 = TMR4 module enabled. bit 3, 1 = TMR3MD: Disable Timer TMR3 bit 1 = TMR3 module disabled. bit 2, 1 = 0 = TMR3 module enabled TMR2MD: Disable Timer TMR2. 1, 1 = bit 1 = TMR2 module disabled 0 = TMR2 module enabled. bit, 1 = TMR1MD: Disable Timer TMR1 bit 1 = TMR1 module disabled 0 = TMR1 module enabled. bit 0, 1 =",
    "REGISTER 19-2: PMD1: PMD CONTROL REGISTER 1\nTMR0MD: Disable Timer TMR0 bit 1 = TMR0 module disabled 0 = TMR0 module enabled",
    "REGISTER 19-3: PMD2: PMD CONTROL REGISTER 2\nU-0, 1 = R/W-0/0. U-0, 2 = R/W-0/0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = DACMD. -, 2 = ADCMD. -, 3 = -. -, 4 = -. -, 5 = CMP2MD. -, 6 = CMP1MD. -, 7 = ZCDMD (1). bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 19-3: PMD2: PMD CONTROL REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = q = Value depends on condition\nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nDACMD:\nDisable DAC bit\n1 = DAC module disabled\n0 = DAC module enabled\nbit 5\nADCMD: Disable ADCC bit\n1 = ADCC module disabled\n0 = ADCC module enabled\nbit 4-3\nUnimplemented: Read as ' 0 '\nbit 2\nCMP2MD: Disable Comparator CMP2 bit\n1 = CMP2 module disabled\n0 = CMP2 module enabled\nbit 1",
    "REGISTER 19-3: PMD2: PMD CONTROL REGISTER 2\nCMP1MD: Disable Comparator CMP1 bit\n1 = CMP1 module disabled\n0 = CMP1 module enabled\nbit 0\nZCDMD: Disable Zero-Cross Detect module bit (1)\n1 = ZCD module disabled\n0 = ZCD module enabled\nNote 1: Subject to ZCD bit in CONFIG2H.",
    "REGISTER 19-4: PMD3: PMD CONTROL REGISTER 3\nPWM8MD, R/W-0/0 = PWM7MD. PWM8MD, R/W-0/0 = PWM6MD. PWM8MD, R/W-0/0 = PWM5MD. PWM8MD, R/W-0/0 = CCP4MD. PWM8MD, R/W-0/0 = CCP3MD. PWM8MD, R/W-0/0 = CCP2MD. PWM8MD, R/W-0/0 = CCP1MD. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit",
    "REGISTER 19-4: PMD3: PMD CONTROL REGISTER 3\n0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = q = Value depends on condition",
    "REGISTER 19-4: PMD3: PMD CONTROL REGISTER 3\nbit 7, 1 = PWM8MD: Disable Pulse-Width Modulator PWM8 bit 1 = PWM8 module disabled 0 = PWM8 module enabled. bit 6, 1 = PWM7MD: Disable Pulse-Width Modulator PWM7 bit 1 = PWM7 module disabled 0 = PWM7 module enabled. bit 5, 1 = PWM6MD: Disable Pulse-Width Modulator PWM6 bit 1 = PWM6 module disabled 0 = PWM6 module enabled. bit 4, 1 = PWM5MD: Disable Pulse-Width Modulator PWM5 bit 1 = PWM5 module disabled 0 = PWM5 module enabled. bit 3, 1 = CCP4MD: Disable Capture/Compare/PWM CCP4 bit 1 = CCP4 module disabled 0 = CCP4 module enabled. bit 2, 1 = CCP3MD: Disable Capture/Compare/PWM CCP3 bit 1 = CCP3 module disabled 0 = CCP3 module enabled. bit 1, 1 =",
    "REGISTER 19-4: PMD3: PMD CONTROL REGISTER 3\nCCP2MD: Disable Capture/Compare/PWM CCP2 bit 1 = CCP2 module disabled 0 = CCP2 module enabled. bit 0, 1 = CCP1MD: Disable Capture/Compare/PWM CCP1 bit 1 = CCP1 module disabled 0 = CCP1 module enabled",
    "REGISTER 19-5: PMD4: PMD CONTROL REGISTER 4\nCWG3MD, R/W-0/0 = CWG2MD. CWG3MD, R/W-0/0 = CWG1MD. CWG3MD, U-0 = -. CWG3MD, U-0 = -. CWG3MD, U-0 = -. CWG3MD, U-0 = -. CWG3MD, U-0 = -. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition\nbit 7\nCWG3MD:\nDisable CWG3 Module bit\n1 = CWG3 module disabled\n0 =  CWG3 module enabled\nbit 6\nCWG2MD: Disable CWG2 Module bit\n1 = CWG2 module disabled\n0 =   CWG2 module enabled\nbit 5\nCWG1MD: Disable CWG1 Module bit\n1 = CWG1 module disabled\n0 =   CWG1 module enabled\nbit 4-0\nUnimplemented: Read as ' 0 '",
    "REGISTER 19-6: PMD5: PMD CONTROL REGISTER 5\nU-0, 1 = U-0. U-0, 2 = R/W-0/0. U-0, 3 = R/W-0/0. U-0, 4 = U-0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = U2MD. -, 3 = U1MD. -, 4 = -. -, 5 = SPI1MD. -, 6 = I2C2MD. -, 7 = I2C1MD. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition\nbit 7-6\nUnimplemented: Read as ' 0 '\nbit 5\nU2MD: Disable UART2 bit\n1 = UART2 module disabled\n0 = UART2 module enabled\nbit 4\nU1MD: Disable UART1 bit\n1 = UART1 module disabled\n0 = UART1 module enabled\nbit 3\nUnimplemented: Read as ' 0 '\nbit 2\nSPI1MD: Disable SPI1 Module bit\n1 = SPI1 module disabled\n0 = SPI1 module enabled\nbit 1\nI2C2MD: Disable I 2 C2 Module bit\n1 = I 2 C2 module disabled\n0 = I 2 C2 module enabled\nbit 0\nI2C1MD: Disable I 2 C1 Module bit\n1 = I 2 C1 module disabled\n0 = I 2 C1 module enabled",
    "REGISTER 19-7: PMD6: PMD CONTROL REGISTER 6\nU-0, 1 = R/W-0/0. U-0, 2 = R/W-0/0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = SMT2MD. -, 2 = SMT1MD. -, 3 = CLC4MD. -, 4 = CLC3MD. -, 5 = CLC2MD. -, 6 = CLC1MD. -, 7 = DSMMD. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit",
    "REGISTER 19-7: PMD6: PMD CONTROL REGISTER 6\n0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = q = Value depends on condition\nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nSMT2MD: Disable SMT2 Module bit\n1 = SMT2 module disabled\n0 = SMT2 module enabled\nbit 5\nSMT1MD: Disable SMT1 Module bit\n1 = SMT1 module disabled\n0 = SMT1 module enabled\nbit 4\nCLC1MD: Disable CLC4 Module bit\n1 = CLC4 module disabled\n0 = CLC4 module enabled\nbit 3\nCLC3MD: Disable CLC3 Module bit",
    "REGISTER 19-7: PMD6: PMD CONTROL REGISTER 6\n1 = CLC3 module disabled\n0 = CLC3 module enabled",
    "bit 2 CLC2MD: Disable CLC2 Module bit\n1 = CLC2 module disabled\n0 = CLC2 module enabled\nbit 1\nCLC1MD: Disable CLC1 Module bit\n1 = CLC1 module disabled\n0 = CLC1 module enabled\nbit 0\nDSMMD: Disable Data Signal Modulator bit\n1 = DSM module disabled\n0 = DSM module enabled",
    "REGISTER 19-8: PMD7: PMD CONTROL REGISTER 7\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = U-0. R/W-0/0, 3 = U-0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = U-0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. CANMD, 1 = -. CANMD, 2 = -. CANMD, 3 = -. CANMD, 4 = -. CANMD, 5 = -. CANMD, 6 = DMA2MD. CANMD, 7 = DMA1MD. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition\nbit 7\nCANMD: Disable CAN Module bit\n1 = CAN module disabled\n0 = CAN module enabled\nbit 6-2\nUnimplemented: Read as ' 0 '\nbit 1\nDMA2MD:\nDisable DMA2 Module bit\n1 = DMA2 module disabled\n0 = DMA2 module enabled\nbit 0\nDMA1MD:\nDisable DMA1 Module bit\n1 = DMA1 module disabled\n0 = DMA1 module enabled",
    "TABLE 19-1: SUMMARY OF REGISTERS ASSOCIATED WITH PERIPHERAL MODULE DISABLE\nPMD0, Bit 7 = SYSCMD. PMD0, Bit 6 = FVRMD. PMD0, Bit 5 = HLVDMD. PMD0, Bit 4 = CRCMD. PMD0, Bit 3 = SCANMD. PMD0, Bit 2 = NVMMD. PMD0, Bit 1 = CLKRMD. PMD0, Bit 0 = IOCMD. PMD0, Register on Page = 276. PMD1, Bit 7 = NCO1MD. PMD1, Bit 6 = TMR6MD. PMD1, Bit 5 = TMR5MD. PMD1, Bit 4 = TMR4MD. PMD1, Bit 3 = TMR3MD. PMD1, Bit 2 = TMR2MD. PMD1, Bit 1 = TMR1MD. PMD1, Bit 0 = TMR0MD. PMD1, Register on Page = 277. PMD2, Bit 7 = -. PMD2, Bit 6 = DACMD. PMD2, Bit 5 = ADCMD.",
    "TABLE 19-1: SUMMARY OF REGISTERS ASSOCIATED WITH PERIPHERAL MODULE DISABLE\nPMD2, Bit 4 = -. PMD2, Bit 3 = -. PMD2, Bit 2 = CMP2MD. PMD2, Bit 1 = CMP1MD. PMD2, Bit 0 = ZCDMD. PMD2, Register on Page = 278. PMD3, Bit 7 = PWM8MD. PMD3, Bit 6 = PWM7MD. PMD3, Bit 5 = PWM6MD. PMD3, Bit 4 = PWM5MD. PMD3, Bit 3 = CCP4MD. PMD3, Bit 2 = CCP3MD. PMD3, Bit 1 = CCP2MD. PMD3, Bit 0 = CCP1MD. PMD3, Register on Page = 279. PMD4, Bit 7 = CWG3MD. PMD4, Bit 6 = CWG2MD. PMD4, Bit 5 = CWG1MD. PMD4, Bit 4 = -. PMD4, Bit 3 = -. PMD4, Bit 2 = -. PMD4, Bit 1",
    "TABLE 19-1: SUMMARY OF REGISTERS ASSOCIATED WITH PERIPHERAL MODULE DISABLE\n= -. PMD4, Bit 0 = -. PMD4, Register on Page = 280. PMD5, Bit 7 = -. PMD5, Bit 6 = -. PMD5, Bit 5 = U2MD. PMD5, Bit 4 = U1MD. PMD5, Bit 3 = -. PMD5, Bit 2 = SPI1MD. PMD5, Bit 1 = I2C2MD. PMD5, Bit 0 = I2C1MD. PMD5, Register on Page = 281. PMD6, Bit 7 = -. PMD6, Bit 6 = SMT2MD. PMD6, Bit 5 = SMT1MD. PMD6, Bit 4 = CLC4MD. PMD6, Bit 3 = CLC3MD. PMD6, Bit 2 = CLC2MD. PMD6, Bit 1 = CLC1MD. PMD6, Bit 0 = DSMMD. PMD6, Register on Page = 281. PMD7, Bit 7 = CANMD. PMD7, Bit 6 = -.",
    "TABLE 19-1: SUMMARY OF REGISTERS ASSOCIATED WITH PERIPHERAL MODULE DISABLE\nPMD7, Bit 5 = -. PMD7, Bit 4 = -. PMD7, Bit 3 = -. PMD7, Bit 2 = -. PMD7, Bit 1 = DMA2MD. PMD7, Bit 0 = DMA1MD. PMD7, Register on Page = 283\nLegend:\n- = unimplemented location, read as ' 0 '. Shaded cells are not used by peripheral module disable.",
    "20.0 TIMER0 MODULE\nTimer0  module  is  an  8/16-bit  timer/counter  with  the following features:\n\u00b7 16-bit timer/counter\n\u00b7 8-bit timer/counter with programmable period\n\u00b7 Synchronous or asynchronous operation\n\u00b7 Selectable clock sources\n\u00b7 Programmable prescaler\n\u00b7 Programmable postscaler\n\u00b7 Operation during Sleep mode\n\u00b7 Interrupt on match or overflow\n\u00b7 Output on I/O pin (via PPS) or to other peripherals\nFIGURE 20-1:\nBLOCK DIAGRAM OF TIMER0",
    "20.1 Timer0 Operation\nTimer0 can operate as either an 8-bit timer/counter or a 16-bit timer/counter. The mode is selected with the MD16 bit of the T0CON register.",
    "20.1.1 16-BIT MODE\nThe  register  pair  TMR0H:TMR0L  increments  on  the rising edge of the clock source. A 15-bit prescaler on the  clock  input  gives  several  prescale  options  (see prescaler  control  bits,  CKPS<3:0>  in  the  T0CON1 register).",
    "20.1.1.1 Timer0 Reads and Writes in 16-Bit Mode\nIn  16-bit  mode,  in  order  to  avoid  rollover  between reading high and low registers, the TMR0H register is a buffered copy of the actual high byte of Timer0, which is neither directly readable, nor writable (see Figure 201). TMR0H is updated with the contents of the high byte of Timer0 during a read of TMR0L. This provides the ability  to  read  all  16  bits  of Timer0  without  having  to verify that the read of the high and low byte was valid, due to a rollover between successive reads of the high and low byte.\nSimilarly, a write to the high byte of Timer0 must also take place through the TMR0H Buffer register. The high byte is updated with the contents of TMR0H when a write occurs to TMR0L. This allows all 16 bits of Timer0 to be updated at once.",
    "20.1.2 8-BIT MODE\nIn 8-bit mode, the value of TMR0L is compared to that of the Period buffer, a copy of TMR0H, on each clock cycle. When the two values match, the following events happen:\n\u00b7 TMR0_out goes high for one prescaled clock period\n\u00b7 TMR0L is reset\n\u00b7 The contents of TMR0H are copied to the period buffer\nIn  8-bit  mode,  the  TMR0L  and  TMR0H  registers  are both directly readable and writable. The  TMR0L register  is  cleared  on  any  device  Reset,  while  the TMR0H register initializes at FFh.\nBoth the prescaler and postscaler counters are cleared on the following events:\n\u00b7 A write to the TMR0L register\n\u00b7 A write to either the T0CON0 or T0CON1 registers\n\u00b7 Any device Reset - Power-on Reset (POR), MCLR Reset, Watchdog Timer Reset (WDTR) or\n\u00b7 Brown-out Reset (BOR)",
    "20.1.3 COUNTER MODE\nIn Counter mode, the prescaler is normally disabled by setting the CKPS bits of the T0CON1 register to ' 0000 '. Each rising edge of the clock input (or the output of the prescaler  if  the  prescaler  is  used)  increments  the counter by ' 1 '.",
    "20.1.4 TIMER MODE\nIn Timer mode, the Timer0 module will increment every instruction cycle as long as there is a valid clock signal and the CKPS bits of the T0CON1 register (Register 20-2) are set to ' 0000 '. When a prescaler is added, the timer will increment at the rate based on the prescaler value.",
    "20.1.5 ASYNCHRONOUS MODE\nWhen the ASYNC bit of the T0CON1 register is set (ASYNC = 1 ), the counter increments with each rising edge of the input source (or output of the prescaler, if used).  Asynchronous  mode  allows  the  counter  to continue  operation  during  Sleep  mode  provided  that the clock also continues to operate during Sleep.",
    "20.1.6 SYNCHRONOUS MODE\nWhen the ASYNC bit of the T0CON1 register is clear (ASYNC = 0 ), the counter clock is synchronized to the system clock (FOSC/4). When operating in Synchronous mode, the counter clock frequency cannot exceed FOSC/4.",
    "20.2 Clock Source Selection\nThe CS<2:0> bits of the T0CON1 register are used to select the  clock  source  for  Timer0.  Register 20-2 displays the clock source selections.",
    "20.2.1 INTERNAL CLOCK SOURCE\nWhen  the  internal  clock  source  is  selected,  Timer0 operates as a timer and will increment on multiples of the clock source, as determined by the Timer0 prescaler.",
    "20.2.2 EXTERNAL CLOCK SOURCE\nWhen an external clock source is selected, Timer0 can operate  as  either  a  timer  or  a  counter.  Timer0  will increment on multiples of the rising edge of the external clock source, as determined by the Timer0 prescaler.",
    "20.3 Programmable Prescaler\nA  software  programmable  prescaler  is  available  for exclusive  use  with  Timer0.  There  are  16  prescaler options for Timer0 ranging in powers of two from 1:1 to 1:32768. The prescaler values are selected using the CKPS<3:0> bits of the T0CON1 register.\nThe  prescaler  is  not  directly  readable  or  writable. Clearing the prescaler register can be done by writing to  the  TMR0L  register  or  to  the  T0CON0/T0CON1 register or by any Reset.",
    "20.4 Programmable Postscaler\nA software programmable postscaler (output divider) is available for exclusive use with Timer0. There are 16 postscaler options for Timer0 ranging from 1:1 to 1:16. The postscaler values are selected using the OUTPS bits of the T0CON0 register.\nThe  postscaler  is  not  directly  readable  or  writable. Clearing the postscaler register can be done by writing to  the  TMR0L  register  or  to  the  T0CON0/T0CON1 register or by any Reset.",
    "20.5 Operation During Sleep\nWhen operating synchronously, Timer0 will halt. When operating  asynchronously,  Timer0  will  continue  to increment and wake the device from Sleep (if Timer0 interrupts  are  enabled)  provided  that  the  input  clock source is active.",
    "20.6 Timer0 Interrupts\nThe  Timer0  interrupt  flag  bit  (TMR0IF)  is  set  when either of the following conditions occur:\n\u00b7 8-bit TMR0L matches the TMR0H value\n\u00b7 16-bit TMR0 rolls over from 'FFFFh'\nWhen the postscaler bits (OUTPS) are set to 1:1 oper -ation (no division), the T0IF flag bit will be set with every TMR0 match or rollover. In general, the TMR0IF flag bit will be set every OUTPS +1 matches or rollovers.\nIf  Timer0  interrupts  are  enabled  (TMR0IE  bit  of  the PIE3 register = ' 1 '), the CPU will be interrupted and the device may wake from Sleep (see Section 20.2 'Clock Source Selection' for more details).",
    "20.7 Timer0 Output\nThe Timer0 output can be routed to any I/O pin via the RxyPPS output selection register (see Section 17.0 'Peripheral Pin Select (PPS) Module' for addi -tional information). The Timer0 output can also be used by other peripherals, such as the auto-conversion trig -ger  of  the  Analog-to-Digital  Converter.  Finally,  the Timer0 output can be monitored through software via the  Timer0  output  bit  (OUT)  of  the T0CON0  register (Register 20-1).\nTMR0_out  will  be  a  pulse  of  one  postscaled  clock period when a match occurs between TMR0L and PR0 (Period  register  for  TMR0)  in  8-bit  mode,  or  when TMR0 rolls over in 16-bit mode. The Timer0 output is a 50% duty cycle that toggles on each TMR0_out rising clock edge.\n20.8",
    "REGISTER 20-1: T0CON0: TIMER0 CONTROL REGISTER 0\nEN, U-0 = -. EN, R-0 = OUT. EN, R/W-0/0 = MD16. EN, R/W-0/0 = . EN, R/W-0/0 = OUTPS<3:0>. EN, R/W-0/0 = . EN, R/W-0/0 = . bit 7, U-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 20-1: T0CON0: TIMER0 CONTROL REGISTER 0\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "bit 7 EN: TMR0 Enable bit\n1 = The module is enabled and operating\n0 = The module is disabled and in the lowest power mode\nbit 6\nUnimplemented: Read as ' 0 '\nbit 5\nOUT: TMR0 Output bit (read-only)\nTMR0 output bit\nbit 4\nMD16: TMR0 Operating as 16-Bit Timer Select bit\n1 = TMR0 is a 16-bit timer\n0 = TMR0 is an 8-bit timer\nbit 3-0\nOUTPS<3:0>: TMR0 Output Postscaler (Divider) Select bits\n1111 = 1:16 Postscaler\n1110 = 1:15 Postscaler\n1101 = 1:14 Postscaler\n1100 = 1:13 Postscaler\n1011 = 1:12 Postscaler\n1010 = 1:11 Postscaler\n1001 = 1:10 Postscaler\n1000 = 1:9 Postscaler\n0111 = 1:8 Postscaler\n0110 = 1:7 Postscaler\n0101 = 1:6 Postscaler\n0100 = 1:5 Postscaler\n0011 = 1:4 Postscaler\n0010 = 1:3 Postscaler",
    "bit 7 EN: TMR0 Enable bit\n0001 = 1:2 Postscaler\n0000 = 1:1 Postscaler",
    "bit 4\nbit 3-0",
    "REGISTER 20-2: T0CON1: TIMER0 CONTROL REGISTER 1\nCS<2:0>, R/W-0/0 = CS<2:0>. CS<2:0>, R/W-0/0 = CS<2:0>. CS<2:0>, R/W-0/0 = ASYNC. CS<2:0>, R/W-0/0 = CKPS<3:0>. CS<2:0>, R/W-0/0 = CKPS<3:0>. CS<2:0>, R/W-0/0 = CKPS<3:0>. CS<2:0>, R/W-0/0 = CKPS<3:0>. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit",
    "REGISTER 20-2: T0CON1: TIMER0 CONTROL REGISTER 1\n7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0\nR = Readable bit u = Bit is,  = W=Writable x = Bit is unknown. R = Readable bit u = Bit is,  = U = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7-5\nCS<2:0>: Timer0 Clock Source Select bits\n111 = CLC1\n110 = SOSC\n101 = MFINTOSC (500 kHz)\n100 = LFINTOSC\n011 = HFINTOSC\n010 = FOSC/4\n001 = Pin selected by T0CKIPPS (Inverted)\n000 = Pin selected by T0CKIPPS (Non-inverted)\nASYNC: TMR0 Input Asynchronization Enable bit\n1 = The input to the TMR0 counter is not synchronized to system clocks\n0 = The input to the TMR0 counter is synchronized to FOSC/4\nCKPS<3:0>: Prescaler Rate Select bit\n1111 = 1:32768\n1110 = 1:16384\n1101 = 1:8192\n1100 = 1:4096\n1011 = 1:2048\n1010 = 1:1024\n1001 = 1:512\n1000 = 1:256\n0111 = 1:128\n0110 = 1:64\n0101 = 1:32\n0100 = 1:16\n0011 = 1:8\n0010 = 1:4\n0001 = 1:2\n0000 = 1:1",
    "REGISTER 20-3: TMR0L: TIMER0 COUNT REGISTER\nbit 7, R/W-0/0.TMR0L<7:0> = . bit 7, R/W-0/0.TMR0L<7:0> = . bit 7, R/W-0/0.TMR0L<7:0> = . bit 7, R/W-0/0.TMR0L<7:0> = . bit 7, R/W-0/0.TMR0L<7:0> = . bit 7, R/W-0/0.TMR0L<7:0> = . bit 7, R/W-0/0.TMR0L<7:0> = bit 0",
    "REGISTER 20-3: TMR0L: TIMER0 COUNT REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = \nbit 7-0 TMR0L<7:0>:\nTMR0 Counter bits <7:0>",
    "REGISTER 20-4: TMR0H: TIMER0 PERIOD REGISTER\nbit 7, R/W-1/1.TMR0H<15:8> = . bit 7, R/W-1/1.TMR0H<15:8> = . bit 7, R/W-1/1.TMR0H<15:8> = . bit 7, R/W-1/1.TMR0H<15:8> = . bit 7, R/W-1/1.TMR0H<15:8> = . bit 7, R/W-1/1.TMR0H<15:8> = . bit 7, R/W-1/1.TMR0H<15:8> = bit 0",
    "REGISTER 20-4: TMR0H: TIMER0 PERIOD REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = \nbit 7-0\nWhen MD16 = 0\nPR0<7:0>: TMR0 Period Register Bits <7:0>\nWhen MD16 = 1\nTMR0H<15:8>:\nTMR0 Counter bits <15:8>",
    "TABLE 20-1: SUMMARY OF REGISTERS ASSOCIATED WITH TIMER0\nT0CON0, Bit 7 = EN. T0CON0, Bit 6 = -. T0CON0, Bit 5 = OUT. T0CON0, Bit 4 = MD16. T0CON0, Bit 3 = OUTPS<3:0>. T0CON0, Bit 2 = OUTPS<3:0>. T0CON0, Bit 1 = OUTPS<3:0>. T0CON0, Bit 0 = OUTPS<3:0>. T0CON0, Register on Page = 287. T0CON1, Bit 7 = CS<2:0>. T0CON1, Bit 6 = CS<2:0>. T0CON1, Bit 5 = CS<2:0>. T0CON1, Bit 4 = ASYNC. T0CON1, Bit 3 = CKPS<3:0>. T0CON1, Bit 2 = CKPS<3:0>. T0CON1, Bit 1 = CKPS<3:0>. T0CON1, Bit 0 = CKPS<3:0>. T0CON1, Register on",
    "TABLE 20-1: SUMMARY OF REGISTERS ASSOCIATED WITH TIMER0\nPage = 288. TMR0L, Bit 7 = TMR0L<7:0>. TMR0L, Bit 6 = TMR0L<7:0>. TMR0L, Bit 5 = TMR0L<7:0>. TMR0L, Bit 4 = TMR0L<7:0>. TMR0L, Bit 3 = TMR0L<7:0>. TMR0L, Bit 2 = TMR0L<7:0>. TMR0L, Bit 1 = TMR0L<7:0>. TMR0L, Bit 0 = TMR0L<7:0>. TMR0L, Register on Page = 289. TMR0H, Bit 7 = TMR0H<15:8>. TMR0H, Bit 6 = TMR0H<15:8>. TMR0H, Bit 5 = TMR0H<15:8>. TMR0H, Bit 4",
    "TABLE 20-1: SUMMARY OF REGISTERS ASSOCIATED WITH TIMER0\n= TMR0H<15:8>. TMR0H, Bit 3 = TMR0H<15:8>. TMR0H, Bit 2 = TMR0H<15:8>. TMR0H, Bit 1 = TMR0H<15:8>. TMR0H, Bit 0 = TMR0H<15:8>. TMR0H, Register on Page = 289\nLegend:\n- = unimplemented location, read as ' 0 '. Shaded cells are not used by Timer0.",
    "21.0 TIMER1/3/5 MODULE WITH GATE CONTROL\nTimer1/3/5  module  is  a  16-bit  timer/counter  with  the following features:\n\u00b7 16-bit timer/counter register pair (TMRxH:TMRxL)\n\u00b7 Programmable internal or external clock source\n\u00b7 2-bit prescaler\n\u00b7 Dedicated Secondary 32 kHz oscillator circuit\n\u00b7 Optionally synchronized comparator out\n\u00b7 Multiple Timer1/3/5 gate (count enable) sources\n\u00b7 Interrupt-on-overflow\n\u00b7 Wake-up on overflow (external clock,",
    "FIGURE 21-1: TIMER1/3/5 BLOCK DIAGRAM\nNote\n1:\nST Buffer is high speed type when using TxCKIPPS\nAsynchronous mode only)\n\u00b7 16-Bit Read/Write Operation\n\u00b7 Time base for the Capture/Compare function with the CCP modules\n\u00b7 Special Event Trigger (with CCP)\n\u00b7 Selectable Gate Source Polarity\n\u00b7 Gate Toggle mode\n\u00b7 Gate Single-pulse mode\n\u00b7 Gate Value Status\n\u00b7 Gate Event Interrupt\nFigure 21-1  is  a  block  diagram  of  the  Timer1/3/5 module.",
    "21.1 Timer1/3/5 Operation\nThe  Timer1/3/5 module is a 16-bit incrementing counter which is accessed through the TMRxH:TMRxL register  pair. Writes  to  TMRxH  or  TMRxL  directly update the counter.\nWhen used with an internal clock source, the module is a  timer  and  increments  on  every  instruction  cycle. When used with an external clock source, the module can  be  used  as  either  a  timer  or  counter  and  incre -ments on every selected edge of the external source.\nTimer1/3/5 is enabled by configuring the ON and GE bits in the TxCON and TxGCON registers, respectively. Table 21-1 displays the Timer1/3/5 enable selections.",
    "TABLE 21-1: TIMER1/3/5 ENABLE SELECTIONS\n1, GE = 1. 1, Timer1/3/5 Operation = Count Enabled. 1, GE = 0. 1, Timer1/3/5 Operation = Always On. 0, GE = 1. 0, Timer1/3/5 Operation = Off. 0, GE = 0. 0, Timer1/3/5 Operation = Off",
    "21.2 Clock Source Selection\nThe CS<4:0> bits of the TMRxCLK register (Register 21-3) are used to select the clock source for Timer1/3/5. The five TMRxCLK bits allow the selection of  several  possible  synchronous  and  asynchronous clock sources. Register 21-3 displays the clock source selections.",
    "21.2.1 INTERNAL CLOCK SOURCE\nWhen  the internal clock source is selected the TMRxH:TMRxL register pair will increment on multiples of FOSC as determined by the Timer1/3/5 prescaler.\nWhen the FOSC internal clock source is selected, the Timer1/3/5 register value will increment by four counts every instruction clock cycle. Due to this condition, a 2 LSB error in resolution will occur when reading the Timer1/3/5 value. To utilize the full resolution of Timer1/ 3/5, an asynchronous input signal must be used to gate the Timer1/3/5 clock input.\nThe following asynchronous sources may be used at the Timer1/3/5 gate:",
    "21.2.1 INTERNAL CLOCK SOURCE\n\u00b7 Asynchronous event on the TxGPPS pin\n\u00b7 TMR0OUT\n\u00b7 TMR1/3/5OUT (excluding the TMR for which it is being used)\n\u00b7 TMR 2/4/6OUT (post-scaled)\n\u00b7 CMP1/2OUT\n\u00b7 SMT1_match\n\u00b7 NCO1OUT\n\u00b7 PWM3/4 OUT\n\u00b7 CCP1/2/3/4 OUT\n\u00b7 CLC1/2/3/4 OUT\n\u00b7 ZCDOUT",
    "Note:\nIn Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge after any one or more of the following conditions:\n\u00b7 Timer1/3/5 enabled after POR\n\u00b7 Write to TMRxH or TMRxL\n\u00b7 Timer1/3/5 is disabled\n\u00b7 Timer1/3/5 is disabled (TMRxON = 0 ) when TxCKI is high then Timer1/3/5 is enabled (TMRxON = 1 ) when TxCKI is low.",
    "21.2.2 EXTERNAL CLOCK SOURCE\nWhen the external clock source is selected, the Timer1/ 3/5 module may work as a timer or a counter.\nWhen enabled to count, Timer1/3/5 is incremented on the  rising  edge  of  the  external  clock  input  of  the TxCKIPPS  pin.  This  external  clock  source  can  be synchronized to the microcontroller system clock or it can run asynchronously.\nWhen  used  as  a  timer  with  a  clock  oscillator,  an external 32.768 kHz crystal can be used in conjunction with the dedicated secondary internal oscillator circuit.",
    "21.3 Timer1/3/5 Prescaler\nTimer1/3/5 has four prescaler options allowing 1, 2, 4 or 8  divisions  of  the  clock  input.  The  CKPS  bits  of  the TxCON  register  control  the  prescale  counter.  The prescale  counter  is  not  directly  readable  or  writable; however, the prescaler counter is cleared upon a write to TMRxH or TMRxL.",
    "21.4 Timer1/3/5 Operation in Asynchronous Counter Mode\nIf  control bit SYNC of the TxCON register is set, the external  clock  input  is  not  synchronized.  The  timer increments  asynchronously  to the internal phase clocks.  If  external  clock  source  is  selected  then  the timer  will continue  to  run  during  Sleep  and  can generate an interrupt on overflow, which will wake up the processor. However, special precautions in software  are  needed  to  read/write  the  timer  (see Section 21.4.1 'Reading and Writing Timer1/3/5 in Asynchronous Counter Mode' ).\nNote:\nWhen  switching from synchronous to asynchronous operation, it is possible to skip  an  increment. When switching  from asynchronous to synchronous operation, it is possible  to  produce  an  additional increment.",
    "21.4.1 READING AND WRITING TIMER1/3/ 5 IN ASYNCHRONOUS COUNTER MODE\nReading TMRxH or TMRxL while the timer is running from an external asynchronous clock will ensure a valid read (taken care of in  hardware).  However,  the  user should keep in mind that reading the 16-bit timer in two 8-bit  values  itself,  poses  certain  problems,  since  the timer may overflow between the reads. For writes, it is recommended that the user simply stop the timer and write the desired values. A write contention may occur by  writing  to  the  timer  registers,  while  the  register  is incrementing.  This  may  produce  an  unpredictable value in the TMRxH:TMRxL register pair.",
    "21.5 Timer1/3/5 16-Bit Read/Write Mode\nTimer1/3/5 can be configured to read and write all 16 bits of data, to and from, the 8-bit TMRxL and TMRxH registers,  simultaneously.  The  16-bit  read  and  write operations are enabled by setting the RD16 bit of the TxCON register.\nTo accomplish this function, the TMRxH register value is mapped to a buffer register called the TMRxH buffer register. While in 16-Bit mode, the TMRxH register is not directly readable or writable and all read and write operations take place through the use of this TMRxH buffer register.",
    "21.5 Timer1/3/5 16-Bit Read/Write Mode\nWhen a read from the TMRxL register is requested, the value of the TMRxH register is simultaneously loaded into the TMRxH buffer register. When a read from the TMRxH  register  is  requested,  the  value  is  provided from the TMRxH buffer register instead. This provides the user with the ability to accurately read all 16 bits of the  Timer1/3/5  value  from  a  single  instance  in  time. Reference the block diagram in Figure 21-2 for more details.\nIn  contrast,  when  not  in  16-Bit  mode,  the  user  must read  each  register  separately  and  determine  if  the values have become invalid due to a rollover that may have occurred between the read operations.",
    "21.5 Timer1/3/5 16-Bit Read/Write Mode\nWhen  a  write  request of the  TMRxL  register is requested, the TMRxH buffer register is simultaneously updated with the contents of the TMRxH register. The value of TMRxH must be preloaded into the TMRxH buffer register prior to the write request for the TMRxL register. This provides the user with the ability to write all  16  bits  to  the  TMRxL:TMRxH  register  pair  at  the same time.\nAny requests to write to the TMRxH directly does not clear  the  Timer1/3/5  prescaler  value.  The  prescaler value  is  only  cleared  through  write  requests  to  the TMRxL register.",
    "21.6 Timer1/3/5 Gate\nTimer1/3/5  can  be  configured  to  count  freely  or  the count can be enabled and disabled using Timer1/3/5 gate circuitry. This is also referred to as Timer1/3/5 gate enable.\nTimer1/3/5 gate can also be driven by multiple selectable sources.",
    "21.6.1 TIMER1/3/5 GATE ENABLE\nThe  Timer1/3/5  Gate  Enable  mode  is  enabled  by setting the TMRxGE bit of the TxGCON register. The polarity of the Timer1/3/5 Gate Enable mode  is configured  using  the  TxGPOL  bit  of  the  TxGCON register.\nWhen  Timer1/3/5  Gate  Enable  mode  is  enabled, Timer1/3/5  will  increment  on  the  rising  edge  of  the Timer1/3/5 clock source. When Timer1/3/5 Gate signal is  inactive,  the  timer  will  not  increment  and  hold  the current count. See Figure 21-4 for timing details.\nTABLE 21-2: TIMER1/3/5 GATE ENABLE SELECTIONS\n\n\uf0ad, TxGPOL = 1. \uf0ad, TxG = 1. \uf0ad, Timer1/3/5 Operation = Counts. \uf0ad, TxGPOL = 1. \uf0ad, TxG = 0. \uf0ad, Timer1/3/5 Operation = Holds Count. \uf0ad, TxGPOL = 0. \uf0ad, TxG = 1. \uf0ad, Timer1/3/5 Operation = Holds Count. \uf0ad, TxGPOL = 0. \uf0ad, TxG = 0. \uf0ad, Timer1/3/5 Operation = Counts",
    "21.6.2 TIMER1/3/5 GATE SOURCE SELECTION\nThe gate source for Timer1/3/5 can be selected using the GSS<4:0> bits of the TMRxGATE register (Register 21-4).  The  polarity  selection  for  the  gate source is controlled by the TxGPOL bit of the TxGCON register (Register 21-2).\nAny  of  the  above  mentioned  signals  can  be  used  to trigger  the  gate.  The  output  of  the  CMPx  can  be synchronized to the Timer1/3/5 clock or left asynchronous. For more information see Section 39.3.1 'Comparator Output Synchronization' .",
    "21.6.3 TIMER1/3/5 GATE TOGGLE MODE\nWhen Timer1/3/5 Gate Toggle mode is enabled, it is possible to measure the duration between every rising and falling edge of the gate signal.\nThe Timer1/3/5 gate source is routed through a flip-flop that changes state on every incrementing edge of the signal. See Figure 21-5 for timing details.\nTimer1/3/5 Gate Toggle mode is enabled by setting the GTM bit of the TxGCON register. When the GTM bit is cleared, the flip-flop is cleared and held clear. This is necessary in order to control which edge is measured.\nNote:\nEnabling Toggle mode at the same time as changing the gate polarity may result in indeterminate operation.",
    "21.6.4 TIMER1/3/5 GATE SINGLE-PULSE MODE\nWhen Timer1/3/5 Gate Single-Pulse mode is enabled, it is  possible  to  capture  a  single-pulse  gate  event. Timer1/3/5 Gate Single-Pulse mode is first enabled by setting the GSPM bit in the TxGCON register. Next, the GGO/DONE bit in the TxGCON register must be set. The  Timer1/3/5  will  be  fully  enabled  on  the  next incrementing  edge  of  the  gate  signal.  On  the  next trailing  edge  of  the  pulse,  the  GGO/DONE  bit  will automatically be cleared. No other gate events will be allowed to increment Timer1/3/5 until the GGO/DONE bit is once again set in software.\nClearing the TxGSPM bit of the TxGCON register will also  clear  the  GGO/DONE  bit.  See  Figure 21-6  for timing details.\nEnabling the Toggle mode and the Single-Pulse mode simultaneously will permit both sections to work together. This allows the period on the Timer1/3/5 gate source  to  be  measured.  See  Figure 21-7  for  timing details.",
    "21.6.5 TIMER1/3/5 GATE VALUE STATUS\nWhen Timer1/3/5  Gate  Value  Status  is  utilized,  it  is possible  to  read  the  most  current  level  of  the  gate signal.  The  value  is  stored  in  the  GVAL  bit  in  the TxGCON register. The GVAL bit is valid even when the Timer1/3/5 gate is not enabled (GE bit is cleared).",
    "21.6.6 TIMER1/3/5 GATE EVENT INTERRUPT\nWhen Timer1/3/5 Gate Event Interrupt is enabled, it is possible to generate an interrupt upon the completion of a gate event. When the falling edge of GVAL occurs, the TMRxGIF flag bit in the respective PIR register will be set. If the TMRxGIE bit in the respective PIE register is set, then an interrupt will be recognized.\nThe TMRxGIF flag bit operates even when the Timer1/ 3/5 gate is not enabled (GE bit is cleared).\nFor more information on selecting high or low priority status  for  the  Timer1/3/5  Gate  Event  Interrupt  see Section 9.0 'Interrupt Controller' .",
    "21.7 Timer1/3/5 Interrupt\nThe Timer1/3/5 register pair (TMRxH:TMRxL) increments to FFFFh and rolls over to 0000h. When Timer1/3/5 rolls over, the Timer1/3/5 interrupt flag bit of the  respective  PIR  register  is  set.  To  enable  the interrupt-on-rollover, you must set these bits:\n\u00b7 ON bit of the TxCON register\n\u00b7 TMRxIE bits of the respective PIE register\n\u00b7 GIE/GIEH bit of the INTCON0 register\nThe interrupt is cleared by clearing the TMRxIF bit in the Interrupt Service Routine.\nFor more information on selecting high or low priority status for the Timer1/3/5 Overflow  Interrupt, see Section 9.0 'Interrupt Controller' .\nNote:\nThe TMRxH:TMRxL register pair and the TMRxIF  bit  should  be  cleared  before enabling interrupts.",
    "21.8 Timer1/3/5 Operation During Sleep\nTimer1/3/5 can only operate during Sleep when set up in  Asynchronous  Counter  mode.  In  this  mode,  an external crystal or clock source  can  be  used  to increment the counter. To set up the timer to wake the device:\n\u00b7 ON bit of the TxCON register must be set\n\u00b7 TMRxIE bit of the respective PIE register must be set\n\u00b7 SYNC bit of the TxCON register must be set\n\u00b7 Configure the TMRxCLK register for using secondary oscillator as the clock source\n\u00b7 Enable the SOSCEN bit of the OSCEN register (Register 7-7)\nThe device will wake-up on an overflow and execute the next instruction. If the GIE/GIEH  bit of the INTCON0  register  is  set,  the  device  will  call  the Interrupt Service Routine.\nThe  secondary  oscillator  will  continue  to  operate  in Sleep regardless of the SYNC bit setting.",
    "21.9 CCP Capture/Compare Time Base\nThe CCP modules use the TMRxH:TMRxL register pair as  the time base  when  operating  in  Capture  or Compare mode.\nIn  Capture  mode,  the  value  in  the  TMRxH:TMRxL register pair is copied  into  the  CCPRxH:CCPRxL register pair on a configured event.\nIn Compare mode, an event is triggered when the value in  the  CCPRxH:CCPRxL  register  pair  matches  the value  in  the  TMRxH:TMRxL  register  pair. This  event can be a Special Event Trigger.\nFor  more  information,  see Section  23.0 'Capture/ Compare/PWM Module' .",
    "21.10 CCP Special Event Trigger\nWhen  any  of  the  CCP's  are  configured  to  trigger  a special event, the trigger will clear the TMRxH:TMRxL register  pair.  This  special  event  does  not  cause  a Timer1/3/5  interrupt.  The  CCP  module  may  still  be configured to generate a CCP interrupt.\nIn this mode  of  operation,  the  CCPRxH:CCPRxL register pair becomes the period register for Timer1/3/ 5.\nTimer1/3/5 should be synchronized and FOSC/4 should be selected as the clock source in order to utilize the Special Event  Trigger.  Asynchronous operation of Timer1/3/5  can  cause  a  Special  Event Trigger  to  be missed.\nIn the event that a write to TMRxH or TMRxL coincides with a Special Event Trigger from the CCP, the write will take precedence.",
    "FIGURE 21-3: TIMER1/3/5 INCREMENTING EDGE\nNote 1: Arrows indicate counter increments.\n- 2: In Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge of the clock.",
    "21.11 Peripheral Module Disable\nWhen a peripheral module is not used or inactive, the module can be disabled by setting the Module Disable bit in the PMD  registers.  This will reduce  power consumption to an absolute minimum. Setting the PMD bits  holds  the  module  in  Reset  and  disconnects  the module's  clock  source.  The  Module  Disable  bits  for Timer1  (TMR1MD),  Timer3  (TMR3MD)  and  Timer5 (TMR5MD)  are  in  the  respective  PMD  registers.  See Section 19.0 'Peripheral Module Disable (PMD)' for more information.",
    "21.12 Register Definitions: Timer1/3/5\nLong bit name prefixes for the Timer1/3/5 are shown below. Refer to Section 1.3.2.2 'Long Bit Names' for more information.\nTimer1, Bit Name Prefix = T1. Timer3, Bit Name Prefix = T3. Timer5, Bit Name Prefix = T5",
    "REGISTER 21-1: TXCON: TIMERx CONTROL REGISTER\n-, U-0 = -. -, R/W-0/u = CKPS<1:0>. -, R/W-0/u = CKPS<1:0>. -, U-0 = -. -, R/W-0/u = SYNC. -, R/W-0/0 = RD16. -, R/W-0/u = ON. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0",
    "REGISTER 21-1: TXCON: TIMERx CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = u = unchanged",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5-4 CKPS<1:0>: Timerx Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value",
    "bit 3 Unimplemented: Read as ' 0 '\nbit 2\nSYNC: Timerx External Clock Input Synchronization Control bit\nTMRxCLK = FOSC/4 or FOSC:\nThis bit is ignored. Timer1 uses the incoming clock as is.",
    "Else:\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input with system clock",
    "bit 1 RD16: 16-Bit Read/Write Mode Enable bit\n1 = Enables register read/write of Timerx in one 16-bit operation\n0 = Enables register read/write of Timerx in two 8-bit operation",
    "bit 0 ON: Timerx On bit\n1\n=\nEnables Timerx\n0 = Disables Timerx",
    "REGISTER 21-2: TxGCON: TIMERx GATE CONTROL REGISTER\nGE, R/W-0/u = GPOL. GE, R/W-0/u = GTM. GE, R/W-0/u = GSPM. GE, R/W-0/u = GGO/DONE. GE, R-x = GVAL. GE, U-0 = -. GE, U-0 = -. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R/W-0/u = bit 7 bit 0. bit 7 bit 0, R-x = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0",
    "REGISTER 21-2: TxGCON: TIMERx GATE CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 GE: Timerx Gate Enable bit\nIf TMRxON = 1 :\n1 = Timerx counting is controlled by the Timerx gate function\n0 = Timerx is always counting",
    "If TMRxON = 0 :\nThis bit is ignored",
    "bit 6 GPOL: Timerx Gate Polarity bit\n1 = Timerx gate is active-high (Timerx counts when gate is high)\n0 = Timerx gate is active-low (Timerx counts when gate is low)",
    "bit 5\nGTM: Timerx Gate Toggle Mode bit\n1 = Timerx Gate Toggle mode is enabled\n0 = Timerx Gate Toggle mode is disabled and Toggle flip-flop is cleared\nTimerx Gate Flip Flop Toggles on every rising edge",
    "bit 4\nGSPM: Timerx Gate Single Pulse Mode bit\n1 = Timerx Gate Single Pulse mode is enabled and is controlling Timerx gate)\n0 = Timerx Gate Single Pulse mode is disabled\nbit 3\nGGO/DONE: Timerx Gate Single Pulse Acquisition Status bit\n1 = Timerx Gate Single Pulse Acquisition is ready, waiting for an edge\n0 = Timerx Gate Single Pulse Acquisition has completed or has not been started.\nThis bit is automatically cleared when TxGSPM is cleared.",
    "bit 2 GVAL: Timerx Gate Current State bit\nIndicates the current state of the Timerx gate that could be provided to TMRxH:TMRxL Unaffected by Timerx Gate Enable (TMRxGE)\nbit 1-0 Unimplemented: Read as ' 0 '",
    "REGISTER 21-3: TxCLK: TIMERx CLOCK REGISTER\n-, U-0 = -. -, U-0 = -. -, R/W-0/u = . -, R/W-0/u = . -, R/W-0/u = CS<4:0>. -, R/W-0/u = . -, R/W-0/u = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 0",
    "REGISTER 21-3: TxCLK: TIMERx CLOCK REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = u = unchanged",
    "bit 4-0 CS<4:0>: Timerx Clock Source Selection bits\n11111-10001, Timer1 Clock.Source = Reserved. 11111-10001, Timer3 Clock Source. = Reserved. 11111-10001, Timer5 Clock.Source = Reserved. 10000, Timer1 Clock.Source = CLC4. 10000, Timer3 Clock Source. = CLC4. 10000, Timer5 Clock.Source = CLC4. 01111, Timer1 Clock.Source = CLC3. 01111, Timer3 Clock Source. = CLC3. 01111, Timer5 Clock.Source = CLC3. 01110, Timer1 Clock.Source = CLC2. 01110, Timer3 Clock Source. = CLC2. 01110, Timer5 Clock.Source = CLC2. 01101, Timer1 Clock.Source = CLC1. 01101, Timer3 Clock Source. = CLC1. 01101, Timer5 Clock.Source = CLC1. 01100, Timer1 Clock.Source = TMR5 overflow. 01100, Timer3 Clock Source. = TMR5 overflow.",
    "bit 4-0 CS<4:0>: Timerx Clock Source Selection bits\n01100, Timer5 Clock.Source = Reserved. 01011, Timer1 Clock.Source = TMR3 overflow. 01011, Timer3 Clock Source. = Reserved. 01011, Timer5 Clock.Source = TMR3 overflow. 01010, Timer1 Clock.Source = Reserved. 01010, Timer3 Clock Source. = TMR1 overflow. 01010, Timer5 Clock.Source = TMR1 overflow. 01001, Timer1 Clock.Source = TMR0 overflow. 01001, Timer3 Clock Source. = TMR0 overflow. 01001, Timer5 Clock.Source = TMR0 overflow. 01000, Timer1 Clock.Source = CLKREF. 01000, Timer3 Clock Source. = CLKREF. 01000, Timer5 Clock.Source = CLKREF. 00111, Timer1 Clock.Source = SOSC. 00111, Timer3 Clock Source. = SOSC. 00111, Timer5 Clock.Source = SOSC. 00110, Timer1",
    "bit 4-0 CS<4:0>: Timerx Clock Source Selection bits\nClock.Source = MFINTOSC (32 kHz). 00110, Timer3 Clock Source. = MFINTOSC (32 kHz). 00110, Timer5 Clock.Source = MFINTOSC (32 kHz). 00101, Timer1 Clock.Source = MFINTOSC (500 kHz). 00101, Timer3 Clock Source. = MFINTOSC (500 kHz). 00101, Timer5 Clock.Source = MFINTOSC (500 kHz). 00100, Timer1 Clock.Source = LFINTOSC. 00100, Timer3 Clock Source. = LFINTOSC. 00100, Timer5 Clock.Source = LFINTOSC. 00011, Timer1 Clock.Source = HFINTOSC. 00011, Timer3 Clock Source. = HFINTOSC. 00011, Timer5 Clock.Source = HFINTOSC. 00010, Timer1 Clock.Source = Fosc. 00010, Timer3 Clock Source. = Fosc. 00010, Timer5 Clock.Source = Fosc. 00001, Timer1 Clock.Source =",
    "bit 4-0 CS<4:0>: Timerx Clock Source Selection bits\nFosc/4. 00001, Timer3 Clock Source. = Fosc/4. 00001, Timer5 Clock.Source = Fosc/4. 00000, Timer1 Clock.Source = T1CKIPPS. 00000, Timer3 Clock Source. = T3CKIPPS. 00000, Timer5 Clock.Source = T5CKIPPS",
    "REGISTER 21-4: TxGATE: TIMERx GATE ISM REGISTER\n-, U-0 = -. -, U-0 = -. -, R/W-0/u = . -, R/W-0/u = . -, R/W-0/u = GSS<4:0>. -, R/W-0/u = . -, R/W-0/u = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 0",
    "REGISTER 21-4: TxGATE: TIMERx GATE ISM REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = u = unchanged",
    "bit 4-0 GSS<4:0>: Timerx Gate Source Selection bits\n11111-11011, Timer1.Gate Source = Reserved. 11111-11011, Timer3.Gate Source = Reserved. 11111-11011, Timer5.Gate Source = Reserved. 11010, Timer1.Gate Source = CLC4_out. 11010, Timer3.Gate Source = CLC4_out. 11010, Timer5.Gate Source = CLC4_out. 11001, Timer1.Gate Source = CLC3_out. 11001, Timer3.Gate Source = CLC3_out. 11001, Timer5.Gate Source = CLC3_out. 11000, Timer1.Gate Source = CLC2_out. 11000, Timer3.Gate Source = CLC2_out. 11000, Timer5.Gate Source = CLC2_out. 10111, Timer1.Gate Source = CLC1_out. 10111, Timer3.Gate Source = CLC1_out. 10111, Timer5.Gate Source = CLC1_out. 10110, Timer1.Gate Source = ZCDOUT. 10110,",
    "bit 4-0 GSS<4:0>: Timerx Gate Source Selection bits\nTimer3.Gate Source = ZCDOUT. 10110, Timer5.Gate Source = ZCDOUT. 10101, Timer1.Gate Source = CMP2OUT. 10101, Timer3.Gate Source = CMP2OUT. 10101, Timer5.Gate Source = CMP2OUT. 10100, Timer1.Gate Source = CMP1OUT. 10100, Timer3.Gate Source = CMP1OUT. 10100, Timer5.Gate Source = CMP1OUT. 10011, Timer1.Gate Source = NCO1OUT. 10011, Timer3.Gate Source = NCO1OUT. 10011, Timer5.Gate Source = NCO1OUT. 10010-10001, Timer1.Gate Source = Reserved. 10010-10001, Timer3.Gate Source = Reserved. 10010-10001, Timer5.Gate Source = Reserved. 10000, Timer1.Gate Source = PWM8OUT. 10000, Timer3.Gate Source = PWM8OUT. 10000, Timer5.Gate Source = PWM8OUT.",
    "bit 4-0 GSS<4:0>: Timerx Gate Source Selection bits\n01111, Timer1.Gate Source = PWM7OUT. 01111, Timer3.Gate Source = PWM7OUT. 01111, Timer5.Gate Source = PWM7OUT. 01110, Timer1.Gate Source = PWM6OUT. 01110, Timer3.Gate Source = PWM6OUT. 01110, Timer5.Gate Source = PWM6OUT. 01101, Timer1.Gate Source = PWM5OUT. 01101, Timer3.Gate Source = PWM5OUT. 01101, Timer5.Gate Source = PWM5OUT. 01100, Timer1.Gate Source = CCP4OUT. 01100, Timer3.Gate Source = CCP4OUT. 01100, Timer5.Gate Source = CCP4OUT. 01011, Timer1.Gate Source = CCP3OUT. 01011, Timer3.Gate Source = CCP3OUT. 01011, Timer5.Gate Source = CCP3OUT. 01010,",
    "bit 4-0 GSS<4:0>: Timerx Gate Source Selection bits\nTimer1.Gate Source = CCP2OUT. 01010, Timer3.Gate Source = CCP2OUT. 01010, Timer5.Gate Source = CCP2OUT. 01001, Timer1.Gate Source = CCP1OUT. 01001, Timer3.Gate Source = CCP1OUT. 01001, Timer5.Gate Source = CCP1OUT. 01000, Timer1.Gate Source = SMT1_match. 01000, Timer3.Gate Source = SMT1_match. 01000, Timer5.Gate Source = SMT1_match. 00111, Timer1.Gate Source = TMR6OUT (post-scaled). 00111, Timer3.Gate Source = TMR6OUT (post-scaled). 00111, Timer5.Gate Source = TMR6OUT (post-scaled). 00110, Timer1.Gate Source = TMR5 overflow. 00110, Timer3.Gate Source = TMR5 overflow. 00110, Timer5.Gate Source = Reserved.",
    "bit 4-0 GSS<4:0>: Timerx Gate Source Selection bits\n00101, Timer1.Gate Source = TMR4OUT (post-scaled). 00101, Timer3.Gate Source = TMR4OUT (post-scaled). 00101, Timer5.Gate Source = TMR4OUT (post-scaled). 00100, Timer1.Gate Source = TMR3 overflow. 00100, Timer3.Gate Source = Reserved. 00100, Timer5.Gate Source = TMR3 overflow. 00011, Timer1.Gate Source = TMR2OUT (post-scaled). 00011, Timer3.Gate Source = TMR2OUT (post-scaled). 00011, Timer5.Gate Source = TMR2OUT (post-scaled). 00010, Timer1.Gate Source = Reserved. 00010, Timer3.Gate Source = TMR1 overflow. 00010, Timer5.Gate Source = TMR1 overflow. 00001, Timer1.Gate Source = TMR0 overflow. 00001, Timer3.Gate Source = TMR0 overflow.",
    "bit 4-0 GSS<4:0>: Timerx Gate Source Selection bits\n00001, Timer5.Gate Source = TMR0 overflow. 00000, Timer1.Gate Source = Pin selected by T1GPPS. 00000, Timer3.Gate Source = Pin selected by T3GPPS. 00000, Timer5.Gate Source = Pin selected by T5GPPS",
    "REGISTER 21-5: TMRxL: TIMERx LOW BYTE REGISTER\nbit 7, R/W-x/x.TMRxL<7:0> = . bit 7, R/W-x/x.TMRxL<7:0> = . bit 7, R/W-x/x.TMRxL<7:0> = . bit 7, R/W-x/x.TMRxL<7:0> = . bit 7, R/W-x/x.TMRxL<7:0> = . bit 7, R/W-x/x.TMRxL<7:0> = . bit 7, R/W-x/x.TMRxL<7:0> = bit 0",
    "REGISTER 21-5: TMRxL: TIMERx LOW BYTE REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = \nbit 7-0 TMRxL<7:0>: Timerx Low Byte bits",
    "REGISTER 21-6: TMRxH: TIMERx HIGH BYTE REGISTER\nbit 7, R/W-x/x.TMRxH<7:0> = . bit 7, R/W-x/x.TMRxH<7:0> = . bit 7, R/W-x/x.TMRxH<7:0> = . bit 7, R/W-x/x.TMRxH<7:0> = . bit 7, R/W-x/x.TMRxH<7:0> = . bit 7, R/W-x/x.TMRxH<7:0> = . bit 7, R/W-x/x.TMRxH<7:0> = bit 0",
    "REGISTER 21-6: TMRxH: TIMERx HIGH BYTE REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is,  = U = Unimplemented bit, read as '0'. '1' = Bit is set, W=Writable bit = . '1' = Bit is set,  = -n/n = Value at POR and BOR/Value at all other Resets. , W=Writable bit = '0' = Bit is cleared. ,  = \nbit 7-0 TMRxH<7:0>: Timerx High Byte bits",
    "TABLE 21-3: SUMMARY OF REGISTERS ASSOCIATED WITH TIMER1/3/5 AS A TIMER/COUNTER\nTxCON, Bit 7 = -. TxCON, Bit 6 = -. TxCON, Bit 5 = CKPS<1:0>. TxCON, Bit 4 = CKPS<1:0>. TxCON, Bit 3 = -. TxCON, Bit 2 = SYNC. TxCON, Bit 1 = RD16. TxCON, Bit 0 = ON. TxCON, Reset Values on Page = 299. TxGCON, Bit 7 = GE. TxGCON, Bit 6 = GPOL. TxGCON, Bit 5 = GTM. TxGCON, Bit 4 = GSPM. TxGCON, Bit 3 = GO/DONE. TxGCON, Bit 2 = GVAL. TxGCON, Bit 1 = -. TxGCON, Bit 0 = -. TxGCON, Reset Values on Page = 300. TxCLK, Bit 7 = -. TxCLK, Bit 6 = -. TxCLK, Bit 5 = -. TxCLK, Bit 4 = CS<4:0>. TxCLK, Bit 3 = CS<4:0>. TxCLK,",
    "TABLE 21-3: SUMMARY OF REGISTERS ASSOCIATED WITH TIMER1/3/5 AS A TIMER/COUNTER\nBit 2 = CS<4:0>. TxCLK, Bit 1 = CS<4:0>. TxCLK, Bit 0 = CS<4:0>. TxCLK, Reset Values on Page = 301. TxGATE, Bit 7 = -. TxGATE, Bit 6 = -. TxGATE, Bit 5 = -. TxGATE, Bit 4 = GSS<4:0>. TxGATE, Bit 3 = GSS<4:0>. TxGATE, Bit 2 = GSS<4:0>. TxGATE, Bit 1 = GSS<4:0>. TxGATE, Bit 0 = GSS<4:0>. TxGATE, Reset Values on Page = 302. TMRxL, Bit 7 = Least Significant Byte of the 16-bit TMR3 Register. TMRxL, Bit 6 = Least Significant Byte of the 16-bit TMR3 Register. TMRxL, Bit 5 = Least Significant Byte of the 16-bit TMR3 Register. TMRxL, Bit 4 = Least Significant Byte of",
    "TABLE 21-3: SUMMARY OF REGISTERS ASSOCIATED WITH TIMER1/3/5 AS A TIMER/COUNTER\nthe 16-bit TMR3 Register. TMRxL, Bit 3 = Least Significant Byte of the 16-bit TMR3 Register. TMRxL, Bit 2 = Least Significant Byte of the 16-bit TMR3 Register. TMRxL, Bit 1 = Least Significant Byte of the 16-bit TMR3 Register. TMRxL, Bit 0 = Least Significant Byte of the 16-bit TMR3 Register. TMRxL, Reset Values on Page = 303. TMRxH, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMRxH, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMRxH, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMRxH, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMRxH, Bit 3 = Holding Register for",
    "TABLE 21-3: SUMMARY OF REGISTERS ASSOCIATED WITH TIMER1/3/5 AS A TIMER/COUNTER\nthe Most Significant Byte of the 16-bit TMR3 Register. TMRxH, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMRxH, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMRxH, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMRxH, Reset Values on Page = 303\nLegend: - = Unimplemented location, read as ' 0 '. Shaded cells are not used by TIMER1/3/5.",
    "22.0 TIMER2/4/6 MODULE\nThe  Timer2/4/6  modules  are  8-bit  timers  that  can operate as free-running period counters or in conjunction with external signals that control start, run, freeze, and reset operation in One-Shot and Monostable modes of operation. Sophisticated waveform control such as pulse density modulation are possible  by  combining  the  operation  of  these  timers with other internal peripherals such as the comparators and CCP modules. Features of the timer include:\n\u00b7 8-bit timer register\n\u00b7 8-bit period register\n\u00b7 Selectable external hardware timer resets\n\u00b7 Programmable prescaler (1:1 to 1:128)\n\u00b7 Programmable postscaler (1:1 to 1:16)\n\u00b7 Selectable synchronous/asynchronous operation\n\u00b7 Alternate clock sources\n\u00b7 Interrupt on period",
    "FIGURE 22-1: TIMER2 BLOCK DIAGRAM\n\u00b7 Three modes of operation:\n-Free Running Period\n-One-Shot\n-Monostable\nSee Figure 22-1  for  a  block  diagram  of Timer2.  See Figure 22-2 for the clock source block diagram.",
    "Note:\nThree identical Timer2 modules are implemented on this device. The timers are named  Timer2,  Timer4,  and  Timer6.  All references  to  Timer2  apply  as  well  to Timer4 and Timer6. All references to T2PR apply as well to T4PR and T6PR.",
    "22.1 Timer2 Operation\nTimer2 operates in three major modes:\n\u00b7 Free Running Period\n\u00b7 One-Shot\n\u00b7 Monostable\nWithin each mode there are several options for starting, stopping, and reset. Table 22-1 lists the options.\nIn all modes the T2TMR count register is incremented on the rising edge of the clock signal from the program -mable prescaler.  When T2TMR equals T2PR then a high level is output to the postscaler counter. T2TMR is cleared on the next clock input.\nAn external signal from hardware can also be config -ured  to  gate  the  timer  operation  or  force  a  T2TMR count Reset. In gate modes the counter stops when the gate  is disabled  and  resumes  when  the  gate  is enabled. In Reset modes the T2TMR count is reset on either the level or edge from the external source.\nThe T2TMR and T2PR registers are both directly read -able and writable. The T2TMR register is cleared and the  T2PR  register  initializes  to  FFh  on  any  device Reset. Both the prescaler and postscaler counters are cleared on the following events:",
    "22.1 Timer2 Operation\n\u00b7 a write to the T2TMR register\n\u00b7 a write to the TxCON register\n\u00b7 any device Reset\n\u00b7 External Reset Source event that resets the timer.\nNote:\nT2TMR  is  not  cleared  when  TxCON  is written.",
    "22.1.1 FREE RUNNING PERIOD MODE\nThe value of T2TMR is compared to that of the Period register,  T2PR,  on  each  clock  cycle.  When  the  two values  match,  the  comparator  resets  the  value  of T2TMR to 00h on  the  next  cycle  and  increments  the output  postscaler  counter.  When  the  postscaler  count equals  the  value  in  the  OUTPS  bits  of  the  TxCON register then a one clock period wide pulse occurs on the T2TMR_postscaled output, and the postscaler count is cleared.",
    "22.1.2 ONE-SHOT MODE\nThe One-Shot mode is identical to the Free Running Period mode except that the ON bit is cleared and the timer is stopped when T2TMR matches T2PR and will not  restart  until  the  T2ON  bit  is  cycled  off  and  on. Postscaler OUTPS values other than 0 are meaningless in this mode because the timer is stopped at  the  first  period  event  and  the  postscaler  is  reset when the timer is restarted.",
    "22.1.3 MONOSTABLE MODE\nMonostable  modes  are  similar  to  One-Shot  modes except that the ON bit is not cleared and the timer can be restarted by an external Reset event.",
    "22.2 Timer2 Output\nThe Timer2 module's primary output is T2TMR_posts -caled,  which  pulses  for  a  single  T2TMR_clk  period when the postscaler counter matches the value in the OUTPS bits of the TxCON register. The T2PR posts -caler  is  incremented  each  time  the  T2TMR  value matches the T2PR value. this signal can be selected as an input to several other input modules.\nTimer2 is also used by the CCP module for pulse gen -eration in PWM mode. Both the actual T2TMR value as well as other internal signals are sent to the CCP mod -ule to properly clock both the period and pulse width of the  PWM  signal.  See Section  23.0 'Capture/Com -pare/PWM  Module' for  more  details  on  setting  up Timer2 for use with the CCP, as well as the timing dia -grams  in Section  22.5 'Operation  Examples' for examples of how the varying Timer2 modes affect CCP PWM output.",
    "22.3 External Reset Sources\nIn addition to the clock source, the Timer2 also takes in an external Reset source. This external Reset source is  selected  for  Timer2,  Timer4,  and  Timer6  with  the T2RST,  T4RST,  and  T6RST  registers,  respectively. This  source  can  control  starting  and  stopping  of  the timer,  as  well  as  resetting  the  timer,  depending  on which mode the timer is in. The mode of the timer is controlled  by  the  MODE  bits  of  the  T2HLT  register. Edge Triggered modes require six Timer clock periods between  external  triggers.  Level  Triggered  modes require the triggering level to be at least three Timer clock periods long. External triggers are ignored while in Debug Freeze mode.",
    "TABLE 22-1: TIMER2 OPERATING MODES\nFree Running, MODE<4:0>.<4:3> = . Free Running, MODE<4:0>.<2:0> = 000. Free Running, Output.Operation = Period Pulse. Free Running, Operation. = Software gate (Figure 22-6). Free Running, Timer Control.Start = ON = 1. Free Running, Timer Control.Reset = -. Free Running, Timer Control.Stop = ON = 0. Free Running, MODE<4:0>.<4:3> = . Free Running, MODE<4:0>.<2:0> = 001. Free Running, Output.Operation = Period Pulse. Free Running, Operation. = Hardware gate, active-high (Figure 22-7). Free Running, Timer Control.Start = ON = 1 & TMRx_ers = 1. Free Running, Timer Control.Reset = -. Free Running, Timer Control.Stop = ON = 0 or TMRx_ers = 0. Free Running, MODE<4:0>.<4:3> = . Free Running, MODE<4:0>.<2:0> =",
    "TABLE 22-1: TIMER2 OPERATING MODES\n010. Free Running, Output.Operation = Period Pulse. Free Running, Operation. = Hardware gate, active-low. Free Running, Timer Control.Start = ON = 1 & TMRx_ers = 0. Free Running, Timer Control.Reset = -. Free Running, Timer Control.Stop = ON = 0 or TMRx_ers = 1. Free Running, MODE<4:0>.<4:3> = . Free Running, MODE<4:0>.<2:0> = 011. Free Running, Output.Operation = Period Pulse with Hardware. Free Running, Operation. = Rising or Falling Edge Reset. Free Running, Timer Control.Start = . Free Running, Timer Control.Reset = TMRx_ers \u2195. Free Running, Timer Control.Stop = ON = 0. Period, MODE<4:0>.<4:3> = 00. Period, MODE<4:0>.<2:0> = 100. Period, Output.Operation = Period Pulse with Hardware. Period, Operation. = Rising Edge Reset (Figure 22-8). Period, Timer Control.Start = .",
    "TABLE 22-1: TIMER2 OPERATING MODES\nPeriod, Timer Control.Reset = TMRx_ers \u2191. Period, Timer Control.Stop = ON = 0. Free Running, MODE<4:0>.<4:3> = . Free Running, MODE<4:0>.<2:0> = 101. Free Running, Output.Operation = Period Pulse with Hardware. Free Running, Operation. = Falling Edge Reset. Free Running, Timer Control.Start = . Free Running, Timer Control.Reset = TMRx_ers \u2193. Free Running, Timer Control.Stop = ON = 0. Free Running, MODE<4:0>.<4:3> = . Free Running, MODE<4:0>.<2:0> = 110. Free Running, Output.Operation = Period Pulse with Hardware. Free Running, Operation. = Low Level Reset. Free Running, Timer Control.Start = ON = 1. Free Running, Timer Control.Reset = TMRx_ers = 0. Free Running, Timer Control.Stop = ON = 0 or TMRx_ers = 0. Free Running, MODE<4:0>.<4:3> =",
    "TABLE 22-1: TIMER2 OPERATING MODES\n. Free Running, MODE<4:0>.<2:0> = 111. Free Running, Output.Operation = Reset. Free Running, Operation. = High Level Reset (Figure 22-9). Free Running, Timer Control.Start = . Free Running, Timer Control.Reset = TMRx_ers = 1. Free Running, Timer Control.Stop = ON = 0 or TMRx_ers = 1. One-shot, MODE<4:0>.<4:3> = . One-shot, MODE<4:0>.<2:0> = 000. One-shot, Output.Operation = One-Shot. One-shot, Operation. = Software Start (Figure 22-10). One-shot, Timer Control.Start = ON = 1. One-shot, Timer Control.Reset = -. One-shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One-shot, MODE<4:0>.<4:3> = . One-shot, MODE<4:0>.<2:0> = 001.",
    "TABLE 22-1: TIMER2 OPERATING MODES\nOne-shot, Output.Operation = Edge Triggered Start (Note 1). One-shot, Operation. = Rising Edge Start (Figure 22-9). One-shot, Timer Control.Start = ON = 1 & TMRx_ers \u2191. One-shot, Timer Control.Reset = -. One-shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One-shot, MODE<4:0>.<4:3> = . One-shot, MODE<4:0>.<2:0> = 010. One-shot, Output.Operation = Edge Triggered Start (Note 1). One-shot, Operation. = Falling Edge Start. One-shot, Timer Control.Start = ON = 1 & TMRx_ers \u2193. One-shot, Timer Control.Reset = -. One-shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One-shot, MODE<4:0>.<4:3> = . One-shot,",
    "TABLE 22-1: TIMER2 OPERATING MODES\nMODE<4:0>.<2:0> = 011. One-shot, Output.Operation = Edge Triggered Start (Note 1). One-shot, Operation. = Any Edge Start. One-shot, Timer Control.Start = ON = 1 & TMRx_ers \u2195. One-shot, Timer Control.Reset = -. One-shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One-shot, MODE<4:0>.<4:3> = 01. One-shot, MODE<4:0>.<2:0> = 100. One-shot, Output.Operation = Edge Triggered Start and Hardware Reset (Note 1). One-shot, Operation. = Rising Edge Start & Rising Edge Reset (Figure 22-12). One-shot, Timer Control.Start = ON = 1 & TMRx_ers \u2191. One-shot, Timer Control.Reset = TMRx_ers \u2191. One-shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note",
    "TABLE 22-1: TIMER2 OPERATING MODES\n2). One-shot, MODE<4:0>.<4:3> = . One-shot, MODE<4:0>.<2:0> = 101. One-shot, Output.Operation = Edge Triggered Start and Hardware Reset (Note 1). One-shot, Operation. = Falling Edge Start & Falling Edge Reset. One-shot, Timer Control.Start = ON = 1 & TMRx_ers \u2193. One-shot, Timer Control.Reset = TMRx_ers \u2193. One-shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One-shot, MODE<4:0>.<4:3> = . One-shot, MODE<4:0>.<2:0> = 110. One-shot, Output.Operation = Edge Triggered Start and Hardware Reset (Note 1). One-shot, Operation. = Rising Edge Start & Low Level Reset (Figure 22-13). One-shot, Timer Control.Start = ON = 1 & TMRx_ers \u2191. One-shot, Timer",
    "TABLE 22-1: TIMER2 OPERATING MODES\nControl.Reset = TMRx_ers = 0. One-shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One-shot, MODE<4:0>.<4:3> = . One-shot, MODE<4:0>.<2:0> = 111. One-shot, Output.Operation = Edge Triggered Start and Hardware Reset (Note 1). One-shot, Operation. = Falling Edge Start & High Level Reset. One-shot, Timer Control.Start = ON = 1 & TMRx_ers \u2193. One-shot, Timer Control.Reset = TMRx_ers = 1. One-shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). Reserved, MODE<4:0>.<4:3> = . Reserved, MODE<4:0>.<2:0> = 000. Reserved, Output.Operation = Reserved. Reserved, Operation. = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset =",
    "TABLE 22-1: TIMER2 OPERATING MODES\nReserved. Reserved, Timer Control.Stop = Reserved. Reserved, MODE<4:0>.<4:3> = . Reserved, MODE<4:0>.<2:0> = 001. Reserved, Output.Operation = Edge Triggered Start (Note 1). Reserved, Operation. = Rising Edge Start (Figure 22-12). Reserved, Timer Control.Start = ON = 1 & TMRx_ers \u2191. Reserved, Timer Control.Reset = -. Reserved, Timer Control.Stop = ON=0 or Next clock after TxTMR = TxPR (Note 3). Reserved, MODE<4:0>.<4:3> = . Reserved, MODE<4:0>.<2:0> = 010. Reserved, Output.Operation = Edge Triggered Start (Note 1). Reserved, Operation. = Falling Edge Start. Reserved, Timer Control.Start = ON = 1 & TMRx_ers \u2193. Reserved, Timer Control.Reset = -. Reserved, Timer Control.Stop = ON=0 or Next clock after TxTMR = TxPR (Note 3). Reserved,",
    "TABLE 22-1: TIMER2 OPERATING MODES\nMODE<4:0>.<4:3> = . Reserved, MODE<4:0>.<2:0> = 011. Reserved, Output.Operation = Edge Triggered Start (Note 1). Reserved, Operation. = Any Edge Start. Reserved, Timer Control.Start = ON = 1 & TMRx_ers \u2195. Reserved, Timer Control.Reset = -. Reserved, Timer Control.Stop = ON=0 or Next clock after TxTMR = TxPR (Note 3). , MODE<4:0>.<4:3> = 10. , MODE<4:0>.<2:0> = 100. , Output.Operation = Reserved. , Operation. = Reserved. , Timer Control.Start = Reserved. , Timer Control.Reset = Reserved. , Timer Control.Stop = Reserved. Reserved, MODE<4:0>.<4:3> = . Reserved, MODE<4:0>.<2:0> = 101. Reserved, Output.Operation = Reserved. Reserved, Operation. = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer",
    "TABLE 22-1: TIMER2 OPERATING MODES\nControl.Stop = Reserved. , MODE<4:0>.<4:3> = . , MODE<4:0>.<2:0> = 110. , Output.Operation = Level Triggered Start and Hardware Reset. , Operation. = High Level Start & Low Level Reset (Figure 22-13). , Timer Control.Start = ON = 1 & TMRx_ers = 1. , Timer Control.Reset = TMRx_ers = 0. , Timer Control.Stop = ON = 0 or Held in Reset (Note 2). One-shot, MODE<4:0>.<4:3> = . One-shot, MODE<4:0>.<2:0> = 111. One-shot, Output.Operation = Level Triggered Start and Hardware Reset. One-shot, Operation. = Low Level Start & High Level Reset. One-shot, Timer Control.Start = ON = 1 & TMRx_ers = 0. One-shot, Timer Control.Reset = TMRx_ers = 1. One-shot, Timer Control.Stop = ON = 0 or Held in Reset",
    "TABLE 22-1: TIMER2 OPERATING MODES\n(Note 2). Reserved, MODE<4:0>.<4:3> = 11. Reserved, MODE<4:0>.<2:0> = xxx. Reserved, Output.Operation = Reserved. Reserved, Operation. = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved\nNote\n1: If ON = 0 then an edge is required to restart the timer after ON = 1 .\n2: When TxTMR = TxPR then the next clock clears ON and stops TxTMR at 00h.\n3: When TxTMR = TxPR then the next clock stops TxTMR at 00h but does not clear ON.",
    "22.4 Timer2 Interrupt\nTimer2  can  also  generate  a  device  interrupt.  The interrupt  is generated  when  the  postscaler  counter matches one of 16 postscale options (from 1:1 through 1:16), which is selected with the postscaler control bits, OUTPS of the T2CON register. The interrupt is enabled by setting the T2TMR Interrupt Enable bit, TMR2IE, of the  respective  PIE  register.  The  interrupt  timing  is illustrated in Figure 22-3.",
    "22.5 Operation Examples\nUnless otherwise specified, the following notes apply to the following timing diagrams:\n-Both the prescaler and postscaler are set to 1:1 (both the CKPS and OUTPS bits in the T2CON register are cleared).\n-The diagrams illustrate any clock except FOSC/4 and show clock-sync delays of at least two full cycles for both ON and T2TMR_ers. When using FOSC/4, the clocksync delay is at least one instruction period for T2TMR_ers; ON applies in the next instruction period.\n-ON and T2TMR_ers are somewhat generalized, and clock-sync delays may produce results that are slightly different than illustrated.\n-The PWM Duty Cycle and PWM output are illustrated assuming that the timer is used for the PWM function of the CCP module as described in Section 23.0 'Capture/Com -pare/PWM Module' and Section 24.0 'Pulse-Width Modulation (PWM)' .\nThe signals are not a part of the T2TMR module.",
    "22.5.1 SOFTWARE GATE MODE\nThe timer increments with each clock input when ON = 1 and  does  not  increment  when  ON = 0 . When  the T2TMR count equals the T2PR period count the timer resets on the next clock and continues counting from 0. Operation  with  the  ON  bit  software  controlled  is  illus -trated in Figure 22-4. With T2PR = 5,  the  counter advances until T2TMR = 5, and goes to zero with the next clock.",
    "22.5.2 HARDWARE GATE MODE\nThe Hardware Gate modes operate the same as the Software Gate mode except the T2TMR_ers external signal can also gate the timer. When used with the CCP the  gating  extends  the  PWM  period.  If  the  timer  is stopped when the PWM output is high then the duty cycle is also extended.\nWhen MODE<4:0> = 00001 then the timer is stopped when the external signal is high. When MODE<4:0> = 00010 then  the  timer  is  stopped  when  the  external signal is low.\nFigure 22-5 illustrates the Hardware Gating mode for MODE<4:0>= 00001 in which a high input level starts the counter.",
    "22.5.3 EDGE-TRIGGERED HARDWARE LIMIT MODE\nIn Hardware Limit mode the timer can be reset by the TMRx_ers external signal before the timer reaches the period count. Three types of Resets are possible:\n\u00b7 Reset on rising or falling edge (MODE<4:0> = 00011 )\n\u00b7 Reset on rising edge (MODE<4:0> = 0010 )\n\u00b7 Reset on falling edge (MODE<4:0> = 00101 )\nWhen the timer is used in conjunction with the CCP in PWM mode then an early Reset shortens the period and restarts  the  PWM pulse after a  two  clock  delay. Refer to Figure 22-6.",
    "22.5.4 LEVEL-TRIGGERED HARDWARE LIMIT MODE\nIn the level triggered Hardware Limit Timer modes the counter is reset by high or low levels of the external signal TMR2_ers, as shown in Figure 22-7. Selecting MODE<4:0> = 00110 will cause the timer to reset on a low  level  external  signal.  Selecting  MODE<4:0>  = 00111 will  cause  the  timer  to  reset  on  a  high  level external  signal.  In  the  example,  the  counter  is  reset while TMR2_ers = 1 . ON is controlled by BSF and BCF instructions. When ON= 0 the external signal is ignored.",
    "PIC18(L)F25/26K83\nWhen the CCP uses the timer as the PWM time base then the PWM output will be set high when the timer starts counting and then set low only when the timer count  matches  the  CCPRx  value. The  timer  is  reset when either the timer count matches the T2PR value or two clock periods after the external Reset signal goes true and stays true.\nThe timer starts counting, and the PWM output is set high, on either the clock following the T2PR match or two clocks after the external Reset signal relinquishes the Reset. The PWM output will remain high until the timer counts up to match the CCPRx pulse width value. If the external Reset signal goes true while the PWM output is  high  then  the  PWM output will remain high until the Reset signal is released allowing the timer to count up to match the CCPRx value.",
    "22.5.5 SOFTWARE START ONE-SHOT MODE\nIn One-Shot mode the timer resets and the ON bit is cleared when the timer value matches the T2PR period value.  The  ON  bit  must  be  set  by  software  to  start another  timer  cycle.  Setting  MODE<4:0>  = 01000 selects One-Shot mode which is illustrated in Figure 22-8. In the example, ON is controlled by BSF and BCF  instructions. In the first case, a BSF instruction sets ON and the counter runs to completion and clears ON. In the second case, a BSF instruction starts the cycle, BCF/BSF instructions turn the counter off and  on  during  the  cycle,  and  then  it  runs  to completion.",
    "22.5.5 SOFTWARE START ONE-SHOT MODE\nWhen One-Shot mode is used in conjunction with the CCP  PWM  operation  the  PWM  pulse  drive  starts concurrent with setting the ON bit. Clearing the ON bit while  the  PWM  drive  is  active  will  extend  the  PWM drive.  The  PWM  drive  will  terminate  when  the  timer value  matches  the  CCPRx  pulse  width  value.  The PWM drive will remain off until software sets the ON bit to start another cycle. If software clears the ON bit after the CCPRx match but before the T2PR match then the PWM drive will be extended by the length of time the ON bit remains cleared. Another timing cycle can only be  initiated  by  setting  the  ON  bit  after  it  has  been cleared by a T2PR period count match.\nFIGURE 22-8: SOFTWARE START ONE-SHOT MODE TIMING DIAGRAM (MODE = 01000 )",
    "22.5.6 EDGE-TRIGGERED ONE-SHOT MODE\nThe Edge-Triggered One-Shot modes start the timer on an edge from the external signal input, after the ON bit is set, and clear the ON bit when the timer matches the T2PR period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE<4:0> = 01001 )\n\u00b7 Falling edge (MODE<4:0> = 01010 )\nIf the timer is halted by clearing the ON bit then another TMRx_ers edge is required after the ON bit is set to resume  counting.  Figure 22-9  illustrates  operation  in the rising edge One-Shot mode.\nWhen  Edge-Triggered  One-Shot  mode  is  used  in conjunction  with  the  CCP  then  the  edge-trigger  will activate the  PWM  drive  and  the  PWM  drive  will deactivate when the timer matches the CCPRx pulse width value and stay deactivated when the timer halts at the T2PR period count match.\n- \u00b7 Rising or Falling edge (MODE<4:0>=' 01011 ')",
    "22.5.7 EDGE-TRIGGERED HARDWARE LIMIT ONE-SHOT\nMODE\nIn Edge-Triggered Hardware Limit One-Shot modes the timer starts on the first external signal edge after the ON bit is set and resets on all subsequent edges. Only the first edge after the ON bit is set is needed to start the timer. The counter will resume counting automatically two clocks after all subsequent external Reset edges. Edge triggers are as follows:\nThe timer resets and clears the ON bit when the timer value matches the T2PR period value. External signal edges will have no effect until after software sets the  ON  bit.  Figure 22-10  illustrates  the  rising  edge  hardware  limit  one-shot operation.\n\u2022 Rising edge Start and Reset                  (MODE<4:0> =\n01100 )\n\u2022 Falling edge Start and Reset                  (MODE<4:0> =\n01101 )",
    "22.5.7 EDGE-TRIGGERED HARDWARE LIMIT ONE-SHOT\nWhen this mode is used in conjunction with the CCP then the first starting edge trigger, and all subsequent Reset edges, will activate the PWM drive. The PWM drive will deactivate when the timer matches the CCPRx pulse width value and stay deactivated until the timer halts at the T2PR period match unless an exter -nal signal edge resets the timer before the match occurs.",
    "FIGURE 22-10: EDGE TRIGGERED HARDWARE LIMIT ONE-SHOT MODE TIMING DIAGRAM (MODE = 01100 ))\nRev. 10-000201C 9/12/2016\nTMRx_clk\nON\nTxPR\nTxTMR\nBSF\nBSF\n5\n0\n1 2 3 4 5\n0\n0\n1\nMODE\n0b01100\n2\nTMRx_postscaled\nTMRx_ers\n1\n2\n3\n4\n5\n0\nPWM Duty Cycle\n3\nPWM Output\nInstruction (1)\nNote\n1:   BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "ONE-SHOT MODES\nIn Level Triggered One-Shot mode the timer count is reset on the external signal level and starts counting on the rising/falling edge of the transition from reset level to the active level while the ON bit is set. Reset levels are selected as follows:\n\u00b7 Low reset level (MODE<4:0> = 01110 )\n\u00b7 High reset level (MODE<4:0> = 01111 )\nWhen the timer count matches the T2PR period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a T2PR match or by software control a new external signal edge is required after the ON bit is set to start the counter.\nWhen Level Triggered Reset One-Shot mode is used in conjunction with the CCP PWM operation the PWM drive goes active with the external signal edge that starts the timer. The PWM drive goes inactive when the timer count equals the CCPRx pulse-width count. The PWM drive does not go active when the timer count clears at the T2PR period count match.",
    "FIGURE 22-11: LOW LEVEL RESET, EDGE-TRIGGERED HARDWARE LIMIT ONE-SHOT MODE TIMING DIAGRAM (MODE = 01110 )\nRev. 10-000202C\n9/12/2016\nTMRx_clk\nON\nTxPR\nTxTMR\nBSF\nBSF\n5\n0\n1 2 3 4 5\n0\n0\n1\nMODE\n0b01110\nTMRx_postscaled\nTMRx_ers\n1 2 3 4 5\n0\nPWM Duty Cycle\n3\nPWM Output\nInstruction (1)\nNote\n1:   BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "22.5.9 EDGE-TRIGGERED MONOSTABLE MODES\nThe Edge-Triggered Monostable modes start the timer on an edge from the external Reset signal input, after the ON bit is set, and stop incrementing the timer when the timer matches the T2PR period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE<4:0> = 10001 )\n\u00b7 Falling edge (MODE<4:0> = 10010 )\n\u00b7 Rising or Falling edge (MODE<4:0> = 10011 )",
    "FIGURE 22-12: RISING EDGE-TRIGGERED MONOSTABLE MODE TIMING DIAGRAM (MODE = 10001 )\nWhen an Edge-Triggered Monostable mode is used in conjunction with the CCP PWM operation the PWM drive goes active with the external Reset signal edge that starts the timer, but will not go active when the timer matches the T2PR value. While the timer is incrementing, additional edges on the external Reset signal will not affect the CCP PWM.",
    "22.5.10 LEVEL-TRIGGERED HARDWARE LIMIT ONE-SHOT MODES\nThe Level Triggered Hardware Limit One-Shot modes hold the timer in Reset on an external Reset level and start counting when both the ON bit is set and the external signal is not at the Reset level. If one of either the external signal is not in reset or the ON bit is set then the other signal being set/made active will start the timer.   Reset levels are selected as follows:\n\u00b7 Low reset level (MODE<4:0> = 10110 )\n\u00b7 High reset level (MODE<4:0> = 10111 )",
    "FIGURE 22-13: LEVEL-TRIGGERED HARDWARE LIMIT ONE-SHOT MODE TIMING DIAGRAM (MODE = 10110 )\nRev. 10-000204B 12/13/2016\nTMRx_clk\nInstruction (1)\nON\nTxPR\nTxTMR\nBSF\nBSF\n5\n0\n1 2 3 4 5\n0\n1 2 3\nMODE\n0b10110\nTMRx_postscaled\nTMRx_ers\n1\n2\n0\nPWM Duty Cycle\n'D3\nPWM Output\nNote\n1:   BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.\n3\n4\n5\n0\nBSF\nBCF\nWhen the timer count matches the T2PR period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a T2PR match or by software control the timer will stay in Reset until both the ON bit is set and the external signal is not at the Reset level.",
    "FIGURE 22-13: LEVEL-TRIGGERED HARDWARE LIMIT ONE-SHOT MODE TIMING DIAGRAM (MODE = 10110 )\nWhen Level Triggered Hardware Limit One-Shot modes are used in conjunction with the CCP PWM operation the PWM drive goes active with either the exter -nal signal edge or the setting of the ON bit, whichever of the two starts the timer.",
    "22.6 Timer2 Operation During Sleep\nWhen PSYNC = 1 ,  Timer2  cannot  be  operated  while the processor is in Sleep mode. The contents of the T2TMR  and  T2PR  registers  will  remain  unchanged while processor is in Sleep mode.\nWhen PSYNC = 0 , Timer2 will operate in Sleep as long as  the  clock  source  selected  is  also  still  running. Selecting the LFINTOSC, MFINTOSC, or HFINTOSC oscillator  as  the  timer  clock  source  will  keep  the selected oscillator running during Sleep.",
    "TABLE 22-2: OPERATING MODES\nLong bit name prefixes for the Timer2/4/6 peripherals are shown in Table 22-2. Refer to Section 1.3.2.2 'Long Bit Names' for more information.\nTimer2, Bit Name Prefix = T2. Timer4, Bit Name Prefix = T4. Timer6, Bit Name Prefix = T6",
    "REGISTER 22-1: TxCLK: TIMERx CLOCK SELECTION REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = . -, 5 = CS<3:0>. -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7-4 Unimplemented: Read as ' 0 '\nbit 3-0 CS<3:0>: Timerx Clock Selection bits",
    "Legend:\n1111, T2TMR.Clock Source = Reserved. 1111, TMR4.Clock Source = Reserved. 1111, TMR6.Clock Source = Reserved. 1110, T2TMR.Clock Source = CLC4_out. 1110, TMR4.Clock Source = CLC4_out. 1110, TMR6.Clock Source = CLC4_out. 1101, T2TMR.Clock Source = CLC3_out. 1101, TMR4.Clock Source = CLC3_out. 1101, TMR6.Clock Source = CLC3_out. 1100, T2TMR.Clock Source = CLC2_out. 1100, TMR4.Clock Source = CLC2_out. 1100, TMR6.Clock Source = CLC2_out. 1011, T2TMR.Clock Source = CLC1_out. 1011, TMR4.Clock Source = CLC1_out. 1011, TMR6.Clock Source = CLC1_out. 1010, T2TMR.Clock Source =",
    "Legend:\nZCD_OUT. 1010, TMR4.Clock Source = ZCD_OUT. 1010, TMR6.Clock Source = ZCD_OUT. 1001, T2TMR.Clock Source = NCO1OUT. 1001, TMR4.Clock Source = NCO1OUT. 1001, TMR6.Clock Source = NCO1OUT. 1000, T2TMR.Clock Source = CLKREF_OUT. 1000, TMR4.Clock Source = CLKREF_OUT. 1000, TMR6.Clock Source = CLKREF_OUT. 0111, T2TMR.Clock Source = SOSC. 0111, TMR4.Clock Source = SOSC. 0111, TMR6.Clock Source = SOSC. 0110, T2TMR.Clock Source = MFINTOSC (32 kHz). 0110, TMR4.Clock Source = MFINTOSC (32 kHz). 0110, TMR6.Clock Source = MFINTOSC (32 kHz). 0101, T2TMR.Clock Source = MFINTOSC (500",
    "Legend:\nkHz). 0101, TMR4.Clock Source = MFINTOSC (500 kHz). 0101, TMR6.Clock Source = MFINTOSC (500 kHz). 0100, T2TMR.Clock Source = LFINTOSC. 0100, TMR4.Clock Source = LFINTOSC. 0100, TMR6.Clock Source = LFINTOSC. 0011, T2TMR.Clock Source = HFINTOSC. 0011, TMR4.Clock Source = HFINTOSC. 0011, TMR6.Clock Source = HFINTOSC. 0010, T2TMR.Clock Source = FOSC. 0010, TMR4.Clock Source = FOSC. 0010, TMR6.Clock Source = FOSC. 0001, T2TMR.Clock Source = FOSC/4. 0001, TMR4.Clock Source = FOSC/4. 0001, TMR6.Clock Source = FOSC/4. 0000, T2TMR.Clock Source = Pin selected by T2INPPS.",
    "Legend:\n0000, TMR4.Clock Source = Pin selected by T4INPPS. 0000, TMR6.Clock Source = Pin selected by T6INPPS",
    "REGISTER 22-2: TxRST: TIMER2 EXTERNAL RESET SIGNAL SELECTION REGISTER\n-, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = RSEL<4:0>. -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 22-2: TxRST: TIMER2 EXTERNAL RESET SIGNAL SELECTION REGISTER\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-5 Unimplemented: Read as ' 0 '\nbit 4-0 RSEL<4:0>: Timer2 External Reset Signal Source Selection bits",
    "REGISTER 22-2: TxRST: TIMER2 EXTERNAL RESET SIGNAL SELECTION REGISTER\n11111 - 11001, T2TMR.Reset Source = Reserved. 11111 - 11001, TMR4.Reset Source = Reserved. 11111 - 11001, TMR6.Reset Source = Reserved. 11000, T2TMR.Reset Source = UART2_tx_edge. 11000, TMR4.Reset Source = UART2_tx_edge. 11000, TMR6.Reset Source = UART2_tx_edge. 10111, T2TMR.Reset Source = UART2_rx_edge. 10111, TMR4.Reset Source = UART2_rx_edge. 10111, TMR6.Reset Source = UART2_rx_edge. 10110, T2TMR.Reset Source = UART1_tx_edge. 10110, TMR4.Reset Source = UART1_tx_edge. 10110, TMR6.Reset Source = UART1_tx_edge. 10101, T2TMR.Reset Source =",
    "REGISTER 22-2: TxRST: TIMER2 EXTERNAL RESET SIGNAL SELECTION REGISTER\nUART1_rx_edge. 10101, TMR4.Reset Source = UART1_rx_edge. 10101, TMR6.Reset Source = UART1_rx_edge. 10100, T2TMR.Reset Source = CLC4_out. 10100, TMR4.Reset Source = CLC4_out. 10100, TMR6.Reset Source = CLC4_out. 10011, T2TMR.Reset Source = CLC3_out. 10011, TMR4.Reset Source = CLC3_out. 10011, TMR6.Reset Source = CLC3_out. 10010, T2TMR.Reset Source = CLC2_out. 10010, TMR4.Reset Source = CLC2_out. 10010, TMR6.Reset Source = CLC2_out. 10001, T2TMR.Reset Source = CLC1_out. 10001, TMR4.Reset Source = CLC1_out. 10001,",
    "REGISTER 22-2: TxRST: TIMER2 EXTERNAL RESET SIGNAL SELECTION REGISTER\nTMR6.Reset Source = CLC1_out. 10000, T2TMR.Reset Source = ZCD_OUT. 10000, TMR4.Reset Source = ZCD_OUT. 10000, TMR6.Reset Source = ZCD_OUT. 01111, T2TMR.Reset Source = CMP2OUT. 01111, TMR4.Reset Source = CMP2OUT. 01111, TMR6.Reset Source = CMP2OUT. 01110, T2TMR.Reset Source = CMP1OUT. 01110, TMR4.Reset Source = CMP1OUT. 01110, TMR6.Reset Source = CMP1OUT. 01101-01100, T2TMR.Reset Source = Reserved. 01101-01100, TMR4.Reset Source = Reserved. 01101-01100, TMR6.Reset Source = Reserved. 01011, T2TMR.Reset Source = PWM8OUT. 01011,",
    "REGISTER 22-2: TxRST: TIMER2 EXTERNAL RESET SIGNAL SELECTION REGISTER\nTMR4.Reset Source = PWM8OUT. 01011, TMR6.Reset Source = PWM8OUT. 01010, T2TMR.Reset Source = PWM7OUT. 01010, TMR4.Reset Source = PWM7OUT. 01010, TMR6.Reset Source = PWM7OUT. 01001, T2TMR.Reset Source = PWM6OUT. 01001, TMR4.Reset Source = PWM6OUT. 01001, TMR6.Reset Source = PWM6OUT. 01000, T2TMR.Reset Source = PWM5OUT. 01000, TMR4.Reset Source = PWM5OUT. 01000, TMR6.Reset Source = PWM5OUT. 00111, T2TMR.Reset Source = CCP4OUT. 00111, TMR4.Reset Source = CCP4OUT. 00111, TMR6.Reset Source =",
    "REGISTER 22-2: TxRST: TIMER2 EXTERNAL RESET SIGNAL SELECTION REGISTER\nCCP4OUT. 00110, T2TMR.Reset Source = CCP3OUT. 00110, TMR4.Reset Source = CCP3OUT. 00110, TMR6.Reset Source = CCP3OUT. 00101, T2TMR.Reset Source = CCP2OUT. 00101, TMR4.Reset Source = CCP2OUT. 00101, TMR6.Reset Source = CCP2OUT. 00100, T2TMR.Reset Source = CCP1OUT. 00100, TMR4.Reset Source = CCP1OUT. 00100, TMR6.Reset Source = CCP1OUT. 00011, T2TMR.Reset Source = TMR6 postscaled. 00011, TMR4.Reset Source = TMR6 postscaled. 00011, TMR6.Reset Source = Reserved. 00010, T2TMR.Reset Source = TMR4 postscaled. 00010, TMR4.Reset Source = Reserved. 00010, TMR6.Reset",
    "REGISTER 22-2: TxRST: TIMER2 EXTERNAL RESET SIGNAL SELECTION REGISTER\nSource = TMR4 postscaled. 00001, T2TMR.Reset Source = Reserved. 00001, TMR4.Reset Source = T2TMR postscaled. 00001, TMR6.Reset Source = T2TMR postscaled. 00000, T2TMR.Reset Source = Pin selected by T2INPPS. 00000, TMR4.Reset Source = Pin selected by T4INPPS. 00000, TMR6.Reset Source = Pin selected by T6INPPS",
    "REGISTER 22-3: TxTMR: TIMERx COUNTER REGISTER\nbit 7, R/W-0/0.TMRx<7:0> = . bit 7, R/W-0/0.TMRx<7:0> = . bit 7, R/W-0/0.TMRx<7:0> = . bit 7, R/W-0/0.TMRx<7:0> = . bit 7, R/W-0/0.TMRx<7:0> = . bit 7, R/W-0/0.TMRx<7:0> = . bit 7, R/W-0/0.TMRx<7:0> = bit 0",
    "REGISTER 22-3: TxTMR: TIMERx COUNTER REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = \nbit 7-0 TMRx<7:0>:\nTimerx Counter bits",
    "REGISTER 22-4: TxPR: TIMERx PERIOD REGISTER\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. PRx<7:0>, 1 = PRx<7:0>. PRx<7:0>, 2 = PRx<7:0>. PRx<7:0>, 3 = PRx<7:0>. PRx<7:0>, 4 = PRx<7:0>. PRx<7:0>, 5 = PRx<7:0>. PRx<7:0>, 6 = PRx<7:0>. PRx<7:0>, 7 =",
    "REGISTER 22-4: TxPR: TIMERx PERIOD REGISTER\nPRx<7:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-0 PRx<7:0>: Timerx Period Register bits",
    "REGISTER 22-5: TxCON: TIMERx CONTROL REGISTER\nR/W/HC-0/0, 1 = R/W-0/0. R/W/HC-0/0, 2 = R/W-0/0. R/W/HC-0/0, 3 = R/W-0/0. R/W/HC-0/0, 4 = R/W-0/0. R/W/HC-0/0, 5 = R/W-0/0. R/W/HC-0/0, 6 = R/W-0/0. R/W/HC-0/0, 7 = R/W-0/0. ON, 1 = CKPS<2:0>. ON, 2 = CKPS<2:0>. ON, 3 = CKPS<2:0>. ON, 4 = OUTPS<3:0>. ON, 5 = OUTPS<3:0>. ON, 6 = OUTPS<3:0>. ON, 7 = OUTPS<3:0>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit",
    "REGISTER 22-5: TxCON: TIMERx CONTROL REGISTER\n7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = HC = Bit is cleared by hardware",
    "bit 7\nON: Timerx On bit (1)\n1 = Timerx is On\n0 = Timerx is Off: all counters and state machines are reset\nbit 6-4\nCKPS<2:0>: Timerx-type Clock Prescale Select bits\n111 = 1:128 Prescaler\n110 = 1:64 Prescaler\n101 = 1:32 Prescaler\n100 = 1:16 Prescaler\n011 = 1:8 Prescaler\n010 = 1:4 Prescaler\n001 = 1:2 Prescaler\n000 = 1:1 Prescaler\nbit 3-0\nOUTPS<3:0>: Timerx Output Postscaler Select bits\n1111 = 1:16 Postscaler\n1110 = 1:15 Postscaler\n1101 = 1:14 Postscaler\n1100 = 1:13 Postscaler\n1011 = 1:12 Postscaler\n1010 = 1:11 Postscaler\n1001 = 1:10 Postscaler\n1000 = 1:9 Postscaler\n0111 = 1:8 Postscaler\n0110 = 1:7 Postscaler\n0101 = 1:6 Postscaler\n0100 = 1:5 Postscaler\n0011 = 1:4 Postscaler",
    "bit 7\n0010 = 1:3 Postscaler\n0001 = 1:2 Postscaler\n0000 = 1:1 Postscaler\nNote 1: In certain modes, the ON bit will be auto-cleared by hardware. See Section 22.1.2 'One-Shot Mode' .",
    "REGISTER 22-6: TxHLT: TIMERx HARDWARE LIMIT CONTROL REGISTER\nPSYNC, R/W-0/0 = CKPOL. PSYNC, R/W-0/0 = CKSYNC. PSYNC, R/W-0/0 = . PSYNC, R/W-0/0 = . PSYNC, R/W-0/0 = MODE<4:0>. PSYNC, R/W-0/0 = . PSYNC, R/W-0/0 = . bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 22-6: TxHLT: TIMERx HARDWARE LIMIT CONTROL REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, = Unimplemented bit, read as '0' = U -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = . '1' = Bit is set, = Unimplemented bit, read as '0' = . , W=Writable bit = '0' = Bit is cleared. , = Unimplemented bit, read as '0' = \nbit 7\nPSYNC: Timerx Prescaler Synchronization Enable bit (1, 2)\n1 = TxTMR Prescaler Output is synchronized to Fosc/4\n0 = TxTMR Prescaler Output is not synchronized to Fosc/4\nbit 6\nCKPOL: Timerx Clock Polarity Selection bit (3)\n1 = Falling edge of input clock clocks timer/prescaler\n0 = Rising edge of input clock clocks timer/prescaler\nbit 5",
    "REGISTER 22-6: TxHLT: TIMERx HARDWARE LIMIT CONTROL REGISTER\nCKSYNC: Timerx Clock Synchronization Enable bit (4, 5)\n1 = ON register bit is synchronized to T2TMR_clk input\n0 = ON register bit is not synchronized to T2TMR_clk input\nbit 4-0\nMODE<4:0>: Timerx Control Mode Selection bits (6, 7)\nSee Table 22-1 for all operating modes.",
    "Note 1: Setting this bit ensures that reading TxTMR will return a valid data value.\n2: When this bit is ' 1 ', Timer2 cannot operate in Sleep mode.\n3: CKPOL should not be changed while ON = 1 .\n4: Setting this bit ensures glitch-free operation when the ON is enabled or disabled.\n5: When this bit is set then the timer operation will be delayed by two TxTMR input clocks after the ON bit is set.\n6: Unless otherwise indicated, all modes start upon ON = 1 and stop upon ON = 0 (stops occur without affecting the value of TxTMR).\n7: When TxTMR = TxPR, the next clock clears TxTMR, regardless of the operating mode.",
    "TABLE 22-3: SUMMARY OF REGISTERS ASSOCIATED WITH TIMER2\nTxPR, Bit 7 = Timer2 Module Period Register. TxPR, Bit 6 = Timer2 Module Period Register. TxPR, Bit 5 = Timer2 Module Period Register. TxPR, Bit 4 = Timer2 Module Period Register. TxPR, Bit 3 = Timer2 Module Period Register. TxPR, Bit 2 = Timer2 Module Period Register. TxPR, Bit 1 = Timer2 Module Period Register. TxPR, Bit 0 = Timer2 Module Period Register. TxPR, Register on Page = 306*. TxTMR, Bit 7 = Holding Register for the 8-bit T2TMR Register. TxTMR, Bit 6 = Holding Register for the 8-bit T2TMR Register. TxTMR, Bit 5 = Holding Register for the 8-bit T2TMR Register. TxTMR, Bit 4 = Holding Register for the 8-bit T2TMR Register. TxTMR, Bit 3 = Holding Register for the 8-bit T2TMR Register. TxTMR, Bit 2 = Holding Register for the 8-bit T2TMR Register. TxTMR, Bit 1 = Holding Register for the 8-bit T2TMR",
    "TABLE 22-3: SUMMARY OF REGISTERS ASSOCIATED WITH TIMER2\nRegister. TxTMR, Bit 0 = Holding Register for the 8-bit T2TMR Register. TxTMR, Register on Page = 306*. TxCON, Bit 7 = ON. TxCON, Bit 6 = CKPS<2:0>. TxCON, Bit 5 = CKPS<2:0>. TxCON, Bit 4 = CKPS<2:0>. TxCON, Bit 3 = CKPS<2:0>. TxCON, Bit 2 = OUTPS<3:0>. TxCON, Bit 1 = OUTPS<3:0>. TxCON, Bit 0 = OUTPS<3:0>. TxCON, Register on Page = 324. TxCLK, Bit 7 = -. TxCLK, Bit 6 = -. TxCLK, Bit 5 = -. TxCLK, Bit 4 = -. TxCLK, Bit 3 = -. TxCLK, Bit 2 = CS<2:0>. TxCLK, Bit 1 = CS<2:0>. TxCLK, Bit 0 = CS<2:0>. TxCLK, Register on Page =",
    "TABLE 22-3: SUMMARY OF REGISTERS ASSOCIATED WITH TIMER2\n321. TxRST, Bit 7 = -. TxRST, Bit 6 = -. TxRST, Bit 5 = -. TxRST, Bit 4 = -. TxRST, Bit 3 = RSEL<3:0>. TxRST, Bit 2 = RSEL<3:0>. TxRST, Bit 1 = RSEL<3:0>. TxRST, Bit 0 = RSEL<3:0>. TxRST, Register on Page = 322. TxHLT, Bit 7 = PSYNC. TxHLT, Bit 6 = CPOL. TxHLT, Bit 5 = CSYNC. TxHLT, Bit 4 = MODE<4:0>. TxHLT, Bit 3 = MODE<4:0>. TxHLT, Bit 2 = MODE<4:0>. TxHLT, Bit 1 = MODE<4:0>. TxHLT, Bit 0 = MODE<4:0>. TxHLT, Register on Page = 325\nLegend:\n- = unimplemented location, read as ' 0 '. Shaded cells are not used for Timer2 module.\n- * Page provides register information.",
    "23.0 CAPTURE/COMPARE/PWM MODULE\nThe  Capture/Compare/PWM  module  is  a  peripheral that allows the user to time and control different events, and to generate Pulse-Width Modulation (PWM) signals.  In  Capture  mode,  the  peripheral  allows  the timing of the duration of an event. The Compare mode allows  the  user  to  trigger  an  external  event  when  a predetermined amount of time has expired. The PWM mode can generate pulse-width modulated signals of varying frequency and duty cycle.\nThis family of devices contains four standard Capture/ Compare/PWM  modules  (CCP1,  CCP2,  CCP3  and CCP4).  Each  individual  CCP  module  can  select  the timer  source  that  controls  the  module.  Each  module has  an  independent  timer  selection  which  can  be accessed  using  the  CxTSEL  bits  in  the  CCPTMRS0 register (Register 23-2). The default timer selection is TMR1 when using Capture/Compare mode and TMR2 when using PWM mode in the CCPx module.",
    "23.0 CAPTURE/COMPARE/PWM MODULE\nPlease note that the Capture/Compare mode operation is described with respect to TMR1 and the PWM mode operation  is  described  with  respect  to  TMR2  in  the following sections.\nThe Capture and Compare functions are identical for all CCP modules.\nNote 1: In devices  with  more  than  one  CCP module, it is very important to pay close attention  to  the  register  names  used. A number placed after the module acronym is used to distinguish between separate modules.  For  example,  the  CCP1CON and CCP2CON control the same operational  aspects  of  two  completely different CCP modules.\n2: Throughout this section, generic references to a CCP module in any of its operating  modes  may  be  interpreted  as being equally applicable to CCPx module. Register names, module signals, I/O pins, and  bit names  may  use  the  generic designator  'x'  to  indicate  the  use  of  a numeral to distinguish a particular module, when required.",
    "23.1 CCP Module Configuration\nEach  Capture/Compare/PWM  module  is  associated with  a  control  register  (CCPxCON),  a  capture  input selection  register  (CCPxCAP)  and  a  data  register (CCPRx). The data register, in turn, is comprised of two 8-bit registers: CCPRxL (low byte) and CCPRxH (high byte).",
    "23.1.1 CCP MODULES AND TIMER RESOURCES\nThe CCP modules utilize Timers 1 through 6 that vary with the selected mode. Various timers are available to the  CCP  modules  in  Capture,  Compare  or  PWM modes, as shown in Table 23-1.\nTABLE 23-1: CCP MODE - TIMER RESOURCE\n\nCapture Compare, Timer Resource = Timer1, Timer3 or Timer5. PWM, Timer Resource = Timer2, Timer4 or Timer6\nThe  assignment  of  a  particular  timer  to  a  module  is determined  by  the  timer  to  CCP  enable  bits  in  the CCPTMRS0  register  (see  Register 23-2)  All  of  the modules  may  be  active  at  once  and  may  share  the same timer resource if they are configured to operate in the same mode (Capture/Compare or PWM) at the same time.",
    "23.1.2 OPEN-DRAIN OUTPUT OPTION\nWhen operating in Output mode (the Compare or PWM modes), the drivers for the CCPx pins can be optionally configured as open-drain outputs. This feature allows the voltage level on the pin to be pulled to a higher level through  an  external  pull-up  resistor  and  allows  the output to communicate with external circuits without the need for additional level shifters.",
    "23.2 Capture Mode\nCapture mode  makes  use of the 16-bit Timer1 resource.  When  an  event  occurs  on  the  capture source, the 16-bit CCPRxH:CCPRxL  register  pair captures and stores the 16-bit value of the TMRxH:TMRxL register pair, respectively. An event is defined as one of the following and is configured by the MODE<3:0> bits of the CCPxCON register:\n\u00b7 Every falling edge of CCPx input\n\u00b7 Every rising edge of CCPx input\n\u00b7 Every 4th rising edge of CCPx input\n\u00b7 Every 16th rising edge of CCPx input\n\u00b7 Every edge of CCPx input (rising or falling)\nWhen a capture is made, the Interrupt Request Flag bit CCPxIF of the respective PIR register is set. The inter -rupt flag must be cleared in software. If another capture occurs before the value in the CCPRxH:CCPRxL reg -ister pair is read, the old captured value is overwritten by the new captured value.\nNote:",
    "23.2 Capture Mode\nIf  an  event  occurs  during  a  2-byte  read, the  high  and  low-byte  data  will  be  from different events. It is recommended while reading  the  CCPRxH:CCPRxL  register pair to either disable the module or read the register pair twice for data integrity.\nFigure 23-1 shows a simplified diagram of the capture operation.",
    "23.2.1 CAPTURE SOURCES\nIn Capture mode, the CCPx pin should be configured as an input by setting the associated TRIS control bit.",
    "Note:\nIf the CCPx pin is configured as an output, a  write  to  the  port  can  cause  a  capture condition.\nThe  capture  source  is  selected  by  configuring  the CTS<2:0>  bits  of  the  CCPxCAP  register.  Refer  to CCPxCAP register (Register 23-4) for a list of sources that can be selected.",
    "23.2.2 TIMER1 MODE RESOURCE\nTimer1 must be running in Timer mode or Synchronized Counter mode for the CCP module to use the capture feature.  In Asynchronous  Counter  mode,  the  capture operation may not work.\n- \u00b7 See Section 21.0 'Timer1/3/5 Module with Gate Control' for more information on configuring Timer1.",
    "Note:\nClocking  Timer1  from  the  system  clock (FOSC)  should  not  be  used  in  Capture mode.  In  order  for Capture  mode  to recognize the trigger event on the CCPx pin,  Timer1  must  be  clocked  from  the instruction clock (FOSC/4)  or from  an external clock source.",
    "23.2.3 SOFTWARE INTERRUPT MODE\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep the CCPxIE  Interrupt  Priority  bit  of  the  respective  PIE register clear to avoid false interrupts. Additionally, the user should clear the CCPxIF interrupt flag bit of the respective PIR register following any change in Operating mode.",
    "23.2.4 CAPTURE DURING SLEEP\nCapture  mode  depends  upon  the  Timer1  module  for proper operation. There are  two options for driving the Timer1 module in Capture mode. It can be driven by the instruction clock (FOSC/4), or by an external clock source.\nWhen Timer1  is  clocked  by  FOSC/4,  Timer1  will  not increment during Sleep. When the device wakes from Sleep, Timer1 will continue from its previous state.\nCapture mode will operate during Sleep as long as the clock source for Timer1 is active in Sleep.",
    "23.3 Compare Mode\nCompare  mode  makes  use  of  the  16-bit  Timer1 resource.  The  16-bit  value  of  the  CCPRxH:CCPRxL register pair is constantly compared against the 16-bit value  of  the  TMRxH:TMRxL  register  pair.  When  a match occurs, one of the following events can occur:\n\u00b7 Toggle the CCPx output, clear TMRx\n\u00b7 Toggle the CCPx output\n\u00b7 Set the CCPx output\n\u00b7 Clear the CCPx output\n\u00b7 Pulse output\n\u00b7 Pulse output, clear TMRx\nThe  action  on  the  pin  is  based  on  the  value  of  the MODE<3:0> control bits of the CCPxCON register. At the same time, the interrupt flag CCPxIF bit is set, and an ADC conversion can be triggered, if selected.\nAll  Compare  modes  can  generate  an  interrupt  and trigger an ADC conversion. When MODE = 0b0001 or 0b1011 , the CCP resets the TMR register pair.\nFigure 23-2 shows a simplified diagram of the compare operation.",
    "23.3.1 CCPx PIN CONFIGURATION\nThe software must configure the CCPx pin as an output by  clearing  the  associated TRIS  bit  and  defining  the appropriate output pin through the RxyPPS registers. See Section 17.0 'Peripheral Pin Select (PPS) Module' for more details.\nNote:\nClearing the CCPxCON register will force the  CCPx  compare  output  latch  to  the default low level. This is not the PORT I/O data latch.",
    "23.3.2 TIMER1 MODE RESOURCE\nIn  Compare mode, Timer1 must be running in either Timer  mode  or  Synchronized  Counter  mode.  The compare  operation  may  not  work  in  Asynchronous Counter mode.\nSee Section  21.0 'Timer1/3/5  Module  with  Gate Control' for more information on configuring Timer1.\nNote:\nClocking  Timer1  from  the  system  clock (FOSC)  should  not  be  used  in  Compare mode.  In  order  for  Compare  mode  to recognize the trigger event on the CCPx pin,  TImer1  must  be  clocked  from  the instruction clock (FOSC/4) or from an external clock source.",
    "23.3.3 AUTO-CONVERSION TRIGGER\nAll CCPx modes set the CCP interrupt flag (CCPxIF). When this  flag  is  set  and  a  match  occurs,  an  autoconversion trigger can take place if the CCP module is selected as the conversion trigger source.\nRefer to Section 37.2.5 'Auto-Conversion Trigger' for more information.\nNote:\nRemoving the match condition by changing  the  contents  of  the  CCPRxH and  CCPRxL  register  pair,  between  the clock edge that generates the  Autoconversion  Trigger  and  the  clock  edge that generates  the  Timer1  Reset,  will preclude the Reset from occurring",
    "23.3.4 COMPARE DURING SLEEP\nSince  FOSC  is  shut  down  during  Sleep  mode,  the Compare mode will not function properly during Sleep, unless the timer is  running. The device  will wake  on interrupt (if enabled).",
    "23.4 PWM Overview\nPulse-Width Modulation (PWM)  is a scheme  that provides power to a load by switching quickly between fully ON  and  fully OFF  states.  The PWM  signal resembles a square wave where the high portion of the signal is considered the ON state and the low portion of the signal is considered the OFF state. The high portion, also known as the pulse width, can vary in time and is defined in steps. A larger number of steps applied, which lengthens the pulse width, also supplies more power to the load. Lowering the number of steps applied, which shortens the pulse width, supplies less power. The PWM period is defined as the duration of one complete cycle or the total amount of on and off time combined.\nPWM resolution defines the maximum number of steps that can be present in a single PWM period. A higher resolution allows for more precise control of the pulsewidth time and in turn the power that is applied to the load.",
    "23.4 PWM Overview\nThe term duty cycle describes the proportion of the on time to the off time and is expressed in percentages, where 0% is fully off and 100% is fully on. A lower duty cycle corresponds to less power applied and a higher duty cycle corresponds to more power applied.\nFigure 23-3  shows  a  typical  waveform  of  the  PWM signal.",
    "23.4.1 STANDARD PWM OPERATION\nThe  standard  PWM  mode  generates  a  Pulse-Width Modulation (PWM) signal on the CCPx pin with up to ten  bits  of  resolution.  The  period,  duty  cycle,  and resolution are controlled by the following registers:\n\u00b7 T2PR registers\n\u00b7 T2CON registers\n\u00b7 CCPRxL and CCPRxH registers\n\u00b7 CCPxCON registers\nIt  is  required  to  have  FOSC/4  as  the  clock  input  to TMR2/4/6  for  correct  PWM  operation.  Figure 23-4 shows a simplified block diagram of PWM operation.\nNote:\nThe  corresponding  TRIS  bit must  be cleared to enable the PWM output on the CCPx pin.",
    "23.4.2 SETUP FOR PWM OPERATION\nThe following steps should be taken when configuring the CCP module for standard PWM operation:",
    "23.4.2 SETUP FOR PWM OPERATION\n1. Use the desired output pin RxyPPS control to select  CCPx  as  the  source  and  disable  the CCPx pin output driver by setting the associated TRIS bit.\n2. Load  the  T2PR  register  with  the  PWM  period value.\n3. Configure the CCP module for the PWM mode by  loading  the  CCPxCON  register  with  the appropriate values.\n4. Load  the  CCPRxL  register,  and  the  CCPRxH register  with  the  PWM  duty  cycle  value  and configure the FMT bit of the CCPxCON register to set the proper register alignment.\n5. Configure and start Timer2:\n\u00b7 Clear the TMR2IF interrupt flag bit of the respective PIR register. See Note below.\n\u00b7 Select the timer clock source to be as FOSC/4 using the T2CLK register. This is required for correct operation of the PWM module.\n\u00b7 Configure the CKPS bits of the T2CON register with the Timer prescale value.\n\u00b7 Enable the Timer by setting the ON bit of the T2CON register.",
    "23.4.2 SETUP FOR PWM OPERATION\n6. Enable PWM output pin:\n\u00b7 Wait until the Timer overflows and the TMR2IF bit of the PIR4 register is set. See Note below.\n\u00b7 Enable the CCPx pin output driver by clearing the associated TRIS bit.\nNote:\nIn order to send a complete duty cycle and period on the first PWM output, the above steps must  be  included in the setup sequence. If it is not critical to start with a complete PWM signal on the first output, then step 6 may be ignored.",
    "23.4.3 TIMER2 TIMER RESOURCE\nThe  PWM  standard  mode  makes  use  of  the  8-bit Timer2 timer resources to specify the PWM period.",
    "23.4.4 PWM PERIOD\nThe PWM period is specified by the T2PR register of Timer2. The PWM period can be calculated using the formula of Equation 23-1.",
    "EQUATION 23-1: PWM PERIOD\nPW M   Pe r i od T2PR \uf028 \uf029 1 + \uf05b \uf05d \uf0b7 4 TOSC \uf0b7 \uf0b7 = ( TM R2  Pr e s c al e   al e ) V u Note 1: TOSC = 1/FOSC\nWhen T2TMR is  equal  to  T2PR,  the  following  three events occur on the next increment cycle:\n\u00b7 T2TMR is cleared\n\u00b7 The CCPx pin is set. (Exception: If the PWM duty cycle = 0%, the pin will not be set.)\n\u00b7 The PWM duty cycle is transferred from the CCPRxL/H register pair into a 10-bit buffer.\nNote:\nThe Timer postscaler (see Section 22.3 'External  Reset  Sources' )  is  not used  in  the  determination  of  the  PWM frequency.",
    "23.4.5 PWM DUTY CYCLE\nThe PWM duty cycle is  specified  by  writing  a  10-bit value  to the CCPRxH:CCPRxL  register  pair.  The alignment of the 10-bit value is determined by the FMT bit  of  the  CCPxCON  register  (see  Figure 23-5).  The CCPRxH:CCPRxL register pair can be written to at any time; however the duty cycle value is not latched into the 10-bit buffer until after a match between T2PR and T2TMR.\nEquation 23-2  is  used  to  calculate  the  PWM  pulse width. Equation 23-3 is used to calculate the PWM duty cycle ratio.",
    "EQUATION 23-2: PULSE WIDTH\nPul s e W i dt h CCPRxH: CCPRxL  r egi s t e r   pai r \uf028 \uf029 \uf0b7 =\nTOSC TM R2  Pr e s c al e   al u e ) \uf0b7 ( V",
    "EQUATION 23-3: DUTY CYCLE RATIO\nDut y   Cy c l   at i eR o =\nCCPRxH: CCPRxL  r e gi s t e r   pai r \uf028 \uf029 - - - - - - - - - - - - - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - ---------------------------\n4 T2PR + 1\n\uf028\n\uf029\nCCPRxH:CCPRxL  register  pair  are  used  to  double buffer  the  PWM  duty  cycle.  This  double  buffering provides glitchless PWM operation.\nThe  8-bit  timer  T2TMR  register  is  concatenated  with either the 2-bit internal system clock (FOSC), or two bits of  the  prescaler,  to  create  the  10-bit  time  base.  The system clock is used if the Timer2 prescaler is set to 1:1.",
    "EQUATION 23-3: DUTY CYCLE RATIO\nWhen the 10-bit time base matches the CCPRxH:CCPRxL register pair, then the CCPx pin is cleared (see Figure 23-4).",
    "23.4.6 PWM RESOLUTION\nThe resolution determines the number of available duty cycles for a given period. For example, a 10-bit resolution will result in 1024 discrete duty cycles, whereas an 8-bit resolution will result in 256 discrete duty cycles.\nThe maximum PWM resolution is ten bits when T2PR is 255. The resolution is a function of the T2PR register value as shown by Equation 23-4.",
    "EQUATION 23-4: PWM RESOLUTION\n<!-- formula-not-decoded -->\nNote:\nIf the pulse-width value is greater than the assigned  PWM  pin(s)  will period, the remain unchanged.",
    "TABLE 23-2: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS (FOSC = 20 MHz)\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.88 kHz = 4. Timer Prescale, 19.53 kHz = 1. Timer Prescale, 78.12 kHz = 1. Timer Prescale, 156.3 kHz = 1. Timer Prescale, 208.3 kHz = 1. T2PR Value, 1.22 kHz = 0xFF. T2PR Value, 4.88 kHz = 0xFF. T2PR Value, 19.53 kHz = 0xFF. T2PR Value, 78.12 kHz = 0x3F. T2PR Value, 156.3 kHz = 0x1F. T2PR Value, 208.3 kHz = 0x17. Maximum Resolution (bits), 1.22 kHz = 10. Maximum Resolution (bits), 4.88 kHz = 10. Maximum Resolution (bits), 19.53 kHz = 10. Maximum Resolution (bits), 78.12 kHz = 8. Maximum Resolution (bits), 156.3 kHz = 7. Maximum Resolution (bits), 208.3 kHz =",
    "TABLE 23-2: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS (FOSC = 20 MHz)\n6.6",
    "TABLE 23-3: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS (FOSC = 8 MHz)\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.90 kHz = 4. Timer Prescale, 19.61 kHz = 1. Timer Prescale, 76.92 kHz = 1. Timer Prescale, 153.85 kHz = 1. Timer Prescale, 200.0 kHz = 1. T2PR Value, 1.22 kHz = 0x65. T2PR Value, 4.90 kHz = 0x65. T2PR Value, 19.61 kHz = 0x65. T2PR Value, 76.92 kHz = 0x19. T2PR Value, 153.85 kHz = 0x0C. T2PR Value, 200.0 kHz = 0x09. Maximum Resolution (bits), 1.22 kHz = 8. Maximum Resolution (bits), 4.90 kHz = 8. Maximum Resolution (bits), 19.61 kHz = 8. Maximum Resolution (bits), 76.92 kHz = 6. Maximum Resolution (bits), 153.85 kHz = 5. Maximum Resolution (bits), 200.0 kHz = 5",
    "23.4.7 OPERATION IN SLEEP MODE\nIn Sleep mode, the T2TMR register will not increment and the state of the module will not change. If the CCPx pin is driving a value, it will continue to drive that value. When the device wakes up, T2TMR will continue from its previous state.",
    "23.4.8 CHANGES IN SYSTEM CLOCK FREQUENCY\nThe PWM frequency is derived from the system clock frequency. Any changes in the system clock frequency will result in changes to the PWM frequency. See Sec -tion  7.0 'Oscillator  Module  (with  Fail-Safe  Clock Monitor)' for additional details.",
    "23.4.9 EFFECTS OF RESET\nAny Reset will force all  ports  to Input  mode  and  the CCP registers to their Reset states.",
    "23.5 Register Definitions: CCP Control\nLong  bit  name  prefixes  for  the  CCP  peripherals  are shown  below.  Refer  to Section  1.3.2.2 'Long  Bit Names' for more information.\nCCP1, Bit Name Prefix = CCP1. CCP2, Bit Name Prefix = CCP2. CCP3, Bit Name Prefix = CCP3. CCP4, Bit Name Prefix = CCP4",
    "REGISTER 23-1: CCPxCON: CCPx CONTROL REGISTER\nEN, U-0 = -. EN, R-x = OUT. EN, R/W-0/0 = FMT. EN, R/W-0/0 = . EN, R/W-0/0 = MODE<3:0>. EN, R/W-0/0 = . EN, R/W-0/0 = . bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R-x = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0",
    "REGISTER 23-1: CCPxCON: CCPx CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nEN: CCP Module Enable bit\n1 = CCP is enabled\n0 = CCP is disabled\nbit 6\nUnimplemented: Read as ' 0 '\nbit 5\nOUT: CCPx Output Data bit (read-only)\nbit 4\nFMT: CCPW (pulse-width) Alignment bit\nMODE = Capture mode:\nUnused\nMODE = Compare mode:\nUnused\nMODE = PWM mode:\n1 = Left-aligned format\n0 = Right-aligned format",
    "bit 3-0\nMODE<3:0>: CCPx Mode Select bits",
    "bit 3-0\n11xx, Operating Mode = PWM. 11xx, Operation = PWM operation. 11xx, Set CCPxIF = Yes. 1011, Operating Mode = Compare. 1011, Operation = Pulse output; clear TMR1 (2). 1011, Set CCPxIF = Yes. 1010, Operating Mode = Compare. 1010, Operation = Pulse output. 1010, Set CCPxIF = Yes. 1001, Operating Mode = Compare. 1001, Operation = Clear output (1). 1001, Set CCPxIF = Yes. 1000, Operating Mode = Compare. 1000, Operation = Set output (1). 1000, Set CCPxIF = Yes. 0111, Operating Mode = Capture. 0111, Operation = Every 16th rising edge of CCPx input. 0111, Set CCPxIF = Yes. 0110, Operating Mode = Capture. 0110, Operation = Every 4th rising edge of CCPx input. 0110, Set CCPxIF = Yes. 0101, Operating Mode = Capture. 0101, Operation = Every rising edge of CCPx input. 0101, Set CCPxIF = Yes.",
    "bit 3-0\n0100, Operating Mode = Capture. 0100, Operation = Every falling edge of CCPx input. 0100, Set CCPxIF = Yes. 0011, Operating Mode = Capture. 0011, Operation = Every edge of CCPx input. 0011, Set CCPxIF = Yes. 0010, Operating Mode = Compare. 0010, Operation = Toggle output. 0010, Set CCPxIF = Yes. 0001, Operating Mode = Compare. 0001, Operation = Toggle output; clear TMR1 (2). 0001, Set CCPxIF = Yes. 0000, Operating Mode = Disabled. 0000, Operation = . 0000, Set CCPxIF = -\nNote 1: The set and clear operations of the Compare mode are reset by setting MODE = 4'b0000 or EN = 0 .\n2: When MODE = 0001 or 1011 , then the timer associated with the CCP module is cleared. TMR1 is the default selection for the CCP module, so it is used for indication purpose only.",
    "bit 5-4\nbit 3-2\nbit 1-0",
    "REGISTER 23-2: CCPTMRS0: CCP TIMERS CONTROL REGISTER 0\nC4TSEL<1:0>, R/W-1/1 = C4TSEL<1:0>. C4TSEL<1:0>, R/W-0/0 = C3TSEL<1:0>. C4TSEL<1:0>, R/W-1/1 = C3TSEL<1:0>. C4TSEL<1:0>, R/W-0/0 = C2TSEL<1:0>. C4TSEL<1:0>, R/W-1/1 = C2TSEL<1:0>. C4TSEL<1:0>, R/W-0/0 = C1TSEL<1:0>. C4TSEL<1:0>, R/W-1/1 = C1TSEL<1:0>. bit 7, R/W-1/1 = bit 0. bit 7, R/W-0/0 = bit 0. bit 7, R/W-1/1 = bit 0. bit 7,",
    "REGISTER 23-2: CCPTMRS0: CCP TIMERS CONTROL REGISTER 0\nR/W-0/0 = bit 0. bit 7, R/W-1/1 = bit 0. bit 7, R/W-0/0 = bit 0. bit 7, R/W-1/1 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-6\nC4TSEL<1:0>: CCP4 Timer Selection bits\n11 = CCP4 is based off Timer5 in Capture/Compare mode and Timer6 in PWM mode",
    "REGISTER 23-2: CCPTMRS0: CCP TIMERS CONTROL REGISTER 0\n10 = CCP4 is based off Timer3 in Capture/Compare mode and Timer4 in PWM mode\n01 = CCP4 is based off Timer1 in Capture/Compare mode and Timer2 in PWM mode\n00 = Reserved",
    "C3TSEL<1:0>: CCP3 Timer Selection bits\n- 11 = CCP3 is based off Timer5 in Capture/Compare mode and Timer6 in PWM mode\n10 = CCP3 is based off Timer3 in Capture/Compare mode and Timer4 in PWM mode\n= CCP3 is based off Timer1 in Capture/Compare mode and Timer2 in PWM mode\n- 01 00 = Reserved\nC2TSEL<1:0>: CCP2 Timer Selection bits\n- 11 = CCP2 is based off Timer5 in Capture/Compare mode and Timer6 in PWM mode\n10 = CCP2 is based off Timer3 in Capture/Compare mode and Timer4 in PWM mode\n01 = CCP2 is based off Timer1 in Capture/Compare mode and Timer2 in PWM mode\n00 = Reserved\nC1TSEL<1:0>: CCP1 Timer Selection bits",
    "C3TSEL<1:0>: CCP3 Timer Selection bits\n11 = CCP1 is based off Timer5 in Capture/Compare mode and Timer6 in PWM mode\n10 = CCP1 is based off Timer3 in Capture/Compare mode and Timer4 in PWM mode\n01 = CCP1 is based off Timer1 in Capture/Compare mode and Timer2 in PWM mode\n00 = Reserved",
    "REGISTER 23-3: CCPTMRS1: CCP TIMERS CONTROL REGISTER 1\nR/W-0/0, 1 = R/W-1/1. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-1/1. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-1/1. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-1/1. P8TSEL<1:0>, 1 = P8TSEL<1:0>. P8TSEL<1:0>, 2 = P7TSEL<1:0>. P8TSEL<1:0>, 3 = P7TSEL<1:0>. P8TSEL<1:0>, 4 = P6TSEL<1:0>. P8TSEL<1:0>, 5 = P6TSEL<1:0>.",
    "REGISTER 23-3: CCPTMRS1: CCP TIMERS CONTROL REGISTER 1\nP8TSEL<1:0>, 6 = P5TSEL<1:0>. P8TSEL<1:0>, 7 = P5TSEL<1:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-6 P8TSEL<1:0>: PWM8 Timer Selection bits\n11 = PWM8 based on TMR8\n10 = PWM8 based on TMR6\n01 = PWM8 based on TMR4\n00 = PWM8 based on TMR2",
    "bit 5-4 P7TSEL<1:0>: PWM7 Timer Selection bits\n11 = PWM7 based on TMR8\n10 = PWM7 based on TMR6\n01 = PWM7 based on TMR4\n00 = PWM7 based on TMR2",
    "bit 3-2 P6TSEL<1:0>: PWM6 Timer Selection bits\n11 = PWM6 based on TMR8\n10 = PWM6 based on TMR6\n01 = PWM6 based on TMR4\n00 = PWM6 based on TMR2",
    "bit 1-0\nP5TSEL<1:0>: PWM5 Timer Selection bits\n11 = PWM5 based on TMR8\n10 = PWM5 based on TMR6\n01 = PWM5 based on TMR4\n00 = PWM5 based on TMR2",
    "REGISTER 23-4: CCPxCAP: CAPTURE INPUT SELECTION MULTIPLEXER REGISTER\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-0/x = . -, R/W-0/x = CTS<3:0>. -, R/W-0/x = . -, R/W-0/x = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/x = bit 7. bit 7, R/W-0/x = bit 7. bit 7, R/W-0/x = bit 7. bit 7, R/W-0/x = bit 0",
    "REGISTER 23-4: CCPxCAP: CAPTURE INPUT SELECTION MULTIPLEXER REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-3 Unimplemented: Read as ' 0 '\nbit 2-0 CTS<2:0>: Capture Trigger Input Selection bits",
    "bit 7-3 Unimplemented: Read as ' 0 '\n1111-1001, Connection.CCP1 = Reserved. 1111-1001, Connection.CCP2 = Reserved. 1111-1001, Connection.CCP3 = Reserved. 1111-1001, Connection.CCP4 = Reserved. 1000, Connection.CCP1 = CAN_rx_timestamp. 1000, Connection.CCP2 = CAN_rx_timestamp. 1000, Connection.CCP3 = CAN_rx_timestamp. 1000, Connection.CCP4 = CAN_rx_timestamp. 0111, Connection.CCP1 = CLC4_out. 0111, Connection.CCP2 = CLC4_out. 0111, Connection.CCP3 = CLC4_out. 0111, Connection.CCP4 = CLC4_out. 0110, Connection.CCP1 = CLC3_out. 0110, Connection.CCP2 = CLC3_out. 0110, Connection.CCP3 = CLC3_out. 0110, Connection.CCP4 =",
    "bit 7-3 Unimplemented: Read as ' 0 '\nCLC3_out. 0101, Connection.CCP1 = CLC2_out. 0101, Connection.CCP2 = CLC2_out. 0101, Connection.CCP3 = CLC2_out. 0101, Connection.CCP4 = CLC2_out. 0100, Connection.CCP1 = CLC1_out. 0100, Connection.CCP2 = CLC1_out. 0100, Connection.CCP3 = CLC1_out. 0100, Connection.CCP4 = CLC1_out. 0011, Connection.CCP1 = IOC_Interrupt. 0011, Connection.CCP2 = IOC_Interrupt. 0011, Connection.CCP3 = IOC_Interrupt. 0011, Connection.CCP4 = IOC_Interrupt. 0010, Connection.CCP1 = CMP2_output. 0010, Connection.CCP2 = CMP2_output. 0010, Connection.CCP3 = CMP2_output. 0010, Connection.CCP4 = CMP2_output. 0001,",
    "bit 7-3 Unimplemented: Read as ' 0 '\nConnection.CCP1 = CMP1_output. 0001, Connection.CCP2 = CMP1_output. 0001, Connection.CCP3 = CMP1_output. 0001, Connection.CCP4 = CMP1_output. 0000, Connection.CCP1 = Pin selected by CCP1PPS. 0000, Connection.CCP2 = Pin selected by CCP2PPS. 0000, Connection.CCP3 = Pin selected by CCP3PPS. 0000, Connection.CCP4 = Pin selected by CCP4PPS",
    "REGISTER 23-5: CCPRxL: CCPx REGISTER LOW BYTE\nbit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x.RL<7:0> = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 MODE = Capture Mode:\nRL<7:0>: LSB of captured TMR1 value\nMODE = Compare Mode:\nRL<7:0>:\nLSB compared to TMR1 value\nMODE = PWM Mode && FMT = 0 :\nRL<7:0>:\nCCPW<7:0> - Pulse-Width LS 8 bits\nMODE = PWM Mode && FMT =\n1 :\nRL<7:6>:\nCCPW<1:0> - Pulse-Width LS 2 bits\nRL<5:0>:\nNot used",
    "REGISTER 23-6: CCPRxH: CCPx REGISTER HIGH BYTE\nbit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x.RH<7:0> = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 MODE = Capture Mode:\nRH<7:0>: MSB of captured TMR1 value\nMODE = Compare Mode:\nRH<7:0>: MSB compared to TMR1 value\nMODE = PWM Mode && FMT = 0 :\nRH<7:2>:\nNot used\nRH<1:0>:\nCCPW<9:8> - Pulse-Width MS 2 bits\nMODE = PWM Mode && FMT = 1 :\nRH<7:0>: CCPW<9:2> - Pulse-Width MS 8 bits",
    "TABLE 23-4: SUMMARY OF REGISTERS ASSOCIATED WITH CCPx\nCCPxCON, Bit 7 = EN. CCPxCON, Bit 6 = -. CCPxCON, Bit 5 = OUT. CCPxCON, Bit 4 = FMT MODE<3:0>. CCPxCON, Bit 3 = FMT MODE<3:0>. CCPxCON, Bit 2 = FMT MODE<3:0>. CCPxCON, Bit 1 = FMT MODE<3:0>. CCPxCON, Bit 0 = FMT MODE<3:0>. CCPxCON, Register on Page = 336. CCPxCAP, Bit 7 = -. CCPxCAP, Bit 6 = -. CCPxCAP, Bit 5 = -. CCPxCAP, Bit 4 = -. CCPxCAP, Bit 3 = -. CCPxCAP, Bit 2 = -. CCPxCAP, Bit 1 = CTS<1:0>. CCPxCAP, Bit 0 = CTS<1:0>. CCPxCAP, Register on Page = 339. CCPRxL, Bit 7 =",
    "TABLE 23-4: SUMMARY OF REGISTERS ASSOCIATED WITH CCPx\nCCPRx<7:0>. CCPRxL, Bit 6 = CCPRx<7:0>. CCPRxL, Bit 5 = CCPRx<7:0>. CCPRxL, Bit 4 = CCPRx<7:0>. CCPRxL, Bit 3 = CCPRx<7:0>. CCPRxL, Bit 2 = CCPRx<7:0>. CCPRxL, Bit 1 = CCPRx<7:0>. CCPRxL, Bit 0 = CCPRx<7:0>. CCPRxL, Register on Page = 339. CCPRxH, Bit 7 = CCPRx<15:8>. CCPRxH, Bit 6 = CCPRx<15:8>. CCPRxH, Bit 5 = CCPRx<15:8>. CCPRxH, Bit 4 = CCPRx<15:8>. CCPRxH, Bit 3 = CCPRx<15:8>. CCPRxH, Bit 2 = CCPRx<15:8>.",
    "TABLE 23-4: SUMMARY OF REGISTERS ASSOCIATED WITH CCPx\nCCPRxH, Bit 1 = CCPRx<15:8>. CCPRxH, Bit 0 = CCPRx<15:8>. CCPRxH, Register on Page = 340. CCPTMRS0, Bit 7 = C4TSEL<1:0>. CCPTMRS0, Bit 6 = C4TSEL<1:0>. CCPTMRS0, Bit 5 = C3TSEL<1:0>. CCPTMRS0, Bit 4 = C3TSEL<1:0>. CCPTMRS0, Bit 3 = C2TSEL<1:0>. CCPTMRS0, Bit 2 = C2TSEL<1:0>. CCPTMRS0, Bit 1 = C1TSEL<1:0>. CCPTMRS0, Bit 0 = C1TSEL<1:0>. CCPTMRS0, Register on Page = 337\nLegend:\n- = Unimplemented location, read as ' 0 '. Shaded cells are not used by the CCP module.",
    "24.0 PULSE-WIDTH MODULATION (PWM)\nThe PWM module generates a pulse-width modulated signal determined  by  the  duty  cycle,  period,  and resolution that are configured by the following registers:\n\u00b7 TxPR\n\u00b7 TxCON\n\u00b7 PWMxDCH\n\u00b7 PWMxDCL\n\u00b7 PWMxCON\nNote:\nThe  corresponding  TRIS  bit must  be cleared to enable the PWM output on the PWMx pin.",
    "FIGURE 24-2: PWM OUTPUT\nFor  a  step-by-step  procedure  on  how  to  set  up  this module for PWM operation, refer to Section 24.1.9 'Setup  for  PWM  Operation  using  PWMx Pins' .\nEach PWM module can select the timer source that controls the module. Each module has an independent timer  selection  which  can  be  accessed  using  the CCPTMRS1 register (Register 23-2). Please note that the PWM mode operation is described with respect to T2TMR in the following sections.\nFigure 24-1 shows a simplified block diagram of PWM operation.\nFigure 24-2  shows  a  typical  waveform  of  the  PWM signal.",
    "24.1 PWMx Pin Configuration\nAll PWM outputs are multiplexed with the PORT data latch. The user must configure the pins as outputs by clearing the associated TRIS bits.",
    "24.1.1 FUNDAMENTAL OPERATION\nThe PWM module produces a 10-bit resolution output. The PWM timer can be selected using the PxTSEL bits in  the  CCPTMRS1 register. The default selection for PWMx is T2TMR. Please note that the PWM module operation  in  the  following  sections  is  described  with respect to T2TMR. Timer2 and T2PR set the period of the  PWM. The  PWMxDCL and PWMxDCH registers configure the duty cycle. The period is common to all PWM  modules,  whereas  the  duty  cycle  is  inde -pendently controlled.\nNote: The  Timer2  postscaler  is  not  used  in  the determination  of  the  PWM  frequency.  The postscaler  could  be  used  to  have  a  servo update rate at a different frequency than the PWM output.",
    "24.1.1 FUNDAMENTAL OPERATION\nAll PWM outputs associated with Timer2 are set when T2TMR  is  cleared.  Each  PWMx  is  cleared  when T2TMR is  equal  to  the  value  specified  in  the  corre -sponding  PWMxDCH  (8 MSb)  and  PWMxDCL<7:6> (2 LSb)  registers.  When  the  value  is  greater  than  or equal to T2PR, the PWM output is never cleared (100% duty cycle).\nNote:\nThe  PWMxDCH  and  PWMxDCL  registers are double buffered. The buffers are updated when Timer2  matches  T2PR.  Care  should be taken to update both registers before the timer match occurs.",
    "24.1.2 PWM OUTPUT POLARITY\nThe output polarity is inverted by setting the PWMxPOL bit of the PWMxCON register.",
    "24.1.3 PWM PERIOD\nThe PWM period is specified by the T2PR register of Timer2. The PWM period can be calculated using the formula of Equation 24-1. It is required to have FOSC/4 as clock input to Timer2/4/6 for correct PWM operation.",
    "EQUATION 24-1: PWM PERIOD\n```\nPW M   Pe r i od T2PR \uf028 \uf029 1 + \uf05b \uf05d \uf0b7 4 TOSC \uf0b7 \uf0b7 = ( TM R2  Pr e s c al e   al e ) V u Note: TOSC = 1/FOSC\n```\nWhen T2TMR is  equal  to  T2PR,  the  following  three events occur on the next increment cycle:\n\u00b7 T2TMR is cleared\n\u00b7 The PWM output is active. (Exception: When the PWM duty cycle = 0%, the PWM output will remain inactive.)\n\u00b7 The PWMxDCH and PWMxDCL register values are latched into the buffers.\nNote:\nThe Timer2 postscaler has no effect on the PWM operation.",
    "24.1.4 PWM DUTY CYCLE\nThe PWM duty cycle is  specified  by  writing  a  10-bit value to the PWMxDCH and PWMxDCL register pair. The PWMxDCH register contains the eight MSbs and the  PWMxDCL<7:6>, the two LSbs. The PWMxDCH and PWMxDCL registers can be written to at any time.\nEquation 24-2  is  used  to  calculate  the  PWM  pulse width.\nEquation 24-3 is used to calculate the PWM duty cycle ratio.",
    "EQUATION 24-2: PULSE WIDTH\n```\n\uf028 \uf029 \uf0b7 TM R2  Pr e s c al e   al ue )\n```\n```\nPul s e W i dt h PW M xD CH : PW M x DCL<7: 6> = TOSC ( \uf0b7 V Note: TOSC = 1/FOSC\n```",
    "EQUATION 24-3: DUTY CYCLE RATIO\nDut y   Cy c l   at i o eR\nPW M xD CH : PW M xDCL<7: 6> \uf028 \uf029 4 T2PR + 1 \uf028 \uf029 - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - ---------------------------=\nThe 8-bit timer T2TMR register is concatenated with the two  Least  Significant  bits  of  1/FOSC,  adjusted  by  the Timer2  prescaler  to  create  the  10-bit  time  base.  The system clock is used if the Timer2 prescaler is set to 1:1.",
    "24.1.5 PWM RESOLUTION\nThe resolution determines the number of available duty cycles for a given period. For example, a 10-bit resolution will result in 1024 discrete duty cycles, whereas an 8-bit resolution will result in 256 discrete duty cycles.\nThe maximum PWM resolution is ten bits when T2PR is 255. The resolution is a function of the T2PR register value as shown by Equation 24-4.",
    "EQUATION 24-4: PWM RESOLUTION\n<!-- formula-not-decoded -->\nNote: If the pulse-width value is greater than the assigned  PWM  pin(s)  will period, the remain unchanged.",
    "TABLE 24-1: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS (FOSC = 20 MHz)\nTimer Prescale, 0.31 kHz = 64. Timer Prescale, 4.88 kHz = 4. Timer Prescale, 19.53 kHz = 1. Timer Prescale, 78.12 kHz = 1. Timer Prescale, 156.3 kHz = 1. Timer Prescale, 208.3 kHz = 1. T2PR Value, 0.31 kHz = 0xFF. T2PR Value, 4.88 kHz = 0xFF. T2PR Value, 19.53 kHz = 0xFF. T2PR Value, 78.12 kHz = 0x3F. T2PR Value, 156.3 kHz = 0x1F. T2PR Value, 208.3 kHz = 0x17. Maximum Resolution (bits), 0.31 kHz = 10. Maximum Resolution (bits), 4.88 kHz = 10. Maximum Resolution (bits), 19.53 kHz = 10. Maximum Resolution (bits), 78.12 kHz = 8. Maximum Resolution (bits), 156.3 kHz = 7. Maximum Resolution (bits), 208.3 kHz =",
    "TABLE 24-1: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS (FOSC = 20 MHz)\n6.6",
    "TABLE 24-2: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS (FOSC = 8 MHz)\nTimer Prescale, 0.31 kHz = 64. Timer Prescale, 4.90 kHz = 4. Timer Prescale, 19.61 kHz = 1. Timer Prescale, 76.92 kHz = 1. Timer Prescale, 153.85 kHz = 1. Timer Prescale, 200.0 kHz = 1. T2PR Value, 0.31 kHz = 0x65. T2PR Value, 4.90 kHz = 0x65. T2PR Value, 19.61 kHz = 0x65. T2PR Value, 76.92 kHz = 0x19. T2PR Value, 153.85 kHz = 0x0C. T2PR Value, 200.0 kHz = 0x09. Maximum Resolution (bits), 0.31 kHz = 8. Maximum Resolution (bits), 4.90 kHz = 8. Maximum Resolution (bits), 19.61 kHz = 8. Maximum Resolution (bits), 76.92 kHz = 6. Maximum Resolution (bits), 153.85 kHz = 5. Maximum Resolution (bits), 200.0 kHz = 5",
    "24.1.6 OPERATION IN SLEEP MODE\nIn Sleep mode, the T2TMR register will not increment and  the  state  of  the  module  will  not  change.  If  the PWMx pin is driving a value, it will continue to drive that value. When the device wakes up, T2TMR will continue from its previous state.",
    "24.1.7 CHANGES IN SYSTEM CLOCK FREQUENCY\nThe PWM frequency is derived from the system clock frequency  (FOSC). Any  changes  in  the  system  clock frequency will result in changes to the PWM frequency. Refer to Section 7.0 'Oscillator Module (with FailSafe Clock Monitor)' for additional details.",
    "24.1.8 EFFECTS OF RESET\nAny Reset will force all  ports  to Input  mode  and  the PWM registers to their Reset states.",
    "24.1.9 SETUP FOR PWM OPERATION USING PWMx PINS\nThe following steps should be taken when configuring the module for PWM operation using the PWMx pins:",
    "24.1.9 SETUP FOR PWM OPERATION USING PWMx PINS\n1. Disable the PWMx pin output driver(s) by setting the associated TRIS bit(s).\n2. Clear the PWMxCON register.\n3. Load  the  T2PR  register  with  the  PWM  period value.\n4. Load the PWMxDCH register and bits <7:6> of the PWMxDCL register with the PWM duty cycle value.\n5. Configure and start Timer2:\n\u00b7 Clear the TMR2IF interrupt flag bit of the respective PIR register. See Note 1 below.\n\u00b7 Select the timer clock source to be as FOSC/4 using the TxCLK register. This is required for correct operation of the PWM module.\n\u00b7 Configure the CKPS bits of the T2CON register with the Timer2 prescale value.\n\u00b7 Enable Timer2 by setting the ON bit of the T2CON register.\n6. Enable PWM output pin and wait until Timer2 overflows,  TMR2IF  bit  of  the  respective  PIR register is set. See note below.",
    "24.1.9 SETUP FOR PWM OPERATION USING PWMx PINS\n7. Enable the PWMx pin output driver(s) by clear -ing  the  associated TRIS  bit(s)  and  setting  the desired pin PPS control bits.\n8. Configure  the  PWM  module  by  loading  the PWMxCON register with the appropriate values.\nNote 1: In  order  to  send  a  complete  duty  cycle and period on the first PWM output, the above steps must be followed in the order given.  If  it  is  not  critical  to  start  with  a complete PWM signal, then move Step 8 to replace Step 4.\n2: For operation with other peripherals only, disable PWMx pin outputs.",
    "24.1.10 SETUP FOR PWM OPERATION TO OTHER DEVICE PERIPHERALS\nThe following steps should be taken when configuring the  module  for  PWM  operation  to  be  used  by  other device peripherals:",
    "24.1.10 SETUP FOR PWM OPERATION TO OTHER DEVICE PERIPHERALS\n1. Disable the PWMx pin output driver(s) by setting the associated TRIS bit(s).\n2. Clear the PWMxCON register.\n3. Load  the  T2PR  register  with  the  PWM  period value.\n4. Load the PWMxDCH register and bits <7:6> of the PWMxDCL register with the PWM duty cycle value.\n5. Configure and start Timer2:\n\u00b7 Clear the TMR2IF interrupt flag bit of the respective PIR register. See Note 1 below.\n\u00b7 Select the timer clock source to be as FOSC/4 using the TxCLK register. This is required for correct operation of the PWM module.\n\u00b7 Configure the CKPS bits of the T2CON regis -ter with the Timer2 prescale value.\n\u00b7 Enable Timer2 by setting the ON bit of the T2CON register.\n6. Enable PWM output pin:\n\u00b7 Wait until Timer2 overflows, TMR2IF bit of the respective PIR register is set. See Note 1 below.",
    "24.1.10 SETUP FOR PWM OPERATION TO OTHER DEVICE PERIPHERALS\n7. Configure  the  PWM  module  by  loading  the PWMxCON register with the appropriate values.\nNote 1: In  order  to  send  a  complete  duty  cycle and period on the first PWM output, the above  steps  must  be  included  in  the setup sequence. If it is not critical to start with a complete PWM signal on the first output, then step 6 may be ignored.",
    "24.2 Register Definitions: PWM Control\nLong bit name prefixes for the PWM peripherals are shown  below.  Refer  to Section  1.3.2.2 'Long  Bit Names' for more information.\nPWM3, Bit Name Prefix = PWM3. PWM4, Bit Name Prefix = PWM4",
    "REGISTER 24-1: PWMxCON: PWM CONTROL REGISTER\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = R-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = U-0. R/W-0/0, 6 = U-0. R/W-0/0, 7 = U-0. EN, 1 = -. EN, 2 = OUT. EN, 3 = POL. EN, 4 = -. EN, 5 = -. EN, 6 = -. EN, 7 = -. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7\nEN: PWM Module Enable bit\n1 = PWM module is enabled\n0 = PWM module is disabled\nbit 6\nUnimplemented: Read as ' 0 '\nbit 5\nOUT: PWM Module Output Level When Bit is Read\nbit 4\nPOL: PWM Output Polarity Select bit\n1 = PWM output is inverted\n0 = PWM output is normal\nbit 3-0\nUnimplemented: Read as ' 0 '",
    "REGISTER 24-2: CCPTMRS1: CCP TIMERS CONTROL REGISTER 1\nP8TSEL<1:0>, R/W-1/1 = P8TSEL<1:0>. P8TSEL<1:0>, R/W-0/0 = P7TSEL<1:0>. P8TSEL<1:0>, R/W-1/1 = P7TSEL<1:0>. P8TSEL<1:0>, R/W-0/0 = P6TSEL<1:0>. P8TSEL<1:0>, R/W-1/1 = P6TSEL<1:0>. P8TSEL<1:0>, R/W-0/0 = P5TSEL<1:0>. P8TSEL<1:0>, R/W-1/1 = P5TSEL<1:0>. bit 7, R/W-1/1 = . bit 7, R/W-0/0 = . bit 7, R/W-1/1 = . bit 7,",
    "REGISTER 24-2: CCPTMRS1: CCP TIMERS CONTROL REGISTER 1\nR/W-0/0 = . bit 7, R/W-1/1 = . bit 7, R/W-0/0 = . bit 7, R/W-1/1 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-6 P8TSEL<1:0>: PWM8 Timer Selection bits\n11 = PWM8 based on TMR6\n10 = PWM8 based on TMR4\n01 = PWM8 based on TMR2\n00 = Reserved",
    "bit 5-4\nP7TSEL<1:0>: PWM7 Timer Selection bits\n11 = PWM7 based on TMR6\n10 = PWM7 based on TMR4\n01 = PWM7 based on TMR2\n00 = Reserved\nbit 3-2\nP6TSEL<1:0>: PWM6 Timer Selection bits\n11 = PWM6 based on TMR6\n10 = PWM6 based on TMR4\n01 = PWM6 based on TMR2\n00 = Reserved\nbit 1-0\nP5TSEL<1:0>: PWM5 Timer Selection bits\n11 = PWM5 based on TMR6\n10 = PWM5 based on TMR4\n01 = PWM5 based on TMR2\n- 00 = Reserved",
    "REGISTER 24-3: PWMxDCH: PWM DUTY CYCLE HIGH BITS\nbit 7, R/W-x/u.DC<9:2> = . bit 7, R/W-x/u. = . bit 7, R/W-x/u. = . bit 7, R/W-x/u. = . bit 7, R/W-x/u. = . bit 7, R/W-x/u. = . bit 7, R/W-x/u. = bit 0\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, U = Unimplemented bit, read as '0' = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "REGISTER 24-3: PWMxDCH: PWM DUTY CYCLE HIGH BITS\nbit 7-0 DC<9:2>: PWM Duty Cycle Most Significant bits\nThese bits are the MSbs of the PWM duty cycle. The two LSbs are found in PWMxDCL Register.",
    "REGISTER 24-4: PWMxDCL: PWM DUTY CYCLE LOW BITS\nR/W-x/u, 1 = R/W-x/u. R/W-x/u, 2 = U-0. R/W-x/u, 3 = U-0. R/W-x/u, 4 = U-0. R/W-x/u, 5 = U-0. R/W-x/u, 6 = U-0. R/W-x/u, 7 = U-0. DC<1:0>, 1 = DC<1:0>. DC<1:0>, 2 = -. DC<1:0>, 3 = -. DC<1:0>, 4 = -. DC<1:0>, 5 = -. DC<1:0>, 6 = -. DC<1:0>, 7 = -. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 24-4: PWMxDCL: PWM DUTY CYCLE LOW BITS\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = \nbit 7-6\nDC<1:0>: PWM Duty Cycle Least Significant bits\nThese bits are the LSbs of the PWM duty cycle. The MSbs are found in PWMxDCH Register.\nbit 5-0\nUnimplemented: Read as ' 0 '",
    "TABLE 24-3: SUMMARY OF REGISTERS ASSOCIATED WITH PWM\nPWMxCON, Bit 7 = EN. PWMxCON, Bit 6 = -. PWMxCON, Bit 5 = OUT. PWMxCON, Bit 4 = POL. PWMxCON, Bit 3 = -. PWMxCON, Bit 2 = -. PWMxCON, Bit 1 = -. PWMxCON, Bit 0 = -. PWMxCON, Register on Page = 345. PWMxDCH, Bit 7 = DC<9:2>. PWMxDCH, Bit 6 = DC<9:2>. PWMxDCH, Bit 5 = DC<9:2>. PWMxDCH, Bit 4 = DC<9:2>. PWMxDCH, Bit 3 = DC<9:2>. PWMxDCH, Bit 2 = DC<9:2>. PWMxDCH, Bit 1 = DC<9:2>. PWMxDCH, Bit 0 = DC<9:2>. PWMxDCH, Register on Page = 347. PWMxDCL, Bit 7 =",
    "TABLE 24-3: SUMMARY OF REGISTERS ASSOCIATED WITH PWM\nDC<1:0>. PWMxDCL, Bit 6 = DC<1:0>. PWMxDCL, Bit 5 = -. PWMxDCL, Bit 4 = -. PWMxDCL, Bit 3 = -. PWMxDCL, Bit 2 = -. PWMxDCL, Bit 1 = -. PWMxDCL, Bit 0 = -. PWMxDCL, Register on Page = 347. CCPTMRS1, Bit 7 = P8TSEL<1:0>. CCPTMRS1, Bit 6 = P8TSEL<1:0>. CCPTMRS1, Bit 5 = P7TSEL<1:0>. CCPTMRS1, Bit 4 = P7TSEL<1:0>. CCPTMRS1, Bit 3 = P6TSEL<1:0>. CCPTMRS1, Bit 2 = P6TSEL<1:0>. CCPTMRS1, Bit 1 = P5TSEL<1:0>. CCPTMRS1, Bit 0",
    "TABLE 24-3: SUMMARY OF REGISTERS ASSOCIATED WITH PWM\n= P5TSEL<1:0>. CCPTMRS1, Register on Page = 346\nLegend: - = Unimplemented locations, read as ' 0 ', u = unchanged, x = unknown. Shaded cells are not used by the PWM.",
    "25.0 SIGNAL MEASUREMENT TIMER (SMTx)\nThe SMT is a 24-bit counter with advanced clock and gating logic, which can be configured for measuring a variety of digital signal parameters such as pulse width, frequency  and  duty  cycle,  and  the  time  difference between edges on two signals. The device  has only one SMT module implemented.\nFeatures of the SMT include:\n\u00b7 24-bit timer/counter\n-Three 8-bit registers (SMTxL/H/U)\n-Readable and writable\n-Optional 16-bit operating mode\n\u00b7 Two 24-bit measurement capture registers\n\u00b7 One 24-bit period match register\n\u00b7 Multi-mode operation, including relative timing measurement\n\u00b7 Interrupt on period match\n\u00b7 Multiple clock, gate and signal sources\n\u00b7 Interrupt on acquisition complete\n\u00b7 Ability to read current input values\nFIGURE 25-1:\nSMT BLOCK DIAGRAM\nFIGURE 25-2: SMT SIGNAL AND WINDOW BLOCK DIAGRAM",
    "25.1 SMT Operation\nThe core of the module is the 24-bit counter, SMTxTMR combined  with  a  complex  data  acquisition  front-end. Depending on the mode of operation selected, the SMT can perform a variety of measurements summarized in Table 25-1.",
    "25.1.1 CLOCK SOURCES\nClock sources available to the SMT include:\n\u00b7 FOSC\n\u00b7 FOSC/4\n\u00b7 HFINTOSC 16 MHz\n\u00b7 LFINTOSC\n\u00b7 MFINTOSC 31.25 kHz\nThe SMT clock source is selected by configuring the CSEL<2:0> bits in  the  SMTxCLK  register. The clock source can also be prescaled using the PS<1:0> bits of the SMTxCON0 register. The prescaled clock source is used to clock both the counter and any synchronization logic used by the module.",
    "25.1.2 PERIOD MATCH INTERRUPT\nSimilar to other timers, the SMT triggers an interrupt when SMTxTMR rolls over to ' 0 '. This happens when SMTxTMR = SMTxPR, regardless of mode. Hence, in any mode that relies on an external signal or a window to reset the  timer, proper  operation  requires  that SMTxPR  be  set  to  a  period  larger  than  that  of  the expected signal or window.",
    "25.2 Basic Timer Function Registers\nThe SMTxTMR  time base and the SMTxCPW/ SMTxPR/SMTxCPR  buffer  registers  serve  several functions and can be manually updated using software.",
    "25.2.1 TIME BASE\nThe SMTxTMR is the 24-bit counter that is the center of the  SMT.  It  is  used  as  the  basic  counter/timer  for measurement in each of the modes of the SMT. It can be reset to a value of 24'h00_0000 by setting the RST bit of the  SMTxSTAT register. It can be written to and read from software, but it is not guarded for atomic access, therefore reads and writes to the SMTxTMR should only be made when the GO = 0 , or the software should have other measures to ensure integrity of SMTxTMR reads/ writes.",
    "25.2.2 PULSE-WIDTH LATCH REGISTERS\nThe  SMTxCPW  registers  are  the  24-bit  SMT  pulsewidth latch. They are used to latch in the value of the SMTxTMR when triggered by  various  signals,  which are determined by the mode the SMT is currently in. The SMTxCPW registers can also be updated with the current  value  of  the  SMTxTMR  value  by  setting  the CPWUP bit of the SMTxSTAT register.",
    "25.2.3 PERIOD LATCH REGISTERS\nThe  SMTxCPR  registers  are  the  24-bit  SMT  period latch.  They  are  used  to  latch  in  other  values  of  the SMTxTMR  when  triggered  by  various  other  signals, which are determined by the mode the SMT is currently in.\nThe SMTxCPR registers can also be updated with the current  value  of  the  SMTxTMR  value  by  setting  the CPRUP bit in the SMTxSTAT register.",
    "25.3 Halt Operation\nThe counter can be prevented from rolling-over using the STP bit in the SMTxCON0 register. When halting is enabled, the period match interrupt persists  until  the SMTxTMR is reset (either by a manual Reset, Section 25.2.1 'Time Base' ) or by clearing the GO bit of the SMTxCON1 register and writing the SMTxTMR values in software.",
    "25.4 Polarity Control\nThe  three  input  signals  for  the  SMT  have  polarity control  to  determine  whether  or  not  they  are  activehigh/positive edge or active-low/negative edge signals.\nThe following bits apply to Polarity Control:\n\u00b7 WSEL bit (Window Polarity)\n\u00b7 SSEL bit (Signal Polarity)\n\u00b7 CSEL bit (Clock Polarity)\nThese bits are located in the SMTxCON0 register.",
    "25.5 Status Information\nThe SMT provides input status information for the user without requiring the need to deal with the polarity of the incoming signals.",
    "25.5.1 WINDOW STATUS\nWindow  status  is  determined  by  the  WS  bit  of  the SMTxSTAT register. This bit is only used in Windowed Measure, Gated Counter and Gated Window Measure modes,  and  is  only  valid  when  TS  = 1 ,  and  will  be delayed in time by synchronizer delays in non-Counter modes.",
    "25.5.2 SIGNAL STATUS\nSignal  status  is  determined  by  the  AS  bit  of  the SMTxSTAT register. This bit is used in all modes except Window Measure, Time of Flight and Capture modes, and is only valid when TS = 1 , and will be delayed in time by synchronizer delays in non-Counter modes.",
    "25.5.3 GO STATUS\nTimer  run  status  is  determined  by  the  TS  bit  of  the SMTxSTAT  register,  and  will  be  delayed  in  time  by synchronizer delays in non-Counter modes.",
    "25.6 Modes of Operation\nThe modes of operation are summarized in Table 25-1. The  following  sections  provide  detailed  descriptions, examples of how the modes can be used. Note that all waveforms  assume  WPOL/SPOL/CPOL = 0 . When WPOL/SPOL/CPOL = 1 , all SMTSIGx, SMTWINx and SMT clock signals will have a polarity opposite to that indicated.  For  all  modes,  the  REPEAT  bit  controls whether  the  acquisition  is  repeated  or  single.  When REPEAT = 0 (Single Acquisition mode), the timer will stop incrementing and the GO bit will be reset upon the completion of an acquisition. Otherwise, the timer will continue and allow for continued acquisitions to overwrite the previous ones until the timer is stopped in software.",
    "25.6.1 TIMER MODE\nTimer mode is the simplest mode of operation where the  SMTxTMR is used as a 16/24-bit timer. No data acquisition takes place in this mode.  The timer increments  as  long  as  the  GO  bit  has  been  set  by software. No SMT window or SMT signal events affect the  GO  bit.  Everything  is  synchronized  to  the  SMT clock  source.  When  the  timer  experiences  a  period match (SMTxTMR = SMTxPR), SMTxTMR is reset and the period match interrupt trips. See Figure 25-3.",
    "TABLE 25-1: MODES OF OPERATION\n0000, Mode of Operation = Timer. 0000, Synchronous Operation = Yes. 0000, Reference = Section 25.6.1 'Timer Mode'. 0001, Mode of Operation = Gated Timer. 0001, Synchronous Operation = Yes. 0001, Reference = Section 25.6.2 'Gated Timer Mode'. 0010, Mode of Operation = Period and Duty Cycle Acquisition. 0010, Synchronous Operation = Yes. 0010, Reference = Section 25.6.3 'Period and Duty Cycle Mode'. 0011, Mode of Operation = High and Low Time Measurement. 0011, Synchronous Operation = Yes. 0011, Reference = Section 25.6.4 'High and Low Measure Mode'. 0100, Mode of Operation = Windowed Measurement. 0100, Synchronous Operation = Yes. 0100, Reference = Section 25.6.5 'Windowed Measure Mode'. 0101, Mode of Operation = Gated Windowed Measurement. 0101, Synchronous Operation = Yes. 0101, Reference = Section 25.6.6 'Gated Windowed Measure Mode'.",
    "TABLE 25-1: MODES OF OPERATION\n0110, Mode of Operation = Time of Flight. 0110, Synchronous Operation = Yes. 0110, Reference = Section 25.6.7 'Time of Flight Measure Mode'. 0111, Mode of Operation = Capture. 0111, Synchronous Operation = Yes. 0111, Reference = Section 25.6.8 'Capture Mode'. 1000, Mode of Operation = Counter. 1000, Synchronous Operation = No. 1000, Reference = Section 25.6.9 'Counter Mode'. 1001, Mode of Operation = Gated Counter. 1001, Synchronous Operation = No. 1001, Reference = Section 25.6.10 'Gated Counter Mode'. 1010, Mode of Operation = Windowed Counter. 1010, Synchronous Operation = No. 1010, Reference = Section 25.6.11 'Windowed Counter Mode'. 1011-1111, Mode of Operation = Reserved. 1011-1111, Synchronous Operation = -. 1011-1111, Reference = -",
    "25.6.2 GATED TIMER MODE\nGated Timer mode uses the SMTSIGx input to control whether or not the SMTxTMR will increment. Upon a falling  edge  of  the  external  signal,  the  SMTxCPW register will update to the current value of the SMTxTMR. Example waveforms for both repeated and single  acquisitions  are  provided  in  Figure 25-4  and Figure 25-5.",
    "25.6.3 PERIOD AND DUTY CYCLE MODE\nIn  Duty  Cycle  mode,  either  the  duty  cycle  or  period (depending  on  polarity)  of  the  SMTx_signal  can  be acquired relative to the SMT clock. The CPW register is updated on a falling edge of the signal, and the CPR register is updated on a rising edge of the signal, along with the SMTxTMR resetting to 0x0001. In addition, the GO bit  is  reset  on  a  rising  edge  when  the  SMT  is  in Single Acquisition mode. See Figure 25-6 and Figure 25-7.",
    "25.6.4 HIGH AND LOW MEASURE MODE\nThis mode measures the high and low pulse time of the SMTSIGx relative to the SMT clock. It begins incrementing the SMTxTMR on a rising edge on the SMTSIGx input, then updates the SMTxCPW register with the value and resets the SMTxTMR on a falling edge,  starting  to  increment  again.  Upon  observing another rising edge, it updates the SMTxCPR register with  its current  value  and  once  again  resets  the SMTxTMR value and begins incrementing again. See Figure 25-8 and Figure 25-9.",
    "25.6.5 WINDOWED MEASURE MODE\nThis  mode  measures  the  window  duration  of  the SMTWINx input of the SMT. It begins incrementing the timer  on  a  rising  edge  of  the  SMTWINx  input  and updates the SMTxCPR register with the value of the timer and resets the timer on a second rising edge. See Figure 25-10 and Figure 25-11.\nFIGURE 25-10:",
    "25.6.6 GATED WINDOWED MEASURE MODE\nThis mode measures the duty cycle of the SMTx_signal input  over  a  known  input  window.  It  does  so  by incrementing the timer on each pulse of the clock signal while  the  SMTx_signal  input  is  high,  updating  the SMTxCPR register  and  resetting  the  timer  on  every rising edge of the SMTWINx input after the first. See Figure 25-12 and Figure 25-13.",
    "25.6.7 TIME OF FLIGHT MEASURE MODE\nThis mode measures the time interval between a rising edge on the SMTWINx input and a rising edge on the SMTx_signal  input,  beginning  to  increment  the  timer upon observing a rising edge on the SMTWINx input, while updating the SMTxCPR register and resetting the timer upon observing a rising edge on the SMTx_signal input.  In  the  event  of  two  SMTWINx  rising  edges without an SMTx_signal rising edge, it will update the SMTxCPW register with the current value of the timer and  reset  the  timer  value.  See  Figure 25-14  and Figure 25-15.",
    "25.6.8 CAPTURE MODE\nThis mode captures the Timer value based on a rising or falling edge on the SMTWINx input and triggers an interrupt.  This  mimics  the  capture  feature  of  a  CCP module. The timer begins incrementing upon the GO bit being set, and updates the value of the SMTxCPR register on each rising edge of SMTWINx, and updates the value of the CPW register on each falling edge of the SMTWINx. The timer is not reset by any hardware conditions in this mode and must be reset by software, if desired. See Figure 25-16 and Figure 25-17.",
    "25.6.9 COUNTER MODE\nThis mode increments the timer on each pulse of the SMTx_signal input. This mode is asynchronous to the SMT clock and uses the SMTx_signal as a time source. The SMTxCPW register will be updated with the current SMTxTMR value on the rising edge of the SMTxWIN input. See Figure 25-18.",
    "25.6.10 GATED COUNTER MODE\nThis mode counts pulses on the SMTx_signal input, gated by the SMTxWIN input. It begins incrementing the timer upon seeing a rising edge of the SMTxWIN input and updates the SMTxCPW register upon a fall -ing edge on the SMTxWIN input. See Figure 25-19 and Figure 25-20.",
    "25.6.11 WINDOWED COUNTER MODE\nThis  mode  counts  pulses  on  the  SMTx_signal  input, within  a  window  dictated  by  the  SMTxWIN  input.  It begins  counting  upon  seeing  a  rising  edge  of  the SMTxWIN input, updates the SMTxCPW register on a falling  edge  of  the  SMTxWIN  input,  and  updates  the SMTxCPR  register on each rising edge of the SMTxWIN input beyond the first. See Figure 25-21 and Figure 25-22.",
    "25.7 Interrupts\nThe SMT can trigger an interrupt under three different conditions:\n\u00b7 PW Acquisition Complete\n\u00b7 PR Acquisition Complete\n\u00b7 Counter Period Match\nThe  interrupts  are  controlled  by  the  PIR  and  PIE registers of the device.",
    "25.7.1 PW AND PR ACQUISITION INTERRUPTS\nThe SMT can trigger interrupts whenever it updates the SMTxCPW  and  SMTxCPR  registers,  the  circum -stances for which are dependent on the SMT mode, and are discussed in each mode's specific section. The SMTxCPW interrupt is controlled by SMTxPWAIF and SMTxPWAIE bits in the respective PIR and PIE regis -ters.  The  SMTxCPR  interrupt  is  controlled  by  the SMTxPRAIF and SMTxPRAIE bits, also located in the respective PIR and PIE registers.\nIn  synchronous  SMT  modes,  the  interrupt  trigger  is synchronized to the SMTxCLK.  In  Asynchronous modes, the interrupt trigger is asynchronous. In either mode, once triggered, the interrupt will be synchronized to the CPU clock.",
    "25.7.2 COUNTER PERIOD MATCH INTERRUPT\nAs described in Section 25.1.2 'Period Match interrupt' , the SMT will also interrupt upon SMTxTMR, matching SMTxPR with its period match limit functionality described in Section 25.3 'Halt Operation' . The period match  interrupt  is  controlled  by  SMTxIF  and  SMTxIE, located in the respective PIR and PIE registers.",
    "25.8 Register Definitions: SMT Control\nLong  bit  name  prefixes  for  the  Signal  Measurement Timer peripherals are shown in Section 1.3 'Register and Bit naming conventions' .",
    "TABLE 25-2: LONG BIT NAMES PREFIXES FOR SMT PERIPHERALS\nSMT1, Bit Name Prefix = SMT1. SMT2, Bit Name Prefix = SMT2",
    "REGISTER 25-1: SMTxCON0: SMT CONTROL REGISTER 0\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. EN (1), 1 = -. EN (1), 2 = STP. EN (1), 3 = WPOL. EN (1), 4 = SPOL. EN (1), 5 = CPOL. EN (1), 6 = PS<1:0>. EN (1), 7 = PS<1:0>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0,",
    "REGISTER 25-1: SMTxCON0: SMT CONTROL REGISTER 0\n4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7\nEN: SMT Enable bit (1)\n1 = SMT is enabled\n0 = SMT is disabled; internal states are reset, clock requests are disabled\nbit 6\nUnimplemented : Read as ' 0 '\nbit 5\nSTP: SMT Counter Halt Enable bit\nWhen SMTxTMR = SMTxPR:\n1 = Counter remains SMTxPR; period match interrupt occurs when clocked\n0 = Counter resets to 24'h000000; period match interrupt occurs when clocked\nbit 4\nWPOL: SMTxWIN Input Polarity Control bit\n1 = SMTxWIN signal is active-low/falling edge enabled\n0 = SMTxWIN signal is active-high/rising edge enabled\nbit 3\nSPOL: SMTxSIG Input Polarity Control bit\n1 = SMTx_signal is active-low/falling edge enabled",
    "Legend:\n0 = SMTx_signal is active-high/rising edge enabled\nbit 2\nCPOL: SMT Clock Input Polarity Control bit\n1 = SMTxTMR increments on the falling edge of the selected clock signal\n0 = SMTxTMR increments on the rising edge of the selected clock signal\nbit 1-0\nPS<1:0>: SMT Prescale Select bits\n11 = Prescaler = 1:8\n10 = Prescaler = 1:4\n01 = Prescaler = 1:2\n00 = Prescaler = 1:1\nNote 1: Setting EN to ' 0 ' does not affect the register contents.",
    "REGISTER 25-2: SMTxCON1: SMT CONTROL REGISTER 1\nR/W/HC-0/0, 1 = R/W-0/0. R/W/HC-0/0, 2 = U-0. R/W/HC-0/0, 3 = U-0. R/W/HC-0/0, 4 = R/W-0/0. R/W/HC-0/0, 5 = R/W-0/0. R/W/HC-0/0, 6 = R/W-0/0. R/W/HC-0/0, 7 = R/W-0/0. GO, 1 = REPEAT. GO, 2 = -. GO, 3 = -. GO, 4 = MODE<3:0>. GO, 5 = MODE<3:0>. GO, 6 = MODE<3:0>. GO, 7 = MODE<3:0>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit",
    "REGISTER 25-2: SMTxCON1: SMT CONTROL REGISTER 1\n0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nHC = Bit is cleared by hardware\nHS = Bit is set by hardware\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition",
    "bit 7\nGO: GO Data Acquisition bit\n1 = Incrementing, acquiring data is enabled\n0 = Incrementing, acquiring data is disabled\nbit 6\nREPEAT: SMT Repeat Acquisition Enable bit\n1 = Repeat Data Acquisition mode is enabled\n0 = Single Acquisition mode is enabled\nbit 5-4\nUnimplemented : Read as ' 0 '\nbit 3-0\nMODE<3:0> SMT Operation Mode Select bits\n1111 = Reserved\n\u2022\n\u2022\n\u2022\n1011 = Reserved\n1010 = Windowed counter\n1001 = Gated counter\n1000 = Counter\n0111 = Capture\n0110 = Time of flight\n0101 = Gated windowed measure\n0100 = Windowed measure\n0011 = High and low time measurement\n0010 = Period and Duty-Cycle Acquisition\n0001 = Gated Timer\n0000 = Timer",
    "REGISTER 25-3: SMTxSTAT: SMT STATUS REGISTER\nR/W/HC-0/0, 1 = R/W/HC-0/0. R/W/HC-0/0, 2 = R/W/HC-0/0. R/W/HC-0/0, 3 = U-0. R/W/HC-0/0, 4 = U-0. R/W/HC-0/0, 5 = R-0/0. R/W/HC-0/0, 6 = R-0/0. R/W/HC-0/0, 7 = R-0/0. CPRUP, 1 = CPWUP. CPRUP, 2 = RST. CPRUP, 3 = -. CPRUP, 4 = -. CPRUP, 5 = TS. CPRUP, 6 = WS. CPRUP, 7 = AS. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit",
    "REGISTER 25-3: SMTxSTAT: SMT STATUS REGISTER\n0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nHC = Bit is cleared by hardware\nHS = Bit is set by hardware\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition\nbit 7\nCPRUP: SMT Manual Period Buffer Update bit\n1 = Request update to SMTxCPRx registers\n0 = SMTxCPRx registers update is complete\nbit 6\nCPWUP: SMT Manual Pulse Width Buffer Update bit\n1 = Request update to SMTxCPW registers\n0 = SMTxCPW registers update is complete\nbit 5\nRST: SMT Manual Timer Reset bit\n1 = Request Reset to SMTxTMR registers\n0 = SMTxTMR registers update is complete",
    "bit 4-3 Unimplemented : Read as ' 0 '\nbit 2\nTS: GO Value Status bit\n1 = SMT timer is incrementing\n0 = SMT timer is not incrementing\nbit 1\nWS: SMTxWIN Value Status bit\n1 = SMT window is open\n0 = SMT window is closed\nbit 0\nAS: SMT_signal Value Status bit\n1 = SMT acquisition is in progress\n0 = SMT acquisition is not in progress",
    "REGISTER 25-4: SMTxCLK: SMT CLOCK SELECTION REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = . -, 6 = CSEL<2:0>. -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition\nbit 7-3 Unimplemented : Read as ' 0 '\nbit 2-0\nCSEL<2:0>: SMT Clock Selection bits\n111 = Reference Clock Output\n110 = SOSC\n101 = MFINTOSC/16 (32 kHz)\n100 = MFINTOSC (500 kHz)\n011 = LFINTOSC\n010 = HFINTOSC 16 MHz\n001 = FOSC\n000 = FOSC/4",
    "REGISTER 25-5: SMTxWIN: SMTx WINDOW INPUT SELECT REGISTER\n-, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = WSEL<4:0>. -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition\nbit 7-5 Unimplemented : Read as ' 0 '\nbit 4-0\nWSEL<4:0>: SMTx Window Selection bits\n11111 = Reserved\n\u2022\n\u2022\n\u2022\n11011 = Reserved\n11010 = CLC4_out\n11001 = CLC3_out\n11000 = CLC2_out\n10111 = CLC1_out\n10110 = ZCD1_out\n10101 = CMP2_out\n10100 = CMP1_out\n10011 = NCO1_out\n10010 = Reserved\n10001 = Reserved\n10000 = PWM8_out\n01111\n= PWM7_out\n01110 = PWM6_out\n01101\n= PWM5_out\n01100 = CCP4_out\n01011 = CCP3_out\n01010 = CCP2_out",
    "Legend:\n01001\n= CCP1_out\n01000 = TMR6_postscaled\n00111\n= TMR4_postscaled\n00110 = TMR2_postscaled\n00101 = TMR0_overflow\n00100 = CLKREF\n00011\n= SOSC\n00010 = MFINTOSC/16 (32 kHz)\n00001\n= LFINTOSC\n00000 = SMTxWINPPS",
    "REGISTER 25-6: SMTxSIG: SMTx SIGNAL INPUT SELECT REGISTER\n-, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = SSEL<4:0>. -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition\nbit 7-5 Unimplemented : Read as ' 0 '\nbit 4-0 SSEL<4:0>: SMTx Signal Selection bits\n11111 = Reserved\nbit 4-0 SSEL<4:0>: SMTx Signal Selection bits\n11111 = Reserved\n\u2022\n\u2022\n\u2022\n11010 = CAN_rx_timestamp\n11001 = CLC4_out\n11000 = CLC3_out\n10111 = CLC2_out\n10110 = CLC1_out\n10101 = ZCD1_out\n10100 = CMP2_out\n10011 = CMP1_out\n10010 = NCO1_out\n10001 = Reserved\n10000 = Reserved\n01111 = PWM8_out\n01110 = PWM7_out\n01101 = PWM6_out",
    "Legend:\n01100 = PWM5_out\n01011 = CCP4_out\n01010 = CCP3_out\n01001 = CCP2_out\n01000 = CCP1_out\n00111 = TMR6_postscaled\n00110 = TMR5_overflow\n00101 = TMR4_postscaled\n00100 = TMR3_overflow\n00011 = TMR2_postscaled\n00010 = TMR1_overflow\n00001 = TMR0_overflow\n00000 = SMTxSIGPPS",
    "REGISTER 25-7: SMTxTMRL: SMT TIMER REGISTER - LOW BYTE\nbit 7, R/W-0/0.SMTxTMR<7:0> = . bit 7, R/W-0/0.SMTxTMR<7:0> = . bit 7, R/W-0/0.SMTxTMR<7:0> = . bit 7, R/W-0/0.SMTxTMR<7:0> = . bit 7, R/W-0/0.SMTxTMR<7:0> = . bit 7, R/W-0/0.SMTxTMR<7:0> = . bit 7, R/W-0/0.SMTxTMR<7:0> = bit 0",
    "REGISTER 25-7: SMTxTMRL: SMT TIMER REGISTER - LOW BYTE\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = \nbit 7-0 SMTxTMR<7:0> : Significant bits of the SMT Counter - Low Byte",
    "REGISTER 25-8: SMTxTMRH: SMT TIMER REGISTER - HIGH BYTE\nbit 7, R/W-0/0.SMTxTMR<15:8> = . bit 7, R/W-0/0.SMTxTMR<15:8> = . bit 7, R/W-0/0.SMTxTMR<15:8> = . bit 7, R/W-0/0.SMTxTMR<15:8> = . bit 7, R/W-0/0.SMTxTMR<15:8> = . bit 7, R/W-0/0.SMTxTMR<15:8> = . bit 7, R/W-0/0.SMTxTMR<15:8> = bit 0",
    "REGISTER 25-8: SMTxTMRH: SMT TIMER REGISTER - HIGH BYTE\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, U = Unimplemented bit, read as '0' = . u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = \nbit 7-0 SMTxTMR<15:8> : Significant bits of the SMT Counter - High Byte",
    "REGISTER 25-9: SMTxTMRU: SMT TIMER REGISTER - UPPER BYTE\nbit 7, R/W-0/0.SMTxTMR<23:16> = . bit 7, R/W-0/0.SMTxTMR<23:16> = . bit 7, R/W-0/0.SMTxTMR<23:16> = . bit 7, R/W-0/0.SMTxTMR<23:16> = . bit 7, R/W-0/0.SMTxTMR<23:16> = . bit 7, R/W-0/0.SMTxTMR<23:16> = . bit 7, R/W-0/0.SMTxTMR<23:16> = bit 0",
    "REGISTER 25-9: SMTxTMRU: SMT TIMER REGISTER - UPPER BYTE\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = \nbit 7-0 SMTxTMR<23:16> : Significant bits of the SMT Counter - Upper Byte",
    "REGISTER 25-10: SMTxCPRL: SMT CAPTURED PERIOD REGISTER - LOW BYTE\nbit 7, R-x/x.SMTxCPR<7:0> = . bit 7, R-x/x.SMTxCPR<7:0> = . bit 7, R-x/x.SMTxCPR<7:0> = . bit 7, R-x/x.SMTxCPR<7:0> = . bit 7, R-x/x.SMTxCPR<7:0> = . bit 7, R-x/x.SMTxCPR<7:0> = . bit 7, R-x/x.SMTxCPR<7:0> = bit 0",
    "REGISTER 25-10: SMTxCPRL: SMT CAPTURED PERIOD REGISTER - LOW BYTE\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-0\nSMTxCPR<7:0> : Significant bits of the SMT Period Latch - Low Byte",
    "REGISTER 25-11: SMTxCPRH: SMT CAPTURED PERIOD REGISTER - HIGH BYTE\nbit 7, R-x/x. = . bit 7, R-x/x.SMTxCPR<15:8> = . bit 7, R-x/x.SMTxCPR<15:8> = . bit 7, R-x/x.SMTxCPR<15:8> = . bit 7, R-x/x.SMTxCPR<15:8> = . bit 7, R-x/x. = . bit 7, R-x/x. = bit 0",
    "REGISTER 25-11: SMTxCPRH: SMT CAPTURED PERIOD REGISTER - HIGH BYTE\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = \nbit 7-0 SMTxCPR<15:8> : Significant bits of the SMT Period Latch - High Byte",
    "REGISTER 25-12: SMTxCPRU: SMT CAPTURED PERIOD REGISTER - UPPER BYTE\nbit 7-0 SMTxCPR<23:16> : Significant bits of the SMT Period Latch - Upper Byte\n\nbit 7, R-x/x. = . bit 7, R-x/x.SMTxCPR<23:16> = . bit 7, R-x/x.SMTxCPR<23:16> = . bit 7, R-x/x.SMTxCPR<23:16> = . bit 7, R-x/x.SMTxCPR<23:16> = . bit 7, R-x/x. = . bit 7, R-x/x. = bit 0",
    "REGISTER 25-12: SMTxCPRU: SMT CAPTURED PERIOD REGISTER - UPPER BYTE\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = ",
    "REGISTER 25-13: SMTxCPWL: SMT CAPTURED PULSE WIDTH REGISTER - LOW BYTE\nbit 7-0 SMTxCPW<7:0> : Significant bits of the SMT PW Latch - Low Byte\n\nbit 7, R-x/x.SMTxCPW<7:0> = . bit 7, R-x/x.SMTxCPW<7:0> = . bit 7, R-x/x.SMTxCPW<7:0> = . bit 7, R-x/x.SMTxCPW<7:0> = . bit 7, R-x/x.SMTxCPW<7:0> = . bit 7, R-x/x.SMTxCPW<7:0> = . bit 7, R-x/x.SMTxCPW<7:0> = bit 0",
    "REGISTER 25-13: SMTxCPWL: SMT CAPTURED PULSE WIDTH REGISTER - LOW BYTE\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = ",
    "REGISTER 25-14: SMTxCPWH: SMT CAPTURED PULSE WIDTH REGISTER - HIGH BYTE\nbit 7, R-x/x.SMTxCPW<15:8> = . bit 7, R-x/x.SMTxCPW<15:8> = . bit 7, R-x/x.SMTxCPW<15:8> = . bit 7, R-x/x.SMTxCPW<15:8> = . bit 7, R-x/x.SMTxCPW<15:8> = . bit 7, R-x/x.SMTxCPW<15:8> = . bit 7, R-x/x.SMTxCPW<15:8> = bit 0",
    "REGISTER 25-14: SMTxCPWH: SMT CAPTURED PULSE WIDTH REGISTER - HIGH BYTE\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = \nbit 7-0 SMTxCPW<15:8> : Significant bits of the SMT PW Latch - High Byte",
    "REGISTER 25-15: SMTxCPWU: SMT CAPTURED PULSE WIDTH REGISTER - UPPER BYTE\nbit 7-0 SMTxCPW<23:16> : Significant bits of the SMT PW Latch - Upper Byte\n\nbit 7, R-x/x. = . bit 7, R-x/x.SMTxCPW<23:16> = . bit 7, R-x/x.SMTxCPW<23:16> = . bit 7, R-x/x.SMTxCPW<23:16> = . bit 7, R-x/x.SMTxCPW<23:16> = . bit 7, R-x/x. = . bit 7, R-x/x. = bit 0",
    "REGISTER 25-15: SMTxCPWU: SMT CAPTURED PULSE WIDTH REGISTER - UPPER BYTE\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = ",
    "REGISTER 25-16: SMTxPRL: SMT PERIOD REGISTER - LOW BYTE\nbit 7, R/W-x/1.SMTxPR<7:0> = . bit 7, R/W-x/1.SMTxPR<7:0> = . bit 7, R/W-x/1.SMTxPR<7:0> = . bit 7, R/W-x/1.SMTxPR<7:0> = . bit 7, R/W-x/1.SMTxPR<7:0> = . bit 7, R/W-x/1.SMTxPR<7:0> = . bit 7, R/W-x/1.SMTxPR<7:0> = bit 0",
    "REGISTER 25-16: SMTxPRL: SMT PERIOD REGISTER - LOW BYTE\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-0 SMTxPR<7:0> : Significant bits of the SMT Timer Value for Period Match - Low Byte",
    "REGISTER 25-17: SMTxPRH: SMT PERIOD REGISTER - HIGH BYTE\nbit 7, R/W-x/1.SMTxPR<15:8> = . bit 7, R/W-x/1.SMTxPR<15:8> = . bit 7, R/W-x/1.SMTxPR<15:8> = . bit 7, R/W-x/1.SMTxPR<15:8> = . bit 7, R/W-x/1.SMTxPR<15:8> = . bit 7, R/W-x/1.SMTxPR<15:8> = . bit 7, R/W-x/1.SMTxPR<15:8> = bit 0",
    "REGISTER 25-17: SMTxPRH: SMT PERIOD REGISTER - HIGH BYTE\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = \nbit 7-0 SMTxPR<15:8> : Significant bits of the SMT Timer Value for Period Match - High Byte",
    "REGISTER 25-18: SMTxPRU: SMT PERIOD REGISTER - UPPER BYTE\nbit 7, R/W-x/1.SMTxPR<23:16> = . bit 7, R/W-x/1.SMTxPR<23:16> = . bit 7, R/W-x/1.SMTxPR<23:16> = . bit 7, R/W-x/1.SMTxPR<23:16> = . bit 7, R/W-x/1.SMTxPR<23:16> = . bit 7, R/W-x/1.SMTxPR<23:16> = . bit 7, R/W-x/1.SMTxPR<23:16> = bit 0",
    "REGISTER 25-18: SMTxPRU: SMT PERIOD REGISTER - UPPER BYTE\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-0 SMTxPR<23:16> : Significant bits of the SMT Timer Value for Period Match - Upper Byte",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\nSMT1CON0, Bit 6 = -. SMT1CON0, Bit 5 = STP. SMT1CON0, Bit 4 = WPOL. SMT1CON0, Bit 3 = SPOL. SMT1CON0, Bit 2 = CPOL. SMT1CON0, Bit 1 = SMT1PS<1:0>. SMT1CON0, Bit 0 = SMT1PS<1:0>. SMT1CON0, Register on Page = 381. SMT1CON1, Bit 6 = REPEAT. SMT1CON1, Bit 5 = -. SMT1CON1, Bit 4 = -. SMT1CON1, Bit 3 = . SMT1CON1, Bit 2 = MODE<3:0>. SMT1CON1, Bit 1 = MODE<3:0>. SMT1CON1, Bit 0 = . SMT1CON1, Register on Page = 382. SMT1STAT, Bit 6 = CPWUP. SMT1STAT, Bit 5 = RST. SMT1STAT, Bit 4 = -.",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\nSMT1STAT, Bit 3 = -. SMT1STAT, Bit 2 = TS. SMT1STAT, Bit 1 = WS. SMT1STAT, Bit 0 = AS. SMT1STAT, Register on Page = 383. SMT1CLK, Bit 6 = -. SMT1CLK, Bit 5 = -. SMT1CLK, Bit 4 = -. SMT1CLK, Bit 3 = -. SMT1CLK, Bit 2 = . SMT1CLK, Bit 1 = CSEL<2:0>. SMT1CLK, Bit 0 = . SMT1CLK, Register on Page = 384. SMT1SIG, Bit 6 = -. SMT1SIG, Bit 5 = -. SMT1SIG, Bit 4 = . SMT1SIG, Bit 3 = . SMT1SIG, Bit 2 = SSEL<4:0>. SMT1SIG, Bit 1 = . SMT1SIG, Bit 0 = . SMT1SIG, Register on Page =",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\n386. SMT1WIN, Bit 6 = -. SMT1WIN, Bit 5 = -. SMT1WIN, Bit 4 = . SMT1WIN, Bit 3 = . SMT1WIN, Bit 2 = WSEL<4:0>. SMT1WIN, Bit 1 = . SMT1WIN, Bit 0 = . SMT1WIN, Register on Page = 385. SMT1TMRL, Bit 6 = . SMT1TMRL, Bit 5 = . SMT1TMRL, Bit 4 = TMR<7:0>. SMT1TMRL, Bit 3 = . SMT1TMRL, Bit 2 = . SMT1TMRL, Bit 1 = . SMT1TMRL, Bit 0 = . SMT1TMRL, Register on Page = 387. SMT1TMRH, Bit 6 = . SMT1TMRH, Bit 5 = . SMT1TMRH, Bit 4 = TMR<15:8>. SMT1TMRH, Bit 3 = . SMT1TMRH, Bit 2 = . SMT1TMRH, Bit 1",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\n= . SMT1TMRH, Bit 0 = . SMT1TMRH, Register on Page = 387. SMT1TMRU, Bit 6 = . SMT1TMRU, Bit 5 = . SMT1TMRU, Bit 4 = TMR<23:16>. SMT1TMRU, Bit 3 = . SMT1TMRU, Bit 2 = . SMT1TMRU, Bit 1 = . SMT1TMRU, Bit 0 = . SMT1TMRU, Register on Page = 387. SMT1CPRL, Bit 6 = . SMT1CPRL, Bit 5 = . SMT1CPRL, Bit 4 = CPR<7:0>. SMT1CPRL, Bit 3 = . SMT1CPRL, Bit 2 = . SMT1CPRL, Bit 1 = . SMT1CPRL, Bit 0 = . SMT1CPRL, Register on Page = 388. SMT1CPRH, Bit 6 = . SMT1CPRH, Bit 5 = . SMT1CPRH, Bit 4 = CPR<15:8>.",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\nSMT1CPRH, Bit 3 = . SMT1CPRH, Bit 2 = . SMT1CPRH, Bit 1 = . SMT1CPRH, Bit 0 = . SMT1CPRH, Register on Page = 388. SMT1CPRU, Bit 6 = . SMT1CPRU, Bit 5 = . SMT1CPRU, Bit 4 = CPR<23:16>. SMT1CPRU, Bit 3 = . SMT1CPRU, Bit 2 = . SMT1CPRU, Bit 1 = . SMT1CPRU, Bit 0 = . SMT1CPRU, Register on Page = 388. SMT1CPWL, Bit 6 = . SMT1CPWL, Bit 5 = . SMT1CPWL, Bit 4 = CPW<7:0>. SMT1CPWL, Bit 3 = . SMT1CPWL, Bit 2 = . SMT1CPWL, Bit 1 = . SMT1CPWL, Bit 0 = . SMT1CPWL, Register on Page = 389. SMT1CPWH, Bit 6 =",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\n. SMT1CPWH, Bit 5 = . SMT1CPWH, Bit 4 = CPW<15:8>. SMT1CPWH, Bit 3 = . SMT1CPWH, Bit 2 = . SMT1CPWH, Bit 1 = . SMT1CPWH, Bit 0 = . SMT1CPWH, Register on Page = 389. SMT1CPWU, Bit 6 = . SMT1CPWU, Bit 5 = . SMT1CPWU, Bit 4 = CPW<23:16>. SMT1CPWU, Bit 3 = . SMT1CPWU, Bit 2 = . SMT1CPWU, Bit 1 = . SMT1CPWU, Bit 0 = . SMT1CPWU, Register on Page = 389. SMT1PRL, Bit 6 = . SMT1PRL, Bit 5 = . SMT1PRL, Bit 4 = PR<7:0>. SMT1PRL, Bit 3 = . SMT1PRL, Bit 2 = . SMT1PRL, Bit 1 =",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\n. SMT1PRL, Bit 0 = . SMT1PRL, Register on Page = 390. SMT1PRH, Bit 6 = . SMT1PRH, Bit 5 = . SMT1PRH, Bit 4 = PR<15:8>. SMT1PRH, Bit 3 = . SMT1PRH, Bit 2 = . SMT1PRH, Bit 1 = . SMT1PRH, Bit 0 = . SMT1PRH, Register on Page = 390. SMT1PRU, Bit 6 = . SMT1PRU, Bit 5 = . SMT1PRU, Bit 4 = PR<23:16>. SMT1PRU, Bit 3 = PR<23:16>. SMT1PRU, Bit 2 = . SMT1PRU, Bit 1 = . SMT1PRU, Bit 0 = . SMT1PRU, Register on Page = 390. SMT2CON0, Bit 6 = -. SMT2CON0, Bit 5 = STP. SMT2CON0, Bit 4 = WPOL.",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\nSMT2CON0, Bit 3 = SPOL. SMT2CON0, Bit 2 = CPOL. SMT2CON0, Bit 1 = SMT2PS<1:0>. SMT2CON0, Bit 0 = SMT2PS<1:0>. SMT2CON0, Register on Page = 381. SMT2CON1, Bit 6 = REPEAT. SMT2CON1, Bit 5 = -. SMT2CON1, Bit 4 = -. SMT2CON1, Bit 3 = . SMT2CON1, Bit 2 = MODE<3:0>. SMT2CON1, Bit 1 = MODE<3:0>. SMT2CON1, Bit 0 = . SMT2CON1, Register on Page = 382. SMT2STAT, Bit 6 = CPWUP. SMT2STAT, Bit 5 = RST. SMT2STAT, Bit 4 = -. SMT2STAT, Bit 3 = -. SMT2STAT, Bit 2 = TS. SMT2STAT, Bit 1 = WS.",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\nSMT2STAT, Bit 0 = AS. SMT2STAT, Register on Page = 383. SMT2CLK, Bit 6 = -. SMT2CLK, Bit 5 = -. SMT2CLK, Bit 4 = -. SMT2CLK, Bit 3 = -. SMT2CLK, Bit 2 = . SMT2CLK, Bit 1 = CSEL<2:0>. SMT2CLK, Bit 0 = . SMT2CLK, Register on Page = 384. SMT2SIG, Bit 6 = -. SMT2SIG, Bit 5 = -. SMT2SIG, Bit 4 = . SMT2SIG, Bit 3 = . SMT2SIG, Bit 2 = SSEL<4:0>. SMT2SIG, Bit 1 = . SMT2SIG, Bit 0 = . SMT2SIG, Register on Page = 386. SMT2WIN, Bit 6 = -. SMT2WIN, Bit 5 = -. SMT2WIN, Bit 4 = .",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\nSMT2WIN, Bit 3 = . SMT2WIN, Bit 2 = WSEL<4:0>. SMT2WIN, Bit 1 = . SMT2WIN, Bit 0 = . SMT2WIN, Register on Page = 385. SMT2TMRL, Bit 6 = . SMT2TMRL, Bit 5 = . SMT2TMRL, Bit 4 = TMR<7:0>. SMT2TMRL, Bit 3 = TMR<7:0>. SMT2TMRL, Bit 2 = . SMT2TMRL, Bit 1 = . SMT2TMRL, Bit 0 = . SMT2TMRL, Register on Page = 387. SMT2TMRH, Bit 6 = . SMT2TMRH, Bit 5 = . SMT2TMRH, Bit 4 = TMR<15:8>. SMT2TMRH, Bit 3 = TMR<15:8>. SMT2TMRH, Bit 2 = . SMT2TMRH, Bit 1 = . SMT2TMRH, Bit 0 = .",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\nSMT2TMRH, Register on Page = 387. SMT2TMRU, Bit 6 = . SMT2TMRU, Bit 5 = . SMT2TMRU, Bit 4 = TMR<23:16>. SMT2TMRU, Bit 3 = TMR<23:16>. SMT2TMRU, Bit 2 = . SMT2TMRU, Bit 1 = . SMT2TMRU, Bit 0 = . SMT2TMRU, Register on Page = 387. SMT2CPRL, Bit 6 = . SMT2CPRL, Bit 5 = . SMT2CPRL, Bit 4 = CPR<7:0>. SMT2CPRL, Bit 3 = CPR<7:0>. SMT2CPRL, Bit 2 = . SMT2CPRL, Bit 1 = . SMT2CPRL, Bit 0 = . SMT2CPRL, Register on Page = 388. SMT2CPRH, Bit 6 = . SMT2CPRH, Bit 5 = . SMT2CPRH, Bit 4 =",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\nCPR<15:8>. SMT2CPRH, Bit 3 = CPR<15:8>. SMT2CPRH, Bit 2 = . SMT2CPRH, Bit 1 = . SMT2CPRH, Bit 0 = . SMT2CPRH, Register on Page = 388. SMT2CPRU, Bit 6 = . SMT2CPRU, Bit 5 = . SMT2CPRU, Bit 4 = CPR<23:16>. SMT2CPRU, Bit 3 = CPR<23:16>. SMT2CPRU, Bit 2 = . SMT2CPRU, Bit 1 = . SMT2CPRU, Bit 0 = . SMT2CPRU, Register on Page = 388. SMT2CPWL, Bit 6 = . SMT2CPWL, Bit 5 = . SMT2CPWL, Bit 4 = CPW<7:0>. SMT2CPWL, Bit 3 = CPW<7:0>. SMT2CPWL, Bit 2 = . SMT2CPWL, Bit 1 = .",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\nSMT2CPWL, Bit 0 = . SMT2CPWL, Register on Page = 389. SMT2CPWH, Bit 6 = . SMT2CPWH, Bit 5 = . SMT2CPWH, Bit 4 = CPW<15:8>. SMT2CPWH, Bit 3 = CPW<15:8>. SMT2CPWH, Bit 2 = . SMT2CPWH, Bit 1 = . SMT2CPWH, Bit 0 = . SMT2CPWH, Register on Page = 389. SMT2CPWU, Bit 6 = . SMT2CPWU, Bit 5 = . SMT2CPWU, Bit 4 = CPW<23:16>. SMT2CPWU, Bit 3 = CPW<23:16>. SMT2CPWU, Bit 2 = . SMT2CPWU, Bit 1 = . SMT2CPWU, Bit 0 = . SMT2CPWU, Register on Page = 389. SMT2PRL, Bit 6 = . SMT2PRL, Bit 5",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\n= . SMT2PRL, Bit 4 = PR<7:0>. SMT2PRL, Bit 3 = PR<7:0>. SMT2PRL, Bit 2 = . SMT2PRL, Bit 1 = . SMT2PRL, Bit 0 = . SMT2PRL, Register on Page = 390. SMT2PRH, Bit 6 = . SMT2PRH, Bit 5 = . SMT2PRH, Bit 4 = PR<15:8>. SMT2PRH, Bit 3 = PR<15:8>. SMT2PRH, Bit 2 = . SMT2PRH, Bit 1 = . SMT2PRH, Bit 0 = . SMT2PRH, Register on Page = 390. SMT2PRU, Bit 6 = . SMT2PRU, Bit 5 = . SMT2PRU, Bit 4 = PR<23:16>. SMT2PRU, Bit 3 = PR<23:16>. SMT2PRU, Bit 2 = . SMT2PRU, Bit 1 = .",
    "TABLE 25-3: SUMMARY OF REGISTERS ASSOCIATED WITH SMTx\nSMT2PRU, Bit 0 = . SMT2PRU, Register on Page = 390\nLegend:\n- = unimplemented read as ' 0 '. Shaded cells are not used for the SMTx module.",
    "26.0 COMPLEMENTARY WAVEFORM GENERATOR (CWG) MODULE\nThe  Complementary  Waveform  Generator  (CWG) produces half-bridge, full-bridge, and steering of PWM waveforms. It is backwards compatible with previous CCP  functions.  The  PIC18(L)F25/26K83  family  has three instances of the CWG module.\nEach of the CWG modules has the following features:\n\u00b7 Six operating modes:\n-Synchronous Steering mode\n-Asynchronous Steering mode\n-Full-Bridge mode, Forward\n-Full-Bridge mode, Reverse\n-Half-Bridge mode\n-Push-Pull mode\n\u00b7 Output polarity control\n\u00b7 Output steering\n\u00b7 Independent 6-bit rising and falling event deadband timers\n-Clocked dead band\n-Independent rising and falling dead-band enables\n\u00b7 Auto-shutdown control with:\n-Selectable shutdown sources\n-Auto-restart option\n-Auto-shutdown pin override control",
    "26.1 Fundamental Operation\nThe CWG generates two output waveforms from the selected input source.\nThe off-to-on transition of each output can be delayed from the on-to-off transition of the other output, thereby, creating a time delay immediately where neither output is driven. This is referred to as dead time and is covered in Section 26.6 'Dead-Band Control' .\nIt may be necessary to guard against the possibility of circuit faults or a feedback event arriving too late or not at all. In this case, the active drive must be terminated before  the  Fault  condition  causes  damage.  This  is referred to as auto-shutdown and is covered in Section 26.10 'Auto-Shutdown' .",
    "26.2 Operating Modes\nThe CWG module can operate in six different modes, as specified by the MODE<2:0> bits of the CWGxCON0 register:\n\u00b7 Half-Bridge mode\n\u00b7 Push-Pull mode\n\u00b7 Asynchronous Steering mode\n\u00b7 Synchronous Steering mode\n\u00b7 Full-Bridge mode, Forward\n\u00b7 Full-Bridge mode, Reverse\nAll modes  accept  a  single  pulse  data  input,  and provide up to four outputs as described in the following sections.\nAll modes include auto-shutdown control as described in Section 26.10 'Auto-Shutdown' .\nNote:\nExcept  as  noted  for  Full-bridge  mode ( Section  26.2.3 'Full-Bridge  Modes' ), mode changes should only be performed while EN = 0 (Register 26-1).",
    "26.2.1 HALF-BRIDGE MODE\nIn Half-Bridge mode, two output signals are generated as true and inverted versions of the input as illustrated in Figure 26-2.  A  non-overlap  (dead-band)  time  is inserted between the two outputs as described in Sec -tion 26.6 'Dead-Band Control' . The output steering feature cannot be used in this mode. A basic block dia -gram of this mode is shown in Figure 26-1.\nThe unused outputs CWGxC and CWGxD drive similar signals  as  CWGxA  and  CWGxB,  with  polarity  inde -pendently controlled by the POLC and POLD bits of the CWGxCON1 register, respectively.",
    "26.2.2 PUSH-PULL MODE\nIn Push-Pull mode, two output signals are generated, alternating copies of the input as illustrated in Figure 26-4.  This  alternation  creates  the  push-pull effect  required  for  driving  some  transformer-based power supply designs. Steering modes are not used in Push-Pull mode.  A basic block diagram for the Push Pull mode is shown in Figure 26-3. -\nThe push-pull sequencer is reset whenever EN = 0 or if  an  auto-shutdown  event  occurs.  The  sequencer  is clocked  by  the  first  input  pulse,  and  the  first  output appears on CWGxA.\nThe unused outputs CWGxC and CWGxD drive copies of CWGxA and CWGxB, respectively, but with polarity controlled by the POLC  and  POLD  bits of the CWGxCON1 register, respectively.\nFIGURE 26-3: SIMPLIFIED CWG BLOCK DIAGRAM (PUSH-PULL MODE, MODE<2:0> = 101 )",
    "26.2.3 FULL-BRIDGE MODES\nIn  Forward  and  Reverse  Full-Bridge  modes,  three outputs drive static values while the fourth is modulated by the input data signal. The mode selection may be toggled between forward and reverse by toggling the MODE<0>  bit  of  the  CWGxCON0  while  keeping MODE<2:1> static, without disabling the CWG module. When connected as shown in Figure 26-5, the outputs are  appropriate  for  a  full-bridge  motor  driver.  Each CWG output signal has independent polarity control, so the circuit can be adapted to high-active and low-active drivers. A simplified block diagram for the Full-Bridge modes is shown in Figure 26-6.\nFIGURE 26-5: EXAMPLE OF FULL-BRIDGE APPLICATION",
    "MODES)\nIn Forward  Full-Bridge  mode  (MODE<2:0> = 010 ), CWGxA  is  driven  to  its  active  state,  CWGxB  and CWGxC are driven to their inactive state, and CWGxD is modulated by the input signal, as shown  in Figure 26-7.\nIn Reverse  Full-Bridge  mode  (MODE<2:0> = 011 ), CWGxC  is  driven  to  its  active  state,  CWGxA  and CWGxD are driven to their inactive states, and CWGxB is modulated by the input signal, as shown  in Figure 26-7.",
    "PIC18(L)F25/26K83\nIn  Full-Bridge  mode,  the  dead-band  period  is  used when there is a switch from forward to reverse or viceversa. This dead-band control is described in Section 26.6 'Dead-Band Control' ,  with  additional  details  in Section 26.7 'Rising Edge  and Reverse Dead Band' and Section 26.8 'Falling Edge and Forward Dead Band' . Steering modes are not used with either of the Full-Bridge modes. The mode selection may be toggled  between  forward  and  reverse  toggling  the MODE<0>  bit  of  the  CWGxCON0  while  keeping MODE<2:1> static, without disabling the CWG module.\nFIGURE 26-7: EXAMPLE OF FULL-BRIDGE OUTPUT",
    "26.2.3.1 Direction Change in Full-Bridge Mode\nIn  Full-Bridge  mode,  changing  MODE<2:0>  controls the forward/reverse direction. Changes to MODE<2:0> change to the new direction on the next rising edge of the modulated input.\nA direction change is initiated in software by changing the MODE<2:0> bits of the CWGxCON0 register. The sequence is illustrated in Figure 26-8.\n\u00b7 The associated active output CWGxA and the inactive output CWGxC are switched to drive in the opposite direction.\n\u00b7 The previously modulated output CWGxD is switched to the inactive state, and the previously inactive output CWGxB begins to modulate.\n\u00b7 CWG modulation resumes after the directionswitch dead band has elapsed.",
    "26.2.3.2 Dead-Band Delay in Full-Bridge Mode\nDead-band  delay  is  important  when  either  of  the following conditions is true:\n1. The direction of the CWG output changes when the  duty  cycle  of  the  data  input  is  at  or  near 100%, or\n2. The turn-off time of the power switch, including the  power  device  and  driver  circuit,  is  greater than the turn-on time.",
    "FIGURE 26-8: EXAMPLE OF PWM DIRECTION CHANGE AT NEAR 100% DUTY CYCLE\nThe dead-band delay is inserted only when changing directions, and only the modulated output is affected. The statically-configured outputs (CWGxA and CWGxC)  are  not  afforded  dead  band,  and  switch essentially simultaneously.\nFigure 26-8  shows  an  example  of  the  CWG  outputs changing  directions  from  forward  to  reverse,  at  near 100% duty cycle. In this example, at time t1, the output of CWGxA and CWGxD become inactive, while output CWGxC becomes active. Since the turn-off time of the power devices is longer than the turn-on time, a shootthrough current will flow through power devices QC and QD for the duration of 't'. The same phenomenon will occur  to  power  devices  QA  and  QB  for  the  CWG direction change from reverse to forward.\nWhen changing the CWG direction at high duty cycle is required for an application, two possible solutions for eliminating the shoot-through current are:\n1. Reduce  the  CWG  duty  cycle  for  one  period before changing directions.\n2. Use switch drivers that can drive the switches off faster than they can drive them on.",
    "26.2.4 STEERING MODES\nIn both Synchronous  and  Asynchronous  Steering modes, the modulated input signal can be steered to any combination of four CWG outputs and a fixed-value will  be  presented  on  all  the  outputs  not  used  for  the PWM output.  Each  output  has  independent  polarity, steering, and shutdown options. Dead-band control is not used in either steering mode.\nWhen STRx = 0 (Register 26-5), then the corresponding pin is held at the level defined by OVRx (Register 26-5). When STRx = 1 , then the pin is driven by the modulated input signal.\nThe  POLx  bits (Register 26-2) control the signal polarity only when STRx = 1 .\nThe  CWG  auto-shutdown  operation  also  applies  to steering modes as described in Section\n26.14 'Register Definitions: CWG Control' .\nNote:\nOnly the STRx bits are synchronized; the SDATx (data) bits are not synchronized.",
    "26.2.4 STEERING MODES\nThe  CWG  auto-shutdown  operation  also  applies  in Steering modes as described in Section 26.10 'AutoShutdown' '. An auto-shutdown event will only affect pins that have STRx = 1 .",
    "26.2.4.1 Synchronous Steering Mode\nIn Synchronous Steering mode (MODE<2:0> bits = 001 , Register 26-1), changes to steering selection registers take effect on the next rising edge of the modulated data input (Figure 26-9). In Synchronous  Steering  mode,  the  output  will  always produce a complete waveform.",
    "26.2.4.2 Asynchronous Steering Mode\nIn Asynchronous  mode  (MODE<2:0>  bits  = 000 , Register 26-1), steering takes effect at the end of the instruction cycle that writes to STR. In Asynchronous Steering mode, the output signal may be an incomplete waveform (Figure 26-10). This operation may be useful when the user firmware needs to immediately remove a signal from the output pin.",
    "26.2.4.3 Start-up Considerations\nThe application hardware must use the proper external pull-up and/or pull-down resistors on the CWG output pins. This is required because all I/O pins are forced to high-impedance at Reset.\nThe POLy bits (Register 26-2) allow the user to choose whether  the  output  signals  are  active-high  or  activelow.",
    "26.3 Clock Source\nThe clock source is used to drive the dead-band timing circuits. The CWG module allows the following clock sources to be selected:\n\u00b7 FOSC (system clock)\n\u00b7 HFINTOSC\nWhen the HFINTOSC is selected, the HFINTOSC will be kept running during Sleep. Therefore, CWG modes requiring  dead  band  can  operate  in  Sleep,  provided that the CWG data input is also active during Sleep.The clock  sources  are  selected  using  the  CS  bit  of  the CWGxCLKCON register (Register 26-3). The  system clock FOSC, is disabled in Sleep and thus dead-band control cannot be used.",
    "26.4 Selectable Input Sources\nThe CWG generates the output waveforms from the following input sources:",
    "TABLE 26-1: SELECTABLE INPUT SOURCES\nCWGxPPS, Signal Name = Pin selected by CWGxPPS. CWGxPPS, ISM<2:0> = 000. CCP1, Signal Name = CCP1 Output. CCP1, ISM<2:0> = 001. CCP2, Signal Name = CCP2 Output. CCP2, ISM<2:0> = 010. PWM3, Signal Name = PWM3 Output. PWM3, ISM<2:0> = 011. PWM4, Signal Name = PWM4 Output. PWM4, ISM<2:0> = 100. CMP1, Signal Name = Comparator 1 Output. CMP1, ISM<2:0> = 101. CMP2, Signal Name = Comparator 2 Output. CMP2, ISM<2:0> = 110. DSM, Signal Name = Data signal modulator output. DSM, ISM<2:0> = 111",
    "TABLE 26-1: SELECTABLE INPUT SOURCES\nThe input sources are selected using the IS<4:0> bits in the CWGxISM register (Register 26-4).",
    "26.5.1 CWG OUTPUTS\nEach CWG output can be routed to a Peripheral Pin Select (PPS) output via the RxyPPS register (see Sec -tion 17.0 'Peripheral Pin Select (PPS) Module' ).",
    "26.5.2 POLARITY CONTROL\nThe polarity of each CWG output can be selected inde -pendently. When the output polarity bit is set, the corre -sponding  output  is  active-high.  Clearing  the  output polarity  bit  configures  the  corresponding  output  as active-low. However, polarity does not affect the over -ride levels. Output polarity is selected with the POLy bits  of  the  CWGxCON1. Auto-shutdown and steering options are unaffected by polarity.",
    "26.6 Dead-Band Control\nThe dead-band control provides non-overlapping PWM signals to prevent  shoot-through  current  in  PWM switches. Dead-band operation is employed for HalfBridge and Full-Bridge modes. The CWG contains two 6-bit  dead-band  counters.  One  is  used  for  the  rising edge of the input source control in Half-Bridge mode or for reverse dead-band Full-Bridge mode. The other is used for the falling edge of the input source control in Half-Bridge  mode  or  for  forward  dead  band  in  FullBridge mode.\nDead band is timed by counting CWG clock periods from zero up to the value in the rising or falling deadband counter registers. See CWGxDBR and CWGxDBF registers, respectively.",
    "26.6.1 DEAD-BAND FUNCTIONALITY IN HALF-BRIDGE MODE\nIn  Half-Bridge mode, the dead-band counters dictate the delay between the falling edge of the normal output and the rising edge of the inverted output. This can be seen in Figure 26-2.",
    "26.6.2 DEAD-BAND FUNCTIONALITY IN FULL-BRIDGE MODE\nIn Full-Bridge mode, the dead-band counters are used when undergoing a direction change. The MODE<0> bit of the CWGxCON0 register can be set or cleared while the CWG is running, allowing for changes from Forward to Reverse mode. The CWGxA and CWGxC signals  will  change  immediately  upon  the  first  rising input edge following a direction change, but the modu -lated signals (CWGxB or CWGxD, depending on the direction of the change) will experience a delay dictated by the dead-band counters.",
    "26.7 Rising Edge and Reverse Dead Band\nIn Half-Bridge mode, the rising edge dead band delays the turn-on of the CWGxA output after the rising edge of  the  CWG  data  input.  In  Full-Bridge  mode,  the reverse dead-band delay is only inserted when changing  directions  from  Forward  mode  to  Reverse mode,  and  only  the  modulated  output  CWGxB  is affected.\nThe CWGxDBR register determines the duration of the dead-band  interval  on  the  rising  edge  of  the  input source signal. This duration is from 0 to 64 periods of the CWG clock.\nDead band is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf  the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.",
    "26.7 Rising Edge and Reverse Dead Band\nThe  CWGxDBR  register  value  is  double-buffered. When  EN  = 0 (Register 26-1),  the  buffer  is  loaded when CWGxDBR is written. If EN = 1 , then the buffer will be loaded at the rising edge following the first falling edge of the data input, after the LD bit (Register 26-1) is set. Refer to Figure 26-12 for an example.",
    "26.8 Falling Edge and Forward Dead Band\nIn Half-Bridge mode, the falling edge dead band delays the turn-on of the CWGxB output at the falling edge of the CWG data input. In Full-Bridge mode, the forward dead-band delay is only inserted when changing direc -tions from Reverse mode to Forward mode, and only the modulated output CWGxD is affected.\nThe CWGxDBF register determines the duration of the dead-band  interval  on  the  falling  edge  of  the  input source signal. This duration is from zero to 64 periods of CWG clock.\nDead-band delay is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf  the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.",
    "26.8 Falling Edge and Forward Dead Band\nThe CWGxDBF register value is double-buffered. When EN = 0 (Register 26-1), the buffer is loaded when CWGxDBF is written. If EN = 1 , then the buffer will be loaded at the rising edge following the first falling edge of the data input after the LD (Register 261) is set. Refer to Figure 26-13 for an example.\nFIGURE 26-13: DEAD-BAND OPERATION, CWGxDBR = 0x03, CWGxDBF = 0x06, SOURCE SHORTER THAN DEAD BAND",
    "26.9 Dead-Band Jitter\nWhen the rising and falling edges of the input source are asynchronous to the CWG clock, it creates jitter in the dead-band time delay. The maximum jitter is equal to one CWG clock period. Refer to Equation 26-1 for more details.",
    "EQUATION 26-1: DEAD-BAND DELAY TIME CALCULATION\n```\nT D EAD -BAND_M IN 1 - - - - - - F C W G   C LO C K - - - - - - - - -- - - - - -- - - - - - - - -----------D Bx 4: 0> \uf03c \uf0b7 = T D EAD -BANDM AX 1 - - - - - - F CW G",
    "EQUATION 26-1: DEAD-BAND DELAY TIME CALCULATION\nC LO C K - -- - - - - - - -- - - - -- ----- ------------ -D Bx 4: 0>+1 \uf03c \uf0b7 = T JI TTER T DEAD -BAND_M AX T D EAD -BAND_M IN -= T JI TTER 1 - - - - - - - F CW G _CLO CK - - - - - - - - - -- - - - -- - - - - - - --------------= T DEAD -BAND_M AX T DEAD -BAND_M IN T JI TTER + = EXAM PLE DBR<4: 0>= 0x0A  = 10 F CW G _C LO CK = 8  M H z T JI TTER = 1 - - 8M H z - - - - - -- -- ---125  ns = T D EAD -BAND_M IN 125  ns*10  = 125  s \uf06d = T D EAD -BAND_M AX 1. 25  s+ 0. 125 \uf06d \uf06d s= 1. 37 \uf06d s =",
    "EQUATION 26-1: DEAD-BAND DELAY TIME CALCULATION\n```",
    "26.10 Auto-Shutdown\nAuto-shutdown is a method to immediately override the CWG output levels with specific overrides that allow for safe shutdown of the circuit. The shutdown state can be either  cleared  automatically  or  held  until  cleared  by software.  The  auto-shutdown  circuit  is  illustrated  in Figure 26-14.",
    "26.10.1 SHUTDOWN\nThe shutdown state  can  be  entered  by  either  of  the following two methods:\n\u00b7 Software generated\n\u00b7 External Input",
    "26.10.1.1 Software Generated Shutdown\nSetting the SHUTDOWN bit of the CWGxAS0 register will force the CWG into the shutdown state.\nWhen the auto-restart is disabled, the shutdown state will persist as long as the SHUTDOWN bit is set.\nWhen auto-restart is enabled, the SHUTDOWN bit will clear automatically and resume operation on the next rising edge event. The SHUTDOWN bit indicates when a  shutdown  condition  exists.  The  bit  may  be  set  or cleared in software or by hardware.",
    "26.10.1.2 External Input Source\nExternal shutdown inputs provide the fastest way to safely suspend CWG operation in the event of a Fault condition. When any of the selected shutdown inputs goes active, the  CWG  outputs  will  immediately  go  to  the  specified override levels without software delay. The override levels are selected by the LSBD<1:0> and LSAC<1:0> bits of the  CWGxAS0  register  (Register 26-6).  Several  input sources can be selected to cause a shutdown condition. All input sources are active-low. The sources are:\n\u00b7 Pin selected by CWGxPPS\n\u00b7 Timer2 postscaled output\n\u00b7 Timer4 postscaled output\n\u00b7 Timer6 postscaled output\n\u00b7 Comparator 1 output\n\u00b7 Comparator 2 output\n\u00b7 CLC2 output\nShutdown input sources are individually enabled by the ASxE bits of the CWGxAS1 register (Register 26-7).\nNote:\nShutdown inputs  are  level  sensitive,  not edge sensitive. The shutdown state can -not be cleared, except by disabling autoshutdown, as long as the shutdown input level persists.",
    "26.10.1.3 Pin Override Levels\nThe levels driven to the CWG outputs during an autoshutdown event are controlled by the LSBD<1:0> and LSAC<1:0> bits of the CWGxAS0 register (Register 26-6). The LSBD<1:0> bits control CWGxB/ D output levels, while the LSAC<1:0> bits control the CWGxA/C output levels.",
    "26.10.1.4 Auto-Shutdown Interrupts\nWhen an auto-shutdown event occurs, either by soft -ware or hardware setting SHUTDOWN, the CWGxIF flag bit of the respective PIR register is set.",
    "26.11 Auto-Shutdown Restart\nAfter an auto-shutdown event has occurred, there are two ways to resume operation:\n\u00b7 Software controlled\n\u00b7 Auto-restart\nIn either case, the shutdown source must be cleared before  the  restart  can  take  place.  That  is,  either  the shutdown condition must be removed, or the corresponding ASxE bit must be cleared.",
    "26.11.1 SOFTWARE-CONTROLLED RESTART\nIf the  REN  bit  of  the  CWGxAS0  register  is  clear (REN = 0 ), the CWG module must be restarted after an auto-shutdown event through software.\nOnce  all  auto-shutdown  sources  are  removed,  the software must clear SHUTDOWN. Once SHUTDOWN is  cleared,  the  CWG  module  will  resume  operation upon the first rising edge of the CWG data input.\nNote:\nThe SHUTDOWN bit cannot be cleared in software if the auto-shutdown condition is still present.",
    "26.11.2 AUTO-RESTART\nIf the REN bit of the CWGxAS0 register is set (REN = 1 ), the  CWG module will restart from the shutdown state automatically.\nOnce all auto-shutdown  conditions are removed, the hardware will automatically clear SHUTDOWN. Once SHUTDOWN is cleared, the CWG module will resume operation upon the first rising edge of the CWG data input.\nNote:\nThe SHUTDOWN bit cannot be cleared in software if the auto-shutdown condition is still present.",
    "26.12 Operation During Sleep\nThe CWG module operates independently from the system clock and will continue to run during Sleep, provided that the clock and input sources selected remain active.\nThe HFINTOSC remains active during Sleep when all the following conditions are met:\n\u00b7 CWG module is enabled\n\u00b7 Input source is active\n\u00b7 HFINTOSC is selected as the clock source, regardless of the system clock source selected.\nIn  other  words,  if  the  HFINTOSC  is  simultaneously selected as system clock and CWG clock, when the CWG is enabled and the input source is active, then the CPU will go Idle during Sleep, but the HFINTOSC will remain active and the CWG will continue to operate. This will have a direct effect on the Sleep mode current.",
    "26.13 Configuring the CWG\n1. Ensure that the TRIS control bits corresponding to CWG  outputs are set so that all are configured as inputs, ensuring that the outputs are  inactive  during  setup.  External  hardware should ensure that pin levels  are  held  to  safe levels.\n2. Clear the EN bit, if not already cleared.\n3. Configure  the  MODE<2:0>  bits  of  the  CWGx -CON0 register to set the output operating mode.\n4. Configure  the  POLy  bits  of  the  CWGxCON1 register to set the output polarities.\n5. Configure the ISM<4:0> bits of the CWGxISM register to select the data input source.\n6. If  a  steering  mode  is  selected,  configure  the STRx bits  to  select  the  desired  output  on  the CWG outputs.\n7. Configure the LSBD<1:0> and LSAC<1:0> bits of  the  CWGxASD0 register to select the autoshutdown output override states (this is necessary  even  if  not  using  auto-shutdown because start-up will be from a shutdown state).",
    "26.13 Configuring the CWG\n8. If  auto-restart  is  desired,  set  the  REN  bit  of CWGxAS0.\n9. If auto-shutdown is desired, configure the ASxE bits of the CWGxAS1 register to select the shut -down source.\n10. Set  the  desired  rising  and  falling  dead-band times with the CWGxDBR  and  CWGxDBF registers.\n11. Select the clock source in the CWGxCLKCON register.\n12. Set the EN bit to enable the module.\n13. Clear the TRIS bits that correspond to the CWG outputs to set them as outputs.\nIf  auto-restart is to be used, set the REN bit and the SHUTDOWN bit will be cleared automatically. Other -wise, clear the SHUTDOWN bit in software to start the CWG.",
    "FIGURE 26-14: CWG SHUTDOWN BLOCK DIAGRAM\nFIGURE 26-15: SHUTDOWN FUNCTIONALITY, AUTO-RESTART DISABLED (REN =  , LSAC = 0 01 , LSBD = 01 )",
    "26.14 Register Definitions: CWG Control\nLong  bit  name  prefixes  for  the  CWG  peripheral  is shown  below.  Refer  to Section  1.3.2.2 'Long  Bit Names' for more information.\nCWG1, Bit Name Prefix = CWG1. CWG2, Bit Name Prefix = CWG2. CWG3, Bit Name Prefix = CWG3\nl",
    "REGISTER 26-1: CWGxCON0: CWG CONTROL REGISTER 0\nR/W-0/0, 1 = R/W/HC-0/0. R/W-0/0, 2 = U-0. R/W-0/0, 3 = U-0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. EN, 1 = LD (1). EN, 2 = -. EN, 3 = -. EN, 4 = -. EN, 5 = MODE<2:0>. EN, 6 = MODE<2:0>. EN, 7 = MODE<2:0>. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 26-1: CWGxCON0: CWG CONTROL REGISTER 0\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HC = Bit is cleared by hardware\nbit 7\nEN:\nCWGx Enable bit\n1 = Module is enabled\n0 = Module is disabled\nbit 6\nLD: CWGx Load Buffers bit (1)\n1 = Dead-band count buffers to be loaded on CWG data rising edge, following first falling edge after this bit is set\n0 = Buffers remain unchanged\nbit 5-3\nUnimplemented : Read as ' 0\n'\nbit 2-0\nMODE<2:0> : CWGx Mode bits\n111 = Reserved\n110 = Reserved\n101 = CWG outputs operate in Push-Pull mode\n100 = CWG outputs operate in Half-Bridge mode\n011 = CWG outputs operate in Reverse Full-Bridge mode",
    "REGISTER 26-1: CWGxCON0: CWG CONTROL REGISTER 0\n010 = CWG outputs operate in Forward Full-Bridge mode\n001 = CWG outputs operate in Synchronous Steering mode\n000 = CWG outputs operate in Asynchronous Steering mode\nNote 1: This bit can only be set after EN = 1 ; it cannot be set in the same cycle when EN is set.",
    "REGISTER 26-2: CWGxCON1: CWG CONTROL REGISTER 1\n-, U-0 = -. -, R-x = IN. -, U-0 = -. -, R/W-0/0 = POLD. -, R/W-0/0 = POLC. -, R/W-0/0 = POLB. -, R/W-0/0 = POLA. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R-x = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition\nbit 7-6\nUnimplemented: Read as ' 0 '\nbit 5\nIN: CWG Input Value bit (read-only)\nbit 4\nUnimplemented: Read as ' 0 '\nbit 3\nPOLD: CWGxD Output Polarity bit\n1 = Signal output is inverted polarity\n0 = Signal output is normal polarity\nbit 2\nPOLC: CWGxC Output Polarity bit\n1\n= Signal output is inverted polarity\n0 = Signal output is normal polarity\nbit 1\nPOLB: CWGxB Output Polarity bit\n1 = Signal output is inverted polarity\n0 = Signal output is normal polarity\nbit 0\nPOLA: CWGxA Output Polarity bit\n1 = Signal output is inverted polarity\n0 = Signal output is normal polarity",
    "REGISTER 26-3: CWGxCLK: CWGx CLOCK INPUT SELECTION REGISTER\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-0/0 = CS. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0",
    "REGISTER 26-3: CWGxCLK: CWGx CLOCK INPUT SELECTION REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = q = Value depends on condition\nbit 7-1 Unimplemented: Read as ' 0 '\nbit 0\nCS: CWG Clock Source Selection Select bits\nNote 1: HFINTOSC remains operating during Sleep.\n\n1, CWG1 = HFINTOSC (1). 1, CWG2 = HFINTOSC (1). 1, CWG3 = HFINTOSC (1). 0, CWG1 = FOSC. 0, CWG2 = FOSC. 0, CWG3 = FOSC",
    "REGISTER 26-4: CWGxISM: CWGx INPUT SELECTION REGISTER\n-, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = IS<4:0>. -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 26-4: CWGxISM: CWGx INPUT SELECTION REGISTER\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = q = Value depends on condition\nbit 7-5 Unimplemented Read as '0'\nbit 4-0 IS<4:0>: CWG Data Input Selection Multiplexer Select bits",
    "REGISTER 26-4: CWGxISM: CWGx INPUT SELECTION REGISTER\n11111-10011, CWG1.Input Selection = Reserved. 11111-10011, CWG2.Input Selection = Reserved. 11111-10011, CWG3.Input Selection = Reserved. 10010, CWG1.Input Selection = CLC4_out. 10010, CWG2.Input Selection = CLC4_out. 10010, CWG3.Input Selection = CLC4_out. 10001, CWG1.Input Selection = CLC3_out. 10001, CWG2.Input Selection = CLC3_out. 10001, CWG3.Input Selection = CLC3_out. 10000, CWG1.Input Selection = CLC2_out. 10000, CWG2.Input Selection = CLC2_out. 10000, CWG3.Input Selection = CLC2_out. 01111, CWG1.Input Selection = CLC1_out. 01111, CWG2.Input Selection = CLC1_out. 01111, CWG3.Input Selection = CLC1_out.",
    "REGISTER 26-4: CWGxISM: CWGx INPUT SELECTION REGISTER\n01110, CWG1.Input Selection = DSM_out. 01110, CWG2.Input Selection = DSM_out. 01110, CWG3.Input Selection = DSM_out. 01101, CWG1.Input Selection = CMP2OUT. 01101, CWG2.Input Selection = CMP2OUT. 01101, CWG3.Input Selection = CMP2OUT. 01100, CWG1.Input Selection = CMP1OUT. 01100, CWG2.Input Selection = CMP1OUT. 01100, CWG3.Input Selection = CMP1OUT. 01011, CWG1.Input Selection = NCO1OUT. 01011, CWG2.Input Selection = NCO1OUT. 01011, CWG3.Input Selection = NCO1OUT. 01010-01001, CWG1.Input Selection = Reserved. 01010-01001, CWG2.Input Selection = Reserved. 01010-01001, CWG3.Input Selection = Reserved.",
    "REGISTER 26-4: CWGxISM: CWGx INPUT SELECTION REGISTER\n01000, CWG1.Input Selection = PWM8OUT. 01000, CWG2.Input Selection = PWM8OUT. 01000, CWG3.Input Selection = PWM8OUT. 00111, CWG1.Input Selection = PWM7OUT. 00111, CWG2.Input Selection = PWM7OUT. 00111, CWG3.Input Selection = PWM7OUT. 00110, CWG1.Input Selection = PWM6OUT. 00110, CWG2.Input Selection = PWM6OUT. 00110, CWG3.Input Selection = PWM6OUT. 00101, CWG1.Input Selection = PWM5OUT. 00101, CWG2.Input Selection = PWM5OUT. 00101, CWG3.Input Selection = PWM5OUT. 00100, CWG1.Input Selection = CCP4_out. 00100, CWG2.Input Selection = CCP4_out. 00100, CWG3.Input Selection =",
    "REGISTER 26-4: CWGxISM: CWGx INPUT SELECTION REGISTER\nCCP4_out. 00011, CWG1.Input Selection = CCP3_out. 00011, CWG2.Input Selection = CCP3_out. 00011, CWG3.Input Selection = CCP3_out. 00010, CWG1.Input Selection = CCP2_out. 00010, CWG2.Input Selection = CCP2_out. 00010, CWG3.Input Selection = CCP2_out. 00001, CWG1.Input Selection = CCP1_out. 00001, CWG2.Input Selection = CCP1_out. 00001, CWG3.Input Selection = CCP1_out. 00000, CWG1.Input Selection = Pin selected by CWG1PPS. 00000, CWG2.Input Selection = Pin selected by CWG2PPS. 00000, CWG3.Input Selection = Pin selected by CWG3PPS",
    "REGISTER 26-5: CWGxSTR (1) : CWG STEERING CONTROL REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. OVRD, 1 = OVRC. OVRD, 2 = OVRB. OVRD, 3 = OVRA. OVRD, 4 = STRD (2). OVRD, 5 = STRC (2). OVRD, 6 = STRB (2). OVRD, 7 = STRA (2). bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7,",
    "REGISTER 26-5: CWGxSTR (1) : CWG STEERING CONTROL REGISTER\n6 = . bit 7, 7 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = q = Value depends on condition\nbit 7\nOVRD:\nSteering Data D bit\nbit 6 OVRC:\nSteering Data C bit\nbit 5 OVRB:\nSteering Data B bit\nbit 4 OVRA:\nSteering Data A bit\nbit 3\nSTRD:\nSteering Enable bit D (2)\n1 = CWGxD output has the CWG data input waveform with polarity control from POLD bit 0 = CWGxD output is assigned to value of OVRD bit\nbit 2",
    "REGISTER 26-5: CWGxSTR (1) : CWG STEERING CONTROL REGISTER\nSTRC: Steering Enable bit C (2)\n1 = CWGxC output has the CWG data input waveform with polarity control from POLC bit\n0 = CWGxC output is assigned to value of OVRC bit",
    "bit 1\nSTRB: Steering Enable bit B (2)\n1 = CWGxB output has the CWG data input waveform with polarity control from POLB bit\n0 = CWGxB output is assigned to value of OVRB bit\nbit 0\nSTRA: Steering Enable bit A\n(2)\n1 = CWGxA output has the CWG data input waveform with polarity control from POLA bit\n0 = CWGxA output is assigned to value of OVRA bit\nNote 1: The bits in this register apply only when MODE<2:0> = 00x (Register 26-1, Steering modes).\n2: This bit is double-buffered when MODE<2:0> = 001 .",
    "REGISTER 26-6: CWGxAS0: CWG AUTO-SHUTDOWN CONTROL REGISTER 0\nR/W/HS/HC-0/0, 1 = R/W-0/0. R/W/HS/HC-0/0, 2 = R/W-0/0. R/W/HS/HC-0/0, 3 = R/W-1/1. R/W/HS/HC-0/0, 4 = R/W-0/0. R/W/HS/HC-0/0, 5 = R/W-1/1. R/W/HS/HC-0/0, 6 = U-0. R/W/HS/HC-0/0, 7 = U-0. SHUTDOWN, 1 = REN. SHUTDOWN, 2 = LSBD<1:0>. SHUTDOWN, 3 = LSBD<1:0>. SHUTDOWN, 4 = LSAC<1:0>. SHUTDOWN, 5 = LSAC<1:0>. SHUTDOWN, 6 = -. SHUTDOWN, 7 = -. bit 7, 1 = bit 7. bit 7, 2 =",
    "REGISTER 26-6: CWGxAS0: CWG AUTO-SHUTDOWN CONTROL REGISTER 0\nbit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets HS/HC = Bit is set/cleared by hardware\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition\nSHUTDOWN: Auto-Shutdown Event Status bit (1,2)",
    "bit 7\n1 = An auto-shutdown state is in effect\n0 = No auto-shutdown event has occurred",
    "bit 6\nREN: Auto-Restart Enable bit\n1 = Auto-restart is enabled\n0 = Auto-restart is disabled",
    "bit 5-4\nLSBD<1:0>: CWGxB and CWGxD Auto-Shutdown State Control bits\n11 = A logic ' 1 ' is placed on CWGxB/D when an auto-shutdown event occurs.\n10 = A logic ' 0 ' is placed on CWGxB/D when an auto-shutdown event occurs.\n01 = Pin is tri-stated on CWGxB/D when an auto-shutdown event occurs.\n00 = The inactive  state of  the  pin,  including  polarity,  is  placed  on  CWGxB/D  after  the  required dead-band interval when an auto-shutdown event occurs.",
    "bit 3-2\nLSAC<1:0>: CWGxA and CWGxC Auto-Shutdown State Control bits\n11 = A logic ' 1 ' is placed on CWGxA/C when an auto-shutdown event occurs.\n10 = A logic ' 0 ' is placed on CWGxA/C when an auto-shutdown event occurs.\n01 = Pin is tri-stated on CWGxA/C when an auto-shutdown event occurs.\n00 = The inactive  state of  the  pin,  including  polarity,  is  placed  on  CWGxA/C  after  the  required dead-band interval when an auto-shutdown event occurs.",
    "bit 1-0 Unimplemented: Read as ' 0 '\nNote 1: This bit may be written while EN = 0 (Register 26-1), to place the outputs into the shutdown configuration.\n2: The outputs will remain in auto-shutdown state until the next rising edge of the CWG data input after this bit is cleared.\nbit 4\nbit 2\nbit 1\nbit 0",
    "REGISTER 26-7: CWGxAS1: CWG AUTO-SHUTDOWN CONTROL REGISTER 1\n-, R/W-0/0 = AS6E. -, R/W-0/0 = AS5E. -, R/W-0/0 = AS4E. -, R/W-0/0 = AS3E. -, R/W-0/0 = AS2E. -, R/W-0/0 = AS1E. -, R/W-0/0 = AS0E. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0",
    "REGISTER 26-7: CWGxAS1: CWG AUTO-SHUTDOWN CONTROL REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = q = Value depends on condition",
    "bit 6 AS6E: CWG Auto-shutdown Source 6 Enable bit\n1 = Auto-shutdown for Source 6 is enabled\n0 =   Auto-shutdown for Source 6 is disabled\nAuto-shutdown Source 6, CWG1 = CLC2 OUT. Auto-shutdown Source 6, CWG2 = CLC3 OUT. Auto-shutdown Source 6, CWG3 = CLC4 OUT",
    "bit 5 AS5E: CWG Auto-shutdown Source 5 (CMP2 OUT) Enable bit\n1 = Auto-shutdown for CMP2 OUT is enabled\n0 = Auto-shutdown for CMP2 OUT is disabled\nAS4E: CWG Auto-shutdown Source 4 (CMP1 OUT) Enable bit\n1 = Auto-shutdown for CMP1 OUT is enabled\n0 = Auto-shutdown for CMP1 OUT is disabled",
    "bit 3 AS3E: CWG Auto-shutdown Source 3 (TMR6_Postscaled) Enable bit\n1 = Auto-shutdown for TMR6_Postscaled is enabled\n0 = Auto-shutdown for TMR6_Postscaled is disabled\nAS2E: CWG Auto-shutdown Source 2 (TMR4_Postscaled) Enable bit\n1 = Auto-shutdown for TMR4_Postscaled is enabled\n0 = Auto-shutdown for TMR4_Postscaled is disabled\nAS1E: CWG Auto-shutdown Source 1 (TMR2_Postscaled) Enable bit\n1 = Auto-shutdown for TMR2_Postscaled is enabled\n0 = Auto-shutdown for TMR2_Postscaled is disabled\nAS0E: CWG Auto-shutdown Source 0 (Pin selected by CWGxPPS) Enable bit\n1 = Auto-shutdown for CWGxPPS Pin is enabled\n0 = Auto-shutdown for CWGxPPS Pin is disabled",
    "REGISTER 26-8: CWGxDBR: CWG RISING DEAD-BAND COUNT REGISTER\n-, U-0 = -. -, R/W-x/u = . -, R/W-x/u = . -, R/W-x/u = DBR<5:0>. -, R/W-x/u = . -, R/W-x/u = . -, R/W-x/u = . bit 7, U-0 = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = bit 0",
    "REGISTER 26-8: CWGxDBR: CWG RISING DEAD-BAND COUNT REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = q = Value depends on condition",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5-0\nDBR<5:0>: CWG Rising Edge Triggered Dead-Band Count bits\n11 1111\n=   63-64 CWG clock periods\n11 1110 =   62-63 CWG clock periods\n.\n.\n.\n00 0010 =   2-3 CWG clock periods\n00 0001 =   1-2 CWG clock periods\n00 0000 =   0 CWG clock periods. Dead-band generation is by-passed",
    "REGISTER 26-9: CWGxDBF: CWG FALLING DEAD-BAND COUNT REGISTER\n-, U-0 = -. -, R/W-x/u = DBF<5:0>. -, R/W-x/u = DBF<5:0>. -, R/W-x/u = DBF<5:0>. -, R/W-x/u = DBF<5:0>. -, R/W-x/u = DBF<5:0>. -, R/W-x/u = DBF<5:0>. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0",
    "REGISTER 26-9: CWGxDBF: CWG FALLING DEAD-BAND COUNT REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = q = Value depends on condition",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5-0\nDBF<5:0>: CWG Falling Edge Triggered Dead-Band Count bits\n11 1111\n=   63-64 CWG clock periods\n11 1110 =   62-63 CWG clock periods\n.\n.\n.\n00 0010 =   2-3 CWG clock periods\n00 0001 =   1-2 CWG clock periods\n00 0000 =   0 CWG clock periods. Dead-band generation is by-passed.",
    "TABLE 26-2: SUMMARY OF REGISTERS ASSOCIATED WITH CWG\nCWGxCON0, Bit 7 = EN. CWGxCON0, Bit 6 = LD. CWGxCON0, Bit 5 = -. CWGxCON0, Bit 4 = -. CWGxCON0, Bit 3 = -. CWGxCON0, Bit 2 = MODE<2:0>. CWGxCON0, Bit 1 = MODE<2:0>. CWGxCON0, Bit 0 = MODE<2:0>. CWGxCON0, Register on Page = 411. CWGxCON1, Bit 7 = -. CWGxCON1, Bit 6 = -. CWGxCON1, Bit 5 = IN. CWGxCON1, Bit 4 = -. CWGxCON1, Bit 3 = POLD. CWGxCON1, Bit 2 = POLC. CWGxCON1, Bit 1 = POLB. CWGxCON1, Bit 0 = POLA. CWGxCON1, Register on Page = 412. CWGxCLK, Bit 7 = -. CWGxCLK, Bit 6 = -.",
    "TABLE 26-2: SUMMARY OF REGISTERS ASSOCIATED WITH CWG\nCWGxCLK, Bit 5 = -. CWGxCLK, Bit 4 = -. CWGxCLK, Bit 3 = -. CWGxCLK, Bit 2 = -. CWGxCLK, Bit 1 = -. CWGxCLK, Bit 0 = CS. CWGxCLK, Register on Page = 413. CWGxISM, Bit 7 = -. CWGxISM, Bit 6 = -. CWGxISM, Bit 5 = -. CWGxISM, Bit 4 = -. CWGxISM, Bit 3 = -. CWGxISM, Bit 2 = ISM<2:0>. CWGxISM, Bit 1 = ISM<2:0>. CWGxISM, Bit 0 = ISM<2:0>. CWGxISM, Register on Page = 414. CWGxSTR, Bit 7 = OVRD. CWGxSTR, Bit 6 = OVRC. CWGxSTR, Bit 5 = OVRB. CWGxSTR, Bit 4 = OVRA.",
    "TABLE 26-2: SUMMARY OF REGISTERS ASSOCIATED WITH CWG\nCWGxSTR, Bit 3 = STRD. CWGxSTR, Bit 2 = STRC. CWGxSTR, Bit 1 = STRB. CWGxSTR, Bit 0 = STRA. CWGxSTR, Register on Page = 415. CWGxAS0, Bit 7 = SHUTDOWN. CWGxAS0, Bit 6 = REN. CWGxAS0, Bit 5 = LSBD<1:0>. CWGxAS0, Bit 4 = LSBD<1:0>. CWGxAS0, Bit 3 = LSAC<1:0>. CWGxAS0, Bit 2 = LSAC<1:0>. CWGxAS0, Bit 1 = -. CWGxAS0, Bit 0 = -. CWGxAS0, Register on Page = 416. CWGxAS1, Bit 7 = -. CWGxAS1, Bit 6 = AS6E. CWGxAS1, Bit 5 = AS5E. CWGxAS1, Bit 4 = AS4E.",
    "TABLE 26-2: SUMMARY OF REGISTERS ASSOCIATED WITH CWG\nCWGxAS1, Bit 3 = AS3E. CWGxAS1, Bit 2 = AS2E. CWGxAS1, Bit 1 = AS1E. CWGxAS1, Bit 0 = AS0E. CWGxAS1, Register on Page = 417. CWGxDBR, Bit 7 = -. CWGxDBR, Bit 6 = -. CWGxDBR, Bit 5 = DBR<5:0>. CWGxDBR, Bit 4 = DBR<5:0>. CWGxDBR, Bit 3 = DBR<5:0>. CWGxDBR, Bit 2 = DBR<5:0>. CWGxDBR, Bit 1 = DBR<5:0>. CWGxDBR, Bit 0 = DBR<5:0>. CWGxDBR, Register on Page = 418. CWGxDBF, Bit 7 = -. CWGxDBF, Bit 6 = -. CWGxDBF, Bit 5 = DBF<5:0>.",
    "TABLE 26-2: SUMMARY OF REGISTERS ASSOCIATED WITH CWG\nCWGxDBF, Bit 4 = DBF<5:0>. CWGxDBF, Bit 3 = DBF<5:0>. CWGxDBF, Bit 2 = DBF<5:0>. CWGxDBF, Bit 1 = DBF<5:0>. CWGxDBF, Bit 0 = DBF<5:0>. CWGxDBF, Register on Page = 418\nLegend: - = unimplemented locations read as ' 0 '. Shaded cells are not used by CWG.",
    "27.0 CONFIGURABLE LOGIC CELL (CLC)\nThe Configurable Logic Cell (CLCx) module provides programmable logic  that  operates  outside  the  speed limitations of software execution. The logic cell takes up to 32 input signals and, through the use of configurable gates, reduces the 32 inputs to four logic lines that drive one of eight selectable single-output logic functions.\nInput sources are a combination of the following:\n\u00b7 I/O pins\n\u00b7 Internal clocks\n\u00b7 Peripherals\n\u00b7 Register bits\nThe output can be directed internally to peripherals and to an output pin.\nThere are four CLC modules available on this device CLC1, CLC2, CLC3 and CLC4.",
    "Note:\nThe  CLC1,  CLC2,  CLC3  and  CLC4  are four  separate  module  instances  of  the same  CLC  module  design.  Throughout this section, the lower case 'x' in register names is a generic reference to the CLC number (which should be substituted with 1,  2,  3,  or  4  during  code  development). For example, the control register is gener -ically described in this chapter as CLCxCON, but the actual device registers are  CLC1CON,  CLC2CON,  CLC3CON and CLC4CON.\nRefer to Figure 27-1 for a simplified diagram showing signal flow through the CLCx.\nPossible configurations include:\n\u00b7 Combinatorial Logic\n-AND\n-NAND\n-AND-OR\n-AND-OR-INVERT\n-OR-XOR\n-OR-XNOR\n\u00b7 Latches\n-S-R\n-Clocked D with Set and Reset\n-Transparent D with Set and Reset",
    "27.1 CLCx Setup\nProgramming  the  CLCx  module  is  performed  by configuring the four stages in the logic signal flow. The four stages are:\n\u00b7 Data selection\n\u00b7 Data gating\n\u00b7 Logic function selection\n\u00b7 Output polarity\nEach stage is setup at run time by writing to the corre -sponding CLCx Special Function Registers. This has the added advantage of permitting logic reconfiguration on-the-fly during program execution.",
    "27.1.1 DATA SELECTION\nThere  are  32  signals  available as inputs to the configurable logic. Four 32-input multiplexers are used to select the inputs to pass on to the next stage.\nData selection is through four multiplexers as indicated on the left side of Figure 27-2. Data inputs in the figure are identified by a generic numbered input name.\nTable 27-1  correlates  the  generic  input  name  to  the actual signal for each CLC module. The column labeled 'DyS<4:0> Value' indicates the MUX selection code for the selected data input. DyS is an abbreviation for the MUX select input codes: D1S<4:0> through D4S<4:0>.\nData  inputs  are  selected  with  CLCxSEL0  through CLCxSEL3 registers Register 27-6).\n(Register 27-3\nthrough\nNote:\nData selections are undefined at power-up.",
    "CLCx DATA INPUT SELECTION\n111111 [63], DyS<5:0> Value = 111111 [63]. 111111 [63], CLCx Input Source = Reserved. \uf0b7, DyS<5:0> Value = \uf0b7. \uf0b7, CLCx Input Source = . \uf0b7, DyS<5:0> Value = \uf0b7. \uf0b7, CLCx Input Source = . \uf0b7, DyS<5:0> Value = \uf0b7. \uf0b7, CLCx Input Source = . 110110, DyS<5:0> Value = [55]. 110110, CLCx Input Source = . 110110, DyS<5:0> Value = [54]. 110110, CLCx Input Source = CAN_tx1. 110101, DyS<5:0> Value = [53]. 110101, CLCx Input Source = CAN_tx0. 110100, DyS<5:0> Value = [52]. 110100, CLCx Input Source = CWG3B_out. 110011, DyS<5:0> Value = [51]. 110011, CLCx Input Source =",
    "CLCx DATA INPUT SELECTION\nCWG3A_out. 110010, DyS<5:0> Value = [50]. 110010, CLCx Input Source = CWG2B_out. 110001, DyS<5:0> Value = [49]. 110001, CLCx Input Source = CWG2A_out. 110000, DyS<5:0> Value = [48]. 110000, CLCx Input Source = CWG1B_out. 101111, DyS<5:0> Value = [47]. 101111, CLCx Input Source = CWG1A_out. 101110, DyS<5:0> Value = [46]. 101110, CLCx Input Source = SS1. 101101, DyS<5:0> Value = [45]. 101101, CLCx Input Source = SCK1. 101100, DyS<5:0> Value = [44]. 101100, CLCx Input Source = SDO1. 101011, DyS<5:0> Value = [43]. 101011,",
    "CLCx DATA INPUT SELECTION\nCLCx Input Source = Reserved. 101010, DyS<5:0> Value = [42]. 101010, CLCx Input Source = UART2_tx_out. 101001, DyS<5:0> Value = [41]. 101001, CLCx Input Source = UART1_tx_out. 101000, DyS<5:0> Value = [40]. 101000, CLCx Input Source = CLC4_out. 100111, DyS<5:0> Value = [39]. 100111, CLCx Input Source = CLC3_out. 100110, DyS<5:0> Value = [38]. 100110, CLCx Input Source = CLC2_out. 100101, DyS<5:0> Value = [37]. 100101, CLCx Input Source = CLC1_out. 100100, DyS<5:0> Value = [36]. 100100, CLCx Input Source = DSM1_out. 100011,",
    "CLCx DATA INPUT SELECTION\nDyS<5:0> Value = [35]. 100011, CLCx Input Source = IOC_flag. 100010, DyS<5:0> Value = [34]. 100010, CLCx Input Source = ZCD_out. 100001 100000, DyS<5:0> Value = [33] [32]. 100001 100000, CLCx Input Source = CMP2_out CMP1_out. 011111, DyS<5:0> Value = [31]. 011111, CLCx Input Source = NCO1_out. 011110, DyS<5:0> Value = [30]. 011110, CLCx Input Source = Reserved. 011101, DyS<5:0> Value = [29]. 011101, CLCx Input Source = Reserved. 011100, DyS<5:0> Value = [28]. 011100, CLCx Input Source = PWM8_out. 011011, DyS<5:0> Value = [27]. 011011, CLCx Input Source",
    "CLCx DATA INPUT SELECTION\n= PWM7_out. 011010, DyS<5:0> Value = [26]. 011010, CLCx Input Source = PWM6_out. 011001, DyS<5:0> Value = [25]. 011001, CLCx Input Source = PWM5_out. 011000, DyS<5:0> Value = [24]. 011000, CLCx Input Source = CCP4_out. 010111, DyS<5:0> Value = [23] [22]. 010111, CLCx Input Source = CCP3_out CCP2_out. , DyS<5:0> Value = [21]. , CLCx Input Source = CCP1 _out. 010110, DyS<5:0> Value = . 010110, CLCx Input Source = . 010101 010100, DyS<5:0> Value = [20]. 010101 010100, CLCx Input Source = SMT2_out. 010011,",
    "CLCx DATA INPUT SELECTION\nDyS<5:0> Value = [19]. 010011, CLCx Input Source = SMT1_out. 010010, DyS<5:0> Value = [18]. 010010, CLCx Input Source = TMR6_out",
    "(CONTINUED)\n010001, DyS<5:0> Value = [17]. 010001, CLCx Input Source = TMR5 _overflow. 010000, DyS<5:0> Value = [16]. 010000, CLCx Input Source = TMR4 _out. 001111, DyS<5:0> Value = [15]. 001111, CLCx Input Source = TMR3 _overflow. 001110, DyS<5:0> Value = [14]. 001110, CLCx Input Source = TMR2 _out. 001101, DyS<5:0> Value = [13]. 001101, CLCx Input Source = TMR1 _overflow. 001100, DyS<5:0> Value = [12]. 001100, CLCx Input Source = TMR0 _overflow. 001011, DyS<5:0> Value = [11]. 001011, CLCx Input Source = CLKR _out. 001010, DyS<5:0> Value =",
    "(CONTINUED)\n[10]. 001010, CLCx Input Source = ADCRC. 001001, DyS<5:0> Value = [9]. 001001, CLCx Input Source = SOSC. 001000, DyS<5:0> Value = [8]. 001000, CLCx Input Source = MFINTOSC (32 kHz). 000111, DyS<5:0> Value = [7]. 000111, CLCx Input Source = MFINTOSC (500 kHz). 000110, DyS<5:0> Value = [6]. 000110, CLCx Input Source = LFINTOSC. 000101, DyS<5:0> Value = [5]. 000101, CLCx Input Source = HFINTOSC. 000100, DyS<5:0> Value = [4]. 000100, CLCx Input Source = FOSC. 000011, DyS<5:0> Value = [3]. 000011, CLCx Input Source = CLCIN3PPS. 000010,",
    "(CONTINUED)\nDyS<5:0> Value = [2]. 000010, CLCx Input Source = CLCIN2PPS. 000001, DyS<5:0> Value = [1]. 000001, CLCx Input Source = CLCIN1PPS. 000000, DyS<5:0> Value = [0]. 000000, CLCx Input Source = CLCIN0PPS",
    "27.1.2 DATA GATING\nOutputs from the input multiplexers are directed to the desired  logic  function  input  through  the  data  gating stage. Each data gate can direct any combination of the four selected inputs.",
    "Note: Data gating is undefined at power-up.\nThe gate stage is more than just signal direction. The gate can be configured to direct each input signal as inverted  or  non-inverted  data.  Directed  signals  are ANDed together in each gate. The output of each gate can be inverted before going on to the logic function stage.\nThe gating is in essence a 1-to-4 input AND/NAND/OR/ NOR gate. When every input is inverted and the output is inverted, the gate is an OR of all enabled data inputs. When the inputs and output are not inverted, the gate is an AND or all enabled inputs.\nTable 27-2 summarizes the basic logic that can be obtained in gate 1 by using the gate logic select bits. The table shows the logic of four input variables, but each gate can be configured to use less than four. If no inputs are selected, the output will be zero or one, depending on the gate output polarity bit.",
    "TABLE 27-2: DATA GATING LOGIC\n0x55, GyPOL = 1. 0x55, Gate Logic = AND. 0x55, GyPOL = 0. 0x55, Gate Logic = NAND. 0xAA, GyPOL = 1. 0xAA, Gate Logic = NOR. 0xAA, GyPOL = 0. 0xAA, Gate Logic = OR. 0x00, GyPOL = 0. 0x00, Gate Logic = Logic 0. 0x00, GyPOL = 1. 0x00, Gate Logic = Logic 1\nIt is possible (but not recommended) to select both the true and negated values of an input. When this is done, the gate output is zero, regardless of the other inputs, but may emit logic glitches (transient-induced pulses). If  the output of the channel must be zero or one, the recommended method is to set all gate bits to zero and use the gate polarity bit to set the desired level.\nData  gating  is  configured  with  the  logic  gate  select registers as follows:",
    "TABLE 27-2: DATA GATING LOGIC\n\u00b7 Gate 1: CLCxGLS0 (Register 27-7)\n\u00b7 Gate 2: CLCxGLS1 (Register 27-8)\n\u00b7 Gate 3: CLCxGLS2 (Register 27-9)\n\u00b7 Gate 4: CLCxGLS3 (Register 27-10)\nRegister  number  suffixes  are  different  than  the  gate numbers because other variations of this module have multiple gate selections in the same register.\nData gating is indicated in the right side of Figure 27-2. Only one gate is shown in detail. The remaining three gates are configured identically with the exception that the  data  enables  correspond  to  the  enables  for  that gate.",
    "27.1.3 LOGIC FUNCTION\nThere are eight available logic functions including:\n\u00b7 AND-OR\n\u00b7 OR-XOR\n\u00b7 AND\n\u00b7 S-R Latch\n\u00b7 D Flip-Flop with Set and Reset\n\u00b7 D Flip-Flop with Reset\n\u00b7 J-K Flip-Flop with Reset\n\u00b7 Transparent Latch with Set and Reset\nLogic functions are shown in Figure 27-2. Each logic function has four inputs and one output. The four inputs are the four data gate outputs of the previous stage. The output is fed to the inversion stage and from there to  other  peripherals,  an  output  pin,  and  back  to  the CLCx itself.",
    "27.1.4 OUTPUT POLARITY\nThe  last  stage  in  the  Configurable  Logic  Cell  is  the output  polarity.  Setting  the  POL  bit  of  the  CLCxPOL register inverts the output signal from the logic stage. Changing the polarity while the interrupts are enabled will cause an interrupt for the resulting output transition.",
    "27.2 CLCx Interrupts\nAn  interrupt  will  be  generated  upon  a  change  in  the output value of the CLCx when the appropriate interrupt enables  are  set. A  rising  edge  detector  and  a  falling edge detector are present in each CLC for this purpose.\nThe CLCxIF bit of the associated PIR5 register will be set when either edge detector is triggered and its asso -ciated enable bit is set. The INTP enables rising edge interrupts and the INTN bit enables falling edge inter -rupts. Both are located in the CLCxCON register.\nTo fully enable the interrupt, set the following bits:\n\u00b7 CLCxIE bit of the respective PIE register\n\u00b7 INTP bit of the CLCxCON register (for a rising edge detection)\n\u00b7 INTN bit of the CLCxCON register (for a falling edge detection)\n\u00b7 GIE bits of the INTCON0 register\nThe CLCxIF bit of the respective PIR register, must be cleared in software as part of the interrupt service. If another  edge  is  detected  while  this  flag  is  being cleared,  the  flag  will  still  be  set  at  the  end  of  the sequence.",
    "27.3 Output Mirror Copies\nMirror copies of all CON output bits are contained in the CLCxDATA  register.  Reading  this  register  reads  the outputs of all CLCs simultaneously. This prevents any reading skew introduced by testing or reading the OUT bits in the individual CLCxCON registers.",
    "27.4 Effects of a Reset\nThe CLCxCON register is cleared to zero as the result of a Reset. All other selection and gating values remain unchanged.",
    "27.5 Operation During Sleep\nThe CLC module operates independently from the system clock and will continue to run during Sleep, provided that the input sources selected remain active.\nThe HFINTOSC remains active during Sleep when the CLC module is enabled and the HFINTOSC is selected as an input source, regardless of the system clock source selected.\nIn other words, if the HFINTOSC is simultaneously selected as the system clock and as a CLC input source, when the CLC is enabled, the CPU will go Idle during Sleep, but the CLC will continue to operate and the HFINTOSC will remain active.\nThis will have a direct effect on the Sleep mode current.",
    "27.6 CLCx Setup Steps\nThe following steps should be followed when setting up the CLCx:",
    "27.6 CLCx Setup Steps\n\u00b7 Disable CLCx by clearing the EN bit.\n\u00b7 Select desired inputs using CLCxSEL0 through CLCxSEL3 registers (See Table 27-1).\n\u00b7 Clear any associated ANSEL bits.\n\u00b7 Set all TRIS bits associated with inputs.\n\u00b7 Clear all TRIS bits associated with outputs.\n\u00b7 Enable the chosen inputs through the four gates using CLCxGLS0, CLCxGLS1, CLCxGLS2, and CLCxGLS3 registers.\n\u00b7 Select the gate output polarities with the GyPOL bits of the CLCxPOL register.\n\u00b7 Select the desired logic function with the MODE<2:0> bits of the CLCxCON register.\n\u00b7 Select the desired polarity of the logic output with the POL bit of the CLCxPOL register. (This step may be combined with the previous gate output polarity step).\n\u00b7 If driving a device pin, set the desired pin PPS control register and also clear the TRIS bit corresponding to that output.\n\u00b7 If interrupts are desired, configure the following bits:\n-Set the INTP bit in the CLCxCON register for rising event.",
    "27.6 CLCx Setup Steps\n-Set the INTN bit in the CLCxCON register for falling event.\n-Set the CLCxIE bit of the respective PIE register.\n-Set the GIE bits of the INTCON0 register.\n\u00b7 Enable the CLCx by setting the EN bit of the CLCxCON register.",
    "PIC18(L)F25/26K83\nFIGURE 27-3:",
    "PROGRAMMABLE LOGIC FUNCTIONS\n, 1 = Rev. 10-000122B 9/13/2016. AND-OR, 1 = OR-XOR. MODE<2:0> = 000 4-input AND lcxg1 lcxg2 lcxg3 lcxg4, 1 = MODE<2:0> = 001 S-R Latch. MODE<2:0> = 010 1-Input DFlip-Flop with S and D Q S lcxg2 lcxg4 lcxq, 1 = MODE<2:0> = 011 2-Input DFlip-Flop with R. J-K Flip-Flop with R MODE<2:0> = 100 J R Q K lcxg1 lcxg2 lcxg3 lcxg4 lcxq, 1 = 1-Input Transparent Latch with S and R MODE<2:0> = 101 D R Q lcxq lcxg1 lcxg2 lcxg3 lcxg4 lcxg4. MODE<2:0> = 110, 1 = MODE<2:0> = 111 D R Q S LE lcxq lcxg1 lcxg2",
    "PROGRAMMABLE LOGIC FUNCTIONS\nlcxg3",
    "REGISTER 27-1: CLCxCON: CONFIGURABLE LOGIC CELL CONTROL REGISTER\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = R-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. EN, 1 = -. EN, 2 = OUT. EN, 3 = INTP. EN, 4 = INTN. EN, 5 = MODE<2:0>. EN, 6 = MODE<2:0>. EN, 7 = MODE<2:0>. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 27-1: CLCxCON: CONFIGURABLE LOGIC CELL CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = \nbit 7\nEN:\nConfigurable Logic Cell Enable bit\n1 = Configurable logic cell is enabled and mixing input signals\n0 = Configurable logic cell is disabled and has logic zero output\nbit 6\nUnimplemented: Read as ' 0 '\nbit 5\nOUT: Configurable Logic Cell Data Output bit\nRead-only: logic cell output data, after LCPOL; sampled from CLCxOUT\nbit 4\nINTP: Configurable Logic Cell Positive Edge Going Interrupt Enable bit",
    "REGISTER 27-1: CLCxCON: CONFIGURABLE LOGIC CELL CONTROL REGISTER\n1 = CLCxIF will be set when a rising edge occurs on CLCxOUT 0 = CLCxIF will not be set\nbit 3\nINTN: Configurable Logic Cell Negative Edge Going Interrupt Enable bit\n1 = CLCxIF will be set when a falling edge occurs on CLCxOUT 0 = CLCxIF will not be set",
    "bit 2-0 MODE<2:0>: Configurable Logic Cell Functional Mode bits\n111 = Cell is 1-input transparent latch with S and R\n110 = Cell is J-K flip-flop with R\n101 = Cell is 2-input D flip-flop with R\n100 = Cell is 1-input D flip-flop with S and R\n011 = Cell is S-R latch\n010 = Cell is 4-input AND\n001 = Cell is OR-XOR\n000 = Cell is AND-OR",
    "REGISTER 27-2: CLCxPOL: SIGNAL POLARITY CONTROL REGISTER\nPOL, U-0 = -. POL, U-0 = -. POL, U-0 = -. POL, R/W-x/u = G4POL. POL, R/W-x/u = G3POL. POL, R/W-x/u = G2POL. POL, R/W-x/u = G1POL. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7\nPOL: CLCxOUT Output Polarity Control bit\n1 = The output of the logic cell is inverted\n0 = The output of the logic cell is not inverted\nbit 6-4\nUnimplemented: Read as ' 0 '\nbit 3\nG4POL: Gate 3 Output Polarity Control bit\n1 = The output of gate 3 is inverted when applied to the logic cell\n0\n= The output of gate 3 is not inverted\nbit 2\nG3POL: Gate 2 Output Polarity Control bit\n1 = The output of gate 2 is inverted when applied to the logic cell\n0 = The output of gate 2 is not inverted\nbit 1\nG2POL: Gate 1 Output Polarity Control bit\n1 = The output of gate 1 is inverted when applied to the logic cell\n0 = The output of gate 1 is not inverted\nbit 0\nG1POL: Gate 0 Output Polarity Control bit\n1 = The output of gate 0 is inverted when applied to the logic cell\n0 = The output of gate 0 is not inverted",
    "PIC18(L)F25/26K83\nREGISTER 27-3:",
    "CLCxSEL0: GENERIC CLCx DATA 0 SELECT REGISTER\n-, U-0 = -. -, R/W-x/u = . -, R/W-x/u = . -, R/W-x/u = D1S<5:0>. -, R/W-x/u = . -, R/W-x/u = . -, R/W-x/u = . bit 7, U-0 = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = bit 0",
    "CLCxSEL0: GENERIC CLCx DATA 0 SELECT REGISTER\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-6\nUnimplemented: Read as '0'\nbit 5-0\nD1S<5:0>: CLCx Data1 Input Selection bits See Table 27-1.",
    "CLCxSEL1: GENERIC CLCx DATA 1 SELECT REGISTER\n-, U-0 = -. -, R/W-x/u = . -, R/W-x/u = . -, R/W-x/u = D2S<5:0>. -, R/W-x/u = . -, R/W-x/u = . -, R/W-x/u = . bit 7, U-0 = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = bit 0",
    "CLCxSEL1: GENERIC CLCx DATA 1 SELECT REGISTER\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-6\nUnimplemented: Read as ' 0 '\nbit 5-0\nD2S<5:0>: CLCx Data 2 Input Selection bits\nSee Table 27-1.",
    "CLCxSEL2: GENERIC CLCx DATA 2 SELECT REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-x/u. U-0, 3 = R/W-x/u. U-0, 4 = R/W-x/u. U-0, 5 = R/W-x/u. U-0, 6 = R/W-x/u. U-0, 7 = R/W-x/u. -, 1 = -. -, 2 = D3S<5:0>. -, 3 = D3S<5:0>. -, 4 = D3S<5:0>. -, 5 = D3S<5:0>. -, 6 = D3S<5:0>. -, 7 = D3S<5:0>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit",
    "CLCxSEL2: GENERIC CLCx DATA 2 SELECT REGISTER\n0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = \nbit 7-6\nUnimplemented: Read as ' 0 '\nbit 5-0\nD3S<5:0>: CLCx Data 3 Input Selection bits See Table 27-1.",
    "CLCxSEL3: GENERIC CLCx DATA 3 SELECT REGISTER\n-, U-0 = -. -, R/W-x/u = . -, R/W-x/u = . -, R/W-x/u = . -, R/W-x/u = D4S<5:0>. -, R/W-x/u = . -, R/W-x/u = . bit 7, U-0 = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = . bit 7, R/W-x/u = bit 0",
    "CLCxSEL3: GENERIC CLCx DATA 3 SELECT REGISTER\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-6\nUnimplemented: Read as ' 0 '\nbit 5-0\nD4S<5:0>:\nCLCx Data 4 Input Selection bits\nSee Table 27-1.",
    "REGISTER 27-7: CLCxGLS0: GATE 0 LOGIC SELECT REGISTER\nG1D4T, R/W-x/u = G1D4N. G1D4T, R/W-x/u = G1D3T. G1D4T, R/W-x/u = G1D3N. G1D4T, R/W-x/u = G1D2T. G1D4T, R/W-x/u = G1D2N. G1D4T, R/W-x/u = G1D1T. G1D4T, R/W-x/u = G1D1N. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7\nG1D4T: Gate 0 Data 4 True (non-inverted) bit\n1 = CLCIN3 (true) is gated into CLCx Gate 0 0 = CLCIN3 (true) is not gated into CLCx Gate 0\nbit 6\nG1D4N: Gate 0 Data 4 Negated (inverted) bit\n1 = CLCIN3 (inverted) is gated into CLCx Gate 0 0 = CLCIN3 (inverted) is not gated into CLCx Gate 0\nbit 5\nG1D3T: Gate 0 Data 3 True (non-inverted) bit\n1 = CLCIN2 (true) is gated into CLCx Gate 0 0 = CLCIN2 (true) is not gated into CLCx Gate 0\nbit 4\nG1D3N: Gate 0 Data 3 Negated (inverted) bit",
    "Legend:\n1 = CLCIN2 (inverted) is gated into CLCx Gate 0 0 = CLCIN2 (inverted) is not gated into CLCx Gate 0\nbit 3\nG1D2T: Gate 0 Data 2 True (non-inverted) bit\n1 = CLCIN1 (true) is gated into CLCx Gate 0 0 = CLCIN1 (true) is not gated into l CLCx Gate 0\nbit 2\nG1D2N: Gate 0 Data 2 Negated (inverted) bit\n1 = CLCIN1 (inverted) is gated into CLCx Gate 0 0 = CLCIN1 (inverted) is not gated into CLCx Gate 0\nbit 1\nG1D1T: Gate 0 Data 1 True (non-inverted) bit\n1 = CLCIN0 (true) is gated into CLCx Gate 0 0 = CLCIN0 (true) is not gated into CLCx Gate 0\nbit 0\nG1D1N: Gate 0 Data 1 Negated (inverted) bit\n1 = CLCIN0 (inverted) is gated into CLCx Gate 0 0 = CLCIN0 (inverted) is not gated into CLCx Gate 0",
    "REGISTER 27-8: CLCxGLS1: GATE 1 LOGIC SELECT REGISTER\nG2D4T, R/W-x/u = G2D4N. G2D4T, R/W-x/u = G2D3T. G2D4T, R/W-x/u = G2D3N. G2D4T, R/W-x/u = G2D2T. G2D4T, R/W-x/u = G2D2N. G2D4T, R/W-x/u = G2D1T. G2D4T, R/W-x/u = G2D1N. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7\nG2D4T: Gate 1 Data 4 True (noninverted) bit\n1 = CLCIN3 (true) is gated into CLCx Gate 1 0 = CLCIN3 (true) is not gated into CLCx Gate 1\nbit 6\nG2D4N: Gate 1 Data 4 Negated (inverted) bit\n1 = CLCIN3 (inverted) is gated into CLCx Gate 1 0 = CLCIN3 (inverted) is not gated into CLCx Gate 1\nbit 5\nG2D3T: Gate 1 Data 3 True (noninverted) bit\n1 = CLCIN2 (true) is gated into CLCx Gate 1 0 = CLCIN2 (true) is not gated into CLCx Gate 1\nbit 4\nG2D3N: Gate 1 Data 3 Negated (inverted) bit",
    "Legend:\n1 = CLCIN2 (inverted) is gated into CLCx Gate 1 0 = CLCIN2 (inverted) is not gated into CLCx Gate 1\nbit 3\nG2D2T: Gate 1 Data 2 True (noninverted) bit\n1 = CLCIN1 (true) is gated into CLCx Gate 1 0 = CLCIN1 (true) is not gated into CLCx Gate 1\nbit 2\nG2D2N: Gate 1 Data 2 Negated (inverted) bit\n1 = CLCIN1 (inverted) is gated into CLCx Gate 1 0 = CLCIN1 (inverted) is not gated into CLCx Gate 1\nbit 1\nG2D1T: Gate 1 Data 1 True (noninverted) bit\n1 = CLCIN0 (true) is gated into CLCx Gate 1 0 = CLCIN0 (true) is not gated into CLCx Gate1\nbit 0\nG2D1N: Gate 1 Data 1 Negated (inverted) bit\n1 = CLCIN0 (inverted) is gated into CLCx Gate 1 0 = CLCIN0 (inverted) is not gated into CLCx Gate 1",
    "REGISTER 27-9: CLCxGLS2: GATE 2 LOGIC SELECT REGISTER\nG3D4T, R/W-x/u = G3D4N. G3D4T, R/W-x/u = G3D3T. G3D4T, R/W-x/u = G3D3N. G3D4T, R/W-x/u = G3D2T. G3D4T, R/W-x/u = G3D2N. G3D4T, R/W-x/u = G3D1T. G3D4T, R/W-x/u = G3D1N. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7\nG3D4T: Gate 2 Data 4 True (noninverted) bit\n1 = CLCIN3 (true) is gated into CLCx Gate 2 0 = CLCIN3 (true) is not gated into CLCx Gate 2\nbit 6\nG3D4N: Gate 2 Data 4 Negated (inverted) bit\n1 = CLCIN3 (inverted) is gated into CLCx Gate 2 0 = CLCIN3 (inverted) is not gated into CLCx Gate 2\nbit 5\nG3D3T: Gate 2 Data 3 True (noninverted) bit\n1 = CLCIN2 (true) is gated into CLCx Gate 2 0 = CLCIN2 (true) is not gated into CLCx Gate 2\nbit 4\nG3D3N: Gate 2 Data 3 Negated (inverted) bit",
    "Legend:\n1 = CLCIN2 (inverted) is gated into CLCx Gate 2 0 = CLCIN2 (inverted) is not gated into CLCx Gate 2\nbit 3\nG3D2T: Gate 2 Data 2 True (noninverted) bit\n1 = CLCIN1 (true) is gated into CLCx Gate 2 0 = CLCIN1 (true) is not gated into CLCx Gate 2\nbit 2\nG3D2N: Gate 2 Data 2 Negated (inverted) bit\n1 = CLCIN1 (inverted) is gated into CLCx Gate 2 0 = CLCIN1 (inverted) is not gated into CLCx Gate 2\nbit 1\nG3D1T: Gate 2 Data 1 True (noninverted) bit\n1 = CLCIN0 (true) is gated into CLCx Gate 2 0 = CLCIN0 (true) is not gated into CLCx Gate 2\nbit 0\nG3D1N: Gate 2 Data 1 Negated (inverted) bit\n1 = CLCIN0 (inverted) is gated into CLCx Gate 2 0 = CLCIN0 (inverted) is not gated into CLCx Gate 2",
    "REGISTER 27-10: CLCxGLS3: GATE 3 LOGIC SELECT REGISTER\nG4D4T, R/W-x/u = G4D4N. G4D4T, R/W-x/u = G4D3T. G4D4T, R/W-x/u = G4D3N. G4D4T, R/W-x/u = G4D2T. G4D4T, R/W-x/u = G4D2N. G4D4T, R/W-x/u = G4D1T. G4D4T, R/W-x/u = G4D1N. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 7. bit 7, R/W-x/u = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7\nG4D4T: Gate 3 Data 4 True (non-inverted) bit\n1 = CLCIN3 (true) is gated into CLCx Gate 3 0 = CLCIN3 (true) is not gated into CLCx Gate 3\nbit 6\nG4D4N: Gate 3 Data 4 Negated (inverted) bit\n1 = CLCIN3 (inverted) is gated into CLCx Gate 3 0 = CLCIN3 (inverted) is not gated into CLCx Gate 3\nbit 5\nG4D3T: Gate 3 Data 3 True (non-inverted) bit\n1 = CLCIN2 (true) is gated into CLCx Gate 3 0 = CLCIN2 (true) is not gated into CLCx Gate 3\nbit 4\nG4D3N: Gate 3 Data 3 Negated (inverted) bit",
    "Legend:\n1 = CLCIN2 (inverted) is gated into CLCx Gate 3 0 = CLCIN2 (inverted) is not gated into CLCx Gate 3\nbit 3\nG4D2T: Gate 3 Data 2 True (non-inverted) bit\n1 = CLCIN1 (true) is gated into CLCx Gate 3 0 = CLCIN1 (true) is not gated into CLCx Gate 3\nbit 2\nG4D2N: Gate 3 Data 2 Negated (inverted) bit\n1 = CLCIN1 (inverted) is gated into CLCx Gate 3 0 = CLCIN1 (inverted) is not gated into CLCx Gate 3\nbit 1\nG4D1T: Gate 4 Data 1 True (non-inverted) bit\n1 = CLCIN0 (true) is gated into CLCx Gate 3 0 = CLCIN0 (true) is not gated into CLCx Gate 3\nbit 0\nG4D1N: Gate 3 Data 1 Negated (inverted) bit\n1 = CLCIN0 (inverted) is gated into CLCx Gate 3 0 = CLCIN0 (inverted) is not gated into CLCx Gate 3",
    "REGISTER 27-11: CLCDATA: CLC DATA OUTPUT\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, R-0 = CLC4OUT. -, R-0 = CLC3OUT. -, R-0 = CLC2OUT. -, R-0 = CLC1OUT. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7-4\nUnimplemented: Read as ' 0 '\nbit 3\nCLC4OUT: Mirror copy of OUT bit of CLC4CON register\nbit 2\nCLC3OUT: Mirror copy of OUT bit of CLC3CON register\nbit 1\nCLC2OUT: Mirror copy of OUT bit of CLC2CON register\nbit 0\nCLC1OUT: Mirror copy of OUT bit of CLC1CON register",
    "TABLE 27-3: SUMMARY OF REGISTERS ASSOCIATED WITH CLCx\nCLCxCON, Bit 7 = EN. CLCxCON, Bit 6 = -. CLCxCON, Bit 5 = OUT. CLCxCON, Bit 4 = INTP. CLCxCON, Bit 3 = INTN. CLCxCON, Bit 2 = MODE<2:0>. CLCxCON, Bit 1 = MODE<2:0>. CLCxCON, Bit 0 = MODE<2:0>. CLCxCON, Registeron Page = <Blue>427. CLCxPOL, Bit 7 = POL. CLCxPOL, Bit 6 = -. CLCxPOL, Bit 5 = -. CLCxPOL, Bit 4 = -. CLCxPOL, Bit 3 = G4POL. CLCxPOL, Bit 2 = G3POL. CLCxPOL, Bit 1 = G2POL. CLCxPOL, Bit 0 = G1POL. CLCxPOL, Registeron Page = <Blue>428. CLCxSEL0, Bit 7 = -. CLCxSEL0, Bit 6 = -. CLCxSEL0,",
    "TABLE 27-3: SUMMARY OF REGISTERS ASSOCIATED WITH CLCx\nBit 5 = D1S<5:0>. CLCxSEL0, Bit 4 = D1S<5:0>. CLCxSEL0, Bit 3 = D1S<5:0>. CLCxSEL0, Bit 2 = D1S<5:0>. CLCxSEL0, Bit 1 = D1S<5:0>. CLCxSEL0, Bit 0 = D1S<5:0>. CLCxSEL0, Registeron Page = <Blue>429. CLCxSEL1, Bit 7 = -. CLCxSEL1, Bit 6 = -. CLCxSEL1, Bit 5 = D2S<5:0>. CLCxSEL1, Bit 4 = D2S<5:0>. CLCxSEL1, Bit 3 = D2S<5:0>. CLCxSEL1, Bit 2 = D2S<5:0>. CLCxSEL1, Bit 1 = D2S<5:0>. CLCxSEL1, Bit 0 =",
    "TABLE 27-3: SUMMARY OF REGISTERS ASSOCIATED WITH CLCx\nD2S<5:0>. CLCxSEL1, Registeron Page = <Blue>429. CLCxSEL2, Bit 7 = -. CLCxSEL2, Bit 6 = -. CLCxSEL2, Bit 5 = D3S<5:0>. CLCxSEL2, Bit 4 = D3S<5:0>. CLCxSEL2, Bit 3 = D3S<5:0>. CLCxSEL2, Bit 2 = D3S<5:0>. CLCxSEL2, Bit 1 = D3S<5:0>. CLCxSEL2, Bit 0 = D3S<5:0>. CLCxSEL2, Registeron Page = <Blue>429. CLCxSEL3, Bit 7 = -. CLCxSEL3, Bit 6 = -. CLCxSEL3, Bit 5 = D4S<5:0>. CLCxSEL3, Bit 4 = D4S<5:0>. CLCxSEL3, Bit 3 =",
    "TABLE 27-3: SUMMARY OF REGISTERS ASSOCIATED WITH CLCx\nD4S<5:0>. CLCxSEL3, Bit 2 = D4S<5:0>. CLCxSEL3, Bit 1 = D4S<5:0>. CLCxSEL3, Bit 0 = D4S<5:0>. CLCxSEL3, Registeron Page = <Blue>429. CLCxGLS0, Bit 7 = G1D4T. CLCxGLS0, Bit 6 = G1D4N. CLCxGLS0, Bit 5 = G1D3T. CLCxGLS0, Bit 4 = G1D3N. CLCxGLS0, Bit 3 = G1D2T. CLCxGLS0, Bit 2 = G1D2N. CLCxGLS0, Bit 1 = G1D1T. CLCxGLS0, Bit 0 = G1D1N. CLCxGLS0, Registeron Page = <Blue>430. CLCxGLS1, Bit 7 = G2D4T.",
    "TABLE 27-3: SUMMARY OF REGISTERS ASSOCIATED WITH CLCx\nCLCxGLS1, Bit 6 = G2D4N. CLCxGLS1, Bit 5 = G2D3T. CLCxGLS1, Bit 4 = G2D3N. CLCxGLS1, Bit 3 = G2D2T. CLCxGLS1, Bit 2 = G2D2N. CLCxGLS1, Bit 1 = G2D1T. CLCxGLS1, Bit 0 = G2D1N. CLCxGLS1, Registeron Page = <Blue>431. CLCxGLS2, Bit 7 = G3D4T. CLCxGLS2, Bit 6 = G3D4N. CLCxGLS2, Bit 5 = G3D3T. CLCxGLS2, Bit 4 = G3D3N. CLCxGLS2, Bit 3 = G3D2T. CLCxGLS2, Bit 2 = G3D2N. CLCxGLS2, Bit 1 = G3D1T. CLCxGLS2, Bit 0",
    "TABLE 27-3: SUMMARY OF REGISTERS ASSOCIATED WITH CLCx\n= G3D1N. CLCxGLS2, Registeron Page = <Blue>432. CLCxGLS3, Bit 7 = G4D4T. CLCxGLS3, Bit 6 = G4D4N. CLCxGLS3, Bit 5 = G4D3T. CLCxGLS3, Bit 4 = G4D3N. CLCxGLS3, Bit 3 = G4D2T. CLCxGLS3, Bit 2 = G4D2N. CLCxGLS3, Bit 1 = G4D1T. CLCxGLS3, Bit 0 = G4D1N. CLCxGLS3, Registeron Page = <Blue>433. CLCDATA, Bit 7 = -. CLCDATA, Bit 6 = -. CLCDATA, Bit 5 = -. CLCDATA, Bit 4 = -. CLCDATA, Bit 3 = CLC4OUT. CLCDATA, Bit 2 = CLC3OUT. CLCDATA, Bit 1 = CLC2OUT.",
    "TABLE 27-3: SUMMARY OF REGISTERS ASSOCIATED WITH CLCx\nCLCDATA, Bit 0 = CLC1OUT. CLCDATA, Registeron Page = <Blue>434\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are unused by the CLCx modules.",
    "28.0 NUMERICALLY CONTROLLED OSCILLATOR (NCO) MODULE\nThe Numerically Controlled Oscillator (NCO) module is a  timer  that  uses  overflow  from  the  addition  of  an increment  value  to  divide  the  input  frequency.  The advantage of the addition method over simple counter driven  timer  is  that  the  output  frequency  resolution does not vary with the divider value. The NCO is most useful for application that requires frequency accuracy and fine resolution at a fixed duty cycle.\nFeatures of the NCO include:\n\u00b7 20-bit Increment Function\n\u00b7 Fixed Duty Cycle mode (FDC) mode\n\u00b7 Pulse Frequency (PF) mode\n\u00b7 Output Pulse-Width Control\n\u00b7 Multiple Clock Input Sources\n\u00b7 Output Polarity Control\n\u00b7 Interrupt Capability\nFigure 28-1 is a simplified block diagram of the NCO module.",
    "28.1 NCO Operation\nThe NCO operates by repeatedly adding a fixed value to an accumulator. Additions occur at the input clock rate. The accumulator will overflow with a carry periodically, which  is  the  raw  NCO  output  (NCO_overflow).  This effectively  reduces  the  input  clock  by  the  ratio  of  the addition value to the maximum accumulator value. See Equation 28-1.\nThe NCO output can be further modified by stretching the  pulse  or  toggling  a  flip-flop.  The  modified  NCO output is then distributed internally to other peripherals and can be optionally output to a pin. The accumulator overflow also generates an interrupt (NCO_overflow).\nThe NCO period changes in discrete steps to create an average frequency. This output depends on the ability of the receiving circuit (i.e., CWG or external resonant converter  circuitry)  to  average  the  NCO  output  to reduce uncertainty.",
    "EQUATION 28-1: NCO OVERFLOW FREQUENCY\nFOVERFLOW = - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - NCO  Cl ock  Fr equency I ncr em ent   Val ue \uf0b4 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -------------------------------------\n2 20",
    "28.1.4 INCREMENT REGISTERS\nClock sources available to the NCO include:\n\u00b7 FOSC\n\u00b7 HFINTOSC\n\u00b7 LFINTOSC\n\u00b7 MFINTOSC/4 (32 kHz)\n\u00b7 MFINTOSC (500 kHz)\n\u00b7 CLC1/2/3/4_out\n\u00b7 CLKREF\n\u00b7 SOSC\nThe NCO clock source is selected by configuring the N1CKS<2:0> bits in the NCO1CLK register.",
    "28.1.2 ACCUMULATOR\nThe accumulator is a 20-bit register.  Read and write access to the accumulator is available through three registers:\n\u00b7 NCO1ACCL\n\u00b7 NCO1ACCH\n\u00b7 NCO1ACCU",
    "28.1.3 ADDER\nThe  NCO  Adder  is  a  full adder, which  operates independently from the source clock. The addition of the previous result and the increment value replaces the accumulator value on the rising edge of each input clock.\nThe increment value is stored in three registers making up a 20-bit incrementer. In order of LSB to MSB they are:\n\u00b7 NCO1INCL\n\u00b7 NCO1INCH\n\u00b7 NCO1INCU\nWhen the NCO module is enabled, the NCO1INCU and NCO1INCH registers should be written first, then the NCO1INCL register. Writing to the NCO1INCL register initiates  the  increment  buffer  registers  to  be  loaded simultaneously  on  the  second  rising  edge  of  the NCO_clk signal.\nThe registers are readable and writable. The increment registers are double-buffered to allow value changes to be made without first disabling the NCO module.\nWhen  the  NCO  module  is  disabled,  the  increment buffers  are  loaded  immediately  after  a  write  to  the increment registers.\nNote:\nThe increment buffer registers are not useraccessible.",
    "28.2 FIXED DUTY CYCLE MODE\nIn  Fixed  Duty  Cycle  (FDC)  mode,  every  time  the accumulator overflows  (NCO_overflow),  the output  is toggled. This provides a 50% duty cycle, provided that the increment  value remains  constant. For more information, see Figure 28-2.",
    "28.3 PULSE FREQUENCY MODE\nIn Pulse Frequency (PF) mode, every time the Accumulator overflows, the output becomes active for one  or  more  clock  periods.  Once  the  clock  period expires,  the  output  returns  to  an  inactive  state.  This provides a pulsed output. The output becomes active on  the  rising  clock  edge  immediately  following  the overflow event. For more information, see Figure 28-2.\nThe value of the active and inactive states depends on the polarity bit, POL in the NCO1CON register.\nThe PF mode is selected by setting the PFM bit in the NCO1CON register.",
    "28.3.1 OUTPUT PULSE-WIDTH CONTROL\nWhen operating in PF mode, the active state of the out -put can vary in width by multiple clock periods. Various pulse widths are selected with the PWS<2:0> bits in the NCO1CLK register.\nWhen  the  selected  pulse  width  is  greater  than  the Accumulator overflow time frame, then DDS operation is undefined.",
    "28.4 OUTPUT POLARITY CONTROL\nThe last stage in the NCO module is the output polarity. The  POL  bit  in  the  NCO1CON  register  selects  the output polarity. Changing the polarity while the interrupts  are  enabled  will  cause  an  interrupt  for  the resulting  output  transition.  The  NCO  output  signal  is available to most of the other peripherals available on the device.",
    "28.5 Interrupts\nWhen the accumulator overflows (NCO_overflow), the NCO Interrupt Flag bit, NCO1IF, of the PIR4 register is set. To enable the interrupt event (NCO_interrupt), the following bits must be set:\n\u00b7 EN bit of the NCO1CON register\n\u00b7 NCO1IE bit of the PIE4 register\n\u00b7 GIE/GIEH bit of the INTCON0 register\nThe interrupt must be cleared by software by clearing the NCO1IF bit in the Interrupt Service Routine.",
    "28.6 Effects of a Reset\nAll  of  the  NCO  registers  are  cleared  to  zero  as  the result of a Reset.",
    "28.7 Operation in Sleep\nThe  NCO  module  operates  independently  from  the system  clock  and  will  continue  to  run  during  Sleep, provided that the clock source selected remains active.\nThe HFINTOSC remains active during Sleep when the NCO  module  is  enabled and  the HFINTOSC  is selected as the clock source, regardless of the system clock source selected.\nIn  other  words,  if  the  HFINTOSC  is  simultaneously selected  as  the  system  clock  and  the  NCO  clock source, when the NCO is enabled, the CPU will go Idle during Sleep, but the NCO will continue to operate and the HFINTOSC will remain active.\nThis will have a direct effect on the Sleep mode current.",
    "REGISTER 28-1:\nNCO1CON: NCO CONTROL REGISTER\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = R-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = U-0. R/W-0/0, 6 = U-0. R/W-0/0, 7 = R/W-0/0. EN, 1 = -. EN, 2 = OUT. EN, 3 = POL. EN, 4 = -. EN, 5 = -. EN, 6 = -. EN, 7 = PFM. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7\nEN: NCO1 Enable bit\n1 = NCO1 module is enabled\n0 = NCO1 module is disabled\nbit 6\nUnimplemented : Read as ' 0 '\nbit 5\nOUT: NCO1 Output bit\nDisplays the current output value of the NCO1 module.\nbit 4\nPOL: NCO1 Polarity\n1 = NCO1 output signal is inverted\n0 = NCO1 output signal is not inverted",
    "bit 3-1\nUnimplemented : Read as ' 0 '\nbit 0\nPFM: NCO1 Pulse Frequency Mode bit\n1 = NCO1 operates in Pulse Frequency mode\n0 = NCO1 operates in Fixed Duty Cycle mode, divide by 2",
    "REGISTER 28-2: NCO1CLK: NCO1 INPUT CLOCK CONTROL REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = U-0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. PWS<2:0> (1,2), 1 = PWS<2:0> (1,2). PWS<2:0> (1,2), 2 = PWS<2:0> (1,2). PWS<2:0> (1,2), 3 = -. PWS<2:0> (1,2), 4 = CKS<3:0>. PWS<2:0> (1,2), 5 =",
    "REGISTER 28-2: NCO1CLK: NCO1 INPUT CLOCK CONTROL REGISTER\nCKS<3:0>. PWS<2:0> (1,2), 6 = CKS<3:0>. PWS<2:0> (1,2), 7 = CKS<3:0>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 28-2: NCO1CLK: NCO1 INPUT CLOCK CONTROL REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-5\nPWS<2:0>: NCO1 Output Pulse Width Select bits (1,2)\n111 =   NCO1 output is active for 128 input clock periods\n110 =   NCO1 output is active for 64 input clock periods\n101 =   NCO1 output is active for 32 input clock periods\n100 =   NCO1 output is active for 16 input clock periods\n011 =   NCO1 output is active for 8 input clock periods",
    "REGISTER 28-2: NCO1CLK: NCO1 INPUT CLOCK CONTROL REGISTER\n010 =   NCO1 output is active for 4 input clock periods\n001 =   NCO1 output is active for 2 input clock periods\n000 =   NCO1 output is active for 1 input clock period\nbit 4 Unimplemented: Read as ' 0 '\nbit 3-0 CKS<3:0>: NCO1 Clock Source Select bits\n1111 = Reserved\n\u2022\n\u2022\n\u2022\n1011 = Reserved\n1010 = CLC4_out\n1001 = CLC3_out\n1000 = CLC2_out\n0111 = CLC1_out\n0110 = CLKREF_out\n0101 = SOSC\n0100 = MFINTOSC/4 (32 kHz)\n0011 = MFINTOSC (500 kHz)\n0010 = LFINTOSC\n0001 = HFINTOSC\n0000 = FOSC\nNote 1: N1PWS applies only when operating in Pulse Frequency mode.\n2: If NCO1 pulse width is greater than NCO1 overflow period, operation is undefined.",
    "REGISTER 28-3: NCO1ACCL: NCO1 ACCUMULATOR REGISTER - LOW BYTE\n\nbit 7-0 ACC<7:0>: NCO1 Accumulator, Low Byte",
    "REGISTER 28-3: NCO1ACCL: NCO1 ACCUMULATOR REGISTER - LOW BYTE\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. ACC<7:0>, 1 = ACC<7:0>. ACC<7:0>, 2 = ACC<7:0>. ACC<7:0>, 3 = ACC<7:0>. ACC<7:0>, 4 = ACC<7:0>. ACC<7:0>, 5 = ACC<7:0>. ACC<7:0>, 6 = ACC<7:0>. ACC<7:0>, 7 =",
    "REGISTER 28-3: NCO1ACCL: NCO1 ACCUMULATOR REGISTER - LOW BYTE\nACC<7:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = ",
    "REGISTER 28-4: NCO1ACCH: NCO1 ACCUMULATOR REGISTER - HIGH BYTE\nbit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0.ACC<15:8> = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-0 ACC<15:8>: NCO1 Accumulator, High Byte",
    "REGISTER 28-5: NCO1ACCU: NCO1 ACCUMULATOR REGISTER - UPPER BYTE (1)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = ACC<19:16>. -, 5 = ACC<19:16>. -, 6 = ACC<19:16>. -, 7 = ACC<19:16>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 28-5: NCO1ACCU: NCO1 ACCUMULATOR REGISTER - UPPER BYTE (1)\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3-0 ACC<19:16>: NCO1 Accumulator, Upper Byte\n- Note 1: The accumulator spans registers NCO1ACCU:NCO1ACCH: NCO1ACCL. The 24 bits are reserved but not all are used.This register updates in real time, asynchronously to the CPU; there is no provision to guarantee atomic access to this 24-bit space using an 8-bit bus. Writing to this register while the module is operating will produce undefined results.",
    "REGISTER 28-6: NCO1INCL: NCO1 INCREMENT REGISTER - LOW BYTE (1,2)\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-1/1. INC<7:0>, 1 = INC<7:0>. INC<7:0>, 2 = INC<7:0>. INC<7:0>, 3 = INC<7:0>. INC<7:0>, 4 = INC<7:0>. INC<7:0>, 5 = INC<7:0>. INC<7:0>, 6 = INC<7:0>. INC<7:0>, 7",
    "REGISTER 28-6: NCO1INCL: NCO1 INCREMENT REGISTER - LOW BYTE (1,2)\n= INC<7:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "bit 7-0 INC<7:0>: NCO1 Increment, Low Byte\nNote 1: The logical increment spans NCO1INCU:NCO1INCH:NCO1INCL.\n2: NCO1INC is double-buffered as INCBUF; INCBUF is updated on the next falling edge of NCOCLK after writing to NCO1INCL; NCO1INCU and NCO1INCH should be written prior to writing NCO1INCL.",
    "REGISTER 28-7: NCO1INCH: NCO1 INCREMENT REGISTER - HIGH BYTE (1)\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. INC<15:8>, 1 = INC<15:8>. INC<15:8>, 2 = INC<15:8>. INC<15:8>, 3 = INC<15:8>. INC<15:8>, 4 = INC<15:8>. INC<15:8>, 5 = INC<15:8>. INC<15:8>, 6 = INC<15:8>. INC<15:8>, 7 =",
    "REGISTER 28-7: NCO1INCH: NCO1 INCREMENT REGISTER - HIGH BYTE (1)\nINC<15:8>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nR = Readable bit,  = W=Writable bit x = Bit is unknown. R = Readable bit,  = U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7-0 INC<15:8>: NCO1 Increment, High Byte\nNote 1: The logical increment spans NCO1INCU:NCO1INCH:NCO1INCL.",
    "REGISTER 28-8: NCO1INCU: NCO1 INCREMENT REGISTER - UPPER BYTE (1)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. INC<19:6>, 1 = INC<19:6>. INC<19:6>, 2 = INC<19:6>. INC<19:6>, 3 = INC<19:6>. INC<19:6>, 4 = INC<19:6>. INC<19:6>, 5 = INC<19:6>. INC<19:6>, 6 = INC<19:6>. INC<19:6>, 7 = INC<19:6>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6",
    "REGISTER 28-8: NCO1INCU: NCO1 INCREMENT REGISTER - UPPER BYTE (1)\n= . bit 7, 7 = bit 0\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = \nbit 7-4 Unimplemented: Read as ' 0 '\nbit 3-0 INC<19:16>: NCO1 Increment, Upper Byte\nNote 1: The logical increment spans NCO1INCU:NCO1INCH:NCO1INCL.",
    "TABLE 28-1: SUMMARY OF REGISTERS ASSOCIATED WITH NCO\nNCO1CON, Bit 7 = N1EN. NCO1CON, Bit 6 = -. NCO1CON, Bit 5 = N1OUT. NCO1CON, Bit 4 = N1POL. NCO1CON, Bit 3 = -. NCO1CON, Bit 2 = -. NCO1CON, Bit 1 = -. NCO1CON, Bit 0 = N1PFM. NCO1CON, Register on Page = 440. NCO1CLK, Bit 7 = N1PWS<2:0>. NCO1CLK, Bit 6 = N1PWS<2:0>. NCO1CLK, Bit 5 = N1PWS<2:0>. NCO1CLK, Bit 4 = -. NCO1CLK, Bit 3 = -. NCO1CLK, Bit 2 = N1CKS<2:0>. NCO1CLK, Bit 1 = N1CKS<2:0>. NCO1CLK, Bit 0 = N1CKS<2:0>. NCO1CLK, Register on Page =",
    "TABLE 28-1: SUMMARY OF REGISTERS ASSOCIATED WITH NCO\n441. NCO1ACCL, Bit 7 = NCO1ACC<7:0>. NCO1ACCL, Bit 6 = NCO1ACC<7:0>. NCO1ACCL, Bit 5 = NCO1ACC<7:0>. NCO1ACCL, Bit 4 = NCO1ACC<7:0>. NCO1ACCL, Bit 3 = NCO1ACC<7:0>. NCO1ACCL, Bit 2 = NCO1ACC<7:0>. NCO1ACCL, Bit 1 = NCO1ACC<7:0>. NCO1ACCL, Bit 0 = NCO1ACC<7:0>. NCO1ACCL, Register on Page = 442. NCO1ACCH, Bit 7 = NCO1ACC<15:8>. NCO1ACCH, Bit 6 = NCO1ACC<15:8>. NCO1ACCH, Bit 5 = NCO1ACC<15:8>. NCO1ACCH, Bit 4 =",
    "TABLE 28-1: SUMMARY OF REGISTERS ASSOCIATED WITH NCO\nNCO1ACC<15:8>. NCO1ACCH, Bit 3 = NCO1ACC<15:8>. NCO1ACCH, Bit 2 = NCO1ACC<15:8>. NCO1ACCH, Bit 1 = NCO1ACC<15:8>. NCO1ACCH, Bit 0 = NCO1ACC<15:8>. NCO1ACCH, Register on Page = 442. NCO1ACCU, Bit 7 = -. NCO1ACCU, Bit 6 = -. NCO1ACCU, Bit 5 = -. NCO1ACCU, Bit 4 = -. NCO1ACCU, Bit 3 = NCO1ACC<19:16>. NCO1ACCU, Bit 2 = NCO1ACC<19:16>. NCO1ACCU, Bit 1 = NCO1ACC<19:16>. NCO1ACCU, Bit 0 = NCO1ACC<19:16>. NCO1ACCU, Register on Page = 443.",
    "TABLE 28-1: SUMMARY OF REGISTERS ASSOCIATED WITH NCO\nNCO1INCL, Bit 7 = NCO1INC<7:0>. NCO1INCL, Bit 6 = NCO1INC<7:0>. NCO1INCL, Bit 5 = NCO1INC<7:0>. NCO1INCL, Bit 4 = NCO1INC<7:0>. NCO1INCL, Bit 3 = NCO1INC<7:0>. NCO1INCL, Bit 2 = NCO1INC<7:0>. NCO1INCL, Bit 1 = NCO1INC<7:0>. NCO1INCL, Bit 0 = NCO1INC<7:0>. NCO1INCL, Register on Page = 443. NCO1INCH, Bit 7 = NCO1INC<15:8>. NCO1INCH, Bit 6 = NCO1INC<15:8>. NCO1INCH, Bit 5 = NCO1INC<15:8>. NCO1INCH, Bit 4 =",
    "TABLE 28-1: SUMMARY OF REGISTERS ASSOCIATED WITH NCO\nNCO1INC<15:8>. NCO1INCH, Bit 3 = NCO1INC<15:8>. NCO1INCH, Bit 2 = NCO1INC<15:8>. NCO1INCH, Bit 1 = NCO1INC<15:8>. NCO1INCH, Bit 0 = NCO1INC<15:8>. NCO1INCH, Register on Page = 443. NCO1INCU, Bit 7 = -. NCO1INCU, Bit 6 = -. NCO1INCU, Bit 5 = -. NCO1INCU, Bit 4 = -. NCO1INCU, Bit 3 = NCO1INC<19:16>. NCO1INCU, Bit 2 = NCO1INC<19:16>. NCO1INCU, Bit 1 = NCO1INC<19:16>. NCO1INCU, Bit 0 = NCO1INC<19:16>. NCO1INCU, Register on Page = 444",
    "TABLE 28-1: SUMMARY OF REGISTERS ASSOCIATED WITH NCO\nLegend: - = unimplemented read as ' 0 '. Shaded cells are not used for NCO module.",
    "29.0 ZERO-CROSS DETECTION (ZCD) MODULE\nThe ZCD module detects when an A/C signal crosses through the ground potential. The actual zero-crossing threshold is the zero-crossing reference voltage, VCPINV, which is typically 0.75V above ground.\nThe connection to the signal to be detected is through a series current-limiting resistor. The module applies a current  source  or  sink  to  the  ZCD  pin  to  maintain  a constant voltage on the pin, thereby preventing the pin voltage from forward biasing the ESD  protection diodes. When the applied voltage is greater than the reference voltage, the module sinks current. When the applied voltage is less than the reference voltage, the module sources current. The current source and sink action  keeps  the  pin  voltage  constant  over  the  full range  of  the  applied  voltage.  The  ZCD  module  is shown in the simplified block diagram Figure 29-2.\nThe  ZCD  module  is  useful  when  monitoring  an A/C waveform for, but not limited to, the following purposes:\n\u00b7 A/C period measurement\n\u00b7 Accurate long term time measurement\n\u00b7 Dimmer phase delayed drive\n\u00b7 Low EMI cycle switching",
    "29.1 External Resistor Selection\nThe ZCD module requires a current-limiting resistor in series with the external voltage source. The impedance and  rating  of  this  resistor  depends  on  the  external source peak voltage. Select a resistor value that will drop all of the peak voltage when the current through the resistor is nominally 300 \uf06d A. Refer to Equation 291  and  Figure 29-1.  Make  sure  that  the  ZCD  I/O  pin internal weak pull-up is disabled so it does not interfere with the current source and sink.",
    "EQUATION 29-1: EXTERNAL RESISTOR\n<!-- formula-not-decoded -->",
    "FIGURE 29-1: EXTERNAL VOLTAGE\nFIGURE 29-2:",
    "29.3 ZCD Logic Polarity\nThe ZCD module includes a Status bit, which can be read to determine whether the current source or sink is active.  The  OUT  bit  of  the  ZCDCON  register  is  set when the current sink is active, and cleared when the current source is active. The OUT bit is affected by the polarity bit, even if the module is disabled.\nThe  OUT  signal  can  also  be  used  as  input  to  other modules.  This  is  controlled  by  the  registers  of  the corresponding module. OUT can be used as follows:\n\u00b7 Gate source for TMR1/3/5\n\u00b7 Clock source for TMR2/4/6\n\u00b7 Reset source for TMR2/4/6\nThe POL bit of the ZCDCON register inverts the OUT bit relative to the current source and sink output. When the POL bit is set, a OUT high indicates that the current source is  active,  and  a  low  output  indicates  that  the current sink is active.\nThe POL bit affects the ZCD interrupts.",
    "29.4 ZCD Interrupts\nAn interrupt  will  be  generated  upon  a  change  in  the ZCD  logic output when  the appropriate interrupt enables are set. A  rising  edge  detector  and  a  falling edge detector are present in the ZCD for this purpose.\nThe ZCDIF bit of the respective PIR register will be set when either edge detector is triggered and its associ -ated enable bit is set. The INTP enables rising edge interrupts and the INTN bit enables falling edge inter -rupts. Both are located in the ZCDCON register. Priority of the interrupt can be changed if the IPEN bit of the INTCON  register  is  set.  The  ZCD  interrupt  can  be made  high  or  low  priority  by  setting  or  clearing  the ZCDIP bit of the respective IPR register.\nTo fully enable the interrupt, the following bits must be set:\n\u00b7 ZCDIE bit of the respective PIE register\n\u00b7 INTP bit of the ZCDCON register (for a rising edge detection)\n\u00b7 INTN bit of the ZCDCON register (for a falling edge detection)\n\u00b7 GIE bits of the INTCON0 register\nChanging the POL bit can cause an interrupt, regardless of the level of the SEN bit.",
    "29.4 ZCD Interrupts\nThe ZCDIF bit of the respective PIR register must be cleared in software as part of the interrupt service. If another  edge  is  detected  while  this  flag  is  being cleared,  the  flag  will  still  be  set  at  the  end  of  the sequence.",
    "29.5 Correcting for VCPINV offset\nThe actual voltage at which the ZCD switches is the reference voltage at the noninverting input of the ZCD op amp. For external voltage source waveforms other than  square  waves,  this  voltage  offset  from  zero causes the zero-cross event to occur either too early or too late. When the waveform is varying relative to VSS, then  the  zero  cross  is  detected  too  early  as  the waveform  falls  and  too  late  as  the  waveform  rises. When the waveform is varying relative to VDD, then the zero cross is detected too late as the waveform rises and too early as the waveform falls. The actual offset time can be determined for sinusoidal waveforms with the corresponding equations shown in Equation 29-2.",
    "EQUATION 29-2: ZCD EVENT OFFSET\nWhen External Voltage Source is relative to VSS:\n<!-- formula-not-decoded -->\nWhen External Voltage Source is relative to VDD:\n<!-- formula-not-decoded -->\nThis offset time can be compensated for by adding a pull-up or pull-down biasing resistor to the ZCD pin. A pull-up  resistor  is  used  when  the  external  voltage source is varying relative to VSS. A pull-down resistor is used when the voltage is varying relative to VDD. The resistor adds a bias to the ZCD pin so that the target external voltage source must go to zero to pull the pin voltage to the VCPINV switching voltage. The pull-up or pull-down value can be determined with the equations shown in Equation 29-3 or Equation 29-4.",
    "EQUATION 29-3: ZCD PULL-UP/DOWN\nWhen External Signal is relative to Vss:\n<!-- formula-not-decoded -->\nWhen External Signal is relative to VDD:\n<!-- formula-not-decoded -->\nMeasuring VCPINV can be difficult, especially when the waveform is  relative  to  VDD.  However,  by  combining Equations 29-2  and 29-3,  the  resistor  value  can  be determined  from  the  time  difference  between  the ZCD_output high and low intervals. Note that the time difference, \u0394 T, is 4*TOFFSET. The equation for determining the pull-up and pull-down resistor values from the high and low ZCD_output periods is shown in Equation 29-4.",
    "EQUATION 29-4: PULL-UP/DOWN RESISTOR VALUES\n<!-- formula-not-decoded -->\nR is pull-up or pull-down resistor.\nVBIAS is VPULLUP when R is pull-up or VDD when R is pull-down.\n\u0394 T is the ZCDOUT high and low period difference.",
    "29.6 Handling VPEAK Variations\nIf the peak  amplitude  of the external voltage is expected to vary, the series resistor must be selected to  keep  the  ZCD  current  source  and  sink  below  the design  maximum  range  of  \u00b1 600 \uf06d A  and  above  a reasonable minimum range. A general rule of thumb is that the maximum peak voltage can be no more than six times the minimum peak voltage. To ensure that the maximum current does not exceed \u00b1 600 \uf06d A and the minimum  is  at  least  \u00b1 100 \uf06d A,  compute  the  series resistance as shown in Equation 29-5. The compensating pull-up for this series resistance can be determined  with  Equation 29-3  because  the  pull-up value is not dependent to the peak voltage.",
    "EQUATION 29-5: SERIES R FOR V RANGE\n<!-- formula-not-decoded -->",
    "29.7 Operation During Sleep\nThe ZCD current sources and interrupts are unaffected by Sleep.",
    "29.8 Effects of a Reset\nThe ZCD circuit can be configured to default to the active or inactive state on Power-on-Reset (POR). When the ZCD Configuration bit is cleared, the ZCD circuit will be active at POR. When the ZCD Configuration bit is set, the  SEN  bit  of  the  ZCDCON  register  must  be  set  to enable the ZCD module.",
    "29.9 Disabling the ZCD Module\nThe ZCD module can be disabled in two ways:\n1. Configuration Word 2H has the ZCD bit which disables the ZCD module when set, but it can be enabled  using  the  SEN  bit  of  the  ZCDCON register (Register 29-1). If the ZCD bit is clear, the ZCD is always enabled.\n2. The  ZCD  can  also  be  disabled  using the ZCDMD  bit  of  the  respective  PMD2  register (Register 19-3). This is subject to the status of the ZCD bit.\n29.10",
    "REGISTER 29-1: ZCDCON: ZERO-CROSS DETECT CONTROL REGISTER\nSEN, U-0 = -. SEN, R-x = OUT. SEN, R/W-0/0 = POL. SEN, U-0 = -. SEN, U-0 = -. SEN, R/W-0/0 = INTP. SEN, R/W-0/0 = INTN. bit 7, U-0 = bit 7. bit 7, R-x = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 29-1: ZCDCON: ZERO-CROSS DETECT CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7\nSEN: Zero-Cross Detect Software Enable bit\nThis bit is ignored when ZCDSEN Configuration bit is set.\n1= Zero-cross detect is enabled.\n0 = Zero-cross detect is disabled. ZCD pin operates according to PPS and TRIS controls.\nbit 6 Unimplemented: Read as ' 0 '",
    "bit 5\nOUT: Zero-Cross Detect Data Output bit\nZCDPOL bit = 0 :\n1 = ZCD pin is sinking current\n0 = ZCD pin is sourcing current\nZCDPOL bit = 1 :\n1 = ZCD pin is sourcing current\n0 = ZCD pin is sinking current",
    "bit 4\nPOL: Zero-Cross Detect Polarity bit\n1 = ZCD logic output is inverted\n0 = ZCD logic output is not inverted",
    "bit 3-2 Unimplemented: Read as ' 0 '\nbit 1\nINTP: Zero-Cross Detect Positive-Going Edge Interrupt Enable bit\n1 = ZCDIF bit is set on low-to-high ZCD_output transition\n0 = ZCDIF bit is unaffected by low-to-high ZCD_output transition\nbit 0\nINTN: Zero-Cross Detect Negative-Going Edge Interrupt Enable bit\n1 = ZCDIF bit is set on high-to-low ZCD_output transition\n0 = ZCDIF bit is unaffected by high-to-low ZCD_output transition",
    "TABLE 29-1: SUMMARY OF REGISTERS ASSOCIATED WITH THE ZCD MODULE\nZCDCON, Bit 7 = SEN. ZCDCON, Bit 6 = -. ZCDCON, Bit 5 = OUT. ZCDCON, Bit 4 = POL. ZCDCON, Bit 3 = -. ZCDCON, Bit 2 = -. ZCDCON, Bit 1 = INTP. ZCDCON, Bit 0 = INTN. ZCDCON, Register on page = 449\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are unused by the ZCD module.",
    "30.0 DATA SIGNAL MODULATOR (DSM) MODULE\nThe Data Signal Modulator (DSM) is a peripheral which allows the user to mix a data stream, also known as a modulator  signal,  with  a  carrier  signal  to  produce  a modulated output.\nBoth the carrier and the modulator signals are supplied to the DSM module either internally, from the output of a peripheral, or externally through an input pin.\nThe modulated output signal is generated by performing a logical 'AND' operation of both the carrier and modulator signals and then provided to the MDOUT pin.\nThe  carrier  signal  is  comprised  of  two  distinct  and separate signals. A carrier high (CARH) signal and a carrier low (CARL) signal. During the time in which the modulator  (MOD)  signal  is  in  a  logic  high  state,  the DSM mixes the carrier high signal with the modulator signal.  When  the  modulator  signal  is  in  a  logic  low state,  the  DSM  mixes  the  carrier  low  signal  with  the modulator signal.\nUsing this method, the DSM can generate the following types of Key Modulation schemes:\n\u00b7 Frequency-Shift Keying (FSK)\n\u00b7 Phase-Shift Keying (PSK)\n\u00b7 On-Off Keying (OOK)",
    "30.0 DATA SIGNAL MODULATOR (DSM) MODULE\nAdditionally, the following features are provided within the DSM module:\n\u00b7 Carrier Synchronization\n\u00b7 Carrier Source Polarity Select\n\u00b7 Programmable Modulator Data\n\u00b7 Modulated Output Polarity Select\n\u00b7 Peripheral Module Disable, which provides the ability to place the DSM module in the lowest power consumption mode\nFigure 30-1 shows a Simplified Block Diagram of the Data Signal Modulator peripheral.",
    "30.1 DSM Operation\nThe DSM module can be enabled by setting the EN bit in  the  MD1CON0 register. Clearing the EN bit in the MD1CON0 register, disables the DSM module output and switches the carrier high and carrier low signals to the default option of MD1CARHPPS and MD1CARLPPS,  respectively.  The  modulator  signal source is also switched to the BIT in the MD1CON0 register.\nThe values used to select the carrier high, carrier low, and modulator sources held by the Modulation Source, Modulation High Carrier, and Modulation Low Carrier control  registers  are  not  affected  when  the  EN  bit  is cleared and the DSM module is disabled. The values inside  these  registers  remain  unchanged  while  the DSM is inactive. The sources for the carrier high, car -rier  low  and  modulator  signals  will  once  again  be selected when the EN bit is set and the DSM module is again enabled and active.",
    "30.2 Modulator Signal Sources\nThe modulator signal can be supplied from the sources specified in Table 30-3.\nThe  modulator  signal  is  selected  by  configuring  the MS<4:0> bits in the MD1SRC register.",
    "30.3 Carrier Signal Sources\nThe carrier high signal and carrier low signal can be supplied from the sources specified in Table 30-1.\nThe carrier high signal is selected by configuring the CH<4:0> bits in the MD1CARH register. The carrier low signal is selected by configuring the CL<4:0> bits in the MD1CARL register.",
    "30.4 Carrier Synchronization\nDuring the time when the DSM switches between car -rier high and carrier low signal sources, the carrier data in the modulated output signal can become truncated. To prevent this, the carrier signal can be synchronized to the  modulator  signal.  When  synchronization  is enabled, the carrier  pulse  that  is  being  mixed  at  the time of the transition is allowed to transition low before the DSM switches over to the next carrier source.\nSynchronization  is  enabled  separately  for  the  carrier high and carrier low signal sources. Synchronization for the carrier high  signal  is enabled  by  setting  the CHSYNC bit in the MD1CON1 register. Synchronization for the carrier low signal is enabled by setting the CLSYNC bit in the MD1CON1 register.\nFigure 30-2 through Figure 30-6 show timing diagrams of using various synchronization methods.\nFIGURE 30-2:",
    "On Off Keying (OOK) Synchronization\nFIGURE 30-3:\nNo Synchronization (CHSYNC =\n0\n, CLSYNC =\n0\n)\nFIGURE 30-4:\nCarrier High Synchronization (CHSYNC = 1 , CLSYNC = 0 )",
    "PIC18(L)F25/26K83\nFIGURE 30-5:\nCarrier Low Synchronization (CHSYNC =\n0\n, CLSYNC =\n1\n)\nFIGURE 30-6: Full Synchronization (CHSYNC = 1 , CLSYNC = 1 )",
    "30.5 Carrier Source Polarity Select\nThe signal provided from any selected input source for the carrier high and carrier low signals can be inverted. Inverting  the  signal  for  the  carrier  high  source  is enabled  by  setting  the  CHPOL  bit  of  the  MD1CON1 register. Inverting the signal for the carrier low source is enabled  by  setting  the  CLPOL  bit  of  the  MD1CON1 register.",
    "30.6 Programmable Modulator Data\nThe BIT of the MD1CON0 register can be selected as the source for the modulator signal. This gives the user the ability to program the value used for modulation.",
    "30.7 Modulated Output Polarity\nThe modulated output signal provided on the DSM pin can also be inverted. Inverting the  modulated  output signal  is  enabled  by  setting  the  OPOL  bit  of  the MD1CON0 register.",
    "30.8 Operation in Sleep Mode\nThe DSM module is not affected by Sleep mode. The DSM can still operate during Sleep, if the Carrier and Modulator input sources are also still operable during Sleep. Refer to Section 10.0 'Power-Saving Opera -tion Modes' for more details.",
    "30.9 Effects of a Reset\nUpon any device Reset, the DSM module is disabled. The user's  firmware  is  responsible  for  initializing  the module before enabling the output. The registers are reset to their default values.",
    "30.10 Peripheral Module Disable\nThe DSM module can be completely disabled using the PMD module to achieve maximum power saving. The DSMMD bit of PMD6 (Register 19-7) when set disables the DSM module completely. When enabled again all the registers of the DSM module default to POR status.",
    "30.11 Register Definitions: Modulation Control\nLong bit name prefixes for the Modulation peripheral is\nshown  below.  Refer  to Section  1.3.2.2 'Long  Bit Names' for more information.\nMD1, Bit Name Prefix = MD1",
    "REGISTER 30-1: MD1CON0: MODULATION CONTROL REGISTER 0\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = R-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = U-0. R/W-0/0, 6 = U-0. R/W-0/0, 7 = R/W-0/0. EN, 1 = -. EN, 2 = OUT. EN, 3 = OPOL. EN, 4 = -. EN, 5 = -. EN, 6 = -. EN, 7 = BIT. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 30-1: MD1CON0: MODULATION CONTROL REGISTER 0\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = Resets. '1' = Bit is set, W=Writable bit = . '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = . , W=Writable bit = '0' = Bit is cleared. , U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = ",
    "bit 7\nEN: Modulator Module Enable bit\n1 = Modulator module is enabled and mixing input signals\n0 = Modulator module is disabled and has no output\nbit 6\nUnimplemented: Read as ' 0 '\nbit 5\nOUT: Modulator Output bit\nDisplays the current output value of the Modulator module. (1)",
    "bit 4\nOPOL: Modulator Output Polarity Select bit\n1 = Modulator output signal is inverted; idle high output\n0 = Modulator output signal is not inverted; idle low output\nbit 3-1 Unimplemented: Read as ' 0 '\nbit 0\nBIT: Allows software to manually set modulation source input to module (2)\n1 = Modulator selects Carrier High\n0 = Modulator selects Carrier Low\nNote 1: The modulated output frequency can be greater and asynchronous from the clock that updates this register bit, the bit value may not be valid for higher speed modulator or carrier signals.\n2: BIT bit must be selected as the modulation source in the MD1SRC register for this operation.",
    "REGISTER 30-2: MD1CON1: MODULATION CONTROL REGISTER 1\nU-0, 1 = U-0. U-0, 2 = R/W-0/0. U-0, 3 = R/W-0/0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = CHPOL. -, 3 = CHSYNC. -, 4 = -. -, 5 = -. -, 6 = CLPOL. -, 7 = CLSYNC. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7-6 Unimplemented: Read as '0'\nbit 5\nCHPOL: Modulator High Carrier Polarity Select bit\n1 = Selected high carrier signal is inverted\n0 = Selected high carrier signal is not inverted\nbit 4\nCHSYNC: Modulator High Carrier Synchronization Enable bit\n1 = Modulator waits for a falling edge on the high time carrier signal before allowing a switch to the low time carrier\n0 = Modulator output is not synchronized to the high time carrier signal (1)",
    "bit 3-2\nUnimplemented: Read as ' 0 '\nbit 1\nCLPOL: Modulator Low Carrier Polarity Select bit\n1 = Selected low carrier signal is inverted\n0 = Selected low carrier signal is not inverted\nbit 0\nCLSYNC: Modulator Low Carrier Synchronization Enable bit\n1 = Modulator waits for a falling edge on the low time carrier signal before allowing a switch to the high time carrier\n0 = Modulator output is not synchronized to the low time carrier signal (1)\nNote1: Narrowed carrier pulse widths or spurs may occur in the signal stream if the carrier is not synchronized.",
    "REGISTER 30-3: MD1CARH: MODULATION HIGH CARRIER CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = . -, 4 = . -, 5 = CH<4:0> (1). -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 30-3: MD1CARH: MODULATION HIGH CARRIER CONTROL REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, = Unimplemented bit, read as '0' = U -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-5 Unimplemented: Read as ' 0 '\nbit 4-0\nCH<4:0>: Modulator Carrier High Selection bits (1)\nSee Table 30-1 for signal list\nNote1: Unused selections provide an input value.",
    "REGISTER 30-4: MD1CARL: MODULATION LOW CARRIER CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = . -, 4 = . -, 5 = CL<4:0> (1). -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 30-4: MD1CARL: MODULATION LOW CARRIER CONTROL REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = \nbit 7-5\nUnimplemented: Read as ' 0 '\nbit 4-0\nCL<4:0>: Modulator Carrier Low Input Selection bits (1)\nSee Table 30-1 for signal list\nNote1: Unused selections provide a zero as the input value.",
    "TABLE 30-1: MD1CARH/MD1CARL SELECTION MUX CONNECTIONS\n11111-10011, MD1CARH.CH<4:0> = 31-19. 11111-10011, MD1CARH.Connection = Reserved. 11111-10011, MD1CARL.CL<4:0> = 11111-10011. 11111-10011, MD1CARL.CL<4:0> = 31-19. 11111-10011, MD1CARL.Connection = Reserved. 10010, MD1CARH.CH<4:0> = 18. 10010, MD1CARH.Connection = CLC4OUT. 10010, MD1CARL.CL<4:0> = 10010. 10010, MD1CARL.CL<4:0> = 18. 10010, MD1CARL.Connection = CLC4OUT. 10001, MD1CARH.CH<4:0> = 17. 10001, MD1CARH.Connection = CLC3OUT. 10001, MD1CARL.CL<4:0> = 10001. 10001,",
    "TABLE 30-1: MD1CARH/MD1CARL SELECTION MUX CONNECTIONS\nMD1CARL.CL<4:0> = 17. 10001, MD1CARL.Connection = CLC3OUT. 10000, MD1CARH.CH<4:0> = 16. 10000, MD1CARH.Connection = CLC2OUT. 10000, MD1CARL.CL<4:0> = 10000. 10000, MD1CARL.CL<4:0> = 16. 10000, MD1CARL.Connection = CLC2OUT. 01111, MD1CARH.CH<4:0> = 15. 01111, MD1CARH.Connection = CLC1OUT. 01111, MD1CARL.CL<4:0> = 01111. 01111, MD1CARL.CL<4:0> = 15. 01111, MD1CARL.Connection = CLC1OUT. 01110, MD1CARH.CH<4:0> = 14. 01110, MD1CARH.Connection = NCO1OUT. 01110,",
    "TABLE 30-1: MD1CARH/MD1CARL SELECTION MUX CONNECTIONS\nMD1CARL.CL<4:0> = 01110. 01110, MD1CARL.CL<4:0> = 14. 01110, MD1CARL.Connection = NCO1OUT. 01101-01100, MD1CARH.CH<4:0> = 13-12. 01101-01100, MD1CARH.Connection = Reserved. 01101-01100, MD1CARL.CL<4:0> = 01101-01100. 01101-01100, MD1CARL.CL<4:0> = 13-12. 01101-01100, MD1CARL.Connection = Reserved. 01011, MD1CARH.CH<4:0> = 11. 01011, MD1CARH.Connection = PWM8 OUT. 01011, MD1CARL.CL<4:0> = 01011. 01011, MD1CARL.CL<4:0> = 11. 01011, MD1CARL.Connection =",
    "TABLE 30-1: MD1CARH/MD1CARL SELECTION MUX CONNECTIONS\nPWM8 OUT. 01010, MD1CARH.CH<4:0> = 10. 01010, MD1CARH.Connection = PWM7 OUT. 01010, MD1CARL.CL<4:0> = 01010. 01010, MD1CARL.CL<4:0> = 10. 01010, MD1CARL.Connection = PWM7 OUT. 01001, MD1CARH.CH<4:0> = 9. 01001, MD1CARH.Connection = PWM6 OUT. 01001, MD1CARL.CL<4:0> = 01001. 01001, MD1CARL.CL<4:0> = 9. 01001, MD1CARL.Connection = PWM6 OUT. 01000, MD1CARH.CH<4:0> = 8. 01000, MD1CARH.Connection = PWM5 OUT. 01000, MD1CARL.CL<4:0> =",
    "TABLE 30-1: MD1CARH/MD1CARL SELECTION MUX CONNECTIONS\n01000. 01000, MD1CARL.CL<4:0> = 8. 01000, MD1CARL.Connection = PWM5 OUT. 00111, MD1CARH.CH<4:0> = 7. 00111, MD1CARH.Connection = CCP4 OUT. 00111, MD1CARL.CL<4:0> = 00111. 00111, MD1CARL.CL<4:0> = 7. 00111, MD1CARL.Connection = CCP4 OUT. 00110, MD1CARH.CH<4:0> = 6. 00110, MD1CARH.Connection = CCP3 OUT. 00110, MD1CARL.CL<4:0> = 00110. 00110, MD1CARL.CL<4:0> = 6. 00110, MD1CARL.Connection = CCP3 OUT. 00101, MD1CARH.CH<4:0> = 5. 00101, MD1CARH.Connection = CCP2 OUT. 00101,",
    "TABLE 30-1: MD1CARH/MD1CARL SELECTION MUX CONNECTIONS\nMD1CARL.CL<4:0> = 00101. 00101, MD1CARL.CL<4:0> = 5. 00101, MD1CARL.Connection = CCP2 OUT. 00100, MD1CARH.CH<4:0> = 4. 00100, MD1CARH.Connection = CCP1 OUT. 00100, MD1CARL.CL<4:0> = 00100. 00100, MD1CARL.CL<4:0> = 4. 00100, MD1CARL.Connection = CCP1 OUT. 00011, MD1CARH.CH<4:0> = 3. 00011, MD1CARH.Connection = CLKREF output. 00011, MD1CARL.CL<4:0> = 00011. 00011, MD1CARL.CL<4:0> = 3. 00011, MD1CARL.Connection = CLKREF output. 00010, MD1CARH.CH<4:0> = 2. 00010, MD1CARH.Connection =",
    "TABLE 30-1: MD1CARH/MD1CARL SELECTION MUX CONNECTIONS\nHFINTOSC. 00010, MD1CARL.CL<4:0> = 00010. 00010, MD1CARL.CL<4:0> = 2. 00010, MD1CARL.Connection = HFINTOSC. 00001, MD1CARH.CH<4:0> = 1. 00001, MD1CARH.Connection = FOSC (system clock). 00001, MD1CARL.CL<4:0> = 00001. 00001, MD1CARL.CL<4:0> = 1. 00001, MD1CARL.Connection = FOSC (system clock). 00000, MD1CARH.CH<4:0> = 0. 00000, MD1CARH.Connection = Pin selected by MD1CARHPPS. 00000, MD1CARL.CL<4:0> = 00000. 00000, MD1CARL.CL<4:0> = 0. 00000, MD1CARL.Connection = Pin selected by MD1CARLPPS",
    "REGISTER 30-5: MD1SRC: MODULATION SOURCE CONTROL REGISTER\n-, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = MS<4:0>. -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 30-5: MD1SRC: MODULATION SOURCE CONTROL REGISTER\nR = Readable bit u = Bit is,  = W=Writable x = Bit is unknown. R = Readable bit u = Bit is,  = U = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-5\nUnimplemented: Read as ' 0 '\nbit 4-0\nMS<4:0>: Modulator Source Selection bits (1)\nSee Table 30-2 for signal list\nNote1: Unused selections provide a zero as the input value.",
    "CONNECTIONS\n1 1111 - 1 1000, MS<4:0> = 31 - 24. 1 1111 - 1 1000, Connection = Reserved. 1 0111, MS<4:0> = 23. 1 0111, Connection = CAN_tx0. 1 0110, MS<4:0> = 22. 1 0110, Connection = SPI1 SDO. 1 0101, MS<4:0> = 21. 1 0101, Connection = Reserved. 1 0100, MS<4:0> = 20. 1 0100, Connection = UART2 TX. 1 0011, MS<4:0> = 19. 1 0011, Connection = UART1 TX. 1 0010, MS<4:0> = 18. 1 0010, Connection = CLC4 OUT. 1 0001, MS<4:0> = 17. 1 0001, Connection = CLC3 OUT. 1 0000, MS<4:0> = 16. 1 0000, Connection = CLC2 OUT. 0 1111, MS<4:0> = 15. 0 1111, Connection = CLC1 OUT. 0 1110, MS<4:0> =",
    "CONNECTIONS\n14. 0 1110, Connection = CMP2 OUT. 0 1101, MS<4:0> = 13. 0 1101, Connection = CMP1 OUT. 0 1100, MS<4:0> = 12. 0 1100, Connection = NCO1 OUT. 0 1011, MS<4:0> = 11. 0 1011, Connection = Reserved. 0 1010, MS<4:0> = 10. 0 1010, Connection = Reserved. 0 1001, MS<4:0> = 9. 0 1001, Connection = PWM8 OUT. 0 1000, MS<4:0> = 8. 0 1000, Connection = PWM7 OUT. 0 0111, MS<4:0> = 7. 0 0111, Connection = PWM6 OUT. 0 0110, MS<4:0> = 6. 0 0110, Connection = PWM5 OUT. 0 0101, MS<4:0> = 5. 0 0101, Connection = CCP4 OUT. 0 0100, MS<4:0> = 4. 0 0100, Connection = CCP3 OUT. 0 0011,",
    "CONNECTIONS\nMS<4:0> = 3. 0 0011, Connection = CCP2 OUT. 0 0010, MS<4:0> = 2. 0 0010, Connection = CCP1 OUT. 0 0001, MS<4:0> = 1. 0 0001, Connection = DSM1 BIT. 0 0000, MS<4:0> = 0. 0 0000, Connection = Pin selected by MDSRCPPS",
    "TABLE 30-3: SUMMARY OF REGISTERS ASSOCIATED WITH DATA SIGNAL MODULATOR MODE\nMD1CON0, Bit 7 = EN. MD1CON0, Bit 6 = -. MD1CON0, Bit 5 = OUT. MD1CON0, Bit 4 = OPOL. MD1CON0, Bit 3 = -. MD1CON0, Bit 2 = -. MD1CON0, Bit 1 = -. MD1CON0, Bit 0 = BIT. MD1CON0, Register on Page = 456. MD1CON1, Bit 7 = -. MD1CON1, Bit 6 = -. MD1CON1, Bit 5 = CHPOL. MD1CON1, Bit 4 = CHSYNC. MD1CON1, Bit 3 = -. MD1CON1, Bit 2 = -. MD1CON1, Bit 1 = CLPOL. MD1CON1, Bit 0 = CLSYNC. MD1CON1, Register on Page = 457. MD1CARH, Bit 7 = -. MD1CARH, Bit 6 = -. MD1CARH, Bit 5 = -. MD1CARH, Bit 4 = -. MD1CARH, Bit 3 = -.",
    "TABLE 30-3: SUMMARY OF REGISTERS ASSOCIATED WITH DATA SIGNAL MODULATOR MODE\nMD1CARH, Bit 2 = . MD1CARH, Bit 1 = CHS<2:0>. MD1CARH, Bit 0 = . MD1CARH, Register on Page = 458. MD1CARL, Bit 7 = -. MD1CARL, Bit 6 = -. MD1CARL, Bit 5 = -. MD1CARL, Bit 4 = -. MD1CARL, Bit 3 = -. MD1CARL, Bit 2 = . MD1CARL, Bit 1 = CLS<2:0>. MD1CARL, Bit 0 = . MD1CARL, Register on Page = 458. MDSRC, Bit 7 = -. MDSRC, Bit 6 = -. MDSRC, Bit 5 = -. MDSRC, Bit 4 = -. MDSRC, Bit 3 = SRCS<3:0>. MDSRC, Bit 2 = SRCS<3:0>. MDSRC, Bit 1 = SRCS<3:0>. MDSRC, Bit 0 = . MDSRC, Register on Page = 459",
    "TABLE 30-3: SUMMARY OF REGISTERS ASSOCIATED WITH DATA SIGNAL MODULATOR MODE\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used in the Data Signal Modulator mode.",
    "31.0 UNIVERSAL ASYNCHRONOUS RECEIVER TRANSMITTER (UART) WITH PROTOCOL SUPPORT\nThe  Universal  Asynchronous Receiver  Transmitter (UART) module is a serial I/O communications peripheral.  It  contains  all  the  clock  generators,  shift registers  and  data  buffers  necessary  to  perform  an input  or  output  serial  data  transfer,  independent  of device program execution. The UART, also known as a Serial Communications Interface (SCI), can be configured  as  a  full-duplex  asynchronous  system  or one of several automated protocols. Full-Duplex mode is useful for communications with peripheral systems, such as CRT terminals and personal computers.\nSupported protocols include:\n\u00b7 LIN Master and Slave\n\u00b7 DMX mode\n\u00b7 DALI control gear and control device",
    "PIC18(L)F25/26K83\nThe UART module includes the following capabilities:\n\u00b7 Full-duplex asynchronous transmit and receive\n\u00b7 Two-character input buffer\n\u00b7 One-character output buffer\n\u00b7 Programmable 7-bit or 8-bit character length\n\u00b7 9th bit Address detection\n\u00b7 9th bit even or odd parity\n\u00b7 Input buffer overrun error detection\n\u00b7 Received character framing error detection\n\u00b7 Hardware and software flow control\n\u00b7 Automatic checksums\n\u00b7 Programmable 1, 1.5, and 2 Stop bits\n\u00b7 Programmable data polarity\n\u00b7 Manchester encoder/decoder\n\u00b7 Operation in Sleep\n\u00b7 Automatic detection and calibration of the baud rate\n\u00b7 Wake-up on Break reception\n\u00b7 Automatic and user timed Break period generation\n\u00b7 RX and TX inactivity timeouts (with Timer2)\nBlock diagrams of the UART transmitter and receiver are shown in Figure 31-1 and Figure 31-2.\nThe UART transmit output (TX_out) is available to the TX pin and internally to various peripherals.",
    "FIGURE 31-2: UART RECEIVE BLOCK DIAGRAM\nThe  operation  of  the  UART  module  is  controlled through nineteen registers:\n\u00b7 Three control registers (UxCON0-UxCON2)\n\u00b7 Error enable and status (UxERRIE, UxERRIR, UxUIR)\n\u00b7 UART buffer status and control (UxFIFO)\n\u00b7 Three 9-bit protocol parameters (UxP1-UxP3)\n\u00b7 16-bit baud rate generator (UxBRGH:L)\n\u00b7 Transmit buffer write (UxTXB)\n\u00b7 Receive buffer read (UxRXB)\n\u00b7 Receive checksum (UxRXCHK)\n\u00b7 Transmit checksum (UxTXCHK)\nThese registers are detailed in Section 31.21 'Register Definitions: UART Control' .",
    "31.1 UART I/O Pin Configuration\nrepresents a ' 1 ' data bit, and a VOL Space state, which represents  a  ' 0 '  data  bit.  NRZ  refers  to  the  fact  that consecutively transmitted data bits of the same value stay at the output level of that bit without returning to a neutral  level  between  each  bit  transmission. An  NRZ transmission port idles in the Mark state. Each character transmission consists of one Start bit followed by seven or eight data bits, one optional parity or address bit, and is always terminated by one or more Stop bits. The Start bit  is  always  a  space  and  the  Stop  bits  are  always marks. The most common data format is eight bits with no parity. Each transmitted bit persists for a period of 1/ (Baud  Rate). An  on-chip  dedicated  16-bit  Baud  Rate Generator is used to derive standard baud rate frequencies from the system oscillator. See Section 31.17 'UART Baud Rate Generator (BRG)' for more information.",
    "31.1 UART I/O Pin Configuration\nThe RX input pin is selected with the UxRPPS register. The TX output pin is selected with each pin's RxyPPS register. When the TRIS control for the pin corresponding to the TX output is cleared, then the UART will maintain control and the logic level on the TX pin. Changing the TXPOL bit in UxCON2 will immediately change the TX pin logic level regardless of the value of EN or TXEN.",
    "31.2 UART Asynchronous Modes\nThe UART has five asynchronous modes:\n\u00b7 7-bit\n\u00b7 8-bit\n\u00b7 8-bit with even parity in the 9th bit\n\u00b7 8-bit with odd parity in the 9th bit\n\u00b7 8-bit with address indicator in the 9th bit\nThe  UART  transmits  and  receives  data  using  the standard  Non-Return-to-Zero  (NRZ)  format.  NRZ  is implemented with two levels: a VOH Mark state, which\nIn  all  the Asynchronous  modes,  the  UART  transmits and receives the LSb first. The UART's transmitter and receiver  are  functionally  independent,  but  share  the same data format and baud rate. Parity is supported by the hardware by even and odd parity modes.",
    "31.2.1 UART ASYNCHRONOUS TRANSMITTER\nThe  UART  transmitter  block  diagram  is  shown  in Figure 31-1. The heart of the transmitter is the serial Transmit  Shift  Register  (TSR),  which  is  not  directly accessible by software. The TSR obtains its data from the transmit buffer, which is the UxTXB register.",
    "31.2.1.1 Enabling the Transmitter\nThe  UART  transmitter  is  enabled  for  asynchronous operations by configuring the following control bits:\n\u00b7 TXEN = 1\n\u00b7 MODE<3:0> = 0h through 3h\n\u00b7 UxBRGH:L = desired baud rate\n\u00b7 UxBRGS = desired baud rate multiplier\n\u00b7 RxyPPS = code for desired output pin\n\u00b7 ON = 1\nAll other UART control bits are assumed to be in their default state.\nSetting the TXEN bit in the UxCON0 register enables the transmitter circuitry of the UART. The MODE<3:0> bits  in  the  UxCON0 register select the desired mode. Setting the ON bit in the UxCON1 register enables the UART. When TXEN is set and the transmitter is not idle, the  TX  pin  is  automatically  configured  as  an  output. When  the  transmitter  is  idle, the  TX  pin  drive  is relinquished  to  the  port TRIS  control.  If  the TX  pin  is shared  with  an  analog  peripheral,  the  analog  I/O function should be disabled by clearing the corresponding ANSEL bit.",
    "Note:\nThe  UxTXIF Transmitter  Interrupt  flag  is set when the TXEN enable bit is set and the UxTXB register can accept data.",
    "31.2.1.2 Transmitting Data\nA transmission is initiated by writing a character to the UxTXB  register.  If  this  is  the  first  character,  or  the previous  character  has  been  completely  transmitted from  the  TSR,  the  data  in  the  UxTXB  is  immediately transferred to the TSR register. If the TSR still contains all  or  part  of  a  previous  character,  the  new  character data is held in the UxTXB until the previous character transmission is complete. The pending character in the UxTXB is then transferred to the TSR at the beginning of  the  previous  character  Stop  bit  transmission.  The transmission  of  the  Start  bit,  data  bits  and  Stop  bit sequence commences immediately following the completion of all of the previous character's Stop bits.",
    "31.2.1.3 Transmit Data Polarity\nThe polarity of the transmit data is controlled with the TXPOL bit in the UxCON2 register. The default state of this  bit  is  ' 0 '  which selects high true transmit idle and data  bits.  Setting  the  TXPOL  bit  to  ' 1 '  will  invert  the transmit data, resulting in low true idle and data bits. The TXPOL bit controls transmit data polarity in all modes.",
    "31.2.1.4 Transmit Interrupt Flag\nThe UxTXIF interrupt flag bit in the PIR register is set whenever  the  UART  transmitter  is  enabled  and  no character is being held for transmission in the UxTXB. In other words, the UxTXIF bit is clear only when the TSR is busy with a character and a new character has been queued for transmission in the UxTXB.\nThe UxTXIF  interrupt  can  be  enabled  by  setting  the UxTXIE  interrupt enable bit in the PIE register. However, the UxTXIF flag bit will be set whenever the UxTXB  is  empty,  regardless  of  the  state  of  UxTXIE enable bit.The UxTXIF bit is read-only and cannot be set or cleared by software.\nTo  use  interrupts  when  transmitting  data,  set  the UxTXIE bit only when there is more data to send. Clear the  UxTXIE  interrupt  enable  bit  upon  writing  UxTXB with the last character of the transmission.",
    "31.2.1.5 TSR Status\nThe TXMTIF bit in the UxERRIR register indicates the status of the TSR. This is a read-only bit. The TXMTIF bit is set when the TSR is empty and idle. The TXMTIF bit  is  cleared  when  a  character  is  transferred  to  the TSR from the UxTXB. The TXMTIF bit remains clear until all bits, including the Stop bits, have been shifted out of the TSR and a byte is not waiting in the UxTXB register.\nThe  TXMTIF  will  generate  an  interrupt  when  the TXMTIE bit in the UxERRIE register is set.\nNote: The TSR is not mapped in data memory, so it is not available to the user.",
    "31.2.1.6 Transmitter 7-bit Mode\n7-Bit mode is selected when the MODE<3:0> bits are set  to  ' 0001 '.  In  7-bit  mode,  only  the  seven  Least Significant  bits  of  the  data  written  to  UxTXB  are transmitted. The Most Significant bit is ignored.",
    "31.2.1.7 Transmitter Parity Modes\nWhen the Odd or even Parity mode is selected, all data is sent as nine bits. The first eight bits are data and the 9th bit is parity. Even and odd parity is selected when the  MODE<3:0>  bits  are  set  to  ' 0011 ' and  ' 0010 ', respectively. Parity is automatically determined by the module and inserted in the serial data stream.",
    "31.2.1.8 Asynchronous Transmission Setup\n1. Initialize the UxBRGH, UxBRGL register pair and the BRGS bit to achieve the desired baud rate (see Section 31.17 'UART Baud Rate Generator (BRG)' ).\n2. Set the MODE<3:0> bits to the desired Asynchronous mode.\n3. Set TXPOL bit if inverted TX output is desired.\n4. Enable the asynchronous serial port by setting the ON bit.\n5. Enable  the  transmitter  by  setting  the  TXEN control bit. This will cause the UxTXIF interrupt flag to be set.\n6. If the device has PPS, configure the desired I/O pin RxyPPS register with the code for TX output.\n7. If interrupts are desired, set the UxTXIE interrupt enable  bit  in  the  respective  PIE  register.  An interrupt will occur immediately provided that the GIE bits in the INTCON0 register are also set.\n8. Write one byte of data into the UxTXB register. This will start the transmission.\n9. Subsequent  bytes  may  be  written  when  the UxTXIF bit is ' 1 '.",
    "31.2.2 UART ASYNCHRONOUS RECEIVER\nThe Asynchronous mode is typically used in RS-232 systems.  The  receiver  block  diagram  is  shown  in Figure 31-2. The data is received on the RX pin and drives the data recovery block. The data recovery block is  actually  a  high-speed  shifter  operating  at  4  or  16 times the baud rate, whereas the serial Receive Shift Register (RSR) operates at the bit rate. When all bits of the character have been shifted in, they are immediately  transferred  to  a  two  character  First-InFirst-Out  (FIFO)  memory.  The  FIFO  buffering  allows reception of two complete characters and the start of a third character before software must start servicing the UART receiver. The FIFO registers and RSR are not directly accessible by software. Access to the received data is via the UxRXB register.",
    "31.2.2.1 Enabling the Receiver\nThe UART receiver is enabled for asynchronous oper -ation by configuring the following control bits:\n\u00b7 RXEN = 1\n\u00b7 MODE<3:0> = 0h through 3h\n\u00b7 UxBRGH:L = desired baud rate\n\u00b7 RXPPS = code for desired input pin\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 ON = 1\nAll other UART control bits are assumed to be in their default state.\nSetting the RXEN bit in the UxCON0 register enables the receiver circuitry of the UART. Setting the MODE<3:0> bits in the UxCON0 register configures the UART for the desired Asynchronous mode. Setting the ON bit in the UxCON1 register enables the UART. The TRIS bit corresponding to the selected RX I/O pin must be set to configure the pin as an input.",
    "Note:\nIf the RX function is on an analog pin, the corresponding ANSEL bit must be cleared for the receiver to function.",
    "31.2.2.2 Receiving Data\nData is recovered from the bit stream by timing to the center of the bits and sampling the input level. In HighSpeed mode, there are four BRG clocks per bit and only  one  sample  is  taken  per  bit.  In  Normal-Speed mode,  there  are  16  BRG  clocks  per  bit  and  three samples are taken per bit.\nThe  receiver  data  recovery  circuit  initiates  character reception on the falling edge of the Start bit. The Start bit, is always a ' 0 '. The Start bit is qualified in the middle of the bit. In Normal-Speed mode only, the Start bit is also  qualified  at  the  leading  edge  of  the  bit.  The following paragraphs  describe  the  majority detect sampling of Normal-Speed mode.\nThe falling edge starts the baud rate generator (BRG) clock. The input is sampled at the first and second BRG clocks.\nIf both  samples  are  high  then  the  falling  edge  is deemed a glitch and the UART returns to the Start bit detection state without generating an error.",
    "31.2.2.2 Receiving Data\nIf either sample  is  low,  the  data  recovery  circuit continues counting BRG clocks and takes samples at clock counts 7, 8, and 9. When less than two samples are low, the Start bit is deemed invalid and the data recovery  circuit  aborts  character  reception,  without generating an error, and resumes looking for the falling edge of the Start bit.\nWhen two or  more  samples  are  low,  the  Start  bit  is deemed valid and the data recovery continues. After a valid  Start  bit  is  detected,  the  BRG  clock  counter continues and resets at count 16. This is the beginning of the first data bit.\nThe data recovery circuit counts BRG clocks from the beginning of the bit and takes samples at clocks 7, 8, and 9. The bit value is determined from the majority of the samples. The resulting ' 0 '  or ' 1 '  is shifted into the RSR.The BRG clock counter continues and resets at count 16. This sequence repeats until all data bits have been sampled and shifted into the RSR.",
    "31.2.2.2 Receiving Data\nAfter all data bits have been shifted in, the first Stop bit is sampled. Stop bits are always a ' 1 '. If the bit sampling determines  that  a  ' 0 '  is  in  the  Stop  bit  position,  the framing error is set for this character. Otherwise, the framing error is cleared for this character. See Section 31.2.2.4 'Receive Framing Error' for more information on framing errors.",
    "31.2.2.3 Receive Interrupts\nImmediately after  all data  bits  and  the  Stop  bit  have been received, the character in the RSR is transferred to the UART receive FIFO. The UxRXIF interrupt flag in the respective PIR register is set at this time, provided it is not being suppressed.\nThe UxRXIF is suppressed by any of the following:\n\u00b7 FERIF if FERIE is set\n\u00b7 PERIF if PERIE is set\nThis  suspends  DMA  transfer  of  data  until  software processes the error and reads UxRXB to advance the FIFO beyond the error.\nUxRXIF  interrupts  are  enabled  by  setting  all  of  the following bits:\n\u00b7 UxRXIE, Interrupt Enable bit in the PIE register\n\u00b7 GIE, Global Interrupt Enable bits in the INTCON0 register",
    "31.2.2.3 Receive Interrupts\nThe  UxRXIF  interrupt  flag  bit  will  be  set  when  not suppressed  and  there  is  an  unread  character  in  the FIFO, regardless of the state of interrupt enable bits. Reading  the  UxRXB  register  will  transfer  the  top character  out  of  the FIFO  and  reduce  the  FIFO contents by one. The UxRXIF interrupt flag bit is readonly, it cannot be set or cleared by software.",
    "31.2.2.4 Receive Framing Error\nEach  character  in  the  receive  FIFO  buffer  has  a corresponding  framing  error  flag  bit. A  framing  error indicates that the Stop bit was not seen at the expected time. The framing error flag is accessed via the FERIF bit in the UxERRIR register. The FERIF bit represents the  frame  status  of  the  top  unread  character  of  the receive FIFO. Therefore, the FERIF bit must be read before reading UxRXB.\nThe FERIF bit is read-only and only applies to the top unread character of the receive FIFO. A framing error (FERIF = 1 ) does not preclude reception of additional characters. It is neither necessary nor possible to clear the FERIF bit directly. Reading the next character from the  FIFO  buffer  will  advance  the  FIFO  to  the  next character and the next corresponding framing error.\nThe FERIF bit is cleared when the character at the top of the FIFO does not have a framing error or when all bytes in the receive FIFO have been read. Clearing the ON bit resets the receive FIFO, thereby also clearing the FERIF bit.",
    "31.2.2.4 Receive Framing Error\nA  framing  error  will  generate  a  summary  UxERR interrupt when the FERIE bit in the UxERRIE register is set. The summary error is reset when the FERIF bit of the top of the FIFO is ' 0 ' or when all FIFO characters have been retrieved.\nWhen FERIE is set, UxRXIF interrupts are suppressed when FERIF is ' 1 '.",
    "31.2.2.5 Receiver Parity Modes\nEven and odd parity is automatically detected when the MODE<3:0> bits are set to ' 0011 ' and ' 0010 ', respectively.  Parity  modes  receive  eight  data  bits  and one parity bit for a total of nine bits for each character. The PERIF bit in the UxERRIR register represents the parity error of the top unread character of the receive FIFO rather than the parity bit itself. The parity error must be read before reading the UxRXB register advances the FIFO.\nA parity error will generate a summary UxERR interrupt when the PERIE bit in the UxERRIE register is set.The summary error is reset when the PERIF bit of the top of the FIFO is ' 0 ' or when all FIFO characters have been retrieved.\nWhen PERIE is set, UxRXIF interrupts are suppressed when PERIF is ' 1 '.",
    "31.2.2.6 Receive FIFO Overflow\nWhen more characters are received than the receive FIFO can hold, the RXFOIF bit in the UxERRIR register is set. The character causing the overflow condition is discarded. The RUNOVF bit in the UxCON2 register determines how the receive circuit responds to characters while the overflow condition persists. When RUNOVF is set, the receive shifter stays synchronized to  the  incoming  data  stream  by  responding  to  Start, data,  and  Stop  bits.  However,  all  received  bytes  not already in the FIFO are discarded. When RUNOVF is cleared, the receive shifter ceases operation and Start, data, and Stop bits are ignored. The receive overflow condition is cleared by reading the UxRXB register and clearing the RXFOIF bit. If the UxRXB register is not read to open a space in the FIFO, the next character received will be discarded and cause another overflow condition.\nA  receive  overflow  error  will  generate  a  summary UxEIF interrupt when the RXFOIE bit in the UxERRIE register is set.",
    "31.2.2.7 Asynchronous Reception Setup\n1. Initialize  the  UxBRGH,  UxBRGL  register  pair and the BRGS bit to achieve the desired baud rate  (see Section 31.17  'UART  Baud  Rate Generator (BRG)' ).\n2. Configure the RXPPS register for the desired RX pin\n3. Clear the  ANSEL bit for the RX pin (if applicable).\n4. Set the MODE<3:0> bits to the desired Asynchronous mode.\n5. Set the RXPOL bit if the data stream is inverted.\n6. Enable the serial port by setting the ON bit.\n7. If  interrupts are desired, set the UxRXIE bit in the PIEx  register and  the  GIE  bits  in the INTCON0 register.\n8. Enable reception by setting the RXEN bit.\n9. The UxRXIF interrupt flag bit will be set when a character  is  transferred  from  the  RSR  to  the receive buffer. An interrupt will be generated if the UxRXIE interrupt enable bit is also set.\n10. Read  the  UxERRIR  register  to  get  the  error flags.",
    "31.2.2.7 Asynchronous Reception Setup\n11. Read  the  UxRXB  register  to  get  the  received byte.\n12. If an overrun occurred, clear the RXFOIF bit.",
    "31.3 Asynchronous Address Mode\nA special Address Detection mode is available for use when multiple receivers share the same transmission line, such as in RS-485 systems.\nWhen  Asynchronous  Address  mode  is  enabled,  all data  is  transmitted  and  received  as  9-bit  characters. The  9th  bit  determines  whether  the  character  is  an address or data. When the 9th bit is set, the eight Least Significant  bits  are  the  address.  When  the  9th  bit  is clear, the Least Significant bits are data. In either case, the 9th bit is stored in PERIF when the byte is written to the receive FIFO. When PERIE is also set, the RXIF will be suppressed, thereby suspending DMA transfers allowing software to process the received address.\nAn  address  character  will  enable  all  receivers  that match  the  address  and  disable  all  other  receivers. Once a receiver is enabled, all non-address characters will be received until an address character is received that does not match.",
    "31.3.1 ADDRESS MODE TRANSMIT\nThe  UART  transmitter  is  enabled  for  asynchronous address operation by configuring the following control bits:\n\u00b7 TXEN = 1\n\u00b7 MODE<3:0> = 0100\n\u00b7 UxBRGH:L = desired baud rate\n\u00b7 RxyPPS = code for desired output pin\n\u00b7 ON = 1\nAddresses are sent by writing to the UxP1L register. This transmits the written byte with the 9th bit set, which indicates that the byte is an address.\nData  is  sent  by  writing  to  the  UxTXB  register.  This transmits the written byte with the 9th bit cleared, which indicates that the byte is data.\nTo send data to a particular device on the transmission bus, first transmit the address of the intended device. All subsequent data will be accepted only by that device until an address of another device is transmitted.\nWrites  to  UxP1L  take  precedence  over  writes  to UxTXB. When both the UxP1L and UxTXB registers are written while the TSR is busy, the next byte to be transmitted will be from UxP1L.",
    "31.3.1 ADDRESS MODE TRANSMIT\nTo ensure that all data intended for one device is sent before the address is changed, wait until the TXMTIF bit is high before writing UxP1L with the new address.",
    "31.3.2 ADDRESS MODE RECEIVE\nThe  UART  receiver  is  enabled  for  asynchronous address operation by configuring the following control bits:\n\u00b7 RXEN = 1\n\u00b7 MODE<3:0> = 0100\n\u00b7 UxBRGH:L = desired baud rate\n\u00b7 RXPPS = code for desired input pin\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 UxP2L = receiver address\n\u00b7 UxP3L = address mask\n\u00b7 ON = 1\nIn Address  mode,  no  data  will  be  transferred  to  the input FIFO until a valid address is received. This is the default state. Any of the following conditions will cause the UART to revert to the default state:\n\u00b7 ON = 0\n\u00b7 RXEN = 0\n\u00b7 Received address does not match\nWhen a character with the 9th bit set is received, the Least  Significant  eight  bits  of  that  character  will  be qualified  by  the  values  in  the  UxP2L  and  UxP3L registers.",
    "31.3.2 ADDRESS MODE RECEIVE\nThe byte is XOR'd with UxP2L then AND'd with UxP3L. A match occurs when the result is 0h, in which case, the  unaltered  received  character  is  stored  in  the receive FIFO, thereby setting the UxRXIF interrupt bit. The 9th bit is stored in the corresponding PERIF bit, identifying this byte as an address.\nAn address match also enables the receiver for all data such that all subsequent characters without the 9th bit set will be stored in the receive FIFO.\nWhen the 9th bit is set and a match does not occur, the character  is  not  stored  in  the  receive  FIFO  and  all subsequent data is ignored.\nThe UxP3L register mask allows a range of addresses to be accepted. Software can then determine the subaddress  of  the  range  by  processing  the  received address character.",
    "31.4 DMX Mode\nDMX is a protocol used in stage and show equipment. This includes lighting, fog machines, motors, etc. The protocol  consists  of  a  controller  that  sends  out  com -mands, and receiver such as theater lights that receive these  commands.  DMX  protocol  is  usually  unidirec -tional, but can be a bidirectional protocol in either Half or  Full-Duplex  modes.  An  example  of  Half-Duplex mode is the RDM (Remote Device Management) pro -tocol  that  sits  on  DMX512A. The  controller transmits commands and the receiver receives them. Also there are no error conditions or retransmit mechanisms.\nDMX,  or  DMX512A  as  it  is  known,  consists  of  a 'Universe'  of  512  channels.  This  means  that  one controller can output up to 512 bytes on a single DMX link.  Each  equipment  on  the  line  is  programmed  to listen  to  a  consecutive  sequence  of  one  or  more  of these bytes.\nFor example, a fog machine connected to one of the universes  may  be  programmed  to  receive  one  byte, starting at byte number 10, and a lighting unit may be programmed  to  receive  four  bytes  starting  at  byte number 22.",
    "31.4.1 DMX CONTROLLER\nDMX Controller mode is configured with the following settings:\n\u00b7 MODE<3:0> = 1010\n\u00b7 TXEN = 1\n\u00b7 RXEN = 0\n\u00b7 TXPOL = 1\n\u00b7 UxP1 = One less than the number of bytes to transmit (excluding the Start code)\n\u00b7 UxBRGH:L = Value to achieve 250K baud rate\n\u00b7 STP<1:0> = 10 for 2 Stop bits\n\u00b7 RxyPPS = TX pin output code\n\u00b7 ON = 1\nEach DMX transmission begins with a Break followed by  a  byte  called  the  'Start  Code'.  The  width  of  the BREAK is fixed at 25 bit times. The Break is followed by  a  'Mark After  Break'  (MAB)  Idle  period. After  this Idle  period,  the  1st  through  'n'th  byte  is  transmitted, where 'n-1' is the value in UxP1. See Figure 31-6.\nSoftware sends the Start Code and the 'n' data bytes by writing the UxTXB register with each byte to be sent in the desired order. A UxTXIF value of ' 1 ' indicates when the UxTXB is ready to accept the next byte.",
    "31.4.1 DMX CONTROLLER\nThe internal byte counter is not accessible to software. Software needs to keep track of the number of bytes written to UxTXB to ensure that no more and no less than 'n' bytes are sent because the DMX state machine will automatically insert a Break and reset its internal counter after 'n' bytes are written. One way to ensure synchronization between hardware and software is to toggle  TXEN  after  the  last  byte  of  the  universe  is completely free of the transmit shift register as indicated by the TXMTIF bit.",
    "31.4.2 DMX RECEIVER\nDMX Receiver mode is configured with the following settings:\n\u00b7 MODE<3:0> = 1010\n\u00b7 TXEN = 0\n\u00b7 RXEN = 1\n\u00b7 RXPOL = 1\n\u00b7 UxP2 = number of first byte to receive\n\u00b7 UxP3 = number of last byte to receive\n\u00b7 UxBRGH:L = Value to achieve 250K baud rate\n\u00b7 STP<1:0> = 10 for 2 Stop bits\n\u00b7 ON = 1\n\u00b7 UxRXPPS = code for desired input pin\n\u00b7 Input pin ANSEL bit = 0\nWhen configured as DMX Receiver, the UART listens for a Break character that is at least 23 bit periods wide. If  the Break is shorter than 23 bit times, the Break is ignored  and  the  DMX  state  machine  remains  in  Idle mode. Upon receiving the Break, the DMX counters will be  reset  to  align  with  the  incoming  data  stream. Immediately  after  the  Break,  the  UART  will  see  the 'Mark after Break' (MAB). This space is ignored by the UART. The Start Code follows the MAB and will always be stored in the receive FIFO.",
    "31.4.2 DMX RECEIVER\nAfter the Start Code, the 1st through 512th byte will be received, but not all of them are stored in the receive FIFO. The UART ignores all received bytes until the ones of interest are received. This is done using the UxP2 and UxP3 registers. The UxP2 register holds the value of the byte number to start the receive process and  the  UxP3  register  holds  the  value  of  the  byte number to end the receive process. The byte counter starts at 0 for the first  byte  after the  Start Code.  For example, to receive four bytes starting at the 10th byte after the Start Code, write 009h (9 decimal) to UxP2H:L and 00Ch (12 decimal) to UxP3H:L. The receive FIFO is  only  2  bytes  deep,  therefore  the  bytes  must  be retrieved by reading UxRXB as they come in to avoid a receive FIFO overrun condition.\nTypically two Stop bits are inserted between bytes. If either Stop bit is detected as a ' 0 ' then the framing error for that byte will be set.",
    "31.4.2 DMX RECEIVER\nSince the DMX sequence always starts with a Break, the  software  can  verify  that  it  is  in  sync  with  the sequence by monitoring the RXBKIF flag to ensure that the next byte received after the RXBKIF is processed as the Start Code and subsequent bytes are processed as the expected data.",
    "31.5 LIN Modes\nLIN is a protocol used primarily in automotive applications. The LIN network consists of two kinds of software  processes:  a  Master  process  and  a  Slave process. Each network has only one Master process and one or more Slave processes.\nFrom a physical layer point of view, the UART on one processor may be driven by both a Master and a Slave process, as long as only one Master process exists on the network.\nWhen  a slave receives data, the checksum is accumulated on each byte as it is received using the same algorithm as the sending process. The last byte, which is the inverted checksum value calculated by the sending  process,  is  added  to  the  locally  calculated checksum by the UART. The check passes when the result  is  all  ' 1 's,  otherwise  the  check  fails  and  the CERIF bit is set.\nA LIN transaction consists of a Master process followed by  a  Slave  process. The  Slave  process  may  involve more than one slave where one is transmitting and the other(s) are receiving. The transaction begins by the following Master process transmission sequence:\n1. Break\n2. Delimiter bit\n3. Sync Field\n4. PID byte",
    "31.5 LIN Modes\nThe  PID  determines which Slave processes are expected to respond to the Master. When the PID byte is  complete,  the TX output  remains in the  Idle  state. One or more of the Slave processes may respond to the Master process. If no one responds within the interbyte period, the Master is free to start another transmis -sion. The inter-byte period is timed by software using a means other than the UART.\nThe Slave process follows the Master process. When the slave software recognizes the PID then that Slave process  responds  by  either  transmitting  the  required response  or  by  receiving  the  transmitted  data.  Only Slave processes send data. Therefore, Slave processes receiving data are receiving that of another Slave process.\nWhen a slave sends data, the slave UART automatically calculates the checksum for the transmitted  bytes  as  they  are  sent  and  appends  the inverted checksum byte to the slave response.",
    "31.5 LIN Modes\nTwo methods for computing the checksum are available: legacy and enhanced. The legacy checksum includes only the data bytes. The enhanced checksum includes the PID and the data. The C0EN control bit in the UxCON2 register determines the checksum method.  Setting  C0EN  to  ' 1 ' selects  the  enhanced method. Software must select the appropriate method before the Start bit of the checksum byte is received.",
    "31.5.1 LIN MASTER/SLAVE MODE\nThe LIN Master mode includes capabilities to generate Slave processes. The Master process stops at the PID transmission. Any  data  that  is  transmitted  in  Master/ Slave mode is done as a Slave process. LIN Master/ Slave mode is configured by the following settings:\n\u00b7 MODE<3:0> = 1100\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxBRGH:L = Value to achieve desired baud rate\n\u00b7 TXPOL = 0 (for high Idle state)\n\u00b7 STP = desired Stop bits selection\n\u00b7 C0EN = desired checksum mode\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 ON = 1",
    "Note:\nThe  TXEN  bit  must  be  set  before  the Master process is received and remain set while  in  LIN  mode  whether  or  not  the Slave process is a transmitter.\nThe Master process is started by writing the PID to the UxP1L register when UxP2 is ' 0 ' and the UART is Idle. The UxTXIF will not be set in this case. Only the six Least  Significant  bits  of  UxP1L  are  used  in  the  PID transmission.\nThe two Most Significant bits of the transmitted PID are PID parity bits. PID<6> is the exclusive-or of PID bits 0,1,2,and 4. PID<7> is the inverse of the exclusive-or of PID bits 1,3,4,and 5.\nThe UART calculates and inserts these bits in the serial stream.",
    "Note:\nWriting UxP1L automatically clears the UxTXCHK and UxRXCHK registers and generates the Break, delimiter bit, Sync character (55h), and PID transmission portion of the transaction. The data portion of the transaction that  follows,  if  there  is  one,  is  a  Slave  process.  See Section 31.5.2 'LIN Slave Mode' for more details of that process. The master receives its own PID when RXEN  is  set.  Software  performs  the  Slave  process corresponding to the PID that was sent and received. Attempting  to  write  UxP1L  before  an  active  master process  is  complete  will  not  succeed.  Instead,  the TXWRE bit will be set.",
    "31.5.2 LIN SLAVE MODE\nLIN Slave mode is configured by the following settings:\n\u00b7 MODE<3:0> = 1011\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP2 = Number of data bytes to transmit\n\u00b7 UxP3 = Number of data bytes to receive\n\u00b7 UxBRGH:L = Value to achieve default baud rate\n\u00b7 TXPOL = 0 (for high Idle state)\n\u00b7 STP = desired Stop bits selection\n\u00b7 C0EN = desired checksum mode\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 ON = 1",
    "31.5.2 LIN SLAVE MODE\nThe Slave process starts upon detecting a Break on the RX pin. The Break clears the UxTXCHK, UxRXCHK, UxP2, and UxP3 registers. At the end of the Break, the auto-baud  circuity  is  activated  and  the  baud  rate  is automatically  set  using  the  Sync  character  following the Break. The character following the Sync character is received as the PID code and is saved in the receive FIFO. The UART computes the two PID parity bits from the six Least Significant bits of the PID. If either parity bit does not match the corresponding bit of the received PID code, the PERIF flag is set and saved at the same FIFO location as the PID code. The UxRXIF bit is set indicating that the PID is available.\nSoftware  retrieves  the  PID  by  reading  the  UxRXB register and determines the Slave process to execute from  that.  The  checksum  method,  number  of  data bytes, and whether to send or receive data, is defined by software according to the PID code.",
    "31.5.2.1 LIN Slave Receiver\nWhen  the  Slave  process  is  a  receiver,  the  software performs the following tasks:\n\u00b7 UxP3 register is written with a value equal to the number of data bytes to receive.\n\u00b7 C0EN bit is set or cleared to select the appropriate checksum. This must be completed before the Start bit of the checksum byte is received.\n\u00b7 Each byte of the process response is read from UxRXB when UxRXIF is set.\nThe UART updates the checksum  on each received byte. When the last data byte is received, the computed checksum total is stored in the UxRXCHK register. The next  received byte  is  saved in the  receive FIFO and added with the value in UxRXCHK. The result of this addition is not accessible. However, if the result is not all  ' 1 's,  the  CERIF  bit  in  the  UxERRIR  is  set.  The CERIF flag persists until cleared by software. Software needs to read UxRXB to remove the checksum byte from  the  FIFO,  but  the  byte  can  be  discarded  if  not needed for any other purpose.",
    "31.5.2.1 LIN Slave Receiver\nAfter the checksum is received, the UART ignores all activity  on  the  RX  pin  until  a  Break  starts  the  next transaction.",
    "31.5.2.2 LIN Slave Transmitter\nWhen  the  Slave  process  is  a  transmitter,  software performs the following tasks in the order shown:\n\u00b7 UxP2 register is written with a value equal to the number of bytes to transmit. This will enable TXIF flag which is disabled when UxP2 is ' 0 '.\n\u00b7 C0EN bit is set or cleared to select the appropriate checksum\n\u00b7 Inter-byte delay is performed\n\u00b7 Each byte of the process response is written to UxTXB when UxTXIF is set\nThe UART accumulates the checksum as each byte is written  to  UxTXB. After  the  last  byte  is  written,  the UART stores the calculated checksum in the UxTXCHK register and transmits the inverted result as the last byte in the response.\nThe TXIF flag is disabled when UxP2 bytes have been written. Any  writes  to  UxTXB  that  exceed  the  UxP2 count will be ignored and set the TXWRE flag in the UxFIFO register.",
    "31.6 DALI Mode\nDALI is a protocol used for intelligent lighting control for building automation. The protocol consists of 'Control Devices'  and  'Control  Gear'.  A  Control  Device  is  an application controller that sends out commands to the light fixtures. The light fixture itself is termed as a con -trol gear. The communication is done using Manches -ter encoding, which is performed by the UART hardware.\nManchester encoding consists of the clock and data in a single bit stream. A high-to-low or a low-to-high tran -sition always occurs in the middle of the bit period and is not guaranteed to occur at the bit period boundaries.\nWhen the consecutive bits in the bit stream are of the same value (i.e., consecutive ' 1 's or consecutive ' 0 's), a transition occurs at the bit boundary. However, when the bit value changes, there is no transition at the bit boundary. According to the standard, a half-bit time is typically 416.7 \uf06d s long. A double half-bit time or a single bit is typically 833.3 \uf06d s.",
    "31.6 DALI Mode\nThe protocol is inherently half-duplex. Communication over the bus occurs in the form of forward and back -ward  frames.  Wait  times  between  the  frames  are defined in the standard to prevent collision between the frames.\nA Control Device transmission is termed as the 'For -ward Frame'. In the DALI 2.0 standard, a forward frame can be two or three bytes in length. The two-byte for -ward frame is used for communication between control device  and  control  gear,  whereas  the  three-byte  for -ward frame is used for communication between Control Devices on the bus. The first byte in the forward frame is the control byte and is followed by either one or two data bytes. The transaction begins when the Control Device  starts  a  transmission.  Unlike  other  protocols, each byte in the frame is transmitted MSB first. Typical frame timing is as shown in Figure 31-8.\nDuring  communication  between  two  control  devices, three bytes are required to be transmitted. In this case, the software must write the third byte to UxTXB as soon as  UxTXIF  goes  True  and  before  the  output  shifter becomes empty. This ensures that the three bytes of the forward frame are transmitted back-to-back, with -out any interruption.",
    "31.6 DALI Mode\nAll control gear on the bus receive the forward frame. If the forward frame requires a reply to be sent, one of the control gear may respond with a single byte, called the 'Backward Frame'. The 2.0 standard requires the con -trol gear to begin transmission of the backward frame between 5.5 ms to 10.5 ms (~14 to 22 half-bit times) after  reception  of  the  forward  frame.  Once  the  back -ward  frame  is  received  by  the  Control  Device,  it  is required to wait a minimum of 2.4 ms (~6 half-bit times). After this wait time, the Control Device is free to trans -mit another forward frame (see Figure 31-9).",
    "31.6 DALI Mode\nA Start bit is used to indicate the start of the forward and backward frames. When ABDEN = 0 ,  the  receiver bit rate is determined by the BRG  register. When ABDEN = 1 , the first bit synchronizes the receiver with the transmitter and sets the receiver bit rate. The low period of the Start bit is measured and is used as the timing  reference  for  all  data  bits  in  the  forward  and backward frames. The ABDOVF bit is set if the Start bit low period causes the measurement counter to over -flow. All bits following the Start bit are data bits. The bit stream terminates when no transition is detected in the middle of a bit period (see Figure 31-7).\nForward and backward frames are terminated by two Idle bit periods or Stop bits. Normally, these start in the first bit period of a byte. If both Stop bits are valid, the byte reception is terminated and the CERIF bit in the UxERRIR1 register is set. This bit needs to be cleared in software.\nIf either of the Stop bits is invalid, the frame is tagged as  invalid  by  saving  it  as  a  null  byte  and  setting  the framing error in the receive FIFO.",
    "31.6 DALI Mode\nA  framing  error  also  occurs  when  no  transition  is detected on the bus in the middle of a bit period when the byte reception is not complete. In such a scenario, the byte will be saved with the FERIF bit.",
    "31.6.1 CONTROL DEVICE\nControl Device mode is configured with the following settings:\n\u00b7 MODE<3:0> = 1000\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP1 = Forward frames are held for transmission this number of half-bit periods after the completion of a forward or backward frame.\n\u00b7 UxP2 = Forward/backward frame threshold delim -iter. Any reception that starts this number of half bit periods after the completion of a forward or backward frame is detected as forward frame and sets the PERIF flag of the corresponding received byte.\n\u00b7 UxBRGH:L = Value to achieve 1200 baud rate\n\u00b7 TXPOL = appropriate polarity for interface circuit\n\u00b7 STP<1:0> = 10 for two Stop bits\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 ON = 1",
    "31.6.1 CONTROL DEVICE\nA forward frame is initiated by writing the control byte to the  UxTXB register.  Each  data  byte  after  the  control byte must be written to the UxTXB register as soon as UxTXIF  goes  true.  It  is  necessary  to  perform  every write  after  UxTXIF  goes  true  to  ensure  the  transmit buffer is ready to accept the byte. Each write must also occur before the TXMTIF bit goes true, to ensure that the  bit  stream  of  forward  frame  is  generated  without interruption.\nWhen TXMTIF goes true, indicating the transmit shift register  has  completed  sending  the  last  byte  in  the frame,  the TX  output  is  held  in  the  Idle  state  for  the number of half-bit periods selected by the STP bits in the UxCON2 register.\nAfter the last Stop bit, the TX output is held in the Idle state for an additional wait time determined by the halfbit period count in the UxP1 register. For example, a 2450 \uf06d s delay (~6 half-bit times) requires a value of 6 in UxP1L.",
    "31.6.1 CONTROL DEVICE\nAny  writes  to  the  UxTXB  register  that  occur  after TXMTIF goes true, but before the UxP1 wait time, will be held and then transmitted immediately following the wait time. If a backward frame is received during the wait  time,  any  bytes  that  may  have  been  written  to UxTXB  will  be  transmitted  after  completion  of  the backward frame reception the backward frame plus the UxP1 wait time.\nThe  wait  timer  is  reset  by  the  backward  frame  and starts over immediately following the Stop bits of the backward frame. Data pending in the transmit shift reg -ister will be sent when the wait time elapses.\nTo replace or delete any pending forward frame data, the TXBE bit needs to be set to flush the shift register and transmit buffer, then write the new control byte to the UxTXB register. The new control byte will be held in the buffer and sent as the beginning of the next forward frame following the UxP1 wait time.",
    "31.6.1 CONTROL DEVICE\nIn Control Device mode, PERIF is set when a forward frame is received. This helps the software distinguish whether the received byte is part of a forward frame from a Control Device (either from the Control Device under consideration or from another Control Device on the bus) or a backward frame from a Control Gear.",
    "31.6.2 CONTROL GEAR\nThe Control Gear mode is configured with the following settings:\n\u00b7 MODE<3:0> = 1001\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP1 = Backward frames are held for transmis -sion this number of half-bit periods after the com -pletion of a forward frame.\n\u00b7 UxP2 = Forward/backward frame threshold delimiter. Idle periods more than this number of half-bit periods are detected as forward frames.\n\u00b7 UxBRGH:L = Value to achieve 1200 baud rate\n\u00b7 TXPOL = appropriate polarity for interface circuit\n\u00b7 RXPOL = same as TXPOL\n\u00b7 STP = 10 for two Stop bits\n\u00b7 RxyPPS = TX pin output code\n\u00b7 TX pin TRIS control = 0\n\u00b7 RXPPS = RX pin selection code\n\u00b7 RX pin TRIS control = 1\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 ON = 1",
    "31.6.2 CONTROL GEAR\nThe UART starts listening for a forward frame when the Control Gear mode is entered. Only the frames that fol -low an Idle period longer than UxP2 half-bit periods are detected  as  forward  frames.  Backward  frames  from other Control Gear are ignored. Only forward frames will be stored in UxRXB. This is necessary because a backward frame can be sent only as a response to a forward frame.\nThe forward frame is received one byte at a time in the receive FIFO and retrieved by reading the UxRXB reg -ister.  The  end  of  the  forward  frame  starts  a  timer  to delay the backward frame response by wait time equal to the number of half-bit periods stored in UxP1. The data received in the forward frame is processed by the application software. If the application decides to send a backward frame in response to the forward frame, the value of the backward frame is written to UxTXB. This value is held for transmission in the transmit shift regis -ter until the wait time expires and is then transmitted.",
    "31.6.2 CONTROL GEAR\nIf the backward frame data is written to UxTXB after the wait time has expired, it is held in the UxTXB register until the end of the wait time following the next forward frame.  The  TXMTIF  bit  is  false  when  the  backward frame data is held in the transmit shift register. Receiv -ing a UxRXIF interrupt before the TXMTIF goes true indicates that the backward frame write was too late and another forward frame was received before send -ing the backward frame. The pending backward frame has to be flushed by setting the TXBE bit, to prevent it from being sent after the next Forward Frame.",
    "FIGURE 31-8: DALI FRAME TIMING\nTX pin, Control Byte 1 Code = CC<7>. TX pin,  = byte1<7> CC<6> CC<0>. TX pin, Byte 1 Control Code = byte1<0>. UxTXIF bit (Transmit Buffer, Control Byte 1 Code = . UxTXIF bit (Transmit Buffer,  = . UxTXIF bit (Transmit Buffer, Byte 1 Control Code = . Reg. Empty Flag), Control Byte 1 Code = . Reg. Empty Flag),  = . Reg. Empty Flag), Byte 1 Control Code = . TXMTIF bit (Transmit Shift Reg. Empty Flag), Control Byte 1 Code = . TXMTIF bit (Transmit Shift Reg. Empty Flag),  = . TXMTIF bit (Transmit Shift Reg. Empty Flag), Byte 1 Control Code = ",
    "31.7 General Purpose Manchester\nGeneral purpose Manchester is a subset of the DALI mode. When the UxP1L register is cleared, there is no minimum  wait  time  between  frames.  This  allows  full and half-duplex operation because writes to the UxTXB are not held waiting for a receive operation to complete.\nGeneral  purpose Manchester  operation  maintains  all other aspects of DALI mode such as:\n\u00b7 Single-pulse Start bit\n\u00b7 Most Significant bit first\n\u00b7 No stop periods between back-to-back bytes\nGeneral purpose Manchester mode is configured with the following settings:\n\u00b7 MODE<3:0> = 1000\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP1 = 0h\n\u00b7 UxBRGH:L = desired baud rate\n\u00b7 TXPOL and RXPOL = desired Idle state\n\u00b7 STP = desired number of stop periods\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 RXPPS = RX pin selection code\n\u00b7 RX pin TRIS control = 1\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 ON = 1\nThe Manchester bit stream timing is shown in Figure 31-7.",
    "31.8 Polarity\nReceive  and  transmit  polarity  is  user  selectable  and affects all modes of operation.\nThe idle level is programmable with the polarity control bits in the UxCON2 register. The control bits default to ' 0 ',  which  select  a  high  idle  level.  The  low  level  Idle state is selected by setting the control bit to ' 1 '. TXPOL controls the TX idle level. RXPOL controls the RX idle level.",
    "31.9 Stop Bits\nThe number of Stop bits is user selectable with the STP bits  in  the  UxCON2  register.The  STP  bits  affect  all modes of operation.\nStop bits selections include:\n\u00b7 1 transmit with receive verify on first\n\u00b7 1.5 transmit with receive verify on first\n\u00b7 2 transmit with receive verify on both\n\u00b7 2 transmit with receive verify on first only\nIn all modes, except DALI, the transmitter is idle for the number of Stop bit periods between each consecutively transmitted word. In DALI, the Stop bits are generated after the last bit in the transmitted data stream.\nThe input is checked for the idle level in the middle of the first Stop bit, when receive verify on first is selected, as well as in the middle of the second Stop bit, when verify  on  both  is  selected.  If  any  Stop  bit  verification indicates a non-idle level, the framing error FERIF bit is set for the received word.",
    "31.9.1 DELAYED UXRXIF\nWhen operating in Half-Duplex mode, where the microcontroller  needs  to  reverse  the  transceiver  direction after a reception, it may be more convenient to hold off the UxRXIF interrupt until the end of the Stop bits to avoid  line  contention.  The  user  selects  when  the UxRXIF  interrupt  occurs  with  the  STPMD  bit  in  the UxFIFO  register.  When  STPMD  is  ' 1 ', the  UxRXIF occurs at the end of the last Stop bit. When STPMD is ' 0 ', UxRXIF occurs when the received byte is stored in the  receive  FIFO.  When  STP<1:0> = 10 , the  store operation is performed in the middle of the second Stop bit, otherwise, it is performed in the middle of the first Stop  bit.  The  FERIF  and  PERIF  interrupts  are  not delayed with STPMD. Only UxRXIF is delayed when STPMD  is  set  and  should  be  the  only  indicator  for reversing transceiver direction.",
    "31.10 Operation after FIFO overflow\nThe Receive Shift Register (RSR) can be configured to stop or continue running during a receive FIFO overflow  condition.  Stopped  operation  is  the  Legacy mode.\nWhen  the  RSR  continues  to  run  during  an  overflow condition,  the  first  word  received  after  clearing  the overflow will always be valid.\nWhen the RSR is stopped during an overflow condition, synchronization with the Start bits is lost. Therefore, the first  word  received  after  the  overflow  is  cleared  may start in the middle of a word.\nOperation during overflow is selected with the RUNOVF  bit  in  the  UxCON2  register.  Setting  the RUNOVF bit selects the run during overflow method.",
    "31.11 Receive and Transmit Buffers\nThe  UART  uses  small  buffer  areas  to  transmit  and receive  data.  These  are  sometimes  referred  to  as FIFOs.\nThe receiver has a Receive Shift Register (RSR) and two buffer registers. The buffer at the top of the FIFO (earliest byte to enter the FIFO) is by retrieved by read -ing the UxRXB register.\nThe transmitter has one Transmit Shift Register (TSR) and  one  buffer  register.  Writes  to  UxTXB  go  to  the transmit  buffer  then  immediately  to  the  TSR,  if  it  is empty. When the TSR is not empty, writes to UxTXB are held then transferred to the TSR when it becomes available.",
    "31.11.1 FIFO STATUS\nThe UxFIFO register contains several Status bits for determining the state of the receive and transmit buf -fers.\nThe RXBE bit indicates that the receive FIFO is empty. This bit is essentially the inverse of UxRXIF. The RXBF bit indicates that the receive FIFO is full.\nThe  transmitter  has  only  one  buffer  register  so  the Status bits are essentially a copy and  inverse of the UxTXIF bit. The TXBE bit indicates that the buffer is empty (same as UxTXIF) and the TXBF bit indicates that the buffer is full (UxTXIF inverse). A third transmit -ter  Status  bit,  TXWRE  (transmit  write  error),  is  set whenever a UxTXB write is performed when the TXBF bit is set. This indicates that the write was unsuccess -ful.",
    "31.11.2 FIFO RESET\nAll  modes support resetting  the receive and  transmit buffers.\nThe receive buffer is flushed and all unread data dis -carded when the RXBE bit in the UxFIFO register is written to ' 1 '. The MOVWF instruction with the TXBE bit cleared should be used to avoid inadvertently clearing a byte pending in the TSR when UxTXB is empty.\nData written to UxTXB when TXEN is low will be held in the  Transmit  Shift  Register  (TSR)  then  sent  when TXEN is set. The transmit buffer and inactive TSR are flushed by setting the TXBE bit in the UxFIFO register. Setting TXBE while a character is actively transmitting from the TSR will  complete  the  transmission  without being flushed.\nClearing the ON bit will discard all received data and transmit data pending in the TSR and UxTXB.",
    "31.12 Flow Control\nThis section does not apply to the LIN, DALI, or DMX modes.\nFlow control is the means by which a sending UART data stream can be suspended by a receiving UART. Flow  control  prevents  input  buffers  from  overflowing without software intervention. The UART supports both hardware and XON/XOFF methods of flow control.\nThe flow control method is selected with the FLO<1:0> bits  in the  UxCON2 register. Flow control is disabled when are both bits are cleared.",
    "31.12.1 HARDWARE FLOW CONTROL\nHardware  flow  control is selected  by setting the FLO<1:0> bits to ' 10 '.\nHardware flow control consists of three lines. The RS232 signal names for two of these are RTS, and CTS. Both are low true. The third line may be used to control an  RS-485  transceiver.  The  signal  name  for  this  is TXDE  for  transmit  drive  enable.  This  output  is  high when the TX output is actively sending a character and low at all other times. The UART is configured as DTE (computer) equipment which means RTS is an output and CTS is an input.\nThe RTS and CTS signals work as a pair to control the transmission flow. A DTE-to-DTE configuration connects the RTS output of the receiving UART to the CTS input of the sending UART. Refer to Figure 31-10.\nThe UART receiving data asserts the RTS output low when the  input  FIFO  is  empty.  When  a  character  is received, the RTS output goes high until the UxRXB is read to free up both FIFO locations.",
    "31.12.1 HARDWARE FLOW CONTROL\nWhen the CTS input goes high after a byte has started to  transmit,  the  transmission  will  complete  normally. The  receiver  accommodates  this  by  accepting  the character in the second FIFO location even when the CTS input is high.",
    "31.12.2 RS-485 TRANSCEIVER CONTROL\nHardware  flow  control  can  be  used  to  control  the direction of an RS-485  transceiver as shown  in Figure 31-11.  Configure  the  CTS  input  to  be  always enabled  by  setting  the  UxCTSPPS  selection  to  an unimplemented port pin such as RD0. When the signal and control lines are configured as shown in Figure 3111, then the UART will not receive its own transmissions. To verify that there are no collisions on the RS-485 lines then the transceiver RE control can be  disconnected  from  TXDE  and  tied  low  thereby enabling loop-back reception of all transmissions. See Section 31.14 'Collision Detection' for more information.",
    "31.12.3 XON/XOFF FLOW CONTROL\nXON/XOFF  flow  control  is  selected  by  setting  the FLO<1:0> bits to ' 01 '.\nXON/XOFF is a data based flow control method. The signals to suspend  and  resume  transmission  are special characters sent by the receiver to the transmitter The advantage is that additional hardware lines are not needed.\nXON/XOFF flow control requires full-duplex operation because the  transmitter  must  be  able  to  receive  the signal to suspend transmitting while the transmission is in progress. Although XON and XOFF are not defined in the ASCII code, the generally accepted values are 13h for XOFF and 11h for XON. The UART uses those codes.\nThe transmitter defaults to XON, or transmitter enabled. This state is also indicated by the read-only XON bit in the UxFIFO register.\nWhen an XOFF character is received, the transmitter stops transmitting after completing the character actively  being  transmitted.  The  transmitter  remains disabled until an XON character is received.\nXON will be forced on when software toggles the TXEN bit.",
    "31.12.3 XON/XOFF FLOW CONTROL\nWhen the RUNOVF bit in the UxCON2 register is set then XON  and  XOFF  characters  continue  to  be received and processed without the need to clear the input  FIFO  by  reading  the  UxRXB.  However,  if  the RUNOVF bit is clear then the UxRXB must be read to avoid  a  receive  overflow  which  will  suspend  flow control when the receive buffer overflows.",
    "31.13 Checksum\nThis  section  does  not  apply  to  the  LIN  mode,  which handles checksums automatically.\nThe transmit and receive checksum adders are enabled when the C0EN bit in the UxCON2 register is set. When enabled, the adders accumulate every byte that is transmitted or received. The accumulated sum includes the carry of the addition. Software is responsible for clearing the checksum registers before a transaction and performing the check at the end of the transaction.\nThe  following  is  an  example  of  how  the  checksum registers could be used in the Asynchronous modes.",
    "31.13.1 TRANSMIT CHECKSUM METHOD\n1. Clear the UxTXCHK register.\n2. Set the C0EN bit.\n3. Send all bytes of the transaction output.\n4. Invert UxTXCHK and send the result as the last byte of the transaction.",
    "31.13.2 RECEIVE CHECKSUM METHOD\n1. Clear the UxRXCHK register.\n2. Set the C0EN bit.\n3. Receive all bytes in the transaction including the checksum byte.\n4. Set MSb of UxRXCHK if 7-bit mode is selected.\n5. Add 1 to UxRXCHK.\n6. If the result is ' 0 ', the checksum  passes, otherwise it fails.\nThe CERIF checksum interrupt flag is not active in any mode other than LIN.",
    "31.14 Collision Detection\nExternal forces that interfere with the transmit line are detected  in all modes  of  operation  with collision detection.  Collision  detection  is  always  active  when RXEN and TXEN are both set.\nWhen the receive input  is  connected  to  the  transmit output  through  either  the  same  I/O  pin  or  external circuitry, a character will be received for every character  transmitted.  The  collision  detection  circuit provides a warning when the word received does not match the word transmitted.\nThe TXCIF  flag  in  the  UxERRIR  register  is  used  to signal collisions. This signal is only useful when the TX output is looped back to the RX input and everything that is transmitted is expected to be received. If more than one transmitter is active at the same time, it can be assumed that the TX word will not match the RX word. The TXCIF detects this mismatch and flags an interrupt. The TXCIF bit will also be set in DALI mode transmissions  when  the  received  bit  is  missing  the expected mid-bit transition.\nCollision  detection  is  always  active,  regardless  of whether  or  not  the  RX  input  is  connected  to  the  TX output. It is up to the user to disable the TXCIE bit when collision interrupts are not required.",
    "31.14 Collision Detection\nThe software overhead of unloading the receive buffer of transmitted data is avoided by setting the RUNOVF bit in UxCON2 and ignoring the receive interrupt and letting the receive buffer overflow. When the transmis -sion is complete, prepare for receiving data by flushing the  receive  buffer  (see  Section 31.11.2,  FIFO  Reset) and clearing the RXFOIF overflow flag in the UxERRIR register.",
    "31.15 RX/TX Activity Timeout\nThe UART works in conjunction with the HLT timers to monitor  activity  on  the  RX  and  TX  lines.  Use  this feature to determine when there has been no activity on  the  receive  or  transmit  lines  for  a  user  specified period of time.\nTo use this feature, set the HLT to the desired timeout period by a combination of the HLT clock source, timer prescale value, and timer period registers. Configure the HLT to reset on the UART TX or RX line and start the HLT at the same time the UART is started. UART activity will keep resetting the HLT to prevent a full HLT period from elapsing. When there has been no activity on the selected TX or RX line for longer than the HLT period  then  an  HLT  interrupt  will  occur  signaling  the timeout event.\nFor example, the following register settings will configure  HLT2  for  a  5  ms  timeout  of  no  activity  on U1RX:",
    "31.15 RX/TX Activity Timeout\n\u00b7 T2PR = 0x9C (156 prescale periods)\n\u00b7 T2CLKCON = 0x05 (500 kHz internal oscillator)\n\u00b7 T2HLT = 0x04 (free running, reset on rising edge)\n\u00b7 T2RST = 0x15 (reset on U1RX)\n\u00b7 T2CON = 0xC0 (Timer2 on with 1:16 prescale)",
    "31.16 Clock Accuracy with Asynchronous Operation\nThe  factory  calibrates  the  internal  oscillator  block output  (INTOSC).  However,  the  INTOSC  frequency may  drift  as  VDD  or  temperature  changes,  and  this directly affects the asynchronous  baud  rate.  Two methods may be used to adjust the baud rate clock, but both require a reference clock source of some kind.\nThe  first (preferred) method  uses  the OSCTUNE register  to  adjust  the  INTOSC  output.  Adjusting  the value of the OSCTUNE register allows for fine resolution changes  to  the  system  clock  source.  See Section 7.2.2.3 'Internal Oscillator Frequency Adjustment' for more information.\nThe other method adjusts the value of the Baud Rate Generator.  This  can  be  done  automatically  with  the Auto-Baud Detect feature (see Section 31.17.1 'Auto-Baud Detect' ). There may not be fine enough  resolution  when  adjusting  the  Baud  Rate Generator to compensate for a gradual change of the peripheral clock frequency.",
    "31.17 UART Baud Rate Generator (BRG)\nThe Baud Rate Generator (BRG) is a 16-bit timer that is dedicated to the support of the UART operation.\nThe  UxBRGH,  UxBRGL  register  pair  determines  the period of the free running baud rate timer. The multiplier of the baud rate period is determined by the BRGS bit in the UxCON0 register.\nTable 31-1  contains  the  formulas  for  determining  the baud rate. Example 31-1 provides a sample calculation for determining the baud rate and baud rate error.\nThe high baud rate range (BRGS = 1 ) is intended to extend the baud rate range up to a faster rate when the desired baud rate is not possible otherwise. Using the normal baud rate range (BRGS = 0 ) is recommended when the desired baud rate is achievable with either range.\nWriting a new value to the UxBRGH, UxBRGL register pair causes the BRG timer to be reset (or cleared). This ensures that the BRG does not wait for a timer overflow before outputting the new baud rate.",
    "31.17 UART Baud Rate Generator (BRG)\nIf the system clock is changed during an active receive operation, a receive error or data loss may result. To avoid this problem, check the status of the RXIDL bit to make  sure  that  the  receive  operation  is  idle  before changing the system clock.",
    "EXAMPLE 31-1: CALCULATING BAUD RATE ERROR\nFor a device with FOSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, BRGS = 0 :\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "TABLE 31-1: BAUD RATE FORMULAS\n1, BRG/UART Mode = High Rate. 1, Baud Rate Formula = FOSC/[4 (n+1)]. 0, BRG/UART Mode = Normal Rate. 0, Baud Rate Formula = FOSC/[16(n+1)]\nLegend:\nn = value of UxBRGH, UxBRGL register pair.",
    "31.17.1 A UTO-BAUD DETECT\nThe UART module supports automatic detection and calibration of the baud rate in the 8-bit Asynchronous and LIN modes. However, setting ABDEN to start autobaud detection is neither necessary, nor possible in LIN mode because that mode supports auto-baud detec -tion automatically  at  the  beginning  of  every  data packet. Enabling auto-baud detect with the ABDEN bit applies to the Asynchronous modes only.\nWhen Auto-Baud Detect (ABD) is active, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RX signal, the RX signal is timing the BRG. The Baud Rate Generator is used to time the period of a received 55h (ASCII 'U'), which is the Sync character for the LIN bus. The unique feature of this character is that it has five falling edges, including the Start bit edge, five rising edges including the Stop bit edge.\nRXIDL indicates that the sync input is active. RXIDL will go low on the first falling edge and go high on the fifth rising edge.",
    "31.17.1 A UTO-BAUD DETECT\nThe BRG auto-baud clock is determined by the BRGS bit  as  shown  in  Table 31-2.  During ABD,  the  internal BRG register is used as a 16-bit counter. However, the UxBRGH and  UxBRGL  registers  retain  the  previous BRG value until the auto-baud process is successfully completed. While calibrating the baud rate period, the internal BRG register is clocked at 1/8th the BRG base clock  rate.  The  resulting  byte  measurement  is  the average  bit  time  when  clocked  at  full  speed  and  is transferred  to  the  UxBRGH  and  UxBRGL  registers when complete.",
    "31.17.1 A UTO-BAUD DETECT\nIn 8-bit Asynchronous mode, setting the ABDEN bit in the UxCON0 register enables the auto-baud calibration sequence. The first falling edge of the RX input after ABDEN  is  set  will  start  the  auto-baud  calibration sequence. While the ABD sequence takes place, the UART state machine is held in idle. On the first falling edge of the receive line, the UxBRG begins counting up using the BRG counter clock as shown in Figure 31-12. The fifth  falling  edge  will  occur  on  the  RX  pin  at  the beginning of the bit 7 period.  At that time, an accumulated value totaling the proper BRG period is left in the UxBRGH, UxBRGL register pair, the ABDEN bit is automatically cleared and the ABDIF interrupt flag is set. ABDIF must be cleared by software.",
    "31.17.1 A UTO-BAUD DETECT\nNote 1: If the WUE bit is set with the ABDEN bit, auto-baud detection will occur on the byte following the Break character (see Sec -tion 31.17.3 'Auto-Wake-up on Break' ).\n2: It  is  up  to  the  user  to  determine  that  the incoming character baud rate is within the range of the selected BRG clock source. Some combinations of oscillator frequency and UART baud rates are not possible.",
    "TABLE 31-2: BRG COUNTER CLOCK RATES\n1, BRG Base Clock = FOSC/4. 1, BRGABD Clock = FOSC/32. 0, BRG Base Clock = FOSC/16. 0, BRGABD Clock = FOSC/128",
    "FIGURE 31-12: AUTOMATIC BAUD RATE CALIBRATION\nBRG Value, 1 = XXXXh. BRG Value, 2 = 0000h 001Ch. RX pin, 1 = . RX pin, 2 = bit 0 bit 1 Start Edge #1 bit 2 bit 3 Edge #2 bit 4 bit 5 Edge #3 bit 6 bit 7 Edge #4 Stop bit Edge #5. BRG Clock, 1 = BRG Clock. BRG Clock, 2 = BRG Clock. ABDEN bit, 1 = Set by User in 8-bit mode. ABDEN bit, 2 = Auto Cleared. RXIDL, 1 = . RXIDL, 2 = . ABDIF bit (Interrupt), 1 = . ABDIF bit (Interrupt), 2 = Cleared by software. UxBRG, 1 = . UxBRG, 2 = XXXXh 001Ch. Note 1: Auto-baud is supported in LIN and, 1 = 8-bit Asynchronous modes only.. Note 1: Auto-baud is supported in LIN and, 2 = 8-bit Asynchronous modes only.",
    "31.17.2 AUTO-BAUD OVERFLOW\nDuring  the  course  of  automatic  baud  detection,  the ABDOVF bit in the UxERRIR register will be set if the baud rate counter overflows before the fifth falling edge is detected on the RX pin. The ABDOVF bit indicates that the counter has exceeded the maximum count that can fit in the 16 bits of the UxBRGH:UxBRGL register pair.  After  the  ABDOVF  bit  has  been  set,  the  state machine continues to search until the fifth falling edge is  detected  on  the  RX  pin.  Upon  detecting  the  fifth falling RX  edge,  the  hardware  will  set  the  ABDIF interrupt flag and clear the ABDEN bit in the UxCON0 register.  The  UxBRGH  and  UxBRGL  register  values retain  their  previous  value.  The  ABDIF  flag  in  the UxUIR  register  and  ABDOVF  flag  in  the  UxERRIR register can be cleared by software directly. To generate an interrupt on an auto-baud overflow condition, all the following bits must be set:",
    "31.17.2 AUTO-BAUD OVERFLOW\n\u00b7 ABDOVE bit in the UxERRIE register\n\u00b7 UxEIE bit in the PIEx register\n\u00b7 PIE and GIE bits in the INTCON register\nTo terminate the auto-baud process before the ABDIF flag is set, clear the ABDEN bit, then clear the ABDOVF bit in the UxERRIR register.",
    "31.17.3 AUTO-WAKE-UP ON BREAK\nDuring  Sleep  mode,  all  clocks  to  the  UART  are suspended. Because of this, the Baud Rate Generator is inactive and a proper character reception cannot be performed. The  Auto-Wake-up feature allows the controller to wake-up due to activity on the RX line.\nThe Auto-Wake-up feature is enabled by setting both the WUE bit in the UxCON1 register and the UxIE bit in the PIEx register. Once set, the normal receive sequence on RX is disabled, and the UART remains in an Idle state, monitoring for a wake-up event independent of the CPU mode. A wake-up event consists of a transition out of the Idle state on the RX line. (This coincides with the start of a  Break  or  a  wake-up  signal  character  for  the  LIN protocol.)",
    "31.17.3 AUTO-WAKE-UP ON BREAK\nThe UART module generates a WUIF interrupt coincident  with  the  wake-up  event.  The  interrupt  is generated synchronously to the Q clocks in normal CPU operating modes (Figure 31-13), and asynchronously, if the device is in Sleep  mode  (Figure 31-14).  The interrupt condition is cleared by clearing the WUIF bit in the UxUIR register. To generate an interrupt on a wakeup event, all the following bits must be set:\n\u00b7 UxIE bit in the PIEx register\n\u00b7 PIE and GIE bits in the INTCON register\nThe WUE bit is automatically cleared by the transition to the Idle state on the RX line at the end of the Break. This signals to the user that the Break event is over. At this point, the UART module is in Idle mode, waiting to receive the next character.",
    "Break Character\nTo avoid character errors or character fragments during a wake-up event, the wake-up character must be all zeros.\nWhen  the  wake-up  is  enabled,  the  function  works independent of the low time on the data stream. If the WUE  bit  is  set  and  a  valid  non-zero  character  is received, the low time from the Start bit to the first rising edge  will  be  interpreted  as  the  wake-up  event.  The remaining bits  of  the  character  will  be  received  as  a fragmented character and subsequent characters can result in framing or overrun errors.\nTherefore, the initial character of the transmission must be all zeros. This must be eleven or more bit times, 13bit times recommended for LIN bus, or any number of bit times for standard RS-232 devices.",
    "Oscillator Start-up Time\nOscillator start-up time must be considered, especially in  applications  using  oscillators  with  longer  start-up intervals  (i.e.,  LP,  XT  or  HS/PLL  modes).  The  Sync Break  (or wake-up  signal) character must  be  of sufficient length, and  be  followed by  a sufficient interval, to allow enough time for the selected oscillator to start and provide proper initialization of the UART.",
    "WUE Bit\nTo ensure that no actual data is lost, check the RXIDL bit to verify that a receive operation is not in process before setting the WUE bit. If a receive operation is not occurring, the  WUE bit may then be set just prior to entering the Sleep mode.",
    "FIGURE 31-14: AUTO-WAKE-UP BIT (WUE) TIMINGS DURING SLEEP\nNote 1: If the wake-up event requires long oscillator warm-up time, the automatic clearing of the WUE bit can occur while the stposc signal is still active. This sequence should not depend on the presence of Q clocks.\n- 2: The UART remains in Idle while the WUE bit is set.",
    "31.18 Transmitting a Break\nThe UART module has the capability of sending either a fixed length Break period or a software timed Break period. The fixed length Break consists of a Start bit, followed  by  12  ' 0 '  bits  and  a  Stop  bit.  The  software timed Break is generated by setting and clearing the BRKOVR bit in the UxCON1 register.\nTo  send  the  fixed  length  Break,  set  the  SENDB  and TXEN  bits in the UxCON0  register. The Break sequence is then initiated  by  a  write  to  UxTXB. The timed Break will occur first, followed by the character written to UxTXB that initiated the Break. The initiating character  is  typically  the  Sync  character  of  the  LIN specification.\nSENB is disabled in the LIN and DMX modes because those modes generate the Break sequence automatically.\nThe SENDB bit is automatically reset by hardware after the Break Stop bit is complete.\nThe TXMTIF bit in the UxERRIR register indicates when the transmit operation is active or idle, just as it does during  normal  transmission.  See  Figure 31-15  for  the timing of the Break sequence.",
    "31.19 Receiving a Break\nThe UART has counters to detect when the RX input remains in the space state for an extended period of time.  When  this  happens,  the  RXBKIF  bit  in  the UxERRIR register is set.\nA Break is detected when the RX input remains in the space state for 11 bit periods for Asynchronous and LIN modes, and 23 bit periods for DMX mode.\nThe user can select to receive the Break interrupt as soon  as  the  Break  is  detected  or  at  the  end  of  the Break,  when  the  RX  input  returns  to  the  Idle  state. When  the  RXBIMD  bit  in  the  UxCON1  is  ' 1 ' then RXBKIF  is  set  immediately  upon  Break  detection. When RXBIMD is ' 0 ' then RXBKIF is set when the RX input returns to the Idle state.",
    "31.20 UART Operation During Sleep\nThe UART ceases to operate during Sleep. The safe way  to  wake  the  device  from  Sleep  by  a  serial operation is to use the Wake-on-Break feature of the UART. See Section 31.17.3, Auto-Wake-up on Break",
    "31.21 Register Definitions: UART Control\nLong bit name prefixes for the UART peripherals are shown below. Refer to Section 1.3 'Register and Bit naming conventions' for more information.\nUART 1, Bit Name Prefix = U1. UART 2, Bit Name Prefix = U2",
    "REGISTER 31-1: UxCON0: UART CONTROL REGISTER 0\nBRGS, R/W/HS/HC-0/0 = ABDEN. BRGS, R/W-0/0 = TXEN. BRGS, R/W-0/0 = RXEN. BRGS, R/W-0/0 = . BRGS, R/W-0/0 = MODE<3:0>. BRGS, R/W-0/0 = . BRGS, R/W-0/0 = . bit 7, R/W/HS/HC-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 31-1: UxCON0: UART CONTROL REGISTER 0\nu = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HC = Hardware clear\nbit 7\nBRGS: Baud rate Generator Speed Select bit\n1 = Baud rate generator is high speed with 4 baud clocks per bit\n0 = Baud rate generator is normal speed with 16 baud clocks per bit\nABDEN: Auto-baud Detect Enable bit (3)\n1 = Auto-baud is enabled. Receiver is waiting for Sync character (0x55)\n0 = Auto-baud is not enabled or auto-baud is complete\nTXEN: Transmit Enable Control bit (2)\n1 = Transmit is enabled. TX output pin drive is forced on when transmission is active, and controlled by PORT TRIS control when transmission is idle.\n0 = Transmit is disabled. TX output pin drive is controlled by PORT TRIS control\n(2)",
    "bit 4 RXEN: Receive Enable Control bit\n1 = Receiver is enabled\n0 = Receiver is disabled",
    "bit 3-0 MODE<3:0>: UART Mode Select bits\n1111\n=\nReserved\n1110 = Reserved\n1101 = Reserved\n- 1100 = LIN Master/Slave mode\n1011 = LIN Slave-Only mode\n1010 = DMX mode\n1001 = DALI Control Gear mode\n1000 = DALI Control Device mode\n0111 = Reserved\n0110 = Reserved\n0101 = Reserved\n0100 = Asynchronous 9-bit UART Address mode. 9th bit: 1 = address, 0 = data\n0011 = Asynchronous 8-bit UART mode with 9th bit even parity\n0010 = Asynchronous 8-bit UART mode with 9th bit odd parity\n0001 = Asynchronous 7-bit UART mode\n0000 = Asynchronous 8-bit UART mode\nNote 1: Changing the UART MODE while ON = 1 may cause unexpected results.\n2: Clearing TXEN or RXEN will not clear the corresponding buffers. Use TXBE or RXBE to clear the buffers.\n3: ABDEN is read-only when MODE = 1001 . When MODE = 100x and ABDEN = 1 , then auto-baud is determined from Start bit.\nbit 6\nbit 5",
    "bit 3-0 MODE<3:0>: UART Mode Select bits\n(1)",
    "REGISTER 31-2: UxCON1: UART CONTROL REGISTER 1\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = U-0. R/W-0/0, 3 = R/W/HC-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = U-0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W/HC-0/0. ON, 1 = -. ON, 2 = -. ON, 3 = WUE. ON, 4 = RXBIMD. ON, 5 = -. ON, 6 = BRKOVR. ON, 7 = SENDB. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 31-2: UxCON1: UART CONTROL REGISTER 1\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = HC = Hardware clear",
    "bit 7\nON: Serial Port Enable bit\n1 = Serial port enabled\n0 = Serial port disabled (held in Reset)\nbit 6-5 Unimplemented: Read as ' 0 '",
    "bit 4\nWUE: Wake-up Enable bit\n1 = Receiver is waiting for falling RX input edge which will set the UxIF bit. Cleared by hardware on wake event. Also requires UxIE bit of PIEx to enable wake\n0 = Receiver operates normally\nbit 3\nRXBIMD: Receive Break Interrupt Mode Select bit\n1 = Set RXBKIF immediately when RX in has been low for the minimum Break time\n0 = Set RXBKIF on rising RX input after RX in has been low for the minimum Break time",
    "bit 1 BRKOVR: Send Break Software Override bit\n1 = TX output is forced to non-idle state\n0 = TX output is driven by transmit shift register",
    "bit 0\nSENDB: Send Break Control bit (1)\n1 = Output Break upon UxTXB write. Written byte follows Break. Bit is cleared by hardware.\n0 = Break transmission completed or disabled",
    "REGISTER 31-3:\nUxCON2: UART CONTROL REGISTER 2",
    "REGISTER 31-3:\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. RUNOVF, 1 = RXPOL. RUNOVF, 2 = STP<1:0>. RUNOVF, 3 = STP<1:0>. RUNOVF, 4 = C0EN. RUNOVF, 5 = TXPOL. RUNOVF, 6 = FLO<1:0>. RUNOVF, 7 = FLO<1:0>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit",
    "REGISTER 31-3:\n0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7 RUNOVF: Run During Overflow Control bit\n1 = RX input shifter continues to synchronize with Start bits after overflow condition\n0 = RX input shifter stops all activity on receiver overflow condition",
    "bit 6\nRXPOL : Receive Polarity Control bit\n1 = Invert RX polarity, Idle state is low\n0 = RX polarity is not inverted, Idle state is high",
    "bit 5-4\nSTP<1:0>: Stop Bit Mode Control bits (1)\n11 = Transmit 2 Stop bits, receiver verifies first Stop bit\n10 = Transmit 2 Stop bits, receiver verifies first and second Stop bits\n01 = Transmit 1.5 Stop bits, receiver verifies first Stop bit\n00 = Transmit 1 Stop bit, receiver verifies first Stop bit\nbit 3\nC0EN\n: Checksum Mode Select bit\nLIN mode:\n1 = Checksum Mode 1, enhanced LIN checksum includes PID in sum\n0 = Checksum Mode 0, legacy LIN checksum does not include PID in sum",
    "Other modes:\n1 = Add all TX and RX characters\n0 = Checksums disabled",
    "bit 2 TXPOL: Transmit Polarity Control bit\n1 = Output data is inverted, TX output is low in Idle state\n0 = Output data is not inverted, TX output is high in Idle state",
    "bit 1-0 FLO<1:0>: Handshake Flow Control bits\n11 = Reserved\n10 = RTS/CTS and TXDE Hardware flow control\n01 = XON/XOFF Software flow control\n00 = Flow control is off\nNote 1: All modes transmit selected number of Stop bits. Only DMX and DALI receivers verify selected number of Stop bits and all others verify only the first Stop bit.",
    "REGISTER 31-4: UxERRIR: UART ERROR INTERRUPT FLAG REGISTER\nR/S/C-1/1, 1 = R/S/C-0/0. R/S/C-1/1, 2 = R/W/S-0/0. R/S/C-1/1, 3 = R/W/S-0/0. R/S/C-1/1, 4 = R/S/C-0/0. R/S/C-1/1, 5 = R/W/S-0/0. R/S/C-1/1, 6 = R/W/S-0/0. R/S/C-1/1, 7 = R/W/S-0/0. TXMTIF, 1 = PERIF. TXMTIF, 2 = ABDOVF. TXMTIF, 3 = CERIF. TXMTIF, 4 = FERIF. TXMTIF, 5 = RXBKIF. TXMTIF, 6 = RXFOIF. TXMTIF, 7 = TXCIF. bit 7, 1 = bit 7. bit 7, 2 =",
    "REGISTER 31-4: UxERRIR: UART ERROR INTERRUPT FLAG REGISTER\nbit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 31-4: UxERRIR: UART ERROR INTERRUPT FLAG REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged, 3 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = S = Hardware set. '1' = Bit is set, 3 = C = Hardware clear",
    "bit 7 TXMTIF: Transmit Shift Register Empty Interrupt Flag bit\n1 = Transmit shift register is empty (Set at end of Stop bits)\n- 0 = Transmit shift register is actively shifting data",
    "bit 6\nPERIF : Parity Error Interrupt Flag bit",
    "LIN and Parity modes:\n1 = Unread byte at top of input FIFO has parity error\n0 = Unread byte at top of input FIFO does not have parity error",
    "DALI Device mode:\n1 = Unread byte at top of input FIFO received as Forward Frame\n0 = Unread byte at top of input FIFO received as Back Frame",
    "Address mode:\n- 1 = Unread byte at top of input FIFO received as address\n0 = Unread byte at top of input FIFO received as data",
    "Other modes:\nNot used bit 5\nABDOVF: Auto-Baud Detect Overflow Interrupt Flag bit",
    "DALI mode:\n1 = Start bit measurement overflowed counter\n0 = No overflow during Start bit measurement",
    "Other modes:\n1 = Baud rate generator overflowed during the auto detection sequence\n0 = Baud rate generator has not overflowed\nbit 4\nCERIF : Checksum Error Interrupt Flag bit (LIN mode only)\n1 = Checksum error\n0 = No checksum error\nbit 3\nFERIF: Framing Error Interrupt Flag bit\n1 = Unread byte at top of input FIFO has framing error\n0 = Unread byte at top of input FIFO does not have framing error",
    "RXBKIF: Break Reception Interrupt Flag bit\n1 = Break detected\n0 = No Break detected",
    "bit 1\nRXFOIF: Receive FIFO Overflow Interrupt Flag bit\n1 = Receive FIFO has overflowed\n0 = Receive FIFO has not overflowed",
    "bit 0\nTXCIF: Transmit Collision Interrupt Flag bit\n1 = Transmitted word is not equal to the word received during transmission\n0 = Transmitted word equals the word received during transmission",
    "REGISTER 31-5: UxERRIE: UART ERROR INTERRUPT ENABLE REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. TXMTIE, 1 = PERIE. TXMTIE, 2 = ABDOVE. TXMTIE, 3 = CERIE. TXMTIE, 4 = FERIE. TXMTIE, 5 = RXBKIE. TXMTIE, 6 = RXFOIE. TXMTIE, 7 = TXCIE. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit",
    "REGISTER 31-5: UxERRIE: UART ERROR INTERRUPT ENABLE REGISTER\n7. bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7\nTXMTIE: Transmit Shift Register Empty Interrupt Enable bit\n1 = Interrupt enabled\n0 = Interrupt not enabled\nbit 6\nPERIE : Parity Error Interrupt Enable bit\n1 = Interrupt enabled\n0 = Interrupt not enabled\nbit 5\nABDOVE: Auto-Baud Detect Overflow Interrupt Enable bit\n1 = Interrupt enabled\n0 = Interrupt not enabled\nbit 4\nCERIE : Checksum Error Interrupt Enable bit\n1 = Interrupt enabled\n0 = Interrupt not enabled\nbit 3\nFERIE: Framing Error Interrupt Enable bit\n1 = Interrupt enabled\n0 = Interrupt not enabled\nbit 2\nRXBKIE: Break Reception Interrupt Enable bit\n1 = Interrupt enabled",
    "REGISTER 31-5: UxERRIE: UART ERROR INTERRUPT ENABLE REGISTER\n0 = Interrupt not enabled\nbit 1\nRXFOIE: Receive FIFO Overflow Interrupt Enable bit\n1 = Interrupt enabled\n0 = Interrupt not enabled\nbit 0\nTXCIE: Transmit Collision Interrupt Enable bit\n1 = Interrupt enabled\n0 = Interrupt not enabled",
    "REGISTER 31-6: UxUIR: UART GENERAL INTERRUPT REGISTER\nR/S/W-0/0, 1 = R/S/W-0/0. R/S/W-0/0, 2 = U-0. R/S/W-0/0, 3 = U-0. R/S/W-0/0, 4 = U-0. R/S/W-0/0, 5 = R/W-0/0. R/S/W-0/0, 6 = U-0. R/S/W-0/0, 7 = U-0. WUIF, 1 = ABDIF. WUIF, 2 = -. WUIF, 3 = -. WUIF, 4 = -. WUIF, 5 = ABDIE. WUIF, 6 = -. WUIF, 7 = -. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nS = Hardware set",
    "bit 7 WUIF: Wake-up Interrupt bit\n1 = Idle to non-idle transition on RX line detected when WUE is set. Also sets UxIF. (WUIF must be cleared by software to clear UxIF)\n0 = WUE not enabled by software or no transition detected",
    "bit 6\nABDIF : Auto-Baud detect interrupt bit\n1 = Auto-baud detection complete. Status shown in UxIF when ABDIE is set. (Must be cleared by software)\n0 = Auto-baud not enabled or auto-baud enabled and auto-baud detection not complete",
    "bit 5-3\nUnimplemented: Read as ' 0 '\nbit 2\nABDIE: Auto-Baud Detect Interrupt Enable bit\n1 = ABDIF will set UxIF bit in PIRx register\n0 = ABDIF will not set UxIF\nbit 1-0\nUnimplemented: Read as ' 0 '",
    "REGISTER 31-7: UxFIFO: UART FIFO STATUS REGISTER\nR/W/S-0/0, 1 = R/W-0/0. R/W/S-0/0, 2 = R/W/S/C-1/1. R/W/S-0/0, 3 = R/S/C-0/0. R/W/S-0/0, 4 = R/S/C-1/1. R/W/S-0/0, 5 = S/C-1/1. R/W/S-0/0, 6 = R/W/S/C-1/1. R/W/S-0/0, 7 = R/S/C-0/0. TXWRE, 1 = STPMD. TXWRE, 2 = TXBE. TXWRE, 3 = TXBF. TXWRE, 4 = RXIDL. TXWRE, 5 = XON. TXWRE, 6 = RXBE. TXWRE, 7 = RXBF. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7,",
    "REGISTER 31-7: UxFIFO: UART FIFO STATUS REGISTER\n3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged, 3 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = S = Hardware set. '1' = Bit is set, 3 = C = Hardware clear",
    "bit 7 TXWRE: Transmit Write Error Status bit (Must be cleared by software)\nLIN Master mode:\n1 = UxP1L was written when a master process was active",
    "LIN Slave mode:\n1 = UxTXB was written when UxP2 = 0 or more than UxP2 bytes have been written to UxTXB since last Break",
    "Address Detect mode:\n1 = UxP1L was written before the previous data in UxP1L was transferred to TX shifter",
    "All modes:\n1 = A new byte was written to UxTXB when the output FIFO was full\n0 = No error",
    "bit 6\nSTPMD : Stop Bit Detection Mode bit\n1 = Assert UxRXIF at end of last Stop bit or end of first Stop bit when STP = 11\n0 = Assert UxRXIF in middle of first Stop bit",
    "bit 5 TXBE: Transmit Buffer Empty Status bit\n1 = Transmit buffer is empty. Setting this bit will clear the transmit buffer and output shift register.\n0 = Transmit buffer is not empty. Software cannot clear this bit.",
    "bit 4 TXBF\n: Transmit Buffer Full Status bit\n1 = Transmit buffer is full\n0 = Transmit buffer is not full",
    "bit 3\nRXIDL: Receive Pin Idle Status bit\n1 = Receive pin is in Idle state\n0 = UART is receiving Start, Stop, Data, Auto-baud, or Break",
    "bit 2\nXON: Software Flow Control Transmit Enable Status bit\n1 = Transmitter is enabled\n0 = Transmitter is disabled",
    "bit 1\nRXBE: Receive Buffer Empty Status bit\n1 = Receive buffer is empty. Setting this bit will clear the RX buffer (1)\n0 = Receive buffer is not empty. Software cannot clear this bit.",
    "bit 0\nRXBF: Receive Buffer Full Status bit\n1 = Receive buffer is full\n0 = Receive buffer is not full\nNote 1: The BSF instruction should not be used to set RXBE because doing so will clear a byte pending in the transmit shift register when the UxTXB register is empty. Instead, use the MOVWF instruction with a ' 0 ' in the TXBE bit location.",
    "REGISTER 31-8: UxBRGL: UART BAUD RATE GENERATOR LOW REGISTER\nbit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0",
    "REGISTER 31-8: UxBRGL: UART BAUD RATE GENERATOR LOW REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = \nbit 7-0 BRG<7:0>: Least Significant Byte of Baud Rate Generator",
    "REGISTER 31-9: UxBRGH: UART BAUD RATE GENERATOR HIGH REGISTER\nbit 7, R/W-0/0.BRG<15:8> = . bit 7, R/W-0/0.BRG<15:8> = . bit 7, R/W-0/0.BRG<15:8> = . bit 7, R/W-0/0.BRG<15:8> = . bit 7, R/W-0/0.BRG<15:8> = . bit 7, R/W-0/0.BRG<15:8> = . bit 7, R/W-0/0.BRG<15:8> = bit 0",
    "REGISTER 31-9: UxBRGH: UART BAUD RATE GENERATOR HIGH REGISTER\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = Resets. u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = \nbit 7-0\nBRG<15:8>: Most Significant Byte of Baud Rate Generator\nNote 1: The UxBRG registers should only be written when ON = 0\n.\n2: Maximum BRG value when MODE = ' 100x ' and BRGS = 1 is 0x7FFE.",
    "REGISTER 31-9: UxBRGH: UART BAUD RATE GENERATOR HIGH REGISTER\n3: Maximum BRG value when MODE = ' 100x ' and BRGS = 0 is 0x1FFE.",
    "REGISTER 31-10: UxRXB: UART RECEIVE REGISTER\nR-0/0, 1 = R-0/0. R-0/0, 2 = R-0/0. R-0/0, 3 = R-0/0. R-0/0, 4 = R-0/0. R-0/0, 5 = R-0/0. R-0/0, 6 = R-0/0. R-0/0, 7 = R-0/0. , 1 = RXB<7:0>. , 2 = RXB<7:0>. , 3 = RXB<7:0>. , 4 = RXB<7:0>. , 5 = . , 6 = . , 7 = . bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 31-10: UxRXB: UART RECEIVE REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-0\nRXB<7:0>: Top of Receive Buffer",
    "REGISTER 31-11: UxTXB: UART TRANSMIT REGISTER\nbit 7, R/W-0/0.TXB<7:0> = . bit 7, R/W-0/0.TXB<7:0> = . bit 7, R/W-0/0.TXB<7:0> = . bit 7, R/W-0/0.TXB<7:0> = . bit 7, R/W-0/0.TXB<7:0> = . bit 7, R/W-0/0.TXB<7:0> = . bit 7, R/W-0/0.TXB<7:0> = bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "REGISTER 31-11: UxTXB: UART TRANSMIT REGISTER\nbit 7-0 TXB<7:0>: Bottom of Transmit Buffer",
    "REGISTER 31-12: UxP1H: UART PARAMETER 1 HIGH REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = P1<8>. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 0\nP1<8>: Most Significant Bit of Parameter 1\nDMX mode:\nMost Significant bit of number of bytes to transmit between Start Code and automatic Break generation\nDALI Control Device mode:\nMost Significant bit of idle time delay after which a Forward Frame is sent. Measured in half-bit periods\nDALI Control Gear mode:\nMost Significant bit of delay between the end of a Forward Frame and the start of the Back Frame Measured in half-bit periods\nOther modes:\nNot used",
    "REGISTER 31-13: UxP1L: UART PARAMETER 1 LOW REGISTER\nbit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0.P1<7:0> = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-0\nP1<7:0>: Least Significant Bits of Parameter 1\nDMX mode:\nLeast  Significant  Byte  of  number  of  bytes  to  transmit  between  Start  Code  and  automatic  Break generation",
    "REGISTER 31-13: UxP1L: UART PARAMETER 1 LOW REGISTER\nDALI Control Device mode:\nLeast Significant Byte of idle time delay after which a Forward Frame is sent. Measured in half-bit periods\nDALI Control Gear mode:\nLeast Significant Byte of delay between the end of a Forward Frame and the start of the Back Frame Measured in half-bit periods\nLIN mode:\nPID to transmit (Only Least Significant 6 bits used)\nAsynchronous Address mode:\nAddress to transmit (9th transmit bit automatically set to ' 1 ')\nOther modes:\nNot used",
    "REGISTER 31-14: UxP2H: UART PARAMETER 2 HIGH REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = P2<8>. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 0\nP2<8>: Most Significant Bit of Parameter 2\nDMX mode:\nMost Significant bit of first address of receive block\nDALI mode:\nMost Significant bit of number of half-bit periods of idle time in Forward Frame detection threshold\nOther modes:\nNot used",
    "REGISTER 31-15: UxP2L: UART PARAMETER 2 LOW REGISTER\nbit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0.P2<7:0> = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, = Unimplemented bit, read as '0' = U -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = ",
    "bit 7-0 P2<7:0>: Least Significant Bits of Parameter 2\nDMX mode:\nLeast Significant Byte of first address of receive block\nLIN Slave mode:\nNumber of data bytes to transmit\nDALI mode:\nLeast Significant Byte of number of half-bit periods of idle time in Forward Frame detection threshold\nAsynchronous Address mode:\nReceiver address\nOther modes:\nNot used",
    "REGISTER 31-16: UxP3H: UART PARAMETER 3 HIGH REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = P3<8>. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 0\nP3<8>: Most Significant Bit of Parameter 3\nDMX mode:\nMost Significant bit of last address of receive block\nOther modes:\nNot used",
    "REGISTER 31-17: UxP3L: UART PARAMETER 3 LOW REGISTER\nbit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0.P3<7:0> = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7-0\nP3<7:0>: Least Significant Bits of Parameter 3\nDMX mode:\nLeast Significant Byte of last address of receive block\nLIN Slave mode:\nNumber of data bytes to receive\nAsynchronous Address mode:\nReceiver address mask. Received address is XOR'd with UxP2L then AND'd with UxP3L Match occurs when result is zero\nOther modes:\nNot used",
    "REGISTER 31-18: UxTXCHK: UART TRANSMIT CHECKSUM RESULT REGISTER\nbit 7, R/W-0/0.TXCHK<7:0> = . bit 7, R/W-0/0.TXCHK<7:0> = . bit 7, R/W-0/0.TXCHK<7:0> = . bit 7, R/W-0/0.TXCHK<7:0> = . bit 7, R/W-0/0.TXCHK<7:0> = . bit 7, R/W-0/0.TXCHK<7:0> = . bit 7, R/W-0/0.TXCHK<7:0> = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7-0 TXCHK<7:0>: Checksum calculated from TX bytes\nLIN mode and C0EN = 1 :\nSum of all transmitted bytes including PID\nLIN mode and C0EN = 0 :\nSum of all transmitted bytes except PID\nAll other modes and C0EN = 1 :\nSum of all transmitted bytes since last clear\nAll other modes and C0EN = 0 :\nNot used",
    "REGISTER 31-19: UxRXCHK: UART RECEIVE CHECKSUM RESULT REGISTER\nbit 7, R/W-0/0.RXCHK<7:0> = . bit 7, R/W-0/0.RXCHK<7:0> = . bit 7, R/W-0/0.RXCHK<7:0> = . bit 7, R/W-0/0.RXCHK<7:0> = . bit 7, R/W-0/0.RXCHK<7:0> = . bit 7, R/W-0/0.RXCHK<7:0> = . bit 7, R/W-0/0.RXCHK<7:0> = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7-0\nRXCHK<7:0>: Checksum calculated from RX bytes\nLIN mode and C0EN = 1 :\nSum of all received bytes including PID\nLIN mode and C0EN = 0 :\nSum of all received bytes except PID\nAll other modes and C0EN = 1 :\nSum of all received bytes since last clear\nAll other modes and C0EN = 0 :\nNot used",
    "TABLE 31-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE UART\nUxCON0, Bit 7 = BRGS. UxCON0, Bit 6 = ABDEN. UxCON0, Bit 5 = TXEN. UxCON0, Bit 4 = RXEN. UxCON0, Bit 3 = MODE<3:0>. UxCON0, Bit 2 = MODE<3:0>. UxCON0, Bit 1 = MODE<3:0>. UxCON0, Bit 0 = MODE<3:0>. UxCON0, Register on page = 484. UxCON1, Bit 7 = ON. UxCON1, Bit 6 = -. UxCON1, Bit 5 = -. UxCON1, Bit 4 = WUE. UxCON1, Bit 3 = RXBIMD. UxCON1, Bit 2 = -. UxCON1, Bit 1 = BRKOVR. UxCON1, Bit 0 = SENDB. UxCON1, Register on page = 485. UxCON2, Bit 7 = RUNOVF. UxCON2, Bit 6 = RXPOL.",
    "TABLE 31-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE UART\nUxCON2, Bit 5 = STP<1:0>. UxCON2, Bit 4 = STP<1:0>. UxCON2, Bit 3 = C0EN. UxCON2, Bit 2 = TXPOL. UxCON2, Bit 1 = FLO<1:0>. UxCON2, Bit 0 = FLO<1:0>. UxCON2, Register on page = 486. UxERRIR, Bit 7 = TXMTIF. UxERRIR, Bit 6 = PERIF. UxERRIR, Bit 5 = ABDOVF. UxERRIR, Bit 4 = CERIF. UxERRIR, Bit 3 = FERIF. UxERRIR, Bit 2 = RXBKIF. UxERRIR, Bit 1 = RXFOIF. UxERRIR, Bit 0 = TXCIF. UxERRIR, Register on page = 487. UxERRIE, Bit 7 = TXMTIE. UxERRIE, Bit 6 = PERIE.",
    "TABLE 31-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE UART\nUxERRIE, Bit 5 = ABDOVE. UxERRIE, Bit 4 = CERIE. UxERRIE, Bit 3 = FERIE;. UxERRIE, Bit 2 = RXBKIE. UxERRIE, Bit 1 = RXFOIE. UxERRIE, Bit 0 = TXCIE. UxERRIE, Register on page = 488. UxUIR, Bit 7 = WUIF. UxUIR, Bit 6 = ABDIF. UxUIR, Bit 5 = -. UxUIR, Bit 4 = -. UxUIR, Bit 3 = -. UxUIR, Bit 2 = ABDIE. UxUIR, Bit 1 = -. UxUIR, Bit 0 = -. UxUIR, Register on page = 489. UxFIFO, Bit 7 = TXWRE. UxFIFO, Bit 6 = STPMD. UxFIFO, Bit 5 = TXBE. UxFIFO, Bit 4 = TXBF. UxFIFO, Bit 3 = RXIDL. UxFIFO, Bit 2",
    "TABLE 31-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE UART\n= XON. UxFIFO, Bit 1 = RXBE. UxFIFO, Bit 0 = RXBF. UxFIFO, Register on page = 490. UxBRGL, Bit 7 = BRG<7:0>. UxBRGL, Bit 6 = BRG<7:0>. UxBRGL, Bit 5 = BRG<7:0>. UxBRGL, Bit 4 = BRG<7:0>. UxBRGL, Bit 3 = BRG<7:0>. UxBRGL, Bit 2 = BRG<7:0>. UxBRGL, Bit 1 = BRG<7:0>. UxBRGL, Bit 0 = BRG<7:0>. UxBRGL, Register on page = 491. UxBRGH, Bit 7 = BRG<15:8>. UxBRGH, Bit 6 = BRG<15:8>. UxBRGH, Bit 5 = BRG<15:8>. UxBRGH, Bit 4 = BRG<15:8>.",
    "TABLE 31-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE UART\nUxBRGH, Bit 3 = BRG<15:8>. UxBRGH, Bit 2 = BRG<15:8>. UxBRGH, Bit 1 = BRG<15:8>. UxBRGH, Bit 0 = BRG<15:8>. UxBRGH, Register on page = 491. UxRXB, Bit 7 = RXB<7:0>. UxRXB, Bit 6 = RXB<7:0>. UxRXB, Bit 5 = RXB<7:0>. UxRXB, Bit 4 = RXB<7:0>. UxRXB, Bit 3 = RXB<7:0>. UxRXB, Bit 2 = RXB<7:0>. UxRXB, Bit 1 = RXB<7:0>. UxRXB, Bit 0 = RXB<7:0>. UxRXB, Register on page = 492. UxTXB, Bit 7 =",
    "TABLE 31-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE UART\nTXB<7:0>. UxTXB, Bit 6 = TXB<7:0>. UxTXB, Bit 5 = TXB<7:0>. UxTXB, Bit 4 = TXB<7:0>. UxTXB, Bit 3 = TXB<7:0>. UxTXB, Bit 2 = TXB<7:0>. UxTXB, Bit 1 = TXB<7:0>. UxTXB, Bit 0 = TXB<7:0>. UxTXB, Register on page = 492. UxP1H, Bit 7 = -. UxP1H, Bit 6 = -. UxP1H, Bit 5 = -. UxP1H, Bit 4 = -. UxP1H, Bit 3 = -. UxP1H, Bit 2 = -. UxP1H, Bit 1 = -. UxP1H, Bit 0 = P1<8>. UxP1H, Register on page = 493. UxP1L,",
    "TABLE 31-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE UART\nBit 7 = P1<7:0>. UxP1L, Bit 6 = P1<7:0>. UxP1L, Bit 5 = P1<7:0>. UxP1L, Bit 4 = P1<7:0>. UxP1L, Bit 3 = P1<7:0>. UxP1L, Bit 2 = P1<7:0>. UxP1L, Bit 1 = P1<7:0>. UxP1L, Bit 0 = P1<7:0>. UxP1L, Register on page = 493. UxP2H, Bit 7 = -. UxP2H, Bit 6 = -. UxP2H, Bit 5 = -. UxP2H, Bit 4 = -. UxP2H, Bit 3 = -. UxP2H, Bit 2 = -. UxP2H, Bit 1 = -. UxP2H, Bit 0 = P2<8>. UxP2H, Register on",
    "TABLE 31-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE UART\npage = 494. UxP2L, Bit 7 = P2<7:0>. UxP2L, Bit 6 = P2<7:0>. UxP2L, Bit 5 = P2<7:0>. UxP2L, Bit 4 = P2<7:0>. UxP2L, Bit 3 = P2<7:0>. UxP2L, Bit 2 = P2<7:0>. UxP2L, Bit 1 = P2<7:0>. UxP2L, Bit 0 = P2<7:0>. UxP2L, Register on page = 494. UxP3H, Bit 7 = -. UxP3H, Bit 6 = -. UxP3H, Bit 5 = -. UxP3H, Bit 4 = -. UxP3H, Bit 3 = -. UxP3H, Bit 2 = -. UxP3H, Bit 1 = -. UxP3H, Bit 0 =",
    "TABLE 31-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE UART\nP3<8>. UxP3H, Register on page = 495. UxP3L, Bit 7 = P3<7:0>. UxP3L, Bit 6 = P3<7:0>. UxP3L, Bit 5 = P3<7:0>. UxP3L, Bit 4 = P3<7:0>. UxP3L, Bit 3 = P3<7:0>. UxP3L, Bit 2 = P3<7:0>. UxP3L, Bit 1 = P3<7:0>. UxP3L, Bit 0 = P3<7:0>. UxP3L, Register on page = 495. UxTXCHK, Bit 7 = TXCHK<7:0>. UxTXCHK, Bit 6 = TXCHK<7:0>. UxTXCHK, Bit 5 = TXCHK<7:0>. UxTXCHK, Bit 4 = TXCHK<7:0>.",
    "TABLE 31-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE UART\nUxTXCHK, Bit 3 = TXCHK<7:0>. UxTXCHK, Bit 2 = TXCHK<7:0>. UxTXCHK, Bit 1 = TXCHK<7:0>. UxTXCHK, Bit 0 = TXCHK<7:0>. UxTXCHK, Register on page = 496. UxRXCHK, Bit 7 = RXCHK<7:0>. UxRXCHK, Bit 6 = RXCHK<7:0>. UxRXCHK, Bit 5 = RXCHK<7:0>. UxRXCHK, Bit 4 = RXCHK<7:0>. UxRXCHK, Bit 3 = RXCHK<7:0>. UxRXCHK, Bit 2 = RXCHK<7:0>. UxRXCHK, Bit 1 = RXCHK<7:0>. UxRXCHK, Bit 0 =",
    "TABLE 31-3: SUMMARY OF REGISTERS ASSOCIATED WITH THE UART\nRXCHK<7:0>. UxRXCHK, Register on page = 496\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are unused by the UART module.",
    "32.1 SPI Module Overview\nThe  SPI  (Serial  Peripheral  Interface)  module  is  a synchronous serial data communication bus that operates in Full-Duplex mode. Devices communicate in a master/slave environment where the master device initiates the communication. A slave device is controlled  through  a  Chip  Select  known  as  Slave Select. Example slave devices include serial EEPROMs, shift registers, display drivers, A/D converters, or another PIC \u00ae device.\nThe SPI bus specifies four signal connections:\n\u00b7 Serial Clock (SCK)\n\u00b7 Serial Data Out (SDO)\n\u00b7 Serial Data IN (SDI)\n\u00b7 Slave Select (SS)\nThe SPI interface  supports  the  following  modes  and features:\n\u00b7 Master mode\n\u00b7 Slave mode\n\u00b7 Clock Polarity and Edge Select\n\u00b7 SDI, SDO, and SS Polarity Control\n\u00b7 Separate Transmit and Receive Enables\n\u00b7 Slave Select Synchronization\n\u00b7 Daisy-chain connection of slave devices\n\u00b7 Separate Transmit and Receive Buffers with 2-byte FIFO and DMA capabilities\nFigure 32-1  shows  the  block  diagram  of  the  SPI module.",
    "FIGURE 32-1: SPI MODULE SIMPLIFIED BLOCK DIAGRAM\nThe SPI transmit output (SDO_out) is available to the remappable  PPS  SDO  pin  and  internally to the following peripherals:\n\u00b7 Configurable Logic Cell (CLC)\n\u00b7 Data Signal Modulator (DSM)\nThe  SPI  bus  typically  operates  with  a  single  master device and one or more slave devices. When multiple slave devices are used, an independent Slave Select connection is required from the master device to each slave device.\nThe master selects only one slave at a time. Most slave devices  have  tri-state  outputs  so  their  output  signal appears disconnected from the bus when they are not selected.",
    "FIGURE 32-1: SPI MODULE SIMPLIFIED BLOCK DIAGRAM\nTransmissions typically involve shift registers, eight bits in size, one in the master and one in the slave. With either the master or the slave device, data is always shifted out one bit at a time, with the Most Significant bit (MSb) shifted out first. At the same time, a new bit is shifted into the device. Unlike older Microchip devices, the SPI on the PIC18(L)F25/26K83 contains two sepa -rate registers for incoming and outgoing data. Both reg -isters also have 2-byte FIFO buffers and allow for DMA bus connections.\nFigure 32-2 shows a typical connection between two devices configured as master and slave devices.\nData  is shifted out of the  transmit FIFO  on  the programmed  clock  edge  and  into  the  receive  shift register on the opposite edge of the clock.\nThe master device  transmits  information  on  its  SDO output pin which is connected to, and received by, the slave's  SDI  input  pin.  The  slave  device  transmits information on its SDO output pin, which is connected to, and received by, the master's SDI input pin.",
    "FIGURE 32-1: SPI MODULE SIMPLIFIED BLOCK DIAGRAM\nThe master device sends out the clock signal. Both the master and the slave devices should be configured for the same clock polarity.\nDuring each SPI clock cycle, a full-duplex data transmission occurs. This means that while the master device is sending out the MSb from its output register (on its SDO pin) and the slave device is reading this bit and saving as the LSb of its input register, that the slave device is also sending out the MSb from its shift register (on its SDO pin) and the master device is reading this bit and saving it as the LSb of its input register.\nAfter eight bits have been shifted out, the master and slave have exchanged register values and stored the incoming data into the receiver FIFOs.\nIf  there  is  more  data  to  exchange,  the  registers  are loaded with new data and the process repeats itself.\nWhether the data is meaningful or not (dummy data) depends  on  the  application  software.  This  leads  to three scenarios for data transmission:",
    "PIC18(L)F25/26K83\n\u00b7 Master sends useful data and slave sends dummy data\n\u00b7 Master sends useful data and slave sends useful data\n\u00b7 Master sends dummy data and slave sends useful data\nIn this particular SPI module, dummy data may be sent without  software  involvement,  by  clearing  either  the RXR bit (for receiving dummy data) or the TXR bit (for sending  dummy  data)  (see  Table 32-1  as  well  as Section 32.5 'Master mode' and Section 32.6 'Slave  Mode' for  further  TXR/RXR  setting  details). This  SPI  module  can  send  transmissions  of  any number of bits, and can send information in segments of  varying  size  (from  1-8  bits  in  width).  As  such, transmissions may involve any number of clock cycles, depending on the amount of data to be transmitted.\nWhen  there  is  no  more  data  to  be  transmitted,  the master stops sending the clock signal and deselects the slave.\nEvery slave device connected to the bus that has not been selected through its Slave Select line disregards the  clock  and  transmission  signals  and  does  not transmit out any data of its own.",
    "32.2 SPI REGISTERS\n\u00b7 SPI Interrupt Flag Register (SPIxINTF)\n\u00b7 SPI Interrupt Enable Register (SPIxINTE)\n\u00b7 SPI Byte Count High and Low Registers (SPIxTCTH/L)\n\u00b7 SPI Bit Count Register (SPIxTWIDTH)\n\u00b7 SPI Baud Rate Register (SPIxBAUD)\n\u00b7 SPI Control Register 0 (SPIxCON0)\n\u00b7 SPI Control Register 1 (SPIxCON1)\n\u00b7 SPI Control Register 2 (SPIxCON2)\n\u00b7 SPI FIFO Status Register (SPIxSTATUS)\n\u00b7 SPI Receiver Buffer Register (SPIxRB)\n\u00b7 SPI Transmit Buffer Register (SPIxTB)\n\u00b7 SPI Clock Select Register (SPIxCLK)\nSPIxCON0,  SPIxCON1,  and  SPIxCON2  are  control registers for the SPI module.\nSPIxSTATUS contains several Status bits that indicate the status of both the SPI module and the receive and transmit FIFOs.",
    "32.2 SPI REGISTERS\nSPIxBAUD and SPIxCLK control the Baud Rate Gen -erator (BRG) of the SPI module when in Master mode. The SPIxCLK selects the clock source that is used. The SPIxBAUD configures the clock divider used on that clock. More information on the baud rate generator is available in Section 32.5.6 'Master Mode SPI Clock Configuration' .'\nSPIxTxB  and  SPIxRxB  are  the  transmit  and  receive buffer registers used to send and receive data on the SPI  bus.  They  both  offer  indirect  access  to  shift registers that are used for shifting the data in and out. Both registers access the two-byte FIFOs, allowing for multiple transmissions/receptions to be stored between software transfers the data.",
    "32.2 SPI REGISTERS\nThe SPIxTCTH:L register pair either count or control the number of bits or bytes in a data transfer. When BMODE =  , the SPIxTCT value signifies bytes and the 1 SPIxTWIDTH value signifies  the  number  of  bits  in  a byte. When  BMODE  = 0 , the SPIxTCT  value  is concatenated with the SPIxTWIDTH register to signify bits.  In  Master  Receive-only  mode  (TXR  = 0 and RXR  = 1 ), the  data  transfer  is  initiated  by  writing SPIxTCT with the desired bit or byte value to transfer. In Master Transmit mode (TXR = 1 ), the data transfer is  initiated  by  writing  the  SPIxTxB  register,  in  which case  the  SPIxTCT  is  a  down  counter  for  the  bits  or bytes transferred.",
    "PIC18(L)F25/26K83\nThe  SPIxINTF  and  SPIxINTE  are  the  flags and enables, respectively, for SPI-specific interrupts. They are tied to the SPIxIF flag and SPIxIE enable in the PIR and PIE registers, which is triggered when any interrupt contained in the SPIxINTF/SPIxINTE  registers is triggered. The PIR/PIE registers also contain SPIxTXIF/SPIxTXIE bits,  which  are  the  interrupt  flag and enable for the SPI Transmit Interrupt, as well as the SPIxRXIF/SPIxRXIE bits, which are the interrupt flag and enable for the SPI Receive Interrupt.",
    "32.3 SPI MODE OPERATION\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control bits (SPIxCON0<2:0>, SPIxCON1<7:4>, SPIxCON1<2:0>, and SPIxCON2<2:0>). These control bits allow the following to be specified:\n\u00b7 Master mode (SCK is the clock output)\n\u00b7 Slave mode (SCK is the clock input)\n\u00b7 Clock Polarity (Idle state of SCK)\n\u00b7 Input, Output, and Slave Select Polarity\n\u00b7 Data Input Sample Phase (middle or end of data output time)\n\u00b7 Clock Edge (output data on first/second edge of SCK)\n\u00b7 Clock Rate (Master mode only)\n\u00b7 Slave Select Mode (Master or Slave mode)\n\u00b7 MSB-First or LSB-First\n\u00b7 Receive/Transmit Modes\n-Full-duplex\n-Receive-without-transmit\n-Transmit-without-receive\n\u00b7 Transfer Counter Mode (Transmit-without-receive mode)",
    "32.3.1 ENABLING AND DISABLING THE SPI MODULE\nTo enable the serial peripheral, the SPI enable bit (EN in SPIxCON0) must be set. To reset or reconfigure SPI mode,  clear  the  EN  bit,  re-initialize  the  SSPxCONx registers  and  then  set  the  EN  bit.  Setting  the  EN  bit enables  the SPI  inputs and  outputs: SDI, SDO, SCK(out),  SCK(in),  SS(out),  and  SS(in). All  of  these inputs and outputs are steered by PPS, and thus must have their functions properly mapped to device pins to function  (see Section 17.0  'Peripheral  Pin  Select (PPS)  Module' ).  In  addition,  SS(out)  and  SCK(out) must have the pins they are steered to set as outputs (TRIS  bits  must  be  ' 0 ')  in  order  to  properly",
    "32.3.1 ENABLING AND DISABLING THE SPI MODULE\noutput. Clearing the TRIS bit of the SDO pin will cause the SPI module to always control that pin, but is not necessary for SDO functionality. (see Section 32.3.5 'Input and Output Polarity Bits' ). Configurations selected by the following registers should not be changed while the EN bit is set:\n\u00b7 SPIxBAUD\n\u00b7 SPIxCON1\n\u00b7 SPIxCON0 (except to clear the EN bit)\nClearing the EN  bit aborts any  transmissions in progress,  disables  the  setting  of  interrupt  flags  by hardware, and resets the FIFO occupancy (see Section 32.3.3  'Transmit  and  Receive  FIFOs' for more FIFO details).",
    "32.3.2 BUSY BIT\nWhile a data transfer is in progress, the SPI module sets the BUSY bit of SPIxCON2. This bit can be polled by the user to determine the current status of the SPI module,  and  to know  when  a  communication  is complete.  The  following  registers/bits  should  not  be written by software while the BUSY bit is set:\n\u00b7 SPIxTCNTH/L\n\u00b7 SPIxTWIDTH\n\u00b7 SPIxCON2\n\u00b7 The CLRBF bit of SPIxSTATUS",
    "Note:\nIt is also not recommended to read SPIx -TCNTH/L while the BUSY bit is set, as the value in the registers may not be a reliable indicator of the Transfer Counter. Use the Transfer  Count  Zero  Interrupt  Flag  (the TCZIF  bit  of SPIxINTF)  to  accurately determine that the Transfer Counter has reached zero.",
    "32.3.3 TRANSMIT AND RECEIVE FIFOS\nThe transmission and reception of data from the SPI module is handled by two FIFOs, one for reception and one for transmission (addressed by the SFRs SPIxRXB and SPIxTXB, respectively.). The TXFIFO is written by software and is read by the SPI module to shift the data onto the SDO pin. The RXFIFO is written by the SPI module as it shifts in the data from the SDI pin and is read by software. Setting the CLRBF bit of SPIxSTATUS  resets  the  occupancy  for  both  FIFOs, emptying both buffers. The FIFOs are also reset by dis -abling the SPI module.",
    "Note:\nTXFIFO occupancy and RXFIFO occupancy simply refer to the number of bytes  that  are  currently  being  stored  in each FIFO. These values are used in this chapter to illustrate the function of these FIFOs  and  are  not  directly  accessible through software.\nThe SPIxRXB register addresses the receive FIFO and is read-only. Reading from this register will read from the first FIFO location that was written to by hardware and decrease the RXFIFO occupancy. If the FIFO is empty, reading from this register will instead return a value of zero and set the RXRE (Receive Buffer Read Error) bit of the SPIxSTATUS register. The RXRE bit must then be cleared in software in order to properly reflect the status of the read error. When RXFIFO is full, the RXBF bit of the SPIxSTATUS register will be set. When  the  device  receives  data  on  the  SDI  pin,  the receive FIFO may be written to by hardware and the occupancy  increased,  depending  on  the  mode  and receiver settings, as summarized in Table 32-1.",
    "Note:\nThe  SPIxTXB  register  addresses  the  transmit  FIFO and is write-only. Writing to the register will write to the first empty FIFO location and increase the occupancy. If the FIFO is full, writing to this register will not affect the data and will set the TXWE bit of the SPIxSTATUS register. When the TXFIFO is empty, the TXBE bit of SPIxSTATUS will be set. When a data transfer occurs, data may be read from the first FIFO location written to and  the  occupancy  decreases,  depending  on  mode and transmitter settings, as summarized in Table 32-1 and Section 32.6.1 'Slave Mode Transmit options' .",
    "32.3.4 LSB VS. MSB-FIRST OPERATION\nTypically, SPI communication is output Most-Significant bit  first,  but  some  devices/buses may not conform to this standard. In this case, the LSBF bit may be used to alter the order in which bits are shifted out during the data exchange. In both Master and Slave mode, the LSBF bit of SPIxCON0 controls if data is shifted MSb or LSb first. Clearing the bit (default) configures the data to transfer MSb first, which is traditional SPI operation, while setting the bit configures the data to transfer LSb first.",
    "32.3.5 INPUT AND OUTPUT POLARITY BITS\nSPIxCON1 has three bits that control the polarity of the SPI  inputs  and  outputs.  The  SDIP  bit  controls  the polarity  of  the  SDI  input,  the  SDOP  bit  controls  the polarity of the SDO output, and the SSP bit controls the polarity of both the slave SS input and the master SS output. For all three bits, when the bit is clear, the input or  output  is  active-high,  and  when  the  bit  is  set,  the input  or  output  is  active-low.  When  the  EN  bit  of SPIxCON0  is  cleared,  SS(out)  and  SCK(out)  both revert to the inactive state dictated by their polarity bits. The SDO output state when the EN bit of SPIxCON0 is cleared is determined by several factors.",
    "32.3.5 INPUT AND OUTPUT POLARITY BITS\n\u00b7 When the associated TRIS bit for the SDO pin is cleared, and the SPI goes Idle after a transmis -sion, the SDO output will remain at the last bit level. The SDO pin will revert to the Idle state if EN is cleared.\n\u00b7 When the associated TRIS bit for the SDO pin is set, behavior varies in Slave and Master mode.\n-In Slave mode, the SDO pin tri-states when:\n-Slave Select is inactive,\n-the EN bit of SPIxCON0 is cleared, or when\n-the TXR bit of SPIxCON2 is cleared.\n-In Master mode, the SDO pin tri-states when TXR = 0 . When TXR = 1 and the SPI goes Idle after a transmission, the SDO output will remain at the last bit level. The SDO pin will revert to the Idle state if EN is cleared.",
    "32.4 Transfer Counter\nIn all Master modes, the transfer counter can be used to  determine  how  many  data  transfers  the  SPI  will send/receive. The transfer counter is comprised of the SPIxTCTH/L  set  of  registers,  and  is  also  partially controlled by the SPIxTWIDTH register. The Transfer Counter  has  two  primary  modes,  determined  by  the BMODE bit of the SPIxCON0 register. Each mode uses the SPIxTCTH/L and SPIxTWIDTH registers to determine the number and size of the transfers. In both modes, when the transfer  counter  reaches  zero,  the TCZIF interrupt flag is set.\nNote:",
    "32.4 Transfer Counter\nWhen  BMODE=   in  all  Master  modes 1 (and  at  all  times  in  Slave  modes),  the Transfer  Counter  will  still  decrement  as transfers occur and can be used to count the  number  of  messages  sent/received, as well as to control SS(out) and to trigger TCZIF.  Also when  BMODE  = 1 , the SPIxTWIDTH  register  can  be  used  in Master and Slave modes to determine the size  of  messages  sent  and  received  by the  SPI,  even  if  the  Transfer  Counter  is not  being  actively  used  to  control  the number of messages being sent/received by the SPI module.",
    "32.4.1 TOTAL BIT COUNT MODE (BMODE = 0 )\nIn this mode,  SPIxTCTH/L  and  SPIxTWIDTH  are concatenated to determine the total number of bits to be transferred. These bits will be loaded from/into the transmit/receive  FIFOs  in  8-bit  increments  and  the transfer counter will be decremented by eight until the total number of remaining bits is less than eight. If there are any remaining bits (SPIxTWIDTH \u2260 0 ), the transmit FIFO will send out one final message with any extra bits greater than the remainder ignored. The SPIxTWIDTH is  the  remaining  bit  count  but  the  value  does  not change as it does for the SPIxTCT value. Similarly, the receiver will load a final byte into the receiver FIFO, and pad  the extra bits with zeros.  The LSBF  bit  of SPIxCON0 determines whether the Most Significant or Least  Significant  bits  of  this  final  byte  are  ignored/ padded. For  example, when LSBF = 0 and  the",
    "32.4.1 TOTAL BIT COUNT MODE (BMODE = 0 )\nfinal transfer contains only two bits then if the last byte sent was 5Fh then the RXB of the receiver will contain 40h which are the two MSbits of the final byte padded with zeros in the LSbits.\nIn this mode,  the SPI  master  will only transmit messages  when  the  SPIxTCT  value  is  greater  than zero, regardless of TXR and RXR settings. In Master Transmit mode, the transfer starts with the data write to the SPIxTXB register or the count value written to the SPIxTCTL register, which ever occurs last. In Master Receive-only mode, the transfer clocks start when the SPIxTCTL value is written. Transfer clocks are suspended when the receive FIFO is full and resume as the FIFO is read.",
    "32.4.2 VARIABLE TRANSFER SIZE MODE (BMODE = 1 )\nIn this mode, SPIxTWIDTH specifies the width of every individual piece of the data transfer in bits. SPIxTCTH/ SPIxTCTL specifies the number of transfers of this bit length. If SPIxTWIDTH = 0 , each piece is a full byte of data.  If  SPIxTWIDTH \u2260 0 , then  only  the  specified number of bits from the transmit FIFO are shifted out, with the unused bits ignored. Received data is padded with zeros in the unused bit areas when transfered into the receive FIFO. The LSBF bit of SPIxCON0 determines  whether  the  Most  Significant  or  Least Significant bits of the transfers are ignored/padded. In this mode, the transfer counter being zero only stops messages from being sent/received when in 'Receive only' mode.",
    "Note:\nWith  BMODE  = 1 ,  it  is  possible  for  the transfer  counter  (SPIxTCTH/L)  to  decre -ment below zero, although when in 'Receive  Only'  Master  mode,  transfer clocks will cease when the transfer counter reaches zero.",
    "32.4.3 TRANSFER COUNTER IN SLAVE MODE\nIn Slave mode, the transfer counter will still decrement as data is shifted in and out of the SPI module, but it will not control data transfers. In addition, in Slave mode, the BMODE bit along with the transfer counter is used to  determine  when  the  device  should  look  for  Slave Select faults. If BMODE = 0 , the SSFLT bit will be set if Slave Select transitions from its active to inactive state during bytes of data, as well as if it transitions before the last bit sent during the final byte (if SPIxTWIDTH \u2260 0 ). If BMODE= 1 ,  the SSFLT bit will be set if Slave Select transitions from its active to inactive state before the final bit of each individual transfer is completed. Note that SSFLT does not have an associ -ated interrupt, so it should be checked in software. An ideal time to do this is when the End of Slave Select Interrupt  (EOSIF)  is  triggered  (see Section 32.8.3.3 'Start of Slave Select and End of Slave Select Inter -rupts' ).",
    "32.5 Master mode\nIn Master mode, the device controls the SCK line, and as such, initiates data transfers and determines when any slaves broadcast data onto the SPI bus.\nMaster mode of this device can be configured in four different modes, configured by the TXR and RXR bits:\n\u00b7 Full-Duplex mode\n\u00b7 Receive Only mode\n\u00b7 Transmit Only mode\n\u00b7 Transfer Off mode\nThe modes are illustrated in Table 32-1, below:",
    "TABLE 32-1: MASTER MODE TXR/RXR SETTINGS\nRXR = 1, TXR = 1 = Full-Duplex mode If BMODE = 1 , transfer when RxFIFO is not full and TxFIFO is not empty If BMODE = 0 , Transfer when RXFIFO is not full, TXFIFO is not empty, and the Transfer Counter is non- zero. RXR = 1, TXR = 0 = Receive Only mode Transfer when RxFIFO is not full and the Transfer Counter is non-zero Transmitted data is either the top of the FIFO or the most recently received data. RXR = 0, TXR = 1 = Transmit Only mode If BMODE = 1 , transfer when TxFIFO is not empty If BMODE = 0 , Transfer when TXFIFO is not empty and the Transfer Counter is non-zero Received data is not stored. RXR = 0, TXR = 0 = No Transfers",
    "32.5.1 FULL-DUPLEX MODE\nWhen both TXR and RXR are set, the SPI master is in Full-Duplex mode. In this mode, data transfer triggering is affected by the BMODE bit of SPIxCON0.\nWhen BMODE = 1 , data transfers will occur whenever both the RXFIFO is not full and there is data present in the TXFIFO. In practice, as long as the RXFIFO is not full,  data  will  be  transmitted/received  as  soon  as  the SPIxTxB register is written to, matching functionality of SPI (MSSP) modules on older 8-bit Microchip devices. The  SPIxTCNT  will  decrement  with  each  transfer. However, when SPIxTCNT is zero the next transfer is not inhibited and the corresponding SPIxTCNT decrement  will  cause  the  count  to  roll  over  to  the maximum value. Figure 32-3 shows an example of a communication using this mode.",
    "32.5.1 FULL-DUPLEX MODE\nWhen BMODE = 0 , the transfer counter (SPIxTCNTH/ SPIxTCNTL) must also be written to before transfers will  occur,  and transfers will cease when the transfer counter reaches ' 0 '. For example, if SPIxTXB is written twice  and  then  SPIxTCTL  is  written  with  '3'  then  the transfer  will  start  with  the  SPIxTCTL  write.  The  two bytes in the TXFIFO will be sent after which the transfer will  suspend until  the  third  and last byte  is written to SPIxTXB.",
    "32.5.2 TRANSMIT ONLY MODE\nWhen TXR is set and RXR is clear, the SPI master is in Transmit  Only  mode.  In  this  mode,  data  transfer triggering is affected by the BMODE bit of SPIxCON0.\nWhen BMODE = 1 , data transfers will occur whenever TXFIFO is not empty. Data will be transmitted as soon as the TXFIFO register is written to, matching functionality of SPI (MSSP) modules on previous 8-bit Microchip devices. The SPIxTCNT will decrement with each transfer. However, when SPIxTCNT is zero the next  transfer  is  not  inhibited  and  the  corresponding SPIxTCNT decrement will cause the count to roll over to the maximum value. Any data received in this mode is not stored in RXFIFO.  Figure 32-4 shows  an example of sending a command and then sending a byte of data, using this mode.\nWhen BMODE = 0 , the transfer counter (SPIxTCNTH/ L) must also be written to before transfers will occur, and  transfers  will  cease  when  the  transfer  counter reaches ' 0 '.",
    "32.5.2 TRANSMIT ONLY MODE\nFor  example,  if  SPIxTXB  is  written  twice  and  then SPIxTCTL is written with '3', the transfer will start with the SPIxTCTL write. The two bytes in the TXFIFO will be sent after which the transfer will suspend until the third and last byte is written to SPIxTXB.",
    "32.5.3 RECEIVE ONLY MODE\nWhen RXR is set and TXR is clear, the SPI master is in Receive Only mode. In this mode, data transfers when the RXFIFO is not full and the Transfer Counter is nonzero. In this mode, writing a value to SPIxTCNTL will start  the  clocks  for  transfer.  The  clocks  will  suspend while the RXFIFO  is full and cease when the SPIxTCNT reaches zero (see Section 32.4 'Transfer Counter' ). If there is any data in the TXFIFO, the first data written to the TXFIFO will be transmitted on each data exchange, although the TXFIFO occupancy will not change, meaning that the same message will be sent  on  each transmission.  If  there  is  no  data  in  the TXFIFO, the most recently received data will instead be transmitted. Figure 32-5 shows an example of sending a  command  using Section 32.5.2  'Transmit  Only Mode' and  then  receiving  a  byte  of  data  using  this mode.",
    "32.5.4 TRANSFER OFF MODE\nWhen both TXR and RXR are cleared, the SPI master is  in  Transfer  Off  mode.  In  this  mode,  SCK  will  not toggle and no data is exchanged. However, writes to SPIxTXB will be transferred to the TXFIFO which will be transmitted if the TXR bit is set.",
    "32.5.5.1 Hardware Slave Select Control\nThis SPI module allows for direct hardware control of a Slave Select output. The Slave Select output SS(out) is controlled both directly, through  the SSET  bit  of SPIxCON2, as well indirectly by the hardware while the transfer counter is non-zero (see Section 32.4 'Transfer Counter' ).  SS(out) is steered by the PPS registers  to  pins  (see Section 17.2 'PPS Outputs' )",
    "PIC18(L)F25/26K83\nand  its polarity is controlled by the SSP  bit of SPIxCON1.  Setting  the  SSET  bit  will  also  assert SS(out). Clearing the SSET bit will leave SS(out) to be controlled by the Transfer Counter. When the Transfer Counter is loaded, the SPI module will automatically assert the SS. When the Transfer Counter decrements to  zero,  the  SPI  module  will  deassert  SS  either  one baud  period  after  the  final  SCK  pulse  of  the  final transfer (if CKE/SMP = 0/1 )  or  one half baud period otherwise (see Figure 32-6).",
    "FIGURE 32-6: SPI MASTER SS OPERATION- CKE = 0 , BMODE = 1 , TCWIDTH = 0 , SSP = 0\nRev. 10- 000284A 9/14/2016\nNote:    1.\nSDO bit number illustrates the transmitted bit number, and is not intended to imply SDO (out) tristate operation.\n2. Assumes SPIxTXB holds data when SPIxTCNTL is written.\n1\n0\nminimum 1 baud clock when FST = 0\napprox. 1 baud clock\n7\n6\n5\n4\n3\nSPIEN\nbaud_clock\nSoftware Write to SPIxTCNTL\nTransfer\nCounter\nSS_out\nSCK_out\nSDO_bit_number\n2\n1\n0",
    "32.5.5.2 Software Slave Select Control\nSlave Select can also be controlled through software via a general purpose I/O pin. In this case, ensure that the  pin  in  question  is  configured  as  a  GPIO  through PPS (see Section 17.2 'PPS Outputs' ), and ensure that the pin is set as an output (clear the appropriate bit in  the  appropriate TRIS register). In this case, SSET will  not  affect  the  Slave  Select,  the Transfer Counter will not automatically control the Slave Select output, and all setting and clearing of the Slave Select output line must be directly controlled by software.",
    "32.5.6.1 SPI Clock Selection\nThe clock source for SPI Master modes is selected by the SPIxCLK register. Selections include the following:\n\u00b7 FOSC\n\u00b7 HFINTOSC\n\u00b7 CLKREF\n\u00b7 Timer0_overflow\n\u00b7 Timer2_Postscaled\n\u00b7 Timer4_Postscaled\n\u00b7 Timer6_Postscaled\n\u00b7 SMT_match\nThe SPIxBAUD register allows for dividing this clock. The  frequency  of  the SCK  output  is defined by Equation 32-1:",
    "EQUATION 32-1: FREQUENCY OF SCK OUTPUT SIGNAL\n<!-- formula-not-decoded -->\nwhere FBAUD is the baud rate frequency output on the SCK  pin,  FCSEL  is  the  frequency  of  the  input  clock selected  by  the  SPIxCLK  register,  and  BAUD  is  the value contained in the SPIxBAUD register.",
    "32.5.6.2 CKE, CKP and SMP\nThe CKP, CKE, and SMP bits control the relationship between  the  SCK  clock  output,  SDO  output  data changes, and SDI input data sampling. The bit functions are as follows:\n\u00b7 CKP - SCK output polarity\n\u00b7 CKE - SDO output change relative to the SCK clock\n\u00b7 SMP - SDI input sampling relative to the clock edges\nThe CKE bit, when set, inverts the low Idle state of the SCK output to a high Idle state.\nFigure 32-7  through  Figure 32-10  illustrate  the  eight possible combinations of the CKP, CKE, and SMP bit selections.\nWhen the CKE bit is set, the SDO data is valid before there  is  a  clock  edge  on  SCK.  When  the  CKE  bit  is cleared,  the  SDO  data  is  undefined  prior  to  the  first SCK edge.\nNote:\nAll timing diagrams assume the LSBF bit of SPIxCON0 is cleared.",
    "PIC18(L)F25/26K83\nFIGURE 32-8: CLOCKING DETAIL - MASTER MODE, CKE/SMP = 1/1\nFIGURE 32-9: CLOCKING DETAIL - MASTER MODE, CKE = 0 , SMP = 1\nFIGURE 32-10: CLOCKING DETAIL - MASTER MODE, CKE = 1 , SMP = 0",
    "32.5.6.3 SCK Start-Up Delay\nWhen  starting  an  SPI  data  exchange,  the  master device sets the SS output (either through hardware or software) and then triggers the module to send data. These  data  triggers  are  synchronized  to  the  clock selected by the SPIxCLK register before the first SCK pulse appears, usually requiring one or two clocks of the selected clock.\nSPIxBAUD  (indicating  lower  SCK  frequencies),  this delay  is  much  smaller  and  the  first  SCK  can  appear relatively quickly after SS is set.\nThe  SPI  module  includes  synchronization  delays  on SCK generation  specifically  designed  to  ensure  that the  Slave  Select  output  timing  is  correct,  without requiring precision software timing loops.\nWhen the value of the SPIxBAUD register is a small number (indicating higher SCK  frequencies), the synchronization delay can be relatively long between setting  SS  and  the  first  SCK.  With  larger  values  of",
    "32.5.6.3 SCK Start-Up Delay\nBy default, the SPI module inserts a \u00bd baud delay (half of  the  period  of  the  clock  selected  by  the  SPIxCLK register)  before  the  first  SCK  pulse.  This  allows  for systems with a high SPIxBAUD value to have extra setup  time  before  the  first  clock.  Setting  the  FST  bit  in SPIxCON1  removes  this  additional  delay,  allowing systems  with  low  SPIxBAUD  values  (and  thus,  long synchronization  delays)  to  forego  this  unnecessary extra delay.",
    "32.6.1 SLAVE MODE TRANSMIT OPTIONS\nThe SDO output of the SPI module in Slave mode is controlled by the TXR bit of SPIxCON2, the TRIS bit associated with the SDO pin, the Slave Select input, and  the  current  state  of  the  TXFIFO.  This  control  is summarized in Table 32-2. In this table, TRISxn refers to the bit in the TRIS register corresponding to the pin that  SDO  has  been  assigned  with  PPS,  TXR  is  the Transmit Data Required Control bit of SPIxCON2, SS is the state of the Slave Select input, and TXBE is the TXFIFO Buffer Empty bit of SPIxSTATUS.",
    "32.6.1.1 SDO Drive/Tri-state\nThe  TRIS  bit  associated  with  the  SDO  pin  controls whether the SDO pin will tri-state. When this TRIS bit is cleared, the pin will always be driving to a level, even when the SPI module is inactive. When the SPI module is  inactive  (either  due  to  the  master  not  clocking  the SCK line or the SS being false), the SDO pin will be driven to the value of the LAT bit associated with the SDO pin. When the SPI module is active, its output is determined by both TXR and whether there is data in the TXFIFO.\nWhen the TRIS bit associated with the SDO pin is set, the pin will only have an output level driven to it when TXR = 1 and the Slave Select input is true. In all other cases, the pin will be tri-stated.",
    "32.6.1.2 SDO Output Data\nThe  TXR  bit  controls  the  nature  of  the  data  that  is transmitted in Slave mode. When  TXR is set, transmitted data is taken from the TXFIFO. If the FIFO is empty,  the  most  recently  received  data  will  be transmitted and the TXUIF flag will be set to indicate that a transmit FIFO underflow has occurred.\nWhen TXR is cleared, the data will be taken from the TXFIFO, and the TXFIFO occupancy will not decrease. If the TXFIFO is empty, the most recently received data will be transmitted, and the TXUIF bit will not be set. However, if the TRIS bit associated with the SDO pin is set, clearing the TXR bit will cause the SPI module to not output any data to the SDO pin.\n\nTABLE 32-2: SLAVE MODE TRANSMIT",
    "32.6.1.2 SDO Output Data\n0, TXR = 0. 0, SS = FALSE. 0, TXBE = 0. 0, SDO State = Drives state determined by LATxn(2). 0, TXR = 0. 0, SS = FALSE. 0, TXBE = 1. 0, SDO State = Drives state determined by LATxn(2). 0, TXR = 0. 0, SS = TRUE. 0, TXBE = 0. 0, SDO State = Outputs the oldest byte in the TXFIFO Does not remove data from the TXFIFO. 0, TXR = 0. 0, SS = TRUE. 0, TXBE = 1. 0, SDO State = Outputs the most recently received byte. 0, TXR = 1. 0, SS = FALSE. 0, TXBE = 0. 0, SDO State = Drives state determined by LATxn(2). 0, TXR = 1. 0, SS = FALSE. 0, TXBE = 1. 0, SDO State = Drives state determined by LATxn(2). 0, TXR = 1. 0, SS = TRUE. 0,",
    "32.6.1.2 SDO Output Data\nTXBE = 0. 0, SDO State = Outputs the oldest byte in the TXFIFO Removes transmitted byte from the TXFIFO Decrements occupancy of TXFIFO. 0, TXR = 1. 0, SS = TRUE. 0, TXBE = 1. 0, SDO State = Outputs the most recently received byte Sets the TXUIF bit of SPIxINTF. 1, TXR = 0. 1, SS = FALSE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = FALSE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = TRUE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = TRUE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = FALSE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 1. 1, SS =",
    "32.6.1.2 SDO Output Data\nFALSE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = TRUE. 1, TXBE = 0. 1, SDO State = Outputs the oldest byte in the TXFIFO Removes transmitted byte from the TXFIFO Decrements occupancy of TXFIFO. 1, TXR = 1. 1, SS = TRUE. 1, TXBE = 1. 1, SDO State = Outputs the most recently received byte Sets the TXUIF bit of SPIxINTF\nNote\n1: TRISxn is the bit in the TRISx register corresponding to the pin that SDO has been assigned with PPS.\n2: LATxn is the bit in the LATx register corresponding to the pin that SDO has been assigned with PPS.",
    "32.6.2 SLAVE MODE RECEIVE OPTIONS\nThe RXR bit controls the nature of receptions in Slave mode.  When  RXR  is  set,  the  SDI  input  data  will  be stored in the RXFIFO if it is not full. If the RXFIFO is full, the RXOIF bit will be set to indicate an RXFIFO over -flow  error  and  the  data  is  discarded.  When  RXR  is cleared, all received data will be ignored and not stored in the RXFIFO (although it may still be used for trans -mission if TXFIFO is empty). Figure 32-11 shows a typ -ical Slave mode communication, showing a case where the master writes two then three bytes, showing inter -rupts as well as the behavior of the transfer counter in Slave mode (see Section 32.4.3 'Transfer Counter in  Slave  mode' for more  details  on  the  transfer counter in Slave mode as well as Section 32.8 'SPI Interrupts' for more information on interrupts).\nFIGURE 32-11: SPI SLAVE MODE OPERATION - INTERRUPT-DRIVEN, MASTER WRITES 2+3 BYTES",
    "32.6.3 SLAVE MODE SLAVE SELECT\nIn Slave mode, an external Slave Select Signal can be used  to  synchronize  communication  with  the  master device. The Slave Select line is held in its inactive state (high  by  default)  until  the  master  device  is  ready  to communicate. When the Slave Select transitions to its active state, the slave knows that a new transmission is starting.\nWhen the Slave Select goes false at the  end  of  the transmission the receive function of the selected SPI slave device returns to the inactive state. The slave is then  ready  to  receive  a  new  transmission  when  the Slave Select goes True again.",
    "32.6.3 SLAVE MODE SLAVE SELECT\nThe Slave Select signal is received on the SS input pin. This pin is remappable with the SPIxSSPPS register (see Section 17.1 'PPS Inputs' ). When the input on this pin is true, transmission and reception are enabled, and the SDO pin is driven. When the input on this pin is false,  the SDO pin is either tri-stated (if the TRIS bit associated with the  SDO  pin  is  set)  or  driven  to  the value of the LAT bit associated with the SDO pin (if the TRIS bit  associated with the  SDO pin  is cleared). In addition, the SCK input is ignored.\nIf the SS input goes False, while a data transfer is still in progress, it is considered a Slave Select fault. The SSFLT  bit  of  SPIxCON2  indicates  whether  such  an event has occurred. The transfer counter value deter -mines the number of bits in a valid data transfer (see Section 32.4 'Transfer Counter' for more details).",
    "32.6.3 SLAVE MODE SLAVE SELECT\nThe Slave Select polarity is controlled by the SSP bit of SPIxCON1.  When  SSP  is  set  (its  default  state),  the Slave Select input is active-low, and when it is cleared, the Slave Select input is active-high.\nThe Slave Select for the SPI module is controlled by the SSET bit of SPIxCON2. When the bit is cleared (its default  state),  the  Slave  Select  will  act  as  described above. When the bit is set, the SPI module will behave as if the SS input was always in its active state.",
    "Note:\nWhen  SSET  is  set,  the  effective  SS(in) signal is always active. Hence, the SSFLT bit may be disregarded.",
    "32.6.4 SLAVE MODE CLOCK CONFIGURATION\nIn Slave  mode,  SCK  is  an  input,  and  must be configured to the same polarity and clock edge as the master device. As in Master mode, the polarity of the clock input is controlled by the CKP bit of SPIxCON1 and  the  clock  edge  used  for  transmitting  data  is controlled by the CKE bit of SPIxCON1.",
    "32.6.5 DAISY-CHAIN CONFIGURATION\nThe  SPI  bus  can  be  connected  in  a  daisy-chain configuration. The first slave output is connected to the second slave input, the second slave output is connected to the third slave input, and so on. The final slave  output  is  connected  to  the  master  input.  Each slave sends out, during a second group of clock pulses, an  exact  copy  of  what  was  received  during  the  first group  of  clock  pulses.  The  whole  chain  acts  as  one large  communication  shift  register.  The  daisy-chain feature only requires a single Slave Select line from the master device connected to all slave devices (alternately,  the  slave  devices  can  be  configured  to ignore the Slave Select line by setting the SSET bit). In a  typical  Daisy-Chain  configuration,  the  SCK  signal from  the  master  is  connected  to  each  of  the  slave device SCK inputs. However, the SCK input and output are  separate  signals  selected  by  the  PPS  control. When the PPS selection is made to configure the SCK input and SCK output on separate pins then, the SCK output  will  follow  the  SCK  input,  allowing  for  SCK signals to be daisy-chained like the SDO/SDI signals.",
    "32.6.5 DAISY-CHAIN CONFIGURATION\nFigure 32-12  shows  the  block  diagram  of  a  typical daisy-chain  connection,  and  Figure 32-13  shows  the block  diagram  of  a  daisy-chain  connection  possible using this SPI module.",
    "PIC18(L)F25/26K83\nFIGURE 32-13: SPI DAISY-CHAIN CONNECTION WITH CHAINED SCK",
    "32.7 SPI Operation in Sleep Mode\nSPI Master mode will operate in Sleep, provided the clock source selected by SPIxCLK is active in Sleep mode. FIFOs will operate as they would when the part is  awake.  When  TXR  = 1 ,  the  TXFIFO  will  need  to contain  data  in  order  for  transfers  to  take  place  in Sleep. All  interrupts  will  still  set  the  interrupt  flags  in Sleep but only enabled interrupts will wake the device from Sleep.\nSPI  Slave  mode  will  operate  in  Sleep,  because  the clock is provided by an external master device. FIFOs will  still  operate  and interrupts will set interrupt flags, and enabled interrupts will wake the device from Sleep.",
    "32.8 SPI Interrupts\nThere  are  three  top  level  SPI  interrupts  in  the  PIRx register:\n\u00b7 SPI Transmit\n\u00b7 SPI Receive\n\u00b7 SPI Module status\nThe status interrupts are enabled at the module level in the SPIxINTE register. Only enabled status interrupts will cause the single top level SPIxIF flag to be set.",
    "32.8.1 SPI RECEIVER DATA INTERRUPT\nThe SPI Receiver Data Interrupt is set when RXFIFO contains  data,  and  is  cleared  when  the  RXFIFO  is empty. The interrupt flag SPI1RXIF is located in PIRx and the interrupt enable SPI1RXIE is located in PIEx. This interrupt flag is read-only.",
    "32.8.2 SPI TRANSMITTER DATA INTERRUPT\nThe SPI Transmitter Data Interrupt is set when TXFIFO is not full, and is cleared when the TXFIFO is full. The interrupt  flag  SPI1TXIF  is  located  in  PIRx  and  the interrupt  enable  SPI1TXIE  is  located  in  PIEx.  The interrupt flag is read-only.",
    "32.8.3 SPI MODULE STATUS INTERRUPTS\nThe SPIxIF flag in  the  respective  PIR  register  is  set when any of the individual status flags in SPIxINTF and their respective SPIxINTE bits are set. In order for the setting of any specific interrupt flag to interrupt normal program flow both the SPIxIE bit as well as the specific bit in SPIxINTE associated with that interrupt must be set.\nThe Status Interrupts are:\n\u00b7 Shift Register Empty Interrupt\n\u00b7 Transfer Counter is Zero Interrupt\n\u00b7 Start of Slave Select Interrupt\n\u00b7 End of Slave Select Interrupt\n\u00b7 Receiver Overflow Interrupt\n\u00b7 Transmitter Underflow Interrupt",
    "32.8.3.1 Shift Register Empty Interrupt\nThe Shift Register Empty interrupt flag and enable are the SRMTIF  and  SRMTIE  bits,  respectively.  This interrupt is only available in Master mode and triggers when a data transfer completes and conditions are not present to start a new transfer, as dictated by the TXR and RXR bits (see Table 32-1 for conditions for starting a new Master mode data transfer with different TXR/ RXR settings). This interrupt will be triggered at the end of the last full bit period, after SCK has been low for one \u00bd-baud period. See Figure 32-14 for more details of the timing of this interrupt as well as other interrupts. This  bit  will  not  clear  itself  when  the  conditions  for starting a new transfer occur, and must be cleared in software.",
    "32.8.3.2 Transfer Counter is Zero Interrupt\nThe transfer counter is zero interrupt flag and enable are  the  TCZIF  and  TCZIE  bits,  respectively.  This interrupt will trigger when the transfer counter (defined by BMODE, SPIxTCTH/L and SPIxTWIDTH) decrements  from  one  to  zero.  See  Figure 32-14  for more details on the timing of this interrupt as well as other interrupts. This bit must be cleared in software.\nNote:\nThe  TCZIF  flag  only  indicates  that  the transfer  counter  has  decremented  from one to zero, and may not indicate that the entire data transfer process is complete. Either poll the BUSY bit of SPIxCON2 and wait  for  it  to  be  cleared  or  use  the  Shift Register  Empty  Interrupt  (SRMTIF)  to determine if a data transfer is fully complete.",
    "32.8.3.3 Start of Slave Select and End of Slave Select Interrupts\nThe start of Slave Select interrupt flag and enable are the SOSIF and SOSIE bits, respectively, and the end of Slave Select interrupt flag and enable are similarly des -ignated by the EOSIF and EOSIE bits. These interrupts trigger  at  the  leading  and  trailing  edges  of  the  Slave Select input. Note that the interrupts are active in both master and Slave mode, and will trigger on transitions of the Slave Select input regardless of which mode the SPI is in. In Master mode, PPS should be used to route the  Slave  Select  input  to  the  same  pin  as  the  Slave Select  output,  allowing  these  interrupts  to  trigger  on changes to the Slave Select output. Also note that in Slave mode, changing the SSET bit can trigger these interrupts,  as  it  changes  the  effective  input  value  of Slave Select. Both SOSIF and EOSIF must be cleared in software",
    "32.8.3.4 Receiver Overflow and Transmitter Underflow Interrupts\nThe  receiver  overflow  interrupt  triggers  if data  is received when the RXFIFO is already full and RXR = 1 . In this case, the data will be discarded and the RXOIF bit will be set. The receiver overflow interrupt flag is the RXOIF bit of SPIxINTF. The receiver overflow interrupt enable bit is the RXOIE bit of SPIxINTE.\nThe Transmitter  Underflow  interrupt  flag  triggers  if  a data transfer begins  when the TXFIFO is empty and TXR = 1 . In this case, the most recently received data will be transmitted and the TXUIF bit will be set. The transmitter underflow interrupt flag is the TXUIF bit of SPIxINTF. The transmitter underflow interrupt enable bit is the TXUIE bit of SPIxINTE.\nBoth of these interrupts will only occur in Slave mode, as Master mode will not allow the RXFIFO to overflow or the TXFIFO to underflow.",
    "REGISTER 32-1: SPIxINTF: SPI INTERRUPT FLAG REGISTER\nR/W/HS-0/0, 1 = R/W/HS-0/0. R/W/HS-0/0, 2 = R/W/HS-0/0. R/W/HS-0/0, 3 = R/W/HS-0/0. R/W/HS-0/0, 4 = U-0. R/W/HS-0/0, 5 = R/W/HS-0/0. R/W/HS-0/0, 6 = R/W/HS-0/0. R/W/HS-0/0, 7 = U-0. SRMTIF, 1 = TCZIF. SRMTIF, 2 = SOSIF. SRMTIF, 3 = EOSIF. SRMTIF, 4 = -. SRMTIF, 5 = RXOIF. SRMTIF, 6 = TXUIF. SRMTIF, 7 = -. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7.",
    "REGISTER 32-1: SPIxINTF: SPI INTERRUPT FLAG REGISTER\nbit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0' HS = Bit can be set by hardware",
    "bit 7 SRMTIF : Shift Register Empty Interrupt Flag bit\nSlave mode:\nThis bit is ignored\nMaster mode:\n1 = The data transfer is complete\n0 = Either no data transfers have occurred or a data transfer is in progress",
    "bit 6 TCZIF : Transfer Counter is Zero Interrupt Flag bit\n1 = The transfer counter (as defined by BMODE in Register 32-7, TCNTH/L, and TWIDTH) has dec - remented to zero\n0 = No interrupt pending",
    "bit 5 SOSIF :   Start of Slave Select Interrupt Flag bit\n1 = SS(in) transitioned from false to true\n0 = No interrupt pending",
    "bit 4 EOSIF : End of Slave Select Interrupt Flag bit\n1 = SS(in) transitioned from true to false\n0 = No interrupt pending",
    "bit 3 Unimplemented : Read as ' 0 '\nbit 2\nRXOIF : Receiver Overflow Interrupt Flag bit\n1 = Data transfer completed when RXBF = 1 (edge triggered) and RXR = 1\n0 = No interrupt pending\nbit 1\nTXUIF : Transmitter Underflow Interrupt Flag bit\n1 = Slave Data transfer started when TXBE = 1 and TXR = 1\n0 = No interrupt pending",
    "REGISTER 32-2: SPIxINTE: SPI INTERRUPT ENABLE REGISTER\nSRMTIE, R/W-0/0 = TCZIE. SRMTIE, R/W-0/0 = SOSIE. SRMTIE, R/W-0/0 = EOSIE. SRMTIE, U-0 = -. SRMTIE, R/W-0/0 = RXOIE. SRMTIE, R/W-0/0 = TXUIE. SRMTIE, U-0 = -. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0",
    "REGISTER 32-2: SPIxINTE: SPI INTERRUPT ENABLE REGISTER\nLegend:, 1 = . Legend:, 2 = . R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'\nbit 7\nSRMTIE : Shift Register Empty Interrupt Enable bit\n1 = Enables the Shift Register Empty Interrupt\n0 = Disables the Shift Register Empty Interrupt\nbit 6\nTCZIE : Transfer Counter is Zero Interrupt Enable bit\n1 = Enables the Transfer Counter is Zero Interrupt\n0 = Disables the Transfer Counter is Zero Interrupt\nbit 5\nSOSIE :   Start of Slave Select Interrupt Enable bit\n1 = Enables the Start of Slave Select Interrupt\n0 = Disables the Start of Slave Select Interrupt\nbit 4\nEOSIE : End of Slave Select Interrupt Enable bit\n1 = Enables the End of Slave Select Interrupt\n0 = Disables the End of Slave Select Interrupt\nbit 3 Unimplemented : Read as ' 0 '\nbit 2\nRXOIE : Receiver Overflow Interrupt Enable bit\n1 = Enables the Receiver Overflow Interrupt\n0 = Disables the Receiver Overflow Interrupt\nbit 1\nTXUIE : Transmitter Underflow Interrupt Enable bit\n1 = Enables the Transmitter Underflow Interrupt",
    "REGISTER 32-2: SPIxINTE: SPI INTERRUPT ENABLE REGISTER\n0 = Disables the Transmitter Underflow Interrupt\nbit 0 Unimplemented : Read as ' 0 '",
    "REGISTER 32-3: SPIxTCNTL - SPI TRANSFER COUNTER LSB REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. TCNT7, 1 = TCNT6. TCNT7, 2 = TCNT5. TCNT7, 3 = TCNT4. TCNT7, 4 = TCNT3. TCNT7, 5 = TCNT2. TCNT7, 6 = TCNT1. TCNT7, 7 = TCNT0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit",
    "REGISTER 32-3: SPIxTCNTL - SPI TRANSFER COUNTER LSB REGISTER\n0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'",
    "bit 7-0 TCNT<7:0> :\nBMODE = 0\nBits 10-3 of the Transfer Counter, counting the total number of bits to transfer BMODE = 1\nBits 7-0 of the Transfer Counter, counting the total number of bytes to transfer\nNote: This register should not be written to while a transfer is in progress (BUSY bit of SPIxCON2 is set).",
    "REGISTER 32-4: SPIxTCNTH: SPI TRANSFER COUNTER MSB REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = TCNT10. -, 6 = TCNT9. -, 7 = TCNT8. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'",
    "REGISTER 32-4: SPIxTCNTH: SPI TRANSFER COUNTER MSB REGISTER\nbit 7-3 Unimplemented : Read as ' 0 '\nbit 2-0 TCNT<10:8> :\nBMODE = 0\nBits 13-11 of the Transfer Counter, counting the total number of bits to transfer\nBMODE = 1\nBits 10-8 of the Transfer Counter, counting the total number of bytes to transfer\nNote: This register should not be written to while a transfer is in progress (BUSY bit of SPIxCON2 is set).",
    "REGISTER 32-5: SPIxTWIDTH: SPI TRANSFER WIDTH REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = TWIDTH2. -, 6 = TWIDTH1. -, 7 = TWIDTH0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'",
    "REGISTER 32-5: SPIxTWIDTH: SPI TRANSFER WIDTH REGISTER\nbit 7-3 Unimplemented : Read as ' 0 '\nbit 2-0 TWIDTH<2:0> :\nBMODE = 0\nBits 2-0 of the Transfer Counter, counting the total number of bits to transfer\nBMODE = 1\nSize (in bits) of each transfer counted by the transfer counter\n111 = 7 bits\n110 = 6 bits\n= 5 bits\n101\n100 = 4 bits\n011 = 3 bits\n010 = 2 bits\n001 = 1 bit\n000 = 8 bits\nNote: This register should not be written to while a transfer is in progress (BUSY bit of SPIxCON2 is set).",
    "REGISTER 32-6: SPIxBAUD: SPI BAUD RATE REGISTER\nBAUD7, R/W-0/0 = BAUD6. BAUD7, R/W-0/0 = BAUD5. BAUD7, R/W-0/0 = BAUD4. BAUD7, R/W-0/0 = BAUD3. BAUD7, R/W-0/0 = BAUD2. BAUD7, R/W-0/0 = BAUD1. BAUD7, R/W-0/0 = BAUD0. bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "REGISTER 32-6: SPIxBAUD: SPI BAUD RATE REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'\nbit 7-0\nBAUD<7:0> : Baud Clock Prescaler Select bits\nSCK high or low time: TSC=SPI Clock Period*(BAUD+1)\nSCK toggle frequency: FSCK=FBAUD= SPI Clock Frequency/(2*(BAUD+1))\nNote:\nThis register should not be written while the SPI is enabled (EN bit of SPIxCON0 = 1 )",
    "REGISTER 32-7: SPIxCON0: SPI CONFIGURATION REGISTER 0\nEN, U-0 = -. EN, U-0 = -. EN, U-0 = -. EN, U-0 = -. EN, R/W-0/0 = LSBF. EN, R/W-0/0 = MST. EN, R/W-0/0 = BMODE. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'",
    "bit 7 EN : SPI Module Enable Control bit\n1 = SPI is enabled\n0 = SPI is disabled,\nbit 6-3\nUnimplemented : Read as ' 0 '\nbit 2\nLSBF : LSb-First Data Exchange bit\n1 = Data is exchanged LSb first\n0 = Data is exchanged MSb first (traditional SPI operation)\nbit 1\nMST : SPI Operating Mode Master Select bit\n1 = SPI module operates as the bus master\n0 = SPI module operates as a bus slave\nbit 0\nBMODE : Bit-Length Mode Select bit\n1 =  SPIxTWIDTH setting applies to every byte: total bits sent is SPIxTWIDTH*SPIxTCNT, end-of- packet occurs when SPIxTCNT = 0\n0 = SPIxTWIDTH setting applies only to the last byte exchanged; total bits sent is SPIxTWIDTH + (SPIxTCNT*8)\nNote: This register should only be written when the EN bit is cleared, or to clear the EN bit.",
    "REGISTER 32-8: SPIxCON1: SPI CONFIGURATION REGISTER 1\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = R/W-1/1. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. SMP, 1 = CKE. SMP, 2 = CKP. SMP, 3 = FST. SMP, 4 = -. SMP, 5 = SSP. SMP, 6 = SDIP. SMP, 7 = SDOP. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 32-8: SPIxCON1: SPI CONFIGURATION REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'",
    "bit 7 SMP : SPI Input Sample Phase Control bit\nSlave mode:\n1 = Reserved\n0 = SDI input is sampled in the middle of data output time\nMaster mode:\n1 = SDI input is sampled at the end of data output time\n0 = SDI input is sampled in the middle of data output time",
    "bit 6\nCKE : Clock Edge Select bit\n1 = Output data changes on transition from active to idle clock state\n0 = Output data changes on transition from idle to active clock state",
    "bit 5\nCKP : Clock Polarity Select bit\n1 = Idle state for SCK is high level\n0 = Idle state for SCK is low level",
    "bit 4 FST : Fast Start Enable bit\nSlave mode:\nThis bit is ignored",
    "Master mode:\n1 = Delay to first SCK may be less than \u00bd baud period\n0 = Delay to first SCK will be at least \u00bd baud period",
    "bit 2\nSSP : SS Input/Output Polarity Control bit\n1 = SS is active-low\n0 = SS is active-high",
    "bit 1\nSDIP : SDI Input Polarity Control bit\n1 = SDI input is active-low\n0 = SDI input is active-high",
    "bit 0\nSDOP : SDI Output Polarity Control bit\n1 = SDO output is active-low\n0 = SDO output is active-high",
    "REGISTER 32-9: SPIxCON2: SPI CONFIGURATION REGISTER 2\nBUSY, R-0/0 = SSFLT. BUSY, U-0 = -. BUSY, U-0 = -. BUSY, U-0 = -. BUSY, R/W-0/0 = SSET. BUSY, R/W-0/0 = TXR (1). BUSY, R/W-0/0 = RXR (1). bit 7 bit 0, R-0/0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0",
    "REGISTER 32-9: SPIxCON2: SPI CONFIGURATION REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'",
    "bit 7 BUSY : SPI Module Busy Status bit\n1 = Data exchange is busy\n0 = Data exchange is not taking place\nbit 6\nSSFLT : SS(in) Fault Status bit\nIf SSET = 0\n- 1 = SS(in) ended the transaction unexpectedly, and the data byte being received was lost\n0 = SS(in) ended normally\nIf SSET = 1\nThis bit is unchanged.",
    "bit 5-3 Unimplemented : Read as ' 0 '\nbit 2\nSSET\n: Slave Select Enable bit\nMaster mode:\n1 = SS(out) is driven to the active state continuously\n0 = SS(out) is driven to the active state while the transmit counter is not zero\nSlave mode:\n1 = SS(in) is ignored and data is clocked on all SCK(in) (as though SS = TRUE at all times)\n0 = SS(in) enables/disables data input and tri-states SDO if the TRIS bit associated with the SDO pin is set (see Table 32-2 for details)\nbit 1 TXR : Transmit Data-Required Control bit (1)\n1 = TxFIFO data is required for a transfer\n0 = TxFIFO data is not required for a transfer\nbit 0 RXR : Receive FIFO Space-Required Control bit (1)",
    "bit 5-3 Unimplemented : Read as ' 0 '\n1 = Data transfers are suspended if the RxFIFO is full\n0 = Received data is not stored in the FIFO\nNote 1: See Table 32-1 as well as Section 32.5 'Master mode' and Section 32.6 'Slave Mode' for more details pertaining to TXR and RXR function.\n2: This register should not be written to while a transfer is in progress (BUSY bit of SPIxCON2 is set).",
    "REGISTER 32-10: SPIxSTATUS: SPI STATUS REGISTER\nR/C/HS-0/0, 1 = U-0. R/C/HS-0/0, 2 = R-1/1. R/C/HS-0/0, 3 = U-0. R/C/HS-0/0, 4 = R/C/HS-0/0. R/C/HS-0/0, 5 = S-0/0. R/C/HS-0/0, 6 = U-0. R/C/HS-0/0, 7 = R-0/0. TXWE, 1 = -. TXWE, 2 = TXBE. TXWE, 3 = -. TXWE, 4 = RXRE. TXWE, 5 = CLRBF. TXWE, 6 = -. TXWE, 7 = RXBF. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 32-10: SPIxSTATUS: SPI STATUS REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0' C = Clearable bit S = Settable bit HS = Bit can be set by hardware\nbit 7\nTXWE : Transmit Buffer Write Error bit\n1 = SPIxTxB was written while TxFIFO was full\n0 = No error has occurred",
    "bit 6 Unimplemented : Read as ' 0 '\nbit 5\nTXBE\n: Transmit Buffer Empty bit (read-only)\n1 = Transmit buffer TxFIFO is empty\n0 = Transmit buffer is not empty",
    "bit 4 Unimplemented : Read as ' 0 '\nbit 3\nRXRE\n: Receive Buffer Read Error bit\n1 = SPIxRB was read while RxFIFO was empty\n0 = No error has occurred\nbit 2\nCLRBF : Clear Buffer Control bit (write only)\n1 = Reset the receive and transmit buffers, making both buffers empty\n0 = Take no action",
    "bit 0 RXBF : Receive Buffer Full bit (read-only)\n1 = Receive buffer is full\n0 = Receive buffer is not full",
    "REGISTER 32-11: SPIxRxB: SPI READ BUFFER REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. RXB7, 1 = RXB6. RXB7, 2 = RXB5. RXB7, 3 = RXB4. RXB7, 4 = RXB3. RXB7, 5 = RXB2. RXB7, 6 = RXB1. RXB7, 7 = RXB0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 32-11: SPIxRxB: SPI READ BUFFER REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'",
    "bit 7-0 RXB<7:0> : Receiver Buffer bits (read-only)\nIf RX buffer is not empty:\nContains  the  top-most  byte  of  RXFIFO,  and  reading  this  register  will  remove  the  top-most  byte RXFIFO and decrease the occupancy of the RXFIFO",
    "If RX buffer is empty:\nReading  this  register  will  read  as  ' 0 ',  leave  the  occupancy  unchanged,  and  set  the  RXRE  bit  of SPIxSTATUS",
    "REGISTER 32-12: SPIxTxB: SPI TRANSMIT BUFFER REGISTER\nTXB7, W-0 = TXB6. TXB7, W-0 = TXB5. TXB7, W-0 = TXB4. TXB7, W-0 = TXB3. TXB7, W-0 = TXB2. TXB7, W-0 = TXB1. TXB7, W-0 = TXB0. bit 7, W-0 = bit 7. bit 7, W-0 = bit 7. bit 7, W-0 = bit 7. bit 7, W-0 = bit 7. bit 7, W-0 = bit 7. bit 7, W-0 = bit 7. bit 7, W-0 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'\nbit 7-0 TXB<7:0> : Transmit Buffer bits (write only)\nIf TXFIFO is not full:",
    "REGISTER 32-12: SPIxTxB: SPI TRANSMIT BUFFER REGISTER\nWriting to this register adds the data to the top of the TXFIFO and increases the occupancy of the TXFIFO write pointer",
    "If TXFIFO is full:\nWriting to this register does not affect the data in the TXFIFO or the write pointer, and the TXWE bit of SPIxSTATUS will be set",
    "REGISTER 32-13: SPIxCLK: SPI CLOCK SELECTION REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = CLKSEL3. -, 5 = CLKSEL2. -, 6 = CLKSEL1. -, 7 = CLKSEL0. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 32-13: SPIxCLK: SPI CLOCK SELECTION REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'",
    "bit 7-4 Unimplemented : Read as ' 0 '\nbit 3-0 CLKSEL<3:0> : SPI Clock Source Selection bits\n1111-1001 = Reserved\n1000 = SMT_match\n0111 = TMR6_Postscaled\n0110 = TMR4_Postscaled\n0101 = TMR2_Postscaled\n0100 = TMR0_overflow\n0011 = CLKREF\n0010 = MFINTOSC\n0001 = HFINTOSC\n0000 = FOSC",
    "TABLE 32-3: SUMMARY OF REGISTERS ASSOCIATED WITH SPI\nSPIxINTF, Bit 7 = SRMTIF. SPIxINTF, Bit 6 = TCZIF. SPIxINTF, Bit 5 = SOSIF. SPIxINTF, Bit 4 = EOSIF. SPIxINTF, Bit 3 = -. SPIxINTF, Bit 2 = RXOIF. SPIxINTF, Bit 1 = TXUIF. SPIxINTF, Bit 0 = -. SPIxINTF, Register on page = 521. SPIxINTE, Bit 7 = SRMTIE. SPIxINTE, Bit 6 = TCZIE. SPIxINTE, Bit 5 = SOSIE. SPIxINTE, Bit 4 = EOSIE. SPIxINTE, Bit 3 = -. SPIxINTE, Bit 2 = RXOIE. SPIxINTE, Bit 1 = TXUIE. SPIxINTE, Bit 0 = -. SPIxINTE, Register on page = 522. SPIxTCNTH, Bit 7 = -. SPIxTCNTH, Bit 6 = -. SPIxTCNTH, Bit 5 = -.",
    "TABLE 32-3: SUMMARY OF REGISTERS ASSOCIATED WITH SPI\nSPIxTCNTH, Bit 4 = -. SPIxTCNTH, Bit 3 = -. SPIxTCNTH, Bit 2 = TCNT10. SPIxTCNTH, Bit 1 = TCNT9. SPIxTCNTH, Bit 0 = TCNT8. SPIxTCNTH, Register on page = 523. SPIxTCNTL, Bit 7 = TCNT7. SPIxTCNTL, Bit 6 = TCNT6. SPIxTCNTL, Bit 5 = TCNT5. SPIxTCNTL, Bit 4 = TCNT4. SPIxTCNTL, Bit 3 = TCNT3. SPIxTCNTL, Bit 2 = TCNT2. SPIxTCNTL, Bit 1 = TCNT1. SPIxTCNTL, Bit 0 = TCNT0. SPIxTCNTL, Register on page = 522. SPIxTWIDTH, Bit 7 = -. SPIxTWIDTH, Bit 6 = -. SPIxTWIDTH, Bit 5 = -. SPIxTWIDTH, Bit 4 = -.",
    "TABLE 32-3: SUMMARY OF REGISTERS ASSOCIATED WITH SPI\nSPIxTWIDTH, Bit 3 = -. SPIxTWIDTH, Bit 2 = TWIDTH2. SPIxTWIDTH, Bit 1 = TWIDTH1. SPIxTWIDTH, Bit 0 = TWITDH0. SPIxTWIDTH, Register on page = 523. SPIxBAUD, Bit 7 = BAUD7. SPIxBAUD, Bit 6 = BAUD6. SPIxBAUD, Bit 5 = BAUD5. SPIxBAUD, Bit 4 = BAUD4. SPIxBAUD, Bit 3 = BAUD3. SPIxBAUD, Bit 2 = BAUD2. SPIxBAUD, Bit 1 = BAUD1. SPIxBAUD, Bit 0 = BAUD0. SPIxBAUD, Register on page = 524. SPIxCON0, Bit 7 = EN. SPIxCON0, Bit 6 = -. SPIxCON0, Bit 5 = -. SPIxCON0, Bit 4 = -. SPIxCON0, Bit 3 = -. SPIxCON0, Bit 2 = LSBF.",
    "TABLE 32-3: SUMMARY OF REGISTERS ASSOCIATED WITH SPI\nSPIxCON0, Bit 1 = MST. SPIxCON0, Bit 0 = BMODE. SPIxCON0, Register on page = 524. SPIxCON1, Bit 7 = SMP. SPIxCON1, Bit 6 = CKE. SPIxCON1, Bit 5 = CKP. SPIxCON1, Bit 4 = FST. SPIxCON1, Bit 3 = -. SPIxCON1, Bit 2 = SSP. SPIxCON1, Bit 1 = SDIP. SPIxCON1, Bit 0 = SDOP. SPIxCON1, Register on page = 525. SPIxCON2, Bit 7 = BUSY. SPIxCON2, Bit 6 = SSFLT. SPIxCON2, Bit 5 = -. SPIxCON2, Bit 4 = -. SPIxCON2, Bit 3 = -. SPIxCON2, Bit 2 = SSET. SPIxCON2, Bit 1 = TXR. SPIxCON2, Bit 0 = RXR. SPIxCON2, Register on page = 526. SPIxSTATUS, Bit 7 = TXWE.",
    "TABLE 32-3: SUMMARY OF REGISTERS ASSOCIATED WITH SPI\nSPIxSTATUS, Bit 6 = -. SPIxSTATUS, Bit 5 = TXBE. SPIxSTATUS, Bit 4 = -. SPIxSTATUS, Bit 3 = RXRE. SPIxSTATUS, Bit 2 = CLRBF. SPIxSTATUS, Bit 1 = -. SPIxSTATUS, Bit 0 = RXBF. SPIxSTATUS, Register on page = 527. SPIxRXB, Bit 7 = RXB7. SPIxRXB, Bit 6 = RXB6. SPIxRXB, Bit 5 = RXB5. SPIxRXB, Bit 4 = RXB4. SPIxRXB, Bit 3 = RXB3. SPIxRXB, Bit 2 = RXB2. SPIxRXB, Bit 1 = RXB1. SPIxRXB, Bit 0 = RXB0. SPIxRXB, Register on page = 527. SPIxTXB, Bit 7 = TXB7. SPIxTXB, Bit 6 = TXB6.",
    "TABLE 32-3: SUMMARY OF REGISTERS ASSOCIATED WITH SPI\nSPIxTXB, Bit 5 = TXB5. SPIxTXB, Bit 4 = TXB4. SPIxTXB, Bit 3 = TXB3. SPIxTXB, Bit 2 = TXB2. SPIxTXB, Bit 1 = TXB1. SPIxTXB, Bit 0 = TXB0. SPIxTXB, Register on page = 528. SPIxCLK, Bit 7 = -. SPIxCLK, Bit 6 = -. SPIxCLK, Bit 5 = -. SPIxCLK, Bit 4 = -. SPIxCLK, Bit 3 = CLKSEL3. SPIxCLK, Bit 2 = CLKSEL2. SPIxCLK, Bit 1 = CLKSEL1. SPIxCLK, Bit 0 = CLKSEL0. SPIxCLK, Register on page = 528\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are unused by the SPI module.",
    "33.0 I 2 C MODULE\nThe device has two dedicated, independent I 2 C modules. Figure 33-1 is a block diagram of the I 2 C interface module. The figure shows both the Master and Slave modes together.",
    "33.1 I 2 C Features\n\u00b7 Inter-Integrated Circuit (I 2 C) interface supports the following modes in hardware:\n-Master mode\n-Slave mode with byte NACKing\n-Multi-Master mode\n\u00b7 Dedicated Address, Receive and Transmit buffers\n\u00b7 Up to four slave addresses matching\n\u00b7 General Call address matching\n\u00b7 7-bit and 10-bit addressing with masking\n\u00b7 Start, Restart, Stop, Address, Write, and ACK Interrupts\n\u00b7 Clock Stretching hardware for:\n-RX Buffer Full\n-TX Buffer Empty\n-After Address, Write, and ACK\n\u00b7 Bus Collision Detection with arbitration\n\u00b7 Bus Timeout Detection",
    "33.2 I 2 C Module Overview\nThe  I 2 C  module  provides  a  synchronous  interface between the microcontroller and other I 2 C-compatible devices  using  the  two-wire  I 2 C  serial  bus.  Devices communicate in a master/slave environment. The I 2 C bus specifies two signal connections:\n\u00b7 Serial Clock (SCL)\n\u00b7 Serial Data (SDA)\nBoth the SCL and SDA connections are bidirectional open-drain lines, each requiring pull-up resistors to the supply voltage. Pulling the line to ground is considered a logical zero and letting the line float is considered a logical one. Every transaction on the I 2 C bus has to be initiated by the master.\nFigure 33-2  shows  a  typical  connection  between  a master and more than one slave.\n\u00b7 SDA hold time selection\n\u00b7 I 2 C, SMBus 2.0, and SMBus 3.0 input level selections",
    "FIGURE 33-2: I 2 C MASTER/SLAVE CONNECTIONS\nThere are four main operations based on the direction of the data being shared during I 2 C communication.\n\u00b7 Master Transmit (master is transmitting data to a slave)\n\u00b7 Master Receive (master is receiving data from a slave)\n\u00b7 Slave Transmit (slave is transmitting data to a master)\n\u00b7 Slave Receive (slave is receiving data from the master)\nTo  begin  any  I 2 C  communication,  the  master  device sends out a Start bit followed by the address byte of the slave it intends to communicate with. This is followed by a single Read/Write bit, which determines whether the master intends to transmit to or receive data from the slave device.\nIf the requested slave exists on the bus, it will respond with an Acknowledge bit, otherwise known as an ACK. The master then continues to shift data in or out of the slave until it terminates the message with a Stop.\nFurther details about the I 2 C module are discussed in the section below.",
    "33.3 I 2 C Mode Operation\nAll I 2 C communication is 8-bit data and 1-bit acknowledge and shifted out MSb first. The user can control  the  interaction  between  the  software  and  the module  using  several  control  registers  and  interrupt flags. Two pins, SDA and SCL, are exercised by the module to communicate with other external I 2 C devices.",
    "33.3.1 DEFINITION OF I 2 C TERMINOLOGY\nThe  I 2 C  communication  protocol  terminologies  are defined for reference below in Table 33-1. These termi -nologies are used throughout this document. Table 331 has been adapted from the Phillips I 2 C specification.",
    "TABLE 33-1: I 2 C BUS TERMS\nTransmitter, Description = The device which shifts data out onto the bus. Receiver, Description = The device which shifts data in from the bus. Master, Description = The device that initiates a transfer, gen - erates clock signals and terminates a transfer. Slave, Description = The device addressed by the master. Multi-master, Description = A bus with more than one device that can initiate data transfers. Arbitration, Description = Procedure to ensure that only one mas - ter at a time controls the bus. Winning arbitration ensures that the message is not corrupted. Synchronization, Description = Procedure to synchronize the clocks of two or more devices on the bus.. Idle, Description = No master is controlling the bus, and both SDAand SCL lines are high. Active, Description = Any time one or more master devices are controlling the bus. Addressed Slave, Description = Slave device that has received a match - ing address and is actively being clocked by a master. Matching Address, Description = Address byte that is clocked into a slave that matches the value stored in I2CxADR. Write Request, Description = Slave receives a matching address with R/W bit clear and is ready to clock",
    "TABLE 33-1: I 2 C BUS TERMS\nin data. Read Request, Description = Master sends an address byte with the R/W bit set, indicating that it wishes to clock data out of the slave. This data is the next and all following bytes until a Restart or Stop.. Clock Stretching, Description = When a device on the bus holds SCL low to stall communication. Bus Collision, Description = Any time the SDA line is sampled low by the module while it is outputting and expected high state.. Bus Timeout, Description = Any time the I2CBTOISM input transi - tions high, the I 2 C module is reset and the module goes Idle.",
    "33.3.2 BYTE FORMAT\nAll communication in I 2 C is done in 9-bit segments. A byte is sent from a master to a slave or vice-versa, fol -lowed by an Acknowledge bit sent by the receiver. After the 8th falling edge of the SCL line, the device transmit -ting data on the SDA line releases control of that pin to an input, and reads in an acknowledge value on the next clock pulse. The clock signal is provided by the master. Data is valid to change while the SCL line is low,  and  sampled  on  the  rising  edge  of  the  clock. Changes on the SDA line while the SCL line is high define Start and Stop conditions on the bus which are explained further in the chapter.",
    "33.3.3 SDA AND SCL PINS\nThe  user  must  configure  these  pins  as  open-drain outputs. This is done by clearing the appropriate TRIS bits and setting the appropriate ODCON bits. The user may also select the input threshold, slew-rate and inter -nal pull-up settings using the RxyI2C control registers (Register 16-9).",
    "33.3.4 SDA HOLD TIME\nThe  hold  time  of  the  SDA  pin  is  selected  by  the SDAHT<1:0> bits of the I2CxCON2 register. Hold time is the time SDA is held valid after the falling edge of SCL. A longer hold time setting may help on buses with large capacitance.",
    "33.3.5 START CONDITION\nThe  I 2 C  specification  defines  a  Start  condition  as  a transition of SDA line from a high to a low state while SCL line is high. A Start condition is always generated by  the  master  and  signifies  the  transition  of  the  bus from  an  Idle  to  an  Active  state.  Figure 33-3  shows waveforms for Start conditions. Master hardware waits for the BFRE bit of I2CxSTAT0 to be set, before assert -ing a Start condition on the SCL and SDA lines. If two masters assert a start at the same time, a collision will occur during the addressing phase.",
    "33.3.6 STOP CONDITION\nA Stop condition is a transition of the SDA line from low to high while the SCL line is high. Figure 33-3 shows waveforms for Stop conditions.",
    "FIGURE 33-3: START AND STOP CONDITIONS\nNote:\nAt  least  one  SCL  low  time  must  appear before  a  Stop  is  valid.  Therefore,  if  the SDA line goes low then high again while the SCL line is high, only the Start condi -tion is detected.",
    "33.3.7 RESTART CONDITION\nA Restart is valid any time that a Stop would be valid. A master can issue a Restart if it wishes to hold the bus after terminating the current transfer. A Restart has the same effect on the slave that a Start would, resetting all slave logic and preparing it to clock in an address. The master  may  want  to  address  the  same  or  another slave.  Figure 33-4 shows the waveform for a Restart condition.\nIn 10-bit Addressing Slave mode a Restart is required for the master to clock data out of the addressed slave. Once a slave has been fully addressed, matching both high and low address bytes (SMA = 1 ), the master can issue a Restart and the high address byte with the R/W bit set. The slave logic will then hold the clock and pre -pare to clock out data.",
    "33.3.8 ACKNOWLEDGE SEQUENCE\nThe ninth SCL pulse for any transferred byte in I 2 C is dedicated  as  an  Acknowledge.  It  allows  receiving devices to respond back to the transmitter by pulling the SDA line low. The transmitter must release control of the line during this time to shift in the response. The Acknowledge (ACK) is an active-low signal, pulling the SDA line low indicates to the transmitter that the device has  received  the  transmitted  data  and  is  ready  to receive more.\nThe result of an ACK is placed in the ACKSTAT bit of the  I2CxCON1 register. The ACKSTAT  bit  is  cleared when the receiving device sends an Acknowledge and is  set  when  the  receiving  device  does  not Acknowl -edge. A slave sends an Acknowledge when it has rec -ognized its address. When in a mode that is receiving data,  the  ACK  data  being  sent  to  the  transmitter depends on the value of I2CxCNT register. ACKDT is the value sent when I2CxCNT! = 0 . When I2CxCNT = 0 , the ACKCNT value is used instead.",
    "33.3.8 ACKNOWLEDGE SEQUENCE\nIn Slave mode, if the ADRIE or WRIE bits are set, clock stretching is initiated when there is an address match or  when  there  is  an  attempt  to  write  to  slave.  This allows the user to set the ACK value sent back to the transmitter. The ACKDT bit of the I2CxCON1 register is set/cleared to determine the response. Slave hardware will generate an ACK response if the ADRIE or WRIE bits are clear.\nCertain conditions will cause a not-ACK (NACK) to be sent automatically. If any of the RXRE, TXRE, RXO, or TXU bits  is  set,  the  hardware  response  is  forced  to NACK. All subsequent responses from the device for address matches or data will be a NACK response.",
    "33.3.9 BUS TIME-OUT\nThe I2CxBTO register can be used to select the time -out  source  for  the  module.  The  I 2 C  module  is  reset when the selected bus time out signal goes high. This feature is useful for SMBus and PMBus\u2122 compatibility.\nFor example, Timer2 can be selected as the bus time -out source and configured to count when the SCL pin is low. If the timer runs over before the SCL pin transi -tioned high, the timer-out pulse will reset the module.\nIf the module is configured as a slave and a BTO event occurs when the slave is active (i.e., the SMA bit is set), the module is immediately reset. The SMA and CSTR bits are also cleared, and the BTOIF bit is set.",
    "33.3.9 BUS TIME-OUT\nIf a BTO event occurs when the module is configured as a master and is active, (i.e., MMA bit is set), and the module immediately tries to assert a Stop condition and also sets the BTOIF bit. The actual generation of the Stop condition may be delayed if the bus is been clock stretched by some slave device. The MMA bit will be cleared only after the Stop condition is generated.",
    "33.3.10 ADDRESS BUFFERS\nThe  I 2 C  module  has  two  address  buffer  registers, I2CxADB0 and I2CxADB1. Depending on the mode, these registers are used as either receive or transmit address buffers. See Table 33-2 for data flow directions in these registers. In Slave modes, these registers are only  updated  when  there  is  an  address  match.  The ADB bit in the I2CxCON2 register is used to enable/dis -able  the  address  buffer  functionality.  When  disabled, the address data is sourced from the transmit buffer and is stored in the receive buffer.",
    "TABLE 33-2: ADDRESS BUFFER DIRECTION AS PER I 2 C MODE\nSlave (7-bit), MODE<2:0> = 000. Slave (7-bit), I2CxADB0 = RX. Slave (7-bit), I2CxADB1 = -. , MODE<2:0> = 001. , I2CxADB0 = RX. , I2CxADB1 = -. Slave (10-bit), MODE<2:0> = 010. Slave (10-bit), I2CxADB0 = RX. Slave (10-bit), I2CxADB1 = RX. , MODE<2:0> = 011. , I2CxADB0 = RX. , I2CxADB1 = RX. Master (7-bit), MODE<2:0> = 100. Master (7-bit), I2CxADB0 = -. Master (7-bit), I2CxADB1 = TX. Master (10-bit), MODE<2:0> = 101. Master (10-bit), I2CxADB0 =",
    "TABLE 33-2: ADDRESS BUFFER DIRECTION AS PER I 2 C MODE\nTX. Master (10-bit), I2CxADB1 = TX. Multi-Master (7-bit), MODE<2:0> = 110. Multi-Master (7-bit), I2CxADB0 = RX. Multi-Master (7-bit), I2CxADB1 = TX. , MODE<2:0> = 111. , I2CxADB0 = RX. , I2CxADB1 = TX",
    "33.3.10.1 Slave Mode (7-bit)\nIn  7-bit  Slave  mode,  I2CxADB0  is  loaded  with  the received matching address and R/W data. The I2CxADB1 register is ignored in this mode.",
    "33.3.10.2 Slave Mode (10-bit)\nIn  10-bit  Slave  mode,  I2CxADB0  is  loaded  with  the lower  eight  bits  of  the  matching  received  address. I2CxADB1  is  loaded  with  full  eight  bits  of  the  high address byte, including the R/W bit.",
    "33.3.10.3 Master Mode (7-bit)\nThe I2CxADB0 register is ignored in this mode. In 7-bit Master mode, the I2CxADB1 register is used to copy address data byte, including the R/W value, to the shift register.",
    "33.3.10.4 Master Mode (10-bit)\nIn  10-bit Master mode, the I2CxADB0 register stores the low address data byte value that will be copied to the shift register after the high address byte is shifted out.  The  I2CxADB1  register  stores  the  high  address byte value that will be copied to the shift register. It is up to the user to specify all eight of these bits, even though the  I 2 C  specification  defines  the  upper  five  bits  as  a constant.",
    "33.3.10.5 Multi-Master Mode (7-bit only)\nIn Multi-Master mode, the device can be both master and slave depending on the sequence of events on the bus.  If  being  addressed  as  a  slave,  the  I2CxADB0 register  stores  the  received  matching  slave  address byte. If the device is trying to communicate as a master on the bus, the contents of the I2CxADB1 register are copied  to  the  shift  register  for  addressing  a  slave device.",
    "33.3.11 RECEIVE AND TRANSMIT BUFFER\nThe receive buffer holds one byte of data while another is  shifted into the SDA pin. The user can access the buffer by software (or DMA) through the I2CxRXB reg -ister. When new data is loaded into the I2CxRXB regis -ter, the receive buffer full Status bit (RXBF) is set and reading the I2CxRXB register clears this bit.\nIf the user tries to read I2CxRXB when it is empty (i.e., RXBF = 0 ), receive read error bit (RXRE) is set and a NACK will be generated. The user must clear the error bit to resume normal operation.\nThe  transmit  buffer  holds  one  byte  of  data  while another can be shifted out through the SDA pin. The user  can  access  the  buffer  by  software  (or  DMA) through the I2CxTXB register. When the I2CxTXB does not contain any transmit data, the transmit buffer empty Status bit (TXBE) is set. At this point, the user can load another byte into the buffer.",
    "33.3.11 RECEIVE AND TRANSMIT BUFFER\nIf the user tries to write I2CxTXB when it is NOT empty (i.e., TXBE = 0 ), transmit write error flag bit (TXRE) is set and the new data is discarded. When TXRE is set, the  user  must  clear  this  error  condition  to  resume normal operation.\nBy setting the CLRBF bit in the I2CxSTAT1 register, the user  can  clear  both  receive  and  transmit  buffers. CLRBF will also clear the I2CxRXIF and I2CxTXIF bits.",
    "33.3.12 CLOCK STRETCHING\nWhen a slave  device  has  not  completed  processing data, it can delay the transfer of more data through the process of clock stretching. An addressed slave device may hold the SCL clock line low after receiving or send -ing a bit, indicating that it is not yet ready to continue. The master will attempt to raise the SCL line in order to transfer the next bit, but will detect that the clock line has not yet been released. Since the SCL connection is open-drain, the slave has the ability to hold the line low until it is ready to continue communicating. Clock stretching allows receivers that cannot keep up with a transmitter to control the flow of incoming data.\nClock  stretching  can  be  enabled  or  disabled  by  the clearing or setting of CSD (clock stretching disable) bit in the I2CxCON1 register. This bit is valid only in the Multi-Master and Slave modes of operation.",
    "33.3.12.1 Clock Stretching for Buffer Operations\nIf enabled, clock stretching is forced during buffer read/ write operations. For example, in Slave mode if RXBF = 1 (receive buffer full), the clock will be stretched after the  seventh  falling  edge  of  SCL.  The  SCL  line  is released only after the user reads data from the receive buffer. This ensures that there is never a receive data overflow. In this situation, if clock stretching is disabled, the RXO bit in I2CxCON1 is set indicating a receive overflow.  When  set,  the  module  will  always  respond with a NACK.\nSimilarly, when TXBE = 1 (transmit buffer empty) and I2CCNT! = 0 , the clock is stretched after the 8th falling edge of SCL. The SCL line is released only after the user  loads  new  data  into  the  transmit  buffer.  This ensures that there is never a transmit underflow. In this situation, if clock stretching is disabled, the TXU bit in I2CxCON1 is set indicating a transmit underflow. When set, the module will always respond with a NACK.",
    "33.3.12.2 Clock Stretching for Other Slave Operations\nThere  are  three  Interrupt  and  Hold  bits  that  provide clock stretching in Slave mode. These bits can also be used in conjunction with the I2CxIE bit in PIRx register to generate system level interrupts.",
    "33.3.12.2 Clock Stretching for Other Slave Operations\n\u00b7 Incoming address match interrupt\n-Clock stretching after an incoming matching address byte is enabled by the Address Inter -rupt and Hold (ADRIE) bit of the I2CxPIE reg -ister. When ADRIE = 1 , the CSTR bit is set and the SCL line is stretched following the 8th falling edge of SCL of a received match -ing address. This allows the user to read the received address from the I2CADB0/1 regis -ters and selectively ACK/NACK based on the received address. Clock stretching from ADRIE is released by software clearing the CSTR bit.\n\u00b7 Data Write Interrupt\n-The data write interrupt and hold enable (WRIE) bit is used to enable clock stretching after a received data byte. When WRIE = 1 , the CSTR bit is set, and the SCL line is stretched, following the 8th falling SCL edge for incoming slave data. This bit allows user software to selectively ACK/NACK each received data byte. Clock stretching from WRIE is released by software clearing the CSTR bit.\n\u00b7 Acknowledge status",
    "33.3.12.2 Clock Stretching for Other Slave Operations\n-The acknowledge status time interrupt and hold enable (ACKTIE) bit is used to enable clock stretching after the ACK phase of a transmission. This bit enables clock stretch -ing for all address/data transactions; address, write, or read. Following the ACK, the slave hardware will set CSTR. Clock stretching from ACKTIE is released by software clearing the CSTR bit.",
    "33.3.13 DATA BYTE COUNT\nThe I2CxCNT register is used to specify the number of bytes in a complete I 2 C packet. The value in this regis -ter will decrement every time a data byte is received or transmitted from the I 2 C module. The I2CxCNT register will not decrement past zero.\nIf a byte transfer causes the I2CxCNT register to dec -rement to zero, the Count Interrupt Flag bit (CNTIF) in I2CxPIR is set. This flag bit is set on the 9 th falling edge of SCL for transmit and receive operations.\nThe I2CxCNT register can be auto-loaded if the ACNT bit in the I2CxCON2 register is set. When ACNT bit is set, the data byte following the address byte is loaded into the I2CxCNT register.",
    "33.3.13 DATA BYTE COUNT\nNote 1: I2CxCNT decrements on the eighth (receive) or ninth (transmit) falling edge of SCL; writes during this bit time can cor -rupt the value.\n2: If the block size of the message is greater than  255,  the  I2CxCNT  register  can  be updated mid-message to prevent decre -ment to zero.",
    "33.4 I 2 C Slave Mode\nThe I 2 C Slave  mode  operates  in  one  of  four  modes selected  in  the  Mode  bits  of  I2CxCON0. The  modes can be divided into 7- and 10-bit Addressing modes. 10-bit Addressing  modes  operate  the  same  as  7-bit with some additional overhead for handling the larger addresses.",
    "33.4.1 SLAVE ADDRESSING MODES\nThe I2CxADR/1/2/3 registers contain the Slave mode addresses.  The  first  byte  received  after  a  Start  or Restart  condition  is  compared  against  the  values stored in these registers. If the byte matches a value, it is  loaded  into  the  I2CxADB0/1  registers.  If  the  value does not match, there is no response from the module. The  I 2 C  module  can  be  configured  in  the  following slave configurations.",
    "33.4.1.1 7-bit Addresses Mode\nIn  this  mode,  the  LSb  of  the  received  data  byte  is ignored when determining if there is an address match. All  four  I2CxADR  registers  are  independently  com -pared to the received address byte.",
    "33.4.1.2 7-bit Addresses with Masking\nIn this mode, the value in I2CxADR0 is masked with the value in I2CxADR1 to determine if an address match occurred. A second address and mask are also com -pared from I2CxADR2/3. When Mode<2:0> = 001 or 111 , the  I2CxADR1/3  registers  serve  as  the  mask value for I2CxADR0/2. All seven bits of the address can be masked",
    "33.4.1.3 10-bit Addresses\nIn  this  mode,  the  values  stored  in  I2CxADR0  and I2CxADR1  registers  are  used  to create a 10-bit address. A second 10-bit compare address is formed from I2CxADR2 and I2CxADR3.",
    "33.4.1.4 10-bit Address with Masking\nNote:\nEven though  10-bit  addressing  calls  out only ten bits used in the address compari -son, all 15 address bits in I2CxADR0/1 are compared in these modes.",
    "33.4.2 GENERAL CALL ADDRESS SUPPORT\nThe addressing procedure for the I 2 C bus is such that the  first  byte  after  the  Start  condition  usually  deter -mines which device will be the slave addressed by the master  device.  The  exception  is  the  general  call address  which  can  address  all  devices.  When  this address is used, all devices should, in theory, respond with an ACK. The general call address is a reserved address in the I 2 C protocol, defined as address 0x00 . In order for the slave hardware to ACK this address, it must  be  enabled  by  setting  the  GCEN  bit  in  the I2CxCON2 register. Setting one of the I2CxADR0/1/2/3 registers to 0x00 is not required. Figure 33-5 shows a General Call reception sequence.",
    "33.4.2 GENERAL CALL ADDRESS SUPPORT\nIn  this  mode,  the  I2CxADR0/1  registers  are  used  to form a 10-bit address, and the I2CxADR2/3 registers are used to form a 10-bit mask for that address. When MODE<2:0> = 011 , the I2CxADR2/3 registers serve as the mask  value  for  the  10-bit  address  stored in I2CxADR0/1.\nIf the  ADRIE bit is set, the module will clock stretch after the eighth SCL pulse just like any other address match.\nGeneral  Call  addressing  is  supported  in\nNote: only 7-bit Addressing modes",
    "33.4.3 SLAVE OPERATION IN 7-BIT ADDRESSING MODE\nThe 8th bit in an address byte transmitted by the mas -ter is used to determine if the master wants to read from or write to the slave device. If set, it denotes that the master wants to read from the slave and if cleared it means the master wants to write to the slave device. If there is an address match, the R/W bit is copied to the R bit of the I2CxSTAT0 register.",
    "33.4.3.1 Slave Reception (7-bit Addressing Mode)\nThis section describes the sequence of events for the I 2 C module configured as an I 2 C slave in 7-bit Address -ing mode and is receiving data. Figure 33-6, Figure 337, and Figure 33-8 are used as a visual reference for this description.",
    "33.4.3.1 Slave Reception (7-bit Addressing Mode)\n1. Master  asserts  Start  condition  (can  also  be  a restart) on the bus. Start condition Interrupt Flag (SCIF) in I2CxPIR register is set.\n2. If Start condition interrupt is enabled (SCIE bit is set), generic interrupt I2CxIF is set.\n3. Master transmits eight bits - 7-bit address and R/W = 0 .\n4. Received address is compared with the values in  I2CxADR0/I2CxADR1/I2CxADR2/I2CxADR3 registers. Refer to section Section 33.4.1 'Slave Addressing Modes' for slave address -ing modes.\n5. If address matches; SMA in I2CxSTAT0 register is set, R/W is copied to R/W bit, D bit is cleared. If the address does not match; module becomes Idle.\n6. The  matched  address  data is loaded into I2CxADB0 (if ABD= 0 )  or  I2CxRXB  (if ABD= 1 ) and ADRIF in I2CxPIR register is set.",
    "33.4.3.1 Slave Reception (7-bit Addressing Mode)\n7. If Address hold interrupt is enabled (ADRIE = 1 ), CSTR is set. I2CxIF is set. Slave software can read address from I2CxADB0 and set/clear ACKDT before releasing SCL.\n8. If there are any previous error conditions (e.g., Receive buffer overflow or transmit buffer under -flow  errors),  slave  will  force  a  NACK  and  the module becomes Idle.\n9. ACKDT  value  is  copied  out  to  SDA  for  ACK pulse to be read by the master on the 9th SCL pulse.\n10. If the Acknowledge interrupt and hold is enabled (ACKTIE = 1 ), CSTR is set, I2CxIF is set, then slave software can read address from I2CxADB0  register  and  change  the  value  of ACKDT  before releasing SCL by clearing CSTR.\n11. Master sends first seven SCL pulses of the data byte or a Stop condition (in the case of NACK).\n12. If Stop condition; PCIF in I2CxPIR register is set,\nmodule becomes Idle.",
    "33.4.3.1 Slave Reception (7-bit Addressing Mode)\n13. If  the  receive  buffer  is  full  from  the  previous transaction  (i.e.,  RXBF  = 1 (I2CxRXIF  = 1 )), CSTR is set. Slave software must read data out of I2CxRXB to resume communication.\n14. Master sends 8th SCL pulse of the data byte. D bit is set, WRIF is set.\n15. I2CxRXB is loaded with new data, RXBF bit is set, I2CxRXIF is set.\n16. If Data  write  interrupt  and  hold  is  enabled (WRIE = 1 ),  CSTR is set, I2CxIF is set. Slave software can read data from I2CxRXB and set/ clear ACKDT before releasing SCL by clearing CSTR.\n17. If I2CxCNT = 0 , the ACKCNT value is output to the SDA; else, if I2CxCNT!= 0 , the ACKDT value is  used  and  the  value  of  I2CxCNT  is  decre -mented.",
    "33.4.3.1 Slave Reception (7-bit Addressing Mode)\n18. The ACK value is copied out to SDA to be read by the master on the 9th SCL pulse.\n19. If I2CxCNT = 0 , CNTIF is set.\n20. If  a  NACK  was  sent,  NACKIF  is  set,  module becomes idle.\n21. If ACKTIE = 1 , CSTR is set, I2CxIF is set. Slave software can read data from I2CxRXB clearing RXBF, before releasing SCL by clearing CSTR.\n22. Go to step 11.",
    "33.4.3.2 Slave Transmission (7-bit Addressing Mode)\nThis section describes the sequence of events for the I 2 C module configured as an I 2 C slave in 7-bit Address -ing  mode  and  is  transmitting  data.  Figure 33-9  and Figure 33-10  are  used  as  a  visual  reference  for  this description.",
    "33.4.3.2 Slave Transmission (7-bit Addressing Mode)\n1. Master  asserts  Start  condition  (can  also  be  a restart) on the bus. Start condition Interrupt Flag (SCIF) in I2CxPIR register is set.\n2. If Start condition interrupt is enabled (SCIE bit is set), generic interrupt I2CxIF is set.\n3. Master transmits eight bits - 7-bit address and R/W = 1 .\n4. Received address is compared with the values in  I2CxADR0/I2CxADR1/I2CxADR2/I2CxADR3 registers. Refer to Section 33.4.1 'Slave Addressing Modes' for Slave  Addressing modes\n5. If address matches; SMA in I2CxSTAT0 register is set, R/W is copied to R bit, D bit is cleared. If the address does not match; module becomes idle.\n6. The  matched  address  data is loaded into I2CxADB0 (if ABD= 0 )  or  I2CxRXB  (if ABD= 1 ) and ADRIF in I2CxPIR register is set.",
    "33.4.3.2 Slave Transmission (7-bit Addressing Mode)\n7. If Address hold interrupt is enabled (ADRIE = 1 ), CSTR is set. I2CxIF is set. Slave software can read address from I2CxADB0 and set/clear  ACKDT  before  releasing  SCL.  SCL line can be released by clearing CSTR.\n8. If the transmit buffer is empty from the previous transaction,  i.e.,  TXBE  = 1 and  I2CxCNT!= 0 (I2CxTXIF  = 1 ),  CSTR  is  set.  Slave  software must  load  data  into  I2CxTXB  to  release  SCL. I2CxCNT decrements  after  the  byte  is  loaded into the shift register.\n9. Slave  hardware  waits  for  9th  SCL  pulse  with ACK data from master.\n10. If I2CxCNT = 0 , CNTIF is set.\n11. If the Acknowledge interrupt and hold is enabled (ACKTIE = 1 ), CSTR is set, I2CxIF is set.\n12. Slave software can change the value of ACKDT before releasing SCL by clearing CSTR.",
    "33.4.3.2 Slave Transmission (7-bit Addressing Mode)\n13. Master sends eight SCL pulses to clock out data or asserts a Stop condition to end the transac -tion.\n14. Go to step 8.",
    "33.4.3.3 Slave operation in 10-bit Addressing Mode\nIn  10-bit Addressing  mode,  the  first  received  byte  is compared to the binary value of ' 11110A9A80 '. A9 and A8 are the two MSb of the 10-bit address. The first byte is compared with the value in I2CxADR1 and I2CxADR3  registers. After  the  high  byte  is  acknowl -edged, the low address byte is clocked in and all eight bits  are  compared  to  the  low  address  value  in  the I2CxADR0 and  I2CxADR2  registers. A  high  and  low address match as a write request is required at the start of  all  10-bit  addressing  communication.  To  initiate  a read,  the  master  needs  to  issue  a  Restart  once  the slave is addressed and clock in the high address with the R/W bit set. The slave hardware will then acknowl -edge the read request and prepare to clock out data. The SMA (slave active) bit is set only when both the high and low address bytes match.",
    "Note:\nAll seven bits of the received high address are compared to the values in the I2CxADR1 and I2CxADR3 registers. The five-bit ' 11110 ' high address format is not enforced by module hardware. It is up to the user to configure these bits correctly.",
    "33.4.3.4 Slave Reception (10-bit Addressing Mode)\nThis section describes the sequence of events for the I 2 C module  configured  as  an  I 2 C  slave  in  10-bit Addressing mode and is receiving data. Figure 33-11 is used as a visual reference for this description.",
    "33.4.3.4 Slave Reception (10-bit Addressing Mode)\n1. Master  asserts  Start  condition  (can  also  be  a restart) on the bus. Start condition Interrupt Flag (SCIF) in I2CxPIR register is set. If Start condi -tion interrupt is enabled (SCIE bit is set), generic interrupt I2CxIF is set.\n2. Master transmits high address byte with R/W = 0 .\n3. The received high address is compared with the values in I2CxADR1 and I2CxADR3 registers.\n4. If high address matches; R/W is copied to R bit, D bit is cleared, high address data is copied to I2CxADB1. If the address does not match; mod -ule becomes idle.\n5. If Address hold interrupt is enabled (ADRIE = 1 ), CSTR is set. I2CxIF is set.\n6. Slave  software  can  read  high  address  from I2CxADB1 and set/clear ACKDT before releas -ing SCL.\n7. ACKDT  value  is  copied  out  to  SDA  for  ACK pulse. SCL line is released by clearing CSTR.",
    "33.4.3.4 Slave Reception (10-bit Addressing Mode)\n8. Master sends ninth SCL pulse for ACK\n9. Slave can force a NACK at this point due to pre -vious error not being cleared. E.g. Receive buf -fer overflow or transmit buffer underflow errors. In  these  cases  the  slave  hardware  forces  a\nNACK and the module becomes Idle.",
    "33.4.3.4 Slave Reception (10-bit Addressing Mode)\n10. Master transmits low address data byte\n11. If the low address matches; SMA is set, ADRIF is  set,  R/W  is  copied  to  R/W  bit,  D/A  bit  is cleared, low address data is copied to I2CxADB0, and ACKDT is copied to SDA. If the address does not match; module becomes Idle.\n12. If  address hold interrupt is enabled, the CSTR bit is set as mentioned in step 6. Slave software can read low address byte from I2CxADB0 reg -ister and change ACKDT value before releasing SCL.\n13. Master sends ninth SCL pulse for ACK.\n14. If the Acknowledge interrupt and hold is enabled (ACKTIE = 1 ), CSTR is set, I2CxIF is set.\n15. Slave software can read address from I2CxADB0 and I2CxADB1 registers and change the  value  of ACKDT  before  releasing  SCL  by clearing CSTR.\n16. Master sends first seven SCL pulses of the data byte or a Stop condition (in the case of NACK).",
    "33.4.3.4 Slave Reception (10-bit Addressing Mode)\n17. If Stop condition; PCIF in I2CxPIR register is set, module becomes Idle.\n18. If  the  receive  buffer  is  full  from  the  previous transaction i.e., RXBF = 1 , I2CxRXIF = 1 , CSTR is  set.  Slave  software  must  read  data  out  of I2CxRXB to resume communication.\n19. Master sends eighth SCL pulse of the data byte. D bit is set, WRIF is set. I2CxRXB is loaded with new data, RXBF bit is set.\n20. If Data  write  interrupt  and  hold  is  enabled (WRIE = 1 ),  CSTR is set, I2CxIF is set. Slave software can read data from I2CxRXB and set/ clear ACKDT before releasing SCL by clearing CSTR.\n21. If I2CxCNT = 0 , the ACKCNT value is output to the SDA; else, the ACKDT value is used and the value of I2CxCNT is decremented.",
    "33.4.3.4 Slave Reception (10-bit Addressing Mode)\n22. Master sends SCL pulse for ACK.\n23. If I2CxCNT = 0 , CNTIF is set.\n24. If  the  response  was  a  NACK;  NACKIF  is  set, module becomes idle.\n25. If ACKTIE = 1 , CSTR is set, I2CxIF is set. Slave software can read data from I2CxRXB clearing RXBF; before releasing SCL by clearing CSTR\n26. Go to step 16.",
    "33.4.3.5 Slave Transmission (10-bit Addressing Mode)\nThis section describes the sequence of events for the I 2 C module  configured  as  an  I 2 C  slave  in  10-bit Addressing mode and is transmitting data. Figure 3312 is used as a visual reference for this description.",
    "33.4.3.5 Slave Transmission (10-bit Addressing Mode)\n1. Master  asserts  Start  condition  (can  also  be  a restart) on the bus. Start condition Interrupt Flag (SCIF) in I2CxPIR register is set. If Start condi -tion interrupt is enabled (SCIE bit is set), generic interrupt I2CxIF is set.\n2. Master transmits high address byte with R/W = 0 .\n3. The received high address is compared with the values in I2CxADR1 and I2CxADR3 registers.\n4. If high address matches; R/W is copied to R bit, D bit is cleared, high address data is copied to I2CxADB1. If the address does not match; mod -ule becomes Idle.\n5. If Address hold interrupt is enabled (ADRIE = 1 ), CSTR is set. I2CxIF is set.\n6. Slave  software  can  read  high  address  from I2CxADB1 and set/clear ACKDT before releasing SCL.\n7. ACKDT  value  is  copied  out  to  SDA  for  ACK pulse. SCL line is released by clearing CSTR.",
    "33.4.3.5 Slave Transmission (10-bit Addressing Mode)\n8. Master sends ninth SCL pulse for ACK.\n9. Slave can force a NACK at this point due to pre -vious error not being cleared. E.g. Receive buf -fer overflow or transmit buffer underflow errors. In  these  cases  the  slave  hardware  forces  a NACK and the module becomes Idle.\n10. Master transmits low address data byte.\n11. If the low address matches; SMA is set, ADRIF is set, low address data is copied to I2CxADB0, and ACKDT  is  copied  to  SDA.  If  the  address does not match; module becomes Idle.\n12. If  address hold interrupt is enabled, the CSTR bit is set as mentioned in step 6. Slave software can read low address byte from I2CxADB0 reg -ister and change ACKDT value before releasing SCL.\n13. Master sends 9th SCL pulse for ACK.\n14. If the Acknowledge interrupt and hold is enabled (ACKTIE = 1 ), CSTR is set, I2CxIF is set.",
    "33.4.3.5 Slave Transmission (10-bit Addressing Mode)\n15. Slave software can read address from I2CxADB0 and I2CxADB1 registers and change the  value  of ACKDT  before  releasing  SCL  by clearing CSTR.\n16. Master  asserts  Restart  condition  (cannot  be Start)  on  the  bus.  Restart  Condition  Interrupt Flag  (RSCIF)  is  set.  If  the  Restart  Condition Interrupt is enabled, generic interrupt I2CxIF is set.\n17. Master transmits high address byte with R/W = 1 .\n18. If SMA = 1 , and if high address matches; R/W is\ncopied to R bit, D bit is cleared, high address data is copied to I2CxADB1, and ACKDT is out -put  to  SDA.  If  the  address  does  not  match  or SMA = 0 ; module become Idle.",
    "33.4.3.5 Slave Transmission (10-bit Addressing Mode)\n19. If ADRIE = 1 , CSTR is set. I2CxIF is set. Slave software  can  read  address  from  I2CxADB0/1 and set/clear ACKDT. The ACKDT value is cop -ied  out  to  SDA.  SCL  is  released  by  clearing CSTR bit.\n20. If TXBE = 1 and I2CxCNT = 0 ,  I2CxTXIF and CSTR is set. Slave software must load data into I2CxTXB to release SCL.\n21. Master sends SCL pulse for ACK. If I2CxCNT = 0 , CNTIF is set.\n22. If NACK; NACKIF is set, slave goes Idle.\n23. If ACKTIE = 1 , CSTR is set, I2CxIF is set. Slave software  can  read  address  from  I2CxADB0/1 before releasing SCL by clearing CSTR.\n24. Master  sends  eight  SCL  pulses  to  clock  out data.\n25. Go to step 20.",
    "33.5 I 2 C Master Mode\nMaster  mode  is  enabled  by  setting  and  clearing  the appropriate MODE<2:0> bits in I2CxCON0 and then by setting  the  EN  bit.  Master  mode  of  operation  is  sup -ported  by  interrupt  generation  on  buffer  full  (RXBF), buffer  empty  (TXBE),  and  the  detection  of  the  Start, Restart,  and  Stop  conditions.  The  Restart  (RS)  and Start (S) bits are cleared from a Reset or when the I 2 C module is disabled. Control of the I 2 C bus is asserted when the BFRE bit of I2CSTAT0 is set.",
    "33.5.1 I 2 C MASTER MODE OPERATION\nThe  master  device  generates  all  of  the  serial  clock pulses and the Start, Restart, and Stop conditions. A transfer is ended with a Stop condition or with a Restart condition. Since the Repeated Start condition is also the beginning of the next serial transfer, the I 2 C bus will not be released, and MMA bit will stay set signifying that the master module is still active.\nThe  steps  to  initiate  a  transaction  depends  on  the setting of the address buffer disable bit (ABD) of the I2CxCON2 register.\n- \u00b7 ABD = 0 (Address buffers are enabled)\nIn  this case, the master module will use the address stored in the address buffer registers (I2CxADB0/1) to initiate communication with a slave device. User soft -ware needs to set the Start bit (S) in the I2CxCON0 reg -ister to start communication. This is valid for both 7-bit and 10-bit Addressing modes.\n- \u00b7 ABD = 1 (Address buffers are disabled)",
    "33.5.1 I 2 C MASTER MODE OPERATION\nIn this case, the slave address is transmitted through the  transmit  buffer  and  the  contents  of  the  address buffers are ignored. User software needs to write the slave  address  to  the  transmit  buffer  (I2CxTXB)  to initiate communication.  Writing  to  the  Start  bit is ignored in this mode. This is valid for both 7-bit and 10bit Addressing modes.",
    "33.5.1.1 Master Transmitter\nIn Master Transmitter mode, the first byte transmitted contains the slave address of the receiving device (7 bits) and the Read/Write (R/W) bit. In the case of mas -ter transmitter, the R/W bit will be logic ' 0 '. Serial data is  transmitted  eight  bits  at  a  time. After  each  byte  is transmitted, an Acknowledge bit is received. Start and Stop  conditions  are  output  to  indicate  the  beginning and the end of a serial transfer.",
    "33.5.1.2 Master Receiver\nIn Master Receive mode, the first byte transmitted con -tains  the  slave  address  of  the  transmitting  device  (7 bits) and the R/W bit. In this case, the R/W bit will be logic ' 1 '. Thus, the first byte transmitted is a 7-bit slave address  followed  by  a  ' 1 '  to  indicate  the  receive  bit. Serial data is received via SDA, while SCL outputs the serial clock. Serial data is received eight bits at a time.\nAfter  each  byte  is  received,  an  Acknowledge  bit  is transmitted.  Start  and  Stop  conditions  indicate  the beginning and end of the transmission.",
    "33.5.2 MASTER CLOCK SOURCE AND ARBITRATION\nThe  I 2 C  module  clock  source  is  selected  by  the I2CxCLK register. The I 2 C Clock provides the SCL out -put clock for Master mode and is used by the Bus Free timer.  The  I 2 C  clock  can  be  sourced  from  several peripherals.",
    "33.5.3 BUS FREE TIME\nIn Master modes, the BFRE bit of the I2CxSTAT0 reg -ister gives an indication of the bus idle status. The mas -ter hardware cannot assert a Start condition until this bit is set by the hardware. This prevents the master from colliding with other masters that may already be talking on the bus. The BFRET<1:0> bits of I2CxCON1 allow selection of 8 to 64 pulses of the I 2 C clock input before asserting the BFRE bit. The BFRET bits are used to ensure  that  the  I 2 C  module  always  follows  the  mini -mum Stop Hold Time. The I 2 C timing requirements are listed in the electrical specifications chapter.\nNote:\nI 2 C clock is not required to have a 50% duty cycle.",
    "33.5.4 MASTER CLOCK TIMING\nThe clock generation in the I 2 C module can be config -ured  using  the  Fast  Mode  Enable  (FME)  bit  of  the I2CxCON2  register.  This  bit  controls  the  number  of times the SCL pin is sampled before the master hard -ware drives it.",
    "33.5.4.1 Clock Timing with FME = 0\nOne TSCL, consists of five clocks of the I 2 C clock input. The  first  clock  is  used  to  drive  SCL  low,  the  third releases SCL high. The fourth and fifth clocks are used to  detect  if  the  SCL  pin  is,  in  fact,  high  or  being stretched by a slave.\nIf a slave is clock stretching, the hardware waits; check -ing SCL on each successive I 2 C clock, proceeding only after detecting SCL high. Figure 33-13 shows the clock synthesis timing when FME = 0 .",
    "FIGURE 33-13: CLOCK SYNTHESIS TIMING (FME = 0 )\n33.5.4.2 Clock Timing with FME = 1\nOne TSCL, consists of four clocks of the I 2 C clock input. The  first  clock  is  used  to  drive  SCL  low,  the  third releases SCL high, and the fourth is used to detect if the clock is, in fact, high or being stretched by a slave.\nIf a slave is clock stretching, the hardware waits; check -ing SCL on each successive I 2 C clock, proceeding only after detecting SCL high. Figure 33-14 shows the clock synthesis timing when FME = 1 .\nFIGURE 33-14: CLOCK SYNTHESIS TIMING (FME = 1 )",
    "33.5.5 I 2 C MASTER MODE START CONDITION TIMING\nThe user can initiate a Start condition by either writing to  the  Start  bit  (S)  of  the  I2CxCON0  register  or  by writing to the I2CxTXB register based on the ABD bit setting. Master hardware waits for BFRE = 1 ,  before asserting  the  Start  condition.  The  action  of  the  SDA being driven low while SCL is high is the Start condition, causing the SCIF bit to be set. One TSCL later the SCL is asserted low, ending the start sequence. Figure 3315 shows the Start condition timing.",
    "33.5.6 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nA Repeated Start condition occurs when the Start bit of the I2CxCON0 register is set and the master module is waiting from a Restart clock stretch event (RSEN = 1 and I2CxCNT = 0 ).\nWhen the Start bit is set, the SDA pin is released high for TSCL/2. Then the SCL pin is released floated high) for TSCL/2. If the SDA pin is detected low, bus collision flag (BCLIF) is set and the master goes idle. If SDA is detected high, the SDA pin will be pulled low (Start con -dition) for TSCL. Last, SCL  is asserted low and I2CxADB0/1 is loaded into the shift register. As soon as a Restart condition is detected on the SDA and SCL pins, the RSCIF bit is set. Figure 33-16 shows the tim -ings for repeated Start Condition.",
    "33.5.7 ACKNOWLEDGE SEQUENCE TIMING\nAn Acknowledge  sequence  is  enabled  automatically following an address/data byte transmission. The SCL pin is pulled low and the contents of the Acknowledge Data bits (ACKDT/ACKCNT) are presented on the SDA pin.  If  the  user  wishes  to  generate  an Acknowledge, then the ACKDT bit should be cleared. If not, the user should set the ACKDT bit before starting an Acknowl -edge  sequence.  The  master  then  waits  one  clock period (TSCL) and the SCL pin is released high. When the  SCL  pin  is  sampled  high  (clock  arbitration),  the master counts another TSCL. The SCL pin is then pulled low. Figure 33-17 shows the timings for Acknowledge sequence.",
    "33.5.8 STOP CONDITION TIMING\nA  Stop  bit  is  asserted  on  the  SDA  pin  at  the  end  of receive/transmit when I2CxCNT = 0 . After the last byte of  a  receive/transmit  sequence,  the  SCL  line  is  held low. The master asserts the SDA line low. The SCL pin is then released high TSCL/2 later and is detected high. The SDA pin is then released. When the SDA pin tran - sitions high while SCL is high, the PCIF bit of the I2CxIF register  is  set.  Figure 33-18  shows  the  timings  for  a Stop condition.",
    "33.5.9 MASTER TRANSMISSION IN 7-BIT ADDRESSING MODE\nvalue of I2CxCNT register is decremented.\nThis section describes the sequence of events for the I 2 C  module  configured  as  an  I 2 C  master  in  7-bit Addressing mode and is transmitting data. Figure 3319 is used as a visual reference for this description.\n- 1. If ABD = 0 ; i.e., Address buffers are enabled\nMaster software loads number of bytes to be transmitted in one sequence in I2CxCNT, slave address in I2CxADB1 with R/W = 0 and the first byte of data in I2CxTXB. Master software has to set the Start (S) bit to initiate communication.\nIf ABD = 1 ; i.e., Address buffers are disabled\nMaster  software  loads  the  number  of  bytes  to  be transmitted in one sequence in I2CxCNT and the slave address with R/W = 0 into the I2CxTXB register. Writing to the I2CxTXB will assert the start condition on the bus and  sets  the  S  bit.  Software  writes  to  the  S  bit  are ignored in this case.",
    "33.5.9 MASTER TRANSMISSION IN 7-BIT ADDRESSING MODE\n2. Master hardware waits for BFRE bit to be set; then shifts out start and address.\n3. If  the  transmit buffer is empty (i.e., TXBE = 1 ) and I2CxCNT!= 0, the I2CxTXIF and MDR bits are set and the clock is stretched on the 8th fall -ing SCL edge. Clock can be started by loading the next data byte in I2CxTXB register.\n4. Master sends out the 9th SCL pulse for ACK.\n5. If the master hardware receives ACK from slave device, it loads the next byte from the transmit buffer (I2CxTXB) into the shift register and the\n6. If a  NACK  was  received,  master  hardware asserts Stop or Restart\n7. If ABD = 0 ; i.e., Address buffers are enabled\nIf I2CxCNT = 0 , Master hardware sends Stop or sets MDR if RSEN = 1 and waits for the software to set the Start bit again to issue a restart condition.\nIf ABD = 1 ; i.e., Address buffers are disabled",
    "33.5.9 MASTER TRANSMISSION IN 7-BIT ADDRESSING MODE\nIf I2CxCNT = 0 , Master hardware sends Stop or sets MDR if RSEN = 1 and waits for the software to write the new address to the I2CxTXB register. Software writes to the S bit are ignored in this case.\n8. Master hardware outputs data on SDA.\n9. If TXBE = 1 and I2CxCNT! = 0 , I2CxTXIF and MDR bits are set and the clock is stretched on 8th falling SCL edge. The user can release the clock by writing the next data byte to I2CxTXB register.\n10. Master hardware clocks in ACK from slave, and loads the next data byte from I2CTXB to the shift register. The value of I2CxCNT is decremented.\n11. Go to step 7.",
    "33.5.10 MASTER RECEPTION IN 7-BIT ADDRESSING MODE\nThis section describes the sequence of events for the I 2 C  module  configured  as  an  I 2 C  master  in  7-bit Addressing mode and is receiving data. Figure 33-20 is used as a visual reference for this description.\n1. Master software loads slave address in I2CxADB1 with R/W bit = 1 and number of bytes to be received in one sequence in I2CxCNT reg -ister.\n2. Master hardware waits for BFRE bit to be set; then shifts out start and address with R/W = 1 .\n3. Master  sends  out  the  9 th SCL  pulse  for ACK, master hardware clocks in ACK from slave\n4. If ABD = 0 ; i.e., Address buffers are enabled\nIf NACK, master hardware sends Stop or sets MDR (if RSEN = 1 ) and waits for user software to write to S bit for restart.\nIf ABD = 1 ; i.e., Address buffers are disabled",
    "33.5.10 MASTER RECEPTION IN 7-BIT ADDRESSING MODE\nIf NACK, master hardware sends Stop or sets MDR (if RSEN = 1 ) and waits for user software to load the new address into I2CxTXB. Software writes to the S bit are ignored in this case.\n5. If ACK, master hardware receives 7 bits of data into the shift register.\n6. If the receive buffer is full (i.e., RXBF = 1 ), clock is stretched on 7 th falling SCL edge.\n7. Master software must read previous data out of I2CxRXB to clear RXBF.\n8. Master hardware receives 8th bit of data into the shift  register  and  loads  it  into  I2CxRXB,  sets I2CxRXIF and RXBF bits. I2CxCNT is decremented.",
    "33.5.10 MASTER RECEPTION IN 7-BIT ADDRESSING MODE\n9. If  I2CxCNT!  = 0 ,  master  hardware  clocks  out ACKDT as ACK value to slave. If I2CxCNT = 0 , master hardware clocks out ACKCNT as ACK value to slave. It is up to the user to set the val -ues  of  ACKDT  and ACKCNT  correctly.  If  the user  does  not  set ACKCNT  to  ' 1 ',  the  master hardware will never send a NACK  when I2CxCNT becomes zero. Since a NACK was not seen on the bus, the master hardware will also not assert a Stop condition.\n10. Go to step 4.\nFIGURE 33-20:",
    "33.5.11 MASTER TRANSMISSION IN 10-BIT ADDRESSING MODE\nThis section describes the sequence of events for the I 2 C  module  configured  as  an  I 2 C  master  in  10-bit Addressing mode and is transmitting data. Figure 3321 is used as a visual reference for this description\n- 1. If ABD = 0 ; i.e., Address buffers are enabled\nMaster software loads number of bytes to be transmitted in one sequence in I2CxCNT, high address byte of slave address in I2CxADB1 with R/W = 0 , low address byte in I2CxADB0 and the first byte of data in I2CxTXB. Master software has to set the Start (S) bit to initiate communication.\nIf ABD = 1 ; i.e., Address buffers are disabled\nMaster  software  loads  the  number  of  bytes  to  be transmitted in one sequence in I2CxCNT and the high address byte of the slave address with R/W = 0 into the I2CxTXB register.  Writing  to  the  I2CxTXB  will  assert the  start  condition  on  the  bus  and  sets  the  S  bit. Software writes to the S bit are ignored in this case.",
    "33.5.11 MASTER TRANSMISSION IN 10-BIT ADDRESSING MODE\n2. Master hardware waits for BFRE bit to be set; then shifts out the start and high address and waits for acknowledge.\n3. If NACK, master hardware sends Stop.\n4. If ABD = 0 ; i.e., Address buffer are enabled\nIf ACK, master hardware sends the low address byte from I2CxADB0.\nIf ABD = 1 ; i.e., Address buffer are disabled\nIf ACK, master hardware sets TXIF and MDR bits and the  software  has  to  write  the  low  address  byte  into I2CxTXB. Writing to I2CxTXB sends the low address on the bus.",
    "33.5.11 MASTER TRANSMISSION IN 10-BIT ADDRESSING MODE\n5. If TXBE = 1 and I2CxCNT! = 0 , I2CxTXIF and MDR bits are set. Clock is stretched on 8th fall -ing  SCL  edge  till  master  software  writes  next data byte to I2CxTXB.\n6. Master  hardware  sends  ninth  SCL  pulse  for ACK from slave and loads the shift register from I2CxTXB. I2CxCNT is decremented.\n7. If slave sends a NACK, master hardware sends Stop and ends transmission.\n8. If slave sends an ACK, master hardware outputs data in the shift register on SDA. I2CxCNT value is checked  on  the  8th  falling  SCL  edge.  If I2CxCNT = 0 ; master hardware sends 9th SCL pulse for ACK and CNTIF is set.\n9. If I2CxCNT != 0 ; go to step 5.",
    "33.5.12 MASTER RECEPTION IN 10-BIT ADDRESSING MODE\nThis section describes the sequence of events for the I 2 C  module  configured  as  an  I 2 C  master  in  10-bit Addressing mode and is receiving data. Figure 33-22 is used as a visual reference for this description.\n1. Depending on the configuration of the Address Buffer  Disable  (ABD)  bit,  one  of  two  methods may be used to begin communication:\n1.1. When ABD is clear (ABD = 0 ), the address buffers, I2CxADB0  and  I2CxADB1,  are  enabled.  In  this case, the address high byte and R/W bit are loaded into  I2CxADB1,  with  R/W  clear  (R/W  = 0 ).  The address low byte is loaded into I2CADB0, and the Restart Enable (RSEN) bit of I2CxCON0 is set by software.  After  these  registers  are  loaded,  soft -ware must set the Start bit to begin communica -tion. Once the S bit is set, master hardware waits for the Bus Free (BFRE) bit to be set before trans -mitting the Start condition to avoid bus collisions.",
    "33.5.12 MASTER RECEPTION IN 10-BIT ADDRESSING MODE\n1.2. When ABD is set (ABD = 1 ), the address buffers are disabled. In this case, the number of expected received  bytes  are  loaded  into  I2CxCNT,  the address  high  byte  and  R/W  bit  are  loaded  into I2CxTXB,  with  R/W  clear  (R/W  = 0 ).  A  write  to I2CxTXB will cause master hardware to automati -cally issue a Start condition once the bus is idle (BFRE = 1 ).  Software  writes  to  the  Start  bit  are ignored.\n2. Master hardware waits for BFRE to be set, then shifts out the Start condition. Module hardware sets  the  Master  Mode  Active  (MMA)  bit  of I2CxSTAT0  and  the  Start  Condition  Interrupt Flag  (SCIF)  of  I2CxPIR.  If  the  Start  Condition Interrupt  Enable  (SCIE)  bit  of  I2CxPIE  is  also set, the generic I2CxIF is also set.\n3. Master  hardware  transmits  the  address  high byte and R/W bit.",
    "33.5.12 MASTER RECEPTION IN 10-BIT ADDRESSING MODE\n4. Master hardware samples SCL to determine if the slave is stretching the clock, and continues to sample SCL until the line is sample high.\n5. Master hardware transmits the 9th clock pulse, and receives the ACK/NACK response from the slave.  If a  NACK  was  received,  the  NACK Detect  Interrupt  Flag  (NACKIF)  is  set  and  the master immediately issues a Stop condition. If an ACK was received, module hardware trans -mits the address low byte.\n6. Master hardware samples SCL to determine if the slave is stretching the clock, and continues to sample SCL until the line is sampled high.\n7. Master hardware transmits the 9th clock pulse, and receives the ACK/NACK response from the slave. If  an ACK was received, hardware sets MDR, and waits for hardware or software to set the Start bit.  If  a  NACK  is  received,  hardware sets the NACK Detect Interrupt Flag (NACKIF), and:",
    "33.5.12 MASTER RECEPTION IN 10-BIT ADDRESSING MODE\n7.1. ABD = 0 :  Master  generates a Stop condition, or sets the MDR bit (if RSEN is also set) and waits for software to set the Start bit to generate a Restart condition.\n7.2. ABD = 1 :  Master  generates a Stop condition, or sets the MDR bit (if RSEN is also set) and waits for software  to  load  a  new  address  into  I2CxTXB. Software writes to the Start bit are ignored. If the NACK Detect Interrupt  Enable  (NACKIE)  is  also set, hardware sets the generic I2CxEIF bit.\n8. Software  loads  I2CxCNT  with  the  expected number of received bytes.\n9. If the ABD is clear (ABD = 0 ), software sets the Start bit. If the ABD is set (ABD = 1 ), software writes the address high byte with R/W bit into I2CxTXB, with R/W set (R/W = 1 ).",
    "33.5.12 MASTER RECEPTION IN 10-BIT ADDRESSING MODE\n10. Master  hardware  transmits  the  Restart  condi -tion, which sets the Restart Condition Interrupt Flag (RSCIF) bit of I2CxPIR. If the Restart Con -dition Interrupt Enable (RSCIE) bit of I2CxPIE is also set, the generic I2CxIF is set by hardware.\n11. Master  hardware  transmits  the  high  address byte and R/W bit.\n12. Master hardware samples SCL to determine if the slave is stretching the clock, and continues to sample SCL until the line is sampled high.\n13. Master hardware transmits the 9th clock pulse, and receives the ACK/NACK response from the slave. If an ACK is received, master hardware receives the first seven bits of the data byte into the receive shift register. If a NACK is received, and:\n13.1. ABD = 0 : Master generates a Stop condition, or sets the MDR bit (if RSEN is also set) and waits for  software  to  set  the  Start  bit  to  generate  a Restart condition.",
    "33.5.12 MASTER RECEPTION IN 10-BIT ADDRESSING MODE\n13.2. ABD = 1 : Master generates a Stop condition, or sets the MDR bit (if RSEN is also set) and waits for software to load a new address into I2CxTXB. Software writes to the Start bit are ignored.\n14. If previous data is currently in I2CxRXB (RXBF = 1 ) when the first seven bits are received by the receive shift register, hardware sets MDR, and the clock is stretched after the 7th falling edge of SCL.  This  allows  software  to  read  I2CxRXB, which  clears  the  RXBF  bit,  and  prevents  a receive  buffer  overflow.  Once  the  RXBF  bit  is clear, hardware releases SCL.\n15. Master hardware clocks in the 8th bit of the data byte into the receive shift register, then transfers the complete byte into I2CxRXB, which sets the I2CxRXIF and RXBF bits. If I2CxRXIE is also set, hardware  sets  the generic I2CxIF bit. I2CxCNT is decremented by one.",
    "33.5.12 MASTER RECEPTION IN 10-BIT ADDRESSING MODE\n16. Hardware checks I2CxCNT for a zero value. If I2CxCNT is non-zero (I2CxCNT! = 0 ), hardware transmits  the  value  of  the Acknowledge  Data (ACKDT) bit as the Acknowledgment response to the slave. It is up to user software to properly configure  ACKDT. In most cases,  ACKDT should be clear (ACKDT = 0 ), which indicates an ACK response. If I2CxCNT is zero (I2CxCNT = 0 ), hardware transmits the value of the Acknowl -edge  Data  (ACKDT)  bit  as  the Acknowledge -ment response to the slave. CNTIF is set, and master hardware either issues a Stop condition or a Restart condition. It is up to user software to properly  configure  ACKCNT.  In  most  cases, ACKCNT should be set (ACKCNT = 1 ),  which indicates  a  NACK  response.  When  hardware detects  a  NACK  on  the  bus,  it  automatically issues  a  Stop  condition.  If  a  NACK",
    "33.5.12 MASTER RECEPTION IN 10-BIT ADDRESSING MODE\nis  not detected, the Stop will not be generated, which may lead to a stalled bus condition.\n17. Master hardware receives the first seven bits of the next data byte into the receive shift register.\n18. Repeat  Steps  14-17  until  all  expected  bytes have been received.",
    "33.6 I 2 C Multi-Master Mode\nIn Multi-Master mode, the bus-free (BFRE) bit allows the master to determine when the bus is free. Control of the I 2 C bus may be taken when the BFRE bit of the I2CxSTAT0 register is set. Interrupt generation on the detection of a slave address match, ADRIE; causes a clock stretch and allows user software to respond to the master being addressed as a slave device. The Slave Active (SMA) bit is set for a matching received slave address.\nClock arbitration occurs when the master, during any receive,  transmit  or  Restart/Stop  condition,  releases the SCL pin (SCL allowed to float high). When the SCL pin is allowed to float high, the SCL line is monitored to see if the pin is actually sampled high.\nIn master operation, the SDA line must be monitored for arbitration to see if the signal level is the expected output level. This check is performed by hardware with the result placed in the BCLIF bit. MMA is cleared when BCLIF is set. The states where arbitration can be lost are:\n\u00b7 Address Transfer\n\u00b7 Data Transfer (master write)\n\u00b7 Repeated Start Condition\n\u00b7 Acknowledge Condition",
    "33.6.1 MULTI-MASTER MODE BUS COLLISION\nNote:\nMulti-Master mode support is achieved by bus arbitra -tion. When the master outputs address/data bits onto the SDA pin, arbitration takes place when the master outputs  a  ' 1 '  on  SDA,  by  letting  SDA  float  high  and another master asserts a ' 0 '. When the SCL pin floats high, data is stable. If the expected data on SDA is a ' 1 ' and the data sampled on the SDA pin is ' 0 ', then a bus collision has taken place. The master will set the Bus Collision Interrupt Flag, BCLIF and reset the I 2 C bus to its Idle state. Refer to Figure 33-23 for a detailed timing diagram.\nIn this mode, the slave hardware has pri -ority  over  the  master  hardware.  Master mode communication can only be initiated when the SMA = 0 .",
    "FIGURE 33-23: BUS COLLISION TIMING FOR TRANSMIT AND ACKNOWLEDGE\nIf transmission was in progress when the bus collision occurred,  the  SDA  and  SCL  lines  are  released.  If  a Repeated Start, Stop or Acknowledge was in progress when the bus collision occurred, the action is aborted; the SDA and SCL lines are released. The BCLIF con -dition must be cleared by software to allow an ACK to be shifted out on the bus again, until then the module will always respond with a NACK. Refer to Figure 3324  for  a  detailed  timing  diagram  of  a  transaction  in Multi-Master mode.",
    "33.7 Register Definitions: I 2 C Control\nThis  section  defines  all  the  registers  associated  with the control and status of the I 2 C bus.",
    "REGISTER 33-1: I2CxCON0: I 2 C CONTROL REGISTER 0\nEN (1,2), R/W-0 = RSEN. EN (1,2), R/W/HC/HS-0 = S. EN (1,2), R/C/HS/HC-0 = CSTR (3). EN (1,2), R-0 = MDR. EN (1,2), R/W-0 = MODE <2:0>. EN (1,2), R/W-0 = MODE <2:0>. EN (1,2), R/W-0 = MODE <2:0>. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W/HC/HS-0 = bit 7 bit 0. bit 7 bit 0, R/C/HS/HC-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit",
    "REGISTER 33-1: I2CxCON0: I 2 C CONTROL REGISTER 0\n0, R/W-0 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 7\nEN: I 2 C Module Enable bit\n- 0 = Disables the I 2 C module.\n1 = Enables the I 2 C module (1,2)",
    "bit 6 RSEN: Restart Enable bit (Only MODE<2:0> = 1xx )\n1 = When (I2CxCNT = 0 or ACKSTAT = 1 ), on 9th falling SCL sets MDR\n0 = When (I2CxCNT = 0 or ACKSTAT = 1 ), on 9th falling SCL; master shifts out a Stop condition\nS:\nMaster Start/Restart bit (Only MODE<2:0> =\n1xx\n)",
    "When MMA = 0\n1 =   Set by user set of START bit or write to I2CxTXB, waits for BFRE = 1 to begin with a Start\n0 =   Cleared by hardware after sending Start",
    "When MMA = 1 & MDR = 1\n1 =   Set by user set of START bit or write to I2CxTXB, resumes communication with a Restart\n0 =   Cleared by hardware after sending Restart\nElse - Writes to I2CxTXB or Start bit (S) has no effect on Start bit",
    "bit 4 CSTR: Slave Clock Stretching bit (3)\n1 = Clock is held low (clock stretching)\n0 = Enable clocking, SCL control is released",
    "SMA = 1 and RXBF = 1 (6)\n- Set by hardware on 7th falling SCL edge\n- User must read byte I2CxRXB to release SCL\nSMA =\n1\nand TXBE =\n1\nand I2CCNT!=\n0\n- Set by hardware on 8th falling SCL edge\n- User must write byte to I2CxTXB to release SCL",
    "when ADRIE is set (4)\n-\nSet by hardware on 8th falling SCL edge of matching received address\n- User must clear CSTR to release SCL",
    "SMA = 1 & WRIE = 1\n-\nSet by hardware on 8th falling SCL edge of received data byte\n- User must clear CSTR to release SCL",
    "S MA = 1 & ACKTIE = 1\n- Set by hardware on 9th falling SCL edge\n- User must clear CSTR to release SCL\nbit 5",
    "bit 3 MDR: Master Data Request (Master pause)\n1 = Master state mechine pauses until data is read/written to proceed (SCL is output held low)\n- 0 = Master clocking of data is enabled.",
    "MMA = 1 & RXBF = 1\npause_for_rx - Set by hardware on 7th falling SCL edge\n- User must read from I2CxRXB to release SCL\nMMA = 1 & TXBE = 1 & I2CCNT!= 0\npause_for_tx -\nSet by hardware on 8th falling SCL edge\n- User must write to I2CxTXB to release SCL\npause_for_restart - Set by hardware on 9th falling SCL edge\nRSEN =\n1\n& MMA =\n1\n&& I2CxCNT =\n0\n|| ACKSTAT =\n1\n- User must set START or write to I2CxTXB to release SCL and shift Restart onto bus",
    "bit 2-0 MODE<2:0>: I 2 C Mode Select bits\n111 = I 2 C Muti-Master mode (SMBus 2.0 Host), (5)\nWorks as both MODE<2:0> = 001 and MODE<2:0> = 100\n110 =\nI 2 C Muti-Master mode (SMBus 2.0 Host), (5)\nWorks as both MODE<2:0> = 000 and MODE<2:0> = 100\n101 = I 2 C Master mode, 10-bit address\n100 = I 2 C Master mode, 7-bit address\n011 = I 2 C Slave mode, one 10-bit address with masking\n010 = I 2 C Slave mode, two 10-bit address\n001 = I 2 C Slave mode, two 7-bit address with masking\n000 =\nI 2 C Slave mode, four 7-bit address\nNote 1: SDA and SCL pins must be configured for open-drain with internal or external pull-up",
    "bit 2-0 MODE<2:0>: I 2 C Mode Select bits\n2: SDA and SCL pins must be selected as both input and output in PPS\n3: CSTR can be set by more than one hardware source, all sources must be addressed by user software before the SCL line is released. CSTR is a module Status bit, and does not show the true bus state.\n4: SMA is set on the same SCL edge as CSTR for a matching received address\n5: In this mode, ADRIE should be set, this allows an interrupt to clear the BCLIF condition and allow the ACK of matching address.\n6: In 10-bit Slave mode, when ADB = 1 , CSTR will set when the high address has not been read out of I2CxRXB before the low address is shifted in.\nbit 4",
    "REGISTER 33-2: I2CxCON1: I 2 C CONTROL REGISTER 1\nACKCNT (2), R/W-0 = ACKDT (1,2). ACKCNT (2), R-0 = ACKSTAT. ACKCNT (2), R-0 = ACKT. ACKCNT (2), U-0 = -. ACKCNT (2), R/W/HS-0 = RXO. ACKCNT (2), R/W/HS-0 = TXU. ACKCNT (2), R/W-0 = CSD. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W/HS-0 = bit 7 bit 0. bit 7 bit 0, R/W/HS-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0\nLegend:",
    "REGISTER 33-2: I2CxCON1: I 2 C CONTROL REGISTER 1\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 7 ACKCNT: Acknowledge End of Count bit (2)\nAcknowledge value transmitted after received data, when I2CxCNT = 0\n1 = Not Acknowledge (copied to SDA output)\n0 = Acknowledge (copied to SDA output)",
    "bit 6 ACKDT: Acknowledge Data bit (1,2)\nAcknowledge value transmitted after matching address\nAcknowledge value transmitted after received data, when I2CxCNT! = 0\n1 = Not Acknowledge (copied to SDA output)\n0 = Acknowledge (copied to SDA output)",
    "bit 5 ACKSTAT: Acknowledge Status bit (Transmission only)\n1 = Acknowledge was not received for most recent transmission\n0 =  Acknowledge was received for most recent transmission\nACKT: Acknowledge Time Status bit\n1 = Indicates the I 2 C bus is in an Acknowledge sequence, set on 8th falling edge of SCL clock\n0 = Not in Acknowledge sequence, cleared on 9th rising edge of SCL",
    "bit 2 RXO: Receive Overflow Status bit (MODE<2:0> = 0xx & 11x )\nThis bit can only be set when CSD= 1\n1 = Set when SMA = 1 , and a master clocks in data when RXBF = 1\n0 = No slave overflow condition",
    "bit 1 TXU: Transmit Underflow Status bit (MODE<2:0> = 0xx & 11x )\nThis bit can only be set when CSD = 1\n1 = Set when SMA = 1 , and a master clocks out data when TXBE = 1\n0 = No slave underflow condition",
    "bit 0 CSD: Clock Stretching Disable bit (MODE<2:0> = 0xx & 11x )\n1 = When SMA = 1 , the CSTR bit will never be set\n0 = Slave clock stretching proceeds normally\nNote 1: Software writes to ACKDT bit must be followed by a minimum SDA data-setup time before clearing CSTR.\n2: NACK may still be generated by I 2 C hardware when bus errors are indicated in the I2CxSTAT1 or I2CxERR registers.",
    "REGISTER 33-3: I2CxCON2: I 2 C CONTROL REGISTER 2\nACNT, R/W-0 = GCEN. ACNT, R/W-0 = FME. ACNT, R/W-0 = ADB. ACNT, R/W-0 = SDAHT<1:0>. ACNT, R/W-0 = SDAHT<1:0>. ACNT, R/W-0 = BFRET<1:0>. ACNT, R/W-0 = BFRET<1:0>. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 33-3: I2CxCON2: I 2 C CONTROL REGISTER 2\nu = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR. u = Bit is unchanged,  = and BOR/Value at all other Resets. ' 1 ' = Bit is set,  = ' 0 ' = Bit is cleared. ' 1 ' = Bit is set,  = HS = Hardware set. ' 1 ' = Bit is set,  = HC = Hardware clear",
    "bit 7 ACNT: Auto-Load I 2 C Count Register Enable bit\n1 = The first received or transmitted byte after the address, is automatically loaded into the I2CxCNT register. The I2CxCNT register is loaded at the same time as the value is moved to/from the shifter. ACKDT is used to determine the ACK/NACK value for the address bytes and first data byte of a received message. This prevents a NACK from being sent for the byte that would update the I2CxCNT register.\n0 = Auto-load of I2CxCNT disabled\nGCEN: General Call Address Enable bit (MODE<2:0> = 00x & 11x )\n1 = General call address, 0x00, causes address match event\n0 = General call address disabled\nFME: Fast Mode Enable bit\n1 = SCL is sampled high only once before driving SCL low. (FSCL = FI2CXCLK/4)\n0 = SCL is sampled high twice before driving SCL low. (FSCL = FI2CXCLK/5)",
    "bit 4 ADB: Address Data Buffer Disable bit\n- 1 = Received address data is loaded into I2CxRXB\nTransmitted address data is loaded from the I2CxTXB\n- 0 = Received address data is loaded only into the I2CxADB\nTransmitted address data is loaded from the I2CxADB0/1 registers.",
    "bit 3-2 SDAHT<1:0>: SDA Hold Time Selection bits\n11 = Reserved\n10 = Minimum of 30 ns hold time on SDA after the falling edge of SCL\n01 = Minimum of 100 ns hold time on SDA after the falling edge of SCL\n00 = Minimum of 300 ns hold time on SDA after the falling edge of SCL",
    "bit 1-0 BFRET<1:0>: Bus Free Time Selection bits\n10 = 32 I 2 C Clock pulses\n- 11 = 64 I 2 C Clock pulses\n01 = 16 I 2 C Clock pulses\n00 =  8 I 2 C Clock pulses",
    "REGISTER 33-4: I2CxCLK: I 2 C CLOCK SELECTION REGISTER\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = CLK<3:0>. -, R/W-0/0 = . -, R/W-0/0 = . bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3-0 CLK<3:0>: I\n2 C Clock Selection Bits\n1010-1111, I 2 Cx Clock Selection = Reserved. 1001, I 2 Cx Clock Selection = SMT1 overflow. 1000, I 2 Cx Clock Selection = TMR6 post scaled output. 0111, I 2 Cx Clock Selection = TMR4 post scaled output. 0110, I 2 Cx Clock Selection = TMR2 post scaled output. 0101, I 2 Cx Clock Selection = TMR0 overflow. 0100, I 2 Cx Clock Selection = Clock Reference output. 0011, I 2 Cx Clock Selection = MFINTOSC (500 kHz). 0010, I 2 Cx Clock Selection = HFINTOSC. 0001, I 2 Cx Clock Selection = FOSC. 0000, I 2 Cx Clock Selection = FOSC/4",
    "REGISTER 33-5: I2CxBTO: I 2 C BUS TIMEOUT SELECTION REGISTER\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = BTO<2:0>. -, R/W-0/0 = . bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 7-3 Unimplemented: Read as ' 0 '\nbit 2-0\nBTO<2:0>: I 2 C Bus Timeout Selection bits\n111, I 2 Cx Bus Timeout Selection = CLC4OUT. 110, I 2 Cx Bus Timeout Selection = CLC3OUT. 101, I 2 Cx Bus Timeout Selection = CLC2OUT. 100, I 2 Cx Bus Timeout Selection = CLC1OUT. 011, I 2 Cx Bus Timeout Selection = TMR6 post scaled output. 010, I 2 Cx Bus Timeout Selection = TMR4 post scaled output. 001, I 2 Cx Bus Timeout Selection = TMR2 post scaled output. 000, I 2 Cx Bus Timeout Selection = Reserved",
    "REGISTER 33-6: I2CxSTAT0: I 2 C STATUS REGISTER 0\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = U-0. R-0, 6 = U-0. R-0, 7 = U-0. BFRE (3), 1 = SMA. BFRE (3), 2 = MMA. BFRE (3), 3 = R (1, 2). BFRE (3), 4 = D. BFRE (3), 5 = -. BFRE (3), 6 = -. BFRE (3), 7 = -. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear\n(3)",
    "bit 7 BFRE: Bus Free Status bit\n- 1 = Indicates the I 2 C bus is Idle\nBoth SCL and SDA have been high for time-out selected by I2CxCON2<BFRET<1:0>> bits.\nI2CxCLK must select a valid clock source for this bit to function.\n- 0 = Bus not Idle (When no I2CxCLK source is selected, this bit remains clear)",
    "bit 6 SMA: Slave Module Active Status bit\n1 = Set after the 8th falling SCL edge of a received matching 7-bit slave address\nSet after the 8th falling SCL edge of a received matching 10-bit slave low address Set after the 8th falling SCL edge of a received matching 10-bit slave high w/ read address, only after a previous matching high and low w/ write.\n0 = Cleared by any Restart/Stop detected on the bus\nCleared by BTOIF and BCLIF conditions",
    "bit 5 MMA: Master Module Active Status bit\n1 =   Master Mode state machine is active Set when master state machine asserts a Start on bus\n0 =   Master state machine is Idle\nCleared when BCLIF is set\nCleared when Stop is shifted out by master.\nCleared for BTOIF condition, after the master successfully shifts out a Stop condition.",
    "bit 4 R: Read Information bit (1, 2)\n1 = Indicates the last matching received (high) address was a Read request\n0 = Indicates the last matching received (high) address was a Write",
    "bit 3 D: Data bit\n1 = Indicates the last byte received or transmitted was data\n0 = Indicates the last byte received or transmitted was an address",
    "bit 2-0 Unimplemented: Read as 1'b0\nNote 1: This bit holds the R bit information following the last received address match. Addresses transmitted by the master or appearing on the bus without a match do not affect this bit.\n2: Clock requests and input from I2CxCLK register are disabled in Slave modes.\n3: Software must use the EN bit to force master or slave hardware to Idle.",
    "REGISTER 33-7: I2CxSTAT1: I 2 C STATUS REGISTER 1\nR/W/HS-0, 1 = U-0. R/W/HS-0, 2 = R-1. R/W/HS-0, 3 = U-0. R/W/HS-0, 4 = R/W/HS-0. R/W/HS-0, 5 = R/S-0/0. R/W/HS-0, 6 = U-0. R/W/HS-0, 7 = R-0. TXWE (2), 1 = -. TXWE (2), 2 = TXBE (1, 3). TXWE (2), 3 = -. TXWE (2), 4 = RXRE (2). TXWE (2), 5 = CLRBF. TXWE (2), 6 = -. TXWE (2), 7 = RXBF (1,3). bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0,",
    "REGISTER 33-7: I2CxSTAT1: I 2 C STATUS REGISTER 1\n4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 7 TXWE:\nTransmit Write Error Status bit (2)\n1 = A new byte of data was written to I2CxTXB when it was full (Must be cleared by software) 0 = No transmit write error",
    "bit 6 Unimplemented: Read as ' 0 '\nbit 5\nTXBE:\nTransmit Buffer Empty Status bit\n1 = I2CxTXB is empty (Cleared by writing the I2CTXB register)\n0 = I2CxTXB is full",
    "bit 4\nUnimplemented: Read as ' 0 '",
    "bit 3\nRXRE: Receive Read Error Status bit\n1 = A byte of data was read from I2CxRXB when it was empty. (Must be cleared by software)\n0 = No receive overflow\nbit 2\nCLRBF:\nClear Buffer bit\nSetting this bit clears/empties the receive and transmit buffers, causing reset of RXBF and TXBE.\nSetting this bit clears the I2CxRXIF and I2CxTXIF interrupt flags.\nThis bit is set-only special function, and always reads ' 0 '",
    "bit 1 Unimplemented: Read as ' 0 '\nbit 0\nRXBF: Receive Buffer Full Status bit\n1 = I2CxRXB has received new data (Cleared by reading the I2CxRXB register)\n0 = I2CxRXB is empty\nNote 1: The bits are held in Reset when EN = 0 .\n2: Will cause NACK to be sent for slave address and master/slave data read bytes.\n3: Used as triggers for DMA operation.",
    "bit 5\n- bit 1",
    "REGISTER 33-8: I2CxERR: I 2 C ERROR REGISTER\n-, R/W/HS-0 = BTOIF (1,2). -, R/W/HS-0 = BCLIF (1). -, R/W/HS-0 = NACKIF (1). -, U-0 = -. -, R/W-0 = BTOIE. -, R/W-0 = BCLIE. -, R/W-0 = NACKIE. bit 7 bit 0, R/W/HS-0 = bit 7 bit 0. bit 7 bit 0, R/W/HS-0 = bit 7 bit 0. bit 7 bit 0, R/W/HS-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 6 BTOIF: Bus Timeout Interrupt Flag bit\n- 1 = Bus Timeout occurred\n0 = No bus timeout\nBCLIF: Bus Collision Detect Interrupt Flag bit (1)\n- 1 = Bus collision detected (On the rising edge of SCL input, SDA output is high and input is sampled low)\nSlave and Master mode the module immediately goes Idle\nMulti-Master mode attempts to match slave addresses, and/or goes Idle\n- 0 = No bus collision detected",
    "bit 4 NACKIF: NACK Detect Interrupt Flag bit (1)\n- 1 = When (SMA = 1 || MMA = 1 ) and a NACK is detected on the bus\nNACKIF is also set when any of the TXWE, RXRE, TXU, or RXO bits are set.\n- 0 = No NACK/Error detected\nNACKIF is not set by the NACK send for non-matching slave addresses",
    "bit 3 Unimplemented: Read as ' 0 '\n- bit 2\nBTOIE: Bus Timeout Interrupt Enable bit\n1 = Enable interrupt on bus timeout\n0 = Bus Timeout not enabled\nBCLIE: Bus Collision Detect Interrupt Enable bit\n1 = Enable interrupt on bus collision\n0 = Bus collision interrupts are disabled\nNACKIE: NACK Detect Interrupt Enable bit\n1 = Enable interrupt on NACKIF\n0 = NACKIF interrupt is disabled\nNote1: Enabled error interrupt flags are OR'd to produce the PIRx<I2CxEIF> bit.\n2: User software must select the Bus Timeout Source in the I2CBTO register.\n(1,2)",
    "REGISTER 33-9: I2CxCNT: I 2 C BYTE COUNT REGISTER\nbit 7, R/W-x/u.CNT<7:0> = . bit 7, R/W-x/u.CNT<7:0> = . bit 7, R/W-x/u.CNT<7:0> = . bit 7, R/W-x/u.CNT<7:0> = . bit 7, R/W-x/u.CNT<7:0> = . bit 7, R/W-x/u.CNT<7:0> = . bit 7, R/W-x/u.CNT<7:0> = bit 0",
    "REGISTER 33-9: I2CxCNT: I 2 C BYTE COUNT REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as ' 0 '. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. ' 1 ' = Bit is set, 1 = ' 0 ' = Bit is cleared. ' 1 ' = Bit is set, 2 = HS = Hardware set HC = Hardware clear",
    "bit 7-0 CNT<7:0>: I 2 C Byte Count Register bits\nIf receiving data, decremented 8th SCL edge, when a new data byte is loaded into I2CxRXB If transmitting data,\ndecremented 9th SCL edge, when a new data byte is moved from I2CxTXB\nCNTIF flag is set on 9th falling SCL edge, when I2CxCNT = 0 . (Byte count cannot decrement past ' 0 ')\nNote1: It is recommended to write this register only when the module is IDLE (MMA = 0 , SMA = 0 ) or when clock stretching (CSTR = 1 || MDR = 1 ).",
    "REGISTER 33-10: I2CxPIR: I2CxIF INTERRUPT FLAG REGISTER\nR/W/HS-0, 1 = R/W/HS-0. R/W/HS-0, 2 = U-0. R/W/HS-0, 3 = R/W/HS-0. R/W/HS-0, 4 = R/W/HS-0. R/W/HS-0, 5 = R/W/HS-0. R/W/HS-0, 6 = R/W/HS-0. R/W/HS-0, 7 = R/W/HS-0. CNTIF, 1 = ACKTIF. CNTIF, 2 = -. CNTIF, 3 = WRIF. CNTIF, 4 = ADRIF. CNTIF, 5 = PCIF. CNTIF, 6 = RSCIF. CNTIF, 7 = SCIF. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit",
    "REGISTER 33-10: I2CxPIR: I2CxIF INTERRUPT FLAG REGISTER\n7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 7 CNTIF: Byte Count Interrupt Flag bit\n1 = When I2CxCNT = 0 , set by the 9th falling edge of SCL.\n0 = I2CxCNT condition has not occurred.\nbit 6\nACKTIF: Acknowledge Status Time Interrupt Flag bit (2) (MODE<2:0> = 0xx OR 11x )\n1 = Set by the 9th falling edge of SCL for any byte when addressed as a slave\n0 = Acknowledge condition not detected.",
    "bit 5\nUnimplemented: Read as ' 0 '\nbit 4\nWRIF: Data Write Interrupt Flag bit (MODE<2:0> = 0xx OR 11x )\n1 = Set the 8th falling edge of SCL for a received data byte.\n0 = Data Write condition not detected\nbit 3 ADRIF: Address Interrupt Flag bit (MODE<2:0> = 0xx OR 11x )\n1 = Set the 8th falling edge of SCL for a matching received (high/low) address byte\n0 = Address condition not detected",
    "bit 2\nPCIF: Stop Condition Interrupt Flag\n1 = Set on detection of Stop condition\n0 = No Stop condition detected",
    "bit 1 RSCIF: Restart Condition Interrupt Flag\n1 = Set on detection of Restart condition\n0 = No Restart condition detected",
    "bit 0\nSCIF: Start Condition Interrupt Flag\n1 = Set on detection of Start condition\n0 = No Start condition detected\nNote 1: Enabled interrupt flags are OR'd to produce the PIRx<I2CxIF> bit.\n2: ACKTIF is not set by a matching, 10-bit, high address byte with the R/W bit clear. It is only set after the matching low address byte is shifted in.",
    "REGISTER 33-11: I2CxPIE: I2CxIE INTERRUPT AND HOLD ENABLE REGISTER\nCNTIE, R/W-0 = ACKTIE. CNTIE, U-0 = -. CNTIE, R/W-0 = WRIE. CNTIE, R/W-0 = ADRIE. CNTIE, R/W-0 = PCIE. CNTIE, R/W-0 = RSCIE. CNTIE, R/W-0 = SCIE. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 33-11: I2CxPIE: I2CxIE INTERRUPT AND HOLD ENABLE REGISTER\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . ' 1 ' = Bit is set,  = ' 0 ' = Bit is cleared. ' 1 ' = Bit is set,  = HS = Hardware set HC = Hardware clear",
    "bit 7 CNTIE: Byte Count Interrupt Enable bit\n1 = When CNTIF is set\n0 = Byte count interrupts are disabled",
    "bit 6\nACKTIE: Acknowledge Interrupt and Hold Enable bit\n1 = When ACKTIF is set\nIf ACK is generated, CSTR is also set.\nIf NACK is generated, CSTR is unchanged\n0 = Acknowledge holding and interrupt is disabled",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nWRIE: Data Write Interrupt and Hold Enable bit\n1 = When WRIF is set; CSTR is set\n0 = Data Write holding and interrupt is disabled",
    "bit 3 ADRIE: Address Interrupt and Hold Enable bit\n1 = When ADRIF is set; CSTR is set\n0 = Address holding and interrupt is disabled\nbit 2\nPCIE: Stop Condition Interrupt Enable bit\n1 = Enable interrupt on detection of Stop condition\n0 = Stop detection interrupts are disabled",
    "bit 1\nRSCIE: Restart Condition Interrupt Enable bit\n1 = Enable interrupt on detection of Restart condition\n0 = Start detection interrupts are disabled\nbit 0\nSCIE: Start Condition Interrupt Enable bit\n1 = Enable interrupt on detection of Start condition\n0 = Start detection interrupts are disabled\nNote 1: Enabled interrupt flags are OR'd to produce the PIRx<I2CxIF> bit.",
    "REGISTER 33-12: I2CxADR0: I 2 C ADDRESS 0 REGISTER\nADR7, R/W-1 = ADR6. ADR7, R/W-1 = ADR5. ADR7, R/W-1 = ADR4. ADR7, R/W-1 = ADR3. ADR7, R/W-1 = ADR2. ADR7, R/W-1 = ADR1. ADR7, R/W-1 = ADR0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 7-0 ADR<7-0>: Address 0 bits\nMODE<2:0> = 00x | 11x - 7-bit Slave/Multi-Master Modes\nADR0<7:1>: 7-bit Slave Address\nADR0<0>:\nUnused in this mode; bit state is a 'don't care'\nMODE<2:0> = 01x\n- 10-bit Slave Modes\nADR0<7:0>: Eight Least Significant bits of 10-bit address 0",
    "REGISTER 33-13: I2CxADR1: I 2 C ADDRESS 1 REGISTER\nADR14, R/W-1 = ADR13. ADR14, R/W-1 = ADR12. ADR14, R/W-1 = ADR11. ADR14, R/W-1 = ADR10. ADR14, R/W-1 = ADR9. ADR14, R/W-1 = ADR8. ADR14, U-0 = -. bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, U-0 = bit 0. R/W-1, R/W-1 = R/W-1. R/W-1, R/W-1 = R/W-1. R/W-1, R/W-1 = R/W-1. R/W-1, R/W-1 = R/W-1.",
    "REGISTER 33-13: I2CxADR1: I 2 C ADDRESS 1 REGISTER\nR/W-1, R/W-1 = R/W-1. R/W-1, R/W-1 = R/W-1. R/W-1, U-0 = U-0. ADR7, R/W-1 = ADR6. ADR7, R/W-1 = ADR5. ADR7, R/W-1 = ADR4. ADR7, R/W-1 = ADR3. ADR7, R/W-1 = ADR2. ADR7, R/W-1 = ADR1. ADR7, U-0 = -. bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, U-0 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 7-1 ADR[7-1]: Address 1 bits\nMODE<2:0> = 000 110\n| - 7-bit Slave/Multi-Master Modes",
    "ADR<7:1>: 7-bit Slave Address\nMODE<2:0> = 001 | 111 - 7-bit Slave/Multi-Master modes w/Masking\nADR<7:1>: 7-bit Slave Address Mask",
    "MODE<2:0> =\n01x - 10-bit Slave Modes\nADR<14-10>: Bit pattern sent by master is fixed by I 2 C specification and must be equal to ' 11110 '. However, these bit values are compared by hardware to the received\ndata to determine a match. It is up to the user to set these bits as ' 11110 '.\nADR<9-8>: Two Most Significant bits of 10-bit address\nbit 0 Unimplemented: Read as ' 0 '.",
    "REGISTER 33-14: I2CxADR2: I 2 C ADDRESS 2 REGISTER\nADR7, R/W-1 = ADR6. ADR7, R/W-1 = ADR5. ADR7, R/W-1 = ADR4. ADR7, R/W-1 = ADR3. ADR7, R/W-1 = ADR2. ADR7, R/W-1 = ADR1. ADR7, R/W-1 = ADR0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 7-0 ADR<7-0>: Address 2 bits\nMODE<2:0> = 000 | 110 - 7-bit Slave/Multi-Master Modes\nADR<7:1>: 7-bit Slave Address\nMODE<2:0> =\n001 | 111 - 7-bit Slave/Multi-Master Modes with Masking\nADR<7:1>: 7-bit Slave Address\nMODE<2:0> = 010\n- 10-Bit Slave Mode\nADR<7:0>: Eight Least Significant bits of second 10-bit address\nMODE<2:0> =\n011 - 10-Bit Slave Mode with Masking\nADR<7-0>: Eight Least Significant bits of 10-bit address mask",
    "REGISTER 33-15: I2CXADR3: I 2 C ADDRESS 3 REGISTER\nADR14, R/W-1 = ADR13. ADR14, R/W-1 = ADR12. ADR14, R/W-1 = ADR11. ADR14, R/W-1 = ADR10. ADR14, R/W-1 = ADR9. ADR14, R/W-1 = ADR8. ADR14, U-0 = -. bit 15, R/W-1 = . bit 15, R/W-1 = . bit 15, R/W-1 = . bit 15, R/W-1 = . bit 15, R/W-1 = . bit 15, R/W-1 = . bit 15, U-0 = bit 8. R/W-1, R/W-1 = R/W-1. R/W-1, R/W-1 = R/W-1. R/W-1, R/W-1 = R/W-1. R/W-1, R/W-1 = R/W-1.",
    "REGISTER 33-15: I2CXADR3: I 2 C ADDRESS 3 REGISTER\nR/W-1, R/W-1 = R/W-1. R/W-1, R/W-1 = R/W-1. R/W-1, U-0 = U-0. ADR7, R/W-1 = ADR6. ADR7, R/W-1 = ADR5. ADR7, R/W-1 = ADR4. ADR7, R/W-1 = ADR3. ADR7, R/W-1 = ADR2. ADR7, R/W-1 = ADR1. ADR7, U-0 = -. bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, U-0 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 7-1 ADR<7-1>: Address 3 bits\nMODE<2:0> = 000 | 110 - 7-bit Slave/Multi-Master Modes\nADR<7:1>: 7-bit Slave Address\nMODE<2:0> =\n001\n|\n111\n- 7-bit Slave/Multi-Master Mode with Masking\nADR<7:1>: 7-bit Slave Address\nMODE<2:0> =\n010 - 10-Bit Slave Mode\nADR<14-10>: Bit pattern sent by master is fixed by I 2 C specification and must be equal to ' 11110 '. However, these bit values are compared by hardware to the received data to determine a match. It is up to the user to set these bits as ' 11110 ' ADR<9-8>: Two Most Significant bits of 10-bit address\nMODE<2:0> = 011\n- 10-Bit Slave Mode with Masking\nADR<14-8>: 10-bit high address mask\nbit 0 Unimplemented: Read as '0'",
    "REGISTER 33-16: I2CxADB0: I 2 C ADDRESS DATA BUFFER 0 REGISTER (1)\nADB7, R/W-x/u = ADB6. ADB7, R/W-x/u = ADB5. ADB7, R/W-x/u = ADB4. ADB7, R/W-x/u = ADB3. ADB7, R/W-x/u = ADB2. ADB7, R/W-x/u = ADB1. ADB7, R/W-x/u = ADB0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u =",
    "REGISTER 33-16: I2CxADB0: I 2 C ADDRESS DATA BUFFER 0 REGISTER (1)\nbit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as ' 0 '. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. ' 1 ' = Bit is set, 1 = ' 0 ' = Bit is cleared. ' 1 ' = Bit is set, 2 = HS = Hardware set HC = Hardware clear",
    "bit 7-0 MODE<2:0> = 00x\nADB<7:1>: Address Data byte\nReceived matching 7-bit slave address data\nR/W:\nRead/not-Write Data bit\nReceived read/write value from 7-bit address byte\nMODE<2:0> = 01x\nADB<7:0>: Address Data byte\nReceived matching lower eight bits of 10-bit slave address data\nMODE<2:0> = 100\nUnused in this mode; bit state is a 'don't care'\nMODE<2:0> = 101\nADB<7:0>: Low Address Data byte\nLow 10-bit address value copied to transmit shift register\nMODE<2:0> = 11x\nADB<7:1>: Address Data byte\nReceived matching 7-bit slave address\nR/W:\nRead/not-Write Data bit\nReceived read/write value received 7-bit slave address byte\nNote 1: This register is read only except in master, 10-bit Address mode (MODE<2:0> = 101 ).",
    "REGISTER 33-17: I2CxADB1: I 2 C ADDRESS DATA BUFFER 1 REGISTER (1)\nADB7, R/W-x/u = ADB6. ADB7, R/W-x/u = ADB5. ADB7, R/W-x/u = ADB4. ADB7, R/W-x/u = ADB3. ADB7, R/W-x/u = ADB2. ADB7, R/W-x/u = ADB1. ADB7, R/W-x/u = ADB0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u = bit 7 bit 0. bit 7 bit 0, R/W-x/u =",
    "REGISTER 33-17: I2CxADB1: I 2 C ADDRESS DATA BUFFER 1 REGISTER (1)\nbit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as ' 0 '\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n' 1 ' = Bit is set\n' 0 ' = Bit is cleared\nHS = Hardware set      HC = Hardware clear",
    "bit 7-0 MODE<2:0> =\n00x\nUnused in this mode; bit state is a 'don't care'\nMODE<2:0> = 01x\nADB<7:1>: 10-bit Address High byte\nReceived matching 10-bit high address data\nR/W: Read/not-Write Data bit\nReceived read/write value from matching 10-bit high address\nMODE<2:0> = 100\nADB<7:1>: Address Data byte\n7-bit address value copied to transmit shift register\nR/W: Read/not-Write Data bit\nRead/write value copied to transmit shift register\nMODE<2:0> = 101\nADB<7:1>: 10-bit Address High Data byte\n10-bit high address value copied to transmit shift register\nR/W: Read/not-Write Data bit\nRead/write value copied to transmit shift register\nMODE<2:0> = 11x\nADB<7:1>: Address Data byte\n7-bit address value copied to transmit shift register\nR/W: Read/not-Write Data bit\nRead/write value copied to transmit shift register",
    "bit 7-0 MODE<2:0> =\nNote 1: This register is read only in slave, 7-bit Addressing modes (MODE<2:0> = 0xx )",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\n2\nI2CxBTO, Bit 7 = -. I2CxBTO, Bit 6 = -. I2CxBTO, Bit 5 = -. I2CxBTO, Bit 4 = -. I2CxBTO, Bit 3 = -. I2CxBTO, Bit 2 = BTO<2:0>. I2CxBTO, Bit 1 = BTO<2:0>. I2CxBTO, Bit 0 = BTO<2:0>. I2CxBTO, Register on page = 569. I2CxCLK, Bit 7 = -. I2CxCLK, Bit 6 = -. I2CxCLK, Bit 5 = -. I2CxCLK, Bit 4 = -. I2CxCLK, Bit 3 = -. I2CxCLK, Bit 2 = CLK<2:0>. I2CxCLK, Bit 1 = CLK<2:0>. I2CxCLK, Bit 0 =",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\nCLK<2:0>. I2CxCLK, Register on page = 568. I2CxPIE, Bit 7 = CNTIE. I2CxPIE, Bit 6 = ACKTIE. I2CxPIE, Bit 5 = -. I2CxPIE, Bit 4 = WRIE. I2CxPIE, Bit 3 = ADRIE. I2CxPIE, Bit 2 = PCIE. I2CxPIE, Bit 1 = RSCIE. I2CxPIE, Bit 0 = SCIE. I2CxPIE, Register on page = 575. I2CxPIR, Bit 7 = CNTIF. I2CxPIR, Bit 6 = ACKTIF. I2CxPIR, Bit 5 = -. I2CxPIR, Bit 4 = WRIF. I2CxPIR, Bit 3 = ADRIF. I2CxPIR, Bit 2 = PCIF. I2CxPIR, Bit 1 = RSCIF. I2CxPIR, Bit 0 = SCIF.",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\nI2CxPIR, Register on page = 574. I2CxERR, Bit 7 = -. I2CxERR, Bit 6 = BTOIF. I2CxERR, Bit 5 = BCLIF. I2CxERR, Bit 4 = NACKIF. I2CxERR, Bit 3 = -. I2CxERR, Bit 2 = BTOIE. I2CxERR, Bit 1 = BCLIE. I2CxERR, Bit 0 = NACKIE. I2CxERR, Register on page = 572. I2CxSTAT0, Bit 7 = BFRE. I2CxSTAT0, Bit 6 = SMA. I2CxSTAT0, Bit 5 = MMA. I2CxSTAT0, Bit 4 = R. I2CxSTAT0, Bit 3 = D. I2CxSTAT0, Bit 2 = -. I2CxSTAT0, Bit 1 = -. I2CxSTAT0, Bit 0 =",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\n-. I2CxSTAT0, Register on page = 570. I2CxSTAT1, Bit 7 = TXWE. I2CxSTAT1, Bit 6 = -. I2CxSTAT1, Bit 5 = TXBE. I2CxSTAT1, Bit 4 = -. I2CxSTAT1, Bit 3 = RXRE. I2CxSTAT1, Bit 2 = CLRBF. I2CxSTAT1, Bit 1 = -. I2CxSTAT1, Bit 0 = RXBF. I2CxSTAT1, Register on page = 571. I2CxCON0, Bit 7 = EN. I2CxCON0, Bit 6 = RSEN. I2CxCON0, Bit 5 = S. I2CxCON0, Bit 4 = CSTR. I2CxCON0, Bit 3 = MDR. I2CxCON0, Bit 2 = MODE<2:0>. I2CxCON0, Bit 1 = MODE<2:0>.",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\nI2CxCON0, Bit 0 = MODE<2:0>. I2CxCON0, Register on page = 564. I2CxCON1, Bit 7 = ACKCNT. I2CxCON1, Bit 6 = ACKDT. I2CxCON1, Bit 5 = ACKSTAT. I2CxCON1, Bit 4 = ACKT. I2CxCON1, Bit 3 = -. I2CxCON1, Bit 2 = RXO. I2CxCON1, Bit 1 = TXU. I2CxCON1, Bit 0 = CSD. I2CxCON1, Register on page = 566. I2CxCON2, Bit 7 = ACNT. I2CxCON2, Bit 6 = GCEN. I2CxCON2, Bit 5 = FME. I2CxCON2, Bit 4 = ABD. I2CxCON2, Bit 3 = SDAHT<3:2>. I2CxCON2, Bit 2 =",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\nSDAHT<3:2>. I2CxCON2, Bit 1 = BFRET<1:0>. I2CxCON2, Bit 0 = BFRET<1:0>. I2CxCON2, Register on page = 567. I2CxADR0, Bit 7 = ADR<7:0>. I2CxADR0, Bit 6 = ADR<7:0>. I2CxADR0, Bit 5 = ADR<7:0>. I2CxADR0, Bit 4 = ADR<7:0>. I2CxADR0, Bit 3 = ADR<7:0>. I2CxADR0, Bit 2 = ADR<7:0>. I2CxADR0, Bit 1 = ADR<7:0>. I2CxADR0, Bit 0 = ADR<7:0>. I2CxADR0, Register on page = 576. I2CxADR1, Bit 7 = ADR<7:1>.",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\nI2CxADR1, Bit 6 = ADR<7:1>. I2CxADR1, Bit 5 = ADR<7:1>. I2CxADR1, Bit 4 = ADR<7:1>. I2CxADR1, Bit 3 = ADR<7:1>. I2CxADR1, Bit 2 = ADR<7:1>. I2CxADR1, Bit 1 = ADR<7:1>. I2CxADR1, Bit 0 = -. I2CxADR1, Register on page = 577. I2CxADR2, Bit 7 = ADR<7:0>. I2CxADR2, Bit 6 = ADR<7:0>. I2CxADR2, Bit 5 = ADR<7:0>. I2CxADR2, Bit 4 = ADR<7:0>. I2CxADR2, Bit 3 = ADR<7:0>. I2CxADR2, Bit 2 =",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\nADR<7:0>. I2CxADR2, Bit 1 = ADR<7:0>. I2CxADR2, Bit 0 = ADR<7:0>. I2CxADR2, Register on page = 578. I2CxADR3, Bit 7 = ADR<7:1>. I2CxADR3, Bit 6 = ADR<7:1>. I2CxADR3, Bit 5 = ADR<7:1>. I2CxADR3, Bit 4 = ADR<7:1>. I2CxADR3, Bit 3 = ADR<7:1>. I2CxADR3, Bit 2 = ADR<7:1>. I2CxADR3, Bit 1 = ADR<7:1>. I2CxADR3, Bit 0 = -. I2CxADR3, Register on page = 579. I2CxADB0, Bit 7 = ADB<7:0>. I2CxADB0, Bit 6 =",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\nADB<7:0>. I2CxADB0, Bit 5 = ADB<7:0>. I2CxADB0, Bit 4 = ADB<7:0>. I2CxADB0, Bit 3 = ADB<7:0>. I2CxADB0, Bit 2 = ADB<7:0>. I2CxADB0, Bit 1 = ADB<7:0>. I2CxADB0, Bit 0 = ADB<7:0>. I2CxADB0, Register on page = 580. I2CxADB1, Bit 7 = ADB<7:0>. I2CxADB1, Bit 6 = ADB<7:0>. I2CxADB1, Bit 5 = ADB<7:0>. I2CxADB1, Bit 4 = ADB<7:0>. I2CxADB1, Bit 3 = ADB<7:0>. I2CxADB1, Bit 2 = ADB<7:0>.",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\nI2CxADB1, Bit 1 = ADB<7:0>. I2CxADB1, Bit 0 = ADB<7:0>. I2CxADB1, Register on page = 581. I2CxCNT, Bit 7 = CNT<7:0>. I2CxCNT, Bit 6 = CNT<7:0>. I2CxCNT, Bit 5 = CNT<7:0>. I2CxCNT, Bit 4 = CNT<7:0>. I2CxCNT, Bit 3 = CNT<7:0>. I2CxCNT, Bit 2 = CNT<7:0>. I2CxCNT, Bit 1 = CNT<7:0>. I2CxCNT, Bit 0 = CNT<7:0>. I2CxCNT, Register on page = 573. I2CxRXB, Bit 7 = RXB<7:0>. I2CxRXB, Bit 6 =",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\nRXB<7:0>. I2CxRXB, Bit 5 = RXB<7:0>. I2CxRXB, Bit 4 = RXB<7:0>. I2CxRXB, Bit 3 = RXB<7:0>. I2CxRXB, Bit 2 = RXB<7:0>. I2CxRXB, Bit 1 = RXB<7:0>. I2CxRXB, Bit 0 = RXB<7:0>. I2CxRXB, Register on page = -. I2CxTXB, Bit 7 = TXB<7:0>. I2CxTXB, Bit 6 = TXB<7:0>. I2CxTXB, Bit 5 = TXB<7:0>. I2CxTXB, Bit 4 = TXB<7:0>. I2CxTXB, Bit 3 = TXB<7:0>. I2CxTXB,",
    "TABLE 33-18: SUMMARY OF REGISTERS FOR I 2 C 8-BIT MACRO\nBit 2 = TXB<7:0>. I2CxTXB, Bit 1 = TXB<7:0>. I2CxTXB, Bit 0 = TXB<7:0>. I2CxTXB, Register on page = -\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are unused by the I C module.",
    "34.0 CAN MODULE\nThis family of devices contain a Controller Area Net -work  (CAN)  module. The  CAN  module  is  fully  back -wards-compatible  with  the  CAN  and  ECAN  modules found in older PIC18 devices.\nThe Controller Area Network (CAN) module is a serial interface which is useful for communicating with other peripherals or microcontroller devices. This interface, or  protocol,  was  designed  to  allow  communications within noisy environments.\nThe CAN module is a communication controller, imple -menting the CAN 2.0A or B protocol as defined in the BOSCH specification. The module will support CAN 1.2, CAN  2.0A,  CAN  2.0B  Passive  and  CAN  2.0B Active versions of the protocol. The module implementation is a full CAN system; however, the CAN specification is not covered within this data sheet. Refer to the BOSCH CAN specification for further details.\nThe module features are as follows:",
    "34.0 CAN MODULE\n\u00b7 Implementation of the CAN protocol, CAN 1.2, CAN 2.0A and CAN 2.0B\n\u00b7 DeviceNet TM  data bytes filter support\n\u00b7 Standard and extended data frames\n\u00b7 0-8 bytes data length\n\u00b7 Programmable bit rate up to 1 Mbit/sec\n\u00b7 Fully backward compatible with CAN modules on older PIC18 devices\n\u00b7 Three modes of operation:\n-Mode 0 - Legacy mode\n-Mode 1 - Enhanced Legacy mode with DeviceNet support\n-Mode 2 - FIFO mode with DeviceNet support\n\u00b7 Support for remote frames with automated handling\n\u00b7 Double-buffered receiver with two prioritized received message storage buffers\n\u00b7 Six buffers programmable as RX and TX message buffers\n\u00b7 16 full (standard/extended identifier) acceptance filters that can be linked to one of four masks\n\u00b7 Two full acceptance filter masks that can be assigned to any filter\n\u00b7 One full acceptance filter that can be used as either an acceptance filter or acceptance filter mask\n\u00b7 Three dedicated transmit buffers with application specified prioritization and abort capability\n\u00b7 Programmable wake-up functionality with integrated low-pass filter\n\u00b7 Programmable Loopback mode supports self-test operation\n\u00b7 Signaling via interrupt capabilities for all CAN receiver and transmitter error states",
    "34.0 CAN MODULE\n\u00b7 Programmable clock source\n\u00b7 Programmable link to timer module for time-stamping and network synchronization\n\u00b7 Low-power Sleep mode",
    "34.1 Module Overview\nThe CAN bus module consists of a protocol engine and message  buffering  and  control.  The  CAN  protocol engine automatically handles all functions for receiving and transmitting messages on the CAN bus. Messages are  transmitted  by  first  loading  the  appropriate  data registers. Status and errors can be checked by reading the  appropriate  registers. Any  message  detected  on the CAN bus is checked for errors and then matched against filters to see if it should be received and stored in one of the two receive registers.\nThe CAN module supports the following frame types:\n\u00b7 Standard Data Frame\n\u00b7 Extended Data Frame\n\u00b7 Remote Frame\n\u00b7 Error Frame\n\u00b7 Overload Frame Reception\nThe CANRX input pin is selected with the CANRXPPS register. The CANTX output pin is selected with each pin's RxyPPS register.",
    "Note:\nThe CANRX pin defaults to pin RB3, but the  CANTX  has  no  default  location  and must  be  assigned  to  a  pin  before  CAN transmissions can occur.\nIn Normal mode, the user must ensure that the appropri -ate TRIS bit for CANRX is set and the appropriate TRIS bit  for  CANRX  is  cleared.  In  addition,  the  appropriate ANSEL bit for CANRX must be cleared to disable the analog input buffer.\nUnlike older Microchip devices with CAN functionality, the CAN pins can be mapped to pins with analog functionality. Ensure that the analog functionality on the CANRX pin is disabled, or the CAN mod -ule will not properly function.",
    "34.1.1 MODULE FUNCTIONALITY\nThe CAN bus module consists of a protocol engine, message buffering and control (see Figure 34-1). The protocol engine can best be understood by defining the types of data frames to be transmitted and received by the module.\nThe following sequence illustrates the necessary initial -ization  steps  before  the  CAN  module  can  be  used  to transmit or receive a message. Steps can be added or removed depending on the requirements of the application.\n1. Use the CANRXPPS and appropriate RxyPPS registers to map  the  CANRX  and  CANTX functions to the desired pins of the device.\n2. Initialize  LAT,  TRIS  and  ANSEL  bits  for  the selected CANRX and CANTX pins.\n3. Ensure that the CAN module is in Configuration mode.\n4. Select CAN Functional mode.\n5. Set up the Baud Rate registers.\n6. Set up the Filter and Mask registers.\n7. Set  the  CAN  module  to  Normal  mode  or  any other mode required by the application logic.",
    "34.2 CAN Modes of Operation\nThe CAN module has six main modes of operation:\n\u00b7 Configuration mode\n\u00b7 Disable/Sleep mode\n\u00b7 Normal Operation mode\n\u00b7 Listen Only mode\n\u00b7 Loopback mode\n\u00b7 Error Recognition mode\nAll modes, except Error Recognition, are requested by setting the REQOP bits (CANCON<7:5>). Error Recog -nition mode is requested through the RXM bits of the Receive  Buffer register(s). Entry into a mode  is acknowledged by monitoring the OPMODE bits.\nWhen  changing  modes,  the  mode  will  not  actually change  until  all  pending  message  transmissions  are complete. Because of this, the user must verify that the device has actually changed into the requested mode before further operations are executed.",
    "Note:\nThe  module  may  fail  to  change  modes from  Configuration  mode  if  the  CANRX and CANTX pins are not externally con -nected to a CAN transceiver. If connection to a transceiver is not desired for the par -ticular use case or application (for exam -ple,  transitioning  to  Loopback  mode  for development/debugging), the CANRX pin must be externally tied to VDD through a 10k pull-up resistor.",
    "34.2.1 CONFIGURATION MODE\nThe  CAN  module  has  to  be  initialized  before  the activation. This is only possible if the module is in the Configuration mode. The Configuration mode is requested by setting the REQOP<2:0> bits to 0b100 . Only when the Status bits OPMODE<2:0> are equal to 0b100 , can the initialization be performed. Afterwards, the Configuration registers, the acceptance mask reg -isters and the acceptance filter registers can be written.\nConfiguration mode protects the user from accidentally violating the CAN  protocol through programming errors, as all registers which control the configuration of the module can not be modified while the module is online. The CAN module will not enter the Configuration mode while a transmission or reception is taking place. The  following registers can only be modified in Configuration mode:\n\u00b7 Configuration Registers\n\u00b7 Functional Mode Selection Registers\n\u00b7 Bit Timing Registers\n\u00b7 Identifier Acceptance Filter Registers\n\u00b7 Identifier Acceptance Mask Registers\n\u00b7 Filter and Mask Control Registers\n\u00b7 Mask Selection Registers",
    "34.2.1 CONFIGURATION MODE\nIn the Configuration mode, the module will not transmit or receive. The error counters are cleared and the inter -rupt  flags  remain  unchanged.  The  programmer  will have access to Configuration registers that are access restricted in other modes. I/O pins will revert to normal I/O functions .",
    "34.2.2 DISABLE/SLEEP MODE\nWhen the REQOP<2:0> bits are set to ' 001 ', the mod -ule will enter Disable/Sleep mode. This mode is similar to disabling other peripheral modules by turning off the module enables. This causes the module internal clock to  stop unless the module is active (i.e., receiving or transmitting  a  message).  If  the  module  is  active,  the module will wait for 11 recessive bits on the CAN bus, detect that condition as an Idle bus, then accept the module  Disable/Sleep  command.  OPMODE<2:0>  = 001 indicates  whether the  module  successfully  went into the module Disable/Sleep mode. In Disable/Sleep mode,  the  module  will  not  transmit  or  receive.  The module has the ability to set the WAKIF bit due to bus activity.  However,  any  pending  interrupts  will  remain and the error counters will retain their value.",
    "34.2.2 DISABLE/SLEEP MODE\nThe WAKIF interrupt is the only module interrupt that is still active in the Disable/Sleep mode. If the WAKDIS is cleared and WAKIE is set, the processor will receive an interrupt whenever the module detects a recessive to dominant transition. On wake-up, the module will auto -matically be set to the previous mode of operation. For example, if the module was switched from Normal to Disable/Sleep  mode  on  bus  activity  wake-up,  the module will automatically enter into Normal mode and the first message that caused the module to wake-up is lost.  The  module  will  not  generate  any  error  frame. Firmware  logic  must  detect  this  condition  and  make sure that retransmission is requested. If the processor receives a wake-up interrupt while it is sleeping, more than one message may get lost. The actual number of messages lost would depend on the processor oscillator start-up time and incoming message bit rate.\nThe CANTX pin will stay in the recessive state while the module is in Disable/Sleep mode.",
    "34.2.3 NORMAL MODE\nThis is the standard operating mode of the CAN mod -ule. In this mode, the device actively monitors all bus messages  and  generates  Acknowledge  bits,  error frames, etc. This  is also the  only  mode  in  which  the CAN module will transmit messages over the CAN bus. The Normal mode is activated by clearing the mode request bits in the CANCON register.",
    "34.2.4 LISTEN ONLY MODE\nListen  Only  mode  provides  a  means  for  the  CAN module to receive all messages, including messages with  errors.  This  mode  can  be  used  for  bus  monitor applications  or  for  detecting  the  baud  rate  in  'hot plugging'  situations.  For  auto-baud  detection,  it  is necessary that there are at least two other nodes which are communicating with each other. The baud rate can be detected empirically by testing different values until valid messages are received. The Listen Only mode is a silent mode, meaning no messages will be transmitted while in this state, including error flags or Acknowledge signals. In Listen Only mode, both valid and invalid messages will be received, regardless of RXMn bit settings. The filters and masks can still be used  to  allow  only  particular  valid  messages  to  be loaded into the Receive registers, or the filter masks can be set to all zeros to allow a  message with any identifier to pass. All invalid messages will be received in this mode, regardless of filters and masks or RXMn Receive Buffer mode bits.The error counters are reset and deactivated in this state. The Listen Only mode is activated  by  setting  the  mode  request  bits  in  the CANCON register to 0b011 .",
    "34.2.5 LOOPBACK MODE\nThis mode will allow internal transmission of messages from the transmit buffers to the receive buffers without actually transmitting messages on the CAN bus. This mode can be used in system development and testing. In this mode, the ACK bit is ignored and the device will allow  incoming  messages  from  itself,  just  as  if  they were coming from another node. The Loopback mode is a silent mode, meaning no messages will be trans -mitted  while  in  this  state,  including  error  flags  or Acknowledge signals. The TXCAN pin will revert to port I/O  while  the  device  is  in  this  mode.  The  filters  and masks can be used to allow only particular messages to be loaded into the receive registers. The masks can be set to all zeros to provide a mode that accepts all messages. The Loopback mode is activated by setting the  mode  request  bits  in  the  CANCON  register  to 0b010 .",
    "34.2.6 ERROR RECOGNITION MODE\nThe module can be set to ignore all errors and receive any message. In functional Mode 0, the Error Recogni -tion mode is activated by setting the RXM<1:0> bits in the RXBnCON registers to ' 11 '. In this mode, the data which is in the message assembly buffer until the error time, is copied in the receive buffer and can be read via the CPU interface.",
    "34.3 CAN Module Functional Modes\nIn addition to CAN modes of operation, the CAN module offers a total of three functional modes. Each of these modes are identified as Mode 0, Mode 1 and Mode 2.",
    "34.3.1 MODE 0 - LEGACY MODE\nMode 0 is designed to be fully compatible with CAN modules used in PIC18CXX8 and PIC18FXX8 devices. This is the default mode of operation on all Reset con -ditions.  As a  result, module  code  written  for  the PIC18XX8 CAN module may be used on the CAN mod -ule with only very minor code changes.\nThe following is the list of resources available in Mode 0:\n\u00b7 Three transmit buffers: TXB0, TXB1 and TXB2\n\u00b7 Two receive buffers: RXB0 and RXB1\n\u00b7 Two acceptance masks, one for each receive buffer: RXM0, RXM1\n\u00b7 Six acceptance filters, 2 for RXB0 and 4 for RXB1: RXF0, RXF1, RXF2, RXF3, RXF4, RXF5",
    "34.3.2 MODE 1 - ENHANCED LEGACY MODE\nMode  1  is  similar  to  Mode  0,  with  the  exception that more resources are available in Mode 1. There are 16 acceptance filters and two acceptance mask regis -ters. Acceptance  Filter  15  can  be  used  as  either  an acceptance  filter  or  an  acceptance  mask  register.  In addition to three transmit and two receive buffers, there are six more message buffers. One or more of these additional buffers can be programmed as transmit or receive buffers. These additional buffers can also be programmed to automatically handle RTR messages.\nFourteen of sixteen acceptance filter registers can be dynamically  associated  to  any  receive  buffer  and acceptance mask register. One can use this capability to associate more than one filter to any one buffer.\nWhen a receive buffer is programmed to use standard identifier messages, part of the full acceptance filter reg -ister can be used as a data byte filter. The length of the data byte filter is programmable from 0 to 18 bits. This functionality simplifies implementation of high-level protocols, such as the DeviceNet\u2122 protocol.\nThe following is the list of resources available in Mode 1:",
    "34.3.2 MODE 1 - ENHANCED LEGACY MODE\n\u00b7 Three transmit buffers: TXB0, TXB1 and TXB2\n\u00b7 Two receive buffers: RXB0 and RXB1\n\u00b7 Six buffers programmable as TX or RX: B0-B5\n\u00b7 Automatic RTR handling on B0-B5\n\u00b7 Sixteen dynamically assigned acceptance filters: RXF0-RXF15\n\u00b7 Two dedicated acceptance mask registers; RXF15 programmable as third mask: RXM0-RXM1, RXF15\n\u00b7 Programmable data filter on standard identifier messages: SDFLC",
    "34.3.3 MODE 2 - ENHANCED FIFO MODE\nIn Mode 2, two or more receive buffers are used to form the receive FIFO (first in, first out) buffer. There is no one-to-one relationship between the receive buffer and acceptance filter registers. Any filter that is enabled and linked to any FIFO  receive buffer can generate acceptance and cause FIFO to be updated.\nFIFO  length  is  user-programmable,  from  2-8  buffers deep.  FIFO  length  is  determined  by  the  very  first programmable  buffer  that  is  configured  as  a  transmit buffer. For example, if Buffer 2 (B2) is programmed as a transmit buffer, FIFO consists of RXB0, RXB1, B0 and B1, creating a FIFO length of four. If all programmable buffers are configured as receive buffers, FIFO will have the maximum length of eight.\nThe following is the list of resources available in Mode 2:",
    "34.3.3 MODE 2 - ENHANCED FIFO MODE\n\u00b7 Three transmit buffers: TXB0, TXB1 and TXB2\n\u00b7 Two receive buffers: RXB0 and RXB1\n\u00b7 Six buffers programmable as TX or RX; receive buffers form FIFO: B0-B5\n\u00b7 Automatic RTR handling on B0-B5\n\u00b7 Sixteen acceptance filters: RXF0-RXF15\n\u00b7 Two dedicated acceptance mask registers; RXF15 programmable as third mask: RXM0-RXM1, RXF15\n\u00b7 Programmable data filter on standard identifier messages: SDFLC, useful for DeviceNet protocol",
    "34.4.1 DEDICATED TRANSMIT BUFFERS\nThe CAN module implements three dedicated transmit buffers - TXB0, TXB1 and TXB2. Each of these buffers occupies 14 bytes of SRAM and are mapped into the SFR memory map. These are the only transmit buffers available in Mode 0. Mode 1 and 2 may access these and other additional buffers.\nEach  transmit  buffer  contains  one  Control  register (TXBnCON), four Identifier registers (TXBnSIDL, TXBnSIDH, TXBnEIDL, TXBnEIDH), one Data Length Count register (TXBnDLC)  and eight Data Byte registers (TXBnDm).",
    "34.4.2 DEDICATED RECEIVE BUFFERS\nThe CAN module implements  two  dedicated  receive buffers: RXB0 and RXB1. Each of these buffers occu -pies  14  bytes  of  SRAM  and  are  mapped  into  SFR memory map. These are the only receive buffers avail -able in Mode 0. Mode 1 and 2 may access these and other additional buffers.\nEach  receive  buffer  contains  one  Control  register (RXBnCON), four Identifier registers (RXBnSIDL, RXBnSIDH, RXBnEIDL, RXBnEIDH), one Data Length Count register (RXBnDLC)  and  eight Data Byte registers (RXBnDm).\nThere  is  also  a  separate  Message Assembly  Buffer (MAB) which acts as an additional receive buffer. MAB is  always  committed  to  receiving  the  next  message from the bus and is not directly accessible to user firm -ware. The MAB assembles all incoming messages one by  one.  A message  is  transferred to appropriate receive  buffers  only  if  the  corresponding  acceptance filter criteria is met.",
    "34.4.3 PROGRAMMABLE TRANSMIT/ RECEIVE BUFFERS\nThe CAN module implements six non-dedicated buffers: B0-B5. These buffers are individually programmable as either  transmit  or  receive  buffers.  These  buffers  are available only in Mode 1 and 2. As with dedicated trans -mit  and  receive  buffers,  each  of  these  programmable buffers occupies 14 bytes of SRAM and are mapped into SFR memory map.\nEach  buffer  contains  one  Control  register  (BnCON), four  Identifier  registers  (BnSIDL,  BnSIDH,  BnEIDL, BnEIDH),  one  Data  Length  Count  register  (BnDLC) and eight Data Byte registers (BnDm). Each of these registers contains two sets of control bits. Depending on  whether  the  buffer  is  configured  as  transmit  or receive, one would use the corresponding control bit set.  By  default,  all  buffers  are  configured  as  receive buffers. Each buffer can be individually configured as a transmit or receive buffer by setting the corresponding TXENn bit in the BSEL0 register.",
    "34.4.3 PROGRAMMABLE TRANSMIT/ RECEIVE BUFFERS\nWhen  configured  as  transmit  buffers,  user  firmware may  access  transmit  buffers  in  any  order  similar  to accessing dedicated transmit buffers. In receive configuration with Mode 1 enabled, user firmware may also access receive buffers in any order required. But in Mode 2, all receive buffers are combined to form a single  FIFO. Actual FIFO length  is  programmable  by user firmware. Access to FIFO must be done through the  FIFO  Pointer  bits  (FP<4:0>)  in  the  CANCON register.  It  must  be  noted  that  there  is  no  hardware protection against out of order FIFO reads.",
    "34.4.4 PROGRAMMABLE AUTO-RTR BUFFERS\nIn  Mode 1 and 2, any of six programmable transmit/ receive buffers may be programmed to automatically respond  to  predefined  RTR  messages  without  user firmware intervention.  Automatic RTR  handling is enabled by setting the TX2EN bit in the BSEL0 register and the RTREN bit in the BnCON register. After this setup, when an RTR request is received, the TXREQ bit is automatically set and the current buffer content is automatically queued  for  transmission  as a RTR response. As with all transmit buffers, once the TXREQ bit  is  set,  buffer  registers  become  read-only  and any writes to them will be ignored.\nThe following outlines the steps required to automatically handle RTR messages:\n1. Set  buffer  to  Transmit  mode  by  setting  the TXnEN bit to ' 1 ' in the BSEL0 register.\n2. At least one acceptance filter must be associ -ated  with  this  buffer  and  preloaded  with  the expected RTR identifier.\n3. Bit, RTREN in the BnCON register, must be set to ' 1 '.\n4. Buffer  must  be  preloaded  with  the  data  to  be sent as a RTR response.",
    "34.4.4 PROGRAMMABLE AUTO-RTR BUFFERS\nNormally, user firmware will keep buffer data registers up to  date.  If  firmware  attempts  to  update  the  buffer while an automatic RTR response is in the process of transmission, all writes to buffers are ignored.",
    "34.5.1 INITIATING TRANSMISSION\nFor the MCU to have write access to the message buf -fer,  the  TXREQ  bit  must  be  clear,  indicating  that  the message buffer is clear of any pending message to be transmitted. At a minimum, the SIDH, SIDL and DLC registers must be loaded. If data bytes are present in the message, the Data registers must also be loaded. If the  message  is  to  use  extended  identifiers,  the EIDH:EIDL  registers  must  also  be  loaded  and  the EXIDE bit set.\nTo initiate message transmission, the TXREQ bit must be set for each buffer to be transmitted. When TXREQ is  set,  the  TXABT,  TXLARB  and TXERR  bits  will  be cleared.  To  successfully  complete  the  transmission, there must be at least one node with matching baud rate on the network.\nSetting  the  TXREQ  bit  does  not  initiate  a  message transmission; it merely flags a message buffer as ready for transmission.  Transmission  will  start  when  the device detects that the bus is available. The device will then begin transmission of the highest priority message that is ready.",
    "34.5.1 INITIATING TRANSMISSION\nWhen the transmission has completed successfully, the TXREQ bit will be cleared, the TXBnIF bit will be set and an interrupt will be generated if the TXBnIE bit is set.\nIf the message transmission fails, the TXREQ will remain set, indicating that the message is still pending for trans -mission and one of the following condition flags will be set. If the message started to transmit but encountered an error condition, the TXERR and the IRXIF bits will be set and an interrupt will be generated. If the message lost arbitration, the TXLARB bit will be set.",
    "34.5.2 ABORTING TRANSMISSION\nThe MCU can request to abort a message by clearing the TXREQ bit associated with the corresponding mes -sage buffer (TXBnCON<3> or BnCON<3>). Setting the ABAT  bit  (CANCON<4>)  will  request  an  abort  of  all pending messages. If the message has not yet started transmission, or if the message started but is interrupted by loss of arbitration or an error, the abort will be pro -cessed. The abort is indicated when the module sets the TXABT bit for the corresponding buffer (TXBnCON<6> or BnCON<6>). If the message has started to transmit, it will attempt to transmit the current message fully. If the current message is transmitted fully and is not lost to arbitration  or  an  error,  the  TXABT  bit  will  not  be  set because  the  message  was  transmitted  successfully. Likewise, if a message is being transmitted during an abort request and the message is lost to arbitration or an error,  the  message  will  not  be  retransmitted  and  the TXABT bit will be set, indicating that the message was successfully aborted.",
    "34.5.2 ABORTING TRANSMISSION\nOnce  an  abort  is  requested  by  setting  the ABAT  or TXABT bits, it cannot be cleared to cancel the abort request. Only CAN  module  hardware  or  a  POR condition can clear it.",
    "34.5.3 TRANSMIT PRIORITY\nTransmit  priority  is  a  prioritization  within  the  ECAN module of the pending transmittable messages. This is independent from, and not related to, any prioritization implicit in the message arbitration scheme built into the CAN  protocol.  Prior  to  sending  the  Start-of-Frame (SOF),  the  priority  of  all  buffers  that  are  queued  for transmission is compared. The transmit buffer with the highest priority will be sent first. If two buffers have the same priority setting, the buffer with the highest buffer number will be sent first. There are four levels of trans -mit priority. If the TXP bits for a particular message buf -fer are set to ' 11 ', that buffer has the highest possible priority. If the TXP bits for a particular message buffer are  set  to  ' 00 ',  that  buffer  has  the  lowest  possible priority.\nFIGURE 34-2:\nTRANSMIT BUFFERS",
    "34.6.1 RECEIVING A MESSAGE\nOf all receive buffers, the MAB is always committed to receiving  the  next  message  from  the  bus. The  MCU can access one buffer while the other buffer is available for message reception or holding a previously received message.\nNote:\nThe entire contents of the MAB are moved into the receive buffer once a message is accepted. This means that regardless of the type of identifier (standard or extended) and the number of data bytes received, the entire receive buffer is over -written with the MAB contents. Therefore, the contents of all registers in the buffer must be assumed to have been modified when any message is received.",
    "34.6.1 RECEIVING A MESSAGE\nthe  current  message  is  an  RTR  frame  or  not.  A received message is considered a standard identifier message if the EXID/EXIDE bit in the RXBnSIDL or the BnSIDL register is cleared. Conversely, a set EXID bit indicates an extended identifier message. If the received  message  is  a  standard  identifier  message, user firmware needs to read the SIDL and SIDH regis -ters.  In  the  case  of  an  extended  identifier  message, firmware should read the SIDL, SIDH, EIDL and EIDH registers. If the RXBnDLC or BnDLC register contain non-zero data count, user firmware should also read the corresponding number of data bytes by accessing the RXBnDm or the BnDm registers. When a received message is an RTR, and if the current buffer is not con -figured  for  automatic  RTR  handling,  user  firmware must take appropriate action and respond manually.",
    "34.6.1 RECEIVING A MESSAGE\nWhen a message is moved into either of the receive buffers, the associated RXFUL bit is set. This bit must be cleared by the MCU when it has completed process -ing the message in the buffer in order to allow a new message  to  be  received  into  the  buffer.  This  bit provides a positive lockout to ensure that the firmware has  finished  with  the  message  before  the  module attempts to load a new message into the receive buffer. If  the receive interrupt is enabled, an interrupt will be generated to indicate that a valid message has been received.\nOnce a message is loaded into any matching buffer, user firmware may determine exactly what filter caused this  reception  by  checking  the  filter  hit  bits  in  the RXBnCON or BnCON registers. In Mode 0, FILHIT<2:0>  of  RXBnCON  serve  as  filter  hit  bits.  In Mode 1 and 2, FILHIT<4:0> bits of BnCON serve as filter hit bits. The same registers also indicate whether",
    "34.6.1 RECEIVING A MESSAGE\nEach receive buffer contains RXM bits to set special Receive modes. In Mode 0, RXM<1:0>  bits in RXBnCON define  a  total  of  four  Receive  modes.  In Mode 1 and 2, RXM1 bit, in combination with the EXID mask and filter bit, define the same four receive modes. Normally, these bits are set to ' 00 ' to enable reception of all valid messages as determined by the appropriate acceptance  filters.  In  this  case,  the  determination  of whether  or not to receive standard or extended messages is determined by the EXIDE bit in the accep -tance filter register. In Mode 0, if the RXM bits are set to ' 01 ' or ' 10 ', the receiver will accept only messages with standard or extended identifiers, respectively. If an acceptance  filter  has  the  EXIDE  bit  set,  such  that  it does not correspond with the RXM mode, that accep -tance  filter  is  rendered  useless.  In  Mode  1  and  2, setting EXID in the SIDL Mask register will ensure that only  standard  or  extended  identifiers  are",
    "34.6.1 RECEIVING A MESSAGE\nreceived. These two modes of RXM bits can be used in systems where it is known that only standard or extended mes -sages will be on the bus. If the RXM bits are set to ' 11 ' (RXM1 = 1 in Mode 1 and 2), the buffer will receive all\nmessages regardless of the values of the acceptance filters. Also, if a message has an error before the end of frame, that portion of the message assembled in the MAB before the error frame will be loaded into the buf -fer. This mode may serve as a valuable debugging tool for a given CAN network. It should not be used in an actual  system  environment  as  the  actual  system  will always have some bus errors and all nodes on the bus are expected to ignore them.\nIn  Mode  1  and  2,  when  a  programmable  buffer  is configured as a transmit buffer and one or more accep -tance filters are associated with it, all incoming messages matching this acceptance filter criteria will be discarded. To avoid this scenario, user firmware must make sure that  there  are  no  acceptance  filters  associated  with  a buffer configured as a transmit buffer.",
    "34.6.2 RECEIVE PRIORITY\nWhen in Mode 0, RXB0 is the higher priority buffer and has two message acceptance filters associated with it. RXB1 is the lower priority buffer and has four acceptance filters associated with it. The lower number of acceptance filters  makes  the  match on  RXB0 more restrictive and implies a higher priority for that buffer. Additionally, the RXB0CON register can be configured such that if RXB0 contains a valid message and another valid message is received, an overflow error will not occur and the new message  will  be  moved  into  RXB1  regardless  of  the acceptance criteria of RXB1.  There  are also two programmable acceptance filter masks available, one for each receive buffer (see Section 34.4 'CAN Message Buffers' ).\nIn  Mode 1 and 2, there are a total of 16 acceptance filters available and each can be dynamically assigned to  any  of  the  receive  buffers.  A  buffer  with  a  lower number has higher priority. Given this, if an incoming message  matches  with  two  or  more  receive  buffer acceptance criteria, the buffer with the lower number will be loaded with that message.",
    "34.6.3 ENHANCED FIFO MODE\nWhen  configured  for  Mode  2,  two  of  the  dedicated receive buffers in combination with one or more pro -grammable transmit/receive buffers, are used to create a maximum of an eight buffers deep FIFO buffer. In this mode, there is no direct correlation between filters and receive buffer registers.  Any filter that has  been enabled can generate an acceptance. When a message has been accepted, it is stored in the next available receive buffer register and an internal Write Pointer is incremented. The FIFO can be a maximum of eight buffers deep. The entire FIFO must consist of contiguous receive buffers. The FIFO head begins at RXB0 buffer and its tail spans toward B5. The maxi -mum length of the FIFO is limited by the presence or absence of the first transmit buffer starting from B0. If a buffer  is  configured  as  a  transmit  buffer,  the  FIFO length  is  reduced  accordingly.  For  instance,  if  B3  is",
    "PIC18(L)F25/26K83\nconfigured  as  a  transmit  buffer,  the  actual  FIFO  will consist of RXB0, RXB1, B0, B1 and B2, a total of five buffers.  If  B0  is  configured  as  a  transmit  buffer,  the FIFO length will be two. If none of the programmable buffers are configured as a transmit buffer, the FIFO will be  eight  buffers  deep. A  system  that  requires  more transmit buffers should try to locate transmit buffers at the  very  end  of  B0-B5  buffers  to  maximize  available FIFO length.",
    "PIC18(L)F25/26K83\nWhen a message is received in FIFO mode, the Inter -rupt Flag Code bits (EICODE<4:0>) in the CANSTAT register  will  have  a  value  of  ' 10000 ',  indicating  the FIFO  has  received  a  message.  FIFO  Pointer  bits, FP<3:0> in the CANCON register, point to the buffer that contains data not yet read. The FIFO Pointer bits, in this sense, serve as the FIFO Read Pointer. The user should use the FP bits and read corresponding buffer data.  When  receive  data  is  no  longer  needed,  the RXFUL  bit  in  the  current  buffer  must  be  cleared, causing FP<3:0> to be updated by the module.",
    "PIC18(L)F25/26K83\nTo determine whether FIFO is empty or not, the user may use the FP<3:0> bits to access the RXFUL bit in the current buffer. If RXFUL is cleared, the FIFO is con -sidered to be empty. If it is set, the FIFO may contain one or more messages. In Mode 2, the module also provides a bit called FIFO High Water Mark (FIFOWM) in  the  ECANCON  register.  This  bit  can  be  used  to cause an interrupt  whenever  the  FIFO  contains  only one or four empty buffers. The FIFO high water mark interrupt can serve as an early warning to a full FIFO condition.",
    "34.6.4 TIME-STAMPING\nThe CAN module can be programmed to generate a time-stamp for every message that is received. When enabled, the module generates a capture signal for the CCP  modules,  which  in  turn  captures  the  value  of Timer1, Timer3 or Timer5. This value can be used as the message time-stamp.\nTo use the time-stamp capability, set the CTS<3:0> bits of the appropriate CCPxCAP register to ' 1000 ' to con -figure the CCP module capture input to the CAN_rx_ -timestamp signal.\nIn addition, the CAN_rx_timestamp can be chosen as a signal input for the Signal Measurement Timer, which can be used for a variety of other timing applications.",
    "34.7 Message Acceptance Filters and Masks\nThe message acceptance filters and masks are used to determine if a message in the Message Assembly Buf -fer  should  be  loaded  into  any  of  the  receive  buffers. Once a valid message has been received into the MAB, the identifier fields of the message are compared to the filter values. If there is a match, that message will be loaded  into  the  appropriate  receive  buffer.  The  filter masks are used to determine which bits in the identifier are  examined  with  the  filters. A  truth  table  is  shown below in Table 34-1 that indicates how each bit in the identifier  is compared  to  the  masks  and  filters  to determine if a message should be loaded into a receive buffer. The mask essentially determines which bits to apply the acceptance filters to. If any mask bit is set to a  zero,  then  that  bit  will  automatically  be  accepted regardless of the filter bit.",
    "34.7 Message Acceptance Filters and Masks\nTABLE 34-1: FILTER/MASK TRUTH TABLE\n\n0, Filter bit n = x. 0, Message Identifier bit n001 = x. 0, Accept or Reject bit n = Accept. 1, Filter bit n = 0. 1, Message Identifier bit n001 = 0. 1, Accept or Reject bit n = Accept. 1, Filter bit n = 0. 1, Message Identifier bit n001 = 1. 1, Accept or Reject bit n = Reject. 1, Filter bit n = 1. 1, Message Identifier bit n001 = 0. 1, Accept or Reject bit n = Reject. 1, Filter bit n = 1. 1, Message Identifier bit n001 = 1. 1, Accept or Reject bit n = Accept\nLegend:\nx = don't care\nIn  Mode 0, acceptance filters, RXF0 and RXF1, and filter mask, RXM0, are associated with RXB0. Filters, RXF2, RXF3, RXF4 and RXF5, and mask, RXM1, are associated with RXB1.",
    "34.7 Message Acceptance Filters and Masks\nIn Mode  1  and 2, there are an additional ten acceptance filters, RXF6-RXF15, creating a total of 16 available  filters.  RXF15  can  be  used  either  as  an acceptance filter or acceptance mask register. Each of these acceptance filters can be individually enabled or disabled by setting or clearing the RXFENn bit in the RXFCONn register. Any of these 16 acceptance filters can be dynamically associated with any of the receive buffers.  Actual  association  is  made  by  setting  the appropriate  bits  in  the  RXFBCONn  register.  Each RXFBCONn register contains a nibble for each filter. This nibble can be used to associate a specific filter to any  of  available  receive  buffers.  User  firmware  may associate  more  than  one  filter  to  any  one  specific receive buffer.",
    "34.7 Message Acceptance Filters and Masks\nIn  addition  to  dynamic  filter  to  buffer  association,  in Mode 1 and 2, each filter can also be dynamically asso -ciated  to  available  Acceptance  Mask  registers.  The FILn_m bits in the MSELn register can be used to link a specific acceptance filter to an acceptance mask reg -ister. As with filter to buffer association, one can also associate more than one mask to a specific acceptance filter.\nWhen a filter matches and a message is loaded into the receive  buffer,  the  filter number  that  enabled  the message reception is loaded into the FILHIT bit(s). In Mode 0 for RXB1, the RXB1CON register contains the FILHIT<2:0> bits. They are coded as follows:\n\u00b7 101 = Acceptance Filter 5 (RXF5)\n\u00b7 100 = Acceptance Filter 4 (RXF4)\n\u00b7 011 = Acceptance Filter 3 (RXF3)\n\u00b7 010 = Acceptance Filter 2 (RXF2)\n\u00b7 001 = Acceptance Filter 1 (RXF1)\n\u00b7 000 = Acceptance Filter 0 (RXF0)\nNote:",
    "34.7 Message Acceptance Filters and Masks\n' 000 ' and  ' 001 ' can  only  occur  if  the RXB0DBEN bit  is  set  in  the  RXB0CON register, allowing RXB0  messages  to rollover into RXB1.\nThe coding of the RXB0DBEN bit enables these three bits to be used similarly to the FILHIT bits and to distin -guish a hit on filter, RXF0 and RXF1, in either RXB0 or after a rollover into RXB1.\n\u00b7 111 = Acceptance Filter 1 (RXF1)\n\u00b7 110 = Acceptance Filter 0 (RXF0)\n\u00b7 001 = Acceptance Filter 1 (RXF1)\n\u00b7 000 = Acceptance Filter 0 (RXF0)\nIf  the  RXB0DBEN  bit  is  clear,  there  are  six  codes corresponding to the six filters. If the RXB0DBEN bit is set, there are six codes corresponding to the six filters, plus two additional codes corresponding to RXF0 and RXF1 filters, that rollover into RXB1.",
    "34.7 Message Acceptance Filters and Masks\nIn Mode 1 and 2, each buffer control register contains five bits of filter hit bits (FILHIT<4:0>). A binary value of ' 0 ' indicates a hit from RXF0 and 15 indicates RXF15.\nIf more than one acceptance filter matches, the FILHIT bits  will  encode  the  binary  value  of  the  lowest  num -bered filter that matched. In other words, if filter RXF2 and filter RXF4 match, FILHIT will be loaded with the value for RXF2. This essentially prioritizes the acceptance  filters  with  a  lower  number  filter  having higher  priority.  Messages  are  compared  to  filters  in ascending order of filter number.\nThe  mask  and  filter  registers  can  only  be  modified when the CAN module is in Configuration mode.",
    "34.8 Baud Rate Setting\nThe 'Nominal Bit Time' is defined as:\nAll  nodes  on  a  given  CAN  bus must  have  the  same nominal bit rate. The CAN protocol uses Non-Returnto-Zero (NRZ) coding which does not encode a clock within  the  data  stream.  Therefore,  the  receive  clock must be recovered by the receiving nodes and synchronized to the transmitter's clock.\nAs  oscillators  and  transmission  time  may  vary  from node  to  node,  the  receiver  must  have  some  type  of Phase Lock Loop (PLL) synchronized to data transmis -sion edges to synchronize and maintain the receiver clock. Since the data is NRZ coded, it is necessary to include  bit  stuffing  to  ensure  that  an  edge  occurs  at least every six bit times to maintain the Digital Phase Lock Loop (DPLL) synchronization.\nThe bit timing of the CAN module is implemented using a DPLL that is configured to synchronize to the incom -ing data and provides the nominal timing for the trans -mitted  data.  The  DPLL  breaks  each  bit  time  into multiple segments made up of minimal periods of time called the Time Quanta (TQ).",
    "34.8 Baud Rate Setting\nBus timing functions executed within the bit time frame, such as synchronization to the local oscillator, network transmission  delay  compensation  and  sample  point positioning, are defined by the programmable bit timing logic of the DPLL.\nAll devices on the CAN bus must use the same bit rate. However, all devices are not required to have the same master oscillator clock frequency. For the different clock frequencies of the individual devices, the bit rate has to be  adjusted  by  appropriately  setting  the  baud  rate prescaler and number of time quanta in each segment.\nThe 'Nominal Bit Rate' is the number of bits transmitted per second, assuming an ideal transmitter with an ideal oscillator,  in  the  absence  of  resynchronization.  The nominal bit rate is defined to be a maximum of 1 Mb/s.",
    "EQUATION 34-1: NOMINAL BIT TIME\nTBIT = 1/Nominal Bit Rate\nThe  Nominal  Bit  Time  can  be  thought  of  as  being divided into separate, non-overlapping time segments. These segments (Figure 34-4) include:\n\u00b7 Synchronization Segment (Sync_Seg)\n\u00b7 Propagation Time Segment (Prop_Seg)\n\u00b7 Phase Buffer Segment 1 (Phase_Seg1)\n\u00b7 Phase Buffer Segment 2 (Phase_Seg2)\nThe time segments (and thus, the Nominal Bit Time) are, in turn, made up of integer units of time called Time Quanta  or  TQ (see  Figure 34-4).  By  definition,  the Nominal Bit Time is programmable from a minimum of 8 TQ to a maximum of 25 TQ. Also by definition, the minimum Nominal Bit Time is 1 \uf06d s, corresponding to a maximum 1 Mb/s rate. The actual duration is given by the following relationship:",
    "EQUATION 34-2: NOMINAL BIT TIME DURATION\nNominal Bit Time = TQ * (Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2)\nThe  Time  Quantum  is  a  fixed  unit  derived  from  the oscillator period. It is also defined by the programmable baud rate prescaler, with integer values from 1 to 64, in addition to a fixed divide-by-two for clock generation. Mathematically, this is:",
    "EQUATION 34-3: TIME QUANTUM\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nwhere  FOSC  is  the  clock  frequency,  TOSC  is  the corresponding oscillator period and BRP is an integer (0  through  63)  represented  by  the  binary  values  of BRGCON1<5:0>.  The  equation  above  refers  to  the effective clock frequency used by the microcontroller. If, for example, a 10 MHz crystal in HS mode is used, then FOSC = 10 MHz and TOSC = 100 ns. If the same 10 MHz crystal  is  used  in  HS-PLL  mode,  then  the  effective frequency is FOSC = 40 MHz and TOSC = 25 ns.",
    "34.8.1 EXTERNAL CLOCK, INTERNAL CLOCK AND MEASURABLE JITTER IN HS-PLL BASED OSCILLATORS\nThe microcontroller clock frequency generated from a PLL circuit is subject to a jitter, also defined as Phase Jitter or Phase Skew. For its PIC18 Enhanced micro -controllers,  Microchip specifies phase  jitter  ( P jitter )  as being 2% (Gaussian distribution, within three standard deviations,  see  Parameter  PLL04  in  Table 45-9)  and Total Jitter ( T jitter ) as being 2 * P jitter .\nThe  CAN  protocol  uses  a  bit-stuffing  technique  that inserts a bit of a given polarity following five bits with the opposite polarity. This gives a total of ten bits transmit -ted without resynchronization (compensation for jitter or phase error).",
    "34.8.1 EXTERNAL CLOCK, INTERNAL CLOCK AND MEASURABLE JITTER IN HS-PLL BASED OSCILLATORS\nGiven the random nature of the added jitter error, it can be shown that the total error caused by the jitter tends to cancel itself over time. For a period of ten bits, it is necessary to add only two jitter intervals to correct for jitter induced error: one interval in the beginning of the 10-bit period and another at the end. The overall effect is shown in Figure 34-5.",
    "FIGURE 34-5: EFFECTS OF PHASE JITTER ON THE MICROCONTROLLER CLOCK AND CAN BIT TIME\nOnce these considerations are taken into account, it is possible to show that the relation between the jitter and the total frequency error can be defined as:",
    "EQUATION 34-6: RESULTANT FREQUENCY ERROR:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nTable 34-2 shows  the  relation between  the  clock generated  by  the  PLL  and  the  frequency  error  from jitter  (measured  jitter-induced  error  of  2%,  Gaussian distribution,  within  three  standard  deviations),  as  a percentage of the nominal clock frequency.\nThis  is  clearly  smaller  than  the  expected  drift  of  a crystal  oscillator,  typically  specified  at  100 ppm  or 0.01%. If we add jitter to oscillator drift, we have a total frequency drift of 0.0132%. The total oscillator frequency errors for common clock frequencies and bit rates,  including  both  drift  and  jitter,  are  shown  in Table 34-3.",
    "EQUATION 34-4: JITTER AND TOTAL FREQUENCY ERROR\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nwhere jitter is expressed in terms of time and NBT is the Nominal Bit Time.\nFor example, assume a CAN bit rate of 125 Kb/s, which gives an NBT of 8 \u00b5s. For a 16 MHz clock generated from a 4x PLL, the jitter at this clock frequency is:",
    "EQUATION 34-5: 16 MHz CLOCK FROM 4x PLL JITTER:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nand resultant frequency error is:",
    "TABLE 34-2: FREQUENCY ERROR FROM JITTER AT VARIOUS PLL GENERATED CLOCK SPEEDS\n40 MHz, P jitter = 0.5 ns. 40 MHz, T jitter = 1 ns. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.00125%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.00250%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).2 \uf06d s (500 Kb/s) = 0.005%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).1 \uf06d s (1 Mb/s) = 0.01%. 24 MHz, P jitter = 0.83 ns. 24 MHz, T jitter = 1.67 ns. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.00209%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.00418%. 24 MHz, Frequency Error at Various Nominal Bit Times",
    "TABLE 34-2: FREQUENCY ERROR FROM JITTER AT VARIOUS PLL GENERATED CLOCK SPEEDS\n(Bit Rates).2 \uf06d s (500 Kb/s) = 0.008%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).1 \uf06d s (1 Mb/s) = 0.017%. 16 MHz, P jitter = 1.25 ns. 16 MHz, T jitter = 2.5 ns. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.00313%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.00625%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).2 \uf06d s (500 Kb/s) = 0.013%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).1 \uf06d s (1 Mb/s) = 0.025%",
    "TABLE 34-3: TOTAL FREQUENCY ERROR AT VARIOUS PLL GENERATED CLOCK SPEEDS (100 PPM OSCILLATOR DRIFT, INCLUDING ERROR FROM JITTER)\n40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.01125%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.01250%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).2 \uf06d s (500 Kb/s) = 0.015%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).1 \uf06d s (1 Mb/s) = 0.02%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.01209%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.01418%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).2 \uf06d s (500 Kb/s) = 0.018%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit",
    "TABLE 34-3: TOTAL FREQUENCY ERROR AT VARIOUS PLL GENERATED CLOCK SPEEDS (100 PPM OSCILLATOR DRIFT, INCLUDING ERROR FROM JITTER)\nRates).1 \uf06d s (1 Mb/s) = 0.027%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.01313%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.01625%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).2 \uf06d s (500 Kb/s) = 0.023%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).1 \uf06d s (1 Mb/s) = 0.035%",
    "34.8.2 TIME QUANTA\nAs already mentioned, the Time Quanta is a fixed unit derived  from  the oscillator period and  baud  rate prescaler. Its relationship to TBIT and the Nominal Bit Rate is shown in Example 34-1.",
    "EXAMPLE 34-1:\nCALCULATING TQ, NOMINAL BIT RATE AND NOMINAL BIT TIME\nTQ ( \uf06d s) = (2 * (BRP + 1))/FOSC (MHz)\nTBIT ( \uf06d s) = TQ ( \uf06d s) * number of TQ per bit interval\nNominal Bit Rate (bits/s) = 1/TBIT\nThis frequency (FOSC) refers to the effective frequency used. If, for example, a 10 MHz external signal is used along with a PLL, then the effective frequency will be 4 x 10 MHz which equals 40 MHz.",
    "CASE 1:\nFor FOSC = 16 MHz, BRP<5:0> = 00h and Nominal Bit Time = 8 TQ:\nTQ = (2 * 1)/16 = 0.125 \uf06d s (125 ns)\nTBIT = 8 * 0.125 = 1 \uf06d s (10 -6 s)\nNominal Bit Rate = 1/10 -6 = 10 6 bits/s (1 Mb/s)",
    "CASE 2:\nFor FOSC = 20 MHz, BRP<5:0> = 01h and Nominal Bit Time = 8 TQ:\nTQ = (2 * 2)/20 = 0.2 \uf06d s (200 ns)\nTBIT = 8 * 0.2 = 1.6 \uf06d s (1.6 * 10 -6 s)\nNominal Bit Rate = 1/1.6 * 10 -6 s = 625,000 bits/s (625 Kb/s)",
    "CASE 3:\nFor FOSC = 25 MHz, BRP<5:0> = 3Fh and Nominal Bit Time = 25 TQ:\nThe frequencies of the oscillators in the different nodes must be coordinated in order to provide a system wide specified Nominal Bit Time. This means that all oscilla -tors must have a TOSC that is an integral divisor of TQ. It should also be noted that although the number of TQ\nis programmable from 4 to 25, the usable minimum is 8 TQ. There is no assurance that a bit time of less than 8 TQ in length will operate correctly.",
    "34.8.3 SYNCHRONIZATION SEGMENT\nThis  part  of  the  bit  time  is  used  to  synchronize  the various CAN nodes on the bus. The edge of the input signal is expected to occur during the sync segment. The duration is 1 TQ.",
    "34.8.4 PROPAGATION SEGMENT\nThis part of the bit time is used to compensate for phys -ical delay times within the network. These delay times consist of the signal propagation time on the bus line and the internal delay time of the nodes. The length of the  propagation  segment  can  be  programmed  from 1 TQ to 8 TQ by setting the PRSEG<2:0> bits.",
    "34.8.5 PHASE BUFFER SEGMENTS\nThe phase buffer segments are used to optimally locate the sampling point of the received bit within the Nominal Bit Time. The sampling point occurs between Phase Seg -ment 1 and Phase Segment 2. These segments can be lengthened  or  shortened  by  the  resynchronization  pro -cess. The end of Phase Segment 1 determines the sam -pling point within a  bit time. Phase  Segment  1  is programmable from 1 TQ to 8 TQ in duration. Phase Seg -ment 2 provides a delay before the next transmitted data transition and is also programmable from 1 TQ to 8 TQ in duration. However, due to IPT requirements, the actual minimum length of Phase Segment 2 is 2 TQ, or it may be defined to be equal to the greater of Phase Segment 1 or the  Information  Processing  Time  (IPT).  The  sampling point should be as late as possible or approximately 80% of the bit time.",
    "34.8.6 SAMPLE POINT\nThe sample point is the point of time at which the bus level is read and the value of the received bit is determined. The sampling point occurs at the end of Phase Segment 1. If the bit timing is slow and contains many TQ, it is possible to specify multiple sampling of the bus line at the sample point. The value of the received bit is deter -mined to be the value of the majority decision of three val -ues. The three samples are taken at the sample point and twice before, with a time of TQ/2 between each sample.",
    "34.8.7 INFORMATION PROCESSING TIME\nThe  Information  Processing  Time  (IPT)  is  the  time segment starting at the sample point that is reserved for  calculation  of  the  subsequent  bit  level.  The  CAN specification defines this time to be less than or equal to 2 TQ. The ECAN module defines this time to be 2 TQ. Thus, Phase Segment 2 must be at least 2 TQ long.",
    "34.8.8 CLOCK SELECTION\nThe  CLKSEL  bit  of  the  CIOCON  register  allows  for selection between two CAN  input clocks. When CLKSEL = 0 (default),  the  CAN  clock  (FOSC  in  the equations above) will be the same as the system clock. When CLKSEL = 1 ,  the  CAN  clock  will  be  the  clock selected  by  the  FEXTOSC  Configuration  bit,  regard -less of the system clock. This allows for the core of the device to be clocked by a PLL at 64 MHz (16 MHz HS crystal+4xPLL) while keeping the CAN clocked by the base 16  MHz HS crystal without the PLL, for example.\nNote:",
    "34.8.8 CLOCK SELECTION\nIf  CLKSEL = 1 ,  the  system  clock  must  be greater  than  or  equal  to  the  FEXTOSC selected  clock.  Having  a  slower  system clock than the CAN clock will lead to unex -pected  behavior.The  Information  Process -ing Time (IPT) is the time segment starting at the sample point that is reserved for cal -culation  of  the  subsequent  bit  level.  The CAN  specification  defines  this  time  to  be less than or equal to 2 TQ. The CAN module defines this time to be 2 TQ. Thus, Phase Segment 2 must be at least 2 TQ long.",
    "34.9 Synchronization\nTo compensate for phase shifts between the oscillator frequencies of each of the nodes on the bus, each CAN controller must be able to synchronize to the relevant signal edge of the incoming signal. When an edge in the transmitted data is detected, the logic will compare the location of the edge to the expected time (Sync_Seg). The circuit will then adjust the values of Phase Segment 1 and Phase Segment 2 as necessary. There are two mechanisms used for synchronization.",
    "34.9.1 HARD SYNCHRONIZATION\nHard  synchronization  is  only  done  when  there  is  a recessive to dominant edge during a bus Idle condition, indicating the start of a message. After hard synchroni -zation, the bit time counters are restarted with Sync_Seg.  Hard  synchronization  forces  the  edge, which  has  occurred  to  lie  within  the  synchronization segment of the restarted bit time. Due to the rules of synchronization, if a hard synchronization occurs, there will not be a resynchronization within that bit time.",
    "34.9.2 RESYNCHRONIZATION\nAs  a  result  of  resynchronization,  Phase  Segment  1 may be lengthened or Phase Segment 2 may be short -ened. The amount of lengthening or shortening of the phase buffer segments has an upper bound given by the Synchronization Jump Width (SJW). The value of the  SJW  will  be  added  to  Phase  Segment  1  (see Figure 34-6) or subtracted from Phase Segment 2 (see Figure 34-7). The SJW is programmable between 1 TQ and 4 TQ.\nClocking information will only be derived from reces -sive to dominant transitions. The property, that only a fixed  maximum  number  of  successive  bits  have  the same  value,  ensures  resynchronization  to  the  bit stream during a frame.\nThe phase error of an edge is given by the position of the edge relative to Sync_Seg, measured in TQ. The phase error is defined in magnitude of TQ as follows:\n\u00b7 e = 0 if the edge lies within Sync_Seg.\n\u00b7 e > 0 if the edge lies before the sample point.\n\u00b7 e < 0 if the edge lies after the sample point of the previous bit.",
    "34.9.2 RESYNCHRONIZATION\nIf the magnitude of the phase error is less than, or equal to, the programmed value of the Synchronization Jump Width, the effect of a resynchronization is the same as that of a hard synchronization.\nIf  the magnitude of the phase error is larger than the Synchronization Jump Width and if the phase error is positive, then Phase Segment 1 is lengthened by an amount equal to the Synchronization Jump Width.\nIf  the magnitude of the phase error is larger than the resynchronization jump width and if the phase error is negative, then Phase Segment 2 is shortened by an amount equal to the Synchronization Jump Width.",
    "34.9.3 SYNCHRONIZATION RULES\n\u00b7 Only one synchronization within one bit time is allowed.\n\u00b7 An edge will be used for synchronization only if the value detected at the previous sample point (previously read bus value) differs from the bus value immediately after the edge.\n\u00b7 All other recessive to dominant edges fulfilling rules 1 and 2 will be used for resynchronization, with the exception that a node transmitting a dominant bit will not perform a resynchronization as a result of a recessive to dominant edge with a positive phase error.",
    "34.11 Oscillator Tolerance\nSome  requirements  for  programming  of  the  time segments:\n\u00b7 Prop_Seg + Phase_Seg 1 \uf0b3 Phase_Seg 2\n\u00b7 Phase_Seg 2 \uf0b3 Sync Jump Width.\nFor example, assume that a 125 kHz CAN baud rate is desired, using 20 MHz for FOSC. With a TOSC of 50 ns, a baud rate prescaler value of 04h gives a TQ of 500 ns. To obtain a Nominal Bit Rate of 125 kHz, the Nominal Bit Time must be 8 \uf06d s or 16 TQ.\nUsing 1 TQ for the Sync_Seg, 2 TQ for the Prop_Seg and 7 TQ for Phase Segment 1 would place the sample point at 10 TQ after the transition. This leaves 6 TQ for Phase Segment 2.\nBy the rules above, the Sync Jump Width could be the maximum of 4 TQ. However, normally a large SJW is only  necessary  when  the  clock  generation  of  the different nodes is inaccurate or unstable, such as using ceramic resonators. Typically, an SJW of 1 is enough.",
    "34.11 Oscillator Tolerance\nAs a rule of thumb, the bit timing requirements allow ceramic  resonators  to  be  used  in  applications  with transmission rates of up to 125 Kbit/sec. For the full bus speed range of the CAN protocol, a quartz oscillator is required. Refer to ISO11898-1 for oscillator tolerance requirements.",
    "34.12 Bit Timing Configuration Registers\nThe Baud Rate Control registers (BRGCON1, BRGCON2, BRGCON3) control the bit timing for the CAN  bus  interface.  These  registers  can  only be modified  when  the  CAN  module  is  in  Configuration mode.",
    "34.12.1 BRGCON1\nThe  BRP  bits  control  the  baud  rate  prescaler.  The SJW<1:0> bits select the synchronization jump width in terms of multiples of TQ.",
    "34.12.2 BRGCON2\nThe PRSEG bits set the length of the propagation seg -ment in terms of TQ. The SEG1PH bits set the length of Phase  Segment  1  in  TQ.  The  SAM  bit  controls  how many times the RXCAN pin is sampled. Setting this bit to a ' 1 ' causes the bus to be sampled three times: twice at TQ/2 before the sample point and once at the normal sample point (which is at the end of Phase Segment 1). The value of the bus is determined to be the value read during at least two of the samples. If the SAM bit is set to a ' 0 ', then the RXCAN pin is sampled only once at the sample point. The SEG2PHTS bit controls how the length of Phase Segment 2 is determined. If this bit is set  to  a  ' 1 ',  then  the  length  of  Phase  Segment  2  is determined by the SEG2PH bits of BRGCON3. If the SEG2PHTS bit is set to a ' 0 ', then the length of Phase Segment 2 is the greater of Phase Segment 1 and the information processing time (which is fixed at 2 TQ for the ECAN module).",
    "34.12.3 BRGCON3\nThe PHSEG2<2:0> bits set the length (in TQ) of Phase Segment 2 if the SEG2PHTS bit is set to a ' 1 '.  If  the SEG2PHTS bit is set to a ' 0 ', then the PHSEG2<2:0> bits have no effect.",
    "34.13 Error Detection\nThe CAN protocol provides sophisticated error detection  mechanisms.  The  following  errors  can  be detected.",
    "34.13.1 CRC ERROR\nWith the Cyclic Redundancy Check (CRC), the trans -mitter calculates special check bits for the bit sequence, from the start of a frame until the end of the data  field.  This  CRC  sequence  is  transmitted  in  the CRC field. The receiving node also calculates the CRC sequence  using  the  same  formula  and  performs  a comparison to the received sequence. If a mismatch is detected, a CRC error has occurred and an error frame is generated. The message is repeated.",
    "34.13.2 ACKNOWLEDGE ERROR\nIn the Acknowledge field of a message, the transmitter checks if the Acknowledge slot (which was sent out as a recessive bit) contains a dominant bit. If not, no other node  has  received  the  frame  correctly. An Acknowl -edge error has occurred, an error frame is generated and the message will have to be repeated.",
    "34.13.3 FORM ERROR\nIf a node detects a dominant bit in one of the four seg -ments, including End-of-Frame (EOF), interframe space, Acknowledge delimiter or CRC delimiter, then a form error has occurred and an error frame is generated. The message is repeated.",
    "34.13.4 BIT ERROR\nA bit error occurs if a transmitter sends a dominant bit and detects a recessive bit, or if it sends a recessive bit and detects a dominant bit, when monitoring the actual bus level and comparing it to the just transmitted bit. In the case where the transmitter sends a recessive bit and a dominant bit is detected  during  the  arbitration field and the  Acknowledge slot, no bit error is generated because normal arbitration is occurring.",
    "34.13.5 STUFF BIT ERROR\nlf,  between  the  Start-of-Frame  (SOF)  and  the  CRC delimiter, six consecutive bits with the same polarity are detected, the bit stuffing rule has been violated. A stuff bit error occurs and an error frame is generated. The message is repeated.",
    "34.13.6 ERROR STATES\nDetected errors are made public to all other nodes via error frames. The transmission of the erroneous mes -sage is aborted and the frame is repeated as soon as possible. Furthermore, each CAN node is in one of the three  error  states;  'error-active',  'error-passive'  or 'bus-off',  according  to  the  value  of  the  internal  error counters.  The  error-active  state  is  the  usual  state where the bus node can transmit messages and acti -vate error frames (made of dominant bits) without any restrictions. In the error-passive state, messages and passive error frames (made of recessive bits) may be transmitted.  The  bus-off  state  makes  it  temporarily impossible  for the node  to  participate in the bus communication. During this state, messages can neither be received nor transmitted.",
    "34.13.7 ERROR MODES AND ERROR COUNTERS\nThe  CAN  module  contains  two  error  counters:  the Receive Error Counter (RXERRCNT) and the Transmit Error Counter (TXERRCNT). The values of both count -ers can be read by the MCU. These counters are incre -mented  or  decremented  in  accordance  with  the  CAN bus specification.",
    "34.13.7 ERROR MODES AND ERROR COUNTERS\nThe CAN module is error-active if both error counters are below the error-passive limit of 128. They are errorpassive if at least one of the error counters equals or exceeds 128. They go to bus-off if the transmit error counter equals or exceeds the bus-off limit of 256. The devices remain in this state until the bus-off recovery sequence is finished. The bus-off recovery sequence consists of 128 occurrences of 11 consecutive reces -sive bits (see Figure 34-8). Note that the CAN module, after  going  bus-off,  will  recover  back  to  error-active without any intervention by the MCU if the bus remains Idle for 128 x 11 bit times. If this is not desired, the error Interrupt Service Routine should address this. The cur -rent Error mode of the CAN module can be read by the MCU via the COMSTAT register.\nAdditionally,  there  is  an  Error  State  Warning  flag  bit, EWARN, which is set if at least one of the error count -ers  equals  or  exceeds  the  error  warning  limit  of  96. EWARN is reset if both error counters are less than the error warning limit.",
    "34.14 CAN Interrupts\nThe module has several sources of interrupts. Each of these  interrupts  can  be  individually  enabled  or  dis -abled. The PIR5 register contains interrupt flags. The PIE5 register contains the enables for the eight main interrupts.  A special set of read-only bits in the CANSTAT  register,  the  ICODE  bits,  can  be  used  in combination with a jump table for efficient handling of interrupts.\nAll interrupts have one source, with the exception of the error interrupt and buffer interrupts in Mode 1 and 2. Any of the error interrupt sources can set the error interrupt flag. The source of the error interrupt can be determined by reading the Communication Status register, COMSTAT.  In  Mode  1  and  2,  there  are  two  interrupt enable/disable and flag bits - one for all transmit buffers and the other for all receive buffers.\nThe interrupts can be broken up into two categories: receive and transmit interrupts.\nThe receive related interrupts are:\n\u00b7 Receive Interrupts\n\u00b7 Wake-up Interrupt\n\u00b7 Receiver Overrun Interrupt\n\u00b7 Receiver Warning Interrupt\n\u00b7 Receiver Error-Passive Interrupt\nThe transmit related interrupts are:\n\u00b7 Transmit Interrupts\n\u00b7 Transmitter Warning Interrupt\n\u00b7 Transmitter Error-Passive Interrupt\n\u00b7 Bus-Off Interrupt",
    "34.14.1 INTERRUPT CODE BITS\nTo simplify  the  interrupt  handling  process  in  user  firm -ware, the ECAN module encodes a special set of bits. In Mode 0,  these  bits  are  ICODE<3:1>  in  the  CANSTAT register. In Mode 1 and 2, these bits are EICODE<4:0> in the CANSTAT register. Interrupts are internally prioritized such that the higher priority interrupts are assigned lower values. Once the highest priority interrupt condition has been cleared, the code for the next highest priority inter -rupt that is pending (if any) will be reflected by the ICODE bits  (see  Table 34-4).  Note  that  only  those  interrupt sources that have their associated interrupt enable bit set will be reflected in the ICODE bits.\nIn Mode 2, when a receive message interrupt occurs, the EICODE bits will always consist of ' 10000 '.  User firmware may use FIFO Pointer bits to actually access the next available buffer.",
    "34.14.2 TRANSMIT INTERRUPT\nWhen the transmit interrupt is enabled, an interrupt will be generated  when  the  associated  transmit buffer becomes empty and is ready to be loaded with a new message. In Mode 0, there are separate interrupt enable/ disable and flag bits for each of the three dedicated trans -mit  buffers.  The  TXBnIF  bit  will  be  set  to  indicate  the source of  the  interrupt. The  interrupt  is  cleared  by  the MCU, resetting the TXBnIF bit to a ' 0 '. In Mode 1 and 2, all transmit buffers share one interrupt enable/disable bit and one flag bit. In Mode 1 and 2, TXBnIE in PIE5 and TXBnIF in PIR5 indicate when a transmit buffer has com -pleted transmission of its message. TXBnIF, TXBnIE and TXBnIP in PIR5, PIE5 and IPR5, respectively, are not used in Mode 1 and 2. Individual transmit buffer interrupts can be enabled or disabled by setting or clearing TXBnIE and B0IE register bits. When a shared interrupt occurs, user  firmware  must  poll  the  TXREQ  bit  of  all  transmit buffers to detect the source of interrupt.",
    "34.14.3 RECEIVE INTERRUPT\nWhen the receive interrupt is enabled, an interrupt will be generated when a message has been successfully received and loaded into the associated receive buffer. This interrupt is  activated  immediately after receiving the End-of-Frame (EOF) field.\nIn Mode 0, the RXBnIF bit is set to indicate the source of the interrupt. The interrupt is cleared by the MCU, resetting the RXBnIF bit to a ' 0 '.\nIn  Mode  1  and  2,  all  receive  buffers  share  RXBnIE, RXBnIF and RXBnIP in PIE5, PIR5 and IPR5, respec -tively. Individual receive buffer interrupts can be con -trolled by the TXBnIE and BIE0 registers. In Mode 1, when a shared receive interrupt occurs, user firmware must poll the RXFUL bit of each receive buffer to detect the source of interrupt. In Mode 2, a receive interrupt indicates that the new message is loaded into FIFO. FIFO can be read by using FIFO Pointer bits, FP.",
    "TABLE 34-4: VALUES FOR ICODE<2:0>\n000, Interrupt = None. 000, Boolean Expression = ERR\u2022WAK\u2022TX0\u2022TX1\u2022TX2\u2022RX0\u2022RX1. 001, Interrupt = Error. 001, Boolean Expression = ERR. 010, Interrupt = TXB2. 010, Boolean Expression = ERR\u2022TX0\u2022TX1\u2022TX2. 011, Interrupt = TXB1. 011, Boolean Expression = ERR\u2022TX0\u2022TX1. 100, Interrupt = TXB0. 100, Boolean Expression = ERR\u2022TX0. 101, Interrupt = RXB1. 101, Boolean Expression = ERR\u2022TX0\u2022TX1\u2022TX2\u2022RX0\u2022RX1. 110, Interrupt = RXB0. 110, Boolean Expression = ERR\u2022TX0\u2022TX1\u2022TX2\u2022RX0. 111, Interrupt = Wake on Interrupt. 111, Boolean Expression = ERR\u2022TX0\u2022TX1\u2022TX2\u2022RX0\u2022RX1\u2022WAK",
    "Legend:\nERR = ERRIF * ERRIE\nRX0 = RXB0IF * RXB0IE\nTX0 = TXB0IF * TXB0IE\nRX1 = RXB1IF * RXB1IE\nTX1 = TXB1IF * TXB1IE\nWAK = WAKIF * WAKIE\nTX2 = TXB2IF * TXB2IE",
    "34.14.4 MESSAGE ERROR INTERRUPT\nWhen an error occurs during transmission or reception of a message, the message error flag, IRXIF, will be set and if the IRXIE bit is set, an interrupt will be generated. This  is  intended  to  be  used  to  facilitate  baud  rate determination  when  used  in  conjunction  with  Listen Only mode.",
    "34.14.5 BUS ACTIVITY WAKE-UP INTERRUPT\nWhen the ECAN module is in Sleep mode and the bus activity wake-up interrupt is enabled, an interrupt will be generated and the WAKIF bit will be set when activity is detected  on  the  CAN  bus.  This  interrupt  causes  the MCU to exit Sleep mode. The interrupt is reset by the MCU, clearing the WAKIF bit.",
    "34.14.6 ERROR INTERRUPT\nWhen the CAN module error interrupt (ERRIE in PIE5) is enabled, an interrupt is generated if an overflow con -dition occurs, or if the error state of the transmitter or receiver has changed. The error flags in COMSTAT will indicate one of the following conditions.",
    "34.14.6.1 Receiver Overflow\nAn  overflow  condition  occurs  when  the  MAB  has assembled  a  valid  received  message  (the  message meets  the  criteria  of  the  acceptance  filters)  and  the receive buffer associated with the filter is not available for loading of a new message.  The associated RXBnOVFL bit in the COMSTAT register will be set to indicate the overflow condition. This bit must be cleared by the MCU. In mode 0, RXB0 and RXB1 have sepa -rate  overflow  bits.  In  modes  1  and  2,  there  is  one shared  bit  that  indicates  a  receive  buffer  has  over -flowed, but each buffer must be checked individually.",
    "34.14.6.2 Receiver Warning\nThe  receive  error  counter  has  reached  the  MCU warning limit of 96. This is indicated by the RXWARN bit of the COMSTAT register",
    "34.14.6.3 Transmitter Warning\nThe  transmit  error  counter  has  reached  the  MCU warning limit of 96. This is indicated by the TXWARN bit of the COMSTAT register.",
    "34.14.6.4 Receiver Bus Passive\nThis will occur when the device has gone to the errorpassive  state  because  the  receive  error  counter  is greater or equal to 128. This is indicated by the RXBP bit of the COMSTAT register.",
    "34.14.6.5 Transmitter Bus Passive\nThis will occur when the device has gone to the errorpassive  state  because  the  transmit  error  counter  is greater or equal to 128. This is indicated by the TXBP bit of the COMSTAT register.",
    "34.14.6.6 Bus-Off\nThe transmit error counter has exceeded 255 and the device has gone to bus-off state. This is indicated by the TXBO bit of the COMSTAT register.",
    "34.15 CAN Module Registers\nNote:\nNot all CAN registers are available in the Access Bank.\nThere are many control and data registers associated with the CAN module. For convenience, their descriptions  have  been  grouped  into  the  following sections:\n\u00b7 Control and Status Registers\n\u00b7 Dedicated Transmit Buffer Registers\n\u00b7 Dedicated Receive Buffer Registers\n\u00b7 Programmable TX/RX and Auto RTR Buffers\n\u00b7 Baud Rate Control Registers\n\u00b7 I/O Control Register\n\u00b7 Interrupt Status and Control Registers\nDetailed descriptions of each register and their usage are described in the following sections.",
    "34.15.1 CAN CONTROL AND STATUS REGISTERS\nThe  registers  described  in  this  section  control  the overall  operation  of  the  CAN  module  and  show  its operational status.",
    "REGISTER 34-1: CANCON: CAN CONTROL REGISTER\nMode 1, R/W-1.REQOP2 = R/W-1. Mode 1, R/W-0.REQOP1 = R/W-0. Mode 1, R/W-0.REQOP0 = R/W-0. Mode 1, R/S-0.ABAT = R/S-0. Mode 1, R/W-0.WIN2 = U0. Mode 1, R/W-0.WIN1 = U-0. Mode 1, R/W-0.WIN0 = U-0. Mode 1, U-0.- = U-0. Mode 1, R/W-1.REQOP2 = REQOP2. Mode 1, R/W-0.REQOP1 = REQOP1. Mode 1, R/W-0.REQOP0 = REQOP0. Mode 1, R/S-0.ABAT = ABAT. Mode 1, R/W-0.WIN2 = -. Mode 1, R/W-0.WIN1 = -. Mode 1,",
    "REGISTER 34-1: CANCON: CAN CONTROL REGISTER\nR/W-0.WIN0 = -. Mode 1, U-0.- = -. Mode 2, R/W-1.REQOP2 = R/W-1. Mode 2, R/W-0.REQOP1 = R/W-0. Mode 2, R/W-0.REQOP0 = R/W-0. Mode 2, R/S-0.ABAT = R/S-0. Mode 2, R/W-0.WIN2 = R-0. Mode 2, R/W-0.WIN1 = R-0. Mode 2, R/W-0.WIN0 = R-0. Mode 2, U-0.- = R-0. Mode 2, R/W-1.REQOP2 = REQOP2. Mode 2, R/W-0.REQOP1 = REQOP1. Mode 2, R/W-0.REQOP0 = REQOP0. Mode 2, R/S-0.ABAT = ABAT. Mode 2, R/W-0.WIN2 =",
    "REGISTER 34-1: CANCON: CAN CONTROL REGISTER\nFP3. Mode 2, R/W-0.WIN1 = FP2. Mode 2, R/W-0.WIN0 = FP1. Mode 2, U-0.- = FP0. , R/W-1.REQOP2 = bit 7 bit 0. , R/W-0.REQOP1 = bit 7 bit 0. , R/W-0.REQOP0 = bit 7 bit 0. , R/S-0.ABAT = bit 7 bit 0. , R/W-0.WIN2 = bit 7 bit 0. , R/W-0.WIN1 = bit 7 bit 0. , R/W-0.WIN0 = bit 7 bit 0. , U-0.- = bit 7 bit 0",
    "REGISTER 34-1: CANCON: CAN CONTROL REGISTER\nLegend:, 1 = S = Settable bit. Legend:, 2 = . Legend:, 3 = . R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-5 REQOP<2:0>: Request CAN Operation Mode bits\n1xx = Requests Configuration mode\n011 = Requests Listen Only mode\n010 = Requests Loopback mode\n001 = Disabled/Sleep mode\n000 = Requests Normal mode",
    "bit 4\nABAT: Abort All Pending Transmissions bit\n1 = Abort all pending transmissions (in all transmit buffers) (1)\n0 = Transmissions proceeding as normal",
    "bit 3-1 Mode 0:\nWIN<2:0>: Window Address bits\nThese bits select which of the CAN buffers to switch into the Access Bank area. This allows access to the buffer registers from any data memory bank. After a frame has caused an interrupt, the ICODE<3:0> bits can be copied to the WIN<2:0> bits to select the correct buffer. See Example 34-2 for a code example.\n111 = Receive Buffer 0\n101 = Receive Buffer 1\n110 = Receive Buffer 0\n100 = Transmit Buffer 0\n010 = Transmit Buffer 2\n011 = Transmit Buffer 1\n001 = Receive Buffer 0\n000 = Receive Buffer 0",
    "bit 0 Mode 0:\nUnimplemented: Read as ' 0 '",
    "bit 4-0 Mode 1:\nUnimplemented: Read as ' 0 '\nMode 2:\nFP<3:0>: FIFO Read Pointer bits\nThese bits point to the message buffer to be read.\n0000 = Receive Message Buffer 0\n0001 = Receive Message Buffer 1\n0010 = Receive Message Buffer 2\n0011 = Receive Message Buffer 3\n0100 = Receive Message Buffer 4\n0101 = Receive Message Buffer 5\n0110 = Receive Message Buffer 6\n0111\n= Receive Message Buffer 7\n1000:1111 Reserved\nNote 1: This bit will clear when all transmissions are aborted.",
    "REGISTER 34-2: CANSTAT: CAN STATUS REGISTER\nMode 1,2, R-1.OPMODE2 (1) = R-1. Mode 1,2, R-0.OPMODE1 (1) = R-0. Mode 1,2, R-0.OPMODE0 (1) = R-0. Mode 1,2, R-0.- = R-0. Mode 1,2, R-0.ICODE2 = R-0. Mode 1,2, R-0.ICODE1 = R-0. Mode 1,2, R-0.ICODE0 = R-0. Mode 1,2, U-0.- = R-0. Mode 1,2, R-1.OPMODE2 (1) = OPMODE2 (1). Mode 1,2, R-0.OPMODE1 (1) = OPMODE1 (1). Mode 1,2, R-0.OPMODE0 (1) = OPMODE0 (1). Mode 1,2, R-0.- = EICODE4. Mode 1,2,",
    "REGISTER 34-2: CANSTAT: CAN STATUS REGISTER\nR-0.ICODE2 = EICODE3. Mode 1,2, R-0.ICODE1 = EICODE2. Mode 1,2, R-0.ICODE0 = EICODE1. Mode 1,2, U-0.- = EICODE0. , R-1.OPMODE2 (1) = bit 7. , R-0.OPMODE1 (1) = . , R-0.OPMODE0 (1) = . , R-0.- = . , R-0.ICODE2 = . , R-0.ICODE1 = . , R-0.ICODE0 = . , U-0.- = bit 0",
    "REGISTER 34-2: CANSTAT: CAN STATUS REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-5\nOPMODE<2:0>: Operation Mode Status bits (1)\n111 = Reserved\n110 = Reserved\n101 = Reserved\n100 = Configuration mode\n011 = Listen Only mode\n010 = Loopback mode\n001 = Disable/Sleep mode\n000 = Normal mode\nMode 0:\nUnimplemented: Read as ' 0 '\nMode 0:\nICODE<2:0>:\nInterrupt Code bits",
    "REGISTER 34-2: CANSTAT: CAN STATUS REGISTER\nWhen an interrupt occurs, a prioritized coded interrupt value will be present in these bits. This code indicates the source of the interrupt. By copying ICODE<3:1> to WIN<3:0> (Mode 0) or EICODE<4:0> to EWIN<4:0> (Mode 1 and 2), it is possible to select the correct buffer to map into the Access Bank area. See Example 34-2 for a code example. To simplify the description, the following table lists all five bits.",
    "REGISTER 34-2: CANSTAT: CAN STATUS REGISTER\nNo interrupt, Mode 0 = 00000. No interrupt, Mode 1 = 00000. No interrupt, Mode 2 = 00000. CAN bus error interrupt, Mode 0 = 00010. CAN bus error interrupt, Mode 1 = 00010. CAN bus error interrupt, Mode 2 = 00010. TXB2 interrupt, Mode 0 = 00100. TXB2 interrupt, Mode 1 = 00100. TXB2 interrupt, Mode 2 = 00100. TXB1 interrupt, Mode 0 = 00110. TXB1 interrupt, Mode 1 = 00110. TXB1 interrupt, Mode 2 = 00110. TXB0 interrupt, Mode 0 = 01000. TXB0 interrupt, Mode 1 = 01000. TXB0 interrupt, Mode 2 = 01000. RXB1 interrupt, Mode 0 = 01010. RXB1 interrupt, Mode 1 = 10001. RXB1 interrupt, Mode 2 = -----. RXB0 interrupt, Mode 0 = 01100. RXB0 interrupt, Mode 1 = 10000. RXB0 interrupt, Mode 2 = 10000. Wake-up interrupt, Mode 0",
    "REGISTER 34-2: CANSTAT: CAN STATUS REGISTER\n= 01110. Wake-up interrupt, Mode 1 = 01110. Wake-up interrupt, Mode 2 = 01110. RXB0 interrupt, Mode 0 = -----. RXB0 interrupt, Mode 1 = 10000. RXB0 interrupt, Mode 2 = 10000. RXB1 interrupt, Mode 0 = -----. RXB1 interrupt, Mode 1 = 10001. RXB1 interrupt, Mode 2 = 10000. RX/TX B0 interrupt, Mode 0 = -----. RX/TX B0 interrupt, Mode 1 = 10010. RX/TX B0 interrupt, Mode 2 = 10010 (2). RX/TX B1 interrupt, Mode 0 = -----. RX/TX B1 interrupt, Mode 1 = 10011. RX/TX B1 interrupt, Mode 2 = 10011 (2). RX/TX B2 interrupt, Mode 0 = -----. RX/TX B2 interrupt, Mode 1 = 10100. RX/TX B2 interrupt, Mode 2 = 10100",
    "REGISTER 34-2: CANSTAT: CAN STATUS REGISTER\n(2). RX/TX B3 interrupt, Mode 0 = -----. RX/TX B3 interrupt, Mode 1 = 10101. RX/TX B3 interrupt, Mode 2 = 10101 (2). RX/TX B4 interrupt, Mode 0 = -----. RX/TX B4 interrupt, Mode 1 = 10110. RX/TX B4 interrupt, Mode 2 = 10110 (2). RX/TX B5 interrupt, Mode 0 = -----. RX/TX B5 interrupt, Mode 1 = 10111. RX/TX B5 interrupt, Mode 2 = 10111 (2)\nbit 0\nMode 0:\nUnimplemented: Read as ' 0 '\nbit 4-0\nMode 1, 2:\nEICODE<4:0>: Interrupt Code bits\nSee ICODE<3:1> above.",
    "REGISTER 34-2: CANSTAT: CAN STATUS REGISTER\nNote 1: To achieve maximum power saving and/or able to wake-up on CAN bus activity, switch the CAN module in Disable/Sleep mode before putting the device to Sleep.\n2: If the buffer is configured as a receiver, the EICODE bits will contain ' 10000 ' upon interrupt.",
    "bit 4\nbit 3-1,4-0",
    "EXAMPLE 34-2: CHANGING TO CONFIGURATION MODE\n```\n; Request Configuration mode. MOVLW B'10000000' ; Set to Configuration Mode. MOVWF CANCON ; A request to switch to Configuration mode may not be immediately honored. ; Module will wait for CAN bus to be idle before switching to Configuration Mode. ; Request for other modes such as Loopback, Disable etc. may be honored immediately. ; It is always good practice to wait and verify before continuing. ConfigWait: MOVF CANSTAT, W ; Read current mode state. ANDLW B'10000000' ; Interested in OPMODE bits only. TSTFSZ WREG ; Is it Configuration mode yet? BRA ConfigWait ; No. Continue to wait... ; Module is in Configuration mode now. ; Modify configuration registers as required. ; Switch back to Normal mode to be able to communicate.\n```",
    "EXAMPLE 34-3: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\n```",
    "EXAMPLE 34-3: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\n; Save application required context. ; Poll interrupt flags and determine source of interrupt ; This was found to be CAN interrupt ; TempCANCON and TempCANSTAT are variables defined in Access Bank low MOVFF CANCON, TempCANCON ; Save CANCON.WIN bits ; This is required to prevent CANCON ; from corrupting CAN buffer access ; in-progress while this interrupt ; occurred MOVFF CANSTAT, TempCANSTAT ; Save CANSTAT register ; This is required to make sure that ; we use same CANSTAT value rather ; than one changed by another CAN ; interrupt. MOVF TempCANSTAT, W ; Retrieve ICODE bits ANDLW B'00001110' ADDWF PCL, F ; Perform computed GOTO ; to corresponding interrupt cause BRA NoInterrupt ; 000 = No interrupt BRA ErrorInterrupt ; 001 = Error interrupt BRA TXB2Interrupt ; 010 = TXB2 interrupt BRA TXB1Interrupt ; 011 = TXB1 interrupt BRA TXB0Interrupt ; 100 = TXB0 interrupt BRA",
    "EXAMPLE 34-3: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\nRXB1Interrupt ; 101 = RXB1 interrupt BRA RXB0Interrupt ; 110 = RXB0 interrupt ; 111 = Wake-up on interrupt WakeupInterrupt BCF PIR3, WAKIF ; Clear the interrupt flag ; ; User code to handle wake-up procedure ; ; ; Continue checking for other interrupt source or return from here \u2026 NoInterrupt \u2026 ; PC should never vector here. User may ; place a trap such as infinite loop or pin/port ; indication to catch this error.\n```",
    "EXAMPLE 34-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nErrorInterrupt\nBCF PIR3, ERRIF\n; Clear the interrupt flag\n\u2026\n; Handle error.\nRETFIE\nTXB2Interrupt\nBCF\nPIR3, TXB2IF\n; Clear the interrupt flag\nGOTO\nAccessBuffer\nTXB1Interrupt\nBCF\nPIR3, TXB1IF\n; Clear the interrupt flag\nGOTO\nAccessBuffer\nTXB0Interrupt\nBCF\nPIR3, TXB0IF\n; Clear the interrupt flag\nGOTO\nAccessBuffer\nRXB1Interrupt\nBCF\nPIR3, RXB1IF\n; Clear the interrupt flag\nGOTO\nAccessbuffer\nRXB0Interrupt\nBCF\nPIR3, RXB0IF\n; Clear the interrupt flag\nGOTO\nAccessBuffer\nAccessBuffer\n; This is either TX or RX interrupt\n; Copy CANSTAT.ICODE bits to CANCON.WIN bits\nMOVF\nTempCANCON, W\n; Clear CANCON.WIN bits before copying ; new ones.\nANDLW\nB'11110001'",
    "EXAMPLE 34-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\n; Use previously saved CANCON value to ; make sure same value.\nMOVWF\nTempCANCON\n; Copy masked value back to TempCANCON ; Retrieve ICODE bits\nMOVF\nTempCANSTAT, W\nANDLW\nB'00001110'\n; Use previously saved CANSTAT value\n; to make sure same value.\nIORWF\nTempCANCON\n; Copy ICODE bits to WIN bits.\nMOVFF\nTempCANCON, CANCON\n; Copy the result to actual CANCON\n; Access current buffer\u2026\n; User code\n; Restore CANCON.WIN bits\nMOVF\nCANCON, W\n; Preserve current non WIN bits\nANDLW\nB'11110001'\nIORWF TempCANCON\n; Restore original WIN bits\n; Do not need to restore CANSTAT - it is read-only register.\n; Return from interrupt or check for another module interrupt source",
    "REGISTER 34-3: ECANCON: ENHANCED CAN CONTROL REGISTER\nMDSEL1 (1), R/W-0 = MDSEL0 (1). MDSEL1 (1), R/W-0 = FIFOWM (2). MDSEL1 (1), R/W-1 = EWIN4. MDSEL1 (1), R/W-0 = EWIN3. MDSEL1 (1), R/W-0 = EWIN2. MDSEL1 (1), R/W-0 = EWIN1. MDSEL1 (1), R/W-0 = EWIN0. bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-1 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = bit 0",
    "REGISTER 34-3: ECANCON: ENHANCED CAN CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-6 MDSEL<1:0>: Mode Select bits (1)\n00 = Legacy mode (Mode 0, default)\n01 = Enhanced Legacy mode (Mode 1)\n10 = Enhanced FIFO mode (Mode 2)\n11 = Reserved",
    "bit 5\nFIFOWM: FIFO High Water Mark bit (2)\n1 = Will cause FIFO interrupt when one receive buffer remains\n0 = Will cause FIFO interrupt when four receive buffers remain (3)",
    "bit 4-0 EWIN<4:0>: Enhanced Window Address bits\nThese bits map the group of 16 banked CAN SFRs into Access Bank addresses, 0F60-0F6Dh. The exact group of registers to map is determined by the binary value of these bits. Mode 0:\nUnimplemented: Read as ' 0 '",
    "Mode 1, 2:\n00000 = Acceptance Filters 0, 1, 2 and BRGCON2, 3\n00001 = Acceptance Filters 3, 4, 5 and BRGCON1, CIOCON\n00010 = Acceptance Filter Masks, Error and Interrupt Control\n00011 = Transmit Buffer 0\n00100 = Transmit Buffer 1\n00101 = Transmit Buffer 2\n00110 = Acceptance Filters 6, 7, 8\n00111 = Acceptance Filters 9, 10, 11\n01000 = Acceptance Filters 12, 13, 14\n01001 = Acceptance Filter 15\n01010 01110 - = Reserved\n01111 = RXINT0, RXINT1\n10000 = Receive Buffer 0\n10001 = Receive Buffer 1\n10010 = TX/RX Buffer 0\n10011 = TX/RX Buffer 1\n10100 = TX/RX Buffer 2\n10101 = TX/RX Buffer 3\n10110 = TX/RX Buffer 4\n10111 = TX/RX Buffer 5\n11000 11111 -= Reserved\nNote 1: These bits can only be changed in Configuration mode. See Register 34-1 to change to Configuration mode.",
    "Mode 1, 2:\n2: This bit is used in Mode 2 only.\n3: If FIFO is configured to contain four or less buffers, then the FIFO interrupt will trigger.",
    "REGISTER 34-4: COMSTAT: COMMUNICATION STATUS REGISTER\nMode 1, R/C-0.RXB0OVFL = R/C-0. Mode 1, R/C-0.RXB1OVFL = R/C-0. Mode 1, R-0.TXBO = R-0. Mode 1, R-0.TXBP = R-0. Mode 1, R-0.RXBP = R-0. Mode 1, R-0.TXWARN = R-0. Mode 1, R-0.RXWARN = R-0. Mode 1, R-0.EWARN = R-0. Mode 1, R/C-0.RXB0OVFL = -. Mode 1, R/C-0.RXB1OVFL = RXBnOVFL. Mode 1, R-0.TXBO = TXB0. Mode 1, R-0.TXBP = TXBP. Mode 1, R-0.RXBP = RXBP. Mode 1, R-0.TXWARN = TXWARN. Mode 1,",
    "REGISTER 34-4: COMSTAT: COMMUNICATION STATUS REGISTER\nR-0.RXWARN = RXWARN. Mode 1, R-0.EWARN = EWARN. Mode 2, R/C-0.RXB0OVFL = R/C-0. Mode 2, R/C-0.RXB1OVFL = R/C-0. Mode 2, R-0.TXBO = R-0. Mode 2, R-0.TXBP = R-0. Mode 2, R-0.RXBP = R-0. Mode 2, R-0.TXWARN = R-0. Mode 2, R-0.RXWARN = R-0. Mode 2, R-0.EWARN = R-0. Mode 2, R/C-0.RXB0OVFL = FIFOEMPTY. Mode 2, R/C-0.RXB1OVFL = RXBnOVFL. Mode 2, R-0.TXBO = TXBO. Mode 2, R-0.TXBP = TXBP. Mode 2,",
    "REGISTER 34-4: COMSTAT: COMMUNICATION STATUS REGISTER\nR-0.RXBP = RXBP. Mode 2, R-0.TXWARN = TXWARN. Mode 2, R-0.RXWARN = RXWARN. Mode 2, R-0.EWARN = EWARN. , R/C-0.RXB0OVFL = bit 7 bit 0. , R/C-0.RXB1OVFL = bit 7 bit 0. , R-0.TXBO = bit 7 bit 0. , R-0.TXBP = bit 7 bit 0. , R-0.RXBP = bit 7 bit 0. , R-0.TXWARN = bit 7 bit 0. , R-0.RXWARN = bit 7 bit 0. , R-0.EWARN = bit 7 bit 0",
    "REGISTER 34-4: COMSTAT: COMMUNICATION STATUS REGISTER\nLegend:, 1 = C = Clearable bit. Legend:, 2 = . Legend:, 3 = . R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Mode 0:\nRXB0OVFL: Receive Buffer 0 Overflow bit\n1 = Receive Buffer 0 has overflowed\n0 = Receive Buffer 0 has not overflowed\nMode 1:\nUnimplemented: Read as ' 0 '\nMode 2:\nFIFOEMPTY: FIFO Not Empty bit\n1 = Receive FIFO is not empty\n0 = Receive FIFO is empty",
    "bit 6 Mode 0:\nRXB1OVFL: Receive Buffer 1 Overflow bit\n1 = Receive Buffer 1 has overflowed\n0 = Receive Buffer 1 has not overflowed",
    "Mode 1, 2:\nRXBnOVFL: Receive Buffer n Overflow bit\n1 = Receive Buffer n has overflowed\n0 = Receive Buffer n has not overflowed",
    "bit 5 TXBO: Transmitter Bus-Off bit\n1 = Transmit error counter > 255\n0 = Transmit error counter \uf0a3\uf020 255",
    "bit 4 TXBP: Transmitter Bus Passive bit\n1 = Transmit error counter > 127\n0 = Transmit error counter \uf0a3\uf020 127",
    "bit 3 RXBP: Receiver Bus Passive bit\n1 = Receive error counter > 127\n0 = Receive error counter \uf0a3\uf020 127",
    "bit 2 TXWARN: Transmitter Warning bit\n1 = Transmit error counter > 95\n0 = Transmit error counter \uf0a3\uf020 95",
    "bit 1 RXWARN: Receiver Warning bit\n1 = 127 \uf0b3 Receive error counter > 95\n0 = Receive error counter \uf0a3 95",
    "bit 0 EWARN: Error Warning bit\nThis bit is a flag of the RXWARN and TXWARN bits.\n1 = The RXWARN or the TXWARN bits are set\n0 = Neither the RXWARN or the TXWARN bits are set",
    "34.15.2 DEDICATED CAN TRANSMIT BUFFER REGISTERS\nThis  section  describes  the  dedicated  CAN  Transmit\nBuffer registers and their associated control registers.",
    "REGISTER 34-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nTXBIF, R-0 = TXABT (1). TXBIF, R-0 = TXLARB (1). TXBIF, R-0 = TXERR (1). TXBIF, R/W-0 = TXREQ (2). TXBIF, U-0 = -. TXBIF, R/W-0 = TXPRI1 (3). TXBIF, R/W-0 = TXPRI0 (3). bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 34-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nLegend:, 1 = C = Clearable bit. Legend:, 2 = C = Clearable bit. Legend:, 3 = C = Clearable bit. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 TXBIF: Transmit Buffer Interrupt Flag bit\n1 = Transmit buffer has completed transmission of a message and may be reloaded\n0 = Transmit buffer has not completed transmission of a message\nbit 6\nTXABT: Transmission Aborted Status bit (1)\n1 = Message was aborted\n0 = Message was not aborted\nbit 5\nTXLARB: Transmission Lost Arbitration Status bit (1)\n1 = Message lost arbitration while being sent\n0 = Message did not lose arbitration while being sent\nbit 4\nTXERR: Transmission Error Detected Status bit (1)\n1 = A bus error occurred while the message was being sent\n0 = A bus error did not occur while the message was being sent\nbit 3\nTXREQ: Transmit Request Status bit (2)\n1 = Requests sending a message; clears the TXABT, TXLARB and TXERR bits\n0 = Automatically cleared when the message is successfully sent",
    "bit 2 Unimplemented: Read as ' 0 '\nbit 1-0 TXPRI<1:0>: Transmit Priority bits (3)\n11 = Priority Level 3 (highest priority)\n10 = Priority Level 2\n01 = Priority Level 1\n00 = Priority Level 0 (lowest priority)\nNote\n1: This bit is automatically cleared when TXREQ is set.\n2: While TXREQ is set, Transmit Buffer registers remain read-only. Clearing this bit in software while the bit is set will request a message abort.\n3: These bits define the order in which transmit buffers will be transferred. They do not alter the CAN message identifier.",
    "REGISTER 34-6: TXBnSIDH: TRANSMIT BUFFER 'n' STANDARD IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 2]\nSID10, R/W-x = SID9. SID10, R/W-x = SID8. SID10, R/W-x = SID7. SID10, R/W-x = SID6. SID10, R/W-x = SID5. SID10, R/W-x = SID4. SID10, R/W-x = SID3. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-6: TXBnSIDH: TRANSMIT BUFFER 'n' STANDARD IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 2]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 SID<10:3>: Standard Identifier bits (if EXIDE (TXBnSIDL<3>) = 0 ) Extended Identifier bits, EID<28:21> (if EXIDE = 1 ).",
    "REGISTER 34-7: TXBnSIDL: TRANSMIT BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 2]\nSID2, R/W-x = SID1. SID2, R/W-x = SID0. SID2, U-0 = -. SID2, R/W-x = EXIDE. SID2, U-0 = -. SID2, R/W-x = EID17. SID2, R/W-x = EID16. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-x = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-7: TXBnSIDL: TRANSMIT BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 2]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-5\nSID<2:0>: Standard Identifier bits (if EXIDE (TXBnSIDL<3>) = 0 )\nExtended Identifier bits, EID<20:18> (if EXIDE = 1 ).\nbit 4\nUnimplemented: Read as ' 0 '\nbit 3\nEXIDE: Extended Identifier Enable bit",
    "REGISTER 34-7: TXBnSIDL: TRANSMIT BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 2]\n1 = Message will transmit extended ID, SID<10:0> become EID<28:18>\n0 = Message will transmit standard ID, EID<17:0> are ignored\nbit 2\nUnimplemented: Read as ' 0 '\nbit 1-0\nEID<17:16>: Extended Identifier bits",
    "REGISTER 34-8: TXBnEIDH: TRANSMIT BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 2]\nEID15, R/W-x = EID14. EID15, R/W-x = EID13. EID15, R/W-x = EID12. EID15, R/W-x = EID11. EID15, R/W-x = EID10. EID15, R/W-x = EID9. EID15, R/W-x = EID8. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-8: TXBnEIDH: TRANSMIT BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 2]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 EID<15:8>: Extended Identifier bits (not used when transmitting standard identifier message)",
    "REGISTER 34-9: TXBnEIDL: TRANSMIT BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 2]\nEID7, R/W-x = EID6. EID7, R/W-x = EID5. EID7, R/W-x = EID4. EID7, R/W-x = EID3. EID7, R/W-x = EID2. EID7, R/W-x = EID1. EID7, R/W-x = EID0. bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = bit 0",
    "REGISTER 34-9: TXBnEIDL: TRANSMIT BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 2]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 EID<7:0>: Extended Identifier bits (not used when transmitting standard identifier message)",
    "REGISTER 34-10: TXBnDm: TRANSMIT BUFFER 'n' DATA FIELD BYTE 'm' REGISTERS [0 \uf0a3 n \uf0a3 2, 0 \uf0a3 m \uf0a3 7]\nTXBnDm7, R/W-x = TXBnDm6. TXBnDm7, R/W-x = TXBnDm5. TXBnDm7, R/W-x = TXBnDm4. TXBnDm7, R/W-x = TXBnDm3. TXBnDm7, R/W-x = TXBnDm2. TXBnDm7, R/W-x = TXBnDm1. TXBnDm7, R/W-x = TXBnDm0. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-10: TXBnDm: TRANSMIT BUFFER 'n' DATA FIELD BYTE 'm' REGISTERS [0 \uf0a3 n \uf0a3 2, 0 \uf0a3 m \uf0a3 7]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 TXBnDm<7:0>: Transmit Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 3 and 0 \uf0a3\uf020 m < 8) Each transmit buffer has an array of registers. For example, Transmit Buffer 0 has 7 registers: TXB0D0 to TXB0D7.",
    "REGISTER 34-11: TXBnDLC: TRANSMIT BUFFER 'n' DATA LENGTH CODE REGISTERS [0   n   2] \uf0a3 \uf0a3\n-, R/W-x = TXRTR. -, U-0 = -. -, U-0 = -. -, R/W-x = DLC3. -, R/W-x = DLC2. -, R/W-x = DLC1. -, R/W-x = DLC0. bit 7, R/W-x = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-11: TXBnDLC: TRANSMIT BUFFER 'n' DATA LENGTH CODE REGISTERS [0   n   2] \uf0a3 \uf0a3\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6\nTXRTR: Transmit Remote Frame Transmission Request bit\n1 = Transmitted message will have the TXRTR bit set\n0 = Transmitted message will have the TXRTR bit cleared\nbit 5-4\nUnimplemented: Read as ' 0 '\nbit 3-0\nDLC<3:0>: Data Length Code bits\n1111\n= Reserved\n1110 = Reserved\n1101 = Reserved\n1100 = Reserved\n1011 = Reserved\n1010 = Reserved\n1001 = Reserved\n1000 = Data length = 8 bytes\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 bytes\n0000 = Data length = 0 bytes",
    "REGISTER 34-12: TXERRCNT: TRANSMIT ERROR COUNT REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. TEC7, 1 = TEC6. TEC7, 2 = TEC5. TEC7, 3 = TEC4. TEC7, 4 = TEC3. TEC7, 5 = TEC2. TEC7, 6 = TEC1. TEC7, 7 = TEC0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 34-12: TXERRCNT: TRANSMIT ERROR COUNT REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 TEC<7:0>: Transmit Error Counter bits\nThis register contains a value which is derived from the rate at which errors occur. When the error count  overflows,  the  bus-off  state  occurs.  When  the  bus  has  128  occurrences  of  11 consecutive recessive bits, the counter value is cleared.",
    "EXAMPLE 34-3: TRANSMITTING A CAN MESSAGE USING BANKED METHOD\n; Need to transmit Standard Identifier message 123h using TXB0 buffer.\n; To successfully transmit, CAN module must be either in Normal or Loopback mode.\n; TXB0 buffer is not in access bank. And since we want banked method, we need to make sure\n; that correct bank is selected.\nBANKSEL TXB0CON\n; One BANKSEL in beginning will make sure that we are\n; in correct bank for rest of the buffer access.\n; Now load transmit data into TXB0 buffer.\nMOVLW MY_DATA_BYTE1\n; Load first data byte into buffer\nMOVWF TXB0D0\n; Compiler will automatically set 'BANKED' bit\n; Load rest of data bytes - up to 8 bytes into TXB0 buffer.\n...\n; Load message identifier\nMOVLW 60H\n; Load SID2:SID0, EXIDE = 0\nMOVWF TXB0SIDL\nMOVLW 24H\n; Load SID10:SID3\nMOVWF TXB0SIDH",
    "EXAMPLE 34-3: TRANSMITTING A CAN MESSAGE USING BANKED METHOD\n; No need to load TXB0EIDL:TXB0EIDH, as we are transmitting Standard Identifier Message only.\n; Now that all data bytes are loaded, mark it for transmission.\nMOVLW\nB'00001000'\n; Normal priority; Request transmission\nMOVWF\nTXB0CON\n; If required, wait for message to get transmitted\nBTFSC\nTXB0CON, TXREQ\n; Is it transmitted?\nBRA\n$-2\n; No. Continue to wait...\n; Message is transmitted.",
    "EXAMPLE 34-4: TRANSMITTING A CAN MESSAGE USING WIN BITS\n```",
    "EXAMPLE 34-4: TRANSMITTING A CAN MESSAGE USING WIN BITS\n; Need to transmit Standard Identifier message 123h using TXB0 buffer. ; To successfully transmit, CAN module must be either in Normal or Loopback mode. ; TXB0 buffer is not in access bank. Use WIN bits to map it to RXB0 area. MOVF CANCON, W ; WIN bits are in lower 4 bits only. Read CANCON ; register to preserve all other bits. If operation ; mode is already known, there is no need to preserve ; other bits. ANDLW B'11110000' ; Clear WIN bits. IORLW B'00001000' ; Select Transmit Buffer 0 MOVWF CANCON ; Apply the changes. ; Now TXB0 is mapped in place of RXB0. All future access to RXB0 registers will actually ; yield TXB0 register values. ; Load transmit data into TXB0 buffer. MOVLW MY_DATA_BYTE1 ; Load first data byte into buffer MOVWF RXB0D0 ; Access TXB0D0 via RXB0D0 address. ; Load rest of the data bytes - up to 8 bytes into",
    "EXAMPLE 34-4: TRANSMITTING A CAN MESSAGE USING WIN BITS\n'TXB0' buffer using RXB0 registers. ... ; Load message identifier MOVLW 60H ; Load SID2:SID0, EXIDE = 0 MOVWF RXB0SIDL MOVLW 24H ; Load SID10:SID3 MOVWF RXB0SIDH ; No need to load RXB0EIDL:RXB0EIDH, as we are transmitting Standard Identifier Message only. ; Now that all data bytes are loaded, mark it for transmission. MOVLW B'00001000' ; Normal priority; Request transmission MOVWF RXB0CON ; If required, wait for message to get transmitted BTFSC RXB0CON, TXREQ ; Is it transmitted? BRA $-2 ; No. Continue to wait... ; Message is transmitted. ; If required, reset the WIN bits to default state.\n```",
    "34.15.3 DEDICATED CAN RECEIVE BUFFER REGISTERS\nThis section shows the dedicated CAN Receive Buffer registers with their associated control registers.",
    "REGISTER 34-13: RXB0CON: RECEIVE BUFFER 0 CONTROL REGISTER\nMode 0, 1 = R/C-0. Mode 0, 2 = R/W-0. Mode 0, 3 = R/W-0. Mode 0, 4 = U-0. Mode 0, 5 = R-0. Mode 0, 6 = R/W-0. Mode 0, 7 = R-0. Mode 0, 8 = R-0. Mode 0, 1 = RXFUL (1). Mode 0, 2 = RXM1. Mode 0, 3 = RXM0. Mode 0, 4 = -. Mode 0, 5 = RXRTRRO. Mode 0, 6 = RXB0DBEN. Mode 0, 7 = JTOFF (2). Mode 0, 8 = FILHIT0",
    "REGISTER 34-13: RXB0CON: RECEIVE BUFFER 0 CONTROL REGISTER\nMode 1,2, R/C-0 = RXFUL (1). Mode 1,2, R/W-0 = RXM1. Mode 1,2, R-0 = RTRRO. Mode 1,2, R-0 = FILHITF4. Mode 1,2, R-0 = FILHIT3. Mode 1,2, R-0 = FILHIT2. Mode 1,2, R-0 = FILHIT1. Mode 1,2, R-0 = FILHIT0. , R/C-0 = bit 7. , R/W-0 = . , R-0 = . , R-0 = . , R-0 = . , R-0 = . , R-0 = . , R-0 = bit 0",
    "REGISTER 34-13: RXB0CON: RECEIVE BUFFER 0 CONTROL REGISTER\nLegend:, 1 = C = Clearable bit. Legend:, 2 = . Legend:, 3 = . R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nRXFUL: Receive Full Status bit (1)\n1 = Receive buffer contains a received message\n0 = Receive buffer is open to receive a new message\nMode 0:\nRXM<1:0>: Receive Buffer Mode bit 1 (combines with RXM0 to form RXM<1:0> bits, see bit 5)",
    "REGISTER 34-13: RXB0CON: RECEIVE BUFFER 0 CONTROL REGISTER\n11 = Receive all messages (including those with errors); filter criteria is ignored\n10 = Receive only valid messages with extended identifier; EXIDEN in RXFnSIDL must be ' 1 '\n01 = Receive only valid messages with standard identifier; EXIDEN in RXFnSIDL must be ' 0 '\n00 = Receive all valid messages as per the EXIDEN bit in the RXFnSIDL register\nMode 1, 2:",
    "RXM1 : Receive Buffer Mode bit 1\n1 = Receive all messages (including those with errors); acceptance filters are ignored\n0 = Receive all valid messages as per acceptance filters",
    "bit 5 Mode 0:\nRXM0: Receive Buffer Mode bit 0 (combines with RXM1 to form RXM<1:0>bits, see bit 6)\nMode 1, 2:\nRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received",
    "bit 4 Mode 0:\nUnimplemented: Read as ' 0 '\nMode 1, 2:\nFILHIT<4:0>:\nFilter Hit bit 4\nThis bit combines with other bits to form filter acceptance bits<4:0>.",
    "bit 3 Mode 0:\nRXRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received\nMode 1, 2:\nFILHIT<4:0>:\nFilter Hit bit 3\nThis bit combines with other bits to form filter acceptance bits<4:0>.\nNote 1: This bit is set by the CAN module upon receiving a message and must be cleared by software after the buffer is read. As long as RXFUL is set, no new message will be loaded and the buffer will be considered full. After clearing the RXFUL flag, the PIR5 bit, RXB0IF, can be cleared. If RXB0IF is cleared, but RXFUL is not cleared, then RXB0IF is set again.\n2: This bit allows the same filter jump table for both RXB0CON and RXB1CON.",
    "bit 2\nMode 0:\nRB0DBEN: Receive Buffer 0 Double-Buffer Enable bit\n1 = Receive Buffer 0 overflow will write to Receive Buffer 1\n0 = No Receive Buffer 0 overflow to Receive Buffer 1\nMode 1, 2:\nFILHIT<4:0>:\nFilter Hit bit 2\nThis bit combines with other bits to form filter acceptance bits<4:0>.",
    "bit 1 Mode 0:\nJTOFF: Jump Table Offset bit (read-only copy of RXB0DBEN) (2)\n1 = Allows jump table offset between 6 and 7\n0 = Allows jump table offset between 1 and 0\nMode 1, 2:",
    "FILHIT<4:0>: Filter Hit bit 1\nThis bit combines with other bits to form filter acceptance bits<4:0>.",
    "bit 0 Mode 0:\nFILHIT0: Filter Hit bit 0\nThis bit indicates which acceptance filter enabled the message reception into Receive Buffer 0.\n1 = Acceptance Filter 1 (RXF1)\n0 = Acceptance Filter 0 (RXF0)",
    "FILHIT<4:0>: Filter Hit bit 0\nThis bit, in combination with FILHIT<4:1>, indicates which acceptance filter enabled the message reception into this receive buffer.\n01111 = Acceptance Filter 15 (RXF15)\n01110 = Acceptance Filter 14 (RXF14)\n...\n00000 = Acceptance Filter 0 (RXF0)\nNote 1: This bit is set by the CAN module upon receiving a message and must be cleared by software after the buffer is read. As long as RXFUL is set, no new message will be loaded and the buffer will be considered full. After clearing the RXFUL flag, the PIR5 bit, RXB0IF, can be cleared. If RXB0IF is cleared, but RXFUL is not cleared, then RXB0IF is set again.\n- 2: This bit allows the same filter jump table for both RXB0CON and RXB1CON.",
    "REGISTER 34-14: RXB1CON: RECEIVE BUFFER 1 CONTROL REGISTER\nMode 0, 1 = R/C-0. Mode 0, 2 = R/W-0. Mode 0, 3 = R/W-0. Mode 0, 4 = U-0. Mode 0, 5 = R-0. Mode 0, 6 = R/W-0. Mode 0, 7 = R-0. Mode 0, 8 = R-0. Mode 0, 1 = RXFUL (1). Mode 0, 2 = RXM1. Mode 0, 3 = RXM0. Mode 0, 4 = -. Mode 0, 5 = RXRTRRO. Mode 0, 6 = FILHIT2. Mode 0, 7 = FILHIT1. Mode 0, 8 = FILHIT0",
    "REGISTER 34-14: RXB1CON: RECEIVE BUFFER 1 CONTROL REGISTER\nMode 1,2, R/C-0 = RXFUL (1). Mode 1,2, R/W-0 = RXM1. Mode 1,2, R-0 = RTRRO. Mode 1,2, R-0 = FILHIT4. Mode 1,2, R-0 = FILHIT3. Mode 1,2, R-0 = FILHIT2. Mode 1,2, R-0 = FILHIT1. Mode 1,2, R-0 = FILHIT0. , R/C-0 = bit 7. , R/W-0 = . , R-0 = . , R-0 = . , R-0 = . , R-0 = . , R-0 = . , R-0 = bit 0",
    "REGISTER 34-14: RXB1CON: RECEIVE BUFFER 1 CONTROL REGISTER\nLegend:, 1 = C = Clearable bit. Legend:, 2 = . Legend:, 3 = . R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 RXFUL: Receive Full Status bit (1)\n1 = Receive buffer contains a received message\n0 = Receive buffer is open to receive a new message",
    "bit 6-5, 6 Mode 0:\nRXM<1:0>: Receive Buffer Mode bit 1 (combines with RXM0 to form RXM<1:0> bits, see bit 5)\n11 = Receive all messages (including those with errors); filter criteria is ignored\n10 = Receive only valid messages with extended identifier; EXIDEN in RXFnSIDL must be ' 1 '\n01 = Receive only valid messages with standard identifier, EXIDEN in RXFnSIDL must be ' 0 '\n00 = Receive all valid messages as per EXIDEN bit in RXFnSIDL register\nMode 1, 2:\nRXM1: Receive Buffer Mode bit\n1 = Receive all messages (including those with errors); acceptance filters are ignored\n0 = Receive all valid messages as per acceptance filters",
    "bit 5 Mode 0:\nRXM<1:0>: Receive Buffer Mode bit 0 (combines with RXM1 to form RXM<1:0> bits, see bit 6)\nMode 1, 2:\nRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received",
    "bit 4 Mode 0:\nFILHIT2 4: Filter Hit bit 4\nMode 1, 2:\nFILHIT<4:0>:\nFilter Hit bit 4\nThis bit combines with other bits to form the filter acceptance bits<4:0>.",
    "bit 3 Mode 0:\nRXRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received\nMode 1, 2:",
    "FILHIT<4:0>: Filter Hit bit 3\nThis bit combines with other bits to form the filter acceptance bits<4:0>.\nNote 1: This bit is set by the CAN module upon receiving a message and must be cleared by software after the buffer is read. As long as RXFUL is set, no new message will be loaded and the buffer will be considered full.",
    "bit 2-0\nMode 0:\nFILHIT<2:0>: Filter Hit bits\nThese bits indicate which acceptance filter enabled the last message reception into Receive Buffer 1.\n111 = Reserved\n110 = Reserved\n101 = Acceptance Filter 5 (RXF5)\n100 = Acceptance Filter 4 (RXF4)\n011 = Acceptance Filter 3 (RXF3)\n010 = Acceptance Filter 2 (RXF2)\n001 = Acceptance Filter 1 (RXF1), only possible when RXB0DBEN bit is set\n000 = Acceptance Filter 0 (RXF0), only possible when RXB0DBEN bit is set\nMode 1, 2:\nFILHIT<4:0>: Filter Hit bits<2:0>\nThese bits, in combination with FILHIT<4:3>, indicate which acceptance filter enabled the message reception into this receive buffer.\n01111 = Acceptance Filter 15 (RXF15)\n01110 = Acceptance Filter 14 (RXF14)\n...\n00000 = Acceptance Filter 0 (RXF0)",
    "bit 2-0\nNote 1: This bit is set by the CAN module upon receiving a message and must be cleared by software after the buffer is read. As long as RXFUL is set, no new message will be loaded and the buffer will be considered full.",
    "REGISTER 34-15: RXBnSIDH: RECEIVE BUFFER 'n' STANDARD IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 1]\nSID10, R-x = SID9. SID10, R-x = SID8. SID10, R-x = SID7. SID10, R-x = SID6. SID10, R-x = SID5. SID10, R-x = SID4. SID10, R-x = SID3. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 0",
    "REGISTER 34-15: RXBnSIDH: RECEIVE BUFFER 'n' STANDARD IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 1]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 SID<10:3>: Standard Identifier bits (if EXID (RXBnSIDL<3>) = 0 Extended Identifier bits, EID<28:21> (if EXID = 1 ).\n)",
    "REGISTER 34-16: RXBnSIDL: RECEIVE BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\nSID2, R-x = SID1. SID2, R-x = SID0. SID2, R-x = SRR. SID2, R-x = EXID. SID2, U-0 = -. SID2, R-x = EID17. SID2, R-x = EID16. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, U-0 = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 0",
    "REGISTER 34-16: RXBnSIDL: RECEIVE BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-5\nSID<2:0>: Standard Identifier bits (if EXID = 0 )\nExtended Identifier bits, EID<20:18> (if EXID = 1 ).\nbit 4\nSRR:\nSubstitute Remote Request bit\nbit 3\nEXID: Extended Identifier bit\n1 = Received message is an extended data frame, SID<10:0> are EID<28:18>",
    "REGISTER 34-16: RXBnSIDL: RECEIVE BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\n0 = Received message is a standard data frame\nbit 2\nUnimplemented: Read as ' 0 '\nbit 1-0\nEID<17:16>: Extended Identifier bits",
    "REGISTER 34-17: RXBnEIDH: RECEIVE BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 1]\nEID15, R-x = EID14. EID15, R-x = EID13. EID15, R-x = EID12. EID15, R-x = EID11. EID15, R-x = EID10. EID15, R-x = EID9. EID15, R-x = EID8. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 0",
    "REGISTER 34-17: RXBnEIDH: RECEIVE BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 1]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 EID<15:8>: Extended Identifier bits",
    "REGISTER 34-18: RXBnEIDL: RECEIVE BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\nEID7, R-x = EID6. EID7, R-x = EID5. EID7, R-x = EID4. EID7, R-x = EID3. EID7, R-x = EID2. EID7, R-x = EID1. EID7, R-x = EID0. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 0",
    "REGISTER 34-18: RXBnEIDL: RECEIVE BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 EID<7:0>: Extended Identifier bits",
    "REGISTER 34-19: RXBnDLC: RECEIVE BUFFER 'n' DATA LENGTH CODE REGISTERS [0   n   1] \uf0a3 \uf0a3\n-, R-x = RXRTR. -, R-x = RB1. -, R-x = RB0. -, R-x = DLC3. -, R-x = DLC2. -, R-x = DLC1. -, R-x = DLC0. bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = bit 0",
    "REGISTER 34-19: RXBnDLC: RECEIVE BUFFER 'n' DATA LENGTH CODE REGISTERS [0   n   1] \uf0a3 \uf0a3\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6 RXRTR: Receiver Remote Transmission Request bit\n1 = Remote transfer request\n0 = No remote transfer request\nbit 5\nRB1:\nReserved bit 1\nReserved by CAN Spec and read as ' 0 '.\nbit 4\nRB0:\nReserved bit 0\nReserved by CAN Spec and read as ' 0 '.",
    "bit 3-0 DLC<3:0>: Data Length Code bits\n1111 = Invalid\n1110 = Invalid\n1101 = Invalid\n1100 = Invalid\n1011 = Invalid\n1010 = Invalid\n1001 = Invalid\n1000 = Data length = 8 bytes\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 byte\n0000 = Data length = 0 bytes",
    "REGISTER 34-20: RXBnDm: RECEIVE BUFFER 'n' DATA FIELD BYTE 'm' REGISTERS [0 \uf0a3 n \uf0a3 1, 0 \uf0a3 m \uf0a3 7]\nRXBnDm7, R-x = RXBnDm6. RXBnDm7, R-x = RXBnDm5. RXBnDm7, R-x = RXBnDm4. RXBnDm7, R-x = RXBnDm3. RXBnDm7, R-x = RXBnDm2. RXBnDm7, R-x = RXBnDm1. RXBnDm7, R-x = RXBnDm0. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 0",
    "REGISTER 34-20: RXBnDm: RECEIVE BUFFER 'n' DATA FIELD BYTE 'm' REGISTERS [0 \uf0a3 n \uf0a3 1, 0 \uf0a3 m \uf0a3 7]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 RXBnDm<7:0>: Receive Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 1 and 0 < m < 7) Each receive buffer has an array of registers. For example, Receive Buffer 0 has eight registers: RXB0D0 to RXB0D7.",
    "REGISTER 34-21: RXERRCNT: RECEIVE ERROR COUNT REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. REC7, 1 = REC6. REC7, 2 = REC5. REC7, 3 = REC4. REC7, 4 = REC3. REC7, 5 = REC2. REC7, 6 = REC1. REC7, 7 = REC0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 34-21: RXERRCNT: RECEIVE ERROR COUNT REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 REC<7:0>: Receive Error Counter bits\nThis  register  contains  the  receive  error  value  as  defined  by  the  CAN  specifications.  When RXERRCNT > 127, the module will go into an error-passive state. RXERRCNT does not have the ability to put the module in 'bus-off' state.",
    "EXAMPLE 34-5: READING A CAN MESSAGE\n```",
    "EXAMPLE 34-5: READING A CAN MESSAGE\n; Need to read a pending message from RXB0 buffer. ; To receive any message, filter, mask and RXM1:RXM0 bits in RXB0CON registers must be ; programmed correctly. ; ; Make sure that there is a message pending in RXB0. BTFSS RXB0CON, RXFUL ; Does RXB0 contain a message? BRA NoMessage ; No. Handle this situation... ; We have verified that a message is pending in RXB0 buffer. ; If this buffer can receive both Standard or Extended Identifier messages, ; identify type of message received. BTFSS RXB0SIDL, EXID ; Is this Extended Identifier? BRA StandardMessage ; No. This is Standard Identifier message. ; Yes. This is Extended Identifier message. ; Read all 29-bits of Extended Identifier message. ... ; Now read all data bytes MOVFF RXB0DO, MY_DATA_BYTE1 ... ; Once entire message is read, mark the RXB0 that it is read and no longer FULL.",
    "EXAMPLE 34-5: READING A CAN MESSAGE\nBCF RXB0CON, RXFUL ; This will allow CAN Module to load new messages ; into this buffer. ...\n```",
    "34.15.3.1 Programmable TX/RX and Auto-RTR Buffers\nThe ECAN module contains six message buffers that can be programmed as transmit or receive buffers. Any of these buffers can also be programmed to automati -cally handle RTR messages.\nNote:\nThese registers are not used in Mode 0.",
    "REGISTER 34-22: BnCON: TX/RX BUFFER 'n' CONTROL REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nRXFUL (2), R/W-0 = RXM1. RXFUL (2), R-0 = RXRTRRO. RXFUL (2), R-0 = FILHIT4. RXFUL (2), R-0 = FILHIT3. RXFUL (2), R-0 = FILHIT2. RXFUL (2), R-0 = FILHIT1. RXFUL (2), R-0 = FILHIT0. bit 7, R/W-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R-0 = bit 0",
    "REGISTER 34-22: BnCON: TX/RX BUFFER 'n' CONTROL REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nRXFUL: Receive Full Status bit (2)",
    "bit 7\n1 = Receive buffer contains a received message\n0 = Receive buffer is open to receive a new message",
    "bit 6\nRXM1: Receive Buffer Mode bit\n1 = Receive all messages including partial and invalid (acceptance filters are ignored)\n0 = Receive all valid messages as per acceptance filters",
    "bit 5\nRXRTRRO: Read-Only Remote Transmission Request for Received Message bit\n1 = Received message is a remote transmission request\n0 = Received message is not a remote transmission request\nbit 4-0\nFILHIT<4:0>:\nFilter Hit bits\nThese bits indicate which acceptance filter enabled the last message reception into this buffer.\n01111 = Acceptance Filter 15 (RXF15)\n01110 = Acceptance Filter 14 (RXF14)\n...\n00001 = Acceptance Filter 1 (RXF1)\n00000 = Acceptance Filter 0 (RXF0)",
    "Note 1: These registers are available in Mode 1 and 2 only.\n- 2: This bit is set by the CAN module upon receiving a message and must be cleared by software after the buffer is read. As long as RXFUL is set, no new message will be loaded and the buffer will be considered full.",
    "REGISTER 34-23: BnCON: TX/RX BUFFER 'n' CONTROL REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\nTXBIF (3), R-0 = TXABT (3). TXBIF (3), R-0 = TXLARB (3). TXBIF (3), R-0 = TXERR (3). TXBIF (3), R/W-0 = TXREQ (2,4). TXBIF (3), R/W-0 = RTREN. TXBIF (3), R/W-0 = TXPRI1 (5). TXBIF (3), R/W-0 = TXPRI0 (5). bit 7, R-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 34-23: BnCON: TX/RX BUFFER 'n' CONTROL REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 34-23: BnCON: TX/RX BUFFER 'n' CONTROL REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\nbit 7 TXBIF: Transmit Buffer Interrupt Flag bit (3)\n00 = Priority Level 0 (lowest priority)\nNote 1: These registers are available in Mode 1 and 2 only.\n2: Clearing this bit in software while the bit is set will request a message abort.\n3: This bit is automatically cleared when TXREQ is set.\n4: While TXREQ is set or a transmission is in progress, Transmit Buffer registers remain read-only.\n5: These bits set the order in which the Transmit Buffer register will be transferred. They do not alter the CAN message identifier.\n1 = A message was successfully transmitted\n0 = No message was transmitted\nbit 6\nTXABT: Transmission Aborted Status bit (3)\n1 = Message was aborted\n0 = Message was not aborted\nbit 5\nTXLARB: Transmission Lost Arbitration Status bit (3)\n1 = Message lost arbitration while being sent\n0 = Message did not lose arbitration while being sent\nbit 4\nTXERR: Transmission Error Detected Status bit (3)",
    "REGISTER 34-23: BnCON: TX/RX BUFFER 'n' CONTROL REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\n1 = A bus error occurred while the message was being sent\n0 = A bus error did not occur while the message was being sent\nbit 3\nTXREQ: Transmit Request Status bit (2,4)\n1 = Requests sending a message; clears the TXABT, TXLARB and TXERR bits\n0 = Automatically cleared when the message is successfully sent\nbit 2\nRTREN: Automatic Remote Transmission Request Enable bit\n1 = When a remote transmission request is received, TXREQ will be automatically set\n0 = When a remote transmission request is received, TXREQ will be unaffected\nbit 1-0\nTXPRI<1:0>: Transmit Priority bits (5)\n11 = Priority Level 3 (highest priority)\n10 = Priority Level 2\n01 = Priority Level 1",
    "REGISTER 34-24: BnSIDH: TX/RX BUFFER 'n' STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nSID10, R-x = SID9. SID10, R-x = SID8. SID10, R-x = SID7. SID10, R-x = SID6. SID10, R-x = SID5. SID10, R-x = SID4. SID10, R-x = SID3. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 0",
    "REGISTER 34-24: BnSIDH: TX/RX BUFFER 'n' STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 SID<10:3>: Standard Identifier bits (if EXIDE (BnSIDL<3>) = )\n0 Extended Identifier bits, EID<28:21> (if EXIDE = 1 ).\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-25: BnSIDH: TX/RX BUFFER 'n' STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL0<n>) = \uf0a3 \uf0a3 1 ] (1)\nSID10, R/W-x = SID9. SID10, R/W-x = SID8. SID10, R/W-x = SID7. SID10, R/W-x = SID6. SID10, R/W-x = SID5. SID10, R/W-x = SID4. SID10, R/W-x = SID3. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-25: BnSIDH: TX/RX BUFFER 'n' STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL0<n>) = \uf0a3 \uf0a3 1 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0\nSID<10:3>: Standard Identifier bits (if EXIDE (BnSIDL<3>) = 0 ) Extended Identifier bits, EID<28:21> (if EXIDE = 1 ).\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-26: BnSIDL: TX/RX BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nSID2, R-x = SID1. SID2, R-x = SID0. SID2, R-x = SRR. SID2, R-x = EXIDE. SID2, U-0 = -. SID2, R-x = EID17. SID2, R-x = EID16. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, U-0 = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 0",
    "REGISTER 34-26: BnSIDL: TX/RX BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-5\nSID<2:0>: Standard Identifier bits (if EXID = 0 )\nExtended Identifier bits, EID<20:18> (if EXID = 1 ).\nbit 4\nSRR: Substitute Remote Transmission Request bit",
    "REGISTER 34-26: BnSIDL: TX/RX BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nThis bit is always ' 1 ' when EXID = 1 or equal to the value of RXRTRRO (BnCON<5>) when EXID = 0 .\nbit 3\nEXIDE: Extended Identifier Enable bit\n1 = Received message is an extended identifier frame (SID<10:0> are EID<28:18>)\n0 = Received message is a standard identifier frame\nbit 2\nUnimplemented: Read as ' 0 '\nbit 1-0 EID<17:16>: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-27: BnSIDL: TX/RX BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL0<n>) = \uf0a3 \uf0a3 1 ] (1)\nSID2, R/W-x = SID1. SID2, R/W-x = SID0. SID2, U-0 = -. SID2, R/W-x = EXIDE. SID2, U-0 = -. SID2, R/W-x = EID17. SID2, R/W-x = EID16. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-x = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-27: BnSIDL: TX/RX BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL0<n>) = \uf0a3 \uf0a3 1 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-5\nSID<2:0>: Standard Identifier bits (if EXIDE (TXBnSIDL<3>) = 0 )\nExtended Identifier bits, EID<20:18> (if EXIDE = 1 ).\nbit 4\nUnimplemented: Read as ' 0 '\nbit 3",
    "REGISTER 34-27: BnSIDL: TX/RX BUFFER 'n' STANDARD IDENTIFIER REGISTERS, LOW BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL0<n>) = \uf0a3 \uf0a3 1 ] (1)\nEXIDE: Extended Identifier Enable bit\n1 = Message will transmit extended ID, SID<10:0> bits become EID<28:18>\n0 = Received will transmit standard ID, EID<17:0> are ignored\nbit 2\nUnimplemented: Read as ' 0 '\nbit 1-0 EID<17:16>: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-28: BnEIDH: TX/RX BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, HIGH BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nEID15, R-x = EID14. EID15, R-x = EID13. EID15, R-x = EID12. EID15, R-x = EID11. EID15, R-x = EID10. EID15, R-x = EID9. EID15, R-x = EID8. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 0",
    "REGISTER 34-28: BnEIDH: TX/RX BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, HIGH BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 EID<15:8>: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-29: BnEIDH: TX/RX BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, HIGH BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL0<n>) = \uf0a3 \uf0a3 1 ] (1)\nEID15, R/W-x = EID14. EID15, R/W-x = EID13. EID15, R/W-x = EID12. EID15, R/W-x = EID11. EID15, R/W-x = EID10. EID15, R/W-x = EID9. EID15, R/W-x = EID8. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-29: BnEIDH: TX/RX BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, HIGH BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL0<n>) = \uf0a3 \uf0a3 1 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 EID<15:8>: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-30: BnEIDL: TX/RX BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, LOW BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL<n>) = 0 ] (1)\nEID7, R-x = EID6. EID7, R-x = EID5. EID7, R-x = EID4. EID7, R-x = EID3. EID7, R-x = EID2. EID7, R-x = EID1. EID7, R-x = EID0. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 0",
    "REGISTER 34-30: BnEIDL: TX/RX BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, LOW BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL<n>) = 0 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 EID<7:0>: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-31: BnEIDL: TX/RX BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, LOW BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL<n>) = 1 ] (1)\nEID7, R/W-x = EID6. EID7, R/W-x = EID5. EID7, R/W-x = FEID4. EID7, R/W-x = EID3. EID7, R/W-x = EID2. EID7, R/W-x = EID1. EID7, R/W-x = EID0. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-31: BnEIDL: TX/RX BUFFER 'n' EXTENDED IDENTIFIER REGISTERS, LOW BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL<n>) = 1 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 EID<7:0>: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-32: BnDm: TX/RX BUFFER 'n' DATA FIELD BYTE 'm' REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 0 ] (1)\nBnDm7, R-x = BnDm6. BnDm7, R-x = BnDm5. BnDm7, R-x = BnDm4. BnDm7, R-x = BnDm3. BnDm7, R-x = BnDm2. BnDm7, R-x = BnDm1. BnDm7, R-x = BnDm0. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 0",
    "REGISTER 34-32: BnDm: TX/RX BUFFER 'n' DATA FIELD BYTE 'm' REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 0 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 BnDm<7:0>: Receive Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 3 and 0 < m < 8) Each receive buffer has an array of registers. For example, Receive Buffer 0 has 7 registers: B0D0 to B0D7.",
    "REGISTER 34-32: BnDm: TX/RX BUFFER 'n' DATA FIELD BYTE 'm' REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 0 ] (1)\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-33: BnDm: TX/RX BUFFER 'n' DATA FIELD BYTE 'm' REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 1 ] (1)\nBnDm7, R/W-x = BnDm6. BnDm7, R/W-x = BnDm5. BnDm7, R/W-x = BnDm4. BnDm7, R/W-x = BnDm3. BnDm7, R/W-x = BnDm2. BnDm7, R/W-x = BnDm1. BnDm7, R/W-x = BnDm0. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-33: BnDm: TX/RX BUFFER 'n' DATA FIELD BYTE 'm' REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 1 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 BnDm<7:0>: Transmit Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 3 and 0 < m < 8) Each transmit buffer has an array of registers. For example, Transmit Buffer 0 has 7 registers: TXB0D0 to TXB0D7.",
    "REGISTER 34-33: BnDm: TX/RX BUFFER 'n' DATA FIELD BYTE 'm' REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 1 ] (1)\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-34: BnDLC: TX/RX BUFFER 'n' DATA LENGTH CODE REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL<n>) = 0 ] (1)\n-, R-x = RXRTR. -, R-x = RB1. -, R-x = RB0. -, R-x = DLC3. -, R-x = DLC2. -, R-x = DLC1. -, R-x = DLC0. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 7. bit 7, R-x = bit 0",
    "REGISTER 34-34: BnDLC: TX/RX BUFFER 'n' DATA LENGTH CODE REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL<n>) = 0 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6\nRXRTR: Receiver Remote Transmission Request bit\n1 = This is a remote transmission request\n0 = This is not a remote transmission request\nbit 5\nRB1: Reserved bit 1\nReserved by CAN Spec and read as ' 0 '.",
    "bit 4 RB0: Reserved bit 0\nReserved by CAN Spec and read as ' 0 '.",
    "bit 3-0 DLC<3:0>: Data Length Code bits\n1111 = Reserved\n1110 = Reserved\n1101 = Reserved\n1100 = Reserved\n1011 = Reserved\n1010 = Reserved\n1001 = Reserved\n1000 = Data length = 8 bytes\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 byte\n0000 = Data length = 0 bytes\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-35: BnDLC: TX/RX BUFFER 'n' DATA LENGTH CODE REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL<n>) = 1 ] (1)\n-, R/W-x = TXRTR. -, U-0 = -. -, U-0 = -. -, R/W-x = DLC3. -, R/W-x = DLC2. -, R/W-x = DLC1. -, R/W-x = DLC0. bit 7, R/W-x = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-35: BnDLC: TX/RX BUFFER 'n' DATA LENGTH CODE REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL<n>) = 1 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6\nTXRTR: Transmitter Remote Transmission Request bit\n1 = Transmitted message will have the RTR bit set\n0 = Transmitted message will have the RTR bit cleared\nbit 5-4\nUnimplemented: Read as ' 0 '\nbit 3-0\nDLC<3:0>: Data Length Code bits\n1111 1001 - = Reserved\n1000 = Data length = 8 bytes\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 byte\n0000 = Data length = 0 bytes\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 34-36: BSEL0: BUFFER SELECT REGISTER 0 (1)\nB5TXEN, R/W-0 = B4TXEN. B5TXEN, R/W-0 = B3TXEN. B5TXEN, R/W-0 = B2TXEN. B5TXEN, R/W-0 = B1TXEN. B5TXEN, R/W-0 = B0TXEN. B5TXEN, U-0 = -. B5TXEN, U-0 = -. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0",
    "REGISTER 34-36: BSEL0: BUFFER SELECT REGISTER 0 (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-2\nB<5:0>TXEN: Buffer 5 to Buffer 0 Transmit Enable bits\n1 = Buffer is configured in Transmit mode\n0 = Buffer is configured in Receive mode\nbit 1-0\nUnimplemented: Read as ' 0 '\nNote 1: These registers are available in Mode 1 and 2 only.",
    "34.15.3.2 Message Acceptance Filters and Masks\nThis section describes the message acceptance filters and masks for the CAN receive buffers.",
    "REGISTER 34-37: RXFnSIDH: RECEIVE ACCEPTANCE FILTER 'n' STANDARD IDENTIFIER FILTER REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 15] (1)\nSID10, R/W-x = SID9. SID10, R/W-x = SID8. SID10, R/W-x = SID7. SID10, R/W-x = SID6. SID10, R/W-x = SID5. SID10, R/W-x = SID4. SID10, R/W-x = SID3. bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = bit 0",
    "REGISTER 34-37: RXFnSIDH: RECEIVE ACCEPTANCE FILTER 'n' STANDARD IDENTIFIER FILTER REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 15] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 SID<10:3>: Standard Identifier Filter bits (if EXIDEN = 0 )\nExtended Identifier Filter bits, EID<28:21> (if EXIDEN = 1 ).\nNote 1: Registers, RXF6SIDH:RXF15SIDH, are available in Mode 1 and 2 only.",
    "REGISTER 34-38: RXFnSIDL: RECEIVE ACCEPTANCE FILTER 'n' STANDARD IDENTIFIER FILTER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 15] (1)\nSID2, R/W-x = SID1. SID2, R/W-x = SID0. SID2, U-0 = -. SID2, R/W-x = EXIDEN (2). SID2, U-0 = -. SID2, R/W-x = EID17. SID2, R/W-x = EID16. bit 7, R/W-x = . bit 7, R/W-x = . bit 7, U-0 = . bit 7, R/W-x = . bit 7, U-0 = . bit 7, R/W-x = . bit 7, R/W-x = bit 0",
    "REGISTER 34-38: RXFnSIDL: RECEIVE ACCEPTANCE FILTER 'n' STANDARD IDENTIFIER FILTER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 15] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-5\nSID<2:0>: Standard Identifier Filter bits (if EXIDEN = 0 )\nExtended Identifier Filter bits, EID<20:18> (if EXIDEN = 1 ).\nbit 4\nUnimplemented: Read as ' 0 '\nbit 3\nEXIDEN: Extended Identifier Filter Enable bit (2)\n1 = Filter will only accept extended ID messages",
    "REGISTER 34-38: RXFnSIDL: RECEIVE ACCEPTANCE FILTER 'n' STANDARD IDENTIFIER FILTER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 15] (1)\n0 = Filter will only accept standard ID messages\nbit 2\nUnimplemented: Read as ' 0 '\nbit 1-0 EID<17:16>: Extended Identifier Filter bits\nNote 1: Registers, RXF6SIDL:RXF15SIDL, are available in Mode 1 and 2 only.\n2: In Mode 0, this bit must be set/cleared as required, irrespective of corresponding mask register value.",
    "REGISTER 34-39: RXFnEIDH: RECEIVE ACCEPTANCE FILTER 'n' EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 15] (1)\nEID15, R/W-x = EID14. EID15, R/W-x = EID13. EID15, R/W-x = EID12. EID15, R/W-x = EID11. EID15, R/W-x = EID10. EID15, R/W-x = EID9. EID15, R/W-x = EID8. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-39: RXFnEIDH: RECEIVE ACCEPTANCE FILTER 'n' EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 15] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 EID<15:8>: Extended Identifier Filter bits\nNote 1: Registers, RXF6EIDH:RXF15EIDH, are available in Mode 1 and 2 only.",
    "REGISTER 34-40: RXFnEIDL: RECEIVE ACCEPTANCE FILTER 'n' EXTENDED IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 15] (1)\nEID7, R/W-x = EID6. EID7, R/W-x = EID5. EID7, R/W-x = EID4. EID7, R/W-x = EID3. EID7, R/W-x = EID2. EID7, R/W-x = EID1. EID7, R/W-x = EID0. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-40: RXFnEIDL: RECEIVE ACCEPTANCE FILTER 'n' EXTENDED IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 15] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 EID<7:0>: Extended Identifier Filter bits\nNote 1: Registers, RXF6EIDL:RXF15EIDL, are available in Mode 1 and 2 only.",
    "REGISTER 34-41: RXMnSIDH: RECEIVE ACCEPTANCE MASK 'n' STANDARD IDENTIFIER MASK REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 1]\nSID10, R/W-x = SID9. SID10, R/W-x = SID8. SID10, R/W-x = SID7. SID10, R/W-x = SID6. SID10, R/W-x = SID5. SID10, R/W-x = SID4. SID10, R/W-x = SID3. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-41: RXMnSIDH: RECEIVE ACCEPTANCE MASK 'n' STANDARD IDENTIFIER MASK REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 1]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 SID<10:3>: Standard Identifier Mask bits or Extended Identifier Mask bits (EID<28:21>)",
    "REGISTER 34-42: RXMnSIDL: RECEIVE ACCEPTANCE MASK 'n' STANDARD IDENTIFIER MASK REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\nSID2, R/W-x = SID1. SID2, R/W-x = SID0. SID2, U-0 = -. SID2, R/W-0 = EXIDEN (1). SID2, U-0 = -. SID2, R/W-x = EID17. SID2, R/W-x = EID16. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-42: RXMnSIDL: RECEIVE ACCEPTANCE MASK 'n' STANDARD IDENTIFIER MASK REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-5 SID<2:0>: Standard Identifier Mask bits or Extended Identifier Mask bits (EID<20:18>)\nbit 4\nUnimplemented: Read as ' 0 '\nbit 3\nMode 0:\nUnimplemented: Read as ' 0 '\nMode 1, 2:\nEXIDEN: Extended Identifier Filter Enable Mask bit (1)",
    "REGISTER 34-42: RXMnSIDL: RECEIVE ACCEPTANCE MASK 'n' STANDARD IDENTIFIER MASK REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\n1 = Messages selected by the EXIDEN bit in RXFnSIDL will be accepted\n0 = Both standard and extended identifier messages will be accepted\nbit 2\nUnimplemented: Read as ' 0 '\nbit 1-0\nEID<17:16>: Extended Identifier Mask bits\nNote 1: This bit is available in Mode 1 and 2 only.",
    "REGISTER 34-43: RXMnEIDH: RECEIVE ACCEPTANCE MASK 'n' EXTENDED IDENTIFIER MASK REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 1]\nEID15, R/W-x = EID14. EID15, R/W-x = EID13. EID15, R/W-x = EID12. EID15, R/W-x = EID11. EID15, R/W-x = EID10. EID15, R/W-x = EID9. EID15, R/W-x = EID8. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-43: RXMnEIDH: RECEIVE ACCEPTANCE MASK 'n' EXTENDED IDENTIFIER MASK REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 1]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 EID<15:8>: Extended Identifier Mask bits",
    "REGISTER 34-44: RXMnEIDL: RECEIVE ACCEPTANCE MASK 'n' EXTENDED IDENTIFIER MASK REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\nEID7, R/W-x = EID6. EID7, R/W-x = EID5. EID7, R/W-x = EID4. EID7, R/W-x = EID3. EID7, R/W-x = EID2. EID7, R/W-x = EID1. EID7, R/W-x = EID0. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 34-44: RXMnEIDL: RECEIVE ACCEPTANCE MASK 'n' EXTENDED IDENTIFIER MASK REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-0 EID<7:0>: Extended Identifier Mask bits",
    "REGISTER 34-45: RXFCONn: RECEIVE FILTER CONTROL REGISTER 'n' [0   n \uf0a3 \uf0a3 1] (1)\nRXFCON0, 1 = R/W-0. RXFCON0, 2 = R/W-0. RXFCON0, 3 = R/W-0. RXFCON0, 4 = R/W-0. RXFCON0, 5 = R/W-0. RXFCON0, 6 = R/W-0. RXFCON0, 7 = R/W-0. RXFCON0, 8 = R/W-0. RXFCON0, 1 = RXF7EN. RXFCON0, 2 = RXF6EN. RXFCON0, 3 = RXF5EN. RXFCON0, 4 = RXF4EN. RXFCON0, 5 = RXF3EN. RXFCON0, 6 = RXF2EN. RXFCON0, 7 = RXF1EN. RXFCON0, 8 = RXF0EN",
    "REGISTER 34-45: RXFCONn: RECEIVE FILTER CONTROL REGISTER 'n' [0   n \uf0a3 \uf0a3 1] (1)\nRXFCON1, R/W-0 = RXF15EN. RXFCON1, R/W-0 = RXF14EN. RXFCON1, R/W-0 = RXF13EN. RXFCON1, R/W-0 = RXF12EN. RXFCON1, R/W-0 = RXF11EN. RXFCON1, R/W-0 = RXF10EN. RXFCON1, R/W-0 = RXF9EN. RXFCON1, R/W-0 = RXF8EN. , R/W-0 = bit 7. , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = bit 0",
    "REGISTER 34-45: RXFCONn: RECEIVE FILTER CONTROL REGISTER 'n' [0   n \uf0a3 \uf0a3 1] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 RXF<7:0>EN: Receive Filter n Enable bits\n0 = Filter is disabled\n1 = Filter is enabled\nNote 1: This register is available in Mode 1 and 2 only.\n\nNote:, 1 = Register 34-46 through Register 34-51 are writable in Configuration mode only.",
    "REGISTER 34-46: SDFLC: STANDARD DATA BYTES FILTER LENGTH COUNT REGISTER (1)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = FLC4. -, 4 = FLC3. -, 5 = FLC2. -, 6 = FLC1. -, 7 = FLC0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 34-46: SDFLC: STANDARD DATA BYTES FILTER LENGTH COUNT REGISTER (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-5 Unimplemented: Read as ' 0 '\nbit 4-0\nFLC<4:0>: Filter Length Count bits\nMode 0:\nNot used; forced to ' 00000 '.\nMode 1, 2:\n00000 10010 - = 0",
    "REGISTER 34-46: SDFLC: STANDARD DATA BYTES FILTER LENGTH COUNT REGISTER (1)\n18 bits are available for standard data byte filter. Actual number of bits used depends on the DLC<3:0> bits (RXBnDLC<3:0> or BnDLC<3:0> if configured as RX buffer) of the message being received.\nIf DLC<3:0>\n= 0000\nNo bits will be compared with incoming data bits.\nIf DLC<3:0>\n= 0001\nUp to 8 data bits of RXFnEID<7:0>, as determined by FLC<2:0>, will be com - pared with the corresponding number of data bits of the incoming message.\nIf DLC<3:0> = 0010\nUp to 16 data bits of RXFnEID<15:0>, as determined by FLC<3:0>, will be compared  with  the  corresponding  number  of  data  bits  of  the  incoming message.\nIf DLC<3:0>\n= 0011",
    "REGISTER 34-46: SDFLC: STANDARD DATA BYTES FILTER LENGTH COUNT REGISTER (1)\nUp to 18 data bits of RXFnEID<17:0>, as determined by FLC<4:0>, will be compared  with  the  corresponding  number  of  data  bits  of  the  incoming message.\nNote 1: This register is available in Mode 1 and 2 only.",
    "REGISTER 34-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER 'n' (1)\n, R/W-0.F1BP_3 = R/W-0. , R/W-0.F1BP_2 = R/W-0. , R/W-0.F1BP_1 = R/W-0. , R/W-0.F1BP_0 = R/W-1. , R/W-0.F0BP_3 = R/W-0. , R/W-0.F0BP_2 = R/W-0. , R/W-0.F0BP_1 = R/W-0. , R/W-0. = . , F0BP_0 = R/W-1. , R/W-0.F1BP_3 = F3BP_3. , R/W-0.F1BP_2 = F3BP_2. , R/W-0.F1BP_1 = F3BP_1. , R/W-0.F1BP_0 =",
    "REGISTER 34-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER 'n' (1)\nF3BP_0. , R/W-0.F0BP_3 = F2BP_3. , R/W-0.F0BP_2 = F2BP_2. , R/W-0.F0BP_1 = . , R/W-0. = F2BP_1. , F0BP_0 = F2BP_0. , R/W-0.F1BP_3 = R/W-0. , R/W-0.F1BP_2 = R/W-0. , R/W-0.F1BP_1 = R/W-0. , R/W-0.F1BP_0 = R/W-1. , R/W-0.F0BP_3 = R/W-0. , R/W-0.F0BP_2 = R/W-0. , R/W-0.F0BP_1 = R/W-0. ,",
    "REGISTER 34-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER 'n' (1)\nR/W-0. = . , F0BP_0 = R/W-1. , R/W-0.F1BP_3 = F5BP_3. , R/W-0.F1BP_2 = F5BP_2. , R/W-0.F1BP_1 = F5BP_1. , R/W-0.F1BP_0 = F5BP_0. , R/W-0.F0BP_3 = F4BP_3. , R/W-0.F0BP_2 = F4BP_2. , R/W-0.F0BP_1 = . , R/W-0. = F4BP_1. , F0BP_0 = F4BP_0. , R/W-0.F1BP_3 = R/W-0. , R/W-0.F1BP_2 = R/W-0. ,",
    "REGISTER 34-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER 'n' (1)\nR/W-0.F1BP_1 = R/W-0. , R/W-0.F1BP_0 = R/W-0. , R/W-0.F0BP_3 = R/W-0. , R/W-0.F0BP_2 = R/W-0. , R/W-0.F0BP_1 = R/W-0. , R/W-0. = . , F0BP_0 = R/W-0. , R/W-0.F1BP_3 = F7BP_3. , R/W-0.F1BP_2 = F7BP_2. , R/W-0.F1BP_1 = F7BP_1. , R/W-0.F1BP_0 = F7BP_0. , R/W-0.F0BP_3 = F6BP_3. , R/W-0.F0BP_2",
    "REGISTER 34-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER 'n' (1)\n= F6BP_2. , R/W-0.F0BP_1 = . , R/W-0. = F6BP_1. , F0BP_0 = F6BP_0. , R/W-0.F1BP_3 = R/W-0. , R/W-0.F1BP_2 = R/W-0. , R/W-0.F1BP_1 = R/W-0. , R/W-0.F1BP_0 = R/W-0. , R/W-0.F0BP_3 = R/W-0. , R/W-0.F0BP_2 = R/W-0. , R/W-0.F0BP_1 = . , R/W-0. = R/W-0. , F0BP_0 = R/W-0. , R/W-0.F1BP_3 = F9BP_3. ,",
    "REGISTER 34-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER 'n' (1)\nR/W-0.F1BP_2 = F9BP_2. , R/W-0.F1BP_1 = F9BP_1. , R/W-0.F1BP_0 = F9BP_0. , R/W-0.F0BP_3 = F8BP_3. , R/W-0.F0BP_2 = F8BP_2. , R/W-0.F0BP_1 = . , R/W-0. = F8BP_1. , F0BP_0 = F8BP_0. , R/W-0.F1BP_3 = R/W-0. , R/W-0.F1BP_2 = R/W-0. , R/W-0.F1BP_1 = R/W-0. , R/W-0.F1BP_0 = R/W-0. ,",
    "REGISTER 34-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER 'n' (1)\nR/W-0.F0BP_3 = R/W-0. , R/W-0.F0BP_2 = R/W-0. , R/W-0.F0BP_1 = R/W-0. , R/W-0. = . , F0BP_0 = R/W-0. , R/W-0.F1BP_3 = F11BP_3. , R/W-0.F1BP_2 = F11BP_2. , R/W-0.F1BP_1 = F11BP_1. , R/W-0.F1BP_0 = F11BP_0. , R/W-0.F0BP_3 = F10BP_3. , R/W-0.F0BP_2 = F10BP_2. , R/W-0.F0BP_1 = . , R/W-0. = F10BP_1.",
    "REGISTER 34-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER 'n' (1)\n, F0BP_0 = F10BP_0. , R/W-0.F1BP_3 = R/W-0. , R/W-0.F1BP_2 = R/W-0. , R/W-0.F1BP_1 = R/W-0. , R/W-0.F1BP_0 = R/W-0. , R/W-0.F0BP_3 = R/W-0. , R/W-0.F0BP_2 = R/W-0. , R/W-0.F0BP_1 = R/W-0. , R/W-0. = . , F0BP_0 = R/W-0. , R/W-0.F1BP_3 = F13BP_3. , R/W-0.F1BP_2 = F13BP_2. , R/W-0.F1BP_1 = F13BP_1.",
    "REGISTER 34-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER 'n' (1)\n, R/W-0.F1BP_0 = F13BP_0. , R/W-0.F0BP_3 = F12BP_3. , R/W-0.F0BP_2 = F12BP_2. , R/W-0.F0BP_1 = . , R/W-0. = F12BP_1. , F0BP_0 = F12BP_0. , R/W-0.F1BP_3 = R/W-0. , R/W-0.F1BP_2 = R/W-0. , R/W-0.F1BP_1 = R/W-0. , R/W-0.F1BP_0 = R/W-0. , R/W-0.F0BP_3 = R/W-0. , R/W-0.F0BP_2 = R/W-0. ,",
    "REGISTER 34-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER 'n' (1)\nR/W-0.F0BP_1 = . , R/W-0. = R/W-0. , F0BP_0 = R/W-0. , R/W-0.F1BP_3 = F15BP_3. , R/W-0.F1BP_2 = F15BP_2. , R/W-0.F1BP_1 = F15BP_1. , R/W-0.F1BP_0 = F15BP_0. , R/W-0.F0BP_3 = F14BP_3. , R/W-0.F0BP_2 = F14BP_2. , R/W-0.F0BP_1 = . , R/W-0. = F14BP_1. , F0BP_0 = F14BP_0. , R/W-0.F1BP_3 = bit 7. ,",
    "REGISTER 34-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER 'n' (1)\nR/W-0.F1BP_2 = . , R/W-0.F1BP_1 = . , R/W-0.F1BP_0 = . , R/W-0.F0BP_3 = . , R/W-0.F0BP_2 = . , R/W-0.F0BP_1 = . , R/W-0. = . , F0BP_0 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "bit 7-0 F<15:2>BP_<3:0>: Filter n Buffer Pointer Nibble bits\n0000 = Filter n is associated with RXB0\n0001 = Filter n is associated with RXB1\n0010 = Filter n is associated with B0\n0011 = Filter n is associated with B1\n...\n0111 = Filter n is associated with B5 1111-1000 = Reserved\nNote 1: This register is available in Mode 1 and 2 only.",
    "REGISTER 34-48: MSEL0: MASK SELECT REGISTER 0 (1)\nFIL3_1, R/W-1 = FIL3_0. FIL3_1, R/W-0 = FIL2_1. FIL3_1, R/W-1 = FIL2_0. FIL3_1, R/W-0 = FIL1_1. FIL3_1, R/W-0 = FIL1_0. FIL3_1, R/W-0 = FIL0_1. FIL3_1, R/W-0 = FIL0_0. bit 7, R/W-1 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 34-48: MSEL0: MASK SELECT REGISTER 0 (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-6\nFIL3_<1:0>: Filter 3 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 5-4\nFIL2_<1:0>: Filter 2 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 3-2\nFIL1_<1:0>: Filter 1 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 1-0\nFIL0_<1:0>: Filter 0 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.",
    "REGISTER 34-49: MSEL1: MASK SELECT REGISTER 1 (1)\nFIL7_1, R/W-0 = FIL7_0. FIL7_1, R/W-0 = FIL6_1. FIL7_1, R/W-0 = FIL6_0. FIL7_1, R/W-0 = FIL5_1. FIL7_1, R/W-1 = FIL5_0. FIL7_1, R/W-0 = FIL4_1. FIL7_1, R/W-1 = FIL4_0. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-1 = bit 0",
    "REGISTER 34-49: MSEL1: MASK SELECT REGISTER 1 (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-6\nFIL7_<1:0>: Filter 7 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 5-4\nFIL6_<1:0>: Filter 6 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 3-2\nFIL5_<1:0>: Filter 5 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 1-0\nFIL4_<1:0>: Filter 4 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.",
    "REGISTER 34-50: MSEL2: MASK SELECT REGISTER 2 (1)\nFIL11_1, R/W-0 = FIL11_0. FIL11_1, R/W-0 = FIL10_1. FIL11_1, R/W-0 = FIL10_0. FIL11_1, R/W-0 = FIL9_1. FIL11_1, R/W-0 = FIL9_0. FIL11_1, R/W-0 = FIL8_1. FIL11_1, R/W-0 = FIL8_0. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 34-50: MSEL2: MASK SELECT REGISTER 2 (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-6\nFIL11_<1:0>: Filter 11 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 5-4\nFIL10_<1:0>: Filter 10 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 3-2\nFIL9_<1:0>: Filter 9 Select bits 1 and 0\n11 = No mask\n10 = Filter 15",
    "REGISTER 34-50: MSEL2: MASK SELECT REGISTER 2 (1)\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 1-0\nFIL8_<1:0>: Filter 8 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.",
    "REGISTER 34-51: MSEL3: MASK SELECT REGISTER 3 (1)\nFIL15_1, R/W-0 = FIL15_0. FIL15_1, R/W-0 = FIL14_1. FIL15_1, R/W-0 = FIL14_0. FIL15_1, R/W-0 = FIL13_1. FIL15_1, R/W-0 = FIL13_0. FIL15_1, R/W-0 = FIL12_1. FIL15_1, R/W-0 = FIL12_0. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 34-51: MSEL3: MASK SELECT REGISTER 3 (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-6\nFIL15_<1:0>: Filter 15 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 5-4\nFIL14_<1:0>: Filter 14 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 3-2\nFIL13_<1:0>: Filter 13 Select bits 1 and 0\n11 = No mask\n10 = Filter 15",
    "REGISTER 34-51: MSEL3: MASK SELECT REGISTER 3 (1)\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 1-0\nFIL12_<1:0>: Filter 12 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.",
    "34.15.4 CAN BAUD RATE REGISTERS\nThis section describes the CAN Baud Rate registers.\nNote:, 1 = These registers are writable in Configuration mode only.",
    "REGISTER 34-52: BRGCON1: BAUD RATE CONTROL REGISTER 1\nSJW1, R/W-0 = SJW0. SJW1, R/W-0 = BRP5. SJW1, R/W-0 = BRP4. SJW1, R/W-0 = BRP3. SJW1, R/W-0 = BRP2. SJW1, R/W-0 = BRP1. SJW1, R/W-0 = BRP0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 34-52: BRGCON1: BAUD RATE CONTROL REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-6 SJW<1:0>: Synchronized Jump Width bits\n11 = Synchronization jump width time = 4 x TQ\n10 = Synchronization jump width time = 3 x TQ\n01 = Synchronization jump width time = 2 x TQ\n00 = Synchronization jump width time = 1 x TQ",
    "bit 5-0\nBRP<5:0>: Baud Rate Prescaler bits\n111111 = TQ = (2 x 64)/FOSC\n111110 = TQ = (2 x 63)/FOSC\n:\n:\n000001 = TQ = (2 x 2)/FOSC\n000000 = TQ = (2 x 1)/FOSC",
    "REGISTER 34-53: BRGCON2: BAUD RATE CONTROL REGISTER 2\nSEG2PHTS, R/W-0 = SAM. SEG2PHTS, R/W-0 = SEG1PH2. SEG2PHTS, R/W-0 = SEG1PH1. SEG2PHTS, R/W-0 = SEG1PH0. SEG2PHTS, R/W-0 = PRSEG2. SEG2PHTS, R/W-0 = PRSEG1. SEG2PHTS, R/W-0 = PRSEG0. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 34-53: BRGCON2: BAUD RATE CONTROL REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nSEG2PHTS: Phase Segment 2 Time Select bit\n1 = Freely programmable\n0 = Maximum of PHEG1 or Information Processing Time (IPT), whichever is greater\nSAM: Sample of the CAN bus Line bit\n- 1 = Bus line is sampled three times prior to the sample point\n0 = Bus line is sampled once at the sample point\nSEG1PH<2:0>: Phase Segment 1 bits\n111 = Phase Segment 1 time = 8 x TQ\n110 = Phase Segment 1 time = 7 x TQ",
    "REGISTER 34-53: BRGCON2: BAUD RATE CONTROL REGISTER 2\n101 = Phase Segment 1 time = 6 x TQ\n100 = Phase Segment 1 time = 5 x TQ\n011 = Phase Segment 1 time = 4 x TQ\n010 = Phase Segment 1 time = 3 x TQ\n001 = Phase Segment 1 time = 2 x TQ\n000 = Phase Segment 1 time = 1 x TQ",
    "bit 2-0 PRSEG<2:0>: Propagation Time Select bits\n111 = Propagation time = 8 x TQ\n110 = Propagation time = 7 x TQ\n101 = Propagation time = 6 x TQ\n100 = Propagation time = 5 x TQ\n011 = Propagation time = 4 x TQ\n010 = Propagation time = 3 x TQ\n001 = Propagation time = 2 x TQ\n000 = Propagation time = 1 x TQ",
    "REGISTER 34-54: BRGCON3: BAUD RATE CONTROL REGISTER 3\nWAKDIS, R/W-0 = WAKFIL. WAKDIS, U-0 = -. WAKDIS, U-0 = -. WAKDIS, U-0 = -. WAKDIS, R/W-0 = SEG2PH2 (1). WAKDIS, R/W-0 = SEG2PH1 (1). WAKDIS, R/W-0 = SEG2PH0 (1). bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 34-54: BRGCON3: BAUD RATE CONTROL REGISTER 3\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 WAKDIS: Wake-up Disable bit\n1 = Disable CAN bus activity wake-up feature\n0 = Enable CAN bus activity wake-up feature\nbit 6\nWAKFIL: Selects CAN bus Line Filter for Wake-up bit\n1 = Use CAN bus line filter for wake-up\n0 = CAN bus line filter is not used for wake-up\nbit 5-3\nUnimplemented: Read as ' 0 '\nbit 2-0 SEG2PH<2:0>: Phase Segment 2 Time Select bits (1)\n111 = Phase Segment 2 time = 8 x TQ\n110 = Phase Segment 2 time = 7 x TQ\n101 = Phase Segment 2 time = 6 x TQ\n100 = Phase Segment 2 time = 5 x TQ\n011 = Phase Segment 2 time = 4 x TQ\n010 = Phase Segment 2 time = 3 x TQ\n001 = Phase Segment 2 time = 2 x TQ\n000 = Phase Segment 2 time = 1 x TQ\nNote 1: These bits are ignored if SEG2PHTS bit (BRGCON2<7>) is ' 0 '.",
    "34.15.5 CAN MODULE I/O CONTROL REGISTER\nThis register controls the operation of the CAN module's I/O pins in relation to the rest of the microcontroller.",
    "REGISTER 34-55: CIOCON: CAN I/O CONTROL REGISTER\nTX1SRC, U-0 = -. TX1SRC, U-0 = -. TX1SRC, U-0 = -. TX1SRC, U-0 = -. TX1SRC, U-0 = -. TX1SRC, U-0 = -. TX1SRC, R/W-0 = CLKSEL. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 34-55: CIOCON: CAN I/O CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nTX1SRC: CAN_tx1 Signal Data Source bit\n1 = CAN_tx1 signal will output the CAN clock\n0 = CAN_tx1 signal will output CANTX\nbit 6-1\nUnimplemented: Read as ' 0 '\nbit 0\nCLKSEL: CAN Clock Source Selection bit\n1 = CAN clock is sourced by the clock selected by the FEXTOSC Configuration bit field, regardless of system clock (1)\n0 = CAN clock is sourced from the system clock",
    "REGISTER 34-55: CIOCON: CAN I/O CONTROL REGISTER\nNote 1: When CLKSEL = 1 , the clock supplied by FEXTOSC must be less than or equal to the system clock. If the CAN clock is greater than the system clock, unexpected behavior will occur.",
    "34.15.6 CAN INTERRUPT REGISTERS\nThe registers in this section are the same as described\nin Section 9.0 'Interrupt Controller' . They are dupli -\ncated here for convenience.",
    "REGISTER 34-56: PIR5: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 5\nMode 1,2, R/W-0.IRXIF = R/W-0. Mode 1,2, R/W-0.WAKIF = R/W-0. Mode 1,2, R/W-0.ERRIF = R/W-0. Mode 1,2, R/W-0.TXB2IF = R/W-0. Mode 1,2, R/W-0.TXB1IF (1) = R/W-0. Mode 1,2, R/W-0.TXB0IF (1) = R/W-0. Mode 1,2, R/W-0.RXB1IF = R/W-0. Mode 1,2, R/W-0.RXB0IF = R/W-0. Mode 1,2, R/W-0.IRXIF = IRXIF. Mode 1,2, R/W-0.WAKIF = WAKIF. Mode 1,2, R/W-0.ERRIF = ERRIF. Mode",
    "REGISTER 34-56: PIR5: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 5\n1,2, R/W-0.TXB2IF = TXBnIF. Mode 1,2, R/W-0.TXB1IF (1) = TXB1IF (1). Mode 1,2, R/W-0.TXB0IF (1) = TXB0IF (1). Mode 1,2, R/W-0.RXB1IF = RXBnIF. Mode 1,2, R/W-0.RXB0IF = FIFOWMIF. , R/W-0.IRXIF = bit 7. , R/W-0.WAKIF = . , R/W-0.ERRIF = . , R/W-0.TXB2IF = . , R/W-0.TXB1IF (1) = . , R/W-0.TXB0IF (1) = . , R/W-0.RXB1IF = . , R/W-0.RXB0IF = bit 0",
    "REGISTER 34-56: PIR5: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 5\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nIRXIF: CAN Bus Error Message Received Interrupt Flag bit\n1 = An invalid message has occurred on the CAN bus\n0 = No invalid message on the CAN bus",
    "bit 6 WAKIF: CAN Bus Activity Wake-up Interrupt Flag bit\n1 = Activity on the CAN bus has occurred\n0 = No activity on the CAN bus",
    "bit 5 ERRIF: CAN Module Error Interrupt Flag bit\n1 = An error has occurred in the CAN module (multiple sources; refer to Section 34.14.6 'Error Interrupt' )\n0 = No CAN module errors",
    "bit 4\nWhen CAN is in Mode 0:\n- 1 = Transmit Buffer 2 has completed transmission of a message and may be reloaded\nTXB2IF: CAN Transmit Buffer 2 Interrupt Flag bit\n- 0 = Transmit Buffer 2 has not completed transmission of a message\nWhen CAN is in Mode 1 or 2:\nTXBnIF: Any Transmit Buffer Interrupt Flag bit\n0 = No transmit buffer is ready for reload\n1 = One or more transmit buffers have completed transmission of a message and may be reloaded\nbit 3 TXB1IF: CAN Transmit Buffer 1 Interrupt Flag bit (1)\n1 = Transmit Buffer 1 has completed transmission of a message and may be reloaded",
    "bit 2 TXB0IF: CAN Transmit Buffer 0 Interrupt Flag bit (1)\n0 = Transmit Buffer 1 has not completed transmission of a message\n1 = Transmit Buffer 0 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 0 has not completed transmission of a message",
    "bit 1 When CAN is in Mode 0:\nRXB1IF: CAN Receive Buffer 1 Interrupt Flag bit\n1 = Receive Buffer 1 has received a new message\n0 = Receive Buffer 1 has not received a new message\nWhen CAN is in Mode 1 or 2:\n- 1 = One or more receive buffers has received a new message\nRXBnIF: Any Receive Buffer Interrupt Flag bit\n- 0 = No receive buffer has received a new message",
    "bit 0 When CAN is in Mode 0:\n- 1 = Receive Buffer 0 has received a new message\nRXB0IF: CAN Receive Buffer 0 Interrupt Flag bit\n- 0 = Receive Buffer 0 has not received a new message\nWhen CAN is in Mode 1:\nUnimplemented: Read as ' 0 '\nWhen CAN is in Mode 2:\nFIFOWMIF: FIFO Watermark Interrupt Flag bit\n0 = FIFO high watermark is not reached\n1 = FIFO high watermark is reached\nNote 1: In CAN Mode 1 and 2, these bits are forced to ' 0 '.",
    "REGISTER 34-57: PIE5: PERIPHERAL INTERRUPT ENABLE REGISTER 5\nMode 0, 1 = R/W-0. Mode 0, 2 = R/W-0. Mode 0, 3 = R/W-0. Mode 0, 4 = R/W-0. Mode 0, 5 = R/W-0. Mode 0, 6 = R/W-0. Mode 0, 7 = R/W-0. Mode 0, 8 = R/W-0. Mode 0, 1 = IRXIE. Mode 0, 2 = WAKIE. Mode 0, 3 = ERRIE. Mode 0, 4 = TXB2IE. Mode 0, 5 = TXB1IE (1). Mode 0, 6 = TXB0IE (1). Mode 0, 7 = RXB1IE. Mode 0, 8 = RXB0IE",
    "REGISTER 34-57: PIE5: PERIPHERAL INTERRUPT ENABLE REGISTER 5\nMode 1, R/W-0 = IRXIE. Mode 1, R/W-0 = WAKIE. Mode 1, R/W-0 = ERRIE. Mode 1, R/W-0 = TXBnIE. Mode 1, R/W-0 = TXB1IE (1). Mode 1, R/W-0 = TXB0IE (1). Mode 1, R/W-0 = RXBnIE. Mode 1, R/W-0 = FIFOWMIE. , R/W-0 = bit 7. , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = bit 0",
    "REGISTER 34-57: PIE5: PERIPHERAL INTERRUPT ENABLE REGISTER 5\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 IRXIE: CAN Bus Error Message Received Interrupt Enable bit\n1 = Enable invalid message received interrupt\n0 = Disable invalid message received interrupt",
    "bit 6\nWAKIE: CAN bus Activity Wake-up Interrupt Enable bit\n1 = Enable bus activity wake-up interrupt\n0 = Disable bus activity wake-up interrupt",
    "bit 5 ERRIE: CAN bus Error Interrupt Enable bit\n1 = Enable CAN module error interrupt\n0 = Disable CAN module error interrupt",
    "bit 4 When CAN is in Mode 0:\nTXB2IE: CAN Transmit Buffer 2 Interrupt Enable bit\n1 = Enable Transmit Buffer 2 interrupt\n0 = Disable Transmit Buffer 2 interrupt\nWhen CAN is in Mode 1 or 2:\nTXBnIE: CAN Transmit Buffer Interrupts Enable bit\n1 = Enable transmit buffer interrupt; individual interrupt is enabled by TXBIE and BIE0\n0 = Disable all transmit buffer interrupts",
    "bit 3 TXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1)\n1 = Enable Transmit Buffer 1 interrupt\n0 = Disable Transmit Buffer 1 interrupt",
    "bit 2\nTXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1)\n1 = Enable Transmit Buffer 0 interrupt\n0 = Disable Transmit Buffer 0 interrupt",
    "bit 1 When CAN is in Mode 0:\nRXB1IE: CAN Receive Buffer 1 Interrupt Enable bit\n1 = Enable Receive Buffer 1 interrupt\n0 = Disable Receive Buffer 1 interrupt\nWhen CAN is in Mode 1 or 2:\nRXBnIE: CAN Receive Buffer Interrupts Enable bit\n1 = Enable receive buffer interrupt; individual interrupt is enabled by BIE0\n0 = Disable all receive buffer interrupts\nWhen CAN is in Mode 0:\nRXB0IE: CAN Receive Buffer 0 Interrupt Enable bit\n1 = Enable Receive Buffer 0 interrupt\n0 = Disable Receive Buffer 0 interrupt\nWhen CAN is in Mode 1:\nUnimplemented: Read as ' 0 '",
    "When CAN is in Mode 2:\nFIFOWMIE: FIFO Watermark Interrupt Enable bit\n1 = Enable FIFO watermark interrupt\n0 = Disable FIFO watermark interrupt\nNote 1: In CAN Mode 1 and 2, these bits are forced to ' 0 '.",
    "REGISTER 34-58: IPR5: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nMode 0\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nIRXIP\nWAKIP\nERRIP\nTXB2IP\nTXB1IP\n(1)\nTXB0IP\n(1)\nRXB1IP\nRXB0IP",
    "REGISTER 34-58: IPR5: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nMode 1,2, R/W-1 = IRXIP. Mode 1,2, R/W-1 = WAKIP. Mode 1,2, R/W-1 = ERRIP. Mode 1,2, R/W-1 = TXBnIP. Mode 1,2, R/W-1 = TXB1IP (1). Mode 1,2, R/W-1 = TXB0IP (1). Mode 1,2, R/W-1 = RXBnIP. Mode 1,2, R/W-1 = FIFOWMIP. , R/W-1 = bit 7. , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = bit 0",
    "REGISTER 34-58: IPR5: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\n-n = Value at POR, W=Writable = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, read = '0' = Bit is cleared. -n = Value at POR, as '0' = x = Bit is unknown\nIRXIP: CAN Bus Error Message Received Interrupt Priority bi t\nbit 7\n1 = High priority\n0 = Low priority\nbit 6\nWAKIP: CAN Bus Activity Wake-up Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 5 ERRIP: CAN Module Error Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 4 When CAN is in Mode 0:\nTXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 1 or 2:\nTXBnIP: CAN Transmit Buffer Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nTXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1)\n1 = High priority\n0 = Low priority",
    "bit 2\nTXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1)\n1 = High priority\n0 = Low priority",
    "bit 1 When CAN is in Mode 0:\nRXB1IP: CAN Receive Buffer 1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 1 or 2:\nRXBnIP: CAN Receive Buffer Interrupts Priority bit\n1 = High priority\n0 = Low priority\nNote 1: In CAN Mode 1 and 2, these bits are forced to ' 0 '.",
    "REGISTER 34-58: IPR5: PERIPHERAL INTERRUPT PRIORITY REGISTER 5 (CONTINUED)\nbit 0 When CAN is in Mode 0:\nRXB0IP: CAN Receive Buffer 0 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 1:\nUnimplemented: Read as ' 0 '\nWhen CAN is in Mode 2:\nFIFOWMIP: FIFO Watermark Interrupt Priority bit\n1 = High priority\n0 = Low priority\nNote 1: In CAN Mode 1 and 2, these bits are forced to ' 0 '.",
    "REGISTER 34-59: TXBIE: TRANSMIT BUFFERS INTERRUPT ENABLE REGISTER (1)\n-, U-0 = -. -, U-0 = -. -, R/W-0 = TXB2IE (2). -, R/W-0 = TXB1IE (2). -, R/W-0 = TXB0IE (2). -, U-0 = -. -, U-0 = -. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0",
    "REGISTER 34-59: TXBIE: TRANSMIT BUFFERS INTERRUPT ENABLE REGISTER (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-5 Unimplemented: Read as ' 0 '\nbit 4-2\nTXB2IE:TXB0IE: Transmit Buffer 2-0 Interrupt Enable bits (2)\n1 = Transmit buffer interrupt is enabled\n0 = Transmit buffer interrupt is disabled\nbit 1-0 Unimplemented: Read as ' 0 '\nNote 1: This register is available in Mode 1 and 2 only.\n2: TXBnIE in PIE5 register must be set to get an interrupt.",
    "REGISTER 34-60: BIE0: BUFFER INTERRUPT ENABLE REGISTER 0 (1)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. B5IE (2), 1 = B4IE (2). B5IE (2), 2 = B3IE (2). B5IE (2), 3 = B2IE (2). B5IE (2), 4 = B1IE (2). B5IE (2), 5 = B0IE (2). B5IE (2), 6 = RXB1IE (2). B5IE (2), 7 = RXB0IE (2). bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit",
    "REGISTER 34-60: BIE0: BUFFER INTERRUPT ENABLE REGISTER 0 (1)\n7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-2\nB<5:0>IE: Programmable Transmit/Receive Buffer 5-0 Interrupt Enable bits (2)\n1 = Interrupt is enabled\n0 = Interrupt is disabled\nbit 1-0\nRXB<1:0>IE: Dedicated Receive Buffer 1-0 Interrupt Enable bits (2)\n1 = Interrupt is enabled\n0 = Interrupt is disabled",
    "REGISTER 34-60: BIE0: BUFFER INTERRUPT ENABLE REGISTER 0 (1)\nNote 1: This register is available in Mode 1 and 2 only.\n2: Either TXBnIE or RXBnIE, in the PIE5 register, must be set to get an interrupt.",
    "35.0 FIXED VOLTAGE REFERENCE (FVR)\nThe  Fixed  Voltage  Reference,  or  FVR,  is  a  stable voltage  reference,  independent  of  VDD,  with  1.024V, 2.048V or 4.096V selectable output levels. The output of  the  FVR  can  be  configured  to  supply  a  reference voltage to the following:\n\u00b7 ADC input channel\n\u00b7 ADC positive reference\n\u00b7 Comparator input\n\u00b7 Digital-to-Analog Converter (DAC)\nThe FVR can be enabled by setting the EN bit of the FVRCON register.\nNote:, 1 = Fixed Voltage Reference output cannot exceed VDD.",
    "35.1 Independent Gain Amplifiers\nThe output of the FVR, which is connected to the ADC, Comparators, and DAC, is routed through two independent programmable gain amplifiers. Each amplifier can be programmed for a gain of 1x, 2x or 4x, to produce the three possible voltage levels.",
    "FIGURE 35-1: VOLTAGE REFERENCE BLOCK DIAGRAM\nThe ADFVR<1:0>  bits  of  the  FVRCON  register  are used to enable and configure the gain amplifier settings for the reference supplied to the  ADC module. Reference Section 37.0 'Analog-to-Digital Con -verter with Computation (ADC2) Module' for addi -tional information.\nThe CDAFVR<1:0> bits of the FVRCON register are used to enable and configure the gain amplifier settings for the reference supplied to the DAC and comparator module.  Reference Section  38.0 '5-Bit  Digital-toAnalog  Converter  (DAC)  Module' and Section 39.0 'Comparator Module' for additional information.",
    "35.2 FVR Stabilization Period\nWhen the Fixed Voltage Reference module is enabled, it requires time for the reference and amplifier circuits to stabilize. Once the circuits stabilize and are ready for use, the RDY bit of the FVRCON register will be set.",
    "REGISTER 35-1: FVRCON: FIXED VOLTAGE REFERENCE CONTROL REGISTER\nEN, R-q/q = RDY. EN, R/W-0/0 = TSEN (2). EN, R/W-0/0 = TSRNG (2). EN, R/W-0/0 = CDAFVR<1:0>. EN, R/W-0/0 = CDAFVR<1:0>. EN, R/W-0/0 = ADFVR<1:0>. EN, R/W-0/0 = ADFVR<1:0>. bit 7 bit 0, R-q/q = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit",
    "REGISTER 35-1: FVRCON: FIXED VOLTAGE REFERENCE CONTROL REGISTER\n0\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = q = Value depends on condition\nbit 7\nEN: Fixed Voltage Reference Enable bit\n1 = Fixed Voltage Reference is enabled\n0 = Fixed Voltage Reference is disabled\nbit 6\nRDY: Fixed Voltage Reference Ready Flag bit\n1 = Fixed Voltage Reference output is ready for use\n0 = Fixed Voltage Reference output is not ready or not enabled\nbit 5\nTSEN: Temperature Indicator Enable bit (2)\n1 = Temperature Indicator is enabled\n0 = Temperature Indicator is disabled\nbit 4\nTSRNG: Temperature Indicator Range Selection bit (2)\n1 = VOUT = 3VT (High Range)\n0 = VOUT = 2VT (Low Range)",
    "bit 3-2 CDAFVR<1:0>: Comparator FVR Buffer Gain Selection bits\n11 = FVR Buffer 2 Gain is 4x, (4.096V) (1)\n10 = FVR Buffer 2 Gain is 2x, (2.048V) (1)\n01 = FVR Buffer 2 Gain is 1x, (1.024V)\n00 = FVR Buffer 2 is off",
    "bit 1-0\nADFVR<1:0>: ADC FVR Buffer Gain Selection bit\n11 = FVR Buffer 1 Gain is 4x, (4.096V) (1)\n10 = FVR Buffer 1 Gain is 2x, (2.048V) (1)\n01 = FVR Buffer 1 Gain is 1x, (1.024V)\n00 = FVR Buffer 1 is off\nNote 1: Fixed Voltage Reference output cannot exceed VDD.\n2: See Section 36.0 'Temperature Indicator Module' for additional information.",
    "TABLE 35-1: SUMMARY OF REGISTERS ASSOCIATED WITH FIXED VOLTAGE REFERENCE\nFVRCON, Bit 7 = EN. FVRCON, Bit 6 = RDY. FVRCON, Bit 5 = TSEN. FVRCON, Bit 4 = TSRNG. FVRCON, Bit 3 = CDAFVR<1:0>. FVRCON, Bit 2 = CDAFVR<1:0>. FVRCON, Bit 1 = ADFVR<1:0>. FVRCON, Bit 0 = ADFVR<1:0>. FVRCON, Register on page = 651\nLegend: - = Unimplemented location, read as ' 0 '. Shaded cells are not used with the Fixed Voltage Reference.",
    "36.0 TEMPERATURE INDICATOR MODULE\nThis family of devices is equipped with a temperature circuit designed to measure the operating temperature of the silicon die.\nThe  circuit's range  of  operating  temperature  falls between  -40\u00b0C  and  +125\u00b0C. A  one-point  calibration allows  the  circuit  to  indicate  a  temperature  closely surrounding  that  point. A  two-point  calibration  allows the  circuit  to  sense  the  entire  range  of  temperature more accurately.",
    "36.1 Module Operation\nThe temperature indicator module consists of a temperature-sensing circuit  that  provides  a  voltage  to the  device ADC.  The  analog  voltage  output,  VMEAS, varies inversely to the device temperature. The output of the temperature indicator is referred to as VMEAS.\nFigure 36-1  shows  a  simplified  block  diagram  of  the temperature indicator module.",
    "TEMPERATURE INDICATOR MODULE BLOCK DIAGRAM\nThe output of the circuit is measured using the internal Analog-to-Digital  Converter. A  channel  is  reserved  for the temperature circuit output. Refer to Section 37.0 'Analog-to-Digital Converter with Computation (ADC2) Module' for detailed information.\nThe  ON/OFF  bit  for  the  module  is  located  in  the FVRCON register. See Section 35.0 'Fixed Voltage Reference (FVR)' for more information. The circuit is enabled  by  setting  the  TSEN  bit  of  the  FVRCON register. When the module is disabled, the circuit draws no current.\nThe circuit operates in either High or Low range. Refer to Section 36.1.2 'Temperature Indicator Range' for more details on the range settings.",
    "36.1.1 MINIMUM OPERATING VDD\nWhen the temperature circuit is operated in low range, the device may be operated at any operating voltage that  is  within  specifications.  When  the  temperature circuit is operated in high range, the device operating voltage, VDD, must be high enough to ensure that the temperature circuit is correctly biased.\nTable 36-1 shows the recommended minimum VDD vs. Range setting.\nTABLE 36-1: RECOMMENDED VDD vs. RANGE\n\n\uf0b3 2.5, Min. VDD, TSRNG = 0 (Low Range) = \uf0b3 1.8",
    "36.1.2 TEMPERATURE INDICATOR RANGE\nThe temperature indicator circuit operates in either high or low range. The high range, selected by setting the TSRNG bit of the FVRCON register, provides a wider output voltage. This provides more resolution over the temperature range. High range requires a higher-bias voltage to operate and thus, a higher VDD is needed. The low range is selected by clearing the TSRNG bit of the FVRCON register. The low range generates a lower sensor voltage and thus, a lower VDD voltage is needed to operate the circuit.\nThe output voltage of the sensor is the highest value at -40\u00b0C and the lowest value at +125\u00b0C.\n\u00b7 High Range: The High range is used in applica -tions with the reference for the ADC, VREF = 2.048V.  This  range  may  not  be  suitable  for battery-powered applications.\n\u00b7 Low Range: This mode is useful in applications in which the VDD is too low for high-range operation. The VDD in this mode can be as low as 1.8V. VDD must, however, be at least 0.5V higher than the maximum sensor voltage, depending on the expected low operating temperature.",
    "36.2 Temperature Calculation\nThis section describes the steps involved in estimating the die temperature, TMEAS:\n1. Obtain  the ADC  count  value  of  the  measured analog  voltage:  The  analog  output  voltage, VMEAS is converted to a digital count value by the  Analog-to-Digital  Converter  (ADC)  and  is referred to as ADCMEAS.\n2. Obtain  the  ADC  count  value,  ADCDIA  at  90 degrees, from the DIA table. This parameter is TSLR2 for the low range setting or TSHR2 for the high range setting of the temperature indicator module.\n3. Obtain the output analog voltage (in mV) value of  the  Fixed  Reference  Voltage  (FVR)  for  2x setting,  from  the  DIA Table. This  parameter  is FVRA2X in the DIA table (Table 5-3).\n4. Obtain  the  value  of  the  temperature  indicator voltage sensitivity, parameter Mv, from Table 4525 for the corresponding range setting.\nEquation 36-1 provides an estimate for the die temperature based on the above parameters.",
    "EQUATION 36-1: SENSOR TEMPERATURE\n<!-- formula-not-decoded -->\nWhere:\nADCMEAS = ADC reading at temperature being estimated\nADCDIA = ADC reading stored in the DIA\nFVRA2X = FVR value stored in the DIA for 2x setting N = Resolution of the ADC\nMv = Temperature Indicator voltage sensitivity (mV/\u00b0C)\nNote:\nIt is recommended to take the average of ten measurements of ADCMEAS to reduce noise and improve accuracy.",
    "TABLE 36-2: SUMMARY OF REGISTERS ASSOCIATED WITH THE TEMPERATURE INDICATOR\nFVRCON, Bit 7 = EN. FVRCON, Bit 6 = RDY. FVRCON, Bit 5 = TSEN. FVRCON, Bit 4 = TSRNG. FVRCON, Bit 3 = CDAFVR<1:0>. FVRCON, Bit 2 = CDAFVR<1:0>. FVRCON, Bit 1 = ADFVR<1:0>. FVRCON, Bit 0 = ADFVR<1:0>. FVRCON, Register on page = 651\nLegend:\n- = Unimplemented location, read as ' 0 '. Shaded cells are unused by the temperature indicator module.",
    "36.2.1.1 Higher-Order Calibration\nIf  the  application  requires  more  precise  temperature measurement,  additional  calibrations  steps  will  be necessary. For these applications, two-point or threepoint calibration is recommended.",
    "36.2.2 TEMPERATURE RESOLUTION\nThe  resolution  of  the  ADC  reading,  Ma  (\u00b0C/count), depends  on  both  the  ADC  resolution  N  and  the reference  voltage  used  for  conversion,  as  shown  in Equation 36-1. It is recommended to use the smallest VREF value, such as the ADC FVR1 output voltage for 2x  setting  (FVRA2X)  value  from  the  DIA,  instead  of VDD. Refer to Table 5-3 for DIA location.\nNote:\nRefer  to  Table 45-17  for  FVR  reference voltage accuracy.",
    "36.3 ADC Acquisition Time\nTo  ensure  accurate  temperature  measurements,  the user  must  wait  a  certain  minimum  acquisition  time (Table 45-25) for the ADC value to settle, after the ADC input  multiplexer  is  connected  to  the  temperature indicator output, before the conversion is performed.",
    "37.0 ANALOG-TO-DIGITAL CONVERTER WITH COMPUTATION (ADC 2 ) MODULE\nThe  Analog-to-Digital Converter with Computation (ADC 2 ) allows conversion of an analog input signal to a 12-bit binary representation of that signal. This device uses analog inputs, which are multiplexed into a single sample and hold circuit. The output of the sample and hold  is  connected  to  the  input  of  the  converter.  The converter generates a 12-bit binary result via successive  approximation  and  stores  the  conversion result into the ADC result registers (ADRESH:ADRESL register pair).\nAdditionally, the following features are provided within the ADC module:\n\u00b7 13-bit Acquisition Timer\n\u00b7 Hardware Capacitive Voltage Divider (CVD) support:\n-13-bit Precharge Timer\n-Adjustable sample and hold capacitor array\n-Guard ring digital output drive\n\u00b7 Automatic repeat and sequencing:\n-Automated double sample conversion for CVD\n-Two sets of result registers (Result and Previous result)\n-Auto-conversion trigger\n-Internal retrigger\n\u00b7 Computation features:\n-Averaging and Low-Pass Filter functions\n-Reference Comparison\n-2-level Threshold Comparison\n-Selectable Interrupts\nFigure 37-1 shows the block diagram of the ADC.",
    "37.0 ANALOG-TO-DIGITAL CONVERTER WITH COMPUTATION (ADC 2 ) MODULE\nThe ADC voltage reference is software selectable to be either internally generated or externally supplied.\nThe ADC can generate an interrupt upon completion of a conversion and upon threshold comparison. These interrupts  can  be  used  to  wake  up  the  device  from Sleep.",
    "PIC18(L)F25/26K83\nFIGURE 37-1:\nADC 2  BLOCK DIAGRAM",
    "37.1 ADC Configuration\nWhen  configuring  and  using  the  ADC  the  following functions must be considered:\n\u00b7 Port configuration\n\u00b7 Channel selection\n\u00b7 ADC voltage reference selection\n\u00b7 ADC conversion clock source\n\u00b7 Interrupt control\n\u00b7 Result formatting\n\u00b7 Conversion Trigger Selection\n\u00b7 ADC Acquisition Time\n\u00b7 ADC Precharge Time\n\u00b7 Additional Sample and Hold Capacitor\n\u00b7 Single/Double Sample Conversion\n\u00b7 Guard Ring Outputs",
    "37.1.1 PORT CONFIGURATION\nThe ADC  can  be  used  to  convert  both  analog  and digital signals. When converting analog signals, the I/O pin  should  be  configured  for  analog  by  setting  the associated  TRIS  and ANSEL  bits.  Refer  to Section 16.0 'I/O Ports' for more information.\nNote:\nAnalog voltages on any pin that is defined as  a  digital  input  may  cause  the  input buffer to conduct excess current.",
    "37.1.2 CHANNEL SELECTION\nThere are several channel selections available:\n\u00b7 Eight PORTA pins (RA<7:0>)\n\u00b7 Eight PORTB pins (RB<7:0>)\n\u00b7 Eight PORTC pins (RC<7:0>)\n\u00b7 Temperature Indicator\n\u00b7 DAC output\n\u00b7 Fixed Voltage Reference (FVR)\n\u00b7 VSS (ground)\nThe  ADPCH  register  determines  which  channel  is connected to the sample and hold circuit.\nWhen changing channels, a delay is required before starting the next conversion.\nRefer  to Section  37.2 'ADC  Operation' for  more information.",
    "37.1.3 ADC VOLTAGE REFERENCE\nThe ADPREF<1:0> bits of the ADREF register provide control of the positive voltage reference. The positive voltage reference can be:\n\u00b7 VREF+ pin\n\u00b7 VDD\n\u00b7 FVR outputs\nThe  ADNREF  bit  of  the  ADREF  register  provides control of the negative voltage reference. The negative voltage reference can be:\n\u00b7 VREF- pin\n\u00b7 VSS\nSee Section 35.0 'Fixed Voltage Reference (FVR)'\nfor more details on the Fixed Voltage Reference.",
    "37.1.4 CONVERSION CLOCK\nThe  source of the conversion clock is software selectable via the ADCLK register and the CS bits of the ADCON0 register. If FOSC is selected as the ADC clock, there is a prescaler available to divide the clock so that it meets the ADC clock period specification. The ADC clock source options are the following:\n\u00b7 FOSC/(2*n)(where n is from 1 to 128)\n\u00b7 FRC (dedicated RC oscillator)\nThe time to complete one bit conversion is defined as TAD. Refer Figure 37-2 for the complete timing details of the ADC conversion.\nFor correct conversion, the appropriate TAD specification must be met. Refer to Table 45-14 for more information. Table 37-1  gives  examples  of  appropriate ADC  clock selections.",
    "37.1.4 CONVERSION CLOCK\nNote 1: Unless using the FRC, any changes in the system clock frequency will  change the ADC clock frequency, which may adversely affect the ADC result.\n2: The internal control logic of the ADC runs off of the clock selected by the CS bit of ADCON0. What this can mean is when the CS bit of ADCON0 is set to ' 1 ' (ADC runs on FRC), there may be unexpected delays  in  operation  when  setting  ADC control bits.",
    "TABLE 37-1: ADC CLOCK PERIOD (TAD) VS. DEVICE OPERATING FREQUENCIES (1,4)\nFOSC/2, ADC Clock Period (T AD).CS<5:0> = 000000. FOSC/2, Device Frequency (F OSC).64 MHz = 31.25 ns (2). FOSC/2, Device Frequency (F OSC).32 MHz = 62.5 ns (2). FOSC/2, Device Frequency (F OSC).20 MHz = 100 ns (2). FOSC/2, Device Frequency (F OSC).16 MHz = 125 ns (2). FOSC/2, Device Frequency (F OSC).8 MHz = 250 ns (2). FOSC/2, Device Frequency (F OSC).4 MHz = 500 ns. FOSC/2, Device Frequency (F OSC).1 MHz = 2.0 \uf06d s. FOSC/4, ADC Clock Period (T AD).CS<5:0> = 000001. FOSC/4, Device Frequency (F OSC).64 MHz = 62.5 ns",
    "TABLE 37-1: ADC CLOCK PERIOD (TAD) VS. DEVICE OPERATING FREQUENCIES (1,4)\n(2). FOSC/4, Device Frequency (F OSC).32 MHz = 125 ns (2). FOSC/4, Device Frequency (F OSC).20 MHz = 200 ns (2). FOSC/4, Device Frequency (F OSC).16 MHz = 250 ns (2). FOSC/4, Device Frequency (F OSC).8 MHz = 500 ns. FOSC/4, Device Frequency (F OSC).4 MHz = 1.0 \uf06d s. FOSC/4, Device Frequency (F OSC).1 MHz = 4.0 \uf06d s. FOSC/6, ADC Clock Period (T AD).CS<5:0> = 000010. FOSC/6, Device Frequency (F OSC).64 MHz = 125 ns (2). FOSC/6, Device Frequency (F OSC).32 MHz = 187.5 ns (2). FOSC/6, Device Frequency (F OSC).20 MHz = 300 ns (2).",
    "TABLE 37-1: ADC CLOCK PERIOD (TAD) VS. DEVICE OPERATING FREQUENCIES (1,4)\nFOSC/6, Device Frequency (F OSC).16 MHz = 375 ns (2). FOSC/6, Device Frequency (F OSC).8 MHz = 750 ns. FOSC/6, Device Frequency (F OSC).4 MHz = 1.5 \uf06d s. FOSC/6, Device Frequency (F OSC).1 MHz = 6.0 \uf06d s. FOSC/8, ADC Clock Period (T AD).CS<5:0> = 000011. FOSC/8, Device Frequency (F OSC).64 MHz = 187.5 ns (2). FOSC/8, Device Frequency (F OSC).32 MHz = 250 ns (2). FOSC/8, Device Frequency (F OSC).20 MHz = 400 ns (2). FOSC/8, Device Frequency (F OSC).16 MHz = 500 ns. FOSC/8, Device Frequency (F OSC).8 MHz = 1.0 \uf06d s. FOSC/8, Device Frequency",
    "TABLE 37-1: ADC CLOCK PERIOD (TAD) VS. DEVICE OPERATING FREQUENCIES (1,4)\n(F OSC).4 MHz = 2.0 \uf06d s. FOSC/8, Device Frequency (F OSC).1 MHz = 8.0 \uf06d s. ..., ADC Clock Period (T AD).CS<5:0> = .... ..., Device Frequency (F OSC).64 MHz = .... ..., Device Frequency (F OSC).32 MHz = .... ..., Device Frequency (F OSC).20 MHz = .... ..., Device Frequency (F OSC).16 MHz = .... ..., Device Frequency (F OSC).8 MHz = .... ..., Device Frequency (F OSC).4 MHz = .... ..., Device Frequency (F OSC).1 MHz = .... FOSC/16, ADC Clock Period (T AD).CS<5:0> = 000111. FOSC/16, Device Frequency (F OSC).64",
    "TABLE 37-1: ADC CLOCK PERIOD (TAD) VS. DEVICE OPERATING FREQUENCIES (1,4)\nMHz = 250 ns (2). FOSC/16, Device Frequency (F OSC).32 MHz = 500 ns. FOSC/16, Device Frequency (F OSC).20 MHz = 800 ns. FOSC/16, Device Frequency (F OSC).16 MHz = 1.0 \uf06d s. FOSC/16, Device Frequency (F OSC).8 MHz = 2.0 \uf06d s. FOSC/16, Device Frequency (F OSC).4 MHz = 4.0 \uf06d s. FOSC/16, Device Frequency (F OSC).1 MHz = 16.0 \uf06d s (3). ..., ADC Clock Period (T AD).CS<5:0> = .... ..., Device Frequency (F OSC).64 MHz = .... ..., Device Frequency (F OSC).32 MHz = .... ..., Device Frequency (F OSC).20 MHz = .... ..., Device Frequency (F OSC).16 MHz",
    "TABLE 37-1: ADC CLOCK PERIOD (TAD) VS. DEVICE OPERATING FREQUENCIES (1,4)\n= .... ..., Device Frequency (F OSC).8 MHz = .... ..., Device Frequency (F OSC).4 MHz = .... ..., Device Frequency (F OSC).1 MHz = .... FOSC/128, ADC Clock Period (T AD).CS<5:0> = 111111. FOSC/128, Device Frequency (F OSC).64 MHz = 2.0 \uf06d s. FOSC/128, Device Frequency (F OSC).32 MHz = 4.0 \uf06d s. FOSC/128, Device Frequency (F OSC).20 MHz = 6.4 \uf06d s. FOSC/128, Device Frequency (F OSC).16 MHz = 8.0 \uf06d s. FOSC/128, Device Frequency (F OSC).8 MHz = 16.0 \uf06d s (3). FOSC/128, Device Frequency (F OSC).4 MHz = 32.0 \uf06d s (2). FOSC/128, Device Frequency",
    "TABLE 37-1: ADC CLOCK PERIOD (TAD) VS. DEVICE OPERATING FREQUENCIES (1,4)\n(F OSC).1 MHz = 128.0 \uf06d s (2). FRC, ADC Clock Period (T AD).CS<5:0> = CS(ADCON0<4>) = 1. FRC, Device Frequency (F OSC).64 MHz = 1.0-6.0 \uf06d s. FRC, Device Frequency (F OSC).32 MHz = 1.0-6.0 \uf06d s. FRC, Device Frequency (F OSC).20 MHz = 1.0-6.0 \uf06d s. FRC, Device Frequency (F OSC).16 MHz = 1.0-6.0 \uf06d s. FRC, Device Frequency (F OSC).8 MHz = 1.0-6.0 \uf06d s. FRC, Device Frequency (F OSC).4 MHz = 1.0-6.0 \uf06d s. FRC, Device Frequency (F OSC).1 MHz = 1.0-6.0 \uf06d s\nLegend:\nShaded cells are outside of recommended range.\nNote",
    "TABLE 37-1: ADC CLOCK PERIOD (TAD) VS. DEVICE OPERATING FREQUENCIES (1,4)\n1: See TAD parameter for FRC source typical TAD value.\n2: These values violate the required TAD time.\n3: Outside the recommended TAD time.\n4: The ADC clock period (TAD) and total ADC conversion time can be minimized when the ADC clock is derived from the system clock FOSC. However, the FRC oscillator source must be used when conversions are to be performed with the device in Sleep mode.",
    "37.1.5 INTERRUPTS\nThe ADC module allows for the ability to generate an interrupt upon completion of an  Analog-to-Digital conversion. The ADC Interrupt Flag is the ADIF bit in the  PIR1  register.  The ADC  Interrupt  Enable  is  the ADIE  bit  in  the  PIE1  register.  The ADIF  bit  must  be cleared in software.\nNote 1: The ADIF bit is set at the completion of every conversion, regardless of whether or not the ADC interrupt is enabled.\n2: The  ADC  operates  during  Sleep  only when the FRC oscillator is selected.\nThis  interrupt  can  be  generated  while  the  device  is operating or while in Sleep. If the device is in Sleep, the interrupt  will  wake  up  the  device.  Upon  waking  from Sleep, the next instruction following the SLEEP instruction is always executed. If the user is attempting to wake  up  from  Sleep  and  resume  in-line  code execution, the ADIE bit of the PIEx register and the GIE bits  of  the  INTCON0 register must both be set. If all these  bits  are  set,  the  execution  will  switch  to  the Interrupt Service Routine.",
    "FIGURE 37-3: 12-BIT ADC CONVERSION RESULT FORMAT\nADRESH\nADRESL\n(FM = 0 )\nMSB\nbit 7\nbit 0\nbit 7\nLSB\nbit 0\n12-bit ADC Result\nUnimplemented:\nRead as ' 0 '\n(FM = 1 )\nMSB\nLSB\nbit 7\nbit 0\nbit 7\nbit 0\nUnimplemented: Read as ' 0 '\n12-bit ADC Result",
    "37.1.6 RESULT FORMATTING\nThe 12-bit ADC conversion result can be supplied in two formats, left justified or right justified. The FM bits of the ADCON0 register controls the output format.\nFigure 37-3 shows the two output formats.\nWrites  to  the  ADRES  register  pair  are  always  right justified regardless of the selected format mode. There -fore, data read after writing to ADRES when ADFRM0 = 0 will be shifted left four places.",
    "37.2.1 STARTING A CONVERSION\nTo enable the ADC module, the ON bit of the ADCON0 register  must  be  set  to  a  ' 1 '.  A  conversion  may  be started by any of the following:\n\u00b7 Software setting the GO bit of ADCON0 to ' 1 '\n\u00b7 An external trigger (selected by Register 37-3)\n\u00b7 A continuous-mode retrigger (see section Sec -tion 37.6.8 'Continuous Sampling mode' )\n.\nNote:\nThe GO bit should not be set in the same instruction that turns on the ADC. Refer to Section  37.2.6 'ADC  Conversion  Pro -cedure (Basic Mode)' .",
    "37.2.2 COMPLETION OF A CONVERSION\nWhen any individual conversion is complete, the value already in ADRES is written into PREV (if ADPSIS = 1 ) and  the  new  conversion  results  appear  in  ADRES. When the conversion completes, the ADC module will:\n\u00b7 Clear the GO bit (unless the CONT bit of ADCON0 is set)\n\u00b7 Set the ADIF Interrupt Flag bit\n\u00b7 Set the ADMATH bit\n\u00b7 Update ACC\nWhen ADDSEN = 0 then  after  every  conversion,  or when ADDSEN = 1 then after every other conversion, the following events occur:\n\u00b7 ERR is calculated\n\u00b7 ADTIF is set if ERR calculation meets threshold comparison\nImportantly,  filter  and  threshold  computations  occur after the conversion  itself is complete.  As  such, interrupt  handlers  responding  to  ADIF  should  check ADTIF before reading filter and threshold results.",
    "37.2.3 ADC OPERATION DURING SLEEP\nThe  ADC  module  can  operate  during  Sleep.  This requires  the ADC clock source to be set to the FRC option. When the FRC oscillator source is selected, the ADC waits one additional instruction before starting the conversion.  This  allows  the SLEEP instruction  to  be executed, which can reduce system noise during the conversion. If the ADC interrupt is enabled, the device will wake-up from Sleep when the conversion completes. If  the ADC  interrupt  is  disabled,  the ADC module is  turned  off  after  the  conversion  completes, although the ON bit remains set.",
    "37.2.4 EXTERNAL TRIGGER DURING SLEEP\nIf  the  external  trigger  is  received  during  Sleep  while ADC clock source is set to the FRC, ADC module will perform the conversion and set the ADIF bit upon com -pletion.\nIf  an external trigger is received when the ADC clock source is something other than FRC, the trigger will be recorded,  but  the  conversion  will  not  begin  until  the device exits Sleep.",
    "37.2.5 AUTO-CONVERSION TRIGGER\nThe auto-conversion trigger allows periodic  ADC measurements without software intervention. When a rising edge of the selected source occurs, the GO bit is set by hardware.\nThe auto-conversion trigger source is selected by the ADACT register.\nUsing  the  auto-conversion  trigger  does  not  assure proper ADC  timing.  It  is  the  user's  responsibility  to ensure that the ADC timing requirements are met. See Register 37-33 for auto-conversion sources.",
    "37.2.6 ADC CONVERSION PROCEDURE (BASIC MODE)\nThis  is  an  example  procedure  for  using  the ADC  to perform an analog-to-digital conversion:\n1. Configure Port:\n\u00b7 Disable pin output driver (Refer to the TRISx register)\n\u00b7 Configure pin as analog (Refer to the ANSELx register)\n2. Configure the ADC module:\n\u00b7 Select ADC conversion clock\n\u00b7 Select voltage reference\n\u00b7 Select ADC input channel",
    "EXAMPLE 37-1: ADC CONVERSION\n/*This code block configures the ADC for polling, VDD and VSS references, FRC oscillator and AN0 input. Conversion start & polling for completion are included. */\nvoid main() { //System Initialize initializeSystem();\n//Setup ADC\nADCON0bits.FM = 1; //right justify ADCON0bits.CS = 1; //FRC Clock ADPCH = 0x00; //RA0 is Analog channel TRISAbits.TRISA0 = 1; //Set RA0 to input ANSELAbits.ANSELA0 = 1; //Set RA0 to analog ADCON0bits.ON = 1; //Turn ADC On while (1) {\nADCON0bits.GO = 1; //Start conversion while (ADCON0bits.GO); //Wait for conversion done\nresultHigh = ADRESH; //Read result resultLow = ADRESL; //Read result\n}\n}",
    "EXAMPLE 37-1: ADC CONVERSION\n\u00b7 Precharge and acquisition\n\u00b7 Turn on ADC module\n3. Configure ADC interrupt (optional):\n\u00b7 Clear ADC interrupt flag\n\u00b7 Enable ADC interrupt\n\u00b7 Enable global interrupt (GIEL bit) (1)\n4. If ADACQ = 0 ,  software must wait the required acquisition time (2) .\n5. Start conversion by setting the GO bit.\n6. Wait for ADC conversion to complete by one of the following:\n\u00b7 Polling the GO bit\n\u00b7 Polling the ADIF bit\n\u00b7 Waiting for the ADC interrupt (interrupts enabled)\n7. Read ADC Result.\n8. Clear the ADC interrupt flag (required if interrupt is enabled).\nNote 1: The global interrupt can be disabled if the user is attempting to wake-up from Sleep and resume in-line code execution.\n2: Refer  to Section  37.3 'ADC  Acquisi -tion Requirements' .",
    "37.3 ADC Acquisition Requirements\nFor the ADC to meet its specified accuracy, the charge holding  capacitor  (CHOLD)  must  be  allowed  to  fully charge to the input channel voltage level. The Analog Input  model  is  shown  in  Figure 37-4.  The  source impedance (RS) and the internal sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD.  The  sampling  switch  (RSS) impedance varies over the device voltage (VDD), refer to Figure 37-4. The maximum recommended impedance for analog sources is 10 k \uf057 . If the source impedance is decreased, the acquisition time may be decreased. After the analog input channel is selected (or changed), an ADC acquisition must be completed before the conversion can be started. To calculate the minimum acquisition time, Equation 37-1 may be used. This  equation  assumes  that  1/2  LSb  error  is  used (4,096  steps  for  the ADC). The  1/2  LSb  error  is  the maximum  error  allowed  for  the  ADC  to  meet  its specified resolution.",
    "EQUATION 37-1: ACQUISITION TIME EXAMPLE\nTemperat ure = 5 0 \u00b0 C  nd x t e r na li a e mpedance  of   10k \uf057 5. 0V  VD D Assumptions:\nTACQ Ampl i f i e r   e tln g  i S ti T me + Hol d  Capac i t or   har gi ng  i m e+ Temper at ur e   Coe f f i c i n t C T e =\n= TAM P + TC + TCOFF\n= 2\u00b5s+ TC + Temper at ur e   -   5\u00b0 C 2 \uf028 \uf029\uf028 0. 05\u00b5s / \u00b0 C \uf029\uf05d \uf05b\nThe value for TC can be approximated with the following equations:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n;[2] VCHOLD charge response to VAPPLIED\n<!-- formula-not-decoded -->\nNote: Where n = number of bits of the ADC.\nSolving for TC:\n<!-- formula-not-decoded -->\n- 4. 54\u00b5s =\nTherefore:\n<!-- formula-not-decoded -->",
    "EQUATION 37-1: ACQUISITION TIME EXAMPLE\nNote 1: The reference voltage (VREF) has no effect on the equation, since it cancels itself out.\n2: The charge holding capacitor (CHOLD) is not discharged after each conversion.\n3: The maximum recommended impedance for analog sources is 10 k \uf057 . This is required to meet the pin leakage specification.",
    "37.4 ADC Charge Pump\nThe ADC module has a dedicated charge pump which can be controlled through the ADCP register (Register 37-36). The  primary  purpose  of  the  charge pump is to supply a constant voltage to the gates of transistor devices in the A/D converter, signal and ref -erence  input  pass-gates,  to  prevent  degradation  of transistor performance at low operating voltage.",
    "37.5 Capacitive Voltage Divider (CVD) Features\nThe charge pump can be enabled by setting the CPON bit  in  the ADC  register.  Once  enabled,  the  pump  will undergo a start-up time to stabilize the charge pump output. Once the output stabilizes and is ready for use, the CPRDY bit of the ADCP register will be set.\nThe ADC module contains several features that allow the user to perform a relative capacitance measurement on any ADC channel using the internal ADC sample and hold capacitance as a reference. This relative  capacitance  measurement  can  be  used  to implement capacitive touch or proximity sensing applications. Figure 37-6 shows the basic block diagram of the CVD portion of the ADC module.",
    "37.5.1 CVD OPERATION\nA  CVD  operation  begins  with  the  ADC's  internal sample and hold capacitor (C HOLD ) being disconnected  from  the  path  which  connects  it  to  the external capacitive sensor node. While disconnected, CHOLD  is precharged to VDD or VSS, while the path to the sensor node is precharged to the level opposite that of CHOLD. When the precharge phase is complete, the VDD/VSS precharge paths for the two nodes are shut off and CHOLD and the path to the external sensor node are reconnected, at which time the acquisition phase of the CVD  operation begins. During acquisition, a capacitive voltage divider is formed  between  the precharged CHOLD and sensor nodes, which results in a final voltage level setting on  CHOLD , which  is determined by the capacitances and precharge levels of the two nodes. After acquisition, the ADC converts the  voltage  level  on  CHOLD.  This  process  is  then repeated  with  inverted  precharge  levels  for  both  the CHOLD and external sensor nodes. Figure 37-7 shows the  waveform  for  two  inverted  CVD  measurements, which is known as differential CVD measurement.",
    "37.5.1 CVD OPERATION\nFIGURE 37-7: DIFFERENTIAL CVD MEASUREMENT WAVEFORM",
    "37.5.2 PRECHARGE CONTROL\nThe precharge stage is an optional period of time that brings  the  external  channel  and  internal  sample  and hold  capacitor  to  known  voltage levels. Precharge  is enabled  by  writing  a  non-zero  value  to  the  PRE register. This stage is initiated when an ADC conversion  begins,  either  from  setting  the  GO  bit,  a special event trigger, or a conversion restart from the computation functionality. If the PRE register is cleared when an ADC conversion begins, this stage is skipped.\nDuring the precharge time, CHOLD is disconnected from the outer portion of the sample path that leads to the external capacitive sensor and is connected to either VDD or VSS, depending on the value of the ADPPOL bit of ADCON1. At the same time, the port pin logic of the selected analog channel is overridden to drive a digital high or low out, in order to precharge the outer portion of the ADC's sample path, which includes the external sensor. The output polarity of this override is also deter -mined by the ADPPOL bit of ADCON1. The amount of time  that  this  charging  receives  is  controlled  by  the PRE register.",
    "37.5.2 PRECHARGE CONTROL\nNote 1: The external charging overrides the TRIS setting of the respective I/O pin.\n2: If  there  is  a  device  attached to this pin, Precharge should not be used.",
    "37.5.3 ACQUISITION CONTROL\nThe Acquisition stage is an optional time for the voltage on the internal sample and hold capacitor to charge or discharge from the selected analog channel.This acquisition time is controlled by the ADACQ register. If PRE = 0 , acquisition starts at the beginning of conversion. When  PRE = 1 , the acquisition stage begins when precharge ends.\nAt the start of the acquisition stage, the port pin logic of the selected analog channel is overridden to turn off the digital high/low output drivers so they do not affect the final result of the charge averaging. Also, the selected ADC  channel  is  connected  to  CHOLD.  This  allows charge averaging to proceed between the precharged channel and the CHOLD capacitor.\nNote:\nWhen PRE! = 0 ,  acquisition time cannot be ' 0 '. In this case, setting ADACQ to ' 0 ' will set a maximum acquisition time (8191 ADC  clock  cycles).  When  precharge  is disabled, setting ADACQ to ' 0 ' will disable hardware acquisition time control.",
    "37.5.4 GUARD RING OUTPUTS\nFigure 37-8 shows a typical guard ring circuit. CGUARD represents  the  capacitance  of  the  guard  ring  trace placed on the PCB board. The user selects values for RA and RB that will create a voltage profile on CGUARD, which will match the selected acquisition channel.\nThe purpose of the guard ring is to generate a signal in phase  with  the  CVD  sensing  signal  to  minimize  the effects  of  the  parasitic  capacitance  on  sensing  elec -trodes. It also can be used as a mutual drive for mutual capacitive sensing. For more information about active guard and mutual drive, see Application Note AN1478, ' mTouch TM Sensing  Solution Acquisition Methods Capacitive Voltage Divider' (DS01478).\nThe ADC has two guard ring drive outputs, ADGRDA and ADGRDB. These outputs can be routed through PPS controls to I/O pins (see Section 17.0 'Peripheral Pin Select (PPS) Module' for details) and the polarity of these outputs are controlled by the ADGPOL and ADIPEN bits of ADCON1.",
    "37.5.4 GUARD RING OUTPUTS\nAt the start of the first precharge stage, both outputs are set to match the ADGPOL bit of ADCON1. Once the acquisition stage begins,  ADGRDA changes polarity,  while  ADGRDB  remains  unchanged.  When performing  a  double  sample  conversion,  setting  the ADIPEN  bit  of  ADCON1  causes  both  guard  ring outputs to transition to the opposite polarity of ADGPOL at the start of the second precharge stage, and ADGRDA toggles again for the second acquisition. For more information on the timing of the guard ring output, refer to Figure 37-8 and Figure 37-9.\nFIGURE 37-8: GUARD RING CIRCUIT",
    "37.5.5 ADDITIONAL SAMPLE AND HOLD CAPACITANCE\nAdditional capacitance can be added in parallel with the internal sample and hold capacitor (CHOLD) by using the ADCAP  register.  This  register  selects  a  digitally programmable capacitance which is added to the ADC conversion bus, increasing the effective internal capac -itance  of  the  sample  and  hold  capacitor  in  the ADC module. This is used to  improve the  match between internal and external capacitance for a better sensing performance.  The  additional  capacitance  does  not affect analog performance of the ADC because it is not connected during conversion. See Figure 37-10.",
    "37.6 Computation Operation\nThe  ADC  module  hardware  is  equipped  with  post conversion computation features. These features provide  data  post-processing  functions  that  can  be operated  on  the  ADC  conversion  result,  including digital filtering/averaging  and  threshold  comparison functions.",
    "FIGURE 37-10: COMPUTATIONAL FEATURES SIMPLIFIED BLOCK DIAGRAM\nThe  operation  of  the ADC  computational  features  is controlled by ADMD <2:0> bits in the ADCON2 register.\nThe module can be operated in one of five modes:\n\u00b7 Basic : In this mode, ADC conversion occurs on single (ADDSEN = 0 ) or double (ADDSEN = 1 ) samples. ADIF is set after all the conversion are complete.\n\u00b7 Accumulate : With each trigger, the ADC conversion result  is  added  to  accumulator  and  CNT  increments. ADIF is set after each conversion. ADTIF is set accord -ing to the calculation mode.\n\u00b7 Average : With  each  trigger,  the  ADC  conversion result  is  added  to  the  accumulator.  When  the  RPT number of samples have been accumulated, a threshold test is performed. Upon the next trigger, the accumulator  is  cleared.  For  the  subsequent  tests, additional RPT samples are required to be accumulated.\n\u00b7 Burst  Average :  At  the  trigger,  the  accumulator  is cleared. The ADC conversion results are then collected repetitively  until  RPT  samples  are  accumulated  and finally the threshold is tested.",
    "FIGURE 37-10: COMPUTATIONAL FEATURES SIMPLIFIED BLOCK DIAGRAM\n\u00b7 Low-Pass Filter (LPF) :  With each trigger, the ADC conversion  result  is  sent  through  a  filter.  When  RPT samples have occurred, a threshold test is performed. Every  trigger  after  that  the ADC  conversion  result  is sent  through  the  filter  and  another  threshold  test  is performed.\nThe five modes are summarized in Table 37-2 below.\nDS40001943C-page 668",
    "TABLE 37-2:\nCOMPUTATION MODES",
    "TABLE 37-2:\nBasic, ADMD = 0. Basic, Bit Clear Conditions.ACC and CNT = ADACLR = 1. Basic, Value after Trigger completion.ACC = Unchanged. Basic, Value after Trigger completion.CNT = Unchanged. Basic, Threshold Operations.Retrigger = No. Basic, Threshold Operations.Threshold Test = Every Sam - ple. Basic, Threshold Operations.Interrupt = If threshold=true. Basic, Value at ADTIF interrupt.ADAOV = N/A. Basic, Value at ADTIF interrupt.FLTR = N/A. Basic, Value at ADTIF interrupt.CNT = count. Accumulate, ADMD = 1. Accumulate, Bit Clear Conditions.ACC and CNT = ADACLR = 1. Accumulate, Value after Trigger completion.ACC = S + ACC or (S2-S1) + ACC. Accumulate, Value after Trigger completion.CNT = If (CNT=0xFF): CNT, oth - erwise: CNT+1. Accumulate, Threshold Operations.Retrigger = No. Accumulate, Threshold Operations.Threshold Test = Every Sam - ple. Accumulate, Threshold Operations.Interrupt = If threshold=true. Accumulate, Value",
    "TABLE 37-2:\nat ADTIF interrupt.ADAOV = ACC Overflow. Accumulate, Value at ADTIF interrupt.FLTR = ACC/2 ADCRS. Accumulate, Value at ADTIF interrupt.CNT = count. Average, ADMD = 2. Average, Bit Clear Conditions.ACC and CNT = ADACLR = 1 or CNT>=RPT at GO or retrigger. Average, Value after Trigger completion.ACC = S + ACC or (S2-S1) + ACC. Average, Value after Trigger completion.CNT = If (CNT=0xFF): CNT, oth - erwise: CNT+1. Average, Threshold Operations.Retrigger = No. Average, Threshold Operations.Threshold Test = If CNT>=RPT. Average, Threshold Operations.Interrupt = If threshold=true. Average, Value at ADTIF interrupt.ADAOV = ACC Overflow. Average, Value at ADTIF interrupt.FLTR = ACC/2 ADCRS. Average, Value at ADTIF interrupt.CNT = count. Burst Average, ADMD = 3. Burst Average, Bit Clear Conditions.ACC and CNT = ADACLR",
    "TABLE 37-2:\n= 1 or GO set or retrigger. Burst Average, Value after Trigger completion.ACC = Each repetition: same as Average End with sum of all samples. Burst Average, Value after Trigger completion.CNT = Each repetition: same as Average End with CNT=RPT. Burst Average, Threshold Operations.Retrigger = Repeat while CNT<RPT. Burst Average, Threshold Operations.Threshold Test = If CNT>=RPT. Burst Average, Threshold Operations.Interrupt = If threshold=true. Burst Average, Value at ADTIF interrupt.ADAOV = ACC Overflow. Burst Average, Value at ADTIF interrupt.FLTR = ACC/2 ADCRS. Burst Average, Value at ADTIF interrupt.CNT = RPT. Low-pass Filter, ADMD = 4. Low-pass Filter, Bit Clear Conditions.ACC and CNT = ADACLR = 1. Low-pass Filter, Value after Trigger completion.ACC = S+ACC-ACC/ 2 ADCRS or (S2-S1)+ACC-ACC/2 ADCRS. Low-pass Filter, Value after Trigger completion.CNT = Count up, stop counting when CNT =",
    "TABLE 37-2:\n0xFF. Low-pass Filter, Threshold Operations.Retrigger = No. Low-pass Filter, Threshold Operations.Threshold Test = If CNT>=RPT. Low-pass Filter, Threshold Operations.Interrupt = If threshold=true. Low-pass Filter, Value at ADTIF interrupt.ADAOV = ACC Overflow. Low-pass Filter, Value at ADTIF interrupt.FLTR = Filtered Value. Low-pass Filter, Value at ADTIF interrupt.CNT = count\nNote:\nS1 and S2 are abbreviations for Sample 1 and Sample 2, respectively. When ADDSEN = 0 , S1 = ADRES; When ADDSEN = 1 , S1 = PREV and S2 = ADRES.",
    "37.6.1 DIGITAL FILTER/AVERAGE\nThe digital filter/average module consists of an accu -mulator with data feedback options, and control logic to determine  when  threshold  tests  need  to  be  applied. The accumulator is a 16-bit wide register which can be accessed through the ADACCH:ADACCL register pair.\nUpon each  trigger  event  (the  GO  bit  set  or  external event trigger), the ADC conversion result is added to the  accumulator.  If  the  accumulated  result  exceeds 2 (accumulator_width) -1  =  18  =  262143,  the  overflow  bit ADAOV in the ADSTAT register is set.\nADCNT  register.  The ADACLR  bit  is  cleared  by  the hardware when accumulator clearing action is complete.\nNote:\nWhen ADC  is  operating  from  FRC,  five FRC clock cycles are required to execute the ACC clearing operation.",
    "37.6.1 DIGITAL FILTER/AVERAGE\nThe number of samples to be accumulated is determined by the RPT (A/D Repeat Setting) register. Each time a sample is added to the accumulator, the ADCNT register is  incremented.  Once  RPT  samples are accumulated (CNT = RPT), an Accumulator Clear command can be issued by the software by setting the ADACLR  bit  in  the  ADCON2  register.  Setting  the ADACLR bit will also clear the ADAOV (Accumulator overflow)  bit  in  the ADSTAT  register,  as  well  as  the",
    "37.6.1 DIGITAL FILTER/AVERAGE\nThe ADCRS <2:0> bits in the ADCON2 register control the data shift on the accumulator result, which effectively divides the value in accumulator (ADACCU:ADACCH:ADACCL)  register  pair.  For  the Accumulate mode of the digital filter, the shift provides a  simple  scaling  operation.  For  the  Average/Burst Average mode, the shift bits are used to determine the number of logical right shifts to be performed on the accumulated result. For the Low-pass Filter mode, the shift is an integral part of the filter, and determines the cut-off frequency of the filter. Table 37-3 shows the -3 dB cut-off frequency in \u03c9 T (radians) and the highest signal  attenuation  obtained  by  this  filter  at  nyquist frequency ( \u03c9 T = \u03c0 ).\n\nTABLE 37-3: LOW-PASS FILTER -3 dB CUT-OFF FREQUENCY",
    "37.6.1 DIGITAL FILTER/AVERAGE\n1, \u03c9 T (radians) @-3 dB Frequency = 0.72. 1, dB @F nyquist =1/(2T) = -9.5. 2, \u03c9 T (radians) @-3 dB Frequency = 0.284. 2, dB @F nyquist =1/(2T) = -16.9. 3, \u03c9 T (radians) @-3 dB Frequency = 0.134. 3, dB @F nyquist =1/(2T) = -23.5. 4, \u03c9 T (radians) @-3 dB Frequency = 0.065. 4, dB @F nyquist =1/(2T) = -29.8. 5, \u03c9 T (radians) @-3 dB Frequency = 0.032. 5, dB @F nyquist =1/(2T) = -36.0. 6, \u03c9 T (radians) @-3 dB Frequency = 0.016. 6, dB @F nyquist =1/(2T) = -42.0. 7, \u03c9 T (radians)",
    "37.6.1 DIGITAL FILTER/AVERAGE\n@-3 dB Frequency = 0.0078. 7, dB @F nyquist =1/(2T) = -48.1",
    "37.6.4 AVERAGE MODE\nBasic  mode  (ADMD = 000 ) disables all additional computation features. In this mode, no accumulation occurs  but  threshold  error  comparison  is  performed. Double  sampling,  Continuous  mode,  and  all  CVD features are still available, but no features involving the digital filter/average features are used.",
    "37.6.3 ACCUMULATE MODE\nIn  Accumulate  mode  (ADMD  = 001 ), after every conversion,  the ADC  result  is  added  to  the ADACC register.  The  ADACC  register  is  right-shifted  by  the value of the ADCRS bits in the ADCON2 register. This right-shifted value is copied in to the ADFLT register. The Formatting mode does not affect the right-justification of the ACC value. Upon each sample, CNT is also incremented, incrementing the number of samples accumulated. After each sample and accumulation, the ACC value has a threshold comparison performed on it (see Section 37.6.7 'Threshold Comparison' ) and the  ADTIF interrupt may trigger.",
    "37.6.3 ACCUMULATE MODE\nIn Average mode (ADMD = 010 ), the ADACC registers accumulate  with each  ADC  sample,  much  as  in Accumulate mode, and the ADCNT register increments with each sample. The ADFLT register is also updated with the right-shifted value of the ADACC register. The value of the ADCRS bits governs the number of right shifts. However, in  Average mode,  the threshold comparison is performed upon CNT being greater than or  equal  to  a  user-defined  RPT  value.  In  this  mode when RPT = 2^CNT, then the final accumulated value will  be  divided  by  number  of  samples,  allowing  for  a threshold comparison operation on the average of all gathered samples.",
    "37.6.5 BURST AVERAGE MODE\nThe Burst Average mode (ADMD = 011 ) acts the same as the Average mode in most respects. The one way it differs is that it continuously retriggers ADC sampling until  the  CNT  value  is  greater  than  or  equal  to  RPT, even  if  Continuous  Sampling  mode  (see Section 37.6.8 'Continuous Sampling mode' ) is not enabled. This allows for a threshold comparison on the average of a short burst of ADC samples.",
    "37.6.6 LOW-PASS FILTER MODE\nThe Low-pass Filter mode (ADMD = 100 ) acts similarly to the  Average  mode  in  how  it  handles  samples (accumulates samples until CNT value greater than or equal to RPT, then triggers threshold comparison), but instead  of  a  simple  average,  it  performs  a  low-pass filter operation on all of the samples, reducing the effect of high-frequency noise on the average, then performs a threshold comparison on the results. (see Table 37-2 for  a  more  detailed  description  of  the  mathematical operation). In this mode, the ADCRS bits determine the cut-off frequency of the low-pass filter (as demonstrated by Table 37-3).",
    "37.6.7 THRESHOLD COMPARISON\nAt the end of each computation:",
    "37.6.7 THRESHOLD COMPARISON\n\u00b7 The conversion results are latched and held stable at the end-of-conversion.\n\u00b7 The error is calculated based on a difference calculation which is selected by the ADCALC<2:0> bits in the ADCON3 register. The value can be one of the following calculations (see Register 37-4 for more details):\n-The first derivative of single measurements\n-The CVD result in CVD mode\n-The current result vs. a setpoint\n-The current result vs. the filtered/average result\n-The first derivative of the filtered/average value\n-Filtered/average value vs. a setpoint\n\u00b7 The result of the calculation (ERR) is compared to the upper and lower thresholds, UTH<ADUTHH:ADUTHL> and LTH<ADLTHH:ADLTHL> registers, to set the ADUTHR and ADLTHR flag bits. The threshold logic is selected by ADTMD<2:0> bits in the ADCON3 register. The threshold trigger option can be one of the following:\n-Never interrupt\n-Error is less than lower threshold\n-Error is greater than or equal to lower threshold\n-Error is between thresholds (inclusive)",
    "37.6.7 THRESHOLD COMPARISON\n-Error is outside of thresholds\n-Error is less than or equal to upper threshold\n-Error is greater than upper threshold\n-Always interrupt regardless of threshold test results\n-If the threshold condition is met, the threshold interrupt flag ADTIF is set.\nNote 1:, 1 = The threshold tests are signed operations.. 2:, 1 = If ADAOV is set, a threshold interrupt is signaled.",
    "37.6.8 CONTINUOUS SAMPLING MODE\nSetting the CONT  bit in the ADCON0  register automatically retriggers a new conversion cycle after updating the ADACC register.   The GO bit remains set and retriggering occurs automatically.\nIf ADSOI = 1 , a threshold interrupt condition will clear GO and the conversions will stop.",
    "37.6.9 DOUBLE SAMPLE CONVERSION\nDouble sampling is enabled by setting the ADDSEN bit of  the  ADCON1  register.  When  this  bit  is  set,  two conversions are required before the module will calculate threshold error (each conversion must still be triggered separately). The first conversion will set the ADMATH  bit  of  the  ADSTAT  register  and  update ADACC, but will not calculate ERR or trigger ADTIF. When the second conversion completes, the first value is  transferred  to  PREV  (depending  on  the  setting  of ADPSIS) and the value  of  the  second  conversion  is placed into ADRES. Only upon the completion of the second  conversion  is  ERR  calculated  and  ADTIF triggered (depending on the value of ADCALC).",
    "REGISTER 37-1: ADCON0: ADC CONTROL REGISTER 0\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = U-0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = U-0. R/W-0/0, 7 = R/W/HC-0. ON, 1 = CONT. ON, 2 = -. ON, 3 = CS. ON, 4 = -. ON, 5 = FM. ON, 6 = -. ON, 7 = GO. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 37-1: ADCON0: ADC CONTROL REGISTER 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = HC = Bit is cleared by hardware",
    "bit 7\nON: ADC Enable bit\n1 = ADC is enabled\n0 = ADC is disabled",
    "bit 6\nCONT: ADC Continuous Operation Enable bit\n1 = GO is retriggered upon completion of each conversion trigger until ADTIF is set (if ADSOI is set) or until GO is cleared (regardless of the value of ADSOI)\n0 = ADC is cleared upon completion of each conversion trigger",
    "bit 5\nUnimplemented: Read as ' 0 '\nbit 4\nCS: ADC Clock Selection bit\n1 = Clock supplied from FRC dedicated oscillator\n0 = Clock supplied by FOSC, divided according to ADCLK register",
    "bit 3\nUnimplemented: Read as ' 0 '\nbit 2\nFM: ADC results Format/alignment Selection\n1 = ADRES and PREV data are right-justified\n0 = ADRES and PREV data are left-justified, zero-filled",
    "bit 1\nUnimplemented: Read as ' 0 '",
    "bit 0\nGO: ADC Conversion Status bit (1)\n1 =  ADC conversion cycle in progress. Setting this bit starts an ADC conversion cycle. The bit is cleared by hardware as determined by the CONT bit\n- 0 = ADC conversion completed/not in progress",
    "Note 1: This bit requires ON bit to be set.\n- 2: If cleared by software while a conversion is in progress, the results of the conversion up to this point will be transfered to ADRES and the state machine will be reset, but the ADIF interrupt flag bit will not be set; filter and threshold operations will not be performed.\nbit 5",
    "REGISTER 37-2: ADCON1: ADC CONTROL REGISTER 1\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = U-0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = U-0. R/W-0/0, 6 = U-0. R/W-0/0, 7 = R/W-0/0. PPOL, 1 = IPEN. PPOL, 2 = GPOL. PPOL, 3 = -. PPOL, 4 = -. PPOL, 5 = -. PPOL, 6 = -. PPOL, 7 = DSEN. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit",
    "REGISTER 37-2: ADCON1: ADC CONTROL REGISTER 1\n7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nPPOL: Precharge Polarity bit",
    "bit 7 If PRE>0x00:\n1, Action During 1st Precharge Stage.External (selected analog I/O pin) = Connected to VDD. 1, Action During 1st Precharge Stage.Internal (AD sampling capacitor) = C HOLD connected to VSS. 0, Action During 1st Precharge Stage.External (selected analog I/O pin) = Connected to VSS. 0, Action During 1st Precharge Stage.Internal (AD sampling capacitor) = C HOLD connected to VDD",
    "Otherwise:\nThe bit is ignored",
    "bit 6 IPEN: A/D Inverted Precharge Enable bit\nIf DSEN = 1\n1 = The precharge and guard signals in the second conversion cycle are the opposite polarity of the first cycle\n0 = Both Conversion cycles use the precharge and guards specified by ADPPOL and ADGPOL Otherwise:\nThe bit is ignored\nGPOL: Guard Ring Polarity Selection bit\n1 = ADC guard Ring outputs start as digital high during Precharge stage\n0 = ADC guard Ring outputs start as digital low during Precharge stage",
    "bit 4-1 Unimplemented: Read as ' 0 '\nbit 0\nDSEN: Double-sample enable bit\n1 = Two conversions are performed on each trigger. Data from the first conversion appears in PREV\n0 = One conversion is performed for each trigger",
    "REGISTER 37-3: ADCON2: ADC CONTROL REGISTER 2\nPSIS, R/W-0/0 = CRS<2:0>. PSIS, R/W-0/0 = . PSIS, R/W-0/0 = . PSIS, R/W/HC-0 = ACLR. PSIS, R/W-0/0 = . PSIS, R/W-0/0 = MD<2:0>. PSIS, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W/HC-0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nHC = Bit is cleared by hardware",
    "bit 7\nPSIS: ADC Previous Sample Input Select bits\n1 = PREV is the FLTR value at start-of-conversion\n0 = PREV is the RES value at start-of-conversion",
    "bit 6-4\nCRS<2:0>: ADC Accumulated Calculation Right Shift Select bits\nIf ADMD = 100 :\nLow-pass filter time constant is 2 ADCRS , filter gain is 1:1\nIf ADMD = 001  010 , or 011 :\nThe accumulated value is right-shifted by CRS (divided by 2 ADCRS ) (1,2)\nOtherwise:\nBits are ignored",
    "bit 3\nACLR: A/D Accumulator Clear Command bit (3)\n1 = ACC, AOV and CNT registers are cleared\n0 = Clearing action is complete (or not started)",
    "bit 2-0\nMD<2:0>: ADC Operating Mode Selection bits (4)\n111-101 = Reserved\n100 = Low-pass Filter mode\n011 = Burst Average mode\n010 = Average mode\n001 = Accumulate mode\n000 = Basic mode\nNote 1: To correctly calculate an average, the number of samples (set in RPT) must be 2ADCRS.\n2: ADCRS = 3'b111 is a reserved option.\n3: This bit is cleared by hardware when the accumulator operation is complete; depending on oscillator selections, the delay may be many instructions.\n4: See Table 37-2 for Full mode descriptions.",
    "REGISTER 37-4: ADCON3: ADC CONTROL REGISTER 3\n-, R/W-0/0 = CALC<2:0>. -, R/W-0/0 = CALC<2:0>. -, R/W-0/0 = . -, R/W/HC-0 = SOI. -, R/W-0/0 = . -, R/W-0/0 = TMD<2:0>. -, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W/HC-0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "REGISTER 37-4: ADCON3: ADC CONTROL REGISTER 3\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = HC = Bit is cleared by hardware",
    "bit 6-4 CALC<2:0>: ADC Error Calculation Mode Select bits\n111, DSEN = 0 Single-Sample Mode = Reserved. 111, DSEN = 1 CVD Double-Sample Mode (1) = Reserved. 111, Application = Reserved. 110, DSEN = 0 Single-Sample Mode = Reserved. 110, DSEN = 1 CVD Double-Sample Mode (1) = Reserved. 110, Application = Reserved. 101, DSEN = 0 Single-Sample Mode = FLTR-STPT. 101, DSEN = 1 CVD Double-Sample Mode (1) = FLTR-STPT. 101, Application = Average/filtered value vs. setpoint. 100, DSEN = 0 Single-Sample Mode = PREV-FLTR. 100, DSEN = 1 CVD Double-Sample Mode (1) = PREV-FLTR. 100, Application = First derivative of filtered value (3) (negative). 011, DSEN = 0 Single-Sample Mode = Reserved. 011, DSEN = 1 CVD Double-Sample Mode (1) = Reserved. 011, Application = Reserved. 010, DSEN = 0 Single-Sample Mode =",
    "bit 6-4 CALC<2:0>: ADC Error Calculation Mode Select bits\nRES-FLTR. 010, DSEN = 1 CVD Double-Sample Mode (1) = (RES-PREV)-FLTR. 010, Application = Actual result vs. averaged/filtered value. 001, DSEN = 0 Single-Sample Mode = RES-STPT. 001, DSEN = 1 CVD Double-Sample Mode (1) = (RES-PREV)-STPT. 001, Application = Actual result vs.setpoint. 000, DSEN = 0 Single-Sample Mode = RES-PREV. 000, DSEN = 1 CVD Double-Sample Mode (1) = RES-PREV. 000, Application = First derivative of single measurement (2). 000, DSEN = 0 Single-Sample Mode = RES-PREV. 000, DSEN = 1 CVD Double-Sample Mode (1) = RES-PREV. 000, Application = Actual CVD result in CVD mode (2)\nbit 3\nSOI: ADC Stop-on-Interrupt bit\nIf CONT = 1:",
    "bit 6-4 CALC<2:0>: ADC Error Calculation Mode Select bits\n1 = GO is cleared when the threshold conditions are met, otherwise the conversion is retriggered 0 = GO is not cleared by hardware, must be cleared by software to stop retriggers",
    "bit 2-0 TMD<2:0>: Threshold Interrupt Mode Select bits\n111 = Interrupt regardless of threshold test results\n110 = Interrupt if ERR>UTH\n100 = Interrupt if ERR \uf03c LTH or ERR>UTH\n101 = Interrupt if ERR \uf0a3 UTH\n011 = Interrupt if ERR>LTH and ERR<UTH\n010 = Interrupt if ERR \u2265 LTH\n001 = Interrupt if ERR<LTH\n000 = Never interrupt\nNote 1: When PSIS = 0 , the value of (RES-PREV) is the value of (S2-S1) from Table 37-2.\n2: When PSIS = 0\n3: When PSIS = 1 .",
    "REGISTER 37-5: ADSTAT: ADC STATUS REGISTER\nR-0/0, 1 = R-0/0. R-0/0, 2 = R-0/0. R-0/0, 3 = R/HS/HC-0/0. R-0/0, 4 = U-0. R-0/0, 5 = R-0/0. R-0/0, 6 = R-0/0. R-0/0, 7 = R-0/0. AOV, 1 = UTHR. AOV, 2 = LTHR. AOV, 3 = MATH. AOV, 4 = -. AOV, 5 = STAT<2:0>. AOV, 6 = STAT<2:0>. AOV, 7 = STAT<2:0>. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 37-5: ADSTAT: ADC STATUS REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = HS/HC = Bit is set/cleared by hardware",
    "bit 7\nAOV : ADC Accumulator Overflow bit\n1 = ADC accumulator or ERR calculation have overflowed\n0 = ADC accumulator and ERR calculation have not overflowed\nbit 6\nUTHR : ADC Module Greater-than Upper Threshold Flag bit\n1 = ERR >UTH\n0 = ERR \uf0a3\uf020 UTH\nbit 5\nLTHR : ADC Module Less-than Lower Threshold Flag bit\n1 = ERR < LTH\n0 = ERR \u2265 LTH\nbit 4\nMATH : ADC Module Computation Status bit\n1 = Registers ACC, FLTR, UTH, LTH and the AOV bit are updating or have already updated\n0 = Associated registers/bits have not changed since this bit was last cleared",
    "bit 3\nUnimplemented: Read as ' 0 '\nbit 2-0\nSTAT<2:0> : ADC Module Cycle Multistage Status bits (1)\n111 = ADC module is in 2 nd conversion stage\n110 = ADC module is in 2 nd acquisition stage\n101 = ADC module is in 2 nd precharge stage\n100 = ADC computation is suspended between 1st and 2nd sample: the computation results are incomplete and awaiting data from the 2nd sample (2,3)\n011 = ADC module is in 1 st conversion stage\n010 = ADC module is in 1 st acquisition stage\n001 = ADC module is in 1 st precharge stage\n000 = ADC module is not converting\nNote 1: If CS = 1 , and FOSC<FRC, these bits may be invalid.\n2: If ADOSC = ADCRC and FOSC < FRC, this reading may be invalid.\n3: ADSTAT = 100 appears between the two triggers when ADDSEN = 1 and ADCONT = 0 .",
    "REGISTER 37-6: ADCLK: ADC CLOCK SELECTION REGISTER\n-, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = CS<5:0>. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "REGISTER 37-6: ADCLK: ADC CLOCK SELECTION REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = . '1' = Bit is set, U = Unimplemented bit, read as '0' = . , W=Writable bit = '0' = Bit is cleared. , U = Unimplemented bit, read as '0' = \nbit 7-6\nUnimplemented : Read as ' 0 '\nbit 5-0\nCS<5:0> : ADC Conversion Clock Select bits\n111111 = FOSC/128\n111110 = FOSC/126\n111101 = FOSC/124\n\uf0b7\n\uf0b7\n\uf0b7\n000000 = FOSC/2",
    "REGISTER 37-7: ADREF: ADC REFERENCE SELECTION REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0/0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = NREF. -, 4 = -. -, 5 = -. -, 6 = PREF<1:0>. -, 7 = PREF<1:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7-5 Unimplemented : Read as ' 0 '\nbit 4\nNREF : ADC Negative Voltage Reference Selection bit\n1 = VREF- is connected to external VREF-\n0 = VREF- is connected to VSS\nbit 3-2\nUnimplemented : Read as ' 0 '\nbit 1-0\nPREF : ADC Positive Voltage Reference Selection bits\n11 = VREF+ is connected to internal Fixed Voltage Reference (FVR) module\n10 = VREF+ is connected to external VREF+\n01 = Reserved\n00 = VREF+ is connected to VDD\nNote",
    "REGISTER 37-8: ADPCH: ADC POSITIVE CHANNEL SELECTION REGISTER\n-, U-0 = -. -, R/W-0/0 = ADPCH<5:0>. -, R/W-0/0 = ADPCH<5:0>. -, R/W-0/0 = ADPCH<5:0>. -, R/W-0/0 = ADPCH<5:0>. -, R/W-0/0 = ADPCH<5:0>. -, R/W-0/0 = ADPCH<5:0>. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7",
    "REGISTER 37-8: ADPCH: ADC POSITIVE CHANNEL SELECTION REGISTER\nbit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-6 Unimplemented : Read as ' 0 '\nbit 5-0 ADPCH<5:0> : ADC Positive Input Channel Selection bits\n111111 = Fixed Voltage Reference (FVR) (2)\n111110 = DAC1 output\n(1)\n111101 = Temperature Indicator\n(3)\n111100 = AVSS (Analog Ground)\n111011 = Reserved. No channel connected.\n\uf0b7\n\uf0b7\n\uf0b7\n010111 = ANC7\n010110 = ANC6\n010101 = ANC5\n010100 = ANC4\n010011 = ANC3\n010010 = ANC2\n010001 = ANC1",
    "REGISTER 37-8: ADPCH: ADC POSITIVE CHANNEL SELECTION REGISTER\n010000 = ANC0\n001111 = ANB7\n001110 = ANB6\n001101 = ANB5\n001100 = ANB4\n001011\n= ANB3\n001010 = ANB2\n001001\n= ANB1\n001000 = ANB0\n000111 = ANA7\n000110 = ANA6\n000101\n= ANA5\n000100 = ANA4\n000011 = ANA3\n000010 = ANA2\n000001\n= ANA1\n= ANA0\n000000\n1: See Section 38.0 '5-Bit Digital-to-Analog Converter (DAC) Module' for more information.\n2: See Section 35.0 'Fixed Voltage Reference (FVR)' for more information.\n3: See Section 36.0 'Temperature Indicator Module' for more information.",
    "REGISTER 37-9: ADPREL: ADC PRECHARGE TIME CONTROL REGISTER (LOW BYTE)\nbit 7, R/W-0/0.PRE<7:0> = . bit 7, R/W-0/0.PRE<7:0> = . bit 7, R/W-0/0.PRE<7:0> = . bit 7, R/W-0/0.PRE<7:0> = . bit 7, R/W-0/0.PRE<7:0> = . bit 7, R/W-0/0.PRE<7:0> = . bit 7, R/W-0/0.PRE<7:0> = bit 0",
    "REGISTER 37-9: ADPREL: ADC PRECHARGE TIME CONTROL REGISTER (LOW BYTE)\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-0\nPRE<7:0> : Precharge Time Select bits\nSee Table 37-4.",
    "REGISTER 37-10: ADPREH: ADC PRECHARGE TIME CONTROL REGISTER (HIGH BYTE)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = . -, 4 = . -, 5 = PRE<12:8>. -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 37-10: ADPREH: ADC PRECHARGE TIME CONTROL REGISTER (HIGH BYTE)\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-5\nUnimplemented : Read as ' 0 '\nbit 4-0\nPRE<12:8>: Precharge Time Select bits\nSee Table 37-4.\nNote:\nIf PRE is not equal to ' 0 ', then ADACQ = b'00000000 means Acquisition time is 256 clocks of the selected ADC clock.",
    "TABLE 37-4: PRECHARGE TIME\n1111 1111 1111, ADPRE = 8191 clocks of the selected ADC clock. 1111 1111 1110, ADPRE = 8190 clocks of the selected ADC clock. 1111 1111 1101, ADPRE = 8189 clocks of the selected ADC clock. ... ..., ADPRE = ... .... 0000 0000 0010, ADPRE = 2 clocks of the selected ADC clock. 0000 0000 0001, ADPRE = 1 clock of the selected ADC clock. 0000 0000 0000, ADPRE = Not included in the data conversion cycle",
    "REGISTER 37-11: ADACQL: ADC ACQUISITION TIME CONTROL REGISTER (LOW BYTE)\nbit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0.ACQ<7:0> = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = . bit 7, R/W-0/0. = bit 0\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other = ",
    "REGISTER 37-11: ADACQL: ADC ACQUISITION TIME CONTROL REGISTER (LOW BYTE)\nbit 7-0 ACQ<7:0>: Acquisition (charge share time) Select bits\nSee Table .",
    "REGISTER 37-12: ADACQH: ADC ACQUISITION TIME CONTROL REGISTER (HIGH BYTE)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = -. -, 3 = . -, 4 = . -, 5 = ACQ<12:8>. -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 37-12: ADACQH: ADC ACQUISITION TIME CONTROL REGISTER (HIGH BYTE)\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = \nbit 7-5 Unimplemented : Read as ' 0 '\nbit 4-0\nACQ<12:8>: Acquisition (charge share time) Select bits See Table .",
    "TABLE 37-5: ACQUISITION TIME\n1 1111, ADACQ = 1111. 1 1111, ADACQ = 1111. 1 1111, Acquisition time = 8191 clocks of the selected ADC clock. 1 1111, ADACQ = 1111. 1 1111, ADACQ = 1110. 1 1111, Acquisition time = 8190 clocks of the selected ADC clock. 1 1111, ADACQ = 1111. 1 1111, ADACQ = 1101. 1 1111, Acquisition time = 8189 clocks of the selected ADC clock. ..., ADACQ = .... ..., ADACQ = .... ..., Acquisition time = .... 0 0000, ADACQ = 0000. 0 0000, ADACQ = 0010. 0 0000, Acquisition time = 2 clocks of the selected ADC clock. 0, ADACQ = 0000. 0, ADACQ = 0001. 0, Acquisition time = 1 clock of the selected ADC clock. 0 0000, ADACQ = 0000. 0 0000, ADACQ = 0000. 0",
    "TABLE 37-5: ACQUISITION TIME\n0000, Acquisition time = Not included in the data conversion cycle (1)\nNote 1: If ADPRE is not equal to ' 0 ', then ADACQ = 0b0_0000_0000_0000 means Acquisition time is 8192 clocks of the selected ADC clock.",
    "REGISTER 37-13: ADCAP: ADC ADDITIONAL SAMPLE CAPACITOR SELECTION REGISTER\n-, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = ADCAP<4:0>. -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 37-13: ADCAP: ADC ADDITIONAL SAMPLE CAPACITOR SELECTION REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = \nbit 7-5\nUnimplemented : Read as ' 0 '\nbit 4-0\nADCAP<4:0> : ADC Additional Sample Capacitor Selection bits\n11111 = 31 pF\n11110 = 30 pF\n11101 = 29 pF\n\uf0b7\n\uf0b7\n\uf0b7\n00011 = 3 pF\n00010 = 2 pF\n00001 = 1 pF\n00000 = No additional capacitance",
    "REGISTER 37-14: ADRPT: ADC REPEAT SETTING REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. RPT<7:0>, 1 = RPT<7:0>. RPT<7:0>, 2 = RPT<7:0>. RPT<7:0>, 3 = RPT<7:0>. RPT<7:0>, 4 = RPT<7:0>. RPT<7:0>, 5 = RPT<7:0>. RPT<7:0>, 6 = RPT<7:0>. RPT<7:0>,",
    "REGISTER 37-14: ADRPT: ADC REPEAT SETTING REGISTER\n7 = RPT<7:0>. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = ",
    "bit 7-0\nRPT<7:0> : ADC Repeat Threshold bits\nCounts the number of times that the ADC has been triggered and is used along with CNT to determine when the error threshold is checked when the computation is Low-pass Filter, Burst Average, or Aver -age modes. See Table 37-2 for more details.",
    "REGISTER 37-15: ADCNT: ADC REPEAT COUNTER REGISTER\nbit 7, R/W-x/u. = . bit 7, R/W-x/u. = . bit 7, R/W-x/u.CNT<7:0> = . bit 7, R/W-x/u. = . bit 7, R/W-x/u. = . bit 7, R/W-x/u. = . bit 7, R/W-x/u. = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = ",
    "bit 7-0 CNT<7:0> : ADC Repeat Count bits\nDetermines the number of times that the ADC is triggered before the threshold is checked when the computation is Low-pass Filter, Burst Average, or Average modes. See Table 37-2 for more details.",
    "REGISTER 37-16: ADFLTRH: ADC FILTER HIGH BYTE REGISTER\nbit 7, R-x. = . bit 7, R-x.FLTR<15:8> = . bit 7, R-x.FLTR<15:8> = . bit 7, R-x.FLTR<15:8> = . bit 7, R-x.FLTR<15:8> = . bit 7, R-x. = . bit 7, R-x. = bit 0\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, U = Unimplemented bit, read as '0' = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "REGISTER 37-16: ADFLTRH: ADC FILTER HIGH BYTE REGISTER\nbit 7-0 FLTR<15:8> : ADC Filter Output Most Significant bits\nIn Accumulate, Average, and Burst Average mode, this is equal to ACC right shifted by the ADCRS bits of ADCON2. In LPF mode, this is the output of the Low-pass Filter.",
    "REGISTER 37-17: ADFLTRL: ADC FILTER LOW BYTE REGISTER\nbit 7, R-x.FLTR<7:0> = . bit 7, R-x.FLTR<7:0> = . bit 7, R-x.FLTR<7:0> = . bit 7, R-x.FLTR<7:0> = . bit 7, R-x.FLTR<7:0> = . bit 7, R-x.FLTR<7:0> = . bit 7, R-x.FLTR<7:0> = bit 0",
    "REGISTER 37-17: ADFLTRL: ADC FILTER LOW BYTE REGISTER\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = ",
    "bit 7-0 FLTR<7:0> : ADC Filter Output Least Significant bits\nIn Accumulate, Average, and Burst Average mode, this is equal to ACC right shifted by the ADCRS bits of ADCON2. In LPF mode, this is the output of the Low-pass Filter.",
    "REGISTER 37-18: ADRESH: ADC RESULT REGISTER HIGH, FM = 0\nbit 7, R/W-x/u.ADRES<11:4> = . bit 7, R/W-x/u.ADRES<11:4> = . bit 7, R/W-x/u.ADRES<11:4> = . bit 7, R/W-x/u.ADRES<11:4> = . bit 7, R/W-x/u.ADRES<11:4> = . bit 7, R/W-x/u.ADRES<11:4> = . bit 7, R/W-x/u.ADRES<11:4> = bit 0",
    "REGISTER 37-18: ADRESH: ADC RESULT REGISTER HIGH, FM = 0\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = \nbit 7-0\nADRES<11:4> : ADC Result Register bits\nUpper eight bits of 12-bit conversion result.",
    "REGISTER 37-19: ADRESL: ADC RESULT REGISTER LOW, FM = 0\nbit 7, R/W-x/u.ADRES<3:0> = . bit 7, R/W-x/u.ADRES<3:0> = . bit 7, R/W-x/u. = . bit 7, U-0.- = . bit 7, U-0.- = . bit 7, U-0.- = . bit 7, U-0.- = bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-4 ADRES<3:0> : ADC Result Register bits. Lower four bits of 12-bit conversion result.\nbit 3-0 Reserved",
    "REGISTER 37-20: ADRESH: ADC RESULT REGISTER HIGH, FM = 1\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-x/u. U-0, 5 = R/W-x/u. U-0, 6 = R/W-x/u. U-0, 7 = R/W-x/u. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = ADRES<11:8>. -, 5 = ADRES<11:8>. -, 6 = ADRES<11:8>. -, 7 = ADRES<11:8>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 37-20: ADRESH: ADC RESULT REGISTER HIGH, FM = 1\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "bit 7-4 Reserved\nbit 3-0 ADRES<11:8> : ADC Sample Result bits. Upper four bits of 12-bit conversion result.",
    "REGISTER 37-21: ADRESL: ADC RESULT REGISTER LOW, FM = 1\nbit 7, R/W-x/u.ADRES<7:0> = . bit 7, R/W-x/u.ADRES<7:0> = . bit 7, R/W-x/u.ADRES<7:0> = . bit 7, R/W-x/u.ADRES<7:0> = . bit 7, R/W-x/u.ADRES<7:0> = . bit 7, R/W-x/u.ADRES<7:0> = . bit 7, R/W-x/u.ADRES<7:0> = bit 0",
    "REGISTER 37-21: ADRESL: ADC RESULT REGISTER LOW, FM = 1\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = \nbit 7-0 ADRES<7:0> : ADC Result Register bits. Lower eight bits of 12-bit conversion result.",
    "REGISTER 37-22: ADPREVH: ADC PREVIOUS RESULT REGISTER\nbit 7, R-x.PREV<15:8> = . bit 7, R-x.PREV<15:8> = . bit 7, R-x.PREV<15:8> = . bit 7, R-x.PREV<15:8> = . bit 7, R-x.PREV<15:8> = . bit 7, R-x.PREV<15:8> = . bit 7, R-x.PREV<15:8> = bit 0\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "bit 7-0 PREV<15:8> : Previous ADC Results bits\nIf ADPSIS = 1 :\nUpper byte of FLTR at the start of current ADC conversion\nIf ADPSIS = 0 :\nUpper bits of ADRES at the start of current ADC conversion (1)\nNote 1: If ADPSIS = 0 , ADPREVH and ADPREVL are formatted the same way as ADRES is, depending on the FM bit.",
    "REGISTER 37-23: ADPREVL: ADC PREVIOUS RESULT REGISTER\nbit 7, R-x.PREV<7:0> = . bit 7, R-x.PREV<7:0> = . bit 7, R-x.PREV<7:0> = . bit 7, R-x.PREV<7:0> = . bit 7, R-x.PREV<7:0> = . bit 7, R-x.PREV<7:0> = . bit 7, R-x.PREV<7:0> = bit 0",
    "REGISTER 37-23: ADPREVL: ADC PREVIOUS RESULT REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, = Unimplemented bit, read as '0' = U -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = . '1' = Bit is set, = Unimplemented bit, read as '0' = . , W=Writable bit = '0' = Bit is cleared. , = Unimplemented bit, read as '0' = ",
    "bit 7-0 PREV<7:0> : Previous ADC Results bits\nIf ADPSIS = 1 :\nLower byte of FLTR at the start of current ADC conversion\nIf ADPSIS = 0 :\nLower bits of ADRES at the start of current ADC conversion (1)\nNote 1: If ADPSIS = 0 , ADPREVH and ADPREVL are formatted the same way as ADRES is, depending on the FM bit.",
    "REGISTER 37-24: ADACCU: ADC ACCUMULATOR REGISTER UPPER\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-x/x = ACC<17:16>. -, R/W-x/x = ACC<17:16>. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-x/x = bit 7 bit 0. bit 7 bit 0, R/W-x/x = bit 7 bit 0",
    "REGISTER 37-24: ADACCU: ADC ACCUMULATOR REGISTER UPPER\nR = Readable bit, W=Writable bit = . R = Readable bit, Unimplemented bit, read as '0' = U =. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = \nbit 7-2\nUnimplemented : Read as ' 0 '\nbit 1-0\nACC<17:16> : ADC Accumulator MSB. Upper two bits of accumulator value. See Table 37-2 for more details.",
    "REGISTER 37-25: ADACCH: ADC ACCUMULATOR REGISTER HIGH\nbit 7, R/W-x/x.ACC<15:8> = . bit 7, R/W-x/x.ACC<15:8> = . bit 7, R/W-x/x.ACC<15:8> = . bit 7, R/W-x/x.ACC<15:8> = . bit 7, R/W-x/x.ACC<15:8> = . bit 7, R/W-x/x.ACC<15:8> = . bit 7, R/W-x/x.ACC<15:8> = bit 0",
    "REGISTER 37-25: ADACCH: ADC ACCUMULATOR REGISTER HIGH\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-0 ACC<15:8> : ADC Accumulator middle bits. Middle eight bits of accumulator value. See Table 37-2 for more details.",
    "REGISTER 37-26: ADACCL: ADC ACCUMULATOR REGISTER LOW\nbit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x.ACC<7:0> = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = . bit 7, R/W-x/x. = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "REGISTER 37-26: ADACCL: ADC ACCUMULATOR REGISTER LOW\nbit 7-0 ACC<7:0> : ADC Accumulator LSB. Lower eight bits of accumulator value. See Table 37-2 for more details.",
    "REGISTER 37-27: ADSTPTH: ADC THRESHOLD SETPOINT REGISTER HIGH\nbit 7, R/W-0/0.STPT<15:8> = . bit 7, R/W-0/0.STPT<15:8> = . bit 7, R/W-0/0.STPT<15:8> = . bit 7, R/W-0/0.STPT<15:8> = . bit 7, R/W-0/0.STPT<15:8> = . bit 7, R/W-0/0.STPT<15:8> = . bit 7, R/W-0/0.STPT<15:8> = bit 0",
    "REGISTER 37-27: ADSTPTH: ADC THRESHOLD SETPOINT REGISTER HIGH\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = . '1' = Bit is set, U = Unimplemented bit, read as '0' = . , W=Writable bit = '0' = Bit is cleared. , U = Unimplemented bit, read as '0' = \nbit 7-0 STPT<15:8> : ADC Threshold Setpoint MSB. Upper byte of ADC threshold setpoint, depending on ADCALC, may be used to determine ERR, see Register 37-29 for more details.",
    "REGISTER 37-28: ADSTPTL: ADC THRESHOLD SETPOINT REGISTER LOW\nbit 7, R/W-0/0.STPT<7:0> = . bit 7, R/W-0/0.STPT<7:0> = . bit 7, R/W-0/0.STPT<7:0> = . bit 7, R/W-0/0.STPT<7:0> = . bit 7, R/W-0/0.STPT<7:0> = . bit 7, R/W-0/0.STPT<7:0> = . bit 7, R/W-0/0.STPT<7:0> = bit 0",
    "REGISTER 37-28: ADSTPTL: ADC THRESHOLD SETPOINT REGISTER LOW\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-0 STPT<7:0> : ADC Threshold Setpoint LSB. Lower byte of ADC threshold setpoint, depending on ADCALC, may be used to determine ERR, see Register 37-30 for more details.",
    "REGISTER 37-29: ADERRH: ADC SETPOINT ERROR REGISTER HIGH\nbit 7, R-x.ERR<15:8> = . bit 7, R-x.ERR<15:8> = . bit 7, R-x.ERR<15:8> = . bit 7, R-x.ERR<15:8> = . bit 7, R-x.ERR<15:8> = . bit 7, R-x.ERR<15:8> = . bit 7, R-x.ERR<15:8> = bit 0",
    "REGISTER 37-29: ADERRH: ADC SETPOINT ERROR REGISTER HIGH\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-0 ERR<15:8> : ADC Setpoint Error MSB. Upper byte of ADC Setpoint Error. Setpoint Error calculation is determined by CALC bits of ADCON3, see Register 37-4 for more details.",
    "REGISTER 37-30: ADERRL: ADC SETPOINT ERROR LOW BYTE REGISTER\nbit 7, R-x.ERR<7:0> = . bit 7, R-x. = . bit 7, R-x. = . bit 7, R-x. = . bit 7, R-x. = . bit 7, R-x. = . bit 7, R-x. = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-0 ERR<7:0> : ADC Setpoint Error LSB. Lower byte of ADC Setpoint Error calculation is determined by CALC bits of ADCON3, see Register 37-4 for more details.",
    "REGISTER 37-31: ADLTHH: ADC LOWER THRESHOLD HIGH BYTE REGISTER\nbit 7, R/W-0/0.LTH<15:8> = . bit 7, R/W-0/0.LTH<15:8> = . bit 7, R/W-0/0.LTH<15:8> = . bit 7, R/W-0/0.LTH<15:8> = . bit 7, R/W-0/0.LTH<15:8> = . bit 7, R/W-0/0.LTH<15:8> = . bit 7, R/W-0/0.LTH<15:8> = bit 0",
    "REGISTER 37-31: ADLTHH: ADC LOWER THRESHOLD HIGH BYTE REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = \nLTH<15:8> : ADC Lower Threshold MSB. LTH and UTH are compared with ERR to set the ADUTHR and ADLTHR bits of ADSTAT. Depending on the setting of ADTMD, an interrupt may be triggered by bit 7-0 the results of this comparison.",
    "REGISTER 37-32: ADLTHL: ADC LOWER THRESHOLD LOW BYTE REGISTER\nbit 7, R/W-0/0.LTH<7:0> = . bit 7, R/W-0/0.LTH<7:0> = . bit 7, R/W-0/0.LTH<7:0> = . bit 7, R/W-0/0.LTH<7:0> = . bit 7, R/W-0/0.LTH<7:0> = . bit 7, R/W-0/0.LTH<7:0> = . bit 7, R/W-0/0.LTH<7:0> = bit 0",
    "REGISTER 37-32: ADLTHL: ADC LOWER THRESHOLD LOW BYTE REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = . '1' = Bit is set, U = Unimplemented bit, read as '0' = . , W=Writable bit = '0' = Bit is cleared. , U = Unimplemented bit, read as '0' = \nbit 7-0 LTH<7:0> : ADC Lower Threshold LSB. LTH and UTH are compared with ERR to set the ADUTHR and ADLTHR bits of ADSTAT. Depending on the setting of ADTMD, an interrupt may be triggered by the results of this comparison.",
    "REGISTER 37-33: ADUTHH: ADC UPPER THRESHOLD HIGH BYTE REGISTER\nbit 7, R/W-0/0.UTH<15:8> = . bit 7, R/W-0/0.UTH<15:8> = . bit 7, R/W-0/0.UTH<15:8> = . bit 7, R/W-0/0.UTH<15:8> = . bit 7, R/W-0/0.UTH<15:8> = . bit 7, R/W-0/0.UTH<15:8> = . bit 7, R/W-0/0.UTH<15:8> = bit 0",
    "REGISTER 37-33: ADUTHH: ADC UPPER THRESHOLD HIGH BYTE REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-0 UTH<15:8> : ADC Upper Threshold MSB. LTH and UTH are compared with ERR to set the ADUTHR and ADLTHR bits of ADSTAT. Depending on the setting of ADTMD, an interrupt may be triggered by the results of this comparison.",
    "REGISTER 37-34: ADUTHL: ADC UPPER THRESHOLD LOW BYTE REGISTER\nbit 7, R/W-0/0.UTH<7:0> = . bit 7, R/W-0/0.UTH<7:0> = . bit 7, R/W-0/0.UTH<7:0> = . bit 7, R/W-0/0.UTH<7:0> = . bit 7, R/W-0/0.UTH<7:0> = . bit 7, R/W-0/0.UTH<7:0> = . bit 7, R/W-0/0.UTH<7:0> = bit 0",
    "REGISTER 37-34: ADUTHL: ADC UPPER THRESHOLD LOW BYTE REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = \nbit 7-0 UTH<7:0> : ADC Upper Threshold LSB. LTH and UTH are compared with ERR to set the ADUTHR and ADLTHR bits of ADSTAT. Depending on the setting of ADTMD, an interrupt may be triggered by the results of this comparison.",
    "REGISTER 37-35: ADACT: ADC AUTO-CONVERSION TRIGGER CONTROL REGISTER\n-, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = ACT<4:0>. -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "REGISTER 37-35: ADACT: ADC AUTO-CONVERSION TRIGGER CONTROL REGISTER\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-5 Unimplemented : Read as ' 0 '\nbit 4-0\nADACT<4:0> : Auto-Conversion Trigger Select Bits\n11111 = Reserved, do not use\n\uf0b7\n\uf0b7\n\uf0b7\n11110 = Reserved, do not use\n11101 = Software write to ADPCH\n11100 = Reserved, do not use\n11011 = Software read of ADRESH\n11010 = Software read of ADERRH\n11001 = CLC4_out\n11000\n= CLC3_out\n10111 = CLC2_out\n10110 = CLC1_out\n10101 = Logical OR of all Interrupt-on-Change Interrupt Flags\n10100 = CMP2_out\n10011",
    "REGISTER 37-35: ADACT: ADC AUTO-CONVERSION TRIGGER CONTROL REGISTER\n= CMP1_out\n10010 = NCO1_out\n10001\n= PWM8_out\n10000 = PWM7_out\n01111\n= PWM6_out\n01110 = PWM5_out\n01101 = CCP4_trigger\n01100 = CCP3_trigger\n01011\n= CCP2_trigger\n01010 = CCP1_trigger\n01001\n= SMT1_trigger\n01000 = TMR6_postscaled\n00111\n= TMR5_overflow\n00110 = TMR4_postscaled\n00101\n= TMR3_overflow\n00100 = TMR2_postscaled\n00011\n= TMR1_overflow\n00010 = TMR0_overflow\n00001 = Pin selected by ADACTPPS\n00000 = External Trigger Disabled",
    "REGISTER 37-36: ADCP: ADC CHARGE PUMP CONTROL REGISTER\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = U-0. R/W-0/0, 3 = U-0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = U-0. R/W-0/0, 6 = U-0. R/W-0/0, 7 = R-0/0. CPON, 1 = -. CPON, 2 = -. CPON, 3 = -. CPON, 4 = -. CPON, 5 = -. CPON, 6 = -. CPON, 7 = CPRDY. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nHS= Hardware set\nbit 7\nCPON : Charge Pump On Control bit\n1 = Charge Pump On when requested by the ADC\n0 = Charge Pump Off\nbit 6-1\nUnimplemented: Read as ' 0 '\nbit 0\nCPRDY: Charge Pump Ready Status bit\n1 = Charge Pump is ready\n0 = Charge Pump is not ready (or never started)",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nADCON0, Bit 7 = ON. ADCON0, Bit 6 = CONT. ADCON0, Bit 5 = -. ADCON0, Bit 4 = CS. ADCON0, Bit 3 = -. ADCON0, Bit 2 = FM. ADCON0, Bit 1 = -. ADCON0, Bit 0 = GO. ADCON0, Register on Page = 671. ADCON1, Bit 7 = ADPPOL. ADCON1, Bit 6 = ADIPEN. ADCON1, Bit 5 = ADGPOL. ADCON1, Bit 4 = -. ADCON1, Bit 3 = -. ADCON1, Bit 2 = -. ADCON1, Bit 1 = -. ADCON1, Bit 0 = ADDSEN. ADCON1, Register on Page = 672. ADCON2, Bit 7 = ADPSIS. ADCON2, Bit 6 = ADCRS<2:0>. ADCON2, Bit 5 = ADCRS<2:0>. ADCON2, Bit 4 = ADCRS<2:0>. ADCON2, Bit 3 = ADACLR.",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nADCON2, Bit 2 = MD<2:0>. ADCON2, Bit 1 = MD<2:0>. ADCON2, Bit 0 = MD<2:0>. ADCON2, Register on Page = 673. ADCON3, Bit 7 = -. ADCON3, Bit 6 = ADCALC<2:0>. ADCON3, Bit 5 = ADCALC<2:0>. ADCON3, Bit 4 = ADCALC<2:0>. ADCON3, Bit 3 = ADSOI. ADCON3, Bit 2 = ADTMD<2:0>. ADCON3, Bit 1 = ADTMD<2:0>. ADCON3, Bit 0 = ADTMD<2:0>. ADCON3, Register on Page = 674. ADSTAT, Bit 7 = ADAOV. ADSTAT, Bit 6 = ADUTHR. ADSTAT, Bit 5 = ADLTHR. ADSTAT, Bit 4 = ADMATH. ADSTAT, Bit 3 = ADSTAT<3:0>. ADSTAT, Bit 2 =",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nADSTAT<3:0>. ADSTAT, Bit 1 = ADSTAT<3:0>. ADSTAT, Bit 0 = ADSTAT<3:0>. ADSTAT, Register on Page = 675. ADCLK, Bit 7 = -. ADCLK, Bit 6 = -. ADCLK, Bit 5 = CS<5:0>. ADCLK, Bit 4 = CS<5:0>. ADCLK, Bit 3 = CS<5:0>. ADCLK, Bit 2 = CS<5:0>. ADCLK, Bit 1 = CS<5:0>. ADCLK, Bit 0 = CS<5:0>. ADCLK, Register on Page = 676. ADREF, Bit 7 = -. ADREF, Bit 6 = -. ADREF, Bit 5 = -. ADREF, Bit 4 = ADNREF. ADREF, Bit 3 = -. ADREF, Bit 2 = -. ADREF, Bit 1 = ADPREF<1:0>. ADREF, Bit 0 =",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nADPREF<1:0>. ADREF, Register on Page = 676. ADPCH, Bit 7 = -. ADPCH, Bit 6 = -. ADPCH, Bit 5 = ADPCH<5:0>. ADPCH, Bit 4 = ADPCH<5:0>. ADPCH, Bit 3 = ADPCH<5:0>. ADPCH, Bit 2 = ADPCH<5:0>. ADPCH, Bit 1 = ADPCH<5:0>. ADPCH, Bit 0 = ADPCH<5:0>. ADPCH, Register on Page = 677. ADPREL, Bit 7 = PRE<7:0>. ADPREL, Bit 6 = PRE<7:0>. ADPREL, Bit 5 = PRE<7:0>. ADPREL, Bit 4 = PRE<7:0>. ADPREL, Bit 3 = PRE<7:0>. ADPREL, Bit 2 = PRE<7:0>. ADPREL, Bit 1 = PRE<7:0>.",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nADPREL, Bit 0 = PRE<7:0>. ADPREL, Register on Page = 678. ADPREH, Bit 7 = -. ADPREH, Bit 6 = -. ADPREH, Bit 5 = -. ADPREH, Bit 4 = PRE<12:8>. ADPREH, Bit 3 = PRE<12:8>. ADPREH, Bit 2 = PRE<12:8>. ADPREH, Bit 1 = PRE<12:8>. ADPREH, Bit 0 = PRE<12:8>. ADPREH, Register on Page = 678. ADACQL, Bit 7 = . ADACQL, Bit 6 = . ADACQL, Bit 5 = . ADACQL, Bit 4 = ACQ<7:0>. ADACQL, Bit 3 = ACQ<7:0>. ADACQL, Bit 2 = ACQ<7:0>. ADACQL, Bit 1 = ACQ<7:0>. ADACQL, Bit 0 = ACQ<7:0>.",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nADACQL, Register on Page = 679. ADCAP, Bit 7 = -. ADCAP, Bit 6 = -. ADCAP, Bit 5 = -. ADCAP, Bit 4 = ADCAP<4:0>. ADCAP, Bit 3 = ADCAP<4:0>. ADCAP, Bit 2 = ADCAP<4:0>. ADCAP, Bit 1 = ADCAP<4:0>. ADCAP, Bit 0 = ADCAP<4:0>. ADCAP, Register on Page = 680. ADRPT, Bit 7 = RPT<7:0>. ADRPT, Bit 6 = RPT<7:0>. ADRPT, Bit 5 = RPT<7:0>. ADRPT, Bit 4 = RPT<7:0>. ADRPT, Bit 3 = RPT<7:0>. ADRPT, Bit 2 = RPT<7:0>. ADRPT, Bit 1 = RPT<7:0>. ADRPT, Bit 0 = RPT<7:0>. ADRPT, Register on Page =",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\n680. ADCNT, Bit 7 = CNT<7:0>. ADCNT, Bit 6 = CNT<7:0>. ADCNT, Bit 5 = CNT<7:0>. ADCNT, Bit 4 = CNT<7:0>. ADCNT, Bit 3 = CNT<7:0>. ADCNT, Bit 2 = CNT<7:0>. ADCNT, Bit 1 = CNT<7:0>. ADCNT, Bit 0 = CNT<7:0>. ADCNT, Register on Page = 681. ADFLTRL, Bit 7 = FLTR<7:0>. ADFLTRL, Bit 6 = FLTR<7:0>. ADFLTRL, Bit 5 = FLTR<7:0>. ADFLTRL, Bit 4 = FLTR<7:0>. ADFLTRL, Bit 3 = FLTR<7:0>. ADFLTRL, Bit 2 = FLTR<7:0>. ADFLTRL, Bit 1 =",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nFLTR<7:0>. ADFLTRL, Bit 0 = FLTR<7:0>. ADFLTRL, Register on Page = 681. ADFLTRH, Bit 7 = FLTR<15:8>. ADFLTRH, Bit 6 = FLTR<15:8>. ADFLTRH, Bit 5 = FLTR<15:8>. ADFLTRH, Bit 4 = FLTR<15:8>. ADFLTRH, Bit 3 = FLTR<15:8>. ADFLTRH, Bit 2 = FLTR<15:8>. ADFLTRH, Bit 1 = FLTR<15:8>. ADFLTRH, Bit 0 = FLTR<15:8>. ADFLTRH, Register on Page = 681. ADRESL, Bit 7 = ADRESL<7:0>. ADRESL, Bit 6 = ADRESL<7:0>. ADRESL, Bit 5 = ADRESL<7:0>. ADRESL, Bit 4 = ADRESL<7:0>. ADRESL,",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nBit 3 = ADRESL<7:0>. ADRESL, Bit 2 = ADRESL<7:0>. ADRESL, Bit 1 = ADRESL<7:0>. ADRESL, Bit 0 = ADRESL<7:0>. ADRESL, Register on Page = 682, 683. ADRESH, Bit 7 = ADRESH<7:0>. ADRESH, Bit 6 = ADRESH<7:0>. ADRESH, Bit 5 = ADRESH<7:0>. ADRESH, Bit 4 = ADRESH<7:0>. ADRESH, Bit 3 = ADRESH<7:0>. ADRESH, Bit 2 = ADRESH<7:0>. ADRESH, Bit 1 = ADRESH<7:0>. ADRESH, Bit 0 = ADRESH<7:0>. ADRESH, Register on Page = 682, 683. ADPREVH, Bit 7 = PREV<15:8>. ADPREVH, Bit 6 = PREV<15:8>. ADPREVH, Bit 5 =",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nPREV<15:8>. ADPREVH, Bit 4 = PREV<15:8>. ADPREVH, Bit 3 = PREV<15:8>. ADPREVH, Bit 2 = PREV<15:8>. ADPREVH, Bit 1 = PREV<15:8>. ADPREVH, Bit 0 = PREV<15:8>. ADPREVH, Register on Page = 684. ADPREVL, Bit 7 = PREV<7:0>. ADPREVL, Bit 6 = PREV<7:0>. ADPREVL, Bit 5 = PREV<7:0>. ADPREVL, Bit 4 = PREV<7:0>. ADPREVL, Bit 3 = PREV<7:0>. ADPREVL, Bit 2 = PREV<7:0>. ADPREVL, Bit 1 = PREV<7:0>. ADPREVL, Bit 0 = PREV<7:0>. ADPREVL, Register on Page = 684. ADACCH,",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nBit 7 = ACC<15:8>. ADACCH, Bit 6 = ACC<15:8>. ADACCH, Bit 5 = ACC<15:8>. ADACCH, Bit 4 = ACC<15:8>. ADACCH, Bit 3 = ACC<15:8>. ADACCH, Bit 2 = ACC<15:8>. ADACCH, Bit 1 = ACC<15:8>. ADACCH, Bit 0 = ACC<15:8>. ADACCH, Register on Page = 685. ADACCL, Bit 7 = ACC<7:0>. ADACCL, Bit 6 = ACC<7:0>. ADACCL, Bit 5 = ACC<7:0>. ADACCL, Bit 4 = ACC<7:0>. ADACCL, Bit 3 = ACC<7:0>. ADACCL, Bit 2 = ACC<7:0>. ADACCL, Bit 1 = ACC<7:0>. ADACCL, Bit 0 = ACC<7:0>. ADACCL, Register on Page = 685.",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nADACCU, Bit 7 = -. ADACCU, Bit 6 = -. ADACCU, Bit 5 = -. ADACCU, Bit 4 = -. ADACCU, Bit 3 = -. ADACCU, Bit 2 = -. ADACCU, Bit 1 = ACC<17:16>. ADACCU, Bit 0 = ACC<17:16>. ADACCU, Register on Page = 685. ADSTPTL, Bit 7 = STPT<7:0>. ADSTPTL, Bit 6 = STPT<7:0>. ADSTPTL, Bit 5 = STPT<7:0>. ADSTPTL, Bit 4 = STPT<7:0>. ADSTPTL, Bit 3 = STPT<7:0>. ADSTPTL, Bit 2 = STPT<7:0>. ADSTPTL, Bit 1 = STPT<7:0>. ADSTPTL, Bit 0 = STPT<7:0>. ADSTPTL, Register on Page = 686. ADSTPTH, Bit 7 = STPT<15:8>. ADSTPTH, Bit",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\n6 = STPT<15:8>. ADSTPTH, Bit 5 = STPT<15:8>. ADSTPTH, Bit 4 = STPT<15:8>. ADSTPTH, Bit 3 = STPT<15:8>. ADSTPTH, Bit 2 = STPT<15:8>. ADSTPTH, Bit 1 = STPT<15:8>. ADSTPTH, Bit 0 = STPT<15:8>. ADSTPTH, Register on Page = 686. ADERRL, Bit 7 = ERR<7:0>. ADERRL, Bit 6 = ERR<7:0>. ADERRL, Bit 5 = ERR<7:0>. ADERRL, Bit 4 = ERR<7:0>. ADERRL, Bit 3 = ERR<7:0>. ADERRL, Bit 2 = ERR<7:0>. ADERRL, Bit 1 = ERR<7:0>. ADERRL, Bit 0 = ERR<7:0>. ADERRL, Register on Page = 687.",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nADERRH, Bit 7 = ERR<15:8>. ADERRH, Bit 6 = ERR<15:8>. ADERRH, Bit 5 = ERR<15:8>. ADERRH, Bit 4 = ERR<15:8>. ADERRH, Bit 3 = ERR<15:8>. ADERRH, Bit 2 = ERR<15:8>. ADERRH, Bit 1 = ERR<15:8>. ADERRH, Bit 0 = ERR<15:8>. ADERRH, Register on Page = 687. ADLTHH, Bit 7 = LTH<15:8>. ADLTHH, Bit 6 = LTH<15:8>. ADLTHH, Bit 5 = LTH<15:8>. ADLTHH, Bit 4 = LTH<15:8>. ADLTHH, Bit 3 = LTH<15:8>. ADLTHH, Bit 2 = LTH<15:8>. ADLTHH, Bit 1 = LTH<15:8>. ADLTHH, Bit 0 =",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nLTH<15:8>. ADLTHH, Register on Page = 687. ADLTHL, Bit 7 = LTH<7:0>. ADLTHL, Bit 6 = LTH<7:0>. ADLTHL, Bit 5 = LTH<7:0>. ADLTHL, Bit 4 = LTH<7:0>. ADLTHL, Bit 3 = LTH<7:0>. ADLTHL, Bit 2 = LTH<7:0>. ADLTHL, Bit 1 = LTH<7:0>. ADLTHL, Bit 0 = LTH<7:0>. ADLTHL, Register on Page = 688. ADUTHH, Bit 7 = UTH<15:8>. ADUTHH, Bit 6 = UTH<15:8>. ADUTHH, Bit 5 = UTH<15:8>. ADUTHH, Bit 4 = UTH<15:8>. ADUTHH, Bit 3 = UTH<15:8>. ADUTHH, Bit 2 = UTH<15:8>. ADUTHH,",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nBit 1 = UTH<15:8>. ADUTHH, Bit 0 = UTH<15:8>. ADUTHH, Register on Page = 688. ADUTHL, Bit 7 = UTH<7:0>. ADUTHL, Bit 6 = UTH<7:0>. ADUTHL, Bit 5 = UTH<7:0>. ADUTHL, Bit 4 = UTH<7:0>. ADUTHL, Bit 3 = UTH<7:0>. ADUTHL, Bit 2 = UTH<7:0>. ADUTHL, Bit 1 = UTH<7:0>. ADUTHL, Bit 0 = UTH<7:0>. ADUTHL, Register on Page = 688. ADERRL, Bit 7 = ERR<15:8>. ADERRL, Bit 6 = ERR<15:8>. ADERRL, Bit 5 = ERR<15:8>. ADERRL, Bit 4 = ERR<15:8>. ADERRL, Bit 3 = ERR<15:8>.",
    "TABLE 37-6: SUMMARY OF REGISTERS ASSOCIATED WITH ADC\nADERRL, Bit 2 = ERR<15:8>. ADERRL, Bit 1 = ERR<15:8>. ADERRL, Bit 0 = ERR<15:8>. ADERRL, Register on Page = 687. ADACT, Bit 7 = -. ADACT, Bit 6 = -. ADACT, Bit 5 = -. ADACT, Bit 4 = -. ADACT, Bit 3 = ADACT<4:0>. ADACT, Bit 2 = . ADACT, Bit 1 = . ADACT, Bit 0 = . ADACT, Register on Page = 689. ADCP, Bit 7 = CPON. ADCP, Bit 6 = -. ADCP, Bit 5 = -. ADCP, Bit 4 = -. ADCP, Bit 3 = -. ADCP, Bit 2 = -. ADCP, Bit 1 = -. ADCP, Bit 0 = CPRDY. ADCP, Register on Page = 690\nLegend:\n-= unimplemented read as ' 0 '. Shaded cells are not used for the ADC module.",
    "38.0 5-BIT DIGITAL-TO-ANALOG CONVERTER (DAC) MODULE\nThe  Digital-to-Analog  Converter  supplies  a  variable voltage  reference,  ratiometric  with  the  input  source, with 32 selectable output levels.\nThe positive input source (VSOURCE+) of the DAC can be connected to:\n\u00b7 FVR Buffer\n\u00b7 External VREF+ pin\n\u00b7 VDD supply voltage\nThe negative input source (VSOURCE-) of the DAC can be connected to:\n\u00b7 External VREF- pin\n\u00b7 Vss",
    "FIGURE 38-1: DIGITAL-TO-ANALOG CONVERTER BLOCK DIAGRAM\nThe output of the DAC (DAC1_output) can be selected as a reference voltage to the following:\n\u00b7 Comparator positive input\n\u00b7 ADC input channel\n\u00b7 DAC1OUT1 pin\n\u00b7 DAC1OUT2 pin\nThe Digital-to-Analog Converter (DAC) can be enabled by setting the EN bit of the DAC1CON0 register.",
    "38.1 Output Voltage Selection\nThe DAC has 32 voltage level ranges. The 32 levels are  set  with  the  DATA<4:0>  bits  of  the  DAC1CON1 register.\nThe DAC output voltage can be determined by using Equation 38-1.",
    "38.2 Ratiometric Output Level\nThe DAC output value is derived using a resistor ladder with  each  end  of  the  ladder  tied  to  a  positive  and negative voltage reference input source. If the voltage of  either  input  source  fluctuates,  a  similar  fluctuation will result in the DAC output value.\nThe value of the individual resistors within the ladder can be found in Table 45-16.",
    "38.3 DAC Voltage Reference Output\nThe  unbuffered  DAC  voltage  can  be  output  to  the DAC1OUTn pin(s) by setting the respective DACOEn bit(s)  of  the  DAC1CON0  register.  Selecting  the  DAC reference voltage for output on either DAC1OUTn pin automatically  overrides  the  digital  output  buffer,  the weak  pull-up and  digital input threshold detector functions of that pin.",
    "IF DACEN = 1\n<!-- formula-not-decoded -->\nNote: See the DAC1CON0 register for the available VSOURCE+ and VSOURCE- selections.\nReading the DAC1OUTn  pin  when  it has been configured for DAC  reference  voltage  output will always return a ' 0 '.\nNote:\nThe unbuffered DAC output (DAC1OUTn) is not intended to drive an external load.",
    "38.4 Operation During Sleep\nWhen  the  device  wakes  up  from  Sleep  through  an interrupt or a Windowed Watchdog Timer Time-out, the contents of the DAC1CON0 register are not affected. To minimize current consumption in Sleep mode, the voltage reference should be disabled.",
    "38.5 Effects of a Reset\nA device Reset affects the following:\n\u00b7 DAC1 is disabled.\n\u00b7 DAC1 output voltage is removed from the DAC1OUTn pin(s).\n\u00b7 The DAC1R<4:0> range select bits are cleared.",
    "38.6 Register Definitions: DAC Control\nLong bit name prefixes for the DAC peripheral is shown below. Refer to Section 1.3.2.2 'Long Bit Names' for more information.\nDAC1, Bit Name Prefix = DAC1\nl",
    "REGISTER 38-1: DAC1CON0: DAC CONTROL REGISTER\nEN, U-0 = -. EN, R/W-0/0 = OE1. EN, R/W-0/0 = OE2. EN, R/W-0/0 = PSS<1:0>. EN, R/W-0/0 = PSS<1:0>. EN, U-0 = -. EN, R/W-0/0 = NSS. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0",
    "REGISTER 38-1: DAC1CON0: DAC CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = \nbit 7\nEN: DAC Enable bit\n1 = DAC is enabled\n0 = DAC is disabled (1)\nbit 6\nUnimplemented: Read as ' 0 '\nbit 5\nOE1: DAC Voltage Output Enable bit\n1 = DAC voltage level is output on the DAC1OUT1 pin\n0 = DAC voltage level is disconnected from the DAC1OUT1 pin\nbit 4\nOE2: DAC Voltage Output Enable bit\n1 = DAC voltage level is output on the DAC1OUT2 pin",
    "REGISTER 38-1: DAC1CON0: DAC CONTROL REGISTER\n0 = DAC voltage level is disconnected from the DAC1OUT2 pin\nbit 3-2\nPSS<1:0>: DAC Positive Source Select bit\n11 = Reserved\n10 = FVR buffer 2\n01 = VREF+\n00 = VDD\nbit 1\nUnimplemented: Read as ' 0 '\nbit 0\nNSS: DAC Negative Source Select bit\n1 = VREF-\n0 = VSS\nNote 1: DAC1OUTx output pins are still active.",
    "REGISTER 38-2: DAC1CON1: DAC DATA REGISTER\n-, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = . -, R/W-0/0 = DATA<4:0>. -, R/W-0/0 = . -, R/W-0/0 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "REGISTER 38-2: DAC1CON1: DAC DATA REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7-5\nUnimplemented: Read as ' 0 '\nbit 4-0\nDATA<4:0>:\nData Input Register for DAC bits",
    "TABLE 38-1: SUMMARY OF REGISTERS ASSOCIATED WITH THE DAC MODULE\nDAC1CON0, Bit 7 = EN. DAC1CON0, Bit 6 = -. DAC1CON0, Bit 5 = OE1. DAC1CON0, Bit 4 = OE2. DAC1CON0, Bit 3 = PSS<1:0>. DAC1CON0, Bit 2 = PSS<1:0>. DAC1CON0, Bit 1 = -. DAC1CON0, Bit 0 = NSS. DAC1CON0, Register on page = 694. DAC1CON1, Bit 7 = -. DAC1CON1, Bit 6 = -. DAC1CON1, Bit 5 = -. DAC1CON1, Bit 4 = DATA<4:0>. DAC1CON1, Bit 3 = DATA<4:0>. DAC1CON1, Bit 2 = DATA<4:0>. DAC1CON1, Bit 1 = DATA<4:0>. DAC1CON1, Bit 0 = DATA<4:0>. DAC1CON1, Register on page =",
    "TABLE 38-1: SUMMARY OF REGISTERS ASSOCIATED WITH THE DAC MODULE\n695\nLegend: - = Unimplemented location, read as ' 0 '. Shaded cells are not used with the DAC module.",
    "39.0 COMPARATOR MODULE\nNote:, 1 = The PIC18(L)F25/26K83 devices have two comparators. Therefore, all informa - tion in this section refers to both C1 and C2.\nComparators are used to interface analog circuits to a digital  circuit  by  comparing  two  analog  voltages  and providing a digital indication of their relative magnitudes. Comparators  are  very  useful  mixed  signal  building blocks because they provide analog functionality independent of program execution.\nThe analog comparator module includes the following features:\n\u00b7 Programmable input selection\n\u00b7 Programmable output polarity\n\u00b7 Rising/falling output edge interrupts",
    "39.1 Comparator Overview\nA single comparator is shown in Figure 39-1 along with the  relationship  between the  analog  input  levels  and the digital output. When the analog voltage at VIN+ is less than the analog voltage at VIN-, the output of the comparator  is  a  digital  low  level.  When  the  analog voltage at VIN+ is greater than the analog voltage at VIN-, the output of the comparator is a digital high level.",
    "39.2 Comparator Control\nEach comparator has two control registers: CMxCON0 and CMxCON1.\nThe  CMxCON0  register  (see  Register 39-1)  contains Control and Status bits for the following:\n\u00b7 Enable\n\u00b7 Output\n\u00b7 Output polarity\n\u00b7 Hysteresis enable\n\u00b7 Timer1 output synchronization\nThe  CMxCON1  register  (see  Register 39-2)  contains Control bits for the following:\n- \u00b7 Interrupt on positive/negative edge enables\nThe  CMxPCH  and  CMxNCH  registers  are  used  to select the positive and negative input channels, respectively.",
    "39.2.1 COMPARATOR ENABLE\nSetting the EN bit of the CMxCON0 register enables the comparator for operation. Clearing the EN bit dis -ables the comparator resulting in minimum current con -sumption.",
    "39.2.2 COMPARATOR OUTPUT\nThe  output  of  the  comparator  can  be  monitored  by reading either the CxOUT bit of the CMxCON0 register or the CxOUT bit of the CMOUT register.\nThe  comparator  output  can  also  be  routed  to  an external pin through the RxyPPS register (Register 17-2). The corresponding TRIS bit must be clear to enable the pin as an output.\nNote 1: The internal output of the comparator is latched with each instruction cycle. Unless otherwise specified, external out -puts are not latched.",
    "39.2.3 COMPARATOR OUTPUT POLARITY\nInverting  the  output  of  the  comparator  is  functionally equivalent  to  swapping  the  comparator  inputs.  The polarity  of  the  comparator  output  can  be  inverted  by setting the POL bit of the CMxCON0 register. Clearing the POL bit results in a noninverted output.\nTable 39-1 shows the output state versus input conditions, including polarity control.",
    "TABLE 39-1: COMPARATOR OUTPUT STATE VS. INPUT CONDITIONS\nCxVN > CxVP, POL = 0. CxVN > CxVP, CxOUT = 0. CxVN < CxVP, POL = 0. CxVN < CxVP, CxOUT = 1. CxVN > CxVP, POL = 1. CxVN > CxVP, CxOUT = 1. CxVN < CxVP, POL = 1. CxVN < CxVP, CxOUT = 0",
    "39.3 Comparator Hysteresis\nA  selectable  amount  of  separation  voltage  can  be added to the input pins of each comparator to provide a hysteresis function to the overall operation. Hysteresis is  enabled  by  setting  the  HYS  bit  of  the  CMxCON0 register.\nSee Comparator Specifications in Table 45-15 for more information.",
    "39.3.1 COMPARATOR OUTPUT SYNCHRONIZATION\nThe  output  from  a  comparator  can  be  synchronized with Timer1 by setting the SYNC bit of the CMxCON0 register.\nOnce enabled, the comparator output is latched on the falling edge of the Timer1 source clock. If a prescaler is used, the CxOUT bit is synchronized with the timer, so that the software sees no ambiguity due to timing. See the Comparator Block Diagram (Figure 39-2) and the Timer1 Block Diagram (Figure 21-1) for more information.",
    "39.4 Comparator Interrupt\nAn interrupt can be generated for every rising or falling edge of the comparator output.\nWhen either edge detector is triggered and its associ -ated  enable  bit  is  set  (INTP  and/or  INTN  bits  of  the CMxCON1 register), the Corresponding Interrupt Flag bit (CxIF bit of the respective PIR register) will be set.\nTo enable the interrupt, you must set the following bits:\n\u00b7 EN bit of the CMxCON0 register\n\u00b7 CxIE bit of the respective PIE register\n\u00b7 INTP bit of the CMxCON1 register (for a rising edge detection)\n\u00b7 INTN bit of the CMxCON1 register (for a falling edge detection)\n\u00b7 GIE bit of the INTCON0 register\nThe  associated  interrupt  flag  bit, CxIF  bit of the respective PIR register, must be cleared in software. If another  edge  is  detected  while  this  flag  is  being cleared,  the  flag  will  still  be  set  at  the  end  of  the sequence.",
    "Note:\nAlthough  a  comparator  is  disabled,  an interrupt  can  be  generated  by  changing the output polarity with the POL bit of the CMxCON0  register,  or  by  switching  the comparator on or off with the EN bit of the CMxCON0 register.",
    "39.5 Comparator Positive Input Selection\nConfiguring the PCH<2:0> bits of the CMxPCH register directs an internal voltage reference or an analog pin to the non-inverting input of the comparator:\n\u00b7 CxIN0+, CxIN1+ analog pin\n\u00b7 DAC output\n\u00b7 FVR (Fixed Voltage Reference)\n\u00b7 VSS (Ground)\nSee Section 35.0 'Fixed Voltage Reference (FVR)' for  more information on the Fixed Voltage Reference module.\nSee Section 38.0 '5-Bit Digital-to-Analog Converter (DAC) Module' for more information on the DAC input signal.\nAny time the comparator is disabled (EN = 0 ), all com -parator inputs are disabled.",
    "39.6 Comparator Negative Input Selection\nThe NCH<2:0> bits of the CMxNCH register direct an analog input pin and internal reference voltage or ana -log ground to the inverting input of the comparator:\n\u00b7 CxIN0-, CxIN1-, CxIN2-, CxIN3- analog pin\n\u00b7 FVR (Fixed Voltage Reference)\n\u00b7 Analog Ground\nNote:\nTo use CxINy+ and CxINy- pins as analog input, the appropriate bits must be set in the ANSEL register and the correspond -ing TRIS bits must also be set to disable the output drivers.",
    "39.7 Comparator Response Time\nThe comparator output is indeterminate for a period of time after the change of an input source or the selection of a new reference voltage. This period is referred to as the response time. The response time of the comparator differs  from  the  settling  time  of  the  voltage  reference. Therefore, both of these times must be considered when determining  the  total  response  time  to  a  comparator input change. See the Comparator and Voltage Reference Specifications in Table 45-15 and Table 4517 for more details.",
    "39.8 Analog Input Connection Considerations\nA  simplified  circuit  for  an  analog  input  is  shown  in Figure 39-3.  Since  the  analog  input  pins  share  their connection  with  a  digital  input,  they  have  reverse biased  ESD  protection  diodes  to  VDD  and  VSS.  The analog input, therefore, must be between VSS and VDD. If  the  input voltage deviates from this range by more than  0.6V  in  either  direction,  one  of  the  diodes  is forward biased and a latch-up may occur.\nA maximum source impedance of 10 k \uf057 is recommended for  the  analog  sources. Also,  any  external  component connected to an analog input pin, such as a capacitor or a Zener diode, should have very little leakage current to minimize inaccuracies introduced.\nNote 1: When reading a PORT register, all pins configured as analog inputs will read as a ' 0 '.  Pins  configured as digital inputs will convert as an analog input, according to the input specification.\n2: Analog  levels  on  any  pin  defined  as  a digital input, may cause the input buffer to consume more current than is specified.\nFIGURE 39-3:\nANALOG INPUT MODEL",
    "39.9 CWG1 Auto-Shutdown Source\nThe output of the comparator module can be used as an auto-shutdown source for the CWG1 module. When the output of the comparator is active and the corresponding WGASxE is enabled, the CWG operation will be suspended immediately (see Section 26.10.1.2 'External Input Source' ).",
    "39.10 ADC Auto-Trigger Source\nThe output of the comparator module can be used to trigger an ADC conversion. When the ADACT register is  set  to  trigger  on  a  comparator  output,  an  ADC conversion  will  trigger  when  the  Comparator  output goes high.",
    "39.11 TMR2/4/6 Reset\nThe output of the comparator module can be used to reset Timer2. When the TxERS register is appropriately set, the timer will reset when the Comparator output goes high.",
    "39.12 Operation in Sleep Mode\nThe comparator module can operate during Sleep. The comparator clock source is based on the Timer1 clock source. If the Timer1 clock source is either the system clock (FOSC) or the instruction clock (FOSC/4), Timer1 will not operate during Sleep, and synchronized comparator outputs will not operate.\nA comparator interrupt will wake the device from Sleep. The CxIE bits of the respective PIE register must be set to enable comparator interrupts.",
    "39.13 Register Definitions: Comparator Control\nLong bit name prefixes for the Comparators are shown\nin Table 39-2.  Refer  to Section  1.3.2.2 'Long  Bit Names' for more information.",
    "TABLE 39-2:\nC1, Bit Name Prefix = C1. C2, Bit Name Prefix = C2",
    "REGISTER 39-1: CMxCON0: COMPARATOR x CONTROL REGISTER 0\nR/W-0/0, 1 = R-0/0. R/W-0/0, 2 = U-0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = U-1. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. EN, 1 = OUT. EN, 2 = -. EN, 3 = POL. EN, 4 = -. EN, 5 = -. EN, 6 = HYS. EN, 7 = SYNC. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 39-1: CMxCON0: COMPARATOR x CONTROL REGISTER 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 EN: Comparator Enable bit\n1 = Comparator is enabled\n0 = Comparator is disabled and consumes no active power",
    "bit 6\nOUT: Comparator Output bit\nIf POL = 0 (noninverted polarity):\n1 = CxVP > CxVN\n0 = CxVP < CxVN\nIf POL = 1 (inverted polarity):\n1 = CxVP < CxVN\n0 = CxVP > CxVN",
    "bit 4 POL: Comparator Output Polarity Select bit\n1 = Comparator output is inverted\n0 = Comparator output is not inverted\nbit 3 Unimplemented: Read as ' 0 '\nbit 2\nUnimplemented: Read as ' 1 '\nbit 1\nHYS: Comparator Hysteresis Enable bit\n1 = Comparator hysteresis enabled\n0 =   Comparator hysteresis disabled",
    "bit 0 SYNC: Comparator Output Synchronous Mode bit\n1 = Comparator output to Timer1/3/5 and I/O pin is synchronous to changes on Timer1 clock source.\n0 = Comparator output to Timer1/3/5 and I/O pin is asynchronous\nOutput updated on the falling edge of Timer1/3/5 clock source.",
    "REGISTER 39-2: CMxCON1: COMPARATOR x CONTROL REGISTER 1\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-0/0 = INTP. -, R/W-0/0 = INTN. bit 7, U-0 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "REGISTER 39-2: CMxCON1: COMPARATOR x CONTROL REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-2\nUnimplemented: Read as ' 0 '\nbit 1 INTP : Comparator Interrupt on Positive-Going Edge Enable bit\n1 = The CxIF interrupt flag will be set upon a positive-going edge of the CxOUT bit\n0 = No interrupt flag will be set on a positive-going edge of the CxOUT bit\nbit 0\nINTN : Comparator Interrupt on Negative-Going Edge Enable bit",
    "REGISTER 39-2: CMxCON1: COMPARATOR x CONTROL REGISTER 1\n1 = The CxIF interrupt flag will be set upon a negative-going edge of the CxOUT bit\n0 = No interrupt flag will be set on a negative-going edge of the CxOUT bit",
    "REGISTER 39-3: CMxNCH: COMPARATOR x INVERTING CHANNEL SELECT REGISTER\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = NCH<2:0>. -, R/W-0/0 = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 39-3: CMxNCH: COMPARATOR x INVERTING CHANNEL SELECT REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-3 Unimplemented: Read as ' 0 '\nbit 2-0 NCH<2:0>: Comparator Inverting Input Channel Select bits\n111 = VSS\n110 = FVR_Buffer2\n101 = NCH not connected\n100 = NCH not connected\n011 = CxIN3-\n010 = CxIN2-\n001 = CxIN1-\n000 = CxIN0-\nDS40001943C-page 703",
    "REGISTER 39-4: CMxPCH: COMPARATOR x NON-INVERTING CHANNEL SELECT REGISTER\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-0/0 = . -, R/W-0/0 = PCH<2:0>. -, R/W-0/0 = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 39-4: CMxPCH: COMPARATOR x NON-INVERTING CHANNEL SELECT REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-3 Unimplemented: Read as ' 0 '\nbit 2-0 PCH<2:0>: Comparator Non-Inverting Input Channel Select bits\n111 = VSS\n110 = FVR_Buffer2\n101 = DAC_Output\n100 = PCH not connected\n011 = PCH not connected\n010 = PCH not connected\n001 = CxIN1+\n000 = CxIN0+",
    "REGISTER 39-5: CMOUT: COMPARATOR OUTPUT REGISTER\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, R-0/0 = C2OUT. -, R-0/0 = C1OUT. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R-0/0 = bit 7. bit 7, R-0/0 = bit 0",
    "REGISTER 39-5: CMOUT: COMPARATOR OUTPUT REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-2\nUnimplemented: Read as ' 0 '\nbit 1\nC2OUT: Mirror copy of C2OUT bit\nbit 0\nC1OUT: Mirror copy of C1OUT bit",
    "TABLE 39-3: SUMMARY OF REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nCMxCON0, Bit 7 = EN. CMxCON0, Bit 6 = OUT. CMxCON0, Bit 5 = -. CMxCON0, Bit 4 = POL. CMxCON0, Bit 3 = -. CMxCON0, Bit 2 = -. CMxCON0, Bit 1 = HYS. CMxCON0, Bit 0 = SYNC. CMxCON0, Reset Values on page = 702. CMxCON1, Bit 7 = -. CMxCON1, Bit 6 = -. CMxCON1, Bit 5 = -. CMxCON1, Bit 4 = -. CMxCON1, Bit 3 = -. CMxCON1, Bit 2 = -. CMxCON1, Bit 1 = INTP. CMxCON1, Bit 0 = INTN. CMxCON1, Reset Values on page = 703. CMxNCH, Bit 7 = -. CMxNCH, Bit 6 = -. CMxNCH, Bit 5 = -. CMxNCH, Bit 4 = -. CMxNCH, Bit 3 = -. CMxNCH, Bit 2 =",
    "TABLE 39-3: SUMMARY OF REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nNCH<2:0>. CMxNCH, Bit 1 = NCH<2:0>. CMxNCH, Bit 0 = NCH<2:0>. CMxNCH, Reset Values on page = 703. CMxPCH, Bit 7 = -. CMxPCH, Bit 6 = -. CMxPCH, Bit 5 = -. CMxPCH, Bit 4 = -. CMxPCH, Bit 3 = -. CMxPCH, Bit 2 = PCH<2:0>. CMxPCH, Bit 1 = PCH<2:0>. CMxPCH, Bit 0 = PCH<2:0>. CMxPCH, Reset Values on page = 704. CMOUT, Bit 7 = -. CMOUT, Bit 6 = -. CMOUT, Bit 5 = -. CMOUT, Bit 4 = -. CMOUT, Bit 3 = -. CMOUT, Bit 2 = -. CMOUT, Bit 1 = C2OUT. CMOUT, Bit 0 = C1OUT. CMOUT, Reset Values on page = 704\nLegend:",
    "TABLE 39-3: SUMMARY OF REGISTERS ASSOCIATED WITH COMPARATOR MODULE\n- = unimplemented, read as ' 0 '. Shaded cells are unused by the comparator module.",
    "40.0 HIGH/LOW-VOLTAGE DETECT (HLVD)\nThe PIC18(L)F25/26K83 family of devices has a High/ Low-Voltage Detect module (HLVD). This is a program -mable circuit that sets both a device voltage trip point and  the  direction  of  change  from  that  point  (positive going, negative going or both). If the device experiences an excursion past the trip point in that direction, an inter -rupt flag is set. If the interrupt is enabled, the program execution branches to the interrupt vector address and the software responds to the interrupt.\nComplete  control  of  the  HLVD  module  is  provided through the HLVDCON0 and HLVDCON1 register. This allows the circuitry to be 'turned off' by the user under software control, which minimizes the current consumption for the device.\nThe module's block diagram is shown in Figure 40-1.",
    "40.0 HIGH/LOW-VOLTAGE DETECT (HLVD)\nSince the HLVD can be software enabled through the EN  bit,  setting  and  clearing  the  enable  bit  does  not produce a false HLVD event glitch. Each time the HLVD module is enabled, the circuitry requires some time to stabilize. The RDY bit (HLVDCON0<4>) is a read-only bit  used  to  indicate  when  the  band  gap  reference voltages are stable.\nThe module can only generate an interrupt after  the module  is  turned  ON  and  the  band  gap  reference voltages are ready.\nThe INTH and INTL bits determine the overall operation of the module. When INTH is set, the module monitors for rises in VDD above the trip point set by the HLVDCON1 register.  When  INTL  is  set,  the  module monitors for drops in VDD below the trip point set by the HLVDCON1 register. When both the INTH and INTL bits are set, any changes above or below the trip point set by the HLVDCON1 register can be monitored.\nThe OUT bit can be read to determine if the voltage is greater than or less than the voltage level selected by the HLVDCON1 register.",
    "40.1 Operation\nWhen the HLVD module is enabled, a comparator uses an  internally  generated  voltage  reference  as  the  set point.  The  set  point  is  compared  with  the  trip  point, where each node in the resistor divider represents a trip point voltage. The 'trip point' voltage is the voltage level at which the device detects a high or low-voltage event, depending on the configuration of the module.\nWhen the supply voltage is equal to the trip point, the voltage tapped off of the resistor array is equal to the internal  reference  voltage  generated  by  the  voltage reference module. The comparator then generates an interrupt signal by setting the HLVDIF bit.\nThe trip point voltage is software programmable to any of SEL<3:0> bits (HLVDCON1<3:0>).",
    "40.2 HLVD Setup\nTo set up the HLVD module:\n1. Select the desired HLVD trip point by writing the value to the SEL<3:0> bits of the HLVDCON1 register.\n2. Depending on the application to detect high voltage peaks or low-voltage drops or both, -set the INTH or INTL bit appropriately.\n3. Enable the HLVD module by setting the EN bit.\n4. Clear  the  HLVD  interrupt  flag  (PIR2  register), which may have been set from a previous inter -rupt.\n5. If interrupts are desired, enable  the  HLVD interrupt  by  setting  the  HLVDIE  in  the  PIE2 register and GIE bits.\nAn interrupt will not be generated until the RDY bit is set.",
    "Note:\nBefore changing any module  settings (INTH,  INTL,  SEL<3:0>),  first  disable  the module (EN = 0 ), make the changes and re-enable  the  module. This prevents the generation of false HLVD events.",
    "40.3 Current Consumption\nWhen the  module is  enabled,  the  HLVD  comparator and  voltage  divider  are  enabled  and  consume  static current. The total current consumption, when enabled, is specified in electrical specification Parameter D206 (Table 45-3).\nDepending on the application, the HLVD module does not  need  to  operate  constantly.  To  reduce  current requirements, the HLVD circuitry may only need to be enabled for short periods where the voltage is checked. After such a check, the module could be disabled.",
    "40.4 HLVD Start-up Time\nThe  internal  reference  voltage  of  the  HLVD  module, specified in electrical specification (Table 45-17), may be used  by  other internal circuitry, such  as the programmable Brown-out Reset. If the HLVD or other circuits  using  the  voltage  reference  are  disabled  to lower the device's current consumption, the reference voltage circuit will require time to become stable before a low or high-voltage condition can be reliably detected. This start-up time, TFVRST, is an interval that is independent of device clock speed. It is specified in electrical specification (Table 45-17).\nThe HLVD interrupt flag is not enabled until TFVRST has expired and a stable reference voltage is reached. For this reason, brief excursions beyond the set point may not be detected during this interval (see Figure 40-2 or Figure 40-3).",
    "40.5 Applications\nIn  many  applications,  it  is  desirable  to  detect  a  drop below, or rise above, a particular voltage threshold. For example, the HLVD  module  could be periodically enabled to detect Universal Serial Bus (USB) attach or detach. This assumes the device is powered by a lower voltage source than the USB when detached. An attach would indicate a High-Voltage Detect from, for example, 3.3V to 5V (the voltage on USB) and vice versa for a detach. This  feature  could  save  a  design  a  few  extra components and an attach signal (input pin).\nFIGURE 40-4: TYPICAL LOW-VOLTAGE DETECT APPLICATION\nFor general battery applications, Figure 40-4 shows a possible voltage curve. Over time, the device voltage decreases. When the device voltage reaches voltage, VA, the HLVD logic generates an interrupt at time, TA. The interrupt could cause the execution of an Interrupt Service Routine (ISR), which would allow the applica -tion to perform 'housekeeping tasks' and a controlled shutdown  before  the  device  voltage  exits  the  valid operating range at TB. This would give the application a time window, represented by the difference between TA and TB, to safely exit.",
    "40.6 Operation During Sleep\nWhen enabled, the HLVD circuitry continues to operate during  Sleep.  If  the  device  voltage  crosses  the  trip point,  the  HLVDIF  bit  will  be  set  and  the  device  will wake  up  from  Sleep.  Device  execution  will  continue from  the  interrupt  vector  address  if  interrupts  have been globally enabled.",
    "40.7 Operation During Idle and Doze Modes\nIn both Idle and Doze modes, the module is active and events are generated if peripheral is enabled.",
    "40.8 Operation During Freeze\nWhen in Freeze mode, no new event or interrupt can be generated. The state of the LRDY bit is frozen.\nRegister reads and writes through the CPU interface are allowed.",
    "40.9 Effects of a Reset\nA device Reset forces all registers to their Reset state. This forces the HLVD module to be turned off.",
    "40.10 Register Definitions: HLVD Control\nLong  bit  name  prefixes  for  the  HLVD  peripheral  is shown in Table 40-1. Refer to Section 1.3.2.2 'Long Bit Names' for more information.",
    "TABLE 40-1:\nHLVD, Bit Name Prefix = HLVD",
    "REGISTER 40-1: HLVDCON0: HIGH/LOW-VOLTAGE DETECT CONTROL REGISTER 0\nEN, U-0 = -. EN, R-x = OUT. EN, R-x = RDY. EN, U-0 = -. EN, U-0 = -. EN, R/W-0/0 = INTH. EN, R/W-0/0 = INTL. bit 7, U-0 = . bit 7, R-x = . bit 7, R-x = . bit 7, U-0 = . bit 7, U-0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "REGISTER 40-1: HLVDCON0: HIGH/LOW-VOLTAGE DETECT CONTROL REGISTER 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nEN: High/Low-voltage Detect Power Enable bit\n1 = Enables HLVD, powers up HLVD circuit and supporting reference circuitry\n0 = Disables HLVD, powers down HLVD and supporting circuitry",
    "bit 6 Unimplemented: Read as '0'\nbit 5\nOUT: HLVD Comparator Output bit\n1 = Voltage \uf0a3 selected detection limit (HLVDL<3:0>)\n0 = Voltage \uf0b3 selected detection limit (HLVDL<3:0>)\nbit 4\nRDY: Band Gap Reference Voltages Stable Status Flag bit\n1 = Indicates HLVD Module is ready and output is stable\n0 = Indicates HLVD Module is not ready",
    "bit 3-2\nUnimplemented: Read as '0'\nbit 1\nINTH: HLVD Positive going (High Voltage) Interrupt Enable\n1 = HLVDIF will be set when voltage \uf0b3 selected detection limit (SEL<3:0>)\n0 = HLVDIF will not be set\nbit 0\nINTL: HLVD Negative going (Low Voltage) Interrupt Enable\n1 = HLVDIF will be set when voltage \uf0a3 selected detection limit (SEL<3:0>)\n0 = HLVDIF will not be set",
    "REGISTER 40-2: HLVDCON1: LOW-VOLTAGE DETECT CONTROL REGISTER 1\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-0/u = . -, R/W-0/u = SEL<3:0>. -, R/W-0/u = . -, R/W-0/u = . bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 0",
    "REGISTER 40-2: HLVDCON1: LOW-VOLTAGE DETECT CONTROL REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = u = Bit is unchanged",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3-0 SEL<3:0>: High/Low Voltage Detection Limit Selection bits\n1111, Typical Voltage = Reserved. 1110, Typical Voltage = 4.65V. 1101, Typical Voltage = 4.35V. 1100, Typical Voltage = 4.20V. 1011, Typical Voltage = 4.00V. 1010, Typical Voltage = 3.75V. 1001, Typical Voltage = 3.60V. 1000, Typical Voltage = 3.35V. 0111, Typical Voltage = 3.15V. 0110, Typical Voltage = 2.90V. 0101, Typical Voltage = 2.75V. 0100, Typical Voltage = 2.60V. 0011, Typical Voltage = 2.50V. 0010, Typical Voltage = 2.25V. 0001, Typical Voltage = 2.10V. 0000, Typical Voltage = 1.90V",
    "TABLE 40-2: SUMMARY OF REGISTERS ASSOCIATED WITH HIGH/LOW-VOLTAGE DETECT MODULE\nHLVDCON0, Bit 7 = EN. HLVDCON0, Bit 6 = -. HLVDCON0, Bit 5 = OUT. HLVDCON0, Bit 4 = RDY. HLVDCON0, Bit 3 = -. HLVDCON0, Bit 2 = -. HLVDCON0, Bit 1 = INTH. HLVDCON0, Bit 0 = INTL. HLVDCON0, Register on Page = 711. HLVDCON1, Bit 7 = -. HLVDCON1, Bit 6 = -. HLVDCON1, Bit 5 = -. HLVDCON1, Bit 4 = -. HLVDCON1, Bit 3 = SEL<3:0>. HLVDCON1, Bit 2 = SEL<3:0>. HLVDCON1, Bit 1 = SEL<3:0>. HLVDCON1, Bit 0 = SEL<3:0>. HLVDCON1, Register on Page = 712\nLegend:",
    "TABLE 40-2: SUMMARY OF REGISTERS ASSOCIATED WITH HIGH/LOW-VOLTAGE DETECT MODULE\n- = unimplemented, read as ' 0 '. Shaded cells are unused by the HLVD module.",
    "41.0 IN-CIRCUIT SERIAL PROGRAMMING\u2122 (ICSP\u2122)\nICSP\u2122 programming allows customers to manufacture circuit boards with unprogrammed devices. Programming can be done after the assembly process, allowing  the device to be programmed with the most recent firmware or a custom firmware. Five pins are needed for ICSP\u2122 programming:\n\u00b7 ICSPCLK\n\u00b7 ICSPDAT\n\u00b7 MCLR/VPP\n\u00b7 VDD\n\u00b7 VSS\nIn Program/Verify mode the program memory, User IDs and the Configuration Words are programmed through serial communications. The ICSPDAT pin is a bidirectional  I/O  used  for  transferring  the  serial  data and  the  ICSPCLK  pin  is  the  clock  input.  For  more information  on  ICSP\u2122  refer  to  the ' PIC18(L)F25/ 26K82 Memory Programming Specification ' (DS40000000).",
    "41.1 High-Voltage Programming Entry Mode\nThe device is placed into High-Voltage Programming Entry  mode  by  holding  the  ICSPCLK  and  ICSPDAT pins low then raising the voltage on MCLR/VPP to VIHH.",
    "41.2 Low-Voltage Programming Entry Mode\nThe Low-Voltage Programming Entry mode allows the PIC  Flash MCUs to be programmed using VDD only, \u00ae without high voltage. When the LVP bit of Configuration Words is set to ' 1 ', the low-voltage ICSP\u2122 programming  entry  is  enabled.  To  disable  the  LowVoltage ICSP mode, the LVP bit must be programmed to ' 0 '.\nEntry into the Low-Voltage Programming Entry mode requires the following steps:\n1. MCLR is brought to VIL.\n2. A 32-bit key sequence is presented on ICSPDAT, while clocking ICSPCLK.\nOnce the key sequence is complete, MCLR must be held at VIL for as long as Program/Verify mode is to be maintained.\nIf  low-voltage programming is enabled (LVP = 1 ), the MCLR  Reset  function  is  automatically  enabled  and cannot be disabled. See Section 6.5 'MCLR ' for more information.\nThe LVP bit can only be reprogrammed to ' 0 ' by using the High-Voltage Programming mode.",
    "41.3 Common Programming Interfaces\nConnection to a target device is typically done through an  ICSP\u2122  header. A  commonly  found  connector  on development tools is the RJ-11 in the 6P6C (6-pin, 6connector) configuration. See Figure 41-1.",
    "FIGURE 41-1: ICD RJ-11 STYLE CONNECTOR INTERFACE\nAnother connector often found in use with the PICkit\u2122 programmers is a standard 6-pin header with 0.1 inch spacing. Refer to Figure 41-2.\nFor additional interface recommendations, refer to your specific device  programmer  manual  prior  to  PCB design.\nIt  is  recommended  that  isolation  devices  be  used  to separate  the  programming  pins  from  other  circuitry. The type of isolation is highly dependent on the specific application and may include devices such as resistors, diodes,  or  even  jumpers.  See  Figure 41-3  for  more information.",
    "42.0 INSTRUCTION SET SUMMARY\nPIC18(L)F25/26K83  devices  incorporate  the  standard set of PIC18 core instructions, as well as an extended set  of  instructions,  for  the  optimization  of  code  that  is recursive or that utilizes a software stack. The extended set is discussed later in this section.",
    "42.1 Standard Instruction Set\nThe standard PIC18 instruction set adds many enhancements to the previous PIC \u00ae  MCU instruction sets, while maintaining an easy migration from these PIC \u00ae   MCU  instruction  sets.  Most  instructions  are  a single program memory word (16 bits), but there are four  instructions  that  require  two-program  memory locations and two that require three-program memory locations.\nEach single-word instruction  is  a 16-bit word  divided into an opcode, which specifies the instruction type and one  or  more  operands,  which  further  specify  the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18 instruction set summary in Table 42-3 lists byte-oriented , bit-oriented , literal and control operations. Table 42-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')",
    "42.1 Standard Instruction Set\nThe  file  register  designator  'f'  specifies  which  file register is to be used by the instruction. The destination designator 'd' specifies where the result of the opera -tion is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result is placed in the file register specified in the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "42.1 Standard Instruction Set\n\u00b7 A program memory address (specified by 'n')\n\u00b7 The mode of the CALL or RETURN instructions (specified by 's')\n\u00b7 The mode of the table read and table write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll instructions  are  a  single  word,  except  for  four double-word instructions. These instructions were made double-word to contain the required information in 32 bits. In the second word, the four MSbs are ' 1 's. If this  second  word  is  executed  as  an  instruction  (by itself), it will execute as a NOP .\nAll  single-word  instructions  are  executed  in  a  single instruction cycle, unless a conditional test is true or the Program Counter is changed as a result of the instruc -tion. In these cases, the execution takes two instruction cycles, with the additional instruction cycle(s) executed as a NOP .\nThe double-word instructions execute in two instruction cycles.",
    "42.1 Standard Instruction Set\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \uf06d s. If a conditional test is true, or the Program Counter is changed as a result of an instruction, the instruction  execution  time is  2 \uf06d s. Two-word branch instructions (if true) would take 3 \uf06d s.\nFigure 42-1 shows the general formats that the instruc -tions can have. All examples use the convention 'nnh' to represent a hexadecimal number.\nThe  Instruction  Set  Summary,  shown  in  Table 42-3, lists the standard instructions recognized by the Microchip Assembler (MPASM TM ).\nSection 42.1.1 'Standard Instruction Set' provides a description of each instruction.",
    "TABLE 42-1: OPCODE FIELD DESCRIPTIONS\na, Description = RAM access bit a = 0: RAM location in Access RAM (BSR register is ignored) a = 1: RAM bank is specified by BSR register. ACCESS, Description = ACCESS = 0: RAM access bit symbol. BANKED, Description = BANKED = 1: RAM access bit symbol. bbb, Description = Bit address within an 8-bit file register (0 to 7). BSR, Description = Bank Select Register. Used to select the current RAM bank.. d, Description = Destination select bit; d = 0: store result in WREG, d = 1: store result in file register f.. dest, Description = Destination either the WREG register or the specified register file location. f, Description = 8-bit Register file address (00h to FFh). f n, Description = FSR Number (0 to 2). f s, Description = 12-bit Register file address (000h to FFFh). This is the source address.. f d, Description = 12-bit Register file address (000h to FFFh). This is the destination address.. z s, Description = 7-bit literal offset for",
    "TABLE 42-1: OPCODE FIELD DESCRIPTIONS\nFSR2 to used as register file address (000h to FFFh). This is the source address.. z d, Description = 7-bit literal offset for FSR2 to used as register file address (000h to FFFh). This is the destination address.. k, Description = Literal field, constant data or label (may be a 6-bit, 8-bit, 12-bit or a 20-bit value). label, Description = Label name. mm, Description = The mode of the TBLPTR register for the Table Read and Table Write instructions Only used with Table Read and Table Write instructions: and writes). *, Description = No Change to register (such as TBLPTR with Table reads. *+, Description = Post-Increment register (such as TBLPTR with Table reads and writes). *-, Description = Post-Decrement register (such as TBLPTR with Table reads and writes). +*, Description = Pre-Increment register (such as TBLPTR with Table reads and writes). n, Description = The relative address (2's complement number) for relative branch instructions, or the",
    "TABLE 42-1: OPCODE FIELD DESCRIPTIONS\ndirect address for Call/Branch and Return instructions. PRODH, Description = Product of Multiply high byte. PRODL, Description = Product of Multiply low byte. s, Description = Fast Call / Return mode select bit. s = 0: do not update into/from shadow registers s = 1: certain registers loaded into/from shadow registers (Fast mode). u, Description = Unused or Unchanged. W, Description = W=0: Destination select bit symbol. WREG, Description = Working register (accumulator). x, Description = Don't care (0 or 1) The assembler will generate code with x = 0 . It is the recommended form of use for compatibility with all Microchip software tools.. TBLPTR, Description = 21-bit Table Pointer (points to a Program Memory location). TABLAT, Description = 8-bit Table Latch. TOS, Description = Top-of-Stack. PC, Description = Program Counter. PCL PCH, Description = Program Counter Low Byte Program Counter High Byte. PCLATH, Description = Program Counter High Byte Latch. PCLATU, Description = Program Counter Upper Byte Latch. GIE, Description = Global Interrupt",
    "TABLE 42-1: OPCODE FIELD DESCRIPTIONS\nEnable bit. WDT, Description = Watchdog Timer. TO, Description = Time-out bit. , Description = ALU Status bits Carry, Digit Carry, Zero, Overflow,. C, DC, Z, OV,, Description = Negative. , Description = Contents. ( ), Description = . \uf0ae, Description = Assigned to",
    "TABLE 42-1: OPCODE FIELD DESCRIPTIONS (CONTINUED)\n< >, Description = Register bit field. \uf0ce, Description = In the set of. italics, Description = User defined term (font is courier)",
    "FIGURE 42-1: General Format for Instructions (1/2)\nOPCODE d a Byte to Byte move operations 15 12 11 a = 1 for BSR to select f = 8-bit file register,  = be WREG register f (FILE #) file register (2-word) bank address. OPCODE d a Byte to Byte move operations 15 12 11 a = 1 for BSR to select f = 8-bit file register, Example Instruction = ADDWF MYREG, W, B. d = 0 for result destination to d = 1 for result destination to be a = 0 to force Access Bank OPCODE f 15 12 11 1111 f f = 12-bit file register Byte to Byte move operations 15 15 12 11,",
    "FIGURE 42-1: General Format for Instructions (1/2)\n= 0 (Source FILE #) 0 (Destination FILE #) address (3-word) 4 3 OPCODE FILE #. d = 0 for result destination to d = 1 for result destination to be a = 0 to force Access Bank OPCODE f 15 12 11 1111 f f = 12-bit file register Byte to Byte move operations 15 15 12 11, Example Instruction = MOVFF MYREG1, MOVFFL MYREG1, MYREG2. file register 15 12 11 9 8 7 1111 15 12 11 1111,  = FILE FILE #. file register 15 12 11 9 8 7 1111 15 12 11 1111, Example Instruction = . Bit-oriented operations,  = 0 f (FILE #) in file register (f) bank address. Bit-oriented operations, Example Instruction = BSF MYREG, bit, B. OPCODE b (BIT #) a b = 3-bit position of bit a = 0 to force Access Bank a = 1 for BSR to select f = 8-bit file register,",
    "FIGURE 42-1: General Format for Instructions (1/2)\n= 0. OPCODE b (BIT #) a b = 3-bit position of bit a = 0 to force Access Bank a = 1 for BSR to select f = 8-bit file register, Example Instruction = . operations 8 7,  = . operations 8 7, Example Instruction = . Literal 15,  = k (literal). Literal 15, Example Instruction = MOVLW 7Fh. OPCODE,  = . OPCODE, Example Instruction = . k =,  = . k =, Example Instruction = . 8-bit immediate,  = . 8-bit immediate, Example Instruction = . value,  = . value, Example Instruction = ",
    "TABLE 42-2: INSTRUCTION SET\nBYTE-ORIENTED FILE REGISTER INSTRUCTIONS,  = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, Description. = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, Cycles. = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, Status.Affected = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, Notes. = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. ADDWF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d ,a. ADDWF, Description. = Add WREG and f. ADDWF, Cycles. = 1. ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word. = 01da. ADDWF, 16-Bit Instruction Word. = ffff. ADDWF, 16-Bit Instruction Word.LSb = ffff. ADDWF, Status.Affected = C, DC, Z, OV, N. ADDWF, Notes. = . ADDWFC,  = f, d, a. ADDWFC, Description. = Add WREG and Carry bit to f. ADDWFC, Cycles. = 1. ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word. = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status.Affected = C, DC, Z, OV, N. ADDWFC, Notes. = . ANDWF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. ANDWF, Description. = AND WREG with f. ANDWF, Cycles. = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001. ANDWF, 16-Bit Instruction Word. = 01da. ANDWF, 16-Bit Instruction Word. = ffff. ANDWF, 16-Bit Instruction Word.LSb = ffff. ANDWF, Status.Affected = Z, N. ANDWF, Notes. = . CLRF,  = f, a. CLRF, Description. = Clear f. CLRF, Cycles. = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word. = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status.Affected = Z. CLRF, Notes. = . COMF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. COMF, Description. = Complement f. COMF, Cycles. = 1. COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction Word. = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status.Affected = Z, N. COMF, Notes. = . DECF,  = f, d, a. DECF, Description. = Decrement f. DECF, Cycles. = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word. = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status.Affected = C, DC, Z, OV, N. DECF, Notes. = . INCF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. INCF, Description. = Increment f. INCF, Cycles. = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word. = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb = ffff. INCF, Status.Affected = C, DC, Z, OV, N. INCF, Notes. = . IORWF,  = f, d, a. IORWF, Description. = Inclusive OR WREG with. IORWF, Cycles. = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word. = 00da. IORWF, 16-Bit Instruction Word. = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status.Affected = Z, N. IORWF, Notes. = . MOVF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. MOVF, Description. = f Move f to WREG or f. MOVF, Cycles. = 1. MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word. = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status.Affected = Z, N. MOVF, Notes. = . MOVFF,  = f s , f d. MOVFF, Description. = Move f s (source) to 1st word. MOVFF, Cycles. = 2. MOVFF, 16-Bit Instruction Word.MSb = 1100. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word.LSb = ffff. MOVFF, Status.Affected = None. MOVFF, Notes. = 2, 3. ,",
    "TABLE 42-2: INSTRUCTION SET\n= . , Description. = f d (destination) 2nd word. , Cycles. = 3. , 16-Bit Instruction Word.MSb = 1111 0000. , 16-Bit Instruction Word. = ffff 0000. , 16-Bit Instruction Word. = ffff 0110. , 16-Bit Instruction Word.LSb = ffff ffff. , Status.Affected = None. , Notes. = 2. MOVFFL,  = f s , f d. MOVFFL, Description. = Move f s (source) to g (full destination) f d (full destination)3rd word. MOVFFL, Cycles. = . MOVFFL, 16-Bit Instruction Word.MSb = 1111 1111. MOVFFL, 16-Bit Instruction Word. = ffff gggg. MOVFFL, 16-Bit Instruction Word. = ffff gggg. MOVFFL, 16-Bit Instruction Word.LSb = ffgg gggg ffff. MOVFFL, Status.Affected = . MOVFFL, Notes. = . MOVWF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, a. MOVWF, Description. = Move WREG to f WREG with f. MOVWF, Cycles. = 1. MOVWF, 16-Bit Instruction Word.MSb = 0110. MOVWF, 16-Bit Instruction Word. = 111a. MOVWF, 16-Bit Instruction Word. = ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff. MOVWF, Status.Affected = None. MOVWF, Notes. = . MULWF,  = f, a. MULWF, Description. = Multiply. MULWF, Cycles. = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word. = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = . MULWF, Status.Affected = None. MULWF, Notes. = . NEGF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, a. NEGF, Description. = Negate f. NEGF, Cycles. = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word. = 110a. NEGF, 16-Bit Instruction Word. = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status.Affected = C, DC, Z, OV, N. NEGF, Notes. = . RLCF,  = f, d, a. RLCF, Description. = Rotate Left f through Carry. RLCF, Cycles. = 1. RLCF, 16-Bit Instruction Word.MSb = 0011. RLCF, 16-Bit Instruction Word. = 01da. RLCF, 16-Bit Instruction Word. = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status.Affected = C, Z, N. RLCF, Notes. = . RLNCF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. RLNCF, Description. = Rotate Left f (No Carry). RLNCF, Cycles. = 1. RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word. = 01da. RLNCF, 16-Bit Instruction Word. = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status.Affected = Z, N. RLNCF, Notes. = . RRCF,  = f, d, a. RRCF, Description. = Rotate Right f through Carry. RRCF, Cycles. = 1. RRCF, 16-Bit Instruction Word.MSb = 0011. RRCF, 16-Bit Instruction Word. = 00da. RRCF, 16-Bit Instruction Word. = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status.Affected = C, Z, N. RRCF, Notes. = . RRNCF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. RRNCF, Description. = Rotate Right f (No Carry). RRNCF, Cycles. = 1. RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word. = 00da. RRNCF, 16-Bit Instruction Word. = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff. RRNCF, Status.Affected = Z, N. RRNCF, Notes. = . SETF,  = f, a. SETF, Description. = Set f. SETF, Cycles. = 1. SETF, 16-Bit Instruction Word.MSb = 0110. SETF, 16-Bit Instruction Word. = 100a. SETF, 16-Bit Instruction Word. = ffff. SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status.Affected = None. SETF, Notes. = . SUBFWB,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. SUBFWB, Description. = Subtract f from WREG with borrow. SUBFWB, Cycles. = 1. SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word. = 01da. SUBFWB, 16-Bit Instruction Word. = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff. SUBFWB, Status.Affected = C, DC, Z, OV, N. SUBFWB, Notes. = . SUBWF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. SUBWF, Description. = Subtract WREG from f. SUBWF, Cycles. = 1. SUBWF, 16-Bit Instruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word. = 11da. SUBWF, 16-Bit Instruction Word. = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status.Affected = C, DC, Z, OV, N N. SUBWF, Notes. = . SUBWFB,  = f, d, a. SUBWFB, Description. = Subtract WREG from f with borrow. SUBWFB, Cycles. = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction Word. = 10da. SUBWFB, 16-Bit Instruction Word. = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status.Affected = C, DC, Z, OV,. SUBWFB, Notes. = . SWAPF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. SWAPF, Description. = Swap nibbles in f. SWAPF, Cycles. = 1. SWAPF, 16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word. = 10da. SWAPF, 16-Bit Instruction Word. = ffff. SWAPF, 16-Bit Instruction Word.LSb = ffff. SWAPF, Status.Affected = None. SWAPF, Notes. = . XORWF,  = f, d, a. XORWF, Description. = Exclusive OR WREG with f. XORWF, Cycles. = 1. XORWF, 16-Bit Instruction Word.MSb = 0001. XORWF, 16-Bit Instruction Word. = 10da. XORWF, 16-Bit Instruction Word. = ffff. XORWF, 16-Bit Instruction Word.LSb = ffff. XORWF, Status.Affected = Z, N. XORWF, Notes. = . BYTE-ORIENTED SKIP INSTRUCTIONS,",
    "TABLE 42-2: INSTRUCTION SET\n= BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, Description. = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, Cycles. = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, 16-Bit Instruction Word. = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, 16-Bit Instruction Word. = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, Status.Affected = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, Notes. = BYTE-ORIENTED SKIP INSTRUCTIONS. CPFSEQ,",
    "TABLE 42-2: INSTRUCTION SET\n= f, a. CPFSEQ, Description. = Compare f with WREG, skip =. CPFSEQ, Cycles. = 1 (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word. = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status.Affected = None. CPFSEQ, Notes. = 1. CPFSGT,  = f, a. CPFSGT, Description. = Compare f with WREG, skip >. CPFSGT, Cycles. = 1 (2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word. = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status.Affected = None. CPFSGT, Notes. = 1. CPFSLT,",
    "TABLE 42-2: INSTRUCTION SET\n= f, a. CPFSLT, Description. = Compare f with WREG, skip <. CPFSLT, Cycles. = 1 (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word. = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status.Affected = None. CPFSLT, Notes. = 1. DECFSZ,  = f, d, a. DECFSZ, Description. = Decrement f, Skip if 0. DECFSZ, Cycles. = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word. = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status.Affected = None. DECFSZ, Notes. = 1. DCFSNZ,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. DCFSNZ, Description. = Decrement f, Skip if Not 0. DCFSNZ, Cycles. = 1 (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word. = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ, 16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status.Affected = None. DCFSNZ, Notes. = 1. INCFSZ,  = f, d, a. INCFSZ, Description. = Increment f, Skip if 0. INCFSZ, Cycles. = 1 (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word. = 11da. INCFSZ, 16-Bit Instruction Word. = ffff. INCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status.Affected = None. INCFSZ, Notes. = 1. INFSNZ,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. INFSNZ, Description. = Increment f, Skip if Not 0. INFSNZ, Cycles. = 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ, 16-Bit Instruction Word. = 10da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status.Affected = None. INFSNZ, Notes. = 1. TSTFSZ,  = f, a. TSTFSZ, Description. = Test f, skip if 0. TSTFSZ, Cycles. = 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word.MSb = 0110. TSTFSZ, 16-Bit Instruction Word. = 011a. TSTFSZ, 16-Bit Instruction Word. = ffff. TSTFSZ, 16-Bit Instruction Word.LSb = ffff. TSTFSZ, Status.Affected = None. TSTFSZ, Notes. = 1. BIT-ORIENTED FILE REGISTER INSTRUCTIONS,",
    "TABLE 42-2: INSTRUCTION SET\n= BIT-ORIENTED FILE REGISTER INSTRUCTIONS. BIT-ORIENTED FILE REGISTER INSTRUCTIONS, Description. = BIT-ORIENTED FILE REGISTER INSTRUCTIONS. BIT-ORIENTED FILE REGISTER INSTRUCTIONS, Cycles. = BIT-ORIENTED FILE REGISTER INSTRUCTIONS. BIT-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED FILE REGISTER INSTRUCTIONS. BIT-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word. = BIT-ORIENTED FILE REGISTER INSTRUCTIONS. BIT-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word. = BIT-ORIENTED FILE REGISTER INSTRUCTIONS. BIT-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word.LSb = BIT-ORIENTED FILE REGISTER INSTRUCTIONS. BIT-ORIENTED FILE REGISTER INSTRUCTIONS, Status.Affected = BIT-ORIENTED FILE REGISTER INSTRUCTIONS. BIT-ORIENTED FILE REGISTER INSTRUCTIONS, Notes. = BIT-ORIENTED FILE REGISTER INSTRUCTIONS. BCF,",
    "TABLE 42-2: INSTRUCTION SET\n= f, b, a. BCF, Description. = Bit Clear f. BCF, Cycles. = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word. = bbba. BCF, 16-Bit Instruction Word. = ffff. BCF, 16-Bit Instruction Word.LSb = ffff. BCF, Status.Affected = None. BCF, Notes. = . BSF,  = f, b, a. BSF, Description. = Bit Set f. BSF, Cycles. = 1. BSF, 16-Bit Instruction Word.MSb = 1000. BSF, 16-Bit Instruction Word. = bbba. BSF, 16-Bit Instruction Word. = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status.Affected = None. BSF, Notes. = . BTG,",
    "TABLE 42-2: INSTRUCTION SET\n= f, d, a. BTG, Description. = Bit Toggle f. BTG, Cycles. = 1. BTG, 16-Bit Instruction Word.MSb = 0111. BTG, 16-Bit Instruction Word. = bbba. BTG, 16-Bit Instruction Word. = ffff. BTG, 16-Bit Instruction Word.LSb = ffff. BTG, Status.Affected = None. BTG, Notes. = . BIT-ORIENTED SKIP INSTRUCTIONS,",
    "TABLE 42-2: INSTRUCTION SET\n= BIT-ORIENTED SKIP INSTRUCTIONS. BIT-ORIENTED SKIP INSTRUCTIONS, Description. = BIT-ORIENTED SKIP INSTRUCTIONS. BIT-ORIENTED SKIP INSTRUCTIONS, Cycles. = BIT-ORIENTED SKIP INSTRUCTIONS. BIT-ORIENTED SKIP INSTRUCTIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED SKIP INSTRUCTIONS. BIT-ORIENTED SKIP INSTRUCTIONS, 16-Bit Instruction Word. = BIT-ORIENTED SKIP INSTRUCTIONS. BIT-ORIENTED SKIP INSTRUCTIONS, 16-Bit Instruction Word. = BIT-ORIENTED SKIP INSTRUCTIONS. BIT-ORIENTED SKIP INSTRUCTIONS, 16-Bit Instruction Word.LSb = BIT-ORIENTED SKIP INSTRUCTIONS. BIT-ORIENTED SKIP INSTRUCTIONS, Status.Affected = BIT-ORIENTED SKIP INSTRUCTIONS. BIT-ORIENTED SKIP INSTRUCTIONS, Notes. = BIT-ORIENTED SKIP INSTRUCTIONS. BTFSC,",
    "TABLE 42-2: INSTRUCTION SET\n= f, b, a. BTFSC, Description. = Bit Test f, Skip if Clear. BTFSC, Cycles. = 1 (2 or 3). BTFSC, 16-Bit Instruction Word.MSb = 1011. BTFSC, 16-Bit Instruction Word. = bbba. BTFSC, 16-Bit Instruction Word. = ffff. BTFSC, 16-Bit Instruction Word.LSb = ffff. BTFSC, Status.Affected = None. BTFSC, Notes. = 1. BTFSS,  = f, b, a. BTFSS, Description. = Bit Test f, Skip if Set. BTFSS, Cycles. = 1 (2 or 3). BTFSS, 16-Bit Instruction Word.MSb = 1010. BTFSS, 16-Bit Instruction Word. = bbba. BTFSS, 16-Bit Instruction Word. = ffff. BTFSS, 16-Bit Instruction Word.LSb = ffff. BTFSS, Status.Affected = None. BTFSS, Notes. = 1",
    "TABLE 42-2: INSTRUCTION SET\nNote 1: If Program Counter (PC) is modified or a conditional test is true, the instruction requires an additional cycle. The extra cycle is exe -cuted as a NOP .\n2: Some instructions are multi word instructions. The second/third words of these instructions will be decoded as a NOP , unless the first word of the instruction retrieves the information embedded in these 16-bits. This ensures that all program memory locations have a valid instruction.\n3: f s and f d do not cover the full memory range. 2 MSBs of bank selection are forced to 'b00 to limit the range of these instructions to lower 4k addressing space.",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nCONTROL INSTRUCTIONS, Mnemonic,.Operands = CONTROL INSTRUCTIONS. CONTROL INSTRUCTIONS, Description.Description = CONTROL INSTRUCTIONS. CONTROL INSTRUCTIONS, Cycles.Cycles = CONTROL INSTRUCTIONS. CONTROL INSTRUCTIONS, 16-Bit Instruction Word.MSb = CONTROL INSTRUCTIONS. CONTROL INSTRUCTIONS, 16-Bit Instruction Word. = CONTROL INSTRUCTIONS. CONTROL INSTRUCTIONS, 16-Bit Instruction Word. = CONTROL INSTRUCTIONS. CONTROL INSTRUCTIONS, 16-Bit Instruction Word.LSb = CONTROL INSTRUCTIONS. CONTROL INSTRUCTIONS, Status Affected.Status Affected = CONTROL INSTRUCTIONS. CONTROL INSTRUCTIONS, Notes.Notes = CONTROL INSTRUCTIONS. BC, Mnemonic,.Operands = n. BC, Description.Description = Branch if Carry. BC, Cycles.Cycles = 1 (2). BC, 16-Bit Instruction Word.MSb = 1110. BC, 16-Bit Instruction Word. = 0010. BC, 16-Bit Instruction Word. = nnnn. BC, 16-Bit Instruction Word.LSb = nnnn. BC, Status Affected.Status Affected = None. BC, Notes.Notes = 1. BN, Mnemonic,.Operands = n. BN, Description.Description = Branch if Negative. BN, Cycles.Cycles = 1",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\n(2). BN, 16-Bit Instruction Word.MSb = 1110. BN, 16-Bit Instruction Word. = 0110. BN, 16-Bit Instruction Word. = nnnn. BN, 16-Bit Instruction Word.LSb = nnnn. BN, Status Affected.Status Affected = None. BN, Notes.Notes = 1. BNC, Mnemonic,.Operands = n. BNC, Description.Description = Branch if Not Carry. BNC, Cycles.Cycles = 1 (2). BNC, 16-Bit Instruction Word.MSb = 1110. BNC, 16-Bit Instruction Word. = 0011. BNC, 16-Bit Instruction Word. = nnnn. BNC, 16-Bit Instruction Word.LSb = nnnn. BNC, Status Affected.Status Affected = None. BNC, Notes.Notes = 1. BNN, Mnemonic,.Operands = n. BNN, Description.Description = Branch if Not Negative. BNN, Cycles.Cycles = 1 (2). BNN, 16-Bit Instruction Word.MSb = 1110. BNN,",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\n16-Bit Instruction Word. = 0111. BNN, 16-Bit Instruction Word. = nnnn. BNN, 16-Bit Instruction Word.LSb = nnnn. BNN, Status Affected.Status Affected = None. BNN, Notes.Notes = 1. BNOV, Mnemonic,.Operands = n. BNOV, Description.Description = Branch if Not Overflow. BNOV, Cycles.Cycles = 1 (2). BNOV, 16-Bit Instruction Word.MSb = 1110. BNOV, 16-Bit Instruction Word. = 0101. BNOV, 16-Bit Instruction Word. = nnnn. BNOV, 16-Bit Instruction Word.LSb = nnnn. BNOV, Status Affected.Status Affected = None. BNOV, Notes.Notes = 1. BNZ, Mnemonic,.Operands = n. BNZ, Description.Description = Branch if Not Zero. BNZ, Cycles.Cycles = 2. BNZ, 16-Bit Instruction Word.MSb = 1110. BNZ, 16-Bit Instruction Word. = 0001. BNZ, 16-Bit Instruction",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nWord. = nnnn. BNZ, 16-Bit Instruction Word.LSb = nnnn. BNZ, Status Affected.Status Affected = None. BNZ, Notes.Notes = 1. BOV, Mnemonic,.Operands = n. BOV, Description.Description = Branch if Overflow. BOV, Cycles.Cycles = 1 (2). BOV, 16-Bit Instruction Word.MSb = 1110. BOV, 16-Bit Instruction Word. = 0100. BOV, 16-Bit Instruction Word. = nnnn. BOV, 16-Bit Instruction Word.LSb = nnnn. BOV, Status Affected.Status Affected = None. BOV, Notes.Notes = 1. BRA, Mnemonic,.Operands = n. BRA, Description.Description = Branch Unconditionally. BRA, Cycles.Cycles = 1 (2). BRA, 16-Bit Instruction Word.MSb = 1101. BRA, 16-Bit Instruction Word. = 0nnn. BRA, 16-Bit Instruction Word. = nnnn. BRA, 16-Bit Instruction Word.LSb =",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nnnnn. BRA, Status Affected.Status Affected = None. BRA, Notes.Notes = . BZ, Mnemonic,.Operands = n. BZ, Description.Description = Branch if Zero. BZ, Cycles.Cycles = 1 (2). BZ, 16-Bit Instruction Word.MSb = 1110. BZ, 16-Bit Instruction Word. = 0000. BZ, 16-Bit Instruction Word. = nnnn. BZ, 16-Bit Instruction Word.LSb = nnnn. BZ, Status Affected.Status Affected = None. BZ, Notes.Notes = 1. CALL, Mnemonic,.Operands = n, s. CALL, Description.Description = Call subroutine 1st word 2nd word. CALL, Cycles.Cycles = 2. CALL, 16-Bit Instruction Word.MSb = 1110 1111. CALL, 16-Bit Instruction Word. = 110s nnnn. CALL, 16-Bit Instruction Word. = nnnn nnnn. CALL, 16-Bit Instruction Word.LSb = nnnn nnnn. CALL, Status Affected.Status Affected =",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nNone. CALL, Notes.Notes = 2. GOTO, Mnemonic,.Operands = n -. GOTO, Description.Description = Go to address 1st word 2nd word. GOTO, Cycles.Cycles = 2. GOTO, 16-Bit Instruction Word.MSb = 1110. GOTO, 16-Bit Instruction Word. = 1111. GOTO, 16-Bit Instruction Word. = nnnn nnnn. GOTO, 16-Bit Instruction Word.LSb = nnnn nnnn. GOTO, Status Affected.Status Affected = None. GOTO, Notes.Notes = 2. CALLW, Mnemonic,.Operands = -. CALLW, Description.Description = W-> PCL and Call subroutine. CALLW, Cycles.Cycles = 2. CALLW, 16-Bit Instruction Word.MSb = 1111 0000. CALLW, 16-Bit Instruction Word. = nnnn 0000. CALLW, 16-Bit Instruction Word. = 0001. CALLW, 16-Bit Instruction Word.LSb = 0100. CALLW, Status Affected.Status Affected = None.",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nCALLW, Notes.Notes = 1. RCALL, Mnemonic,.Operands = n. RCALL, Description.Description = Relative Call. RCALL, Cycles.Cycles = 2. RCALL, 16-Bit Instruction Word.MSb = 1101. RCALL, 16-Bit Instruction Word. = 1nnn. RCALL, 16-Bit Instruction Word. = nnnn. RCALL, 16-Bit Instruction Word.LSb = nnnn. RCALL, Status Affected.Status Affected = None. RCALL, Notes.Notes = 1. RETFIE, Mnemonic,.Operands = s. RETFIE, Description.Description = Return from interrupt enable. RETFIE, Cycles.Cycles = 2. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word. = 0000. RETFIE, 16-Bit Instruction Word. = 0001. RETFIE, 16-Bit Instruction Word.LSb = 000s. RETFIE, Status Affected.Status Affected = None. RETFIE, Notes.Notes = 1. RETLW,",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word. = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected.Status Affected = None. RETLW, Notes.Notes = 1. RETURN, Mnemonic,.Operands = s. RETURN, Description.Description = Return from Subroutine. RETURN, Cycles.Cycles = 2. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word. = 0000. RETURN, 16-Bit Instruction Word. = 0001. RETURN, 16-Bit Instruction Word.LSb = 001s. RETURN, Status Affected.Status Affected = None. RETURN, Notes.Notes = 1. INHERENT INSTRUCTIONS, Mnemonic,.Operands = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, Description.Description = INHERENT INSTRUCTIONS. INHERENT",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nINSTRUCTIONS, Cycles.Cycles = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, 16-Bit Instruction Word.MSb = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, 16-Bit Instruction Word. = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, 16-Bit Instruction Word. = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, 16-Bit Instruction Word.LSb = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, Status Affected.Status Affected = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, Notes.Notes = INHERENT INSTRUCTIONS. CLRWDT, Mnemonic,.Operands = -. CLRWDT, Description.Description = Clear Watchdog Timer. CLRWDT, Cycles.Cycles = 1. CLRWDT, 16-Bit Instruction Word.MSb = 0000. CLRWDT, 16-Bit Instruction Word. = 0000. CLRWDT, 16-Bit Instruction Word. = 0000. CLRWDT, 16-Bit Instruction Word.LSb = 0100. CLRWDT, Status Affected.Status Affected = None. CLRWDT, Notes.Notes = . DAW, Mnemonic,.Operands = -. DAW, Description.Description = Decimal Adjust WREG. DAW, Cycles.Cycles =",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\n1. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word.LSb = 0111. DAW, Status Affected.Status Affected = C. DAW, Notes.Notes = . NOP, Mnemonic,.Operands = -. NOP, Description.Description = No Operation. NOP, Cycles.Cycles = 1. NOP, 16-Bit Instruction Word.MSb = 0000. NOP, 16-Bit Instruction Word. = 0000. NOP, 16-Bit Instruction Word. = 0000. NOP, 16-Bit Instruction Word.LSb = 0000. NOP, Status Affected.Status Affected = None. NOP, Notes.Notes = . NOP, Mnemonic,.Operands = -. NOP, Description.Description = No Operation. NOP, Cycles.Cycles = 1. NOP, 16-Bit Instruction Word.MSb = 1111. NOP, 16-Bit Instruction Word. = xxxx.",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nNOP, 16-Bit Instruction Word. = xxxx. NOP, 16-Bit Instruction Word.LSb = xxxx. NOP, Status Affected.Status Affected = None. NOP, Notes.Notes = 2. POP, Mnemonic,.Operands = -. POP, Description.Description = Pop top of return stack (TOS). POP, Cycles.Cycles = 1. POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word.LSb = 0110. POP, Status Affected.Status Affected = None. POP, Notes.Notes = . PUSH, Mnemonic,.Operands = -. PUSH, Description.Description = Push top of return stack (TOS). PUSH, Cycles.Cycles = 1. PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word.LSb = 0101. PUSH, Status",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nAffected.Status Affected = None. PUSH, Notes.Notes = . RESET, Mnemonic,.Operands = . RESET, Description.Description = Software device Reset. RESET, Cycles.Cycles = 1. RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word. = 0000. RESET, 16-Bit Instruction Word. = 1111. RESET, 16-Bit Instruction Word.LSb = 1111. RESET, Status Affected.Status Affected = All. RESET, Notes.Notes = . SLEEP, Mnemonic,.Operands = -. SLEEP, Description.Description = Go into Standby mode. SLEEP, Cycles.Cycles = 1. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word.LSb = 0011. SLEEP, Status Affected.Status Affected = None. SLEEP, Notes.Notes = ",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nNote 1: If Program Counter (PC) is modified or a conditional test is true, the instruction requires an additional cycle. The extra cycle is exe -cuted as a NOP .\n2: Some instructions are multi word instructions. The second/third words of these instructions will be decoded as a NOP , unless the first word of the instruction retrieves the information embedded in these 16-bits. This ensures that all program memory locations have a valid instruction.\n3: f s and f d do not cover the full memory range. 2 MSBs of bank selection are forced to 'b00 to limit the range of these instructions to lower 4k addressing space.",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nLITERAL INSTRUCTIONS, Mnemonic,.Operands = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, Description = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, Cycles. = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, 16-Bit Instruction Word.MSb = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, 16-Bit Instruction Word.MSb = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, 16-Bit Instruction Word.MSb = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, 16-Bit Instruction Word.LSb = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, Status Affected. = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, Notes. = LITERAL INSTRUCTIONS. ADDLW, Mnemonic,.Operands = k. ADDLW, Description = Add literal and WREG. ADDLW, Cycles. = 1. ADDLW, 16-Bit Instruction Word.MSb = 0000. ADDLW, 16-Bit Instruction Word.MSb = 1111. ADDLW, 16-Bit Instruction Word.MSb = kkkk. ADDLW, 16-Bit Instruction Word.LSb = kkkk. ADDLW, Status Affected. = C, DC, Z, OV, N. ADDLW, Notes. = . ANDLW,",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = k. ANDLW, Description = AND literal with WREG. ANDLW, Cycles. = 1. ANDLW, 16-Bit Instruction Word.MSb = 0000. ANDLW, 16-Bit Instruction Word.MSb = 1011. ANDLW, 16-Bit Instruction Word.MSb = kkkk. ANDLW, 16-Bit Instruction Word.LSb = kkkk. ANDLW, Status Affected. = Z, N. ANDLW, Notes. = . IORLW, Mnemonic,.Operands = k. IORLW, Description = Inclusive OR literal with WREG. IORLW, Cycles. = 1. IORLW, 16-Bit Instruction Word.MSb = 0000. IORLW, 16-Bit Instruction Word.MSb = 1001. IORLW, 16-Bit Instruction Word.MSb = kkkk. IORLW, 16-Bit Instruction Word.LSb = kkkk. IORLW, Status Affected. = Z, N. IORLW, Notes. = . LFSR,",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = f n , k. LFSR, Description = Load FSR(f n ) with a 14-bit. LFSR, Cycles. = 2. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word.MSb = 00ff. LFSR, 16-Bit Instruction Word.LSb = kkkk. LFSR, Status Affected. = None. LFSR, Notes. = . , Mnemonic,.Operands = . , Description = literal (k). , Cycles. = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word.MSb = 00kk. , 16-Bit Instruction Word.MSb = kkkk. , 16-Bit Instruction Word.LSb = kkkk. , Status Affected. = . , Notes. = . ADDFSR, Mnemonic,.Operands = f n , k. ADDFSR, Description = Add FSR(f n ) with",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\n(k). ADDFSR, Cycles. = 1. ADDFSR, 16-Bit Instruction Word.MSb = 1110. ADDFSR, 16-Bit Instruction Word.MSb = 1000. ADDFSR, 16-Bit Instruction Word.MSb = ffkk. ADDFSR, 16-Bit Instruction Word.LSb = kkkk. ADDFSR, Status Affected. = None. ADDFSR, Notes. = . SUBFSR, Mnemonic,.Operands = f n , k. SUBFSR, Description = Subtract (k) from FSR(f n ). SUBFSR, Cycles. = 1. SUBFSR, 16-Bit Instruction Word.MSb = 1110. SUBFSR, 16-Bit Instruction Word.MSb = 1001. SUBFSR, 16-Bit Instruction Word.MSb = ffkk. SUBFSR, 16-Bit Instruction Word.LSb = kkkk. SUBFSR, Status Affected. = None. SUBFSR, Notes. = . MOVLB, Mnemonic,.Operands = k. MOVLB, Description = Move literal",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nto BSR<5:0>. MOVLB, Cycles. = 1. MOVLB, 16-Bit Instruction Word.MSb = 0000. MOVLB, 16-Bit Instruction Word.MSb = 0001. MOVLB, 16-Bit Instruction Word.MSb = 00kk. MOVLB, 16-Bit Instruction Word.LSb = kkkk. MOVLB, Status Affected. = None. MOVLB, Notes. = . MOVLW, Mnemonic,.Operands = k. MOVLW, Description = Move literal to WREG. MOVLW, Cycles. = 1. MOVLW, 16-Bit Instruction Word.MSb = 0000. MOVLW, 16-Bit Instruction Word.MSb = 1110. MOVLW, 16-Bit Instruction Word.MSb = kkkk. MOVLW, 16-Bit Instruction Word.LSb = kkkk. MOVLW, Status Affected. = None. MOVLW, Notes. = . MULLW, Mnemonic,.Operands = k.",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nMULLW, Description = Multiply literal with WREG. MULLW, Cycles. = 1. MULLW, 16-Bit Instruction Word.MSb = 0000. MULLW, 16-Bit Instruction Word.MSb = 1101. MULLW, 16-Bit Instruction Word.MSb = kkkk. MULLW, 16-Bit Instruction Word.LSb = kkkk. MULLW, Status Affected. = None. MULLW, Notes. = . RETLW, Mnemonic,.Operands = k. RETLW, Description = Return with literal in WREG. RETLW, Cycles. = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word.MSb = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected. = None. RETLW, Notes. = . SUBLW, Mnemonic,.Operands = k. SUBLW, Description =",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nSubtract WREG from literal. SUBLW, Cycles. = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000. SUBLW, 16-Bit Instruction Word.MSb = 1000. SUBLW, 16-Bit Instruction Word.MSb = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected. = C, DC, Z, OV, N. SUBLW, Notes. = . XORLW, Mnemonic,.Operands = k. XORLW, Description = Exclusive OR literal with WREG. XORLW, Cycles. = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word.MSb = 1010. XORLW, 16-Bit Instruction Word.MSb = kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected. = Z, N. XORLW, Notes. = . DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS,",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS, Description = DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS, Cycles. = DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS, 16-Bit Instruction Word.LSb = DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS, Status Affected. = DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS, Notes. = DATA MEMORY \uf02d PROGRAM MEMORY INSTRUCTIONS. TBLRD*, Mnemonic,.Operands = TBLRD*. TBLRD*, Description = Table Read. TBLRD*, Cycles. = 2 - 5. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word.MSb =",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\n0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected. = None. TBLRD*, Notes. = . TBLRD*+, Mnemonic,.Operands = TBLRD*+. TBLRD*+, Description = Table Read with post-increment. TBLRD*+, Cycles. = . TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected. = None. TBLRD*+, Notes. = . TBLRD*-, Mnemonic,.Operands = TBLRD*-. TBLRD*-, Description = Table Read with post-decrement. TBLRD*-, Cycles. = . TBLRD*-, 16-Bit Instruction Word.MSb = 0000.",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nTBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected. = None. TBLRD*-, Notes. = . TBLRD+*, Mnemonic,.Operands = TBLRD+*. TBLRD+*, Description = Table Read with pre-increment. TBLRD+*, Cycles. = . TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected. = None. TBLRD+*, Notes. = . TBLWT*, Mnemonic,.Operands = TBLWT*. TBLWT*, Description = Table Write.",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nTBLWT*, Cycles. = 2 - 5. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status Affected. = None. TBLWT*, Notes. = . TBLWT*+, Mnemonic,.Operands = TBLWT*+. TBLWT*+, Description = Table Write with post-increment. TBLWT*+, Cycles. = . TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected. = None. TBLWT*+, Notes. = . TBLWT*-,",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = TBLWT*-. TBLWT*-, Description = Table Write with post-decrement. TBLWT*-, Cycles. = . TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected. = None. TBLWT*-, Notes. = . TBLWT+*, Mnemonic,.Operands = TBLWT+*. TBLWT+*, Description = Table Write with pre-increment. TBLWT+*, Cycles. = . TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction",
    "TABLE 42-2: INSTRUCTION SET (CONTINUED)\nWord.LSb = 1111. TBLWT+*, Status Affected. = None. TBLWT+*, Notes. = \nNote 1: If Program Counter (PC) is modified or a conditional test is true, the instruction requires an additional cycle. The extra cycle is exe -cuted as a NOP .\n2: Some instructions are multi word instructions. The second/third words of these instructions will be decoded as a NOP , unless the first word of the instruction retrieves the information embedded in these 16-bits. This ensures that all program memory locations have a valid instruction.\n3: f s and f d do not cover the full memory range. 2 MSBs of bank selection are forced to 'b00 to limit the range of these instructions to lower 4k addressing space.",
    "Add Literal to FSR\nSyntax:, 1 = ADDFSR f, k. Syntax:, 2 = ADDFSR f, k. Syntax:, 3 = ADDFSR f, k. Syntax:, 4 = ADDFSR f, k. Operands:, 1 = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operands:, 2 = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operands:, 3 = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operands:, 4 = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operation:, 1 = FSR(f) + k \uf0ae FSR(f). Operation:, 2 = FSR(f) + k \uf0ae FSR(f). Operation:, 3 = FSR(f) + k \uf0ae FSR(f). Operation:, 4 = FSR(f) + k \uf0ae FSR(f). Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 1110. Encoding:, 2 = 1000. Encoding:, 3 = ffkk. Encoding:, 4",
    "Add Literal to FSR\n= kkkk. Description:, 1 = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Description:, 2 = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Description:, 3 = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Description:, 4 = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = Q4. , 1 = Decod e. , 2 = Read literal 'k'. , 3",
    "Add Literal to FSR\n= Pro - cess Data. , 4 = Write to FSR. , 1 = Decod e. , 2 = Read literal 'k'. , 3 = Pro - cess Data. , 4 = Write to FSR",
    "Example:\nADDFSR 2, 23h\nBefore Instruction\nFSR2\n=\n03FFh\nAfter Instruction\nFSR2\n=\n0422h",
    "Example:\nSyntax:, ADD literal to W = ADDLW k. Syntax:, ADD literal to W = ADDLW k. Syntax:, ADD literal to W = ADDLW k. Operands:, ADD literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, ADD literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, ADD literal to W = 0 \uf0a3 k \uf0a3 255. Operation:, ADD literal to W = (W) + k \uf0ae W. Operation:, ADD literal to W = (W) + k \uf0ae W. Operation:, ADD literal to W = (W) + k \uf0ae W. Status Affected:, ADD literal to W = N, OV, C, DC, Z. Status Affected:, ADD literal to W = N, OV, C, DC, Z. Status Affected:, ADD literal to W = N, OV, C, DC, Z. Encoding:, ADD literal to W = 0000. Encoding:, ADD literal to W = 1111 kkkk. Encoding:, ADD literal to W = kkkk. Description:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:,",
    "Example:\nADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Words:, ADD literal to W = 1. Words:, ADD literal to W = 1. Words:, ADD literal to W = 1. Cycles:, ADD literal to W = 1. Cycles:, ADD literal to W = 1. Cycles:, ADD literal to W = 1. Q Cycle Activity:, ADD literal to W = Q Cycle Activity:. Q Cycle Activity:, ADD literal to W = Q Cycle Activity:. Q Cycle Activity:, ADD literal to W = Q Cycle Activity:. Q1, ADD literal to W = Q2. Q1, ADD literal to W = Q3. Q1, ADD literal to W = Q4. Decode, ADD literal to W = Read literal 'k'. Decode, ADD literal to W = Process Data. Decode, ADD literal to W = Write to W\nExample:\nADDLW 15h\nBefore Instruction\nW = 10h\nAfter Instruction\nW = 25h",
    "Example:\nSyntax:, ADD Wto f = ADDWF. Syntax:, ADD Wto f = f {,d {,a}}. Syntax:, ADD Wto f = . Syntax:, ADD Wto f = . Operands:, ADD Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, ADD Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, ADD Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, ADD Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, ADD Wto f = (W) + (f) \uf0ae dest. Operation:, ADD Wto f = (W) + (f) \uf0ae dest. Operation:, ADD Wto f = (W) + (f) \uf0ae dest. Operation:, ADD Wto f = (W) + (f) \uf0ae dest. Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto f = N, OV,",
    "Example:\nC, DC, Z. Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto f = N, OV, C, DC, Z. Encoding:, ADD Wto f = 0010. Encoding:, ADD Wto f = 01da. Encoding:, ADD Wto f = ffff. Encoding:, ADD Wto f = ffff. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit -. Description:, ADD Wto f = Add Wto register",
    "Example:\n'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit -. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever",
    "Example:\nf \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit -. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit -. Words:, ADD Wto f = 1. Words:, ADD Wto f = . Words:, ADD Wto f = . Words:, ADD Wto f = . Cycles:, ADD Wto f = 1. Cycles:, ADD Wto f = . Cycles:, ADD Wto f = . Cycles:, ADD Wto f = ",
    "Q Cycle Activity:\nExample:\n, Q2.Read register 'f' = ADDWF. , Q3.Process Data = REG, 0, 0. , Q4.Write to destination = . Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3.Process Data = . Before Instruction, Q4.Write to destination = . W, Q2.Read register 'f' = = 17h. W, Q3.Process Data = . W, Q4.Write to destination = . REG, Q2.Read register 'f' = = 0C2h. REG, Q3.Process Data = . REG, Q4.Write to destination = . After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3.Process Data = . After Instruction, Q4.Write to destination = . W, Q2.Read register 'f' = = 0D9h. W, Q3.Process Data = . W, Q4.Write to destination = . REG, Q2.Read register 'f' = = 0C2h. REG, Q3.Process Data = . REG, Q4.Write to destination = ",
    "Q Cycle Activity:\nNote:\nAll PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction format then becomes: {label} instruction argument(s).",
    "Q Cycle Activity:\nSyntax:, ADD Wand CARRY bit to f = ADDWFC. Syntax:, ADD Wand CARRY bit to f = f {,d {,a}}. Syntax:, ADD Wand CARRY bit to f = . Syntax:, ADD Wand CARRY bit to f = . Operands:, ADD Wand CARRY bit to f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1] a \uf0ce\uf020 [0,1]. Operands:, ADD Wand CARRY bit to f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1] a \uf0ce\uf020 [0,1]. Operands:, ADD Wand CARRY bit to f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1] a \uf0ce\uf020 [0,1]. Operands:, ADD Wand CARRY bit to f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1] a \uf0ce\uf020 [0,1]. Operation:, ADD Wand CARRY bit to f = (W) + (f) + (C) \uf0ae dest. Operation:, ADD Wand CARRY bit to f = (W) + (f) + (C) \uf0ae dest. Operation:, ADD Wand CARRY bit to f = (W) + (f) + (C) \uf0ae dest. Operation:, ADD Wand CARRY bit to f = (W) +",
    "Q Cycle Activity:\n(f) + (C) \uf0ae dest. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Encoding:, ADD Wand CARRY bit to f = 0010. Encoding:, ADD Wand CARRY bit to f = 00da. Encoding:, ADD Wand CARRY bit to f = ffff. Encoding:, ADD Wand CARRY bit to f = ffff. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data mem - ory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If",
    "Q Cycle Activity:\n'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data mem - ory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data mem",
    "Q Cycle Activity:\n- ory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data mem - ory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a'",
    "Q Cycle Activity:\nis ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Words:, ADD Wand CARRY bit to f = 1. Words:, ADD Wand CARRY bit to f = . Words:, ADD Wand CARRY bit to f = . Words:, ADD Wand CARRY bit to f = \nWords:\n1\nCycles:\n1\nQ Cycle Activity:",
    "Example:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. , Q2 = ADDWFC. , Q3 = REG, 0,. , Q4 = 1. Before Instruction CARRY bit = REG = W =, Q2 = 1. Before Instruction CARRY bit = REG = W =, Q3 = . Before Instruction CARRY bit = REG = W =, Q4 = . , Q2 = 02h. , Q3 = . , Q4 = . After Instruction CARRY bit, Q2 = 4Dh. After Instruction CARRY bit, Q3 = . After Instruction CARRY bit, Q4 = . REG, Q2 = = 0 = 02h. REG, Q3 = . REG, Q4 = . W, Q2 = =. W, Q3 = . W, Q4 = . , Q2 = 50h. , Q3 = . , Q4 = ",
    "PIC18(L)F25/26K83\nSyntax:, AND literal with W = ANDLW k. Syntax:, AND literal with W = ANDLW k. Syntax:, AND literal with W = ANDLW k. Syntax:, AND literal with W = ANDLW k. Operands:, AND literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND literal with W = 0 \uf0a3 k \uf0a3 255. Operation:, AND literal with W = (W) .AND. k \uf0ae W. Operation:, AND literal with W = (W) .AND. k \uf0ae W. Operation:, AND literal with W = (W) .AND. k \uf0ae W. Operation:, AND literal with W = (W) .AND. k \uf0ae W. Status Affected:, AND literal with W = N, Z. Status Affected:, AND literal with W = N, Z. Status Affected:, AND literal with W = N, Z. Status Affected:, AND literal with W = N, Z. Encoding:, AND literal with W = 0000. Encoding:, AND literal with W =",
    "PIC18(L)F25/26K83\n1011. Encoding:, AND literal with W = kkkk. Encoding:, AND literal with W = kkkk. Description:, AND literal with W = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Words:, AND literal with W = 1. Words:, AND literal with W = 1. Words:, AND literal with W = 1. Words:, AND literal with W = 1. Cycles:, AND literal with W = 1. Cycles:, AND literal with W = 1. Cycles:, AND literal with W = 1. Cycles:, AND literal with W = 1. Q Cycle Activity:,",
    "PIC18(L)F25/26K83\nAND literal with W = Q Cycle Activity:. Q Cycle Activity:, AND literal with W = Q Cycle Activity:. Q Cycle Activity:, AND literal with W = Q Cycle Activity:. Q Cycle Activity:, AND literal with W = Q Cycle Activity:. Q1, AND literal with W = Q2. Q1, AND literal with W = Q3. Q1, AND literal with W = . Q1, AND literal with W = Q4. Decode, AND literal with W = Read literal 'k'. Decode, AND literal with W = Process Data. Decode, AND literal with W = . Decode, AND literal with W = Write to W\nExample:\nANDLW\nBefore Instruction\nW\n=\nA3h\nAfter Instruction\nW\n=\n03h\n05Fh",
    "PIC18(L)F25/26K83\nSyntax:, AND Wwith f = ANDWF. Syntax:, AND Wwith f = f {,d {,a}}. Syntax:, AND Wwith f = f {,d {,a}}. Syntax:, AND Wwith f = f {,d {,a}}. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f =",
    "PIC18(L)F25/26K83\nN, Z. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Encoding:, AND Wwith f = 0001. Encoding:, AND Wwith f = 01da. Encoding:, AND Wwith f = ffff. Encoding:, AND Wwith f = ffff. Description:, AND Wwith f = The contents of Ware AND'ed with. Description:, AND Wwith f = The contents of Ware AND'ed with. Description:, AND Wwith f = The contents of Ware AND'ed with. Description:, AND Wwith f = The contents of Ware AND'ed with\nregister 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.",
    "PIC18(L)F25/26K83\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec -tion 42.2.3 'Byte-Oriented and BitOriented Instructions in Indexed Lit -eral Offset Mode' for details.\n1\n1\nWords:\nCycles:\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nANDWF\nBefore Instruction\nW\n=\n17h\nREG\n=\nC2h\nAfter Instruction\nW\n=\n02h\nREG\n=\nC2h\nREG, 0, 0",
    "PIC18(L)F25/26K83\nBC Branch if Carry, 1 = BC Branch if Carry. BC Branch if Carry, 2 = BC Branch if Carry. BC Branch if Carry, 3 = BC Branch if Carry. BC Branch if Carry, 4 = BC Branch if Carry. BC Branch if Carry, 5 = BC Branch if Carry. Syntax:, 1 = Syntax:. Syntax:, 2 = Syntax:. Syntax:, 3 = BC n. Syntax:, 4 = BC n. Syntax:, 5 = BC n. Operands:, 1 = Operands:. Operands:, 2 = Operands:. Operands:, 3 = -128 \uf0a3 n \uf0a3 127. Operands:, 4 = -128 \uf0a3 n \uf0a3 127. Operands:, 5 = -128 \uf0a3 n \uf0a3 127. Operation:, 1 = Operation:. Operation:, 2 = Operation:. Operation:, 3 = if CARRY bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 4 = if CARRY bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 5 = if CARRY bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, 1 = Status",
    "PIC18(L)F25/26K83\nAffected:. Status Affected:, 2 = Status Affected:. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = Encoding:. Encoding:, 3 = 1110. Encoding:, 4 = 0010. Encoding:, 5 = nnnn. Description: If the will The added PC + 2, 1 = Description: If the will The added PC + 2. Description: If the will The added PC + 2, 2 = Description: If the will The added PC + 2. Description: If the will The added PC + 2, 3 = CARRYbit is ' 1 ', then the program branch. 2's complement number '2n' is to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be + 2n. This instruction is then a 2-cycle instruction.. Description: If the will The added PC + 2, 4 = CARRYbit is ' 1 ', then the program branch. 2's complement number '2n' is to the PC. Since the PC will have",
    "PIC18(L)F25/26K83\nincremented to fetch the next instruction, the new address will be + 2n. This instruction is then a 2-cycle instruction.. Description: If the will The added PC + 2, 5 = CARRYbit is ' 1 ', then the program branch. 2's complement number '2n' is to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be + 2n. This instruction is then a 2-cycle instruction.. Words:, 1 = Words:. Words:, 2 = Words:. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = Cycles:. Cycles:, 3 = 1(2). Cycles:, 4 = 1(2). Cycles:, 5 = 1(2). Q Cycle Activity: If, 1 = Q Cycle Activity: If. Q Cycle Activity: If, 2 = Q Cycle Activity: If. Q Cycle Activity: If, 3 = . Q Cycle Activity: If, 4 = . Q Cycle Activity: If, 5 = . Jump:, 1",
    "PIC18(L)F25/26K83\n= Jump:. Jump:, 2 = Jump:. Jump:, 3 = . Jump:, 4 = . Jump:, 5 = . , 1 = Q1. , 2 = Q2. , 3 = . , 4 = Q3. , 5 = . , 1 = Decode. , 2 = Read. , 3 = literal 'n'. , 4 = Process Data. , 5 = . , 1 = No operation. , 2 = No. , 3 = operation. , 4 = No operation. , 5 = . If No Jump:, 1 = If No Jump:. If No Jump:, 2 = If No Jump:. If No Jump:, 3 = . If No Jump:, 4 = . If No Jump:, 5 = . , 1 = Q1. , 2 = Q2. , 3 = . , 4 = Q3. , 5 = . , 1 = Decode. , 2 = Read literal 'n'. , 3 = . , 4 = Process Data. , 5 = . , 1 = . , 2 = . , 3 = . , 4 = BC. , 5 = . Example: HERE, 1 = Example:",
    "PIC18(L)F25/26K83\nHERE. Example: HERE, 2 = Example: HERE. Example: HERE, 3 = . Example: HERE, 4 = . Example: HERE, 5 = 5. Before Instruction, 1 = PC. Before Instruction, 2 = Before Instruction. Before Instruction, 3 = =. Before Instruction, 4 = address. Before Instruction, 5 = (HERE). , 1 = After Instruction If CARRY PC. , 2 = = =. , 3 = 1; address. , 4 = . , 5 = (HERE. , 1 = If CARRY PC. , 2 = = =. , 3 = 0; address. , 4 = (HERE. , 5 = ",
    "BCF\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "Bit Clear f\nBCF     f, b {,a}\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b \uf0a3 7\na \uf0ce\uf020 [0,1]\n0 \uf0ae f<b>",
    "None\n1001\nbbba ffff\nffff\nBit 'b' in register 'f' is cleared.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec -tion 42.2.3 'Byte-Oriented and BitOriented Instructions in Indexed Lit -eral Offset Mode' for details.\n1\n1\nQ Cycle Activity:\nExample:, Q2.Read register 'f' = BCF. Example:, Q3.Process Data = FLAG_REG,. Example:, Q4.Write register 'f' = 7, 0. Before Instruction FLAG_REG =, Q2.Read register 'f' = Before Instruction FLAG_REG =. Before Instruction FLAG_REG =, Q3.Process Data = C7h. Before Instruction FLAG_REG =, Q4.Write register 'f' = ",
    "PIC18(L)F25/26K83\nSyntax:, Branch if Negative = BN n. Syntax:, Branch if Negative = BN n. Syntax:, Branch if Negative = BN n. Syntax:, Branch if Negative = BN n. Syntax:, Branch if Negative = BN n. Syntax:, Branch if Negative = BN n. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Negative = if NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if NEGATIVE bit",
    "PIC18(L)F25/26K83\nis ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Encoding:, Branch if Negative = 1110. Encoding:, Branch if Negative = 1110. Encoding:, Branch if Negative = 0110. Encoding:, Branch if Negative = nnnn. Encoding:, Branch if Negative = nnnn. Encoding:, Branch if Negative = nnnn. Description:, Branch if Negative = If the NEGATIVE bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Negative = If",
    "PIC18(L)F25/26K83\nthe NEGATIVE bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Negative = If the NEGATIVE bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Negative = If the NEGATIVE bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Negative = If the NEGATIVE bit is ' 1 ', then the program will branch. The 2's complement",
    "PIC18(L)F25/26K83\nnumber '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Negative = If the NEGATIVE bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative =",
    "PIC18(L)F25/26K83\n1(2). Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . Q1, Branch if Negative = Q2. Q1, Branch if Negative = . Q1, Branch if Negative = . Q1, Branch if Negative = Q3. Q1, Branch if Negative = . Q1, Branch if Negative = Q4. , Branch if Negative = Decode. , Branch if Negative = Read literal 'n'. , Branch if Negative = Read literal 'n'. , Branch if Negative = Process Data. , Branch if Negative = Process Data. , Branch if Negative = Write to PC. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. If No",
    "PIC18(L)F25/26K83\nJump:, Branch if Negative = . If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . , Branch if Negative = Q1. , Branch if Negative = Q2. , Branch if Negative = Q2. , Branch if Negative = Q3. , Branch if Negative = Q3. , Branch if Negative = Q4. , Branch if Negative = Decode. , Branch if Negative = Read literal 'n'. , Branch if Negative = Read literal 'n'. , Branch if Negative = Process Data. , Branch if Negative = Process Data. , Branch if Negative = No operation. Example:, Branch if Negative = Example:. Example:, Branch if Negative = HERE. Example:, Branch if Negative = BN. Example:, Branch if Negative = Jump. Example:, Branch if Negative = . Example:, Branch if Negative = . Before Instruction PC, Branch if Negative = . Before Instruction PC, Branch if Negative = =. Before Instruction PC, Branch if Negative = address. Before Instruction",
    "PIC18(L)F25/26K83\nPC, Branch if Negative = (HERE). Before Instruction PC, Branch if Negative = . Before Instruction PC, Branch if Negative = . After Instruction If NEGATIVE PC, Branch if Negative = =. After Instruction If NEGATIVE PC, Branch if Negative = =. After Instruction If NEGATIVE PC, Branch if Negative = 1; address 0;. After Instruction If NEGATIVE PC, Branch if Negative = (Jump). After Instruction If NEGATIVE PC, Branch if Negative = . After Instruction If NEGATIVE PC, Branch if Negative = . If NEGATIVE PC, Branch if Negative = =. If NEGATIVE PC, Branch if Negative = =. If NEGATIVE PC, Branch if Negative = address. If NEGATIVE PC, Branch if Negative = (HERE. If NEGATIVE PC, Branch if Negative = +. If NEGATIVE PC, Branch if Negative = 2)",
    "PIC18(L)F25/26K83\nSyntax:, BNC = Syntax:. Syntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Operands:, BNC = Operands:. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operation:, BNC = Operation:. Operation:, Branch if Not Carry = if CARRY bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if CARRY bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if CARRY bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if CARRY bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, BNC = Status Affected:.",
    "PIC18(L)F25/26K83\nStatus Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Encoding:, BNC = Encoding:. Encoding:, Branch if Not Carry = 1110. Encoding:, Branch if Not Carry = 0011. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Description:, BNC = Description:. Description:, Branch if Not Carry = If the CARRYbit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Carry = If the CARRYbit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC +",
    "PIC18(L)F25/26K83\n2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Carry = If the CARRYbit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Carry = If the CARRYbit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, BNC = Words:. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Cycles:, BNC = Cycles:. Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if",
    "PIC18(L)F25/26K83\nNot Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Q Cycle Activity: If Jump:, BNC = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = . Q Cycle Activity: If Jump:, Branch if Not Carry = . Q Cycle Activity: If Jump:, Branch if Not Carry = . Q Cycle Activity: If Jump:, Branch if Not Carry = . , BNC = Q1. , Branch if Not Carry = Q2. , Branch if Not Carry = Q3. , Branch if Not Carry = . , Branch if Not Carry = Q4. , BNC = Decode. , Branch if Not Carry = Read literal 'n'. , Branch if Not Carry = Process Data. , Branch if Not Carry = Process Data. , Branch if Not Carry = Write to PC. , BNC = No operation. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. , BNC =",
    "PIC18(L)F25/26K83\nQ1. , Branch if Not Carry = Q2. , Branch if Not Carry = Q3. , Branch if Not Carry = Q3. , Branch if Not Carry = Q4. , BNC = Decode. , Branch if Not Carry = Read literal 'n'. , Branch if Not Carry = Process Data. , Branch if Not Carry = Process Data. , Branch if Not Carry = No operation. Example:, BNC = Example:. Example:, Branch if Not Carry = HERE. Example:, Branch if Not Carry = BNC. Example:, Branch if Not Carry = Jump. Example:, Branch if Not Carry = . , BNC = Before Instruction. , Branch if Not Carry = Before Instruction. , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , BNC = PC If CARRY. , Branch if Not Carry = =. , Branch if Not Carry = address (HERE). , Branch if Not Carry = . , Branch if Not Carry = . , BNC = After Instruction. , Branch if Not Carry = After Instruction. , Branch if Not Carry = . , Branch if Not Carry = . , Branch",
    "PIC18(L)F25/26K83\nif Not Carry = . , BNC = PC. , Branch if Not Carry = = =. , Branch if Not Carry = 0; address (Jump). , Branch if Not Carry = . , Branch if Not Carry = . , BNC = If CARRY PC. , Branch if Not Carry = = =. , Branch if Not Carry = 1; address (HERE. , Branch if Not Carry = +. , Branch if Not Carry = 2)",
    "PIC18(L)F25/26K83\nSyntax:, Branch if Not Negative = BNN n. Syntax:, Branch if Not Negative = BNN n. Syntax:, Branch if Not Negative = BNN n. Syntax:, Branch if Not Negative = BNN n. Syntax:, Branch if Not Negative = BNN n. Syntax:, Branch if Not Negative = BNN n. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Negative = if NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if NEGATIVE bit is '",
    "PIC18(L)F25/26K83\n0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 0111. Encoding:, Branch if Not Negative = nnnn. Encoding:, Branch if Not Negative = nnnn. Encoding:, Branch if Not Negative = nnnn. Description:, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented",
    "PIC18(L)F25/26K83\nto fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 +",
    "PIC18(L)F25/26K83\n2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if",
    "PIC18(L)F25/26K83\nNot Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Q Cycle Activity: If Jump:, Branch if Not Negative = . Q Cycle Activity: If Jump:, Branch if Not Negative = . Q Cycle Activity: If Jump:, Branch if Not Negative = . Q Cycle Activity: If Jump:, Branch if Not Negative = . Q Cycle Activity: If Jump:, Branch if Not Negative = . Q Cycle Activity: If Jump:, Branch if Not Negative = . Q1, Branch if Not Negative = Q2. Q1, Branch if Not Negative = . Q1, Branch if Not Negative = . Q1, Branch if Not Negative = Q3. Q1, Branch if Not Negative = . Q1, Branch if Not Negative = Q4. , Branch if Not Negative = Decode. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Process",
    "PIC18(L)F25/26K83\nData. , Branch if Not Negative = Process Data. , Branch if Not Negative = Write to PC. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . , Branch if Not Negative = Q1. , Branch if Not Negative = Q2. , Branch if Not Negative = Q2. , Branch if Not Negative = Q3. , Branch if Not Negative = Q3. , Branch if Not Negative = Q4. , Branch if Not Negative = Decode. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Process Data. , Branch if Not Negative = Process",
    "PIC18(L)F25/26K83\nData. , Branch if Not Negative = No operation. Example:, Branch if Not Negative = Example:. Example:, Branch if Not Negative = HERE. Example:, Branch if Not Negative = BNN. Example:, Branch if Not Negative = Jump. Example:, Branch if Not Negative = . Example:, Branch if Not Negative = . Before Instruction PC, Branch if Not Negative = Before Instruction PC. Before Instruction PC, Branch if Not Negative = =. Before Instruction PC, Branch if Not Negative = address. Before Instruction PC, Branch if Not Negative = (HERE). Before Instruction PC, Branch if Not Negative = . Before Instruction PC, Branch if Not Negative = . After Instruction If NEGATIVE PC, Branch if Not Negative = = =. After Instruction If NEGATIVE PC, Branch if Not Negative = . After Instruction If NEGATIVE PC, Branch if Not Negative = 0; address 1;. After Instruction If NEGATIVE PC, Branch if Not Negative = (Jump). After Instruction If NEGATIVE PC, Branch if Not Negative = . After Instruction If NEGATIVE PC, Branch if Not Negative = . If NEGATIVE PC, Branch if Not Negative = =. If NEGATIVE PC, Branch if Not Negative = =. If",
    "PIC18(L)F25/26K83\nNEGATIVE PC, Branch if Not Negative = address. If NEGATIVE PC, Branch if Not Negative = (HERE. If NEGATIVE PC, Branch if Not Negative = +. If NEGATIVE PC, Branch if Not Negative = 2)",
    "PIC18(L)F25/26K83\nSyntax:, Branch if Not Overflow = BNOV n. Syntax:, Branch if Not Overflow = BNOV n. Syntax:, Branch if Not Overflow = BNOV n. Syntax:, Branch if Not Overflow = BNOV n. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Overflow = if OVERFLOW bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if OVERFLOW bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if OVERFLOW bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if OVERFLOW bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None.",
    "PIC18(L)F25/26K83\nStatus Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 0101. Encoding:, Branch if Not Overflow = nnnn. Description:, Branch if Not Overflow = nnnn If the OVERFLOW bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Overflow = nnnn If the OVERFLOW bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Overflow =",
    "PIC18(L)F25/26K83\nnnnn If the OVERFLOW bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Overflow = nnnn If the OVERFLOW bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if",
    "PIC18(L)F25/26K83\nNot Overflow = 1(2). Q Cycle Activity: If Jump:, Branch if Not Overflow = . Q Cycle Activity: If Jump:, Branch if Not Overflow = . Q Cycle Activity: If Jump:, Branch if Not Overflow = . Q Cycle Activity: If Jump:, Branch if Not Overflow = . Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = . , Branch if Not Overflow = Q2 Q3 Q4. , Branch if Not Overflow = Q2 Q3 Q4. , Branch if Not Overflow = Q2 Q3 Q4. , Branch if Not Overflow = Q2 Q3 Q4. , Branch if Not Overflow = Read literal 'n' Process Data Write to PC No No No. , Branch if Not Overflow = Read literal 'n' Process Data Write to PC No No No. , Branch if Not Overflow = Read literal 'n' Process Data Write to PC No No No. , Branch if Not Overflow = Read literal 'n' Process Data Write to",
    "PIC18(L)F25/26K83\nPC No No No. Decode, Branch if Not Overflow = operation operation operation. Decode, Branch if Not Overflow = operation operation operation. Decode, Branch if Not Overflow = operation operation operation. Decode, Branch if Not Overflow = operation operation operation. Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = . Decode, Branch if Not Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNOV Jump. Decode, Branch if Not Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNOV Jump. Decode, Branch if Not Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNOV Jump. Decode, Branch if Not Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNOV Jump. Before Instruction PC, Branch if Not Overflow = =. Before Instruction PC, Branch if Not Overflow = address. Before Instruction PC, Branch if Not",
    "PIC18(L)F25/26K83\nOverflow = (HERE). Before Instruction PC, Branch if Not Overflow = . After Instruction, Branch if Not Overflow = 0;. After Instruction, Branch if Not Overflow = . After Instruction, Branch if Not Overflow = (Jump). After Instruction, Branch if Not Overflow = . If OVERFLOW= PC If OVERFLOW= PC, Branch if Not Overflow = = =. If OVERFLOW= PC If OVERFLOW= PC, Branch if Not Overflow = address 1; address. If OVERFLOW= PC If OVERFLOW= PC, Branch if Not Overflow = (HERE. If OVERFLOW= PC If OVERFLOW= PC, Branch if Not Overflow = + 2)",
    "PIC18(L)F25/26K83\nSyntax:, Branch if Not Zero = BNZ n. Syntax:, Branch if Not Zero = BNZ n. Syntax:, Branch if Not Zero = BNZ n. Syntax:, Branch if Not Zero = BNZ n. Syntax:, Branch if Not Zero = BNZ n. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Zero = if ZERO bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if ZERO bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if ZERO bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if ZERO bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if ZERO bit is ' 0",
    "PIC18(L)F25/26K83\n' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Encoding:, Branch if Not Zero = 1110. Encoding:, Branch if Not Zero = 0001. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Description:, Branch if Not Zero = If the ZERO bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Zero = If the ZERO bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have",
    "PIC18(L)F25/26K83\nincremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Zero = If the ZERO bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Zero = If the ZERO bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Zero = If the ZERO bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC +",
    "PIC18(L)F25/26K83\n2 + 2n. This instruction is then a 2-cycle instruction.. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Q Cycle Activity: If Jump:, Branch if Not Zero = . Q Cycle Activity: If Jump:, Branch if Not Zero = . Q Cycle Activity: If Jump:, Branch if Not Zero = . Q Cycle Activity: If Jump:, Branch if Not Zero = . Q Cycle Activity: If Jump:, Branch if Not Zero = . Q1, Branch if Not Zero = . Q1, Branch if Not Zero = . Q1, Branch if Not Zero = . Q1, Branch if Not Zero = . Q1, Branch if Not Zero",
    "PIC18(L)F25/26K83\n= . , Branch if Not Zero = Q2 Q3 Q4. , Branch if Not Zero = Q2 Q3 Q4. , Branch if Not Zero = Q2 Q3 Q4. , Branch if Not Zero = Q2 Q3 Q4. , Branch if Not Zero = Q2 Q3 Q4. Decode, Branch if Not Zero = . Decode, Branch if Not Zero = . Decode, Branch if Not Zero = . Decode, Branch if Not Zero = . Decode, Branch if Not Zero = . , Branch if Not Zero = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if Not Zero = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if Not Zero = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if Not Zero = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if Not Zero = Read literal 'n' Process Data Write to PC No operation No operation No operation. Q1, Branch if Not Zero = . Q1, Branch if Not Zero =",
    "PIC18(L)F25/26K83\n. Q1, Branch if Not Zero = . Q1, Branch if Not Zero = . Q1, Branch if Not Zero = . , Branch if Not Zero = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Zero = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Zero = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Zero = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Zero = Q2 Q3 Q4 Read literal 'n' Process Data No operation. Example:, Branch if Not Zero = HERE BNZ Jump. Example:, Branch if Not Zero = HERE BNZ Jump. Example:, Branch if Not Zero = HERE BNZ Jump. Example:, Branch if Not Zero = HERE BNZ Jump. Example:, Branch if Not Zero = HERE BNZ Jump. Before Instruction PC, Branch if Not Zero = = address. Before Instruction PC, Branch if Not Zero = . Before Instruction PC, Branch if Not Zero = (HERE). Before Instruction PC, Branch if",
    "PIC18(L)F25/26K83\nNot Zero = . Before Instruction PC, Branch if Not Zero = . After Instruction, Branch if Not Zero = =. After Instruction, Branch if Not Zero = 0; address. After Instruction, Branch if Not Zero = . After Instruction, Branch if Not Zero = . After Instruction, Branch if Not Zero = . If ZERO PC If ZERO PC, Branch if Not Zero = = = =. If ZERO PC If ZERO PC, Branch if Not Zero = 1; address. If ZERO PC If ZERO PC, Branch if Not Zero = (Jump) (HERE. If ZERO PC If ZERO PC, Branch if Not Zero = + 2). If ZERO PC If ZERO PC, Branch if Not Zero = ",
    "Unconditional Branch\nAdd the 2's complement number '2n' to the PC. Since the PC will have incre -mented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a 2-cycle instruction.",
    "Unconditional Branch\nSyntax:, 1 = BRA n. Syntax:, 2 = BRA n. Syntax:, 3 = BRA n. Syntax:, 4 = BRA n. Operands:, 1 = -1024 \uf0a3 n \uf0a3 1023. Operands:, 2 = -1024 \uf0a3 n \uf0a3 1023. Operands:, 3 = -1024 \uf0a3 n \uf0a3 1023. Operands:, 4 = -1024 \uf0a3 n \uf0a3 1023. Operation:, 1 = (PC) + 2 + 2n \uf0ae PC. Operation:, 2 = (PC) + 2 + 2n \uf0ae PC. Operation:, 3 = (PC) + 2 + 2n \uf0ae PC. Operation:, 4 = (PC) + 2 + 2n \uf0ae PC. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 1101. Encoding:, 2 = 0nnn. Encoding:, 3 = nnnn. Encoding:, 4 = nnnn\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3",
    "Unconditional Branch\nDecode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nBefore Instruction PC, HERE = =. Before Instruction PC, BRA = address. Before Instruction PC, Jump = (HERE). After Instruction PC, HERE = =. After Instruction PC, BRA = address. After Instruction PC, Jump = (Jump)\nQ4",
    "PIC18(L)F25/26K83\nBSF, 1 = Bit Set f. BSF, 2 = Bit Set f. BSF, 3 = Bit Set f. BSF, 4 = Bit Set f. Syntax:, 1 = BSF f, b {,a}. Syntax:, 2 = BSF f, b {,a}. Syntax:, 3 = BSF f, b {,a}. Syntax:, 4 = BSF f, b {,a}. Operands:, 1 = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7. Operands:, 2 = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7. Operands:, 3 = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7. Operands:, 4 = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7. , 1 = a \uf0ce\uf020 [0,1]. , 2 = a \uf0ce\uf020 [0,1]. , 3 = a \uf0ce\uf020 [0,1]. , 4 = a \uf0ce\uf020 [0,1]. Operation:, 1 = 1 \uf0ae f<b>. Operation:, 2 = 1 \uf0ae f<b>. Operation:, 3 = 1 \uf0ae f<b>. Operation:, 4 = 1 \uf0ae f<b>. Status Affected:, 1 = None. Status Affected:,",
    "PIC18(L)F25/26K83\n2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 1000. Encoding:, 2 = bbba. Encoding:, 3 = ffff. Encoding:, 4 = ffff. Description:, 1 = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, 2 = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed",
    "PIC18(L)F25/26K83\nLiteral Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, 3 = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, 4 = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020",
    "PIC18(L)F25/26K83\n95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q1, 1 = . Q1, 2 = . Q1, 3 = . Q1, 4 = . , 1 = Q2. , 2 = Q2. , 3 = Q3. , 4 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Read register 'f'. Decode, 3 = Process Data. Decode, 4 = Write register 'f'. Example:, 1 = BSF. Example:, 2 = FLAG_REG,. Example:, 3 = 7,.",
    "PIC18(L)F25/26K83\nExample:, 4 = 1. FLAG_REG = After Instruction FLAG_REG =, 1 = FLAG_REG = After Instruction FLAG_REG =. FLAG_REG = After Instruction FLAG_REG =, 2 = 8Ah. FLAG_REG = After Instruction FLAG_REG =, 3 = . FLAG_REG = After Instruction FLAG_REG =, 4 = ",
    "PIC18(L)F25/26K83\nSyntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Operands:, Bit Test File, Skip if Clear = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operation:, Bit Test File, Skip if",
    "PIC18(L)F25/26K83\nClear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Encoding:, Bit Test File, Skip if Clear = 1011. Encoding:, Bit Test File, Skip if Clear = 1011. Encoding:, Bit Test File, Skip if Clear = bbba. Encoding:, Bit Test File, Skip if Clear = ffff. Encoding:, Bit Test File, Skip if Clear = ffff. Description:,",
    "PIC18(L)F25/26K83\nBit Test File, Skip if Clear = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is",
    "PIC18(L)F25/26K83\nselected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Bit Test File,",
    "PIC18(L)F25/26K83\nSkip if Clear = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If",
    "PIC18(L)F25/26K83\n'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Words:, Bit Test File, Skip if Clear = Literal Offset Mode' for details. 1. Words:, Bit Test File, Skip if Clear = Literal Offset Mode' for details. 1. Words:, Bit Test File, Skip if Clear = Literal Offset Mode' for details. 1. Words:, Bit Test File, Skip if Clear = Literal Offset Mode' for details. 1. Words:, Bit Test File, Skip if Clear = Literal Offset Mode' for details. 1. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if",
    "PIC18(L)F25/26K83\nClear = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Q Cycle Activity: Q1, Bit Test File, Skip if Clear = Q2. Q Cycle Activity: Q1, Bit Test File, Skip if Clear = Q2. Q Cycle Activity: Q1, Bit Test File, Skip if Clear = Q3. Q Cycle Activity: Q1, Bit Test File, Skip if Clear = Q3. Q Cycle Activity: Q1, Bit Test File, Skip if Clear = Q4. Decode, Bit Test File, Skip if Clear = Read register 'f'. Decode, Bit Test File, Skip if Clear = Read register 'f'. Decode, Bit Test File, Skip if Clear = Process Data. Decode, Bit Test File, Skip if Clear = Process Data. Decode, Bit Test File, Skip",
    "PIC18(L)F25/26K83\nif Clear = No operation. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. Q1, Bit Test File, Skip if Clear = Q2. Q1, Bit Test File, Skip if Clear = Q2. Q1, Bit Test File, Skip if Clear = Q3. Q1, Bit Test File, Skip if Clear = Q3. Q1, Bit Test File, Skip if Clear = Q4. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear",
    "PIC18(L)F25/26K83\n= If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. Q1, Bit Test File, Skip if Clear = Q2. Q1, Bit Test File, Skip if Clear = Q2. Q1, Bit Test File, Skip if Clear = Q3. Q1, Bit Test File, Skip if Clear = Q3. Q1, Bit Test File, Skip if Clear = Q4. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation.",
    "PIC18(L)F25/26K83\nNo operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. Example: HERE, Bit Test File, Skip if Clear = Example: HERE. Example: HERE, Bit Test File, Skip if Clear = FALSE BTFSC :. Example: HERE, Bit Test File, Skip if Clear = FALSE BTFSC :. Example: HERE, Bit Test File, Skip if Clear = FLAG,. Example: HERE, Bit Test File, Skip if Clear = 1, 0. Before Instruction, Bit Test File, Skip if Clear = Before Instruction. Before Instruction, Bit Test File, Skip if Clear = Before Instruction. Before Instruction, Bit Test File, Skip if Clear = Before Instruction. Before Instruction, Bit Test File, Skip if Clear = Before Instruction. Before Instruction, Bit Test File,",
    "PIC18(L)F25/26K83\nSkip if Clear = Before Instruction. PC, Bit Test File, Skip if Clear = =. PC, Bit Test File, Skip if Clear = . PC, Bit Test File, Skip if Clear = address. PC, Bit Test File, Skip if Clear = (HERE). PC, Bit Test File, Skip if Clear = . After Instruction If FLAG<1> PC, Bit Test File, Skip if Clear = = = =. After Instruction If FLAG<1> PC, Bit Test File, Skip if Clear = 0; address. After Instruction If FLAG<1> PC, Bit Test File, Skip if Clear = 0; address. After Instruction If FLAG<1> PC, Bit Test File, Skip if Clear = (TRUE). After Instruction If FLAG<1> PC, Bit Test File, Skip if Clear = . If FLAG<1> PC, Bit Test File, Skip if Clear = =. If FLAG<1> PC, Bit Test File, Skip if Clear = 1; address. If FLAG<1> PC, Bit Test File, Skip if Clear = 1; address. If FLAG<1> PC, Bit Test File, Skip if Clear = (FALSE). If",
    "PIC18(L)F25/26K83\nFLAG<1> PC, Bit Test File, Skip if Clear = ",
    "PIC18(L)F25/26K83\nSyntax:, BTFSS = Syntax:. Syntax:, Bit Test File, Skip if Set = BTFSS f, b {,a}. Syntax:, Bit Test File, Skip if Set = BTFSS f, b {,a}. Syntax:, Bit Test File, Skip if Set = BTFSS f, b {,a}. Syntax:, Bit Test File, Skip if Set = BTFSS f, b {,a}. Operands:, BTFSS = Operands:. Operands:, Bit Test File, Skip if Set = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Test File, Skip if Set = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Test File, Skip if Set = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Test File, Skip if Set = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operation:, BTFSS = Operation:. Operation:, Bit Test File, Skip if Set = skip if (f<b>) =",
    "PIC18(L)F25/26K83\n1. Operation:, Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, Bit Test File, Skip if Set = skip if (f<b>) = 1. Status Affected:, BTFSS = Status Affected:. Status Affected:, Bit Test File, Skip if Set = None. Status Affected:, Bit Test File, Skip if Set = None. Status Affected:, Bit Test File, Skip if Set = None. Status Affected:, Bit Test File, Skip if Set = None. Encoding:, BTFSS = Encoding:. Encoding:, Bit Test File, Skip if Set = 1010. Encoding:, Bit Test File, Skip if Set = 1010. Encoding:, Bit Test File, Skip if Set = bbba. Encoding:, Bit Test File, Skip if Set = ffff. Description:, BTFSS = Description:. Description:, Bit Test File, Skip if Set = If bit 'b' in register 'f' is ' 1 ', then the next instruction is",
    "PIC18(L)F25/26K83\nskipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Bit Test File, Skip if Set = If bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is '",
    "PIC18(L)F25/26K83\n0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Bit Test File, Skip if Set = If bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Bit Test File, Skip if Set = If bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit",
    "PIC18(L)F25/26K83\n'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Words:, BTFSS = Words:. Words:, Bit Test File, Skip if Set = Literal Offset Mode' for details. 1. Words:, Bit Test File, Skip if Set = Literal Offset Mode' for details. 1. Words:, Bit Test File, Skip if Set = Literal Offset Mode' for details. 1. Words:, Bit Test File, Skip if Set = Literal Offset Mode' for details. 1. Cycles:, BTFSS = Cycles:. Cycles:, Bit Test File, Skip if Set = 1(2) Note: 3",
    "PIC18(L)F25/26K83\ncycles if skip and followed. Cycles:, Bit Test File, Skip if Set = 1(2) Note: 3 cycles if skip and followed. Cycles:, Bit Test File, Skip if Set = 1(2) Note: 3 cycles if skip and followed. Cycles:, Bit Test File, Skip if Set = 1(2) Note: 3 cycles if skip and followed. , BTFSS = Q1. , Bit Test File, Skip if Set = Q2. , Bit Test File, Skip if Set = Q2. , Bit Test File, Skip if Set = Q3. , Bit Test File, Skip if Set = Q3. , BTFSS = Decode. , Bit Test File, Skip if Set = Read register 'f'. , Bit Test File, Skip if Set = Read register 'f'. , Bit Test File, Skip if Set = Process Data. , Bit Test File, Skip if Set = Process Data. If skip:, BTFSS = If skip:. If skip:, Bit Test File, Skip if Set = If skip:. If skip:, Bit Test File, Skip if Set = If skip:. If skip:,",
    "PIC18(L)F25/26K83\nBit Test File, Skip if Set = If skip:. If skip:, Bit Test File, Skip if Set = If skip:. , BTFSS = Q1. , Bit Test File, Skip if Set = Q2. , Bit Test File, Skip if Set = Q2. , Bit Test File, Skip if Set = Q3. , Bit Test File, Skip if Set = Q3. , BTFSS = No operation. , Bit Test File, Skip if Set = No operation. , Bit Test File, Skip if Set = No operation. , Bit Test File, Skip if Set = No operation. , Bit Test File, Skip if Set = No operation. If skip and followed by 2-word instruction:, BTFSS = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Set",
    "PIC18(L)F25/26K83\n= If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. , BTFSS = Q1. , Bit Test File, Skip if Set = Q2. , Bit Test File, Skip if Set = Q2. , Bit Test File, Skip if Set = Q3. , Bit Test File, Skip if Set = Q3. , BTFSS = No operation. , Bit Test File, Skip if Set = No operation. , Bit Test File, Skip if Set = No operation. , Bit Test File, Skip if Set = No operation. , Bit Test File, Skip if Set = No operation. , BTFSS = No operation. , Bit Test File, Skip if Set = No operation. , Bit Test File, Skip if Set = No operation. , Bit Test File, Skip if Set = No operation. , Bit Test File, Skip if Set = No operation. Example:, BTFSS = Example:. Example:, Bit Test File, Skip if Set = HERE FALSE TRUE. Example:, Bit Test File, Skip if",
    "PIC18(L)F25/26K83\nSet = BTFSS :. Example:, Bit Test File, Skip if Set = BTFSS :. Example:, Bit Test File, Skip if Set = FLAG,. Before Instruction, BTFSS = Before Instruction. Before Instruction, Bit Test File, Skip if Set = Before Instruction. Before Instruction, Bit Test File, Skip if Set = Before Instruction. Before Instruction, Bit Test File, Skip if Set = Before Instruction. Before Instruction, Bit Test File, Skip if Set = Before Instruction. , BTFSS = PC. , Bit Test File, Skip if Set = =. , Bit Test File, Skip if Set = address. , Bit Test File, Skip if Set = address. , Bit Test File, Skip if Set = (HERE). , BTFSS = After Instruction If FLAG<1> PC. , Bit Test File, Skip if Set = = =. , Bit Test File, Skip if Set = 0; address. , Bit Test File, Skip if Set = 0; address. , Bit Test File, Skip if Set = (FALSE). , BTFSS = If FLAG<1> PC. , Bit Test File, Skip if Set = =",
    "PIC18(L)F25/26K83\n=. , Bit Test File, Skip if Set = 1; address. , Bit Test File, Skip if Set = 1; address. , Bit Test File, Skip if Set = (TRUE)",
    "PIC18(L)F25/26K83\nSyntax:, Bit Toggle f = BTG f, b {,a}. Syntax:, Bit Toggle f = BTG f, b {,a}. Syntax:, Bit Toggle f = BTG f, b {,a}. Syntax:, Bit Toggle f = BTG f, b {,a}. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255. , Bit Toggle f = 0 \uf0a3 b < 7. , Bit Toggle f = 0 \uf0a3 b < 7. , Bit Toggle f = 0 \uf0a3 b < 7. , Bit Toggle f = 0 \uf0a3 b < 7. , Bit Toggle f = a \uf0ce\uf020 [0,1]. , Bit Toggle f = a \uf0ce\uf020 [0,1]. , Bit Toggle f = a \uf0ce\uf020 [0,1]. , Bit Toggle f = a \uf0ce\uf020 [0,1]. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit",
    "PIC18(L)F25/26K83\nToggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Encoding:, Bit Toggle f = 0111. Encoding:, Bit Toggle f = bbba. Encoding:, Bit Toggle f = ffff. Encoding:, Bit Toggle f = ffff. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is\nBit 'b' in data memory location 'f' is inverted.",
    "PIC18(L)F25/26K83\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec -tion 42.2.3 'Byte-Oriented and BitOriented Instructions in Indexed Lit -eral Offset Mode' for details.\n1\nWords:\nCycles:\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write register 'f'\nBefore Instruction: PORTC =, BTG = 0111. Before Instruction: PORTC =, PORTC, = 0101. Before Instruction: PORTC =, 4, 0 = [75h]. After Instruction: PORTC =, BTG = 0110. After Instruction: PORTC =, PORTC, = 0101. After Instruction: PORTC =, 4, 0 = [65h]",
    "PIC18(L)F25/26K83\nBOV, 1 = BOV. BOV, 2 = Branch if Overflow. BOV, 3 = Branch if Overflow. BOV, 4 = Branch if Overflow. BOV, 5 = Branch if Overflow. Syntax:, 1 = Syntax:. Syntax:, 2 = BOV n. Syntax:, 3 = BOV n. Syntax:, 4 = BOV n. Syntax:, 5 = BOV n. Operands:, 1 = Operands:. Operands:, 2 = -128 \uf0a3 n \uf0a3 127. Operands:, 3 = -128 \uf0a3 n \uf0a3 127. Operands:, 4 = -128 \uf0a3 n \uf0a3 127. Operands:, 5 = -128 \uf0a3 n \uf0a3 127. Operation:, 1 = Operation:. Operation:, 2 = if OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 3 = if OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 4 = if OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 5 = if OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \uf0ae",
    "PIC18(L)F25/26K83\nPC. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 1110. Encoding:, 3 = 1110. Encoding:, 4 = 0100. Encoding:, 5 = nnnn. Description:, 1 = Description:. Description:, 2 = If the OVERFLOW bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 3 = If the OVERFLOW bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:,",
    "PIC18(L)F25/26K83\n4 = If the OVERFLOW bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 5 = If the OVERFLOW bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1(2). Cycles:, 3 = 1(2). Cycles:, 4 = 1(2). Cycles:, 5 = 1(2). Q Cycle Activity: If Jump:, 1 = Q Cycle Activity: If",
    "PIC18(L)F25/26K83\nJump:. Q Cycle Activity: If Jump:, 2 = . Q Cycle Activity: If Jump:, 3 = . Q Cycle Activity: If Jump:, 4 = . Q Cycle Activity: If Jump:, 5 = . , 1 = Q1. , 2 = Q2. , 3 = . , 4 = Q3. , 5 = . , 1 = Decode. , 2 = Read literal 'n'. , 3 = Read literal 'n'. , 4 = Process Data. , 5 = Process Data. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation. , 5 = No operation. , 1 = Q1. , 2 = Q2. , 3 = Q2. , 4 = Q3. , 5 = Q3. , 1 = Decode. , 2 = Read literal 'n'. , 3 = Read literal 'n'. , 4 = Process Data. , 5 = Process Data. Example:, 1 = Example:. Example:, 2 = HERE. Example:, 3 = BOV. Example:, 4 = Jump. Example:, 5 = . , 1 =",
    "PIC18(L)F25/26K83\nBefore Instruction PC. , 2 = =. , 3 = address. , 4 = (HERE). , 5 = . , 1 = If OVERFLOW= PC = If. , 2 = If OVERFLOW= PC = If. , 3 = 1; address 0;. , 4 = (Jump). , 5 = . , 1 = OVERFLOW= PC =. , 2 = OVERFLOW= PC =. , 3 = address. , 4 = (HERE. , 5 = +",
    "PIC18(L)F25/26K83\nSyntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Zero = if ZERO bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero = if ZERO bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero = if ZERO bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero = if ZERO bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero = if ZERO bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:,",
    "PIC18(L)F25/26K83\nBranch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Encoding:, Branch if Zero = 1110. Encoding:, Branch if Zero = 1110. Encoding:, Branch if Zero = 0000. Encoding:, Branch if Zero = nnnn. Encoding:, Branch if Zero = nnnn. Description:, Branch if Zero = If the ZERO bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Zero = If the ZERO bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a",
    "PIC18(L)F25/26K83\n2-cycle instruction.. Description:, Branch if Zero = If the ZERO bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Zero = If the ZERO bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Zero = If the ZERO bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, Branch if Zero = 1. Words:, Branch",
    "PIC18(L)F25/26K83\nif Zero = 1. Words:, Branch if Zero = 1. Words:, Branch if Zero = 1. Words:, Branch if Zero = 1. Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Q Cycle Activity: If Jump:, Branch if Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Zero = Q Cycle Activity: If Jump:. Q1 Q2 Q3 Q4, Branch if Zero = Q1 Q2 Q3 Q4. Q1 Q2 Q3 Q4, Branch if Zero = Q1 Q2 Q3 Q4. Q1 Q2 Q3",
    "PIC18(L)F25/26K83\nQ4, Branch if Zero = Q1 Q2 Q3 Q4. Q1 Q2 Q3 Q4, Branch if Zero = Q1 Q2 Q3 Q4. Q1 Q2 Q3 Q4, Branch if Zero = Q1 Q2 Q3 Q4. Decode Read literal 'n' Process Data Write to PC No operation No operation No operation No operation Jump:, Branch if Zero = Decode Read literal 'n' Process Data Write to PC No operation No operation No operation No operation Jump:. Decode Read literal 'n' Process Data Write to PC No operation No operation No operation No operation Jump:, Branch if Zero = Decode Read literal 'n' Process Data Write to PC No operation No operation No operation No operation Jump:. Decode Read literal 'n' Process Data Write to PC No operation No operation No operation No operation Jump:, Branch if Zero = Decode Read literal 'n' Process Data Write to PC No operation No operation No operation No operation Jump:. Decode Read literal 'n' Process Data Write to PC No operation No operation No operation No operation Jump:, Branch if Zero = Decode Read literal 'n'",
    "PIC18(L)F25/26K83\nProcess Data Write to PC No operation No operation No operation No operation Jump:. Decode Read literal 'n' Process Data Write to PC No operation No operation No operation No operation Jump:, Branch if Zero = Decode Read literal 'n' Process Data Write to PC No operation No operation No operation No operation Jump:. Q1 Q2 Q3 Q4, Branch if Zero = Q1 Q2 Q3 Q4. Q1 Q2 Q3 Q4, Branch if Zero = Q1 Q2 Q3 Q4. Q1 Q2 Q3 Q4, Branch if Zero = Q1 Q2 Q3 Q4. Q1 Q2 Q3 Q4, Branch if Zero = Q1 Q2 Q3 Q4. Q1 Q2 Q3 Q4, Branch if Zero = Q1 Q2 Q3 Q4. Decode Read literal 'n' Process Data No operation, Branch if Zero = Decode Read literal 'n' Process Data No operation. Decode Read literal 'n' Process Data No operation, Branch if Zero = Decode Read literal 'n' Process Data No operation. Decode Read literal 'n' Process Data No operation,",
    "PIC18(L)F25/26K83\nBranch if Zero = Decode Read literal 'n' Process Data No operation. Decode Read literal 'n' Process Data No operation, Branch if Zero = Decode Read literal 'n' Process Data No operation. Decode Read literal 'n' Process Data No operation, Branch if Zero = Decode Read literal 'n' Process Data No operation. HERE BZ Jump, Branch if Zero = HERE BZ Jump. HERE BZ Jump, Branch if Zero = HERE BZ Jump. HERE BZ Jump, Branch if Zero = HERE BZ Jump. HERE BZ Jump, Branch if Zero = HERE BZ Jump. HERE BZ Jump, Branch if Zero = HERE BZ Jump. Example:, Branch if Zero = Example:. Example:, Branch if Zero = Example:. Example:, Branch if Zero = Example:. Example:, Branch if Zero = Example:. Example:, Branch if Zero = Example:. Before Instruction, Branch if Zero = Before Instruction. Before Instruction, Branch if Zero = Before Instruction. Before Instruction, Branch if Zero = . Before Instruction, Branch if Zero = . Before Instruction, Branch if Zero = . , Branch if Zero = . , Branch",
    "PIC18(L)F25/26K83\nif Zero = . , Branch if Zero = . , Branch if Zero = (HERE). , Branch if Zero = . PC =, Branch if Zero = PC =. PC =, Branch if Zero = PC =. PC =, Branch if Zero = . PC =, Branch if Zero = . PC =, Branch if Zero = . After, Branch if Zero = After. After, Branch if Zero = After. After, Branch if Zero = . After, Branch if Zero = . After, Branch if Zero = . , Branch if Zero = . , Branch if Zero = . , Branch if Zero = address. , Branch if Zero = . , Branch if Zero = . Instruction 1;, Branch if Zero = Instruction 1;. Instruction 1;, Branch if Zero = Instruction 1;. Instruction 1;, Branch if Zero = Instruction 1;. Instruction 1;, Branch if Zero = Instruction 1;. Instruction 1;, Branch if Zero = Instruction 1;. , Branch if Zero = . , Branch if Zero = =. , Branch if Zero = . , Branch if Zero = . , Branch if Zero = . If ZERO =, Branch if Zero = If ZERO =. If ZERO =,",
    "PIC18(L)F25/26K83\nBranch if Zero = . If ZERO =, Branch if Zero = . If ZERO =, Branch if Zero = . If ZERO =, Branch if Zero = . , Branch if Zero = . , Branch if Zero = . , Branch if Zero = address (Jump). , Branch if Zero = address (Jump). , Branch if Zero = address (Jump). PC, Branch if Zero = PC. PC, Branch if Zero = . PC, Branch if Zero = . PC, Branch if Zero = . PC, Branch if Zero = . ZERO =, Branch if Zero = ZERO =. ZERO =, Branch if Zero = . ZERO =, Branch if Zero = . ZERO =, Branch if Zero = . ZERO =, Branch if Zero = . , Branch if Zero = . , Branch if Zero = . , Branch if Zero = address. , Branch if Zero = address. , Branch if Zero = address. If, Branch if Zero = If. If, Branch if Zero = . If, Branch if Zero = . If, Branch if Zero = . If, Branch if Zero = . , Branch if Zero = . , Branch if Zero = =. , Branch if Zero = . , Branch if Zero",
    "PIC18(L)F25/26K83\n= . , Branch if Zero = . PC, Branch if Zero = PC. PC, Branch if Zero = . PC, Branch if Zero = . PC, Branch if Zero = . PC, Branch if Zero = . , Branch if Zero = . , Branch if Zero = . , Branch if Zero = (HERE + 2). , Branch if Zero = (HERE + 2). , Branch if Zero = (HERE + 2). 0;, Branch if Zero = 0;. 0;, Branch if Zero = 0;. 0;, Branch if Zero = 0;. 0;, Branch if Zero = 0;. 0;, Branch if Zero = 0;",
    "PIC18(L)F25/26K83\nSyntax:, Subroutine Call = CALL k {,s}. Syntax:, Subroutine Call = CALL k {,s}. Syntax:, Subroutine Call = CALL k {,s}. Syntax:, Subroutine Call = CALL k {,s}. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (W) \uf0ae WS, (Status) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (W) \uf0ae WS, (Status) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, Subroutine",
    "PIC18(L)F25/26K83\nCall = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (W) \uf0ae WS, (Status) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (W) \uf0ae WS, (Status) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = 110s k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = k 7 kkk kkkk. Encoding: 1st word",
    "PIC18(L)F25/26K83\n(k<7:0>) 2nd word(k<19:8>), Subroutine Call = kkkk 0 kkkk 8. Description:, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a 2-cycle instruction.. Description:, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into",
    "PIC18(L)F25/26K83\nPC<20:1>. CALL is a 2-cycle instruction.. Description:, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a 2-cycle instruction.. Description:, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a 2-cycle instruction..",
    "PIC18(L)F25/26K83\nWords:, Subroutine Call = 2. Words:, Subroutine Call = 2. Words:, Subroutine Call = 2. Words:, Subroutine Call = 2. Cycles:, Subroutine Call = 2. Cycles:, Subroutine Call = 2. Cycles:, Subroutine Call = 2. Cycles:, Subroutine Call = 2. Q Cycle Activity:, Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call = Q Cycle Activity:. Q1, Subroutine Call = Q2. Q1, Subroutine Call = Q3. Q1, Subroutine Call = Q4. Q1, Subroutine Call = Q4. Decode, Subroutine Call = Read literal 'k'<7:0>,. Decode, Subroutine Call = PUSHPCto stack. Decode, Subroutine Call = Read literal 'k'<19:8>, Write to PC. Decode,",
    "PIC18(L)F25/26K83\nSubroutine Call = Read literal 'k'<19:8>, Write to PC. No operation, Subroutine Call = No operation. No operation, Subroutine Call = No operation. No operation, Subroutine Call = No operation. No operation, Subroutine Call = No operation\nBefore Instruction, HERE = . Before Instruction, CALL THERE, 1 = . Before Instruction,  = . PC, HERE = =. PC, CALL THERE, 1 = address. PC,  = (HERE). After Instruction, HERE = . After Instruction, CALL THERE, 1 = . After Instruction,  = . PC, HERE = =. PC, CALL THERE, 1 = address. PC,  = (THERE). TOS, HERE = =. TOS, CALL THERE, 1 = address. TOS,  = (HERE + 4). WS, HERE = =. WS, CALL THERE, 1 = W. WS,  = . BSRS, HERE = =. BSRS, CALL THERE, 1 = BSR. BSRS,  = . STATUSS=, HERE = . STATUSS=, CALL THERE, 1 = Status. STATUSS=,  = ",
    "CALLW\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding: Description\nWords:\nCycles:\nQ Cycle Activity:",
    "Subroutine Call Using WREG\nCALLW\nNone\n(PC + 2) \uf0ae TOS,\n(W) \uf0ae PCL,\n(PCLATH) \uf0ae PCH,\n(PCLATU) \uf0ae PCU",
    "None\n0000\n0000\n0001\n0100\nFirst, the return address (PC + 2) is pushed onto the return stack. Next, the contents of W are written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL , there is no option to update W, Status or BSR.\n1\n2\nQ1\nQ2\nQ3\nQ4\nDecode, 1 = Read WREG. Decode, 2 = PUSHPC to stack. Decode, 3 = No operation. No operation, 1 = No opera - tion. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE\nCALLW\nBefore Instruction\nPC\n=\naddress\n(HERE)\nPCLATH =\n10h\nPCLATU =\n00h\nW\n=\n06h\nAfter Instruction\nPC\n=\n001006h\nTOS\n=\naddress (HERE + 2)\nPCLATH =\n10h\nPCLATU =\n00h\nW\n=\n06h",
    "Clear f\nSyntax:\nCLRF    f {,a}\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce\uf020 [0,1]\nOperation:\n000h \uf0ae f\n1 \uf0ae Z\nStatus Affected:\nZ\nEncoding:\n0110\n101a\nffff\nffff\nDescription:\nClears the contents of the specified register.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite\nregister 'f'\nExample:\nCLRF\nFLAG_REG, 1\nBefore Instruction\nFLAG_REG\n=\n5Ah\nAfter Instruction\nFLAG_REG\n=\n00h",
    "Clear f\nSyntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO, 1 \uf0ae PD. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO, 1 \uf0ae PD. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO, 1 \uf0ae PD. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO, 1 \uf0ae PD. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO, 1 \uf0ae",
    "Clear f\nPD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0100. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post - scaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post - scaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post - scaler of the WDT. Status bits, TO and PD, are",
    "Clear f\nset.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post - scaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post - scaler of the WDT. Status bits, TO and PD, are set.. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q",
    "Clear f\nCycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = Q4. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = No operation. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Before Instruction WDT Counter, Clear Watchdog Timer = Before Instruction WDT Counter. Before Instruction WDT Counter, Clear Watchdog Timer = =. Before Instruction WDT Counter, Clear Watchdog Timer = ?. Before Instruction WDT Counter, Clear Watchdog Timer = . Before Instruction WDT Counter, Clear Watchdog Timer",
    "Clear f\n= . WDT Counter WDT Postscaler, Clear Watchdog Timer = WDT Counter WDT Postscaler. WDT Counter WDT Postscaler, Clear Watchdog Timer = = =. WDT Counter WDT Postscaler, Clear Watchdog Timer = 00h 0. WDT Counter WDT Postscaler, Clear Watchdog Timer = . WDT Counter WDT Postscaler, Clear Watchdog Timer = . TO, Clear Watchdog Timer = TO. TO, Clear Watchdog Timer = =. TO, Clear Watchdog Timer = 1. TO, Clear Watchdog Timer = . TO, Clear Watchdog Timer = . PD, Clear Watchdog Timer = PD. PD, Clear Watchdog Timer = =. PD, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = . PD, Clear Watchdog Timer = ",
    "PIC18(L)F25/26K83\nSyntax:, Complement f = COMF. Syntax:, Complement f = f {,d {,a}}. Syntax:, Complement f = . Syntax:, Complement f = . Operands:, Complement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Complement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Complement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Complement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operation:, Complement f = (f) \uf0ae dest. Operation:, Complement f = (f) \uf0ae dest. Operation:, Complement f = (f) \uf0ae dest. Operation:, Complement f = (f) \uf0ae dest. Status Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z. Encoding:, Complement f = 0001. Encoding:, Complement f = 11da. Encoding:, Complement f = ffff. Encoding:, Complement f = ffff. Description:, Complement f = The contents",
    "PIC18(L)F25/26K83\ncomplemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit -. Description:, Complement f = of. Description:, Complement f = register 'f' are. Description:, Complement f = The contents complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If",
    "PIC18(L)F25/26K83\n'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit -. Words:, Complement f = 1. Words:, Complement f = 1. Words:, Complement f = 1. Words:, Complement f = 1. Cycles:, Complement f = 1. Cycles:, Complement f = 1. Cycles:, Complement f = 1. Cycles:, Complement f = 1. Q Cycle Activity:, Complement f = . Q Cycle Activity:, Complement f = . Q Cycle Activity:, Complement f = . Q Cycle Activity:, Complement f = . Q1, Complement f = Q2. Q1, Complement f = Q3. Q1, Complement f = Q3. Q1, Complement f = Q4. Decode, Complement f = Read register 'f'. Decode, Complement f = Process Data. Decode, Complement f = Process Data. Decode, Complement f = Write to destination. Example:, Complement f = COMF.",
    "PIC18(L)F25/26K83\nExample:, Complement f = REG,. Example:, Complement f = 0, 0. Example:, Complement f = . Before Instruction REG = After Instruction, Complement f = 13h. Before Instruction REG = After Instruction, Complement f = . Before Instruction REG = After Instruction, Complement f = . Before Instruction REG = After Instruction, Complement f = . W, Complement f = ECh. W, Complement f = . W, Complement f = . W, Complement f = \nCPFSEQ",
    "Compare f with W, skip if f = W\nSyntax:\nCPFSEQ    f {,a}\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce [0,1]\nOperation:\n(f) - (W),\nskip if (f) = (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n001a\nffff\nffff\nDescription:\nCompares the contents of data memory location 'f' to the contents of W by performing an unsigned subtraction. If 'f' = W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.\nWords:\n1\nCycles:\n1(2)\nWords:\n1\nCycles:\n1(2)\nNote:",
    "Compare f with W, skip if f = W\n3 cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:",
    "Compare f with W, skip if f = W\nDecode If skip:, Q2 = Read register 'f' Process Data. Decode If skip:, Q3 = Read register 'f' Process Data. Decode If skip:, Q4 = No operation. Q1 No, Q2 = Q2 Q3. Q1 No, Q3 = Q2 Q3. Q1 No, Q4 = Q4 No. operation and followed, Q2 = No operation No operation. operation and followed, Q3 = No operation No operation. operation and followed, Q4 = operation. skip by 2-word instruction:, Q2 = skip by 2-word instruction:. skip by 2-word instruction:, Q3 = skip by 2-word instruction:. skip by 2-word instruction:, Q4 = skip by 2-word instruction:. Q1, Q2 = Q2 Q3. Q1, Q3 = Q2 Q3. Q1, Q4 = Q4. No operation, Q2 = No operation No operation. No operation, Q3 = No operation No operation. No operation, Q4 = No operation. No operation, Q2 = No operation No operation. No",
    "Compare f with W, skip if f = W\noperation, Q3 = No operation No operation. No operation, Q4 = No operation. Example:, Q2 = HERE CPFSEQ REG,. Example:, Q3 = HERE CPFSEQ REG,. Example:, Q4 = 0. Before Instruction, Q2 = Before Instruction. Before Instruction, Q3 = . Before Instruction, Q4 = . PC Address = W =, Q2 = PC Address = W =. PC Address = W =, Q3 = HERE. PC Address = W =, Q4 = . REG = After Instruction, Q2 = REG = After Instruction. REG = After Instruction, Q3 = ?. REG = After Instruction, Q4 = . If REG, Q2 = =. If REG, Q3 = W;. If REG, Q4 = . PC REG \uf0b9, Q2 = =. PC REG \uf0b9, Q3 = Address. PC REG \uf0b9, Q4 = (EQUAL). If, Q2 = If. If, Q3 = W;. If, Q4 = . PC =, Q2 = PC =. PC =, Q3 = Address. PC =, Q4 = (NEQUAL)",
    "Compare f with W, skip if f > W\nSyntax:\nCPFSGT    f {,a}\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce [0,1]\nOperation:\n(f) - \uf020\uf028 W),\nskip if (f) > (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n010a\nffff\nffff\nDescription:\nCompares the contents of data memory\nlocation 'f' to the contents of the W by performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec -\ntion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.\nWords:\n1\nCycles:\n1(2)\nNote:",
    "Compare f with W, skip if f > W\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f' Process Data. Decode, Q3 = Read register 'f' Process Data. Decode, Q4 = No operation. If skip:, Q2 = . If skip:, Q3 = . If skip:, Q4 = . Q1, Q2 = Q2 Q3. Q1, Q3 = Q2 Q3. Q1, Q4 = Q4. No operation, Q2 = No operation No operation. No operation, Q3 = No operation No operation. No operation, Q4 = No operation. If skip and followed by 2-word instruction:, Q2 = . If skip and followed by 2-word instruction:, Q3 = . If skip and followed by 2-word instruction:, Q4 = . Q1, Q2 = Q2 Q3. Q1, Q3 = Q2 Q3. Q1, Q4 = Q4. No operation, Q2 = No operation No operation. No operation, Q3 = No operation No operation. No operation, Q4 = No operation. No operation, Q2 = No operation No operation. No operation, Q3 = No operation No operation.",
    "Q Cycle Activity:\nNo operation, Q4 = No operation. Example:, Q2 = HERE CPFSGT REG, 0. Example:, Q3 = HERE CPFSGT REG, 0. Example:, Q4 = HERE CPFSGT REG, 0. Before Instruction, Q2 = Before Instruction. Before Instruction, Q3 = Address (HERE). Before Instruction, Q4 = Address (HERE). PC = W = After Instruction, Q2 = PC = W = After Instruction. PC = W = After Instruction, Q3 = ?. PC = W = After Instruction, Q4 = ?. , Q2 = . , Q3 = W;. , Q4 = W;. PC = If REG \uf0a3, Q2 = PC = If REG \uf0a3. PC = If REG \uf0a3, Q3 = Address (GREATER) W;. PC = If REG \uf0a3, Q4 = Address (GREATER) W;. , Q2 = . , Q3 = Address (NGREATER). , Q4 = Address (NGREATER). PC =, Q2 = PC =. PC =, Q3 = . PC =, Q4 = ",
    "Q Cycle Activity:\nSyntax:, CPFSLT = Syntax:. Syntax:, Compare f with W, skip if f < W = CPFSLT f {,a}. Syntax:, Compare f with W, skip if f < W = CPFSLT f {,a}. Syntax:, Compare f with W, skip if f < W = CPFSLT f {,a}. Operands:, CPFSLT = Operands:. Operands:, Compare f with W, skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, CPFSLT = Operation:. Operation:, Compare f with W, skip if f < W = (f) - \uf020\uf028 W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, skip if f < W = (f) - \uf020\uf028 W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f with",
    "Q Cycle Activity:\nW, skip if f < W = (f) - \uf020\uf028 W), skip if (f) < (W) (unsigned comparison). Status Affected:, CPFSLT = Status Affected:. Status Affected:, Compare f with W, skip if f < W = None. Status Affected:, Compare f with W, skip if f < W = None. Status Affected:, Compare f with W, skip if f < W = None. Encoding:, CPFSLT = Encoding:. Encoding:, Compare f with W, skip if f < W = 0110. Encoding:, Compare f with W, skip if f < W = 0110. Encoding:, Compare f with W, skip if f < W = 000a ffff. Description:, CPFSLT = Description:. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank",
    "Q Cycle Activity:\nis selected. If 'a' is ' 1 ', the BSR is used to select the. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the. Words:, CPFSLT = Words:. Words:, Compare f",
    "Q Cycle Activity:\nwith W, skip if f < W = 1. Words:, Compare f with W, skip if f < W = 1. Words:, Compare f with W, skip if f < W = 1. Cycles:, CPFSLT = Cycles:. Cycles:, Compare f with W, skip if f < W = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Compare f with W, skip if f < W = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Compare f with W, skip if f < W = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Q Cycle Activity:, CPFSLT = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, skip if f < W = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, skip if f < W = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, skip if f < W = Q Cycle Activity:. , CPFSLT = Q1. , Compare f with W, skip if f < W =",
    "Q Cycle Activity:\nQ2. , Compare f with W, skip if f < W = Q2. , Compare f with W, skip if f < W = Q3. , CPFSLT = Decode. , Compare f with W, skip if f < W = Read register 'f'. , Compare f with W, skip if f < W = Read register 'f'. , Compare f with W, skip if f < W = Process Data. If skip:, CPFSLT = If skip:. If skip:, Compare f with W, skip if f < W = If skip:. If skip:, Compare f with W, skip if f < W = If skip:. If skip:, Compare f with W, skip if f < W = If skip:. , CPFSLT = Q1. , Compare f with W, skip if f < W = Q2. , Compare f with W, skip if f < W = Q2. , Compare f with W, skip if f < W = Q3. , CPFSLT = No operation. , Compare f with W, skip if f < W = No operation. , Compare f with W, skip if f < W = No operation.",
    "Q Cycle Activity:\n, Compare f with W, skip if f < W = No operation. If skip and followed by 2-word instruction:, CPFSLT = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, skip if f < W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, skip if f < W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, skip if f < W = If skip and followed by 2-word instruction:. , CPFSLT = Q1. , Compare f with W, skip if f < W = Q2. , Compare f with W, skip if f < W = Q2. , Compare f with W, skip if f < W = Q3. , CPFSLT = No operation. , Compare f with W, skip if f < W = No operation. , Compare f with W, skip if f < W = No operation. , Compare f with W, skip if f < W = No operation. , CPFSLT = No",
    "Q Cycle Activity:\noperation. , Compare f with W, skip if f < W = No operation. , Compare f with W, skip if f < W = No operation. , Compare f with W, skip if f < W = No operation. Example:, CPFSLT = Example:. Example:, Compare f with W, skip if f < W = HERE NLESS LESS. Example:, Compare f with W, skip if f < W = CPFSLT REG, : :. Example:, Compare f with W, skip if f < W = CPFSLT REG, : :. Before Instruction, CPFSLT = Before Instruction. Before Instruction, Compare f with W, skip if f < W = Before Instruction. Before Instruction, Compare f with W, skip if f < W = . Before Instruction, Compare f with W, skip if f < W = . , CPFSLT = PC W. , Compare f with W, skip if f < W = = =. , Compare f with W, skip if f < W = Address (HERE) ?. , Compare f with W, skip if f < W = Address (HERE) ?. After Instruction, CPFSLT = After Instruction. After Instruction, Compare f with",
    "Q Cycle Activity:\nW, skip if f < W = After Instruction. After Instruction, Compare f with W, skip if f < W = After Instruction. After Instruction, Compare f with W, skip if f < W = After Instruction. , CPFSLT = If REG PC. , Compare f with W, skip if f < W = <. , Compare f with W, skip if f < W = W; Address (LESS). , Compare f with W, skip if f < W = W; Address (LESS). , CPFSLT = If REG. , Compare f with W, skip if f < W = \uf0b3. , Compare f with W, skip if f < W = W;. , Compare f with W, skip if f < W = W;. , CPFSLT = PC. , Compare f with W, skip if f < W = =. , Compare f with W, skip if f < W = Address (NLESS). , Compare f with W, skip if f < W = Address (NLESS)",
    "Decimal Adjust W Register\nSyntax:\nDAW\nOperands:\nNone\nOperation:\nIf [W<3:0> > 9] or [DC = 1] then (W<3:0>) + 6 \uf0ae W<3:0>; else\n( W<3:0>) \uf0ae W<3:0>;\nIf [W<7:4> + DC > 9] or [C = 1] then ( W<7:4>) + 6 + DC \uf0ae W<7:4> ; \uf020 else\n(W<7:4>) + DC \uf0ae W<7:4>\nStatus Affected:\nC\nEncoding:\n0000\n0000\n0000\n0111\nDescription:\nDAW adjusts the 8-bit value in W, result - ing from the earlier addition of two vari - ables (each in packed BCD format) and produces a correct packed BCD result.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister W\nProcess\nData\nWrite\nW\nExample1:\nDAW\nBefore Instruction\nW\n=\nA5h\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n= 05h\nC\n=\n1\nDC\n=\n0\nExample 2:\nBefore Instruction\nW\n=\nCEh\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n=",
    "Decimal Adjust W Register\n34h\nC\n=\n1\nDC\n=\n0",
    "Decimal Adjust W Register\nSyntax:, Decrement f = DECF f. Syntax:, Decrement f = {,d {,a}}. Syntax:, Decrement f = . Syntax:, Decrement f = . Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255. Operands:, Decrement f = . Operands:, Decrement f = . , Decrement f = d \uf0ce [0,1]. , Decrement f = d \uf0ce [0,1]. , Decrement f = . , Decrement f = . , Decrement f = a \uf0ce [0,1]. , Decrement f = a \uf0ce [0,1]. , Decrement f = . , Decrement f = . Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = . Operation:, Decrement f = . Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f =",
    "Decimal Adjust W Register\nC, DC, N, OV, Z. Status Affected:, Decrement f = . Status Affected:, Decrement f = . Encoding:, Decrement f = 0000. Encoding:, Decrement f = 01da. Encoding:, Decrement f = ffff. Encoding:, Decrement f = ffff. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the\nDecrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).",
    "Decimal Adjust W Register\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec -tion 42.2.3 'Byte-Oriented and BitOriented Instructions in Indexed Lit -eral Offset Mode' for details.\n1\n1\nWords:\nCycles:\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nDECF    CNT,\n1, 0\nBefore Instruction\nCNT\n=\nZ\n=\nAfter Instruction\nCNT\nZ\n=\n=\n01h\n0\n00h\n1",
    "PIC18(L)F25/26K83\nDECFSZ, 1 = DECFSZ. DECFSZ, 2 = Decrement f, skip if 0. DECFSZ, 3 = Decrement f, skip if 0. DECFSZ, 4 = Decrement f, skip if 0. DECFSZ, 5 = Decrement f, skip if 0. Syntax:, 1 = Syntax:. Syntax:, 2 = DECFSZ f {,d {,a}}. Syntax:, 3 = DECFSZ f {,d {,a}}. Syntax:, 4 = DECFSZ f {,d {,a}}. Syntax:, 5 = DECFSZ f {,d {,a}}. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 3 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 4 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 5 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce",
    "PIC18(L)F25/26K83\n[0,1]. Operation:, 1 = Operation:. Operation:, 2 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, 3 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, 4 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, 5 = (f) - 1 \uf0ae dest, skip if result = 0. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 0010 11da. Encoding:, 3 = ffff. Encoding:, 4 = ffff. Encoding:, 5 = . Description:, 1 = Description:. Description:, 2 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ',",
    "PIC18(L)F25/26K83\nthe next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, 3 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1",
    "PIC18(L)F25/26K83\n', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, 4 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec",
    "PIC18(L)F25/26K83\n- tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, 5 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 =",
    "PIC18(L)F25/26K83\n1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, 3 = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, 4 = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, 5 = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycle Activity:, 1 = Cycle Activity:. Cycle Activity:, 2 = . Cycle Activity:, 3 = . Cycle Activity:, 4 = . Cycle Activity:, 5 = . Q1, 1 = . Q1, 2 = Q2. Q1, 3 = Q3. Q1, 4 = Q4. Q1, 5 = . Decode, 1 = Read register 'f'. Decode, 2 = Read register 'f'. Decode, 3 = Process Data. Decode, 4 = Write to destination. Decode, 5 = . If",
    "PIC18(L)F25/26K83\nskip:, 1 = If skip:. If skip:, 2 = If skip:. If skip:, 3 = If skip:. If skip:, 4 = If skip:. If skip:, 5 = If skip:. Q1, 1 = Q2. Q1, 2 = Q2. Q1, 3 = Q3. Q1, 4 = Q4. Q1, 5 = . No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 4 = No operation. No operation, 5 = . If skip and followed by 2-word instruction:, 1 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 2 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 3 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 4 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 5 = If skip and followed by 2-word",
    "PIC18(L)F25/26K83\ninstruction:. Q1, 1 = Q2. Q1, 2 = Q2. Q1, 3 = Q3. Q1, 4 = Q4. Q1, 5 = . No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 4 = No operation. No operation, 5 = . No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 4 = No operation. No operation, 5 = . Example:, 1 = Example:. Example:, 2 = HERE. Example:, 3 = DECFSZ GOTO. Example:, 4 = CNT, 1, 1 LOOP. Example:, 5 = . CONTINUE, 1 = CONTINUE. CONTINUE, 2 = CONTINUE. CONTINUE, 3 = CONTINUE. CONTINUE, 4 = CONTINUE. CONTINUE, 5 = CONTINUE. Before Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. Before Instruction, 3 = Before Instruction. Before Instruction, 4 = Before Instruction. Before Instruction, 5 = Before Instruction. PC, 1 = Address. PC, 2 = Address.",
    "PIC18(L)F25/26K83\nPC, 3 = (HERE). PC, 4 = . PC, 5 = . After Instruction CNT =, 1 = After Instruction CNT =. After Instruction CNT =, 2 = After Instruction CNT =. After Instruction CNT =, 3 = After Instruction CNT =. After Instruction CNT =, 4 = After Instruction CNT =. After Instruction CNT =, 5 = After Instruction CNT =. If CNT PC, 1 = CNT - 1. If CNT PC, 2 = CNT - 1. If CNT PC, 3 = (CONTINUE). If CNT PC, 4 = . If CNT PC, 5 = . If CNT PC, 1 = 0; = Address. If CNT PC, 2 = 0; = Address. If CNT PC, 3 = (HERE +. If CNT PC, 4 = 2). If CNT PC, 5 = ",
    "Decrement f, skip if not 0\nSyntax:\nDCFSNZ    f {,d {,a}}\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n(f) - 1 \uf0ae dest,\nskip if result \uf0b9 0\nStatus Affected:\nNone\nEncoding:\n0100\n11da\nffff\nffff\nDescription:\nThe contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.",
    "Decrement f, skip if not 0\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "If skip:\nNo operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No = No operation. No operation, No = No operation. No operation, No = No operation\nExample:\nHERE    DCFSNZ  TEMP, 1, 0\nZERO    :\nNZERO   :\nBefore Instruction\nTEMP\n=\n?\nAfter Instruction\nTEMP\n=\nTEMP - 1,\nIf TEMP\n=\n0;\nPC\n=\nAddress (ZERO)\nIf TEMP\n\uf0b9\n0;\nPC\n=\nAddress (NZERO)",
    "Unconditional Branch\nSyntax:\nGOTO   k\nOperands:\n0 \uf0a3 k \uf0a3 1048575\nOperation:\nk \uf0ae PC<20:1>\nStatus Affected:\nNone\nEncoding: 1st word (k<7:0>) 2nd word(k<19:8>)\n1110\n1111\n1111\nk19 kkk\nk 7\nkkk\nkkkk\nkkkk0\nkkkk8\nDescription:\nGOTO allows an unconditional branch\nanywhere within entire\n2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.\nWords:\n2\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal\n'k'<7:0>,\nNo\noperation\nRead literal\n'k'<19:8>,\nWrite to PC\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation",
    "Example:\nGOTO THERE\nAfter Instruction\nPC\n=\nAddress\n(THERE)",
    "Example:\nSyntax:, Increment f = INCF. Syntax:, Increment f = f {,d {,a}}. Syntax:, Increment f = . Syntax:, Increment f = . Operands:, Increment f = 0 \uf0a3 f \uf0a3 255. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255. Operands:, Increment f = . Operands:, Increment f = . , Increment f = d \uf0ce [0,1]. , Increment f = d \uf0ce [0,1]. , Increment f = . , Increment f = . , Increment f = a \uf0ce [0,1]. , Increment f = a \uf0ce [0,1]. , Increment f = . , Increment f = . Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = . Operation:, Increment f = . Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = C,",
    "Example:\nDC, N, OV, Z. Status Affected:, Increment f = . Status Affected:, Increment f = . Encoding:, Increment f = 0010. Encoding:, Increment f = 10da. Encoding:, Increment f = ffff. Encoding:, Increment f = ffff. Description:, Increment f = The contents of register 'f' are. Description:, Increment f = The contents of register 'f' are. Description:, Increment f = The contents of register 'f' are. Description:, Increment f = The contents of register 'f' are\nincremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.",
    "Example:\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec -tion 42.2.3 'Byte-Oriented and BitOriented Instructions in Indexed Lit -eral Offset Mode' for details.\n1\n1\nWords:\nCycles:\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nINCF\nCNT, 1, 0\nBefore Instruction\nCNT\n=\nFFh\nZ\n=\n0\nC\n=\n?\nDC\n=\n?\nAfter Instruction\nCNT\n=\n00h\nZ\n=\n1\nC\n=\n1\nDC\n=\n1",
    "PIC18(L)F25/26K83\nSyntax:, INCFSZ = Syntax:. Syntax:, Increment f, skip if 0 = INCFSZ f {,d {,a}}. Syntax:, Increment f, skip if 0 = INCFSZ f {,d {,a}}. Syntax:, Increment f, skip if 0 = INCFSZ f {,d {,a}}. Syntax:, Increment f, skip if 0 = INCFSZ f {,d {,a}}. Operands:, INCFSZ = Operands:. Operands:, Increment f, skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, INCFSZ",
    "PIC18(L)F25/26K83\n= Operation:. Operation:, Increment f, skip if 0 = (f) + 1 \uf0ae dest, skip if result = 0. Operation:, Increment f, skip if 0 = (f) + 1 \uf0ae dest, skip if result = 0. Operation:, Increment f, skip if 0 = (f) + 1 \uf0ae dest, skip if result = 0. Operation:, Increment f, skip if 0 = (f) + 1 \uf0ae dest, skip if result = 0. Status Affected:, INCFSZ = Status Affected:. Status Affected:, Increment f, skip if 0 = None. Status Affected:, Increment f, skip if 0 = None. Status Affected:, Increment f, skip if 0 = None. Status Affected:, Increment f, skip if 0 = None. Encoding:, INCFSZ = Encoding:. Encoding:, Increment f, skip if 0 = 0011. Encoding:, Increment f, skip if 0 = 11da. Encoding:, Increment f, skip if 0 = ffff. Encoding:, Increment f, skip",
    "PIC18(L)F25/26K83\nif 0 = ffff. Description:, INCFSZ = Description:. Description:, Increment f, skip if 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details. 1. Description:, Increment f, skip if 0 = The contents of register 'f' are incremented. If",
    "PIC18(L)F25/26K83\n'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details. 1. Description:, Increment f, skip if 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is",
    "PIC18(L)F25/26K83\n' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details. 1. Description:, Increment f, skip if 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is ' 0 ', the",
    "PIC18(L)F25/26K83\nAccess Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details. 1. Words:, INCFSZ = Words:. Words:, Increment f, skip if 0 = . Words:, Increment f, skip if 0 = . Words:, Increment f, skip if 0 = . Words:, Increment f, skip if 0 = . Cycles:, INCFSZ = Cycles:. Cycles:, Increment f, skip if 0 = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Increment f, skip if 0 = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Increment f, skip if 0 =",
    "PIC18(L)F25/26K83\n1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Increment f, skip if 0 = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycle Activity:, INCFSZ = Cycle Activity:. Cycle Activity:, Increment f, skip if 0 = Cycle Activity:. Cycle Activity:, Increment f, skip if 0 = Cycle Activity:. Cycle Activity:, Increment f, skip if 0 = Cycle Activity:. Cycle Activity:, Increment f, skip if 0 = Cycle Activity:. Q1, INCFSZ = . Q1, Increment f, skip if 0 = Q2. Q1, Increment f, skip if 0 = Q3. Q1, Increment f, skip if 0 = . Q1, Increment f, skip if 0 = Q4. , INCFSZ = Decode. , Increment f, skip if 0 = Read register 'f'. , Increment f, skip if 0 = Process Data. , Increment f, skip if 0",
    "PIC18(L)F25/26K83\n= . , Increment f, skip if 0 = Write to destination. If skip:, INCFSZ = If skip:. If skip:, Increment f, skip if 0 = If skip:. If skip:, Increment f, skip if 0 = If skip:. If skip:, Increment f, skip if 0 = If skip:. If skip:, Increment f, skip if 0 = If skip:. Q1, INCFSZ = . Q1, Increment f, skip if 0 = Q2. Q1, Increment f, skip if 0 = Q3. Q1, Increment f, skip if 0 = . Q1, Increment f, skip if 0 = Q4. No, INCFSZ = operation. No, Increment f, skip if 0 = No operation. No, Increment f, skip if 0 = No operation. No, Increment f, skip if 0 = . No, Increment f, skip if 0 = No operation. If skip and followed by 2-word instruction:, INCFSZ = If skip and followed by",
    "PIC18(L)F25/26K83\n2-word instruction:. If skip and followed by 2-word instruction:, Increment f, skip if 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Increment f, skip if 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Increment f, skip if 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Increment f, skip if 0 = If skip and followed by 2-word instruction:. Q1, INCFSZ = . Q1, Increment f, skip if 0 = Q2. Q1, Increment f, skip if 0 = Q3. Q1, Increment f, skip if 0 = . Q1, Increment f, skip if 0 = Q4. No operation, INCFSZ = . No operation, Increment f, skip if 0 = No operation. No operation, Increment f, skip if 0 = No operation. No operation, Increment f, skip if",
    "PIC18(L)F25/26K83\n0 = . No operation, Increment f, skip if 0 = No operation. No, INCFSZ = operation. No, Increment f, skip if 0 = No operation. No, Increment f, skip if 0 = No operation. No, Increment f, skip if 0 = . No, Increment f, skip if 0 = No operation. Example:, INCFSZ = Example:. Example:, Increment f, skip if 0 = HERE NZERO ZERO. Example:, Increment f, skip if 0 = INCFSZ : :. Example:, Increment f, skip if 0 = CNT,. Example:, Increment f, skip if 0 = 1, 0. Before Instruction, INCFSZ = Before Instruction. Before Instruction, Increment f, skip if 0 = . Before Instruction, Increment f, skip if 0 = . Before Instruction, Increment f, skip if 0 = . Before Instruction, Increment f, skip if 0 = . PC, INCFSZ = PC. PC, Increment f, skip if 0 = PC. PC,",
    "PIC18(L)F25/26K83\nIncrement f, skip if 0 = PC. PC, Increment f, skip if 0 = PC. PC, Increment f, skip if 0 = PC. Instruction CNT, INCFSZ = =. Instruction CNT, Increment f, skip if 0 = Address. Instruction CNT, Increment f, skip if 0 = (HERE). Instruction CNT, Increment f, skip if 0 = . Instruction CNT, Increment f, skip if 0 = . After = CNT + 1, INCFSZ = After = CNT + 1. After = CNT + 1, Increment f, skip if 0 = After = CNT + 1. After = CNT + 1, Increment f, skip if 0 = After = CNT + 1. After = CNT + 1, Increment f, skip if 0 = After = CNT + 1. After = CNT + 1, Increment f, skip if 0 = After = CNT + 1. If CNT PC If CNT, INCFSZ = = = \uf0b9. If CNT PC If CNT, Increment",
    "PIC18(L)F25/26K83\nf, skip if 0 = 0; Address 0;. If CNT PC If CNT, Increment f, skip if 0 = (ZERO). If CNT PC If CNT, Increment f, skip if 0 = . If CNT PC If CNT, Increment f, skip if 0 = . PC, INCFSZ = =. PC, Increment f, skip if 0 = Address. PC, Increment f, skip if 0 = (NZERO). PC, Increment f, skip if 0 = . PC, Increment f, skip if 0 = ",
    "Increment f, skip if not 0\nSyntax:\nINFSNZ    f {,d {,a}}\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n(f) + 1 \uf0ae dest,\nskip if result \uf0b9 0\nStatus Affected:\nNone\nEncoding:\n0100\n10da\nffff\nffff\nDescription:\nThe contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.",
    "Increment f, skip if not 0\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.\nWords:\n1\nCycles:\n1(2)\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. If skip:, Q2 = . If skip:, Q3 = . If skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. If skip and followed by 2-word instruction:, Q2 = . If skip and followed by 2-word instruction:, Q3 = . If skip and followed by 2-word instruction:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. Example:, Q2 = HERE ZERO NZERO. Example:, Q3 =",
    "Q Cycle Activity:\nINFSNZ REG,. Example:, Q4 = 1, 0. Before Instruction, Q2 = . Before Instruction, Q3 = . Before Instruction, Q4 = . PC, Q2 = = Address. PC, Q3 = (HERE). PC, Q4 = . After Instruction, Q2 = . After Instruction, Q3 = . After Instruction, Q4 = . REG, Q2 = = REG. REG, Q3 = 1. REG, Q4 = . If REG, Q2 = \uf0b9. If REG, Q3 = . If REG, Q4 = . PC, Q2 = 0; = Address 0;. PC, Q3 = (NZERO). PC, Q4 = . If REG PC, Q2 = = = Address. If REG PC, Q3 = (ZERO). If REG PC, Q4 = ",
    "Inclusive OR literal with W\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nIORLW   k\n0 \uf0a3 k \uf0a3 255\n(W) .OR. k \uf0ae W\nN, Z\n0000\n1001\nkkkk kkkk\nThe contents of W are ORed with the 8bit literal 'k'. The result is placed in W.\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read literal 'k'. Decode, Q3 = Process Data. Decode, Q4 = Write to W",
    "Example:\nIORLW\nBefore Instruction\nW\n=\n9Ah\nAfter Instruction\nW\n=\nBFh\n35h",
    "Example:\nSyntax:, Inclusive OR Wwith f = IORWF. Syntax:, Inclusive OR Wwith f = f {,d {,a}}. Syntax:, Inclusive OR Wwith f = f {,d {,a}}. Syntax:, Inclusive OR Wwith f = f {,d {,a}}. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255. , Inclusive OR Wwith f = d \uf0ce [0,1]. , Inclusive OR Wwith f = d \uf0ce [0,1]. , Inclusive OR Wwith f = d \uf0ce [0,1]. , Inclusive OR Wwith f = d \uf0ce [0,1]. , Inclusive OR Wwith f = a \uf0ce [0,1]. , Inclusive OR Wwith f = a \uf0ce [0,1]. , Inclusive OR Wwith f = a \uf0ce [0,1]. , Inclusive OR Wwith f = a \uf0ce [0,1]. Operation:, Inclusive OR Wwith f = (W) .OR.",
    "Example:\n(f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Encoding:, Inclusive OR Wwith f = 0001. Encoding:, Inclusive OR Wwith f = 00da. Encoding:, Inclusive OR Wwith f = ffff. Encoding:, Inclusive OR Wwith f = ffff. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is. Description:, Inclusive OR Wwith f =",
    "Example:\nInclusive OR Wwith register 'f'. If 'd' is\n' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec -tion 42.2.3 'Byte-Oriented and BitOriented Instructions in Indexed Lit -eral Offset Mode' for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nIORWF  RESULT, 0, 1\nBefore Instruction\nRESULT = 13h\nW\n=\n91h\nAfter Instruction\nRESULT =\n13h\nW\n=\n93h",
    "Load FSR\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nLFSR   f, k\n0 \uf0a3 f \uf0a3 2\n0 \uf0a3 k \uf0a3 16383\nk \uf0ae FSRf\nNone\n1110\n1110\n00k13 k kkkk\n1111\n0000\nk7 kkk kkkk\nThe 14-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.\n2\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'k' MSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' MSB to FSRfH. Decode, Q2 = Read literal 'k' LSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' to FSRfL",
    "Example:\nLFSR 2, 3ABh\nAfter Instruction\nFSR2H FSR2L\n= 03h\n= ABh",
    "Example:\nSyntax:, Move f = MOVF. Syntax:,  = f {,d {,a}}. Syntax:,  = . Syntax:,  = . Operands:, Move f = 0 \uf0a3 f \uf0a3 255. Operands:,  = . Operands:,  = . Operands:,  = . , Move f = d \uf0ce [0,1]. ,  = . ,  = . ,  = . , Move f = a \uf0ce [0,1]. ,  = . ,  = . ,  = . Operation:, Move f = f \uf0ae dest. Operation:,  = . Operation:,  = . Operation:,  = . Status Affected:, Move f = N, Z. Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Encoding:, Move f = 0101. Encoding:,  = 00da. Encoding:,  = ffff. Encoding:,  = ffff. Description:, Move f = The contents of register 'f' are moved to. Description:,  = The contents of register 'f' are moved to. Description:,  = The contents of register 'f' are moved to. Description:,  = The contents of register 'f' are moved to",
    "Example:\nThe contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec -tion 42.2.3 'Byte-Oriented and BitOriented Instructions in Indexed Lit -eral Offset Mode' for details.\n1\n1\nWords:\nCycles:\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write W\nMOVF   REG, 0, 0\nBefore Instruction\nREG\n=\n22h\nW\n=\nFFh\nAfter Instruction\nREG\n=\n22h\nW\n=\n22h",
    "PIC18(L)F25/26K83\nSyntax:, Move f to f = MOVFF f s ,f d. Syntax:, Move f to f = MOVFF f s ,f d. Syntax:,  = . Syntax:,  = . Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:,  = . Operands:,  = . Operation:, Move f to f = (f s ) \uf0ae f d. Operation:, Move f to f = (f s ) \uf0ae f d. Operation:,  = . Operation:,  = . Status Affected:, Move f to f = None. Status Affected:, Move f to f = None. Status Affected:,  = . Status Affected:,  = . Encoding: 1st word (source), Move f to f = 1100. Encoding: 1st word (source), Move f to f = ffff. Encoding: 1st word (source),  = ffff. Encoding: 1st word (source),",
    "PIC18(L)F25/26K83\n= ffff s. 2nd word (destin.), Move f to f = 1111. 2nd word (destin.), Move f to f = ffff. 2nd word (destin.),  = ffff. 2nd word (destin.),  = ffff d\nDescription:\nThe contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f ' can be anywhere s in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh.\nMOVFF has curtailed the source and destination range to the lower 4 Kbyte space of memory (Banks 1 through 15). For everything else, use MOVFFL .\n2\n2 (3)\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nQ2\nQ3",
    "PIC18(L)F25/26K83\nDecode, 1 = Read register 'f' (src). Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f' (dest)\nBefore Instruction, MOVFF = . Before Instruction, REG1, REG2 = . REG1, MOVFF = =. REG1, REG1, REG2 = 33h. REG2, MOVFF = =. REG2, REG1, REG2 = 11h. After Instruction, MOVFF = . After Instruction, REG1, REG2 = . REG1, MOVFF = =. REG1, REG1, REG2 = 33h. REG2, MOVFF = =. REG2, REG1, REG2 = 33h\nQ4",
    "PIC18(L)F25/26K83\nSyntax:, Move f to f (Long Range) = MOVFFL f s ,f d. Operands:, Move f to f (Long Range) = 0 \uf0a3 f s \uf0a3 16383 0 \uf0a3 f d \uf0a3 16383. Operation:, Move f to f (Long Range) = (f s ) \uf0ae f d. Status Affected:, Move f to f (Long Range) = None\nEncoding: 1st word 2nd word 3rd word\n0000 1111 1111, 1 = 0000 f s f s f s f s f d f d f d f d. 0000 1111 1111, 2 = 0110 f s f s f s f s f d f d f d f d. 0000 1111 1111, 3 = f s f s f s f s f s f s f d f d f d f d f d f d\nDescription:\nThe contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f ' can be anywhere in s the 16 Kbyte data space (0000h to 3FFFh). Either source or destination can be W (a useful special situation).",
    "PIC18(L)F25/26K83\nMOVFFL is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port).\nThe MOVFFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.\nWords:\n3\nCycles:\n3\nQ Cycle Activity:\nDecode, Q2 = No operation. Decode, Q3 = No operation. Decode, Q4 = No operation. Decode, Q2 = Read reg - ister 'f s ' (src). Decode, Q3 = Process data. Decode, Q4 = No operation. Decode, Q2 = No operation Nodummy read. Decode, Q3 = No operation. Decode, Q4 = Write register 'f d ' (dest)",
    "PIC18(L)F25/26K83\nBefore Instruction, 2000h, 200Ah = . Contents of 2000h, 2000h, 200Ah = = 33h. Contents of 200Ah, 2000h, 200Ah = = 11h. After Instruction, 2000h, 200Ah = . Contents of 2000h, 2000h, 200Ah = = 33h =. Contents of 200Ah, 2000h, 200Ah = 33h",
    "PIC18(L)F25/26K83\nSyntax:, Move literal to BSR = MOVLW k. Syntax:, Move literal to BSR = MOVLW k. Syntax:, Move literal to BSR = MOVLW k. Syntax:, Move literal to BSR = MOVLW k. Syntax:, Move literal to BSR = MOVLW k. Operands:, Move literal to BSR = 0 \uf0a3 k \uf0a3 63. Operands:, Move literal to BSR = 0 \uf0a3 k \uf0a3 63. Operands:, Move literal to BSR = 0 \uf0a3 k \uf0a3 63. Operands:, Move literal to BSR = 0 \uf0a3 k \uf0a3 63. Operands:, Move literal to BSR = 0 \uf0a3 k \uf0a3 63. Operation:, Move literal to BSR = k \uf0ae BSR. Operation:, Move literal to BSR = k \uf0ae BSR. Operation:, Move literal to BSR = k \uf0ae BSR. Operation:, Move literal to BSR = k \uf0ae BSR. Operation:, Move literal to BSR = k \uf0ae BSR. Status Affected:, Move literal to BSR = None. Status Affected:, Move literal to BSR = None. Status Affected:, Move literal to BSR =",
    "PIC18(L)F25/26K83\nNone. Status Affected:, Move literal to BSR = None. Status Affected:, Move literal to BSR = None. Encoding:, Move literal to BSR = 0000. Encoding:, Move literal to BSR = 0001. Encoding:, Move literal to BSR = 0001. Encoding:, Move literal to BSR = 00kk. Encoding:, Move literal to BSR = kkkk. Description:, Move literal to BSR = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Description:, Move literal to BSR = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Description:, Move literal to BSR = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Description:, Move",
    "PIC18(L)F25/26K83\nliteral to BSR = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Description:, Move literal to BSR = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Words:, Move literal to BSR = 1. Words:, Move literal to BSR = 1. Words:, Move literal to BSR = 1. Words:, Move literal to BSR = 1. Words:, Move literal to BSR = 1. Cycles:, Move literal to BSR = 1. Cycles:, Move literal to BSR = 1. Cycles:, Move literal to BSR = 1. Cycles:, Move literal to BSR = 1. Cycles:, Move literal to BSR = 1. Q Cycle Activity:, Move literal to BSR = Q Cycle Activity:. Q Cycle Activity:, Move literal to BSR = Q Cycle Activity:. Q Cycle",
    "PIC18(L)F25/26K83\nActivity:, Move literal to BSR = Q Cycle Activity:. Q Cycle Activity:, Move literal to BSR = Q Cycle Activity:. Q Cycle Activity:, Move literal to BSR = Q Cycle Activity:. Q1, Move literal to BSR = Q2. Q1, Move literal to BSR = Q2. Q1, Move literal to BSR = Q3. Q1, Move literal to BSR = . Q1, Move literal to BSR = Q4. Decode, Move literal to BSR = Read literal 'k'. Decode, Move literal to BSR = Read literal 'k'. Decode, Move literal to BSR = Process Data. Decode, Move literal to BSR = Write literal 'k' to BSR. Decode, Move literal to BSR = Write literal 'k' to BSR. Example:, Move literal to BSR = MOVLB. Example:, Move literal to BSR = MOVLB. Example:, Move literal to BSR = 5. Example:, Move literal to BSR = . Example:, Move literal to BSR = . Before Instruction BSR Register",
    "PIC18(L)F25/26K83\n=, Move literal to BSR = Before Instruction BSR Register =. Before Instruction BSR Register =, Move literal to BSR = 02h. Before Instruction BSR Register =, Move literal to BSR = . Before Instruction BSR Register =, Move literal to BSR = . Before Instruction BSR Register =, Move literal to BSR = ",
    "PIC18(L)F25/26K83\nSyntax:, Move literal to W = MOVLW k. Syntax:, Move literal to W = MOVLW k. Syntax:, Move literal to W = MOVLW k. Syntax:, Move literal to W = MOVLW k. Operands:, Move literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to W = 0 \uf0a3 k \uf0a3 255. Operation:, Move literal to W = k \uf0ae W. Operation:, Move literal to W = k \uf0ae W. Operation:, Move literal to W = k \uf0ae W. Operation:, Move literal to W = k \uf0ae W. Status Affected:, Move literal to W = None. Status Affected:, Move literal to W = None. Status Affected:, Move literal to W = None. Status Affected:, Move literal to W = None. Encoding:, Move literal to W = 0000. Encoding:, Move literal to W = 1110. Encoding:, Move literal to W = kkkk. Encoding:, Move literal to W = kkkk.",
    "PIC18(L)F25/26K83\nDescription:, Move literal to W = The 8-bit literal 'k' is loaded into W.. Description:, Move literal to W = The 8-bit literal 'k' is loaded into W.. Description:, Move literal to W = The 8-bit literal 'k' is loaded into W.. Description:, Move literal to W = The 8-bit literal 'k' is loaded into W.. Words:, Move literal to W = 1. Words:, Move literal to W = 1. Words:, Move literal to W = 1. Words:, Move literal to W = 1. Cycles:, Move literal to W = 1. Cycles:, Move literal to W = 1. Cycles:, Move literal to W = 1. Cycles:, Move literal to W = 1. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q1, Move literal to W = Q2. Q1, Move literal",
    "PIC18(L)F25/26K83\nto W = Q3. Q1, Move literal to W = Q4. Q1, Move literal to W = Q4. Decode, Move literal to W = Read literal 'k'. Decode, Move literal to W = Process Data. Decode, Move literal to W = Write to W. Decode, Move literal to W = Write to W. Example:, Move literal to W = MOVLW. Example:, Move literal to W = 5Ah. Example:, Move literal to W = . Example:, Move literal to W = . After Instruction, Move literal to W = After Instruction. After Instruction, Move literal to W = After Instruction. After Instruction, Move literal to W = After Instruction. After Instruction, Move literal to W = After Instruction",
    "PIC18(L)F25/26K83\nSyntax:, Move Wto f = MOVWF. Syntax:, Move Wto f = f {,a}. Syntax:, Move Wto f = . Syntax:, Move Wto f = . Operands:, Move Wto f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Move Wto f = . Operands:, Move Wto f = . Operands:, Move Wto f = . Operation:, Move Wto f = (W) \uf0ae f. Operation:, Move Wto f = . Operation:, Move Wto f = . Operation:, Move Wto f = . Status Affected:, Move Wto f = None. Status Affected:, Move Wto f = . Status Affected:, Move Wto f = . Status Affected:, Move Wto f = . Encoding:, Move Wto f = 0110. Encoding:, Move Wto f = 111a. Encoding:, Move Wto f = ffff. Encoding:, Move Wto f = ffff. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere",
    "PIC18(L)F25/26K83\nin the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit-. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit-. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the",
    "PIC18(L)F25/26K83\n256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit-. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit-. Words:, Move Wto f = 1. Words:, Move Wto f = . Words:, Move Wto f = . Words:,",
    "PIC18(L)F25/26K83\nMove Wto f = . Cycles:, Move Wto f = 1. Cycles:, Move Wto f = . Cycles:, Move Wto f = . Cycles:, Move Wto f = \nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write register 'f'\nExample:\nMOVWF\nREG, 0\nBefore Instruction\nW\n= 4Fh\nREG\n=\nFFh\nAfter Instruction\nW\n=\n4Fh\nREG\n=\n4Fh",
    "PIC18(L)F25/26K83\nSyntax:, Multiply literal with W = MULLW. Syntax:, Multiply literal with W = k. Syntax:, Multiply literal with W = k. Syntax:, Multiply literal with W = k. Operands:, Multiply literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Multiply literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Multiply literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Multiply literal with W = 0 \uf0a3 k \uf0a3 255. Operation:, Multiply literal with W = (W) x k \uf0ae PRODH:PRODL. Operation:, Multiply literal with W = (W) x k \uf0ae PRODH:PRODL. Operation:, Multiply literal with W = (W) x k \uf0ae PRODH:PRODL. Operation:, Multiply literal with W = (W) x k \uf0ae PRODH:PRODL. Status Affected:, Multiply literal with W = None. Status Affected:, Multiply literal with W = None. Status Affected:, Multiply literal with W = None. Status Affected:, Multiply literal with W = None. Encoding:, Multiply literal with W = 0000.",
    "PIC18(L)F25/26K83\nEncoding:, Multiply literal with W = 1101. Encoding:, Multiply literal with W = kkkk. Encoding:, Multiply literal with W = kkkk. Description:, Multiply literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The",
    "PIC18(L)F25/26K83\n16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Words:, Multiply literal with W = 1. Words:, Multiply literal with W = 1. Words:, Multiply literal with W = 1. Words:, Multiply literal with W = 1. Cycles:, Multiply literal with W = 1. Cycles:, Multiply literal with W = 1. Cycles:, Multiply literal with W = 1. Cycles:, Multiply literal with W = 1. Q Cycle Activity:, Multiply literal with W",
    "PIC18(L)F25/26K83\n= Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W = Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W = Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W = Q Cycle Activity:. Q1, Multiply literal with W = Q2. Q1, Multiply literal with W = Q3. Q1, Multiply literal with W = . Q1, Multiply literal with W = Q4. Decode, Multiply literal with W = Read literal 'k'. Decode, Multiply literal with W = Process Data. Decode, Multiply literal with W = Process Data. Decode, Multiply literal with W = Write registers PRODH: PRODL\nExample:\nMULLW   0C4h\nBefore Instruction\nW\n=\nE2h\nPRODH\n=\n?\nPRODL\n=\n?\nAfter Instruction\nW\n= E2h\nPRODH\n= ADh\nPRODL\n=\n08h",
    "PIC18(L)F25/26K83\nMULWF, 1 = MULWF. MULWF, 2 = Multiply Wwith f. MULWF, 3 = Multiply Wwith f. MULWF, 4 = Multiply Wwith f. Syntax:, 1 = Syntax:. Syntax:, 2 = MULWF f {,a}. Syntax:, 3 = MULWF f {,a}. Syntax:, 4 = MULWF f {,a}. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, 3 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, 4 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, 1 = Operation:. Operation:, 2 = (W) x (f) \uf0ae PRODH:PRODL. Operation:, 3 = (W) x (f) \uf0ae PRODH:PRODL. Operation:, 4 = (W) x (f) \uf0ae PRODH:PRODL. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status",
    "PIC18(L)F25/26K83\nAffected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 0000. Encoding:, 3 = 001a. Encoding:, 4 = ffff. Description:, 1 = Description:. Description:, 2 = An unsigned multiplication is carried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever. Description:, 3 = An unsigned multiplication is carried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register",
    "PIC18(L)F25/26K83\npair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever. Description:, 4 = An unsigned multiplication is carried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction",
    "PIC18(L)F25/26K83\nset is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read register 'f'. , 3 = Process Data. , 4 = ",
    "Example:\nMULWF   REG, 1\nBefore Instruction\nW\n=\nC4h\nREG\n=\nB5h\nPRODH\n=\n?\nPRODL\n=\n?\nAfter Instruction\nW\n= C4h\nREG\n=\nB5h\nPRODH\n=\n8Ah\nPRODL\n=\n94h",
    "Example:\nSyntax:, Negate f = NEGF. Syntax:, Negate f = f {,a}. Syntax:, Negate f = . Syntax:, Negate f = . Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Encoding:, Negate f = 0110.",
    "Example:\nEncoding:, Negate f = 110a. Encoding:, Negate f = ffff. Encoding:, Negate f = ffff. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit -. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95",
    "Example:\n(5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit -. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit -. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95",
    "Example:\n(5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit -. Words:, Negate f = 1. Words:, Negate f = . Words:, Negate f = . Words:, Negate f = \nCycles:\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write register 'f'\nBefore Instruction REG =, NEGF = 0011. Before Instruction REG =, REG, = 1010. Before Instruction REG =, 1 = [3Ah]. After Instruction REG =, NEGF = 1100. After Instruction REG =, REG, = 0110. After Instruction REG =, 1 = [C6h]",
    "No Operation\nSyntax:, 1 = NOP. Syntax:, 2 = NOP. Syntax:, 3 = NOP. Syntax:, 4 = NOP. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = No operation. Operation:, 2 = No operation. Operation:, 3 = No operation. Operation:, 4 = No operation. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000 1111. Encoding:, 2 = 0000 xxxx. Encoding:, 3 = 0000 xxxx. Encoding:, 4 = 0000 xxxx. Description:, 1 = No operation.. Description:, 2 = No operation.. Description:, 3 = No operation.. Description:, 4 = No operation.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1.",
    "No Operation\nCycles:, 4 = 1. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = . Q1, 4 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = . Decode, 4 = No operation\nExample:\nNone.",
    "No Operation\nSyntax:, Pop Top of Return Stack = POP. Syntax:, Pop Top of Return Stack = POP. Syntax:, Pop Top of Return Stack = POP. Syntax:, Pop Top of Return Stack = POP. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack = 0110.",
    "No Operation\nDescription:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Words:, Pop Top of Return Stack =",
    "No Operation\n1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q1, Pop Top of Return Stack = Q2. Q1, Pop Top of Return Stack = Q3. Q1, Pop Top of Return Stack = Q3. Q1, Pop Top of Return Stack = Q4. Decode, Pop Top of Return Stack = No operation. Decode, Pop Top of Return Stack = POP TOS value. Decode, Pop Top of Return Stack = POP TOS value. Decode, Pop Top of Return Stack = No operation. Example:, Pop Top of Return Stack = POP. Example:, Pop Top of Return Stack = . Example:, Pop Top of",
    "No Operation\nReturn Stack = . Example:, Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = Before Instruction. Before Instruction, Pop Top of Return Stack = =. Before Instruction, Pop Top of Return Stack = 0031A2h. Before Instruction, Pop Top of Return Stack = . TOS Stack (1 level down), Pop Top of Return Stack = TOS Stack (1 level down). TOS Stack (1 level down), Pop Top of Return Stack = =. TOS Stack (1 level down), Pop Top of Return Stack = 014332h. TOS Stack (1 level down), Pop Top of Return Stack = . After Instruction TOS PC, Pop Top of Return Stack = After Instruction TOS PC. After Instruction TOS PC, Pop Top of Return Stack = = =. After Instruction TOS PC, Pop Top of Return Stack = 014332h NEW. After Instruction TOS PC, Pop Top of Return Stack = ",
    "PIC18(L)F25/26K83\nSyntax:, Push Top of Return Stack = PUSH. Syntax:, Push Top of Return Stack = PUSH. Syntax:, Push Top of Return Stack = PUSH. Syntax:, Push Top of Return Stack = PUSH. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operation:, Push Top of Return Stack = (PC + 2) \uf0ae TOS. Operation:, Push Top of Return Stack = (PC + 2) \uf0ae TOS. Operation:, Push Top of Return Stack = (PC + 2) \uf0ae TOS. Operation:, Push Top of Return Stack = (PC + 2) \uf0ae TOS. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0000.",
    "PIC18(L)F25/26K83\nEncoding:, Push Top of Return Stack = 0101. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Words:, Push Top of Return Stack",
    "PIC18(L)F25/26K83\n= 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q1, Push Top of Return Stack = Q2. Q1, Push Top of Return Stack = Q3. Q1, Push Top of Return Stack = Q3. Q1, Push Top of Return Stack = Q4. Decode, Push Top of Return Stack = PUSH PC + 2 onto return stack. Decode, Push Top of Return Stack = No operation. Decode, Push Top of Return Stack = No operation. Decode, Push Top of Return Stack = No",
    "PIC18(L)F25/26K83\noperation. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. TOS, Push Top of Return Stack = TOS. TOS, Push Top of Return Stack = = =. TOS, Push Top of Return Stack = 345Ah. TOS, Push Top of Return Stack = . PC, Push Top of Return Stack = PC. PC, Push Top of Return Stack = . PC, Push Top of Return Stack = 0124h. PC, Push Top of Return Stack = . After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. PC, Push Top of Return Stack = PC. PC, Push Top of Return",
    "PIC18(L)F25/26K83\nStack = =. PC, Push Top of Return Stack = 0126h. PC, Push Top of Return Stack = . TOS, Push Top of Return Stack = TOS. TOS, Push Top of Return Stack = =. TOS, Push Top of Return Stack = 0126h. TOS, Push Top of Return Stack = . Stack (1 level down), Push Top of Return Stack = Stack (1 level down). Stack (1 level down), Push Top of Return Stack = =. Stack (1 level down), Push Top of Return Stack = 345Ah. Stack (1 level down), Push Top of Return Stack = \nRCALL\nSyntax:\nOperands:\nOperation:\nStatus Affected: Encoding:\nDescription:\nWords:\nCycles:",
    "Relative Call\nRCALL    n\n-1024 \uf0a3 n \uf0a3 1023\n(PC) + 2 \uf0ae TOS,\n(PC) + 2 + 2n \uf0ae PC\nNone\n1101\n1nnn nnnn\nnnnn\nSubroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a 2-cycle instruction.\n1\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'n' PUSHPCto stack. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE\nRCALL Jump\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nAfter Instruction\nPC\n=\nAddress\n(Jump)\nTOS =\nAddress\n(HERE + 2)",
    "PIC18(L)F25/26K83\nSyntax:, Reset = RESET. Syntax:, Reset = RESET. Syntax:, Reset = RESET. Syntax:, Reset = RESET. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Encoding:, Reset = 0000. Encoding:, Reset = 0000. Encoding:, Reset = 1111. Encoding:, Reset = 1111. Description:, Reset = This instruction provides a way to execute a MCLR Reset by software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset by software..",
    "PIC18(L)F25/26K83\nDescription:, Reset = This instruction provides a way to execute a MCLR Reset by software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset by software.. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q1, Reset = Q2. Q1, Reset = Q3. Q1, Reset = Q3. Q1, Reset = Q4. Decode, Reset = Start Reset. Decode, Reset = No operation. Decode, Reset = No operation. Decode, Reset = No operation. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset = RESET. After Instruction Registers = Flags* =,",
    "PIC18(L)F25/26K83\nReset = Reset Value. After Instruction Registers = Flags* =, Reset = Reset Value. After Instruction Registers = Flags* =, Reset = Reset Value. After Instruction Registers = Flags* =, Reset = Reset Value",
    "PIC18(L)F25/26K83\nSyntax:, RETFIE = Syntax:. Syntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Operands:, RETFIE = Operands:. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operation:, RETFIE = Operation:. Operation:, Return from Interrupt = (TOS) \uf0ae PC, if s = 1 , context is restored into WREG, STATUS, BSR, FSR0H, FSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU registers from the corresponding shadow registers.. Operation:, Return from Interrupt = (TOS) \uf0ae PC, if s = 1 , context is restored into WREG, STATUS, BSR, FSR0H, FSR0L,",
    "PIC18(L)F25/26K83\nFSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU registers from the corresponding shadow registers.. Operation:, Return from Interrupt = (TOS) \uf0ae PC, if s = 1 , context is restored into WREG, STATUS, BSR, FSR0H, FSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU registers from the corresponding shadow registers.. Status Affected:, RETFIE = Status Affected:. Status Affected:, Return from Interrupt = STAT<1:0> in INTCON1 register. Status Affected:, Return from Interrupt = STAT<1:0> in INTCON1 register. Status Affected:, Return from Interrupt = STAT<1:0> in INTCON1 register. Encoding:, RETFIE = Encoding:. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0001. Description:, RETFIE = Description:.",
    "PIC18(L)F25/26K83\nDescription:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers, WREG, STATUS, BSR, FSR0H, FSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU, are loaded into corresponding registers. There are two sets of shadow registers, main context and low context. The set retrieved on RETFIE instruction execution depends on what the state of operation of the CPU was when RET - FIE was executed. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers, WREG,",
    "PIC18(L)F25/26K83\nSTATUS, BSR, FSR0H, FSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU, are loaded into corresponding registers. There are two sets of shadow registers, main context and low context. The set retrieved on RETFIE instruction execution depends on what the state of operation of the CPU was when RET - FIE was executed. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers, WREG, STATUS, BSR, FSR0H, FSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU, are loaded into corresponding registers. There are two sets of shadow registers, main",
    "PIC18(L)F25/26K83\ncontext and low context. The set retrieved on RETFIE instruction execution depends on what the state of operation of the CPU was when RET - FIE was executed. If 's' = 0 , no update of these registers occurs (default).. Words:, RETFIE = Words:. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Cycles:, RETFIE = Cycles:. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Q Cycle Activity:, RETFIE = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. , RETFIE = Q1. , Return from Interrupt = Q2. , Return from Interrupt = Q3. , Return from Interrupt = Q4. , RETFIE = Decode. , Return from Interrupt = No operation. , Return from Interrupt = No operation. , Return from Interrupt = POP",
    "PIC18(L)F25/26K83\nPC from stack Set GIEH or GIEL. , RETFIE = No operation. , Return from Interrupt = No operation. , Return from Interrupt = No operation. , Return from Interrupt = No operation",
    "Example:\nRETFIE  1\nAfter Interrupt\nPC\n=\nTOS\nWREG\n=\nWREG_SHAD\nBSR\n=\nBSR_SHAD\nSTATUS\n=      STATUS_SHAD\nFSR0L/H\n=      FSR0L/H_SHAD\nFSR1L/H\n=      FSR1L/H_SHAD\nFSR2L/H\n=      FSR2L/H_SHAD\nPROD/H\n=      PROD/H_SHAD\nPCLATH/U\n=      PCLATH/U_SHAD",
    "PIC18(L)F25/26K83\nSyntax:, Return literal to W = RETLW k. Syntax:, Return literal to W = RETLW k. Syntax:, Return literal to W = RETLW k. Syntax:, Return literal to W = RETLW k. Operands:, Return literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return literal to W = 0 \uf0a3 k \uf0a3 255. Operation:, Return literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Status Affected:, Return literal to W = None. Status Affected:, Return literal to W = None. Status Affected:, Return literal to W =",
    "PIC18(L)F25/26K83\nNone. Status Affected:, Return literal to W = None. Encoding:, Return literal to W = 0000. Encoding:, Return literal to W = 1100. Encoding:, Return literal to W = kkkk. Encoding:, Return literal to W = kkkk. Description:, Return literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack",
    "PIC18(L)F25/26K83\n(the return address). The high address latch (PCLATH) remains unchanged.. Words:, Return literal to W = 1. Words:, Return literal to W = 1. Words:, Return literal to W = 1. Words:, Return literal to W = 1. Cycles:, Return literal to W = 2. Cycles:, Return literal to W = 2. Cycles:, Return literal to W = 2. Cycles:, Return literal to W = 2. Q Cycle Activity:, Return literal to W = Q Cycle Activity:. Q Cycle Activity:, Return literal to W = Q Cycle Activity:. Q Cycle Activity:, Return literal to W = Q Cycle Activity:. Q Cycle Activity:, Return literal to W = Q Cycle Activity:. Q1, Return literal to W = Q2. Q1, Return literal to W = Q3. Q1, Return literal to W = . Q1, Return literal to W = Q4. Decode, Return literal to W = Read literal 'k'. Decode, Return literal to W = Process Data. Decode, Return literal to W = Process Data. Decode, Return literal to W",
    "PIC18(L)F25/26K83\n= POP PC from stack, Write to W. No operation, Return literal to W = No operation. No operation, Return literal to W = No operation. No operation, Return literal to W = No operation. No operation, Return literal to W = No operation",
    "Example:\n:\nTABLE\n:\n:\nCALL TABLE\n; W contains table\n; offset value\n; W now has\n; table value\nADDWF PCL\n; W = offset\nRETLW k0\n; Begin table\nRETLW k1\n;\nRETLW kn\n; End of table",
    "Before Instruction\nW\n=\n07h\nAfter Instruction\nW\n=\nvalue of kn",
    "Return from Subroutine\nSyntax:\nRETURN   {s}\nOperands:\ns \uf0ce [0,1]\nOperation:\n(TOS) \uf0ae PC,\nif s = 1\n(WS) \uf0ae W,\n(STATUSS) \uf0ae Status,\n(BSRS) \uf0ae BSR,\nPCLATU, PCLATH are unchanged\nStatus Affected:\nNone\nEncoding:\n0000\n0000\n0001\n001s\nDescription:\nReturn from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nNo\noperation\nProcess Data\nPOP PC from stack\nNo operation\nNo operation\nNo\noperation\nNo operation\nExample:\nRETURN\nAfter Instruction: PC = TOS",
    "PIC18(L)F25/26K83\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "Rotate Left f through Carry\nSyntax:\nRLCF     f {,d {,a}}\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n(f<n>) \uf0ae dest<n + 1>,\n(f<7>) \uf0ae C,\n(C) \uf0ae dest<0>\nStatus Affected:\nC, N, Z\nEncoding:\n0011\n01da\nffff\nffff\nDescription:\nThe contents of register 'f' are rotated one bit to the left through the CARRY flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.\nIf 'a' is ' 0 ' and the extended instruction\nset is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Ori - ented Instructions in Indexed Literal Offset Mode' for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:",
    "Rotate Left f through Carry\nQ1\nQ2\nQ3\nQ4\nC\nregister f\nExample:\nRLCF\nREG, 0, 0\nBefore Instruction\nREG\n=\n1110 0110\nC\n=\n0\nAfter Instruction\nREG\n=\n1110 0110\nW\n=\n1100 1100\nC\n=\n1",
    "Rotate Left f through Carry\nSyntax:, Rotate Left f (No Carry) = RLNCF. Syntax:, Rotate Left f (No Carry) = f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = f {,d {,a}}. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae",
    "Rotate Left f through Carry\ndest<0>. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Encoding:, Rotate Left f (No Carry) = 0100. Encoding:, Rotate Left f (No Carry) = 01da. Encoding:, Rotate Left f (No Carry) = ffff ffff. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented",
    "Rotate Left f through Carry\nInstructions in Indexed Lit - eral Offset Mode' for details.. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is",
    "Rotate Left f through Carry\n' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q1, Rotate Left f (No Carry) = Q2 Read register 'f'. Q1,",
    "Rotate Left f through Carry\nRotate Left f (No Carry) = Q3 Process Data. Q1, Rotate Left f (No Carry) = Q4 Write to destination. Example:, Rotate Left f (No Carry) = RLNCF. Example:, Rotate Left f (No Carry) = REG,. Example:, Rotate Left f (No Carry) = . Before Instruction REG, Rotate Left f (No Carry) = 1010. Before Instruction REG, Rotate Left f (No Carry) = 1011. Before Instruction REG, Rotate Left f (No Carry) = 0. = After Instruction REG =, Rotate Left f (No Carry) = 0101. = After Instruction REG =, Rotate Left f (No Carry) = 0111. = After Instruction REG =, Rotate Left f (No Carry) = ",
    "PIC18(L)F25/26K83\nSyntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry =",
    "PIC18(L)F25/26K83\n(f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = . Status Affected:, Rotate Right f through Carry = . Status Affected:, Rotate Right f through Carry = . Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the CARRY flag. If 'd' is ' 0",
    "PIC18(L)F25/26K83\n', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the CARRY flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0",
    "PIC18(L)F25/26K83\n' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the CARRY flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, Rotate Right f through Carry = The contents of register 'f'",
    "PIC18(L)F25/26K83\nare rotated one bit to the right through the CARRY flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = . Words:, Rotate Right f through Carry = . Words:, Rotate Right f through Carry = . Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = . Cycles:, Rotate Right f through Carry = . Cycles:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through",
    "PIC18(L)F25/26K83\nCarry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q1, Rotate Right f through Carry = Q2. Q1, Rotate Right f through Carry = Q3. Q1, Rotate Right f through Carry = . Q1, Rotate Right f through Carry = Q4. Decode, Rotate Right f through Carry = Read register 'f'. Decode, Rotate Right f through Carry = Process Data. Decode, Rotate Right f through Carry = . Decode, Rotate Right f through Carry = Write to destination. Example:, Rotate Right f through Carry = RRCF. Example:, Rotate Right f through Carry = REG, 0,. Example:, Rotate Right f through Carry = 0. Example:, Rotate Right f through Carry = . Before Instruction, Rotate Right f through Carry = Before Instruction. Before Instruction, Rotate Right f through Carry = . Before Instruction, Rotate Right f through Carry = . Before Instruction, Rotate Right f through Carry = . REG C,",
    "PIC18(L)F25/26K83\nRotate Right f through Carry = = 1110 = 0. REG C, Rotate Right f through Carry = 0110. REG C, Rotate Right f through Carry = . REG C, Rotate Right f through Carry = . After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = . After Instruction, Rotate Right f through Carry = . After Instruction, Rotate Right f through Carry = . REG, Rotate Right f through Carry = = 1110. REG, Rotate Right f through Carry = 0110. REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . W, Rotate Right f through Carry = = 0111. W, Rotate Right f through Carry = 0011. W, Rotate Right f through Carry = . W, Rotate Right f through Carry = . C, Rotate Right f through Carry = = 0. C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = ",
    "PIC18(L)F25/26K83\nSyntax:, Rotate Right f (No Carry) = RRNCF. Syntax:, Rotate Right f (No Carry) = f {,d {,a}}. Syntax:, Rotate Right f (No Carry) = . Syntax:, Rotate Right f (No Carry) = . Operands:, Rotate Right f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (No Carry) = . Operands:, Rotate Right f (No Carry) = . Operands:, Rotate Right f (No Carry) = . Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f",
    "PIC18(L)F25/26K83\n(No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = . Status Affected:, Rotate Right f (No Carry) = . Status Affected:, Rotate Right f (No Carry) = . Encoding:, Rotate Right f (No Carry) = 0100. Encoding:, Rotate Right f (No Carry) = 00da. Encoding:, Rotate Right f (No Carry) = ffff. Encoding:, Rotate Right f (No Carry) = ffff. Description:, Rotate Right f (No Carry) = The contents of register 'f' are rotated. Description:, Rotate Right f (No Carry) = The contents of register 'f' are rotated. Description:, Rotate Right f (No Carry) = The contents of register 'f' are rotated. Description:, Rotate Right f (No Carry) = The contents of register 'f' are rotated",
    "PIC18(L)F25/26K83\nThe contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected (default), overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec -tion 42.2.3 'Byte-Oriented and BitOriented Instructions in Indexed Lit -eral Offset Mode' for details.\nWords:\nCycles:\n1\n1\nQ Cycle Activity:",
    "Example 1:\nRRNCF   REG, 1, 0\nBefore Instruction\nREG\n=\n1101 0111\nAfter Instruction\nREG\n=\n1110 1011",
    "Example 2:\nRRNCF   REG, 0, 0\nBefore Instruction\nW\n=\n?\nREG\n=\n1101 0111\nAfter Instruction\nW\n=\n1110 1011\nREG\n=\n1101 0111",
    "PIC18(L)F25/26K83\nSETF, 1 = Set f. SETF, 2 = Set f. SETF, 3 = Set f. SETF, 4 = Set f. Syntax:, 1 = SETF f {,a}. Syntax:, 2 = SETF f {,a}. Syntax:, 3 = SETF f {,a}. Syntax:, 4 = SETF f {,a}. Operands:, 1 = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, 2 = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, 3 = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, 4 = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operation:, 1 = FFh \uf0ae f. Operation:, 2 = FFh \uf0ae f. Operation:, 3 = FFh \uf0ae f. Operation:, 4 = FFh \uf0ae f. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0110. Encoding:, 2 = 100a. Encoding:, 3 = ffff. Encoding:, 4",
    "PIC18(L)F25/26K83\n= ffff. Description:, 1 = The contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, 2 = The contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details..",
    "PIC18(L)F25/26K83\nDescription:, 3 = The contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, 4 = The contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Words:, 1 =",
    "PIC18(L)F25/26K83\n1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q1, 1 = Q2. Q1, 2 = Q2. Q1, 3 = Q3. Q1, 4 = Q4 Write. , 1 = register 'f'. , 2 = register 'f'. , 3 = Data. , 4 = register 'f'. Example:, 1 = SETF. Example:, 2 = . Example:, 3 = REG,. Example:, 4 = 1. REG After Instruction REG, 1 = = =. REG After Instruction REG, 2 = 5Ah FFh. REG After Instruction REG, 3 = . REG After Instruction REG, 4 = ",
    "PIC18(L)F25/26K83\nSyntax:, Enter Sleep mode = SLEEP. Syntax:, Enter Sleep mode = SLEEP. Syntax:, Enter Sleep mode = SLEEP. Syntax:, Enter Sleep mode = SLEEP. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operation:, Enter Sleep mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler, 1 \uf0ae TO, 0 \uf0ae PD. Operation:, Enter Sleep mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler, 1 \uf0ae TO, 0 \uf0ae PD. Operation:, Enter Sleep mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler, 1 \uf0ae TO, 0 \uf0ae PD. Operation:, Enter Sleep mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler, 1 \uf0ae TO, 0 \uf0ae PD. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Encoding:, Enter Sleep mode = 0000. Encoding:, Enter Sleep mode = 0000.",
    "PIC18(L)F25/26K83\nEncoding:, Enter Sleep mode = 0000. Encoding:, Enter Sleep mode = 0011. Description:, Enter Sleep mode = The Power-down Status bit (PD) is cleared. The Time-out Status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep mode = The Power-down Status bit (PD) is cleared. The Time-out Status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep mode = The Power-down Status bit (PD) is cleared. The Time-out Status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep mode = The Power-down Status bit (PD) is cleared. The Time-out Status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with",
    "PIC18(L)F25/26K83\nthe oscillator stopped.. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Q Cycle Activity:, Enter Sleep mode = Q Cycle Activity:. Q Cycle Activity:, Enter Sleep mode = Q Cycle Activity:. Q Cycle Activity:, Enter Sleep mode = Q Cycle Activity:. Q Cycle Activity:, Enter Sleep mode = Q Cycle Activity:. Q1, Enter Sleep mode = Q2. Q1, Enter Sleep mode = Q3. Q1, Enter Sleep mode = . Q1, Enter Sleep mode = Q4. Decode, Enter Sleep mode = No operation. Decode, Enter Sleep mode = Process Data. Decode, Enter Sleep mode = . Decode, Enter Sleep mode = Go to Sleep",
    "Example:\nSLEEP\nBefore Instruction\nTO\n=\n?\nPD\n=\n?\nAfter Instruction\nTO\n=\n1 \u2020\nPD\n=\n0\n- \u2020   If WDT causes wake-up, this bit is cleared.",
    "PIC18(L)F25/26K83\nSyntax:, Subtract Literal from FSR = SUBFSR f, k. Syntax:, Subtract Literal from FSR = SUBFSR f, k. Syntax:, Subtract Literal from FSR = SUBFSR f, k. Syntax:, Subtract Literal from FSR = SUBFSR f, k. Operands:, Subtract Literal from FSR = 0 \uf0a3 k \uf0a3 63. Operands:, Subtract Literal from FSR = 0 \uf0a3 k \uf0a3 63. Operands:, Subtract Literal from FSR = 0 \uf0a3 k \uf0a3 63. Operands:, Subtract Literal from FSR = 0 \uf0a3 k \uf0a3 63. , Subtract Literal from FSR = f \uf0ce [ 0, 1, 2 ]. , Subtract Literal from FSR = f \uf0ce [ 0, 1, 2 ]. , Subtract Literal from FSR = f \uf0ce [ 0, 1, 2 ]. , Subtract Literal from FSR = f \uf0ce [ 0, 1, 2 ]. Operation:, Subtract Literal from FSR = FSR(f) - k \uf0ae FSRf. Operation:, Subtract Literal from FSR =",
    "PIC18(L)F25/26K83\nFSR(f) - k \uf0ae FSRf. Operation:, Subtract Literal from FSR = FSR(f) - k \uf0ae FSRf. Operation:, Subtract Literal from FSR = FSR(f) - k \uf0ae FSRf. Status Affected:, Subtract Literal from FSR = None. Status Affected:, Subtract Literal from FSR = None. Status Affected:, Subtract Literal from FSR = None. Status Affected:, Subtract Literal from FSR = None. Encoding:, Subtract Literal from FSR = 1110. Encoding:, Subtract Literal from FSR = 1001. Encoding:, Subtract Literal from FSR = ffkk. Encoding:, Subtract Literal from FSR = kkkk. Description:, Subtract Literal from FSR = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f'.. Description:, Subtract Literal from FSR = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f'.. Description:,",
    "PIC18(L)F25/26K83\nSubtract Literal from FSR = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f'.. Description:, Subtract Literal from FSR = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f'.. Words:, Subtract Literal from FSR = 1. Words:, Subtract Literal from FSR = 1. Words:, Subtract Literal from FSR = 1. Words:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Q Cycle Activity:, Subtract Literal from FSR = Q Cycle Activity:. Q Cycle Activity:, Subtract Literal from FSR = Q Cycle Activity:. Q Cycle Activity:, Subtract Literal from FSR = Q Cycle Activity:. Q Cycle Activity:, Subtract Literal from FSR = Q Cycle",
    "PIC18(L)F25/26K83\nActivity:. Q1, Subtract Literal from FSR = Q2. Q1, Subtract Literal from FSR = Q3. Q1, Subtract Literal from FSR = . Q1, Subtract Literal from FSR = Q4. Decode, Subtract Literal from FSR = Read register 'f'. Decode, Subtract Literal from FSR = Data. Decode, Subtract Literal from FSR = Process. Decode, Subtract Literal from FSR = Write to destination",
    "Example:\nSUBFSR 2, 23h\nBefore Instruction\nFSR2\n=\n03FFh\nAfter Instruction\nFSR2\n=\n03DCh",
    "Subtract f from W with borrow\nSyntax:\nSUBFWB    f {,d {,a}}\nOperands:\n0 \uf0a3\uf020 f \uf0a3\uf020 255\nd \uf0ce [0,1]\na\n\uf0ce\n[0,1]\nOperation:\n(W) - (f) - (C) \uf0ae\uf020 dest\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0101\n01da\nffff\nffff\nDescription:\nSubtract register 'f' and CARRY flag (borrow) from W (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Ori - ented Instructions in Indexed Literal Offset Mode' for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:",
    "Subtract f from W with borrow\nBefore Instruction, Read.Example 1: SUBFWB = Before Instruction. Before Instruction, Q2.register 'f'.Example 1: SUBFWB = Before Instruction. Before Instruction, Q3.Process Data.REG, 1, 0 = . Before Instruction, Q4.Write to destination. = . REG, Read.Example 1: SUBFWB = =. REG, Q2.register 'f'.Example 1: SUBFWB = 3. REG, Q3.Process Data.REG, 1, 0 = . REG, Q4.Write to destination. = . W, Read.Example 1: SUBFWB = =. W, Q2.register 'f'.Example 1: SUBFWB = 2. W, Q3.Process Data.REG, 1, 0 = . W, Q4.Write to destination. = . C, Read.Example 1: SUBFWB = =. C, Q2.register 'f'.Example 1: SUBFWB = 1. C, Q3.Process Data.REG, 1, 0 = . C, Q4.Write to destination. = . After",
    "Subtract f from W with borrow\nInstruction, Read.Example 1: SUBFWB = After Instruction. After Instruction, Q2.register 'f'.Example 1: SUBFWB = After Instruction. After Instruction, Q3.Process Data.REG, 1, 0 = After Instruction. After Instruction, Q4.Write to destination. = After Instruction. REG, Read.Example 1: SUBFWB = . REG, Q2.register 'f'.Example 1: SUBFWB = FF. REG, Q3.Process Data.REG, 1, 0 = . REG, Q4.Write to destination. = . W, Read.Example 1: SUBFWB = = =. W, Q2.register 'f'.Example 1: SUBFWB = 2. W, Q3.Process Data.REG, 1, 0 = . W, Q4.Write to destination. = . C, Read.Example 1: SUBFWB = =. C, Q2.register 'f'.Example 1: SUBFWB = 0. C, Q3.Process Data.REG, 1, 0 = . C, Q4.Write to destination. =",
    "Subtract f from W with borrow\n. Z, Read.Example 1: SUBFWB = =. Z, Q2.register 'f'.Example 1: SUBFWB = 0. Z, Q3.Process Data.REG, 1, 0 = . Z, Q4.Write to destination. = . N, Read.Example 1: SUBFWB = . N, Q2.register 'f'.Example 1: SUBFWB = ;. N, Q3.Process Data.REG, 1, 0 = . N, Q4.Write to destination. = . 2:, Read.Example 1: SUBFWB = =. 2:, Q2.register 'f'.Example 1: SUBFWB = 1. 2:, Q3.Process Data.REG, 1, 0 = result is negative. 2:, Q4.Write to destination. = . Example, Read.Example 1: SUBFWB = . Example, Q2.register 'f'.Example 1: SUBFWB = SUBFWB. Example, Q3.Process Data.REG, 1, 0 = REG, 0, 0. Example,",
    "Subtract f from W with borrow\nQ4.Write to destination. = . Before Instruction, Read.Example 1: SUBFWB = Before Instruction. Before Instruction, Q2.register 'f'.Example 1: SUBFWB = Before Instruction. Before Instruction, Q3.Process Data.REG, 1, 0 = Before Instruction. Before Instruction, Q4.Write to destination. = Before Instruction. REG, Read.Example 1: SUBFWB = =. REG, Q2.register 'f'.Example 1: SUBFWB = 2. REG, Q3.Process Data.REG, 1, 0 = . REG, Q4.Write to destination. = . W, Read.Example 1: SUBFWB = =. W, Q2.register 'f'.Example 1: SUBFWB = 5. W, Q3.Process Data.REG, 1, 0 = . W, Q4.Write to destination. = . C, Read.Example 1: SUBFWB = =. C, Q2.register 'f'.Example 1: SUBFWB = 1. C, Q3.Process Data.REG, 1, 0 = .",
    "Subtract f from W with borrow\nC, Q4.Write to destination. = . After Instruction, Read.Example 1: SUBFWB = After Instruction. After Instruction, Q2.register 'f'.Example 1: SUBFWB = After Instruction. After Instruction, Q3.Process Data.REG, 1, 0 = After Instruction. After Instruction, Q4.Write to destination. = After Instruction. REG, Read.Example 1: SUBFWB = =. REG, Q2.register 'f'.Example 1: SUBFWB = 2. REG, Q3.Process Data.REG, 1, 0 = . REG, Q4.Write to destination. = . W, Read.Example 1: SUBFWB = =. W, Q2.register 'f'.Example 1: SUBFWB = 3. W, Q3.Process Data.REG, 1, 0 = . W, Q4.Write to destination. = . C, Read.Example 1: SUBFWB = =. C, Q2.register 'f'.Example 1: SUBFWB = 1. C, Q3.Process Data.REG, 1, 0",
    "Subtract f from W with borrow\n= . C, Q4.Write to destination. = . Z, Read.Example 1: SUBFWB = =. Z, Q2.register 'f'.Example 1: SUBFWB = 0. Z, Q3.Process Data.REG, 1, 0 = . Z, Q4.Write to destination. = . N, Read.Example 1: SUBFWB = =. N, Q2.register 'f'.Example 1: SUBFWB = 0 ;. N, Q3.Process Data.REG, 1, 0 = result is positive. N, Q4.Write to destination. = . Example 3:, Read.Example 1: SUBFWB = . Example 3:, Q2.register 'f'.Example 1: SUBFWB = SUBFWB. Example 3:, Q3.Process Data.REG, 1, 0 = REG, 1, 0. Example 3:, Q4.Write to destination. = . Before Instruction, Read.Example 1: SUBFWB = Before Instruction. Before Instruction, Q2.register 'f'.Example 1: SUBFWB = Before",
    "Subtract f from W with borrow\nInstruction. Before Instruction, Q3.Process Data.REG, 1, 0 = Before Instruction. Before Instruction, Q4.Write to destination. = Before Instruction. REG, Read.Example 1: SUBFWB = =. REG, Q2.register 'f'.Example 1: SUBFWB = 1. REG, Q3.Process Data.REG, 1, 0 = . REG, Q4.Write to destination. = . W, Read.Example 1: SUBFWB = =. W, Q2.register 'f'.Example 1: SUBFWB = 2. W, Q3.Process Data.REG, 1, 0 = . W, Q4.Write to destination. = . C, Read.Example 1: SUBFWB = =. C, Q2.register 'f'.Example 1: SUBFWB = 0. C, Q3.Process Data.REG, 1, 0 = . C, Q4.Write to destination. = . After Instruction, Read.Example 1: SUBFWB = After Instruction. After Instruction, Q2.register 'f'.Example 1: SUBFWB",
    "Subtract f from W with borrow\n= After Instruction. After Instruction, Q3.Process Data.REG, 1, 0 = After Instruction. After Instruction, Q4.Write to destination. = After Instruction. REG, Read.Example 1: SUBFWB = =. REG, Q2.register 'f'.Example 1: SUBFWB = 0. REG, Q3.Process Data.REG, 1, 0 = . REG, Q4.Write to destination. = . W, Read.Example 1: SUBFWB = =. W, Q2.register 'f'.Example 1: SUBFWB = 2. W, Q3.Process Data.REG, 1, 0 = . W, Q4.Write to destination. = . C, Read.Example 1: SUBFWB = =. C, Q2.register 'f'.Example 1: SUBFWB = 1. C, Q3.Process Data.REG, 1, 0 = . C, Q4.Write to destination. = . Z, Read.Example 1: SUBFWB = =. Z, Q2.register 'f'.Example 1: SUBFWB =",
    "Subtract f from W with borrow\n1 ;. Z, Q3.Process Data.REG, 1, 0 = result is zero. Z, Q4.Write to destination. = . N, Read.Example 1: SUBFWB = =. N, Q2.register 'f'.Example 1: SUBFWB = 0. N, Q3.Process Data.REG, 1, 0 = . N, Q4.Write to destination. = ",
    "Subtract W from literal\nSyntax:, 1 = SUBLW k. Syntax:, 2 = SUBLW k. Syntax:, 3 = SUBLW k. Syntax:, 4 = SUBLW k. Syntax:, 5 = SUBLW k. Operands:, 1 = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, 2 = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, 3 = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, 4 = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, 5 = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operation:, 1 = k - (W) \uf0ae\uf020 W. Operation:, 2 = k - (W) \uf0ae\uf020 W. Operation:, 3 = k - (W) \uf0ae\uf020 W. Operation:, 4 = k - (W) \uf0ae\uf020 W. Operation:, 5 = k - (W) \uf0ae\uf020 W. Status Affected:, 1 = N, OV, C, DC, Z. Status Affected:, 2 = N, OV, C, DC, Z. Status Affected:, 3 = N, OV, C, DC, Z. Status Affected:, 4 = N, OV, C, DC, Z. Status Affected:, 5 = N, OV, C, DC, Z. Encoding:, 1 =",
    "Subtract W from literal\n0000. Encoding:, 2 = 1000. Encoding:, 3 = . Encoding:, 4 = kkkk. Encoding:, 5 = kkkk. Description, 1 = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, 2 = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, 3 = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, 4 = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, 5 = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Cycles:, 5 = 1. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle",
    "Subtract W from literal\nActivity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. Q Cycle Activity:, 5 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q2. Q1, 3 = Q2. Q1, 4 = Q3. Q1, 5 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Read literal 'k'. Decode, 3 = Read literal 'k'. Decode, 4 = Process Data. Decode, 5 = Write to W. Example 1: SUBLW 02h, 1 = Example 1: SUBLW 02h. Example 1: SUBLW 02h, 2 = Example 1: SUBLW 02h. Example 1: SUBLW 02h, 3 = Example 1: SUBLW 02h. Example 1: SUBLW 02h, 4 = Example 1: SUBLW 02h. Example 1: SUBLW 02h, 5 = Example 1: SUBLW 02h. Before, 1 = Instruction W =. Before, 2 =",
    "Subtract W from literal\n01h. Before, 3 = . Before, 4 = . Before, 5 = . C = ?, 1 = C = ?. C = ?, 2 = C = ?. C = ?, 3 = C = ?. C = ?, 4 = C = ?. C = ?, 5 = C = ?. After, 1 = Instruction W C. After, 2 = . After, 3 = . After, 4 = . After, 5 = . = 01h = 1 ; result is positive Z = 0 N = 0, 1 = = 01h = 1 ; result is positive Z = 0 N = 0. = 01h = 1 ; result is positive Z = 0 N = 0, 2 = = 01h = 1 ; result is positive Z = 0 N = 0. = 01h = 1 ; result is positive Z = 0 N = 0, 3 = = 01h = 1 ; result is positive Z = 0 N = 0. = 01h = 1 ; result is positive Z = 0 N = 0, 4 = = 01h = 1 ; result is positive Z = 0 N = 0. = 01h = 1 ; result is positive Z = 0 N = 0, 5 =",
    "Subtract W from literal\n= 01h = 1 ; result is positive Z = 0 N = 0. Example, 1 = Before. Example, 2 = Instruction. Example, 3 = . Example, 4 = . Example, 5 = . 2: SUBLW 02h, 1 = 2: SUBLW 02h. 2: SUBLW 02h, 2 = 2: SUBLW 02h. 2: SUBLW 02h, 3 = 2: SUBLW 02h. 2: SUBLW 02h, 4 = 2: SUBLW 02h. 2: SUBLW 02h, 5 = 2: SUBLW 02h. , 1 = W = C =. , 2 = 02h ?. , 3 = . , 4 = . , 5 = . After, 1 = Instruction W = C =. After, 2 = 00h 1. After, 3 = ; result is zero. After, 4 = ; result is zero. After, 5 = ; result is zero. Example 3: SUBLW, 1 = Example 3: SUBLW. Example 3: SUBLW, 2 = Example 3: SUBLW. Example 3: SUBLW, 3 = Example 3:",
    "Subtract W from literal\nSUBLW. Example 3: SUBLW, 4 = Example 3: SUBLW. Example 3: SUBLW, 5 = Example 3: SUBLW. , 1 = Before Instruction W. , 2 = 1. , 3 = 02h. , 4 = 02h. , 5 = 02h. Z = N = 0, 1 = Z = N = 0. Z = N = 0, 2 = Z = N = 0. Z = N = 0, 3 = Z = N = 0. Z = N = 0, 4 = Z = N = 0. Z = N = 0, 5 = Z = N = 0. , 1 = = C. , 2 = 03h. , 3 = . , 4 = . , 5 = . = ? After Instruction, 1 = = ? After Instruction. = ? After Instruction, 2 = = ? After Instruction. = ? After Instruction, 3 = = ? After Instruction. = ? After Instruction, 4 = = ? After Instruction. = ? After Instruction, 5 = = ? After Instruction. , 1 = W C Z. , 2 = 0 0. , 3 = ; (2's complement) ; result is negative. , 4",
    "Subtract W from literal\n= ; (2's complement) ; result is negative. , 5 = ; (2's complement) ; result is negative. = FFh = = N = 1, 1 = = FFh = = N = 1. = FFh = = N = 1, 2 = = FFh = = N = 1. = FFh = = N = 1, 3 = = FFh = = N = 1. = FFh = = N = 1, 4 = = FFh = = N = 1. = FFh = = N = 1, 5 = = FFh = = N = 1",
    "Subtract W from literal\nSyntax:, Subtract Wfrom f = SUBWF. Syntax:, Subtract Wfrom f = f {,d {,a}}. Syntax:, Subtract Wfrom f = . Syntax:, Subtract Wfrom f = . Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255. Operands:, Subtract Wfrom f = . Operands:, Subtract Wfrom f = . , Subtract Wfrom f = d \uf0ce [0,1]. , Subtract Wfrom f = d \uf0ce [0,1]. , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = a \uf0ce [0,1]. , Subtract Wfrom f = a \uf0ce [0,1]. , Subtract Wfrom f = . , Subtract Wfrom f = . Operation:, Subtract Wfrom f = (f) - (W) \uf0ae\uf020 dest. Operation:, Subtract",
    "Subtract W from literal\nWfrom f = (f) - (W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = . Operation:, Subtract Wfrom f = . Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = . Status Affected:, Subtract Wfrom f = . Encoding:, Subtract Wfrom f = 0101. Encoding:, Subtract Wfrom f = 11da. Encoding:, Subtract Wfrom f = ffff. Encoding:, Subtract Wfrom f = ffff. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's. Description:,",
    "Subtract W from literal\nSubtract Wfrom f = Subtract Wfrom register 'f' (2's\nSubtract W from register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 42.2.3 'Byte-Oriented and Bit-Ori -ented Instructions in Indexed Literal Offset Mode' for details.\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\n1\n1\nQ2\nRead\nQ3\nProcess register 'f'\nExample 1:\nData\nSUBWF   REG, 1, 0\nBefore Instruction\nW\n=\nREG\n=\nC\n=\nAfter Instruction\nW\nREG\n=\nC\n=\nZ\n=\n=\nN\n=\nExample 2:\nBefore Instruction\nW\n=\nREG\n=\nC\n=\nAfter Instruction\nW\nREG\n=\nC",
    "Subtract W from literal\n=\nZ\n=\n=\nN\n=\nExample 3:\nBefore Instruction\nW\n=\nREG\n=\nC\n=\nAfter Instruction\nW\nREG\n=\nC\n=\nZ\n=\nN\n=\n=\n3\n?\n2\n1\n1\n2\n0\n; result is positive\n0\nSUBWF   REG, 0, 0\n2\n?\n2\n2\n1\n0\n1\n; result is zero\n0\nSUBWF   REG, 1, 0\n1\n?\n2\nFFh ;(2's complement)\n0\n2\n0\n; result is negative\n1\nQ4\nWrite to destination",
    "PIC18(L)F25/26K83\nSyntax:, Subtract Wfrom f with Borrow = SUBWFB. Syntax:, Subtract Wfrom f with Borrow = f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = f {,d {,a}}. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] \uf0ce. Operands:, Subtract Wfrom f with Borrow = . Operands:, Subtract Wfrom f with Borrow = . Operands:, Subtract Wfrom f with Borrow = . Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:, Subtract",
    "PIC18(L)F25/26K83\nWfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Encoding:, Subtract Wfrom f with Borrow = 0101. Encoding:, Subtract Wfrom f with Borrow = 10da. Encoding:, Subtract Wfrom f with Borrow = ffff. Encoding:, Subtract Wfrom f with Borrow = ffff\nDescription:",
    "PIC18(L)F25/26K83\nSubtract W and the CARRY flag (borrow) from register 'f' (2's comple -ment method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec -tion 42.2.3 'Byte-Oriented and BitOriented Instructions in Indexed Lit -eral Offset Mode' for details.\nWords:\nCycles:\n1\n1\nQ Cycle Activity:",
    "PIC18(L)F25/26K83\nExample 1:,  = Example 1:. Example 1:, Q2 Read.register 'f' = SUBWFB. Example 1:, Q3 Process.Data = REG, 1, 0. Example 1:, Q4 Write to.destination = . Before Instruction,  = Before Instruction. Before Instruction, Q2 Read.register 'f' = . Before Instruction, Q3 Process.Data = . Before Instruction, Q4 Write to.destination = . REG,  = =. REG, Q2 Read.register 'f' = 19h. REG, Q3 Process.Data = (0001. REG, Q4 Write to.destination = 1001). W,  = =. W, Q2 Read.register 'f' = 0Dh. W, Q3 Process.Data = (0000. W, Q4 Write to.destination = 1101). C,  = =. C, Q2 Read.register 'f' = 1. C, Q3 Process.Data = . C, Q4 Write to.destination = . After Instruction,",
    "PIC18(L)F25/26K83\n= After Instruction. After Instruction, Q2 Read.register 'f' = . After Instruction, Q3 Process.Data = . After Instruction, Q4 Write to.destination = . REG,  = =. REG, Q2 Read.register 'f' = 0Ch. REG, Q3 Process.Data = (0000. REG, Q4 Write to.destination = 1100). W,  = =. W, Q2 Read.register 'f' = 0Dh. W, Q3 Process.Data = (0000. W, Q4 Write to.destination = 1101). C,  = =. C, Q2 Read.register 'f' = 1. C, Q3 Process.Data = . C, Q4 Write to.destination = . Z,  = =. Z, Q2 Read.register 'f' = 0. Z, Q3 Process.Data = . Z, Q4 Write to.destination = . N,",
    "PIC18(L)F25/26K83\n= =. N, Q2 Read.register 'f' = 0. N, Q3 Process.Data = ; result is positive. N, Q4 Write to.destination = ; result is positive. Example 2:,  = Example 2:. Example 2:, Q2 Read.register 'f' = SUBWFB. Example 2:, Q3 Process.Data = REG,. Example 2:, Q4 Write to.destination = . ,  = . , Q2 Read.register 'f' = . , Q3 Process.Data = 0, 0. , Q4 Write to.destination = . Before Instruction REG,  = =. Before Instruction REG, Q2 Read.register 'f' = 1Bh. Before Instruction REG, Q3 Process.Data = (0001. Before Instruction REG, Q4 Write to.destination = 1011). W,  = =. W, Q2 Read.register 'f' = 1Ah. W, Q3 Process.Data = (0001. W, Q4 Write to.destination = 1010). C,",
    "PIC18(L)F25/26K83\n= =. C, Q2 Read.register 'f' = 0. C, Q3 Process.Data = . C, Q4 Write to.destination = . After Instruction,  = After Instruction. After Instruction, Q2 Read.register 'f' = . After Instruction, Q3 Process.Data = . After Instruction, Q4 Write to.destination = . REG,  = =. REG, Q2 Read.register 'f' = 1Bh. REG, Q3 Process.Data = (0001. REG, Q4 Write to.destination = 1011). W,  = =. W, Q2 Read.register 'f' = 00h. W, Q3 Process.Data = . W, Q4 Write to.destination = . C,  = =. C, Q2 Read.register 'f' = 1. C, Q3 Process.Data = . C, Q4 Write to.destination = . Z,  = =. Z, Q2 Read.register 'f' = 1. Z, Q3 Process.Data = ; result is zero. Z, Q4 Write to.destination = . N,",
    "PIC18(L)F25/26K83\n= =. N, Q2 Read.register 'f' = 0. N, Q3 Process.Data = . N, Q4 Write to.destination = . Example 3:,  = Example 3:. Example 3:, Q2 Read.register 'f' = SUBWFB. Example 3:, Q3 Process.Data = REG, 1,. Example 3:, Q4 Write to.destination = . Before Instruction,  = Before Instruction. Before Instruction, Q2 Read.register 'f' = Before Instruction. Before Instruction, Q3 Process.Data = . Before Instruction, Q4 Write to.destination = . REG,  = =. REG, Q2 Read.register 'f' = 03h. REG, Q3 Process.Data = (0000 0011). REG, Q4 Write to.destination = . W,  = =. W, Q2 Read.register 'f' = 0Eh. W, Q3 Process.Data = (0000. W, Q4 Write to.destination = 1110). C,",
    "PIC18(L)F25/26K83\n= =. C, Q2 Read.register 'f' = 1. C, Q3 Process.Data = . C, Q4 Write to.destination = . After Instruction,  = After Instruction. After Instruction, Q2 Read.register 'f' = . After Instruction, Q3 Process.Data = . After Instruction, Q4 Write to.destination = . REG,  = =. REG, Q2 Read.register 'f' = F5h. REG, Q3 Process.Data = (1111 0101) ; [2's comp]. REG, Q4 Write to.destination = . W,  = =. W, Q2 Read.register 'f' = 0Eh. W, Q3 Process.Data = (0000 1110). W, Q4 Write to.destination = . C,  = =. C, Q2 Read.register 'f' = 0. C, Q3 Process.Data = . C, Q4 Write to.destination = . Z,",
    "PIC18(L)F25/26K83\n= =. Z, Q2 Read.register 'f' = 0. Z, Q3 Process.Data = . Z, Q4 Write to.destination = . N,  = =. N, Q2 Read.register 'f' = 1. N, Q3 Process.Data = ; result is negative. N, Q4 Write to.destination = ",
    "PIC18(L)F25/26K83\nSyntax:, Swap f = SWAPF f {,d {,a}}. Syntax:, Swap f = SWAPF f {,d {,a}}. Syntax:, Swap f = SWAPF f {,d {,a}}. Syntax:, Swap f = SWAPF f {,d {,a}}. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap",
    "PIC18(L)F25/26K83\nf = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Encoding:, Swap f = 0011. Encoding:, Swap f = 10da. Encoding:, Swap f = ffff. Encoding:, Swap f = ffff. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is",
    "PIC18(L)F25/26K83\n' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If",
    "PIC18(L)F25/26K83\n'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the",
    "PIC18(L)F25/26K83\nextended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Words:, Swap f = 1. Words:, Swap f = 1. Words:, Swap f = 1. Words:, Swap f = 1. Cycles:, Swap f = 1. Cycles:, Swap f = 1. Cycles:, Swap f = 1. Cycles:, Swap f = 1. Q Cycle Activity:, Swap f = . Q Cycle Activity:, Swap f = . Q Cycle Activity:, Swap f = . Q Cycle Activity:, Swap f = . Q1, Swap f = . Q1, Swap f = . Q1, Swap f = . Q1, Swap f = . , Swap f = Q2. , Swap f = Q3. , Swap f = Q3. , Swap f = Q4. Decode, Swap f = Read register 'f'. Decode, Swap f = Process Data. Decode, Swap f = Process Data.",
    "PIC18(L)F25/26K83\nDecode, Swap f = Write to destination. Example:, Swap f = SWAPF. Example:, Swap f = REG, 1, 0. Example:, Swap f = REG, 1, 0. Example:, Swap f = . Before Instruction, Swap f = 53h. Before Instruction, Swap f = . Before Instruction, Swap f = . Before Instruction, Swap f = . REG = After Instruction =, Swap f = . REG = After Instruction =, Swap f = . REG = After Instruction =, Swap f = . REG = After Instruction =, Swap f = . REG, Swap f = 35h. REG, Swap f = . REG, Swap f = . REG, Swap f = ",
    "PIC18(L)F25/26K83\nSyntax:, Table Read = TBLRD ( *; *+; *-; +*). Syntax:, Table Read = TBLRD ( *; *+; *-; +*). Syntax:, Table Read = TBLRD ( *; *+; *-; +*). Syntax:, Table Read = TBLRD ( *; *+; *-; +*). Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem",
    "PIC18(L)F25/26K83\n(TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*,",
    "PIC18(L)F25/26K83\n(TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Encoding:, Table Read = 0000. Encoding:, Table Read = 0000. Encoding:, Table Read = 0000. Encoding:, Table Read = 10nn nn=0 * =1 *+ =2 *-. Description:,",
    "PIC18(L)F25/26K83\nTable Read = =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : LeastSignificant Byte of Program Memory. Description:, Table Read = =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : LeastSignificant Byte of Program Memory. Description:, Table Read = =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The",
    "PIC18(L)F25/26K83\nTBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : LeastSignificant Byte of Program Memory. Description:, Table Read = =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : LeastSignificant Byte of Program Memory. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Cycles:, Table Read = . Cycles:, Table Read = . Cycles:, Table Read = . Cycles:, Table Read = . , Table Read = 2. , Table Read = 2. , Table Read = 2. , Table Read = 2. Q Cycle Activity:, Table Read = Q Cycle",
    "PIC18(L)F25/26K83\nActivity:. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q1, Table Read = Q2. Q1, Table Read = . Q1, Table Read = Q3. Q1, Table Read = Q4. Decode, Table Read = . Decode, Table Read = No operation. Decode, Table Read = No operation. Decode, Table Read = No operation. , Table Read = No operation. , Table Read = No operation (Read Program Memory). , Table Read = No operation. , Table Read = No operation (Write TABLAT)",
    "Table Read (Continued)\nExample1:, 1 = TBLRD *+. Example1:, 2 = ;. Example1:, 3 = . Before Instruction TABLAT, 1 = Before Instruction TABLAT. Before Instruction TABLAT, 2 = =. Before Instruction TABLAT, 3 = 55h. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 00A356h. MEMORY (00A356h), 1 = MEMORY (00A356h). MEMORY (00A356h), 2 = =. MEMORY (00A356h), 3 = 34h. After Instruction, 1 = After Instruction. After Instruction, 2 = =. After Instruction, 3 = 34h. TABLAT TBLPTR, 1 = TABLAT TBLPTR. TABLAT TBLPTR, 2 = =. TABLAT TBLPTR, 3 = 00A357h. Example2:, 1 = TBLRD +*. Example2:, 2 = ;. Example2:, 3 = . Before Instruction, 1 = Before Instruction. Before Instruction, 2 = =. Before Instruction, 3 = AAh. TABLAT",
    "Table Read (Continued)\nTBLPTR, 1 = TABLAT TBLPTR. TABLAT TBLPTR, 2 = =. TABLAT TBLPTR, 3 = 01A357h. MEMORY (01A357h), 1 = MEMORY (01A357h). MEMORY (01A357h), 2 = =. MEMORY (01A357h), 3 = 12h. MEMORY (01A358h), 1 = MEMORY (01A358h). MEMORY (01A358h), 2 = =. MEMORY (01A358h), 3 = 34h. After Instruction, 1 = After Instruction. After Instruction, 2 = =. After Instruction, 3 = 34h. TABLAT TBLPTR, 1 = TABLAT TBLPTR. TABLAT TBLPTR, 2 = =. TABLAT TBLPTR, 3 = 01A358h",
    "Table Read (Continued)\nSyntax:, Table Write = TBLWT ( *; *+; *-; +*). Syntax:, Table Write = TBLWT ( *; *+; *-; +*). Syntax:, Table Write = TBLWT ( *; *+; *-; +*). Syntax:, Table Write = TBLWT ( *; *+; *-; +*). Operands:, Table Write = None. Operands:, Table Write = None. Operands:, Table Write = None. Operands:, Table Write = None. Operation:, Table Write = if TBLWT*, (TABLAT) \uf0ae Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \uf0ae Holding Register; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLWT*-, (TABLAT) \uf0ae Holding Register; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLWT+*, (TBLPTR) + 1 \uf0ae TBLPTR; (TABLAT) \uf0ae Holding Register;. Operation:, Table Write = if TBLWT*, (TABLAT) \uf0ae Holding Register; TBLPTR - No",
    "Table Read (Continued)\nChange; if TBLWT*+, (TABLAT) \uf0ae Holding Register; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLWT*-, (TABLAT) \uf0ae Holding Register; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLWT+*, (TBLPTR) + 1 \uf0ae TBLPTR; (TABLAT) \uf0ae Holding Register;. Operation:, Table Write = if TBLWT*, (TABLAT) \uf0ae Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \uf0ae Holding Register; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLWT*-, (TABLAT) \uf0ae Holding Register; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLWT+*, (TBLPTR) + 1 \uf0ae TBLPTR; (TABLAT) \uf0ae Holding Register;. Operation:, Table Write = if TBLWT*, (TABLAT) \uf0ae Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \uf0ae Holding Register; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLWT*-, (TABLAT) \uf0ae Holding Register; (TBLPTR) -",
    "Table Read (Continued)\n1 \uf0ae TBLPTR; if TBLWT+*, (TBLPTR) + 1 \uf0ae TBLPTR; (TABLAT) \uf0ae Holding Register;. Status Affected:, Table Write = None. Status Affected:, Table Write = None. Status Affected:, Table Write = None. Status Affected:, Table Write = None. Encoding:, Table Write = 0000. Encoding:, Table Write = 0000. Encoding:, Table Write = 0000. Encoding:, Table Write = 11nn nn=0 *. , Table Write = . , Table Write = . , Table Write = . , Table Write = =1 *+. , Table Write = . , Table Write = . , Table Write = . , Table Write = =2 *-. , Table Write = . , Table Write = . , Table Write = . , Table Write = =3 +*\nDescription:",
    "Table Read (Continued)\nThis instruction uses the three LSBs of TBLPTR to determine which of the eight holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to Section 13.1 'Program Flash Memory' for additional details on pro -gramming Flash memory.) The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MByte address range. The LSb of the TBLPTR selects which byte of the program memory location to access.\nTBLPTR[0] = 0 :\nLeast Significant Byte of Program Memory Word\nTBLPTR[0] = 1 :\nMost Significant Byte of Program\nMemory Word\nThe TBLWT instruction can modify the value of TBLPTR as follows:\n\u00b7 no change\n\u00b7 post-increment\n\u00b7 post-decrement\n\u00b7 pre-increment\n2\nWords:\n1\nCycles:\nQ Cycle Activity:",
    "Table Read (Continued)\nDecode, Q2 = No operation. Decode, Q3 = No operation. Decode, Q4 = No operation. No operation, Q2 = No operation (Read TABLAT). No operation, Q3 = No operation. No operation, Q4 = No operation (Write to Holding Register)",
    "PIC18(L)F25/26K83\nExample1:, Table Write (Continued) = TBLWT *+;. Example1:, Table Write (Continued) = . Before Instruction, Table Write (Continued) = . Before Instruction, Table Write (Continued) = . TABLAT, Table Write (Continued) = . TABLAT, Table Write (Continued) = 55h. TBLPTR, Table Write (Continued) = . TBLPTR, Table Write (Continued) = 00A356h. HOLDING REGISTER (00A356h), Table Write (Continued) = . HOLDING REGISTER (00A356h), Table Write (Continued) = FFh. After Instructions (table write completion), Table Write (Continued) = After Instructions (table write completion). After Instructions (table write completion), Table Write (Continued) = After Instructions (table write completion). TABLAT, Table Write (Continued) = . TABLAT, Table Write (Continued) = 55h. TBLPTR, Table Write (Continued) = . TBLPTR, Table Write (Continued) = 00A357h. HOLDING REGISTER (00A356h), Table Write (Continued) = . HOLDING",
    "PIC18(L)F25/26K83\nREGISTER (00A356h), Table Write (Continued) = 55h. Example 2: TBLWT, Table Write (Continued) = . Example 2: TBLWT, Table Write (Continued) = . Before Instruction, Table Write (Continued) = . Before Instruction, Table Write (Continued) = . TABLAT, Table Write (Continued) = . TABLAT, Table Write (Continued) = 34h. TBLPTR, Table Write (Continued) = . TBLPTR, Table Write (Continued) = 01389Ah. HOLDING REGISTER (01389Ah), Table Write (Continued) = . HOLDING REGISTER (01389Ah), Table Write (Continued) = FFh. HOLDING REGISTER (01389Bh), Table Write (Continued) = . HOLDING REGISTER (01389Bh), Table Write (Continued) = FFh. After Instruction (table write completion), Table Write (Continued) = . After Instruction (table write completion), Table Write (Continued) = . TABLAT, Table Write (Continued) = . TABLAT, Table Write (Continued) = 34h. TBLPTR, Table Write (Continued) =",
    "PIC18(L)F25/26K83\n. TBLPTR, Table Write (Continued) = 01389Bh. HOLDING REGISTER (01389Ah), Table Write (Continued) = . HOLDING REGISTER (01389Ah), Table Write (Continued) = FFh. HOLDING REGISTER, Table Write (Continued) = . HOLDING REGISTER, Table Write (Continued) = . (01389Bh), Table Write (Continued) = . (01389Bh), Table Write (Continued) = 34h",
    "PIC18(L)F25/26K83\nSyntax:, Test f, skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, skip if 0 = TSTFSZ f {,a}. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f,",
    "PIC18(L)F25/26K83\nskip if 0 = None. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Encoding:, Test f, skip if 0 = 0110. Encoding:, Test f, skip if 0 = 011a. Encoding:, Test f, skip if 0 = ffff. Encoding:, Test f, skip if 0 = ffff. Description:, Test f, skip if 0 = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit-. Description:, Test f, skip if 0 = If 'f' = 0 , the next instruction fetched during the current instruction execution",
    "PIC18(L)F25/26K83\nis discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit-. Description:, Test f, skip if 0 = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit-. Description:, Test f, skip",
    "PIC18(L)F25/26K83\nif 0 = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit-. Words:, Test f, skip if 0 = 1. Words:, Test f, skip if 0 = 1. Words:, Test f, skip if 0 = 1. Words:, Test f, skip if 0 = 1. Cycles:, Test f, skip if 0 = 1(2). Cycles:, Test f, skip if 0 = 1(2). Cycles:, Test f, skip if 0 = 1(2). Cycles:, Test f, skip if 0 = 1(2)\nNote:",
    "PIC18(L)F25/26K83\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. skip:, Q2 = . skip:, Q3 = . skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:",
    "Q Cycle Activity:\nHERE    TSTFSZ  CNT, 1\nNZERO   :\nZERO    :\nBefore Instruction\nPC\n=\nAddress (HERE)\nAfter Instruction\nIf CNT\n=\n00h,\nPC\n=\nAddress (ZERO)\nIf CNT\n\uf0b9\n00h,\nPC\n=\nAddress (NZERO)",
    "PIC18(L)F25/26K83\nSyntax:, Exclusive OR literal with W = XORLW k. Syntax:, Exclusive OR literal with W = XORLW k. Syntax:, Exclusive OR literal with W = XORLW k. Syntax:, Exclusive OR literal with W = XORLW k. Operands:, Exclusive OR literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operation:, Exclusive OR literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR literal with W = (W) .XOR. k \uf0ae\uf020 W. Status Affected:, Exclusive OR literal with W = N, Z. Status Affected:, Exclusive OR literal with W = N, Z. Status Affected:, Exclusive OR literal with W = N, Z. Status Affected:, Exclusive OR literal with W =",
    "PIC18(L)F25/26K83\nN, Z. Encoding:, Exclusive OR literal with W = 0000. Encoding:, Exclusive OR literal with W = 1010. Encoding:, Exclusive OR literal with W = kkkk. Encoding:, Exclusive OR literal with W = kkkk. Description:, Exclusive OR literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Words:, Exclusive OR literal with W = 1. Words:, Exclusive OR literal with W = 1. Words:, Exclusive OR literal with W = 1. Words:, Exclusive OR literal with W = 1. Cycles:, Exclusive OR literal with W = 1. Cycles:,",
    "PIC18(L)F25/26K83\nExclusive OR literal with W = 1. Cycles:, Exclusive OR literal with W = 1. Cycles:, Exclusive OR literal with W = 1. Q Cycle Activity:, Exclusive OR literal with W = Q Cycle Activity:. Q Cycle Activity:, Exclusive OR literal with W = Q Cycle Activity:. Q Cycle Activity:, Exclusive OR literal with W = Q Cycle Activity:. Q Cycle Activity:, Exclusive OR literal with W = Q Cycle Activity:. Q1, Exclusive OR literal with W = Q2. Q1, Exclusive OR literal with W = Q3. Q1, Exclusive OR literal with W = Q4. Q1, Exclusive OR literal with W = Q4. Decode, Exclusive OR literal with W = Read literal 'k'. Decode, Exclusive OR literal with W = Process Data. Decode, Exclusive OR literal with W = Write to W. Decode, Exclusive OR literal with W = Write to W. Example:, Exclusive OR literal with W = XORLW. Example:, Exclusive OR literal with W = 0AFh. Example:, Exclusive OR literal with W = . Example:, Exclusive OR literal with W = . Before",
    "PIC18(L)F25/26K83\nInstruction, Exclusive OR literal with W = Before Instruction. Before Instruction, Exclusive OR literal with W = Before Instruction. Before Instruction, Exclusive OR literal with W = Before Instruction. Before Instruction, Exclusive OR literal with W = Before Instruction. W, Exclusive OR literal with W = B5h. W, Exclusive OR literal with W = . W, Exclusive OR literal with W = . W, Exclusive OR literal with W = . After Instruction, Exclusive OR literal with W = After Instruction. After Instruction, Exclusive OR literal with W = After Instruction. After Instruction, Exclusive OR literal with W = After Instruction. After Instruction, Exclusive OR literal with W = After Instruction. W, Exclusive OR literal with W = 1Ah. W, Exclusive OR literal with W = . W, Exclusive OR literal with W = . W, Exclusive OR literal with W = ",
    "PIC18(L)F25/26K83\nSyntax:, Exclusive OR Wwith f = XORWF. Syntax:, Exclusive OR Wwith f = f {,d {,a}}. Syntax:, Exclusive OR Wwith f = f {,d {,a}}. Syntax:, Exclusive OR Wwith f = f {,d {,a}}. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:,",
    "PIC18(L)F25/26K83\nExclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Encoding:, Exclusive OR Wwith f = 0001. Encoding:, Exclusive OR Wwith f = 10da. Encoding:, Exclusive OR Wwith f = ffff. Encoding:, Exclusive OR Wwith f = ffff. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing",
    "PIC18(L)F25/26K83\nmode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If",
    "PIC18(L)F25/26K83\n'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal",
    "PIC18(L)F25/26K83\nOffset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Sec - tion 42.2.3 'Byte-Oriented and Bit- Oriented Instructions in Indexed Lit - eral Offset Mode' for details.. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Q Cycle Activity:, Exclusive OR Wwith f = . Q Cycle Activity:, Exclusive OR Wwith f = . Q Cycle Activity:, Exclusive OR Wwith f = . Q Cycle Activity:, Exclusive OR Wwith f = . Q1, Exclusive OR Wwith f = . Q1, Exclusive OR Wwith f = . Q1, Exclusive OR Wwith f = . Q1, Exclusive OR Wwith f = . , Exclusive OR Wwith f = Q2. , Exclusive OR Wwith f = Q3. , Exclusive OR",
    "PIC18(L)F25/26K83\nWwith f = Q3. , Exclusive OR Wwith f = Q4. Decode, Exclusive OR Wwith f = Read register 'f'. Decode, Exclusive OR Wwith f = Process Data. Decode, Exclusive OR Wwith f = Process Data. Decode, Exclusive OR Wwith f = Write to destination. Example: Before, Exclusive OR Wwith f = XORWF Instruction AFh. Example: Before, Exclusive OR Wwith f = REG, 1,. Example: Before, Exclusive OR Wwith f = 0. Example: Before, Exclusive OR Wwith f = . W, Exclusive OR Wwith f = = B5h. W, Exclusive OR Wwith f = . W, Exclusive OR Wwith f = . W, Exclusive OR Wwith f = . After Instruction =, Exclusive OR Wwith f = After Instruction =. After Instruction =, Exclusive OR Wwith f = After Instruction =. After Instruction =, Exclusive OR Wwith f = After Instruction =. After Instruction =, Exclusive OR Wwith f = After Instruction =. REG, Exclusive OR Wwith f = 1Ah. REG, Exclusive OR Wwith f = . REG, Exclusive",
    "PIC18(L)F25/26K83\nOR Wwith f = . REG, Exclusive OR Wwith f = . W, Exclusive OR Wwith f = = B5h. W, Exclusive OR Wwith f = . W, Exclusive OR Wwith f = . W, Exclusive OR Wwith f = ",
    "42.2 Extended Instruction Set\nIn addition to the standard 75 instructions of the PIC18 instruction set, PIC18(L)F25/26K83 devices also provide an optional extension to the core CPU functionality. The added features include eight additional instructions that augment indirect and indexed addressing operations and the implementation of Indexed Literal Offset Addressing mode for many of the standard PIC18 instructions.\nThe additional features of the extended instruction set are disabled by default. To enable them, users must set the XINST Configuration bit.\nThe  instructions in the extended  set  can  all be classified as literal operations, which either manipulate the  File  Select  Registers,  or  use  them  for  indexed addressing.  Two  of  the  instructions, ADDFSR and SUBFSR , each have an additional special instantiation for using FSR2.  These versions ( ADDULNK and SUBULNK ) allow for automatic return after execution.\nThe extended instructions are specifically implemented to optimize re-entrant program code (that is, code that is  recursive  or  that  uses  a  software  stack)  written  in high-level languages,  particularly C.  Among  other things, they allow users working in high-level languages  to  perform  certain operations on  data structures more efficiently. These include:",
    "42.2 Extended Instruction Set\n\u00b7 dynamic allocation and deallocation of software stack space when entering and leaving subroutines\n\u00b7 function pointer invocation\n\u00b7 software Stack Pointer manipulation\n\u00b7 manipulation of variables located in a software stack\nA summary of the instructions in the extended instruc -tion set is provided in Table 42-3. Detailed descriptions are provided in Section 42.2.2 'Extended Instruction Set' . The opcode field descriptions in Table 42-1 apply to  both the  standard and extended PIC18 instruction sets.\nNote:\nThe  instruction  set  extension  and  the Indexed  Literal  Offset Addressing  mode were designed for optimizing applications written in C; the user may likely never use these  instructions  directly  in  assembler. The  syntax  for  these  commands  is  pro -vided as a reference for users who may be reviewing code that has been generated by a compiler.",
    "42.2.1 EXTENDED INSTRUCTION SYNTAX\nMost of the extended instructions use indexed arguments, using one of the File Select Registers and some offset to specify a source or destination register. When an argument for an instruction serves as part of indexed addressing, it is enclosed in square brackets ('[ ]'). This is done to indicate that the argument is used as an index or offset. MPASM\u2122 Assembler will flag an error if it determines that an index or offset value is not bracketed.\nWhen the extended instruction set is enabled, brackets are  also  used  to  indicate  index  arguments  in  byteoriented and bit-oriented instructions. This is in addition to other changes in their syntax. For more details, see Section 42.2.3.1 'Extended Instruction Syntax with Standard PIC18 Commands' .\nNote:\nIn  the  past,  square  brackets  have  been used to denote optional arguments in the PIC18 and earlier instruction sets. In this text and going forward, optional arguments are denoted by braces ('{ }').",
    "TABLE 42-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\nADDULNK, Mnemonic,. = k. ADDULNK, Description. = Add FSR2 with (k) & return. ADDULNK, Cycles. = 2. ADDULNK, 16-Bit Instruction Word.MSb = 1110. ADDULNK, 16-Bit Instruction Word. = 1000. ADDULNK, 16-Bit Instruction Word. = 11kk. ADDULNK, 16-Bit Instruction Word.LSb = kkkk. ADDULNK, Status Affected. = None. MOVSF, Mnemonic,. = z s , f d. MOVSF, Description. = Move z s (source) to 1st word f d (destination) 2nd word. MOVSF, Cycles. = 2 2. MOVSF, 16-Bit Instruction Word.MSb = 1110. MOVSF, 16-Bit Instruction Word. = 1011. MOVSF, 16-Bit Instruction Word. = 0zzz. MOVSF, 16-Bit Instruction Word.LSb = zzzz. MOVSF, Status Affected. = None. MOVSFL, Mnemonic,. = z s ,",
    "TABLE 42-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\nf d. MOVSFL, Description. = Opcode Move z s (source) to. MOVSFL, Cycles. = 3. MOVSFL, 16-Bit Instruction Word.MSb = 0000 1111. MOVSFL, 16-Bit Instruction Word. = 0000 xxxz. MOVSFL, 16-Bit Instruction Word. = 0000 zzzz. MOVSFL, 16-Bit Instruction Word.LSb = 0010 zzff. MOVSFL, Status Affected. = None. MOVSS, Mnemonic,. = z s , z d. MOVSS, Description. = f d (full destination) 3rd Move z s (source) to 1st z d (destination) 2nd. MOVSS, Cycles. = 2. MOVSS, 16-Bit Instruction Word.MSb = 1111 1110 1111. MOVSS, 16-Bit Instruction Word. = ffff 1011 xxxx. MOVSS, 16-Bit Instruction Word. = ffff 1zzz xzzz. MOVSS, 16-Bit Instruction Word.LSb = ffff zzzz zzzz.",
    "TABLE 42-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\nMOVSS, Status Affected. = None. PUSHL, Mnemonic,. = k. PUSHL, Description. = Push literal to POSTDEC2. PUSHL, Cycles. = 1. PUSHL, 16-Bit Instruction Word.MSb = 1110. PUSHL, 16-Bit Instruction Word. = 1010. PUSHL, 16-Bit Instruction Word. = kkkk. PUSHL, 16-Bit Instruction Word.LSb = kkkk. PUSHL, Status Affected. = None. SUBULNK, Mnemonic,. = k. SUBULNK, Description. = Subtract (k) from FSR2 & return. SUBULNK, Cycles. = 2. SUBULNK, 16-Bit Instruction Word.MSb = 1110. SUBULNK, 16-Bit Instruction Word. = 1001. SUBULNK, 16-Bit Instruction Word. = 11kk. SUBULNK, 16-Bit Instruction Word.LSb = kkkk. SUBULNK, Status Affected. = None",
    "TABLE 42-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\nNote 1: If Program Counter (PC) is modified or a conditional test is true, the instruction requires an additional cycle. The extra cycle is executed as a NOP .\n2: Some instructions are multi word instructions. The second/third words of these instructions will be decoded as a NOP , unless the first word of the instruction retrieves the information embedded in these 16-bits. This ensures that all program memory locations have a valid instruction.\n3: Only available when extended instruction set is enabled.\n4: f s and f d do not cover the full memory range. Two MSBs of bank selection are forced to 'b00 to limit the range of these instructions to lower 4k addressing space.",
    "ADDULNK Add Literal to FSR2 and Return\nSyntax:\nADDULNK   k\nOperands:\n0 \uf0a3 k \uf0a3 63\nOperation:\nFSR2 + k \uf0ae FSR2,\n(TOS) \uf0ae\uf020 PC\nStatus Affected: Encoding:\nNone\n1110\n1000\n11kk\nkkkk\nDescription:\nThe 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS.\nThe instruction takes two cycles to execute; a NOP is performed during the second cycle.\nThis may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary ' 11 '); it operates only on FSR2.\nWords:\n1\nCycles:\n2",
    "Q Cycle Activity:\nDecode, Q2 = Read literal 'k'. Decode, Q3 = Process Data. Decode, Q4 = Write to FSR. No Operation, Q2 = No Operation. No Operation, Q3 = No Operation. No Operation, Q4 = No Operation",
    "Example: ADDULNK 23h\nBefore Instruction\nFSR2\n=\n03FFh\nPC =\n0100h\nAfter Instruction\nFSR2\n=\n0422h\nPC\n= (TOS)\nNote:\nAll PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction syntax then becomes: {label} instruction argument(s).",
    "Example: ADDULNK 23h\nSyntax:, Move Indexed to f = MOVSF. Syntax:, Move Indexed to f = [z s ], f d. Syntax:, Move Indexed to f = . Syntax:, Move Indexed to f = . Operands:, Move Indexed to f = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 f d \uf0a3 4095. Operands:, Move Indexed to f = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 f d \uf0a3 4095. Operands:, Move Indexed to f = . Operands:, Move Indexed to f = . Operation:, Move Indexed to f = ((FSR2) + z s ) \uf0ae f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \uf0ae f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \uf0ae f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \uf0ae f d. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Encoding:, Move Indexed to f = . Encoding:, Move Indexed to",
    "Example: ADDULNK 23h\nf = . Encoding:, Move Indexed to f = . Encoding:, Move Indexed to f = . 1st word (source), Move Indexed to f = 1110. 1st word (source), Move Indexed to f = 1011. 1st word (source), Move Indexed to f = 0zzz. 1st word (source), Move Indexed to f = zzzz s. 2nd word (destin.), Move Indexed to f = 1111. 2nd word (destin.), Move Indexed to f = ffff. 2nd word (destin.), Move Indexed to f = ffff. 2nd word (destin.), Move Indexed to f = ffff d\nDescription:\nThe contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space (000h to FFFh).",
    "Example: ADDULNK 23h\nMOVSF has curtailed the destination range to the lower 4 Kbyte space in memory (Banks 1 through 15). For everything else, use MOVSFL .\n2\n2\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode, Determine source addr = No operation No dummy read. Decode, Determine source addr = No operation. Decode, Read source reg = Write register 'f' (dest)\nExample:\nMOVSF   [05h], REG2\nBefore Instruction\nFSR2\n=\n80h\nContents\nof 85h\n= 33h\nREG2\n= 11h\nAfter Instruction\nFSR2\n= 80h\nContents\nof 85h\n= 33h\nREG2\n=\n33h",
    "PIC18(L)F25/26K83\nSyntax:, Move Indexed to f (Long Range) = MOVSFL [z s ], f d. Syntax:, Move Indexed to f (Long Range) = MOVSFL [z s ], f d. Syntax:, Move Indexed to f (Long Range) = MOVSFL [z s ], f d. Syntax:, Move Indexed to f (Long Range) = MOVSFL [z s ], f d. Operands:, Move Indexed to f (Long Range) = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 f d \uf0a3 16383. Operands:, Move Indexed to f (Long Range) = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 f d \uf0a3 16383. Operands:, Move Indexed to f (Long Range) = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 f d \uf0a3 16383. Operands:, Move Indexed to f (Long Range) = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 f d \uf0a3 16383. Operation:, Move Indexed to f (Long Range) = ((FSR2) + z s ) \uf0ae f d. Operation:, Move Indexed to f (Long Range) = ((FSR2) + z s ) \uf0ae f d. Operation:, Move Indexed to f (Long",
    "PIC18(L)F25/26K83\nRange) = ((FSR2) + z s ) \uf0ae f d. Operation:, Move Indexed to f (Long Range) = ((FSR2) + z s ) \uf0ae f d. Status Affected:, Move Indexed to f (Long Range) = None. Status Affected:, Move Indexed to f (Long Range) = None. Status Affected:, Move Indexed to f (Long Range) = None. Status Affected:, Move Indexed to f (Long Range) = None. Encoding:, Move Indexed to f (Long Range) = . Encoding:, Move Indexed to f (Long Range) = . Encoding:, Move Indexed to f (Long Range) = . Encoding:, Move Indexed to f (Long Range) = . 1st word (opcode), Move Indexed to f (Long Range) = 0000. 1st word (opcode), Move Indexed to f (Long Range) = 0000. 1st word (opcode), Move Indexed to f (Long Range) = 0110. 1st word (opcode), Move Indexed to f (Long Range) = 0010. 2nd word (source), Move Indexed to f (Long Range) =",
    "PIC18(L)F25/26K83\n1111. 2nd word (source), Move Indexed to f (Long Range) = xxxz. 2nd word (source), Move Indexed to f (Long Range) = zzzz. 2nd word (source), Move Indexed to f (Long Range) = zz s ff. 3rd word (full destin.), Move Indexed to f (Long Range) = 1111. 3rd word (full destin.), Move Indexed to f (Long Range) = ffff. 3rd word (full destin.), Move Indexed to f (Long Range) = ffff. 3rd word (full destin.), Move Indexed to f (Long Range) = ffff d\nDescription:",
    "PIC18(L)F25/26K83\nThe contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2 (14 bits). The address of the destination register is specified by the 14-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 16 Kbyte data space (0000h to 3FFFh). The MOVSFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h.\nWords:\n3\nCycles:\n3\nQ Cycle Activity:",
    "PIC18(L)F25/26K83\nDecode, Q2 = No opera - tion. Decode, Q3 = No operation. Decode, Q4 = No operation. Decode, Q2 = Read register 'z' (src.). Decode, Q3 = Process data. Decode, Q4 = No operation. Decode, Q2 = No opera - tion No dummy read. Decode, Q3 = No operation. Decode, Q4 = Write register 'f' (dest.)\nExample:\nMOVSFL   [05h], REG2\nBefore Instruction\nFSR2\n= 80h\nContents of 85h =    33h\nREG2\n=\n11h\nAfter Instruction\nFSR2\n=\n80h\nContents of 85h =\n33h",
    "PIC18(L)F25/26K83\nMOVSS, 1 = MOVSS. MOVSS, 2 = Move Indexed to Indexed. MOVSS, 3 = Move Indexed to Indexed. MOVSS, 4 = Move Indexed to Indexed. MOVSS, 5 = Move Indexed to Indexed. Syntax:, 1 = Syntax:. Syntax:, 2 = MOVSS [z s ], [z d ]. Syntax:, 3 = MOVSS [z s ], [z d ]. Syntax:, 4 = MOVSS [z s ], [z d ]. Syntax:, 5 = MOVSS [z s ], [z d ]. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 z d \uf0a3 127. Operands:, 3 = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 z d \uf0a3 127. Operands:, 4 = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 z d \uf0a3 127. Operands:, 5 = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 z d \uf0a3 127. Operation:, 1 = Operation:. Operation:, 2 = ((FSR2) + z s ) \uf0ae ((FSR2) + z d ). Operation:, 3 =",
    "PIC18(L)F25/26K83\n((FSR2) + z s ) \uf0ae ((FSR2) + z d ). Operation:, 4 = ((FSR2) + z s ) \uf0ae ((FSR2) + z d ). Operation:, 5 = ((FSR2) + z s ) \uf0ae ((FSR2) + z d ). Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = . Encoding:, 3 = . Encoding:, 4 = . Encoding:, 5 = . 1st word (source), 1 = 1st word (source). 1st word (source), 2 = 1110 1111. 1st word (source), 3 = 1011 xxxx. 1st word (source), 4 = 1zzz xzzz. 1st word (source), 5 = zzzz s zzzz d. Description, 1 = Description. Description, 2 = The contents of the source register are moved to the destination register. The addresses",
    "PIC18(L)F25/26K83\nof the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h. If the resultant destination address points to. Description, 3 = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h. If the resultant destination address",
    "PIC18(L)F25/26K83\npoints to. Description, 4 = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h. If the resultant destination address points to. Description, 5 = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant",
    "PIC18(L)F25/26K83\nsource address points to an indirect addressing register, the value returned will be 00h. If the resultant destination address points to. , 1 = . , 2 = 2. , 3 = 2. , 4 = 2. , 5 = 2. , 1 = . , 2 = 2. , 3 = 2. , 4 = 2. , 5 = 2. Q Cycle Activity: Q1, 1 = . Q Cycle Activity: Q1, 2 = . Q Cycle Activity: Q1, 3 = . Q Cycle Activity: Q1, 4 = . Q Cycle Activity: Q1, 5 = . , 1 = addr Determine source addr Read source reg. , 2 = addr Determine source addr Read source reg. , 3 = addr Determine source addr Read source reg. , 4 = addr Determine source addr Read source reg. , 5 = addr Determine source addr Read source reg. , 1 = Determine source. , 2 = Determine source. , 3 = Determine source. , 4 = Determine source. , 5 = Determine source. , 1 = Determine Determine Write. , 2 = Determine Determine Write. , 3 = Determine Determine Write. , 4 = Determine Determine",
    "PIC18(L)F25/26K83\nWrite. , 5 = Determine Determine Write. Decode, 1 = . Decode, 2 = . Decode, 3 = . Decode, 4 = . Decode, 5 = . , 1 = dest addr dest addr to dest reg. , 2 = dest addr dest addr to dest reg. , 3 = dest addr dest addr to dest reg. , 4 = dest addr dest addr to dest reg. , 5 = dest addr dest addr to dest reg. Decode, 1 = Q2 Q3 Q4. Decode, 2 = Q2 Q3 Q4. Decode, 3 = Q2 Q3 Q4. Decode, 4 = Q2 Q3 Q4. Decode, 5 = Q2 Q3 Q4. an instruction Words: Cycles:, 1 = an instruction Words: Cycles:. an instruction Words: Cycles:, 2 = an instruction Words: Cycles:. an instruction Words: Cycles:, 3 = an instruction Words: Cycles:. an instruction Words: Cycles:, 4 = an instruction Words: Cycles:. an",
    "PIC18(L)F25/26K83\ninstruction Words: Cycles:, 5 = an instruction Words: Cycles:\nExample:\nMOVSS [05h], [06h]\nBefore Instruction\nFSR2\n=\n80h\nContents\nof 85h\n= 33h\nContents\nof 86h\n= 11h\nAfter Instruction\nFSR2\n= 80h\nContents\nof 85h\n= 33h\nContents\nof 86h\n=\n33h",
    "PUSHL\nStore Literal at FSR2, Decrement FSR2\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nPUSHL k\n0 \uf020\uf0a3\uf020 k \uf0a3 255\nk \uf0ae (FSR2),\nFSR2 - 1 \uf0ae FSR2\nNone\n1111\n1010\nkkkk kkkk\nThe 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software stack.\nWords:\nCycles:\nQ Cycle Activity:\n1\n1\nDecode, Q2 = Read 'k'. Decode, Q3 = Process data. Decode, Q4 = Write to destination\nExample:\nPUSHL 08h\nBefore Instruction FSR2H:FSR2L Memory (01ECh)\n=\n01ECh\n= 00h\nAfter Instruction\nFSR2H:FSR2L\n=\n01EBh\nMemory (01ECh)\n=\n08h",
    "SUBULNK Subtract Literal from FSR2 and Return\nSyntax:\nSUBULNK   k\nOperands:\n0 \uf0a3 k \uf0a3 63\nOperation:\nFSR2 - k \uf0ae FSR2\n(TOS) \uf0ae\uf020 PC\nStatus Affected:\nNone\nEncoding:\n1110\n1001\n11kk\nkkkk\nDescription:\nThe 6-bit literal 'k' is subtracted from the contents of the FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle.\nThis may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary ' 11 '); it operates only on FSR2.\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite to destination\nNo\nOperation\nNo\nOperation\nNo\nOperation\nNo\nOperation\nExample:\nSUBULNK 23h\nBefore Instruction\nFSR2\n=\n03FFh\nPC\n=\n0100h\nAfter Instruction\nFSR2\n=\n03DCh\nPC\n=\n(TOS)",
    "42.2.3 BYTE-ORIENTED AND BIT-ORIENTED INSTRUCTIONS IN INDEXED LITERAL OFFSET MODE\nNote:\nEnabling the PIC18 instruction set extension may cause legacy applications to behave erratically or fail entirely.\nIn addition to eight new commands in the extended set, enabling  the  extended  instruction  set  also  enables Indexed Literal Offset  Addressing mode  ( Section 4.8.1 'Indexed  Addressing  with  Literal  Offset' ). This  has  a  significant  impact  on  the  way  that  many commands of the standard PIC18 instruction set are interpreted.\nWhen the extended set is disabled, addresses embedded in opcodes  are  treated  as  literal  memory locations: either as a location in the Access Bank ('a' = 0 ), or in a GPR bank designated by the BSR ('a' = 1 ). When the extended instruction set is enabled and 'a' = 0 ,  however, a file register argument of 5Fh or less is interpreted as an offset from the pointer value in FSR2 and not as a literal address. For practical purposes, this means that all instructions that use the Access RAM bit as  an  argument  -  that  is,  all  byte-oriented  and  bitoriented instructions, or almost half of the core PIC18 instructions -may behave differently when the extended instruction set is enabled.",
    "42.2.3 BYTE-ORIENTED AND BIT-ORIENTED INSTRUCTIONS IN INDEXED LITERAL OFFSET MODE\nWhen the content of FSR2 is 00h, the boundaries of the Access RAM are essentially remapped to their original values.  This  may  be  useful  in  creating  backward compatible code. If this technique is used, it may be necessary  to  save  the  value  of  FSR2  and  restore  it when moving back and forth between C and assembly routines in order to preserve the Stack Pointer. Users must also keep in mind the syntax requirements of the extended instruction set (see Section 42.2.3.1 'Extended Instruction Syntax with Standard PIC18 Commands' ).\nAlthough the Indexed Literal Offset Addressing mode can  be  very  useful  for  dynamic  stack  and  pointer manipulation, it can also be very annoying if a simple arithmetic operation is carried out on  the wrong register.  Users  who  are  accustomed  to  the  PIC18 programming  must  keep  in  mind  that,  when  the extended instruction set is enabled, register addresses of  5Fh  or  less  are  used  for  Indexed  Literal  Offset Addressing.",
    "42.2.3 BYTE-ORIENTED AND BIT-ORIENTED INSTRUCTIONS IN INDEXED LITERAL OFFSET MODE\nRepresentative examples of typical byte-oriented and bit-oriented  instructions  in  the  Indexed  Literal  Offset Addressing mode are provided on the following page to show how execution is affected. The operand condi -tions  shown  in  the  examples  are  applicable  to  all instructions of these types.",
    "42.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nWhen the extended instruction set is enabled, the file register argument, 'f', in the standard byte-oriented and bit-oriented commands is replaced with the literal offset value, 'k'. As already noted, this occurs only when 'f' is less than or equal to 5Fh. When an offset value is used, it must be indicated by square brackets ('[ ]'). As with the extended instructions, the use of brackets indicates to the compiler that the value is to be interpreted as an index  or  an  offset.  Omitting  the  brackets,  or  using  a value greater than 5Fh within brackets, will generate an error in the MPASM assembler.\nIf the index argument is properly bracketed for Indexed Literal Offset Addressing, the Access RAM argument is never specified; it will automatically be assumed to be ' 0 '. This is in contrast to standard operation (extended instruction set disabled) when 'a' is set on the basis of the  target  address.  Declaring  the Access  RAM  bit  in this  mode will  also  generate  an  error  in  the  MPASM assembler.\nThe destination argument, 'd', functions as before.",
    "42.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nIn  the  latest  versions  of  the  MPASM\u2122  assembler, language support for the extended instruction set must be  explicitly  invoked.  This  is  done  with  either  the command line  option, /y ,  or  the  PE  directive  in  the source listing.",
    "42.2.4 CONSIDERATIONS WHEN ENABLING THE EXTENDED INSTRUCTION SET\nIt is important to note that the extensions to the instruc -tion set may not be beneficial to all users. In particular, users who are not writing code that uses a software stack may not benefit from using the extensions to the instruction set.\nAdditionally, the Indexed  Literal Offset  Addressing mode  may  create  issues  with  legacy  applications written to the  PIC18  assembler.  This  is  because instructions in the legacy code may attempt to address registers in the Access Bank below 5Fh. Since these addresses  are  interpreted  as  literal  offsets  to  FSR2 when  the  instruction  set  extension  is  enabled,  the application  may  read  or  write  to  the  wrong  data addresses.\nWhen  porting  an  application  to  the PIC18(L)F25/ 26K83, it is very important to consider the type of code. A large, re-entrant application that is written in 'C' and would  benefit  from  efficient  compilation  will  do  well when  using  the  instruction  set  extensions.  Legacy applications that heavily use the Access Bank will most likely  not  benefit  from  using  the  extended  instruction set.\nADDWF",
    "ADD W to Indexed (Indexed Literal Offset mode)\nSyntax:\nADDWF      [k] {,d}\nOperands:\n0 \uf0a3 k \uf0a3 95\nd \uf0ce [0,1]\nOperation:\n(W) + ((FSR2) + k) \uf0ae dest\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0010\n01d0\nkkkk\nkkkk\nDescription:\nThe contents of W are added to the contents of the register indicated by FSR2, offset by the value 'k'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead 'k'\nProcess\nData\nWrite to\ndestination",
    "Example:\nADDWF\n[OFST] , 0\nBefore Instruction\nW\n=\n17h\nOFST\n=\n2Ch\nFSR2\n=\n0A00h\nContents\nof 0A2Ch\n= 20h\nAfter Instruction\nW\n= 37h\nContents\nof 0A2Ch\n=\n20h",
    "PIC18(L)F25/26K83\nBit Set Indexed",
    "BSF\n(Indexed Literal Offset mode)\nSyntax:\nBSF   [k], b\nOperands:\n0 \uf0a3 f \uf0a3 95\n0 \uf0a3 b \uf0a3 7\nOperation:\n1 \uf0ae ((FSR2) + k)<b>\nStatus Affected:\nNone\nEncoding:\n1000\nbbb0\nkkkk\nkkkk\nDescription:\nBit 'b' of the register indicated by FSR2, offset by the value 'k', is set.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:",
    "Example:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. , Q2 = BSF. , Q3 = [FLAG_OFST],. , Q4 = 7. Before Instruction FLAG_OFST FSR2, Q2 = Before Instruction FLAG_OFST FSR2. Before Instruction FLAG_OFST FSR2, Q3 = 0Ah 0A00h. Before Instruction FLAG_OFST FSR2, Q4 = ",
    "Example:\nSyntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \uf0a3 k \uf0a3 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \uf0a3 k \uf0a3 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \uf0a3 k \uf0a3 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \uf0a3 k \uf0a3 95. Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \uf0ae ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \uf0ae ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \uf0ae ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \uf0ae ((FSR2) + k). Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Status",
    "Example:\nAffected:, Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Encoding:, Set Indexed (Indexed Literal Offset mode) = 0110. Encoding:, Set Indexed (Indexed Literal Offset mode) = 1000. Encoding:, Set Indexed (Indexed Literal Offset mode) = kkkk. Encoding:, Set Indexed (Indexed Literal Offset mode) = kkkk. Description:, Set Indexed (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, Set Indexed (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, Set Indexed (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, Set Indexed (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Words:, Set Indexed",
    "Example:\n(Indexed Literal Offset mode) = 1. Words:, Set Indexed (Indexed Literal Offset mode) = 1. Words:, Set Indexed (Indexed Literal Offset mode) = 1. Words:, Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Set Indexed (Indexed Literal Offset mode) = 1. Q Cycle Activity:, Set Indexed (Indexed Literal Offset mode) = Q Cycle Activity:. Q Cycle Activity:, Set Indexed (Indexed Literal Offset mode) = Q Cycle Activity:. Q Cycle Activity:, Set Indexed (Indexed Literal Offset mode) = Q Cycle Activity:. Q Cycle Activity:, Set Indexed (Indexed Literal Offset mode) = Q Cycle Activity:. Q1, Set Indexed (Indexed Literal Offset mode) = Q2. Q1, Set Indexed (Indexed Literal Offset mode) = Q3. Q1, Set Indexed (Indexed Literal Offset mode) = . Q1, Set Indexed (Indexed Literal Offset mode) = Q4. Decode, Set Indexed (Indexed Literal Offset mode) = Read",
    "Example:\n'k'. Decode, Set Indexed (Indexed Literal Offset mode) = Process Data. Decode, Set Indexed (Indexed Literal Offset mode) = . Decode, Set Indexed (Indexed Literal Offset mode) = Write register\nBefore Instruction, SETF = . Before Instruction, [OFST] = . OFST, SETF = =. OFST, [OFST] = 2Ch. FSR2, SETF = =. FSR2, [OFST] = 0A00h. Contents of 0A2Ch, SETF = =. Contents of 0A2Ch, [OFST] = 00h. After Instruction Contents of 0A2Ch, SETF = =. After Instruction Contents of 0A2Ch, [OFST] = FFh",
    "42.2.5 SPECIAL CONSIDERATIONS WITH MICROCHIP MPLAB \u00ae  IDE TOOLS\nThe latest versions of Microchip's software tools have been designed to fully support the extended instruction set of the PIC18(L)F25/26K83 family of devices. This includes the MPLAB C18 C compiler, MPASM assembly language and MPLAB Integrated Development Environment (IDE).\nWhen selecting a target device for software development, MPLAB IDE will automatically set default Configuration bits for that device. The default setting for the XINST  Configuration bit is ' 0 ', disabling the extended  instruction  set  and  Indexed  Literal  Offset Addressing mode. For proper execution of applications developed to take advantage of the extended instruction set, XINST must be set during programming.\nTo develop software for the extended instruction set, the user must enable support for the instructions and the Indexed Addressing mode in their language tool(s). Depending on the environment being used, this may be done in several ways:\n\u00b7 A menu option, or dialog box within the environment, that allows the user to configure the language tool and its settings for the project\n\u00b7 A command line option\n\u00b7 A directive in the source code",
    "42.2.5 SPECIAL CONSIDERATIONS WITH MICROCHIP MPLAB \u00ae  IDE TOOLS\nThese options vary between different compilers, assemblers and development environments. Users are encouraged to review the documentation accompanying their development systems for the appropriate information.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n3FFFh, Name = TOSU. 3FFFh, Bit 7 = -. 3FFFh, Bit 6 = -. 3FFFh, Bit 5 = -. 3FFFh, Bit 4 = Top-of-Stack Upper byte. 3FFFh, Bit 3 = Top-of-Stack Upper byte. 3FFFh, Bit 2 = Top-of-Stack Upper byte. 3FFFh, Bit 1 = Top-of-Stack Upper byte. 3FFFh, Bit 0 = Top-of-Stack Upper byte. 3FFFh, Register on page = 28. 3FFEh, Name = TOSH. 3FFEh, Bit 7 = Top-of-Stack High byte. 3FFEh, Bit 6 = Top-of-Stack High byte. 3FFEh, Bit 5 = Top-of-Stack High byte. 3FFEh, Bit 4 = Top-of-Stack High byte. 3FFEh, Bit 3 = Top-of-Stack High byte. 3FFEh, Bit 2 = Top-of-Stack High byte. 3FFEh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nBit 1 = Top-of-Stack High byte. 3FFEh, Bit 0 = Top-of-Stack High byte. 3FFEh, Register on page = 28. 3FFDh, Name = TOSL. 3FFDh, Bit 7 = Top-of-Stack Low byte. 3FFDh, Bit 6 = Top-of-Stack Low byte. 3FFDh, Bit 5 = Top-of-Stack Low byte. 3FFDh, Bit 4 = Top-of-Stack Low byte. 3FFDh, Bit 3 = Top-of-Stack Low byte. 3FFDh, Bit 2 = Top-of-Stack Low byte. 3FFDh, Bit 1 = Top-of-Stack Low byte. 3FFDh, Bit 0 = Top-of-Stack Low byte. 3FFDh, Register on page = 28. 3FFCh, Name = STKPTR. 3FFCh, Bit 7 = -. 3FFCh, Bit 6 = -. 3FFCh, Bit 5 = -. 3FFCh, Bit 4 = Stack Pointer. 3FFCh, Bit 3 = Stack Pointer.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n3FFCh, Bit 2 = Stack Pointer. 3FFCh, Bit 1 = Stack Pointer. 3FFCh, Bit 0 = Stack Pointer. 3FFCh, Register on page = 29. 3FFBh, Name = PCLATU. 3FFBh, Bit 7 = -. 3FFBh, Bit 6 = -. 3FFBh, Bit 5 = -. 3FFBh, Bit 4 = Holding Register for PC Upper byte. 3FFBh, Bit 3 = Holding Register for PC Upper byte. 3FFBh, Bit 2 = Holding Register for PC Upper byte. 3FFBh, Bit 1 = Holding Register for PC Upper byte. 3FFBh, Bit 0 = Holding Register for PC Upper byte. 3FFBh, Register on page = 29. 3FFAh, Name = PCLATH. 3FFAh, Bit 7 = Register for PC High byte. 3FFAh, Bit 6 = Register for PC High byte. 3FFAh, Bit 5 = Register for PC High byte. 3FFAh, Bit 4 = Register for PC High byte. 3FFAh, Bit 3 = Register for PC High byte.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n3FFAh, Bit 2 = Register for PC High byte. 3FFAh, Bit 1 = Register for PC High byte. 3FFAh, Bit 0 = Register for PC High byte. 3FFAh, Register on page = 29. 3FF9h, Name = PCL. 3FF9h, Bit 7 = PC Low byte. 3FF9h, Bit 6 = PC Low byte. 3FF9h, Bit 5 = PC Low byte. 3FF9h, Bit 4 = PC Low byte. 3FF9h, Bit 3 = PC Low byte. 3FF9h, Bit 2 = PC Low byte. 3FF9h, Bit 1 = PC Low byte. 3FF9h, Bit 0 = PC Low byte. 3FF9h, Register on page = 29. 3FF8h, Name = TBLPTRU. 3FF8h, Bit 7 = -. 3FF8h, Bit 6 = -. 3FF8h, Bit 5 = Program. 3FF8h, Bit 4 = Memory Table Pointer Upper byte. 3FF8h, Bit 3 = Memory Table Pointer Upper",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nbyte. 3FF8h, Bit 2 = Memory Table Pointer Upper byte. 3FF8h, Bit 1 = Memory Table Pointer Upper byte. 3FF8h, Bit 0 = Memory Table Pointer Upper byte. 3FF8h, Register on page = 29. 3FF7h, Name = TBLPTRH. 3FF7h, Bit 7 = Program Memory Table Pointer High byte. 3FF7h, Bit 6 = Program Memory Table Pointer High byte. 3FF7h, Bit 5 = Program Memory Table Pointer High byte. 3FF7h, Bit 4 = Program Memory Table Pointer High byte. 3FF7h, Bit 3 = Program Memory Table Pointer High byte. 3FF7h, Bit 2 = Program Memory Table Pointer High byte. 3FF7h, Bit 1 = Program Memory Table Pointer High byte. 3FF7h, Bit 0 = Program Memory Table Pointer High byte. 3FF7h, Register on page = 182. 3FF6h, Name = TBLPTRL. 3FF6h, Bit 7 = Program Memory Table Pointer Low byte. 3FF6h, Bit 6 = Program",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nMemory Table Pointer Low byte. 3FF6h, Bit 5 = Program Memory Table Pointer Low byte. 3FF6h, Bit 4 = Program Memory Table Pointer Low byte. 3FF6h, Bit 3 = Program Memory Table Pointer Low byte. 3FF6h, Bit 2 = Program Memory Table Pointer Low byte. 3FF6h, Bit 1 = Program Memory Table Pointer Low byte. 3FF6h, Bit 0 = Program Memory Table Pointer Low byte. 3FF6h, Register on page = 182. 3FF5h, Name = TABLAT. 3FF5h, Bit 7 = Table Latch. 3FF5h, Bit 6 = Table Latch. 3FF5h, Bit 5 = Table Latch. 3FF5h, Bit 4 = Table Latch. 3FF5h, Bit 3 = Table Latch. 3FF5h, Bit 2 = Table Latch. 3FF5h, Bit 1 = Table Latch. 3FF5h, Bit 0 = Table Latch. 3FF5h, Register on page = 182. 3FF4h, Name = PRODH. 3FF4h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nProduct Register High byte. 3FF4h, Bit 6 = Product Register High byte. 3FF4h, Bit 5 = Product Register High byte. 3FF4h, Bit 4 = Product Register High byte. 3FF4h, Bit 3 = Product Register High byte. 3FF4h, Bit 2 = Product Register High byte. 3FF4h, Bit 1 = Product Register High byte. 3FF4h, Bit 0 = Product Register High byte. 3FF4h, Register on page = 177. 3FF3h, Name = PRODL. 3FF3h, Bit 7 = Product Register Low byte. 3FF3h, Bit 6 = Product Register Low byte. 3FF3h, Bit 5 = Product Register Low byte. 3FF3h, Bit 4 = Product Register Low byte. 3FF3h, Bit 3 = Product Register Low byte. 3FF3h, Bit 2 = Product Register Low byte. 3FF3h, Bit 1 = Product Register Low byte. 3FF3h, Bit 0 = Product Register Low byte. 3FF3h, Register on page = 177.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n3FF2h, Name = -. 3FF2h, Bit 7 = Unimplemented. 3FF2h, Bit 6 = Unimplemented. 3FF2h, Bit 5 = Unimplemented. 3FF2h, Bit 4 = Unimplemented. 3FF2h, Bit 3 = Unimplemented. 3FF2h, Bit 2 = Unimplemented. 3FF2h, Bit 1 = Unimplemented. 3FF2h, Bit 0 = Unimplemented. 3FF2h, Register on page = -. 3FF1h, Name = PCON1. 3FF1h, Bit 7 = -. 3FF1h, Bit 6 = -. 3FF1h, Bit 5 = -. 3FF1h, Bit 4 = -. 3FF1h, Bit 3 = -. 3FF1h, Bit 2 = -. 3FF1h, Bit 1 = MEMV. 3FF1h, Bit 0 = -. 3FF1h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n81. 3FF0h, Name = PCON0. 3FF0h, Bit 7 = STKOVF. 3FF0h, Bit 6 = STKUNF. 3FF0h, Bit 5 = WDTWV. 3FF0h, Bit 4 = RWDT. 3FF0h, Bit 3 = RMCLR. 3FF0h, Bit 2 = RI. 3FF0h, Bit 1 = POR. 3FF0h, Bit 0 = BOR. 3FF0h, Register on page = 80. 3FEFh, Name = INDF0. 3FEFh, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 not changed. 3FEFh, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 not changed. 3FEFh, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 not changed. 3FEFh, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 not",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nchanged. 3FEFh, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 not changed. 3FEFh, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 not changed. 3FEFh, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 not changed. 3FEFh, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 not changed. 3FEFh, Register on page = 50. 3FEEh, Name = POSTINC0. 3FEEh, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. 3FEEh, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. 3FEEh, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. 3FEEh, Bit 4 = Uses contents of FSR0 to address",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\ndata memory - value of FSR0 post-incremented. 3FEEh, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. 3FEEh, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. 3FEEh, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. 3FEEh, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. 3FEEh, Register on page = 51. 3FEDh, Name = POSTDEC0. 3FEDh, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented. 3FEDh, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented. 3FEDh, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\npost-decremented. 3FEDh, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented. 3FEDh, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented. 3FEDh, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented. 3FEDh, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented. 3FEDh, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented. 3FEDh, Register on page = 51. 3FECh, Name = PREINC0. 3FECh, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented. 3FECh, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented. 3FECh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nBit 5 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented. 3FECh, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented. 3FECh, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented. 3FECh, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented. 3FECh, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented. 3FECh, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented. 3FECh, Register on page = 51. 3FEBh, Name = PLUSW0. 3FEBh, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented - value of FSR0 offset by W. 3FEBh, Bit 6",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n= Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented - value of FSR0 offset by W. 3FEBh, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented - value of FSR0 offset by W. 3FEBh, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented - value of FSR0 offset by W. 3FEBh, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented - value of FSR0 offset by W. 3FEBh, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented - value of FSR0 offset by W. 3FEBh, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented - value of FSR0 offset by W. 3FEBh, Bit 0 = Uses contents of",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nFSR0 to address data memory - value of FSR0 pre-incremented - value of FSR0 offset by W. 3FEBh, Register on page = 51. 3FEAh, Name = FSR0H. 3FEAh, Bit 7 = -. 3FEAh, Bit 6 = -. 3FEAh, Bit 5 = Indirect Data Memory Address Pointer 0 High. 3FEAh, Bit 4 = Indirect Data Memory Address Pointer 0 High. 3FEAh, Bit 3 = Indirect Data Memory Address Pointer 0 High. 3FEAh, Bit 2 = Indirect Data Memory Address Pointer 0 High. 3FEAh, Bit 1 = Indirect Data Memory Address Pointer 0 High. 3FEAh, Bit 0 = Indirect Data Memory Address Pointer 0 High. 3FEAh, Register on page = 51. 3FE9h, Name = FSR0L. 3FE9h, Bit 7 = Indirect Data Memory Address Pointer 0 Low. 3FE9h, Bit 6 = Indirect Data Memory Address Pointer 0 Low. 3FE9h, Bit 5 = Indirect Data Memory Address Pointer 0 Low. 3FE9h, Bit 4",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n= Indirect Data Memory Address Pointer 0 Low. 3FE9h, Bit 3 = Indirect Data Memory Address Pointer 0 Low. 3FE9h, Bit 2 = Indirect Data Memory Address Pointer 0 Low. 3FE9h, Bit 1 = Indirect Data Memory Address Pointer 0 Low. 3FE9h, Bit 0 = Indirect Data Memory Address Pointer 0 Low. 3FE9h, Register on page = 51. 3FE8h, Name = WREG. 3FE8h, Bit 7 = . 3FE8h, Bit 6 = . 3FE8h, Bit 5 = . 3FE8h, Bit 4 = Working. 3FE8h, Bit 3 = Register. 3FE8h, Bit 2 = . 3FE8h, Bit 1 = . 3FE8h, Bit 0 = . 3FE8h, Register on page = -. 3FE7h, Name = INDF1. 3FE7h, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 not changed. 3FE7h, Bit 6 = Uses contents of FSR1 to address data",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nmemory - value of FSR1 not changed. 3FE7h, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 not changed. 3FE7h, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 not changed. 3FE7h, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 not changed. 3FE7h, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 not changed. 3FE7h, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 not changed. 3FE7h, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 not changed. 3FE7h, Register on page = 51. 3FE6h, Name = POSTINC1. 3FE6h, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented. 3FE6h, Bit 6 = Uses",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\ncontents of FSR1 to address data memory - value of FSR1 post-incremented. 3FE6h, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented. 3FE6h, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented. 3FE6h, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented. 3FE6h, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented. 3FE6h, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented. 3FE6h, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented. 3FE6h, Register on page = 51. 3FE5h, Name = POSTDEC1. 3FE5h, Bit 7 = Uses contents",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nof FSR1 to address data memory - value of FSR1 post-decremented. 3FE5h, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented. 3FE5h, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented. 3FE5h, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented. 3FE5h, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented. 3FE5h, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented. 3FE5h, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented. 3FE5h, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n3FE5h, Register on page = 51. 3FE4h, Name = PREINC1. 3FE4h, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented. 3FE4h, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented. 3FE4h, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented. 3FE4h, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented. 3FE4h, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented. 3FE4h, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented. 3FE4h, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n3FE4h, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented. 3FE4h, Register on page = 51. 3FE3h, Name = PLUSW1. 3FE3h, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented - value of FSR1 offset by W. 3FE3h, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented - value of FSR1 offset by W. 3FE3h, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented - value of FSR1 offset by W. 3FE3h, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented - value of FSR1 offset by W. 3FE3h, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\npre-incremented - value of FSR1 offset by W. 3FE3h, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented - value of FSR1 offset by W. 3FE3h, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented - value of FSR1 offset by W. 3FE3h, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented - value of FSR1 offset by W. 3FE3h, Register on page = 51. 3FE2h, Name = FSR1H. 3FE2h, Bit 7 = -. 3FE2h, Bit 6 = -. 3FE2h, Bit 5 = Indirect Data Memory Address Pointer 1 High. 3FE2h, Bit 4 = Indirect Data Memory Address Pointer 1 High. 3FE2h, Bit 3 = Indirect Data Memory Address Pointer 1 High. 3FE2h, Bit 2 = Indirect Data Memory",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nAddress Pointer 1 High. 3FE2h, Bit 1 = Indirect Data Memory Address Pointer 1 High. 3FE2h, Bit 0 = Indirect Data Memory Address Pointer 1 High. 3FE2h, Register on page = 51. 3FE1h, Name = FSR1L. 3FE1h, Bit 7 = Indirect Data Memory Address Pointer 1 Low. 3FE1h, Bit 6 = Indirect Data Memory Address Pointer 1 Low. 3FE1h, Bit 5 = Indirect Data Memory Address Pointer 1 Low. 3FE1h, Bit 4 = Indirect Data Memory Address Pointer 1 Low. 3FE1h, Bit 3 = Indirect Data Memory Address Pointer 1 Low. 3FE1h, Bit 2 = Indirect Data Memory Address Pointer 1 Low. 3FE1h, Bit 1 = Indirect Data Memory Address Pointer 1 Low. 3FE1h, Bit 0 = Indirect Data Memory Address Pointer 1 Low. 3FE1h, Register on page = 51. 3FE0h, Name = BSR. 3FE0h, Bit 7 = -. 3FE0h, Bit 6 = -. 3FE0h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nBit 5 = Bank Select Register. 3FE0h, Bit 4 = Bank Select Register. 3FE0h, Bit 3 = Bank Select Register. 3FE0h, Bit 2 = Bank Select Register. 3FE0h, Bit 1 = Bank Select Register. 3FE0h, Bit 0 = Bank Select Register. 3FE0h, Register on page = 34. 3FDFh, Name = INDF2. 3FDFh, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 not changed. 3FDFh, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 not changed. 3FDFh, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 not changed. 3FDFh, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 not changed. 3FDFh, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 not changed. 3FDFh, Bit 2 = Uses contents",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nof FSR2 to address data memory - value of FSR2 not changed. 3FDFh, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 not changed. 3FDFh, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 not changed. 3FDFh, Register on page = 51. 3FDEh, Name = POSTINC2. 3FDEh, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented. 3FDEh, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented. 3FDEh, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented. 3FDEh, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented. 3FDEh, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\npost-incremented. 3FDEh, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented. 3FDEh, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented. 3FDEh, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented. 3FDEh, Register on page = 51. 3FDDh, Name = POSTDEC2. 3FDDh, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented. 3FDDh, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented. 3FDDh, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented. 3FDDh, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\npost-decremented. 3FDDh, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented. 3FDDh, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented. 3FDDh, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented. 3FDDh, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented. 3FDDh, Register on page = 51. 3FDCh, Name = PREINC2. 3FDCh, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. 3FDCh, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. 3FDCh, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\npre-incremented. 3FDCh, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. 3FDCh, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. 3FDCh, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. 3FDCh, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. 3FDCh, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. 3FDCh, Register on page = 51. 3FDBh, Name = PLUSW2. 3FDBh, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented - value of FSR2 offset by W. 3FDBh, Bit 6 = Uses contents of FSR2 to address data",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nmemory - value of FSR2 pre-incremented - value of FSR2 offset by W. 3FDBh, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented - value of FSR2 offset by W. 3FDBh, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented - value of FSR2 offset by W. 3FDBh, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented - value of FSR2 offset by W. 3FDBh, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented - value of FSR2 offset by W. 3FDBh, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented - value of FSR2 offset by W. 3FDBh, Bit 0 = Uses contents of FSR2 to address data",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\nmemory - value of FSR2 pre-incremented - value of FSR2 offset by W. 3FDBh, Register on page = 51. 3FDAh, Name = FSR2H. 3FDAh, Bit 7 = -. 3FDAh, Bit 6 = -. 3FDAh, Bit 5 = Indirect Data Memory Address Pointer 2 High. 3FDAh, Bit 4 = Indirect Data Memory Address Pointer 2 High. 3FDAh, Bit 3 = Indirect Data Memory Address Pointer 2 High. 3FDAh, Bit 2 = Indirect Data Memory Address Pointer 2 High. 3FDAh, Bit 1 = Indirect Data Memory Address Pointer 2 High. 3FDAh, Bit 0 = Indirect Data Memory Address Pointer 2 High. 3FDAh, Register on page = 51. 3FD9h, Name = FSR2L. 3FD9h, Bit 7 = Indirect Data Memory Address Pointer 2 Low. 3FD9h, Bit 6 = Indirect Data Memory Address Pointer 2 Low. 3FD9h, Bit 5 = Indirect Data Memory Address Pointer 2 Low. 3FD9h, Bit 4",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n= Indirect Data Memory Address Pointer 2 Low. 3FD9h, Bit 3 = Indirect Data Memory Address Pointer 2 Low. 3FD9h, Bit 2 = Indirect Data Memory Address Pointer 2 Low. 3FD9h, Bit 1 = Indirect Data Memory Address Pointer 2 Low. 3FD9h, Bit 0 = Indirect Data Memory Address Pointer 2 Low. 3FD9h, Register on page = 51. 3FD8h, Name = STATUS. 3FD8h, Bit 7 = -. 3FD8h, Bit 6 = TO. 3FD8h, Bit 5 = PD. 3FD8h, Bit 4 = N. 3FD8h, Bit 3 = OV. 3FD8h, Bit 2 = Z. 3FD8h, Bit 1 = DC. 3FD8h, Bit 0 = C. 3FD8h, Register on page = 48. 3FD7h, Name = IVTBASEU. 3FD7h, Bit 7 = -. 3FD7h, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n-. 3FD7h, Bit 5 = -. 3FD7h, Bit 4 = BASE20. 3FD7h, Bit 3 = BASE19. 3FD7h, Bit 2 = BASE18. 3FD7h, Bit 1 = BASE17. 3FD7h, Bit 0 = BASE16. 3FD7h, Register on page = 157. 3FD6h, Name = IVTBASEH. 3FD6h, Bit 7 = BASE15. 3FD6h, Bit 6 = BASE14. 3FD6h, Bit 5 = BASE13. 3FD6h, Bit 4 = BASE12. 3FD6h, Bit 3 = BASE11. 3FD6h, Bit 2 = BASE10. 3FD6h, Bit 1 = BASE9. 3FD6h, Bit 0 = BASE8. 3FD6h, Register on page = 157. 3FD5h, Name = IVTBASEL. 3FD5h, Bit 7 = BASE7.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n3FD5h, Bit 6 = BASE6. 3FD5h, Bit 5 = BASE5. 3FD5h, Bit 4 = BASE4. 3FD5h, Bit 3 = BASE3. 3FD5h, Bit 2 = BASE2. 3FD5h, Bit 1 = BASE1. 3FD5h, Bit 0 = BASE0. 3FD5h, Register on page = 157. 3FD4h 3FD3h, Name = IVTLOCK INTCON1. 3FD4h 3FD3h, Bit 7 = - - STAT. 3FD4h 3FD3h, Bit 6 = - - STAT. 3FD4h 3FD3h, Bit 5 = - -. 3FD4h 3FD3h, Bit 4 = - -. 3FD4h 3FD3h, Bit 3 = - -. 3FD4h 3FD3h, Bit 2 = - -. 3FD4h 3FD3h, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n- -. 3FD4h 3FD3h, Bit 0 = IVTLOCKED -. 3FD4h 3FD3h, Register on page = 159 126. 3FD2h, Name = INTCON0. 3FD2h, Bit 7 = GIE. 3FD2h, Bit 6 = GIEL. 3FD2h, Bit 5 = IPEN. 3FD2h, Bit 4 = -. 3FD2h, Bit 3 = -. 3FD2h, Bit 2 = INT2EDG. 3FD2h, Bit 1 = INT1EDG. 3FD2h, Bit 0 = INT0EDG. 3FD2h, Register on page = 125. 3FD1h- 3FD0h, Name = -. 3FD1h- 3FD0h, Bit 7 = Unimplemented. 3FD1h- 3FD0h, Bit 6 = Unimplemented. 3FD1h-",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES\n3FD0h, Bit 5 = Unimplemented. 3FD1h- 3FD0h, Bit 4 = Unimplemented. 3FD1h- 3FD0h, Bit 3 = Unimplemented. 3FD1h- 3FD0h, Bit 2 = Unimplemented. 3FD1h- 3FD0h, Bit 1 = Unimplemented. 3FD1h- 3FD0h, Bit 0 = Unimplemented. 3FD1h- 3FD0h, Register on page = -\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition Note 1: Not present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3FCEh, Name = PORTE. 3FCEh, Bit 7 = -. 3FCEh, Bit 6 = -. 3FCEh, Bit 5 = -. 3FCEh, Bit 4 = -. 3FCEh, Bit 3 = RE3. 3FCEh, Bit 2 = -. 3FCEh, Bit 1 = -. 3FCEh, Bit 0 = -. 3FCEh, Register on page = 253. 3FCDh, Name = - Unimplemented. 3FCDh, Bit 7 = - Unimplemented. 3FCDh, Bit 6 = - Unimplemented. 3FCDh, Bit 5 = - Unimplemented. 3FCDh, Bit 4 = - Unimplemented. 3FCDh, Bit 3 = - Unimplemented. 3FCDh, Bit 2 = - Unimplemented. 3FCDh, Bit 1 = - Unimplemented. 3FCDh, Bit 0 = - Unimplemented. 3FCDh, Register on page = -. 3FCCh, Name",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= PORTC. 3FCCh, Bit 7 = RC7. 3FCCh, Bit 6 = RC6. 3FCCh, Bit 5 = RC5. 3FCCh, Bit 4 = RC4. 3FCCh, Bit 3 = RC3. 3FCCh, Bit 2 = RC2. 3FCCh, Bit 1 = RC1. 3FCCh, Bit 0 = RC0. 3FCCh, Register on page = 253. 3FCBh, Name = PORTB. 3FCBh, Bit 7 = RB7. 3FCBh, Bit 6 = RB6. 3FCBh, Bit 5 = RB5. 3FCBh, Bit 4 = RB4. 3FCBh, Bit 3 = RB3. 3FCBh, Bit 2 = RB2. 3FCBh, Bit 1 = RB1. 3FCBh, Bit 0 = RB0. 3FCBh, Register on page = 253. 3FCAh, Name = PORTA. 3FCAh, Bit 7 = RA7. 3FCAh, Bit 6 = RA6. 3FCAh, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRA5. 3FCAh, Bit 4 = RA4. 3FCAh, Bit 3 = RA3. 3FCAh, Bit 2 = RA2. 3FCAh, Bit 1 = RA1. 3FCAh, Bit 0 = RA0. 3FCAh, Register on page = 253. 3FC9h- 3FC5h, Name = - Unimplemented. 3FC9h- 3FC5h, Bit 7 = - Unimplemented. 3FC9h- 3FC5h, Bit 6 = - Unimplemented. 3FC9h- 3FC5h, Bit 5 = - Unimplemented. 3FC9h- 3FC5h, Bit 4 = - Unimplemented. 3FC9h- 3FC5h, Bit 3 = - Unimplemented. 3FC9h- 3FC5h, Bit 2 = - Unimplemented. 3FC9h- 3FC5h, Bit 1 = - Unimplemented. 3FC9h-",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3FC5h, Bit 0 = - Unimplemented. 3FC9h- 3FC5h, Register on page = -. 3FC4h, Name = TRISC. 3FC4h, Bit 7 = TRISC7. 3FC4h, Bit 6 = TRISC6. 3FC4h, Bit 5 = TRISC5. 3FC4h, Bit 4 = TRISC4. 3FC4h, Bit 3 = TRISC3. 3FC4h, Bit 2 = TRISC2. 3FC4h, Bit 1 = TRISC1. 3FC4h, Bit 0 = TRISC0. 3FC4h, Register on page = 254. 3FC3h, Name = TRISB. 3FC3h, Bit 7 = TRISB7. 3FC3h, Bit 6 = TRISB6. 3FC3h, Bit 5 = TRISB5. 3FC3h, Bit 4 = TRISB4. 3FC3h, Bit 3 = TRISB3. 3FC3h, Bit 2 = TRISB2.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3FC3h, Bit 1 = TRISB1. 3FC3h, Bit 0 = TRISB0. 3FC3h, Register on page = 254. 3FC2h, Name = TRISA. 3FC2h, Bit 7 = TRISA7. 3FC2h, Bit 6 = TRISA6. 3FC2h, Bit 5 = TRISA5. 3FC2h, Bit 4 = TRISA4. 3FC2h, Bit 3 = TRISA3. 3FC2h, Bit 2 = TRISA2. 3FC2h, Bit 1 = TRISA1. 3FC2h, Bit 0 = TRISA0. 3FC2h, Register on page = 254. 3FC1h- 3FBDh, Name = - Unimplemented. 3FC1h- 3FBDh, Bit 7 = - Unimplemented. 3FC1h- 3FBDh, Bit 6 = - Unimplemented. 3FC1h- 3FBDh, Bit 5 = - Unimplemented.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3FC1h- 3FBDh, Bit 4 = - Unimplemented. 3FC1h- 3FBDh, Bit 3 = - Unimplemented. 3FC1h- 3FBDh, Bit 2 = - Unimplemented. 3FC1h- 3FBDh, Bit 1 = - Unimplemented. 3FC1h- 3FBDh, Bit 0 = - Unimplemented. 3FC1h- 3FBDh, Register on page = -. 3FBCh, Name = LATC. 3FBCh, Bit 7 = LATC7. 3FBCh, Bit 6 = LATC6. 3FBCh, Bit 5 = LATC5. 3FBCh, Bit 4 = LATC4. 3FBCh, Bit 3 = LATC3. 3FBCh, Bit 2 = LATC2. 3FBCh, Bit 1 = LATC1. 3FBCh, Bit 0 = LATC0. 3FBCh, Register on page = 255. 3FBBh, Name = LATB. 3FBBh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 7 = LATB7. 3FBBh, Bit 6 = LATB6. 3FBBh, Bit 5 = LATB5. 3FBBh, Bit 4 = LATB4. 3FBBh, Bit 3 = LATB3. 3FBBh, Bit 2 = LATB2. 3FBBh, Bit 1 = LATB1. 3FBBh, Bit 0 = LATB0. 3FBBh, Register on page = 255. 3FBAh, Name = LATA. 3FBAh, Bit 7 = LATA7. 3FBAh, Bit 6 = LATA6. 3FBAh, Bit 5 = LATA5. 3FBAh, Bit 4 = LATA4. 3FBAh, Bit 3 = LATA3. 3FBAh, Bit 2 = LATA2. 3FBAh, Bit 1 = LATA1. 3FBAh, Bit 0 = LATA0. 3FBAh, Register on page = 255. 3FB9h, Name = T0CON1 CS<2:0> ASYNC",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCKPS<3:0>. 3FB9h, Bit 7 = T0CON1 CS<2:0> ASYNC CKPS<3:0>. 3FB9h, Bit 6 = T0CON1 CS<2:0> ASYNC CKPS<3:0>. 3FB9h, Bit 5 = T0CON1 CS<2:0> ASYNC CKPS<3:0>. 3FB9h, Bit 4 = T0CON1 CS<2:0> ASYNC CKPS<3:0>. 3FB9h, Bit 3 = T0CON1 CS<2:0> ASYNC CKPS<3:0>. 3FB9h, Bit 2 = T0CON1 CS<2:0> ASYNC CKPS<3:0>. 3FB9h, Bit 1 = T0CON1 CS<2:0> ASYNC CKPS<3:0>. 3FB9h, Bit 0 = T0CON1 CS<2:0>",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nASYNC CKPS<3:0>. 3FB9h, Register on page = 288. 3FB8h, Name = T0CON0. 3FB8h, Bit 7 = EN. 3FB8h, Bit 6 = -. 3FB8h, Bit 5 = OUT. 3FB8h, Bit 4 = MD16. 3FB8h, Bit 3 = . 3FB8h, Bit 2 = OUTPS. 3FB8h, Bit 1 = OUTPS. 3FB8h, Bit 0 = OUTPS. 3FB8h, Register on page = 287. 3FB7h, Name = TMR0H TMR0H. 3FB7h, Bit 7 = TMR0H TMR0H. 3FB7h, Bit 6 = TMR0H TMR0H. 3FB7h, Bit 5 = TMR0H TMR0H. 3FB7h, Bit 4 = TMR0H TMR0H. 3FB7h, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nTMR0H TMR0H. 3FB7h, Bit 2 = TMR0H TMR0H. 3FB7h, Bit 1 = TMR0H TMR0H. 3FB7h, Bit 0 = TMR0H TMR0H. 3FB7h, Register on page = 289. 3FB6h, Name = TMR0L TMR0L. 3FB6h, Bit 7 = TMR0L TMR0L. 3FB6h, Bit 6 = TMR0L TMR0L. 3FB6h, Bit 5 = TMR0L TMR0L. 3FB6h, Bit 4 = TMR0L TMR0L. 3FB6h, Bit 3 = TMR0L TMR0L. 3FB6h, Bit 2 = TMR0L TMR0L. 3FB6h, Bit 1 = TMR0L TMR0L.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3FB6h, Bit 0 = TMR0L TMR0L. 3FB6h, Register on page = 289. 3FB5h, Name = T1CLK CS. 3FB5h, Bit 7 = T1CLK CS. 3FB5h, Bit 6 = T1CLK CS. 3FB5h, Bit 5 = T1CLK CS. 3FB5h, Bit 4 = T1CLK CS. 3FB5h, Bit 3 = T1CLK CS. 3FB5h, Bit 2 = T1CLK CS. 3FB5h, Bit 1 = T1CLK CS. 3FB5h, Bit 0 = T1CLK CS. 3FB5h, Register on page = 301. 3FB4h, Name = T1GATE GSS. 3FB4h, Bit 7 = T1GATE GSS. 3FB4h, Bit 6 = T1GATE GSS. 3FB4h, Bit 5 = T1GATE GSS. 3FB4h, Bit 4 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nT1GATE GSS. 3FB4h, Bit 3 = T1GATE GSS. 3FB4h, Bit 2 = T1GATE GSS. 3FB4h, Bit 1 = T1GATE GSS. 3FB4h, Bit 0 = T1GATE GSS. 3FB4h, Register on page = 302. 3FB3h, Name = T1GCON. 3FB3h, Bit 7 = GE. 3FB3h, Bit 6 = GPOL. 3FB3h, Bit 5 = GTM. 3FB3h, Bit 4 = GSPM. 3FB3h, Bit 3 = GGO. 3FB3h, Bit 2 = GVAL. 3FB3h, Bit 1 = -. 3FB3h, Bit 0 = -. 3FB3h, Register on page = 300. 3FB2h, Name = T1CON. 3FB2h, Bit 7 = -. 3FB2h, Bit 6 = -. 3FB2h, Bit 5 = . 3FB2h, Bit 4 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCKPS<1:0>. 3FB2h, Bit 3 = -. 3FB2h, Bit 2 = SYNC. 3FB2h, Bit 1 = RD16. 3FB2h, Bit 0 = ON. 3FB2h, Register on page = 324. 3FB1h, Name = TMR1H TMR1H. 3FB1h, Bit 7 = TMR1H TMR1H. 3FB1h, Bit 6 = TMR1H TMR1H. 3FB1h, Bit 5 = TMR1H TMR1H. 3FB1h, Bit 4 = TMR1H TMR1H. 3FB1h, Bit 3 = TMR1H TMR1H. 3FB1h, Bit 2 = TMR1H TMR1H. 3FB1h, Bit 1 = TMR1H TMR1H. 3FB1h, Bit 0 = TMR1H TMR1H.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3FB1h, Register on page = 303. 3FB0h, Name = TMR1L TMR1L. 3FB0h, Bit 7 = TMR1L TMR1L. 3FB0h, Bit 6 = TMR1L TMR1L. 3FB0h, Bit 5 = TMR1L TMR1L. 3FB0h, Bit 4 = TMR1L TMR1L. 3FB0h, Bit 3 = TMR1L TMR1L. 3FB0h, Bit 2 = TMR1L TMR1L. 3FB0h, Bit 1 = TMR1L TMR1L. 3FB0h, Bit 0 = TMR1L TMR1L. 3FB0h, Register on page = 303. 3FAFh, Name = T2RST. 3FAFh, Bit 7 = -. 3FAFh, Bit 6 = -. 3FAFh, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n-. 3FAFh, Bit 4 = . 3FAFh, Bit 3 = . 3FAFh, Bit 2 = RSEL. 3FAFh, Bit 1 = RSEL. 3FAFh, Bit 0 = RSEL. 3FAFh, Register on page = 322. 3FAEh, Name = T2CLK. 3FAEh, Bit 7 = -. 3FAEh, Bit 6 = -. 3FAEh, Bit 5 = -. 3FAEh, Bit 4 = -. 3FAEh, Bit 3 = . 3FAEh, Bit 2 = CS. 3FAEh, Bit 1 = CS. 3FAEh, Bit 0 = CS. 3FAEh, Register on page = 301. 3FADh, Name = T2HLT. 3FADh, Bit 7 = PSYNC. 3FADh, Bit 6 = CKPOL. 3FADh, Bit 5 = CKSYNC. 3FADh, Bit 4 = . 3FADh, Bit 3 = . 3FADh, Bit 2 = MODE. 3FADh, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nMODE. 3FADh, Bit 0 = MODE. 3FADh, Register on page = 325. 3FACh, Name = T2CON ON CKPS OUTPS. 3FACh, Bit 7 = T2CON ON CKPS OUTPS. 3FACh, Bit 6 = T2CON ON CKPS OUTPS. 3FACh, Bit 5 = T2CON ON CKPS OUTPS. 3FACh, Bit 4 = T2CON ON CKPS OUTPS. 3FACh, Bit 3 = T2CON ON CKPS OUTPS. 3FACh, Bit 2 = T2CON ON CKPS OUTPS. 3FACh, Bit 1 = T2CON ON CKPS OUTPS. 3FACh, Bit 0 = T2CON ON CKPS OUTPS. 3FACh, Register on page = 299. 3FABh, Name = T2PR PR2 TMR2. 3FABh, Bit 7 = T2PR PR2 TMR2. 3FABh, Bit 6 = T2PR PR2 TMR2. 3FABh, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nT2PR PR2 TMR2. 3FABh, Bit 4 = T2PR PR2 TMR2. 3FABh, Bit 3 = T2PR PR2 TMR2. 3FABh, Bit 2 = T2PR PR2 TMR2. 3FABh, Bit 1 = T2PR PR2 TMR2. 3FABh, Bit 0 = T2PR PR2 TMR2. 3FABh, Register on page = 323. 3FAAh 3FA9h, Name = T2TMR T3CLK. 3FAAh 3FA9h, Bit 7 = T2TMR T3CLK. 3FAAh 3FA9h, Bit 6 = T2TMR T3CLK. 3FAAh 3FA9h, Bit 5 = T2TMR T3CLK. 3FAAh 3FA9h, Bit 4 = CS. 3FAAh 3FA9h, Bit 3 = T2TMR T3CLK. 3FAAh 3FA9h, Bit 2 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nT2TMR T3CLK. 3FAAh 3FA9h, Bit 1 = T2TMR T3CLK. 3FAAh 3FA9h, Bit 0 = T2TMR T3CLK. 3FAAh 3FA9h, Register on page = 323 301. 3FA8h, Name = T3GATE GSS. 3FA8h, Bit 7 = T3GATE GSS. 3FA8h, Bit 6 = T3GATE GSS. 3FA8h, Bit 5 = T3GATE GSS. 3FA8h, Bit 4 = T3GATE GSS. 3FA8h, Bit 3 = T3GATE GSS. 3FA8h, Bit 2 = T3GATE GSS. 3FA8h, Bit 1 = T3GATE GSS. 3FA8h, Bit 0 = T3GATE GSS. 3FA8h, Register on page = 302. 3FA7h, Name = T3GCON. 3FA7h, Bit 7 = GE. 3FA7h, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nGPOL. 3FA7h, Bit 5 = GTM. 3FA7h, Bit 4 = GSPM. 3FA7h, Bit 3 = GGO. 3FA7h, Bit 2 = GVAL. 3FA7h, Bit 1 = -. 3FA7h, Bit 0 = -. 3FA7h, Register on page = 300. 3FA6h, Name = T3CON - - CKPS - NOT_SYNC RD16 ON. 3FA6h, Bit 7 = T3CON - - CKPS - NOT_SYNC RD16 ON. 3FA6h, Bit 6 = T3CON - - CKPS - NOT_SYNC RD16 ON. 3FA6h, Bit 5 = T3CON - - CKPS - NOT_SYNC RD16 ON. 3FA6h, Bit 4 = T3CON - - CKPS - NOT_SYNC RD16 ON. 3FA6h, Bit 3 = T3CON - - CKPS - NOT_SYNC RD16 ON. 3FA6h, Bit 2 = T3CON - - CKPS -",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nNOT_SYNC RD16 ON. 3FA6h, Bit 1 = T3CON - - CKPS - NOT_SYNC RD16 ON. 3FA6h, Bit 0 = T3CON - - CKPS - NOT_SYNC RD16 ON. 3FA6h, Register on page = 324. 3FA5h, Name = TMR3H TMR3H. 3FA5h, Bit 7 = TMR3H TMR3H. 3FA5h, Bit 6 = TMR3H TMR3H. 3FA5h, Bit 5 = TMR3H TMR3H. 3FA5h, Bit 4 = TMR3H TMR3H. 3FA5h, Bit 3 = TMR3H TMR3H. 3FA5h, Bit 2 = TMR3H TMR3H. 3FA5h, Bit 1 = TMR3H TMR3H. 3FA5h, Bit 0 = TMR3H",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nTMR3H. 3FA5h, Register on page = 303. 3FA4h, Name = TMR3L TMR3L. 3FA4h, Bit 7 = TMR3L TMR3L. 3FA4h, Bit 6 = TMR3L TMR3L. 3FA4h, Bit 5 = TMR3L TMR3L. 3FA4h, Bit 4 = TMR3L TMR3L. 3FA4h, Bit 3 = TMR3L TMR3L. 3FA4h, Bit 2 = TMR3L TMR3L. 3FA4h, Bit 1 = TMR3L TMR3L. 3FA4h, Bit 0 = TMR3L TMR3L. 3FA4h, Register on page = 303. 3FA3h, Name = T4RST. 3FA3h, Bit 7 = -. 3FA3h, Bit 6 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3FA3h, Bit 5 = -. 3FA3h, Bit 4 = . 3FA3h, Bit 3 = . 3FA3h, Bit 2 = RSEL. 3FA3h, Bit 1 = RSEL. 3FA3h, Bit 0 = RSEL. 3FA3h, Register on page = 322. 3FA2h, Name = T4CLK. 3FA2h, Bit 7 = -. 3FA2h, Bit 6 = -. 3FA2h, Bit 5 = -. 3FA2h, Bit 4 = -. 3FA2h, Bit 3 = . 3FA2h, Bit 2 = CS. 3FA2h, Bit 1 = CS. 3FA2h, Bit 0 = CS. 3FA2h, Register on page = 321. 3FA1h, Name = T4HLT. 3FA1h, Bit 7 = PSYNC. 3FA1h, Bit 6 = CKPOL. 3FA1h, Bit 5 = CKSYNC. 3FA1h, Bit 4 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3FA1h, Bit 3 = . 3FA1h, Bit 2 = MODE. 3FA1h, Bit 1 = MODE. 3FA1h, Bit 0 = MODE. 3FA1h, Register on page = 325. 3FA0h, Name = T4CON ON CKPS OUTPS. 3FA0h, Bit 7 = T4CON ON CKPS OUTPS. 3FA0h, Bit 6 = T4CON ON CKPS OUTPS. 3FA0h, Bit 5 = T4CON ON CKPS OUTPS. 3FA0h, Bit 4 = T4CON ON CKPS OUTPS. 3FA0h, Bit 3 = T4CON ON CKPS OUTPS. 3FA0h, Bit 2 = T4CON ON CKPS OUTPS. 3FA0h, Bit 1 = T4CON ON CKPS OUTPS. 3FA0h, Bit 0 = T4CON ON CKPS OUTPS. 3FA0h, Register on page = 324. 3F9Fh, Name = T4PR PR4.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F9Fh, Bit 7 = T4PR PR4. 3F9Fh, Bit 6 = T4PR PR4. 3F9Fh, Bit 5 = T4PR PR4. 3F9Fh, Bit 4 = T4PR PR4. 3F9Fh, Bit 3 = T4PR PR4. 3F9Fh, Bit 2 = T4PR PR4. 3F9Fh, Bit 1 = T4PR PR4. 3F9Fh, Bit 0 = T4PR PR4. 3F9Fh, Register on page = 323. 3F9Eh, Name = T4TMR. 3F9Eh, Bit 7 = T4TMR. 3F9Eh, Bit 6 = T4TMR. 3F9Eh, Bit 5 = T4TMR. 3F9Eh, Bit 4 = TMR4. 3F9Eh, Bit 3 = T4TMR. 3F9Eh, Bit 2 = T4TMR. 3F9Eh, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nT4TMR. 3F9Eh, Bit 0 = T4TMR. 3F9Eh, Register on page = 323. 3F9Dh, Name = T5CLK CS. 3F9Dh, Bit 7 = T5CLK CS. 3F9Dh, Bit 6 = T5CLK CS. 3F9Dh, Bit 5 = T5CLK CS. 3F9Dh, Bit 4 = T5CLK CS. 3F9Dh, Bit 3 = T5CLK CS. 3F9Dh, Bit 2 = T5CLK CS. 3F9Dh, Bit 1 = T5CLK CS. 3F9Dh, Bit 0 = T5CLK CS. 3F9Dh, Register on page = 321. 3F9Ch, Name = T5GATE. 3F9Ch, Bit 7 = T5GATE. 3F9Ch, Bit 6 = T5GATE. 3F9Ch, Bit 5 = T5GATE. 3F9Ch, Bit 4 = GSS. 3F9Ch, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nT5GATE. 3F9Ch, Bit 2 = T5GATE. 3F9Ch, Bit 1 = T5GATE. 3F9Ch, Bit 0 = T5GATE. 3F9Ch, Register on page = 302. 3F9Bh, Name = T5GCON. 3F9Bh, Bit 7 = GE. 3F9Bh, Bit 6 = GPOL. 3F9Bh, Bit 5 = GTM. 3F9Bh, Bit 4 = GSPM. 3F9Bh, Bit 3 = GGO. 3F9Bh, Bit 2 = GVAL. 3F9Bh, Bit 1 = -. 3F9Bh, Bit 0 = -. 3F9Bh, Register on page = 300. 3F9Ah, Name = T5CON. 3F9Ah, Bit 7 = -. 3F9Ah, Bit 6 = -. 3F9Ah, Bit 5 = . 3F9Ah, Bit 4 = CKPS. 3F9Ah, Bit 3 = -. 3F9Ah, Bit 2 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nNOT_SYNC. 3F9Ah, Bit 1 = RD16. 3F9Ah, Bit 0 = ON. 3F9Ah, Register on page = 324. 3F99h, Name = TMR5H TMR5H. 3F99h, Bit 7 = TMR5H TMR5H. 3F99h, Bit 6 = TMR5H TMR5H. 3F99h, Bit 5 = TMR5H TMR5H. 3F99h, Bit 4 = TMR5H TMR5H. 3F99h, Bit 3 = TMR5H TMR5H. 3F99h, Bit 2 = TMR5H TMR5H. 3F99h, Bit 1 = TMR5H TMR5H. 3F99h, Bit 0 = TMR5H TMR5H. 3F99h, Register on page = 303.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F98h, Name = TMR5L TMR5L. 3F98h, Bit 7 = TMR5L TMR5L. 3F98h, Bit 6 = TMR5L TMR5L. 3F98h, Bit 5 = TMR5L TMR5L. 3F98h, Bit 4 = TMR5L TMR5L. 3F98h, Bit 3 = TMR5L TMR5L. 3F98h, Bit 2 = TMR5L TMR5L. 3F98h, Bit 1 = TMR5L TMR5L. 3F98h, Bit 0 = TMR5L TMR5L. 3F98h, Register on page = 303. 3F97h, Name = T6RST - - - RSEL. 3F97h, Bit 7 = T6RST - - - RSEL.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F97h, Bit 6 = T6RST - - - RSEL. 3F97h, Bit 5 = T6RST - - - RSEL. 3F97h, Bit 4 = T6RST - - - RSEL. 3F97h, Bit 3 = T6RST - - - RSEL. 3F97h, Bit 2 = T6RST - - - RSEL. 3F97h, Bit 1 = T6RST - - - RSEL. 3F97h, Bit 0 = T6RST - - - RSEL. 3F97h, Register on page = 322\nLegend: Note 1: Not present in LF devices.\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F96h, Name = T6CLK. 3F96h, Bit 7 = -. 3F96h, Bit 6 = -. 3F96h, Bit 5 = -. 3F96h, Bit 4 = -. 3F96h, Bit 3 = . 3F96h, Bit 2 = CS. 3F96h, Bit 1 = CS. 3F96h, Bit 0 = . 3F96h, Register on page = 301. 3F95h, Name = T6HLT. 3F95h, Bit 7 = PSYNC. 3F95h, Bit 6 = CKPOL. 3F95h, Bit 5 = CKSYNC. 3F95h, Bit 4 = . 3F95h, Bit 3 = . 3F95h, Bit 2 = MODE. 3F95h, Bit 1 = MODE. 3F95h, Bit 0 = . 3F95h, Register on page = 325.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F94h, Name = T6CON. 3F94h, Bit 7 = ON. 3F94h, Bit 6 = . 3F94h, Bit 5 = CKPS. 3F94h, Bit 4 = . 3F94h, Bit 3 = . 3F94h, Bit 2 = OUTPS. 3F94h, Bit 1 = OUTPS. 3F94h, Bit 0 = . 3F94h, Register on page = 324. 3F93h, Name = T6PR. 3F93h, Bit 7 = . 3F93h, Bit 6 = . 3F93h, Bit 5 = . 3F93h, Bit 4 = PR6. 3F93h, Bit 3 = . 3F93h, Bit 2 = . 3F93h, Bit 1 = . 3F93h, Bit 0 = . 3F93h, Register on page = 323. 3F92h, Name = T6TMR.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F92h, Bit 7 = . 3F92h, Bit 6 = . 3F92h, Bit 5 = . 3F92h, Bit 4 = TMR6. 3F92h, Bit 3 = . 3F92h, Bit 2 = . 3F92h, Bit 1 = . 3F92h, Bit 0 = . 3F92h, Register on page = 323. 3F91h, Name = ECANCON. 3F91h, Bit 7 = MDSEL1. 3F91h, Bit 6 = MDSEL0. 3F91h, Bit 5 = FIFOWM. 3F91h, Bit 4 = EWIN4. 3F91h, Bit 3 = EWIN3. 3F91h, Bit 2 = EWIN2. 3F91h, Bit 1 = EWIN1. 3F91h, Bit 0 = EWIN0. 3F91h, Register on page = 608. 3F90h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nName = COMSTAT. 3F90h, Bit 7 = RXB0OVFL. 3F90h, Bit 6 = RXB1OVFL. 3F90h, Bit 5 = TXBO. 3F90h, Bit 4 = TXBP. 3F90h, Bit 3 = RXBP. 3F90h, Bit 2 = TXWARN. 3F90h, Bit 1 = RXWARN. 3F90h, Bit 0 = EWARN. 3F90h, Register on page = 609. 3F90h, Name = COMSTAT. 3F90h, Bit 7 = -. 3F90h, Bit 6 = RXBnOVFL. 3F90h, Bit 5 = TXBO. 3F90h, Bit 4 = TXBP. 3F90h, Bit 3 = RXBP. 3F90h, Bit 2 = TXWARN. 3F90h, Bit 1 = RXWARN. 3F90h, Bit 0 = EWARN.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F90h, Register on page = 609. 3F90h, Name = COMSTAT. 3F90h, Bit 7 = FIFOEMPTY. 3F90h, Bit 6 = RXBnOVFL. 3F90h, Bit 5 = TXBO. 3F90h, Bit 4 = TXBP. 3F90h, Bit 3 = RXBP. 3F90h, Bit 2 = TXWARN. 3F90h, Bit 1 = RXWARN. 3F90h, Bit 0 = EWARN. 3F90h, Register on page = 609. 3F8Fh, Name = CANCON. 3F8Fh, Bit 7 = REQOP2. 3F8Fh, Bit 6 = REQOP1. 3F8Fh, Bit 5 = REQOP0. 3F8Fh, Bit 4 = ABAT. 3F8Fh, Bit 3 = WIN2. 3F8Fh, Bit 2 = WIN1. 3F8Fh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 1 = WIN0. 3F8Fh, Bit 0 = -. 3F8Fh, Register on page = 604. 3F8Fh, Name = CANCON. 3F8Fh, Bit 7 = REQOP2. 3F8Fh, Bit 6 = REQOP1. 3F8Fh, Bit 5 = REQOP0. 3F8Fh, Bit 4 = ABAT. 3F8Fh, Bit 3 = -. 3F8Fh, Bit 2 = -. 3F8Fh, Bit 1 = -. 3F8Fh, Bit 0 = -. 3F8Fh, Register on page = 604. 3F8Fh, Name = CANCON. 3F8Fh, Bit 7 = REQOP2. 3F8Fh, Bit 6 = REQOP1. 3F8Fh, Bit 5 = REQOP0. 3F8Fh, Bit 4 = ABAT. 3F8Fh, Bit 3 = FP3.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F8Fh, Bit 2 = FP2. 3F8Fh, Bit 1 = FP1. 3F8Fh, Bit 0 = FP0. 3F8Fh, Register on page = 604. 3F8Eh, Name = CANSTAT. 3F8Eh, Bit 7 = OPMODE2. 3F8Eh, Bit 6 = OPMODE1. 3F8Eh, Bit 5 = OPMODE0. 3F8Eh, Bit 4 = -. 3F8Eh, Bit 3 = ICODE2. 3F8Eh, Bit 2 = ICODE1. 3F8Eh, Bit 1 = ICODE0. 3F8Eh, Bit 0 = -. 3F8Eh, Register on page = 605. 3F8Eh, Name = CANSTAT. 3F8Eh, Bit 7 = OPMODE2. 3F8Eh, Bit 6 = OPMODE1. 3F8Eh, Bit 5 = OPMODE0. 3F8Eh, Bit 4 = EICODE4.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F8Eh, Bit 3 = EICODE3. 3F8Eh, Bit 2 = EICODE2. 3F8Eh, Bit 1 = EICODE1. 3F8Eh, Bit 0 = EICODE0. 3F8Eh, Register on page = 605. 3F8Dh, Name = RXB0D7. 3F8Dh, Bit 7 = RXB0Dm7. 3F8Dh, Bit 6 = RXB0Dm6. 3F8Dh, Bit 5 = RXB0Dm5. 3F8Dh, Bit 4 = RXB0Dm4. 3F8Dh, Bit 3 = RXB0Dm3. 3F8Dh, Bit 2 = RXB0Dm2. 3F8Dh, Bit 1 = RXB0Dm1. 3F8Dh, Bit 0 = RXB0Dm0. 3F8Dh, Register on page = 621. 3F8Ch, Name = RXB0D6. 3F8Ch, Bit 7",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= RXB0Dm7. 3F8Ch, Bit 6 = RXB0Dm6. 3F8Ch, Bit 5 = RXB0Dm5. 3F8Ch, Bit 4 = RXB0Dm4. 3F8Ch, Bit 3 = RXB0Dm3. 3F8Ch, Bit 2 = RXB0Dm2. 3F8Ch, Bit 1 = RXB0Dm1. 3F8Ch, Bit 0 = RXB0Dm0. 3F8Ch, Register on page = 621. 3F8Bh, Name = RXB0D5. 3F8Bh, Bit 7 = RXB0Dm7. 3F8Bh, Bit 6 = RXB0Dm6. 3F8Bh, Bit 5 = RXB0Dm5. 3F8Bh, Bit 4 = RXB0Dm4. 3F8Bh, Bit 3 = RXB0Dm3. 3F8Bh, Bit 2 = RXB0Dm2.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F8Bh, Bit 1 = RXB0Dm1. 3F8Bh, Bit 0 = RXB0Dm0. 3F8Bh, Register on page = 621. 3F8Ah, Name = RXB0D4. 3F8Ah, Bit 7 = RXB0Dm7. 3F8Ah, Bit 6 = RXB0Dm6. 3F8Ah, Bit 5 = RXB0Dm5. 3F8Ah, Bit 4 = RXB0Dm4. 3F8Ah, Bit 3 = RXB0Dm3. 3F8Ah, Bit 2 = RXB0Dm2. 3F8Ah, Bit 1 = RXB0Dm1. 3F8Ah, Bit 0 = RXB0Dm0. 3F8Ah, Register on page = 621. 3F89h, Name = RXB0D3. 3F89h, Bit 7 = RXB0Dm7. 3F89h, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRXB0Dm6. 3F89h, Bit 5 = RXB0Dm5. 3F89h, Bit 4 = RXB0Dm4. 3F89h, Bit 3 = RXB0Dm3. 3F89h, Bit 2 = RXB0Dm2. 3F89h, Bit 1 = RXB0Dm1. 3F89h, Bit 0 = RXB0Dm0. 3F89h, Register on page = 621. 3F88h, Name = RXB0D2. 3F88h, Bit 7 = RXB0Dm7. 3F88h, Bit 6 = RXB0Dm6. 3F88h, Bit 5 = RXB0Dm5. 3F88h, Bit 4 = RXB0Dm4. 3F88h, Bit 3 = RXB0Dm3. 3F88h, Bit 2 = RXB0Dm2.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F88h, Bit 1 = RXB0Dm1. 3F88h, Bit 0 = RXB0Dm0. 3F88h, Register on page = 621. 3F87h, Name = RXB0D1. 3F87h, Bit 7 = RXB0Dm7. 3F87h, Bit 6 = RXB0Dm6. 3F87h, Bit 5 = RXB0Dm5. 3F87h, Bit 4 = RXB0Dm4. 3F87h, Bit 3 = RXB0Dm3. 3F87h, Bit 2 = RXB0Dm2. 3F87h, Bit 1 = RXB0Dm1. 3F87h, Bit 0 = RXB0Dm0. 3F87h, Register on page = 621. 3F86h, Name = RXB0D0. 3F86h, Bit 7 = RXB0Dm7.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F86h, Bit 6 = RXB0Dm6. 3F86h, Bit 5 = RXB0Dm5. 3F86h, Bit 4 = RXB0Dm4. 3F86h, Bit 3 = RXB0Dm3. 3F86h, Bit 2 = RXB0Dm2. 3F86h, Bit 1 = RXB0Dm1. 3F86h, Bit 0 = RXB0Dm0. 3F86h, Register on page = 621. 3F85h, Name = RXB0DLC. 3F85h, Bit 7 = -. 3F85h, Bit 6 = RXRTR. 3F85h, Bit 5 = RB1. 3F85h, Bit 4 = RB0. 3F85h, Bit 3 = DLC3. 3F85h, Bit 2 = DLC2. 3F85h, Bit 1 = DLC1. 3F85h, Bit 0 = DLC0. 3F85h, Register on",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\npage = 621. 3F84h, Name = RXB0EIDL. 3F84h, Bit 7 = EID7. 3F84h, Bit 6 = EID6. 3F84h, Bit 5 = EID5. 3F84h, Bit 4 = EID4. 3F84h, Bit 3 = EID3. 3F84h, Bit 2 = EID2. 3F84h, Bit 1 = EID1. 3F84h, Bit 0 = EID0. 3F84h, Register on page = 621. 3F83h, Name = RXB0EIDH. 3F83h, Bit 7 = EID15. 3F83h, Bit 6 = EID14. 3F83h, Bit 5 = EID13. 3F83h, Bit 4 = EID12. 3F83h, Bit 3 = EID11. 3F83h, Bit 2 = EID10.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F83h, Bit 1 = EID9. 3F83h, Bit 0 = EID8. 3F83h, Register on page = 621. 3F82h, Name = RXB0SIDL. 3F82h, Bit 7 = SID2. 3F82h, Bit 6 = SID1. 3F82h, Bit 5 = SID0. 3F82h, Bit 4 = SRR. 3F82h, Bit 3 = EXID. 3F82h, Bit 2 = -. 3F82h, Bit 1 = EID17. 3F82h, Bit 0 = EID16. 3F82h, Register on page = 621. 3F81h, Name = RXB0SIDH. 3F81h, Bit 7 = SID10. 3F81h, Bit 6 = SID9. 3F81h, Bit 5 = SID8. 3F81h, Bit 4 = SID7.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F81h, Bit 3 = SID6. 3F81h, Bit 2 = SID5. 3F81h, Bit 1 = SID4. 3F81h, Bit 0 = SID3. 3F81h, Register on page = 621. 3F80h, Name = RXB0CON. 3F80h, Bit 7 = RXFUL. 3F80h, Bit 6 = RXM1. 3F80h, Bit 5 = RXM0. 3F80h, Bit 4 = -. 3F80h, Bit 3 = RXRTRRO. 3F80h, Bit 2 = RXB0DBEN. 3F80h, Bit 1 = JTOFF. 3F80h, Bit 0 = FILHIT0. 3F80h, Register on page = 621. 3F80h, Name = RXB0CON. 3F80h, Bit 7 = RXFUL. 3F80h, Bit 6 = RXM1. 3F80h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n5 = RTRRO. 3F80h, Bit 4 = FILHITF4. 3F80h, Bit 3 = FILHIT3 FILHIT2. 3F80h, Bit 2 = . 3F80h, Bit 1 = FILHIT1. 3F80h, Bit 0 = FILHIT0. 3F80h, Register on page = 621. 3F7Fh, Name = CCP1CAP. 3F7Fh, Bit 7 = - - - - CTS<3:0> EN. 3F7Fh, Bit 6 = - - - - CTS<3:0> EN. 3F7Fh, Bit 5 = - - - - CTS<3:0> EN. 3F7Fh, Bit 4 = - - - - CTS<3:0> EN. 3F7Fh, Bit 3 = - - - - CTS<3:0> EN. 3F7Fh, Bit 2 = - - - - CTS<3:0> EN.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F7Fh, Bit 1 = - - - - CTS<3:0> EN. 3F7Fh, Bit 0 = - - - - CTS<3:0> EN. 3F7Fh, Register on page = 339 336. 3F7Eh 3F7Dh, Name = CCP1CON CCPR1H. 3F7Eh 3F7Dh, Bit 7 = . 3F7Eh 3F7Dh, Bit 6 = -. 3F7Eh 3F7Dh, Bit 5 = OUT. 3F7Eh 3F7Dh, Bit 4 = FMT. 3F7Eh 3F7Dh, Bit 3 = RH. 3F7Eh 3F7Dh, Bit 2 = . 3F7Eh 3F7Dh, Bit 1 = MODE. 3F7Eh 3F7Dh, Bit 0 = . 3F7Eh 3F7Dh, Register on page = 340. 3F7Ch, Name = CCPR1L. 3F7Ch, Bit 7 = . 3F7Ch, Bit 6",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= . 3F7Ch, Bit 5 = . 3F7Ch, Bit 4 = . 3F7Ch, Bit 3 = RL. 3F7Ch, Bit 2 = . 3F7Ch, Bit 1 = . 3F7Ch, Bit 0 = . 3F7Ch, Register on page = 339. 3F7Bh, Name = CCP2CAP. 3F7Bh, Bit 7 = -. 3F7Bh, Bit 6 = -. 3F7Bh, Bit 5 = -. 3F7Bh, Bit 4 = -. 3F7Bh, Bit 3 = . 3F7Bh, Bit 2 = CTS<3:0>. 3F7Bh, Bit 1 = . 3F7Bh, Bit 0 = . 3F7Bh, Register on page = 339. 3F7Ah, Name = CCP2CON. 3F7Ah, Bit 7 = EN. 3F7Ah, Bit 6 = -. 3F7Ah, Bit 5 = OUT. 3F7Ah, Bit 4 = FMT.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F7Ah, Bit 3 = . 3F7Ah, Bit 2 = MODE. 3F7Ah, Bit 1 = . 3F7Ah, Bit 0 = . 3F7Ah, Register on page = 336. 3F79h, Name = CCPR2H. 3F79h, Bit 7 = . 3F79h, Bit 6 = . 3F79h, Bit 5 = . 3F79h, Bit 4 = RH. 3F79h, Bit 3 = . 3F79h, Bit 2 = . 3F79h, Bit 1 = . 3F79h, Bit 0 = . 3F79h, Register on page = 340. 3F78h, Name = CCPR2L. 3F78h, Bit 7 = . 3F78h, Bit 6 = . 3F78h, Bit 5 = . 3F78h, Bit 4 = RL. 3F78h, Bit 3 = . 3F78h, Bit 2 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F78h, Bit 1 = . 3F78h, Bit 0 = . 3F78h, Register on page = 339. 3F77h, Name = CCP3CAP. 3F77h, Bit 7 = -. 3F77h, Bit 6 = -. 3F77h, Bit 5 = -. 3F77h, Bit 4 = -. 3F77h, Bit 3 = . 3F77h, Bit 2 = CTS<3:0>. 3F77h, Bit 1 = . 3F77h, Bit 0 = . 3F77h, Register on page = 339. 3F76h, Name = CCP3CON. 3F76h, Bit 7 = EN. 3F76h, Bit 6 = -. 3F76h, Bit 5 = OUT. 3F76h, Bit 4 = FMT. 3F76h, Bit 3 = . 3F76h, Bit 2 = MODE.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F76h, Bit 1 = . 3F76h, Bit 0 = . 3F76h, Register on page = 336. 3F75h, Name = CCPR3H. 3F75h, Bit 7 = . 3F75h, Bit 6 = . 3F75h, Bit 5 = . 3F75h, Bit 4 = RH. 3F75h, Bit 3 = . 3F75h, Bit 2 = . 3F75h, Bit 1 = . 3F75h, Bit 0 = . 3F75h, Register on page = 340. 3F74h, Name = CCPR3L. 3F74h, Bit 7 = . 3F74h, Bit 6 = . 3F74h, Bit 5 = . 3F74h, Bit 4 = RL. 3F74h, Bit 3 = . 3F74h, Bit 2 = . 3F74h, Bit 1 = . 3F74h, Bit 0 = . 3F74h, Register",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\non page = 339. 3F73h, Name = CCP4CAP. 3F73h, Bit 7 = -. 3F73h, Bit 6 = -. 3F73h, Bit 5 = -. 3F73h, Bit 4 = -. 3F73h, Bit 3 = . 3F73h, Bit 2 = CTS<3:0>. 3F73h, Bit 1 = . 3F73h, Bit 0 = . 3F73h, Register on page = 339. 3F72h, Name = CCP4CON. 3F72h, Bit 7 = EN. 3F72h, Bit 6 = -. 3F72h, Bit 5 = OUT. 3F72h, Bit 4 = FMT. 3F72h, Bit 3 = . 3F72h, Bit 2 = . 3F72h, Bit 1 = MODE. 3F72h, Bit 0 = . 3F72h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n336. 3F71h, Name = CCPR4H. 3F71h, Bit 7 = . 3F71h, Bit 6 = . 3F71h, Bit 5 = . 3F71h, Bit 4 = RH. 3F71h, Bit 3 = . 3F71h, Bit 2 = . 3F71h, Bit 1 = . 3F71h, Bit 0 = . 3F71h, Register on page = 340. 3F70h, Name = CCPR4L. 3F70h, Bit 7 = . 3F70h, Bit 6 = . 3F70h, Bit 5 = . 3F70h, Bit 4 = RL. 3F70h, Bit 3 = . 3F70h, Bit 2 = . 3F70h, Bit 1 = . 3F70h, Bit 0 = . 3F70h, Register on page = 339. 3F6Fh, Name = -. 3F6Fh, Bit 7 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F6Fh, Bit 6 = . 3F6Fh, Bit 5 = . 3F6Fh, Bit 4 = Unimplemented. 3F6Fh, Bit 3 = . 3F6Fh, Bit 2 = . 3F6Fh, Bit 1 = . 3F6Fh, Bit 0 = . 3F6Fh, Register on page = -. 3F6Eh, Name = PWM5CON. 3F6Eh, Bit 7 = EN. 3F6Eh, Bit 6 = -. 3F6Eh, Bit 5 = OUT. 3F6Eh, Bit 4 = POL. 3F6Eh, Bit 3 = -. 3F6Eh, Bit 2 = -. 3F6Eh, Bit 1 = -. 3F6Eh, Bit 0 = -. 3F6Eh, Register on page = 345. 3F6Dh, Name = PWM5DCH. 3F6Dh, Bit 7 = DC9. 3F6Dh, Bit 6 = DC8.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F6Dh, Bit 5 = DC7. 3F6Dh, Bit 4 = DC6. 3F6Dh, Bit 3 = DC5. 3F6Dh, Bit 2 = DC4. 3F6Dh, Bit 1 = DC3. 3F6Dh, Bit 0 = DC2. 3F6Dh, Register on page = 347. 3F6Ch, Name = PWM5DCL. 3F6Ch, Bit 7 = DC1. 3F6Ch, Bit 6 = DC0. 3F6Ch, Bit 5 = -. 3F6Ch, Bit 4 = -. 3F6Ch, Bit 3 = -. 3F6Ch, Bit 2 = -. 3F6Ch, Bit 1 = -. 3F6Ch, Bit 0 = -. 3F6Ch, Register on page = 347. 3F6Bh, Name = -. 3F6Bh, Bit 7 = . 3F6Bh, Bit 6 = . 3F6Bh, Bit 5 = . 3F6Bh, Bit 4 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nUnimplemented. 3F6Bh, Bit 3 = . 3F6Bh, Bit 2 = . 3F6Bh, Bit 1 = . 3F6Bh, Bit 0 = . 3F6Bh, Register on page = -\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1:\nNot present in LF devices.\nDS40001943C-page 771",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F6Ah, Name = PWM6CON. 3F6Ah, Bit 7 = EN. 3F6Ah, Bit 6 = -. 3F6Ah, Bit 5 = OUT. 3F6Ah, Bit 4 = POL. 3F6Ah, Bit 3 = -. 3F6Ah, Bit 2 = -. 3F6Ah, Bit 1 = -. 3F6Ah, Bit 0 = -. 3F6Ah, Register on page = 345. 3F69h, Name = PWM6DCH. 3F69h, Bit 7 = DC9. 3F69h, Bit 6 = DC9. 3F69h, Bit 5 = DC7. 3F69h, Bit 4 = DC6. 3F69h, Bit 3 = DC5. 3F69h, Bit 2 = DC4. 3F69h, Bit 1 = DC3. 3F69h, Bit 0 = DC2. 3F69h, Register on page = 347.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F68h, Name = PWM6DCL. 3F68h, Bit 7 = DC1. 3F68h, Bit 6 = DC0. 3F68h, Bit 5 = -. 3F68h, Bit 4 = -. 3F68h, Bit 3 = -. 3F68h, Bit 2 = -. 3F68h, Bit 1 = -. 3F68h, Bit 0 = -. 3F68h, Register on page = 347. 3F67h, Name = -. 3F67h, Bit 7 = . 3F67h, Bit 6 = . 3F67h, Bit 5 = . 3F67h, Bit 4 = Unimplemented. 3F67h, Bit 3 = Unimplemented. 3F67h, Bit 2 = . 3F67h, Bit 1 = . 3F67h, Bit 0 = . 3F67h, Register on page = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F66h, Name = PWM7CON. 3F66h, Bit 7 = EN. 3F66h, Bit 6 = -. 3F66h, Bit 5 = OUT. 3F66h, Bit 4 = POL. 3F66h, Bit 3 = -. 3F66h, Bit 2 = -. 3F66h, Bit 1 = -. 3F66h, Bit 0 = -. 3F66h, Register on page = 345. 3F65h, Name = PWM7DCH. 3F65h, Bit 7 = DC9. 3F65h, Bit 6 = DC8. 3F65h, Bit 5 = DC7. 3F65h, Bit 4 = DC6. 3F65h, Bit 3 = DC5. 3F65h, Bit 2 = DC4. 3F65h, Bit 1 = DC3. 3F65h, Bit 0 = DC2. 3F65h, Register on page = 347. 3F64h, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nPWM7DCL. 3F64h, Bit 7 = DC1. 3F64h, Bit 6 = DC0. 3F64h, Bit 5 = -. 3F64h, Bit 4 = -. 3F64h, Bit 3 = -. 3F64h, Bit 2 = -. 3F64h, Bit 1 = -. 3F64h, Bit 0 = -. 3F64h, Register on page = 347. 3F63h, Name = -. 3F63h, Bit 7 = . 3F63h, Bit 6 = . 3F63h, Bit 5 = . 3F63h, Bit 4 = Unimplemented. 3F63h, Bit 3 = Unimplemented. 3F63h, Bit 2 = . 3F63h, Bit 1 = . 3F63h, Bit 0 = . 3F63h, Register on page = -. 3F62h, Name = PWM8CON.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F62h, Bit 7 = EN. 3F62h, Bit 6 = -. 3F62h, Bit 5 = OUT. 3F62h, Bit 4 = POL. 3F62h, Bit 3 = -. 3F62h, Bit 2 = -. 3F62h, Bit 1 = -. 3F62h, Bit 0 = -. 3F62h, Register on page = 345. 3F61h, Name = PWM8DCH. 3F61h, Bit 7 = DC9. 3F61h, Bit 6 = DC8. 3F61h, Bit 5 = DC7. 3F61h, Bit 4 = DC6. 3F61h, Bit 3 = DC5. 3F61h, Bit 2 = DC4. 3F61h, Bit 1 = DC3. 3F61h, Bit 0 = DC2. 3F61h, Register on page = 347. 3F60h, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nPWM8DCL. 3F60h, Bit 7 = DC1. 3F60h, Bit 6 = DC0. 3F60h, Bit 5 = -. 3F60h, Bit 4 = -. 3F60h, Bit 3 = -. 3F60h, Bit 2 = -. 3F60h, Bit 1 = -. 3F60h, Bit 0 = -. 3F60h, Register on page = 347. 3F5Fh, Name = CCPTMRS1. 3F5Fh, Bit 7 = P8TSEL. 3F5Fh, Bit 6 = P8TSEL. 3F5Fh, Bit 5 = P7TSEL. 3F5Fh, Bit 4 = P7TSEL. 3F5Fh, Bit 3 = P6TSEL. 3F5Fh, Bit 2 = P6TSEL. 3F5Fh, Bit 1 = P5TSEL. 3F5Fh, Bit 0 = P5TSEL.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F5Fh, Register on page = 346. 3F5Eh, Name = CCPTMRS0. 3F5Eh, Bit 7 = C4TSEL. 3F5Eh, Bit 6 = C4TSEL. 3F5Eh, Bit 5 = C3TSEL. 3F5Eh, Bit 4 = C3TSEL. 3F5Eh, Bit 3 = C2TSEL. 3F5Eh, Bit 2 = C2TSEL. 3F5Eh, Bit 1 = C1TSEL. 3F5Eh, Bit 0 = C1TSEL. 3F5Eh, Register on page = 346. 3F5Dh- 3F5Bh, Name = -. 3F5Dh- 3F5Bh, Bit 7 = . 3F5Dh- 3F5Bh, Bit 6 = . 3F5Dh- 3F5Bh, Bit 5 = . 3F5Dh- 3F5Bh, Bit 4 = Unimplemented. 3F5Dh- 3F5Bh, Bit 3 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F5Dh- 3F5Bh, Bit 2 = . 3F5Dh- 3F5Bh, Bit 1 = . 3F5Dh- 3F5Bh, Bit 0 = . 3F5Dh- 3F5Bh, Register on page = -. 3F5Ah, Name = CWG1STR. 3F5Ah, Bit 7 = OVRD. 3F5Ah, Bit 6 = OVRC. 3F5Ah, Bit 5 = OVRB. 3F5Ah, Bit 4 = OVRA. 3F5Ah, Bit 3 = STRD. 3F5Ah, Bit 2 = STRC. 3F5Ah, Bit 1 = STRB. 3F5Ah, Bit 0 = STRA. 3F5Ah, Register on page = 415. 3F59h, Name = CWG1AS1. 3F59h, Bit 7 = -. 3F59h, Bit 6 = AS6E. 3F59h, Bit 5 = AS5E. 3F59h, Bit 4 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nAS4E. 3F59h, Bit 3 = AS3E. 3F59h, Bit 2 = AS2E. 3F59h, Bit 1 = AS1E. 3F59h, Bit 0 = AS0E. 3F59h, Register on page = 417. 3F58h, Name = CWG1AS0. 3F58h, Bit 7 = SHUTDOWN. 3F58h, Bit 6 = REN. 3F58h, Bit 5 = LSBD. 3F58h, Bit 4 = . 3F58h, Bit 3 = LSAC. 3F58h, Bit 2 = LSAC. 3F58h, Bit 1 = -. 3F58h, Bit 0 = -. 3F58h, Register on page = 416. 3F57h, Name = CWG1CON1. 3F57h, Bit 7 = -. 3F57h, Bit 6 = -. 3F57h, Bit 5 = IN. 3F57h, Bit 4 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F57h, Bit 3 = POLD. 3F57h, Bit 2 = POLC. 3F57h, Bit 1 = POLB. 3F57h, Bit 0 = POLA. 3F57h, Register on page = 412. 3F56h, Name = CWG1CON0. 3F56h, Bit 7 = EN. 3F56h, Bit 6 = LD. 3F56h, Bit 5 = -. 3F56h, Bit 4 = -. 3F56h, Bit 3 = -. 3F56h, Bit 2 = . 3F56h, Bit 1 = MODE. 3F56h, Bit 0 = . 3F56h, Register on page = 411. 3F55h, Name = CWG1DBF. 3F55h, Bit 7 = -. 3F55h, Bit 6 = -. 3F55h, Bit 5 = . 3F55h, Bit 4 = . 3F55h, Bit 3 = DBF. 3F55h, Bit 2 = DBF.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F55h, Bit 1 = . 3F55h, Bit 0 = . 3F55h, Register on page = 418. 3F54h, Name = CWG1DBR. 3F54h, Bit 7 = -. 3F54h, Bit 6 = -. 3F54h, Bit 5 = . 3F54h, Bit 4 = . 3F54h, Bit 3 = DBR. 3F54h, Bit 2 = DBR. 3F54h, Bit 1 = . 3F54h, Bit 0 = . 3F54h, Register on page = 418. 3F53h, Name = CWG1ISM. 3F53h, Bit 7 = -. 3F53h, Bit 6 = -. 3F53h, Bit 5 = -. 3F53h, Bit 4 = -. 3F53h, Bit 3 = . 3F53h, Bit 2 = . 3F53h, Bit 1 = . 3F53h, Bit 0 = . 3F53h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n414. 3F52h 3F51h, Name = CWG1CLK CWG2STR. 3F52h 3F51h, Bit 7 = -. 3F52h 3F51h, Bit 6 = -. 3F52h 3F51h, Bit 5 = -. 3F52h 3F51h, Bit 4 = - OVRA. 3F52h 3F51h, Bit 3 = - STRD. 3F52h 3F51h, Bit 2 = - STRC. 3F52h 3F51h, Bit 1 = - STRB. 3F52h 3F51h, Bit 0 = CS STRA. 3F52h 3F51h, Register on page = 413 415. , Name = . , Bit 7 = OVRD. , Bit 6 = OVRC. , Bit 5 = OVRB. , Bit 4 = . , Bit 3 = AS3E. , Bit 2 = . , Bit 1 = . , Bit 0 = . , Register on page = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F50h, Name = CWG2AS1. 3F50h, Bit 7 = -. 3F50h, Bit 6 = AS6E. 3F50h, Bit 5 = AS5E. 3F50h, Bit 4 = AS4E. 3F50h, Bit 3 = . 3F50h, Bit 2 = AS2E. 3F50h, Bit 1 = AS1E. 3F50h, Bit 0 = AS0E. 3F50h, Register on page = 417. 3F4Fh, Name = CWG2AS0. 3F4Fh, Bit 7 = SHUTDOWN. 3F4Fh, Bit 6 = REN. 3F4Fh, Bit 5 = LSBD. 3F4Fh, Bit 4 = . 3F4Fh, Bit 3 = LSAC. 3F4Fh, Bit 2 = . 3F4Fh, Bit 1 = -. 3F4Fh, Bit 0 = -. 3F4Fh, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n416. 3F4Eh, Name = CWG2CON1. 3F4Eh, Bit 7 = -. 3F4Eh, Bit 6 = -. 3F4Eh, Bit 5 = IN. 3F4Eh, Bit 4 = -. 3F4Eh, Bit 3 = POLD. 3F4Eh, Bit 2 = POLC. 3F4Eh, Bit 1 = POLB. 3F4Eh, Bit 0 = POLA. 3F4Eh, Register on page = 412. 3F4Dh, Name = CWG2CON0. 3F4Dh, Bit 7 = EN. 3F4Dh, Bit 6 = LD. 3F4Dh, Bit 5 = -. 3F4Dh, Bit 4 = -. 3F4Dh, Bit 3 = -. 3F4Dh, Bit 2 = . 3F4Dh, Bit 1 = MODE. 3F4Dh, Bit 0 = . 3F4Dh, Register on page = 411. 3F4Ch, Name = CWG2DBF. 3F4Ch,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 7 = -. 3F4Ch, Bit 6 = -. 3F4Ch, Bit 5 = . 3F4Ch, Bit 4 = . 3F4Ch, Bit 3 = DBF. 3F4Ch, Bit 2 = . 3F4Ch, Bit 1 = . 3F4Ch, Bit 0 = . 3F4Ch, Register on page = 418. 3F4Bh 3F4Ah, Name = CWG2DBR CWG2ISM. 3F4Bh 3F4Ah, Bit 7 = - -. 3F4Bh 3F4Ah, Bit 6 = - -. 3F4Bh 3F4Ah, Bit 5 = . 3F4Bh 3F4Ah, Bit 4 = . 3F4Bh 3F4Ah, Bit 3 = DBR. 3F4Bh 3F4Ah, Bit 2 = . 3F4Bh 3F4Ah, Bit 1 = . 3F4Bh 3F4Ah, Bit 0 = . 3F4Bh 3F4Ah, Register on page = 418",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n414. 3F49h, Name = CWG2CLK. 3F49h, Bit 7 = -. 3F49h, Bit 6 = -. 3F49h, Bit 5 = - -. 3F49h, Bit 4 = - -. 3F49h, Bit 3 = -. 3F49h, Bit 2 = -. 3F49h, Bit 1 = -. 3F49h, Bit 0 = CS. 3F49h, Register on page = 413. 3F48h, Name = CWG3STR. 3F48h, Bit 7 = OVRD. 3F48h, Bit 6 = OVRC. 3F48h, Bit 5 = OVRB. 3F48h, Bit 4 = OVRA. 3F48h, Bit 3 = STRD. 3F48h, Bit 2 = STRC. 3F48h, Bit 1 = STRB. 3F48h, Bit 0 = STRA. 3F48h, Register on page = 415. 3F47h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nName = CWG3AS1. 3F47h, Bit 7 = -. 3F47h, Bit 6 = AS6E. 3F47h, Bit 5 = AS5E. 3F47h, Bit 4 = AS4E. 3F47h, Bit 3 = AS3E. 3F47h, Bit 2 = AS2E. 3F47h, Bit 1 = AS1E. 3F47h, Bit 0 = AS0E. 3F47h, Register on page = 417. 3F46h, Name = CWG3AS0. 3F46h, Bit 7 = SHUTDOWN. 3F46h, Bit 6 = REN. 3F46h, Bit 5 = LSBD. 3F46h, Bit 4 = . 3F46h, Bit 3 = LSAC. 3F46h, Bit 2 = . 3F46h, Bit 1 = -. 3F46h, Bit 0 = -. 3F46h, Register on page = 416. 3F45h, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCWG3CON1. 3F45h, Bit 7 = -. 3F45h, Bit 6 = -. 3F45h, Bit 5 = IN. 3F45h, Bit 4 = -. 3F45h, Bit 3 = POLD. 3F45h, Bit 2 = POLC. 3F45h, Bit 1 = POLB. 3F45h, Bit 0 = POLA. 3F45h, Register on page = 412. 3F44h, Name = CWG3CON0. 3F44h, Bit 7 = EN. 3F44h, Bit 6 = LD. 3F44h, Bit 5 = -. 3F44h, Bit 4 = -. 3F44h, Bit 3 = -. 3F44h, Bit 2 = . 3F44h, Bit 1 = MODE. 3F44h, Bit 0 = . 3F44h, Register on page = 411. 3F43h 3F42h, Name = CWG3DBF CWG3DBR. 3F43h",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F42h, Bit 7 = - -. 3F43h 3F42h, Bit 6 = - -. 3F43h 3F42h, Bit 5 = . 3F43h 3F42h, Bit 4 = . 3F43h 3F42h, Bit 3 = DBF. 3F43h 3F42h, Bit 2 = . 3F43h 3F42h, Bit 1 = . 3F43h 3F42h, Bit 0 = . 3F43h 3F42h, Register on page = 418 418. 3F41h, Name = CWG3ISM. 3F41h, Bit 7 = -. 3F41h, Bit 6 = -. 3F41h, Bit 5 = . 3F41h, Bit 4 = . 3F41h, Bit 3 = DBR. 3F41h, Bit 2 = . 3F41h, Bit 1 = . 3F41h, Bit 0 = . 3F41h, Register on page = . , Name = . , Bit 7 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n, Bit 6 = . , Bit 5 = -. , Bit 4 = -. , Bit 3 = . , Bit 2 = . , Bit 1 = . , Bit 0 = . , Register on page = 414. 3F40h, Name = CWG3CLK. 3F40h, Bit 7 = -. 3F40h, Bit 6 = -. 3F40h, Bit 5 = -. 3F40h, Bit 4 = -. 3F40h, Bit 3 = -. 3F40h, Bit 2 = -. 3F40h, Bit 1 = -. 3F40h, Bit 0 = CS. 3F40h, Register on page = 413. 3F3Fh, Name = NCO1CLK. 3F3Fh, Bit 7 = . 3F3Fh, Bit 6 = PWS. 3F3Fh, Bit 5 = . 3F3Fh, Bit 4 = -. 3F3Fh, Bit 3 = . 3F3Fh, Bit 2 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F3Fh, Bit 1 = CKS. 3F3Fh, Bit 0 = . 3F3Fh, Register on page = 441. 3F3Eh, Name = NCO1CON. 3F3Eh, Bit 7 = EN. 3F3Eh, Bit 6 = -. 3F3Eh, Bit 5 = OUT. 3F3Eh, Bit 4 = POL. 3F3Eh, Bit 3 = -. 3F3Eh, Bit 2 = -. 3F3Eh, Bit 1 = -. 3F3Eh, Bit 0 = PFM. 3F3Eh, Register on page = 440. 3F3Dh, Name = NCO1INCU. 3F3Dh, Bit 7 = . 3F3Dh, Bit 6 = . 3F3Dh, Bit 5 = . 3F3Dh, Bit 4 = INC. 3F3Dh, Bit 3 = . 3F3Dh, Bit 2 = . 3F3Dh, Bit 1 = . 3F3Dh, Bit 0 = . 3F3Dh, Register on",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\npage = 444. 3F3Ch, Name = NCO1INCH. 3F3Ch, Bit 7 = . 3F3Ch, Bit 6 = . 3F3Ch, Bit 5 = . 3F3Ch, Bit 4 = INC. 3F3Ch, Bit 3 = . 3F3Ch, Bit 2 = . 3F3Ch, Bit 1 = . 3F3Ch, Bit 0 = . 3F3Ch, Register on page = 443. 3F3Bh, Name = NCO1INCL. 3F3Bh, Bit 7 = . 3F3Bh, Bit 6 = . 3F3Bh, Bit 5 = . 3F3Bh, Bit 4 = INC. 3F3Bh, Bit 3 = . 3F3Bh, Bit 2 = . 3F3Bh, Bit 1 = . 3F3Bh, Bit 0 = . 3F3Bh, Register on page = 443. 3F3Ah, Name = NCO1ACCU. 3F3Ah, Bit 7 = . 3F3Ah, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n. 3F3Ah, Bit 5 = . 3F3Ah, Bit 4 = ACC. 3F3Ah, Bit 3 = . 3F3Ah, Bit 2 = . 3F3Ah, Bit 1 = . 3F3Ah, Bit 0 = . 3F3Ah, Register on page = 443. 3F39h, Name = NCO1ACCH. 3F39h, Bit 7 = . 3F39h, Bit 6 = . 3F39h, Bit 5 = . 3F39h, Bit 4 = ACC. 3F39h, Bit 3 = . 3F39h, Bit 2 = . 3F39h, Bit 1 = . 3F39h, Bit 0 = . 3F39h, Register on page = 442. 3F38h, Name = NCO1ACCL. 3F38h, Bit 7 = . 3F38h, Bit 6 = . 3F38h, Bit 5 = . 3F38h, Bit 4 = ACC. 3F38h, Bit 3 = . 3F38h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n2 = . 3F38h, Bit 1 = . 3F38h, Bit 0 = . 3F38h, Register on page = 442\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1:\nNot present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F37h - 3F24h, Name = -. 3F37h - 3F24h, Bit 7 = Unimplemented. 3F37h - 3F24h, Bit 6 = Unimplemented. 3F37h - 3F24h, Bit 5 = Unimplemented. 3F37h - 3F24h, Bit 4 = Unimplemented. 3F37h - 3F24h, Bit 3 = Unimplemented. 3F37h - 3F24h, Bit 2 = Unimplemented. 3F37h - 3F24h, Bit 1 = Unimplemented. 3F37h - 3F24h, Bit 0 = Unimplemented. 3F37h - 3F24h, Register on page = -. 3F23h, Name = SMT1WIN. 3F23h, Bit 7 = -. 3F23h, Bit 6 = -. 3F23h, Bit 5 = -. 3F23h, Bit 4",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= . 3F23h, Bit 3 = . 3F23h, Bit 2 = WSEL. 3F23h, Bit 1 = . 3F23h, Bit 0 = . 3F23h, Register on page = 385. 3F22h, Name = SMT1SIG. 3F22h, Bit 7 = -. 3F22h, Bit 6 = -. 3F22h, Bit 5 = -. 3F22h, Bit 4 = . 3F22h, Bit 3 = . 3F22h, Bit 2 = SSEL. 3F22h, Bit 1 = . 3F22h, Bit 0 = . 3F22h, Register on page = 386. 3F21h, Name = SMT1CLK. 3F21h, Bit 7 = -. 3F21h, Bit 6 = -. 3F21h, Bit 5 = -. 3F21h, Bit 4 = -. 3F21h, Bit 3 = -. 3F21h, Bit 2 = . 3F21h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n1 = CSEL. 3F21h, Bit 0 = . 3F21h, Register on page = 384. 3F20h, Name = SMT1STAT. 3F20h, Bit 7 = CPRUP. 3F20h, Bit 6 = CPWUP. 3F20h, Bit 5 = RST. 3F20h, Bit 4 = -. 3F20h, Bit 3 = -. 3F20h, Bit 2 = TS. 3F20h, Bit 1 = WS. 3F20h, Bit 0 = AS. 3F20h, Register on page = 383. 3F1Fh, Name = SMT1CON1. 3F1Fh, Bit 7 = GO. 3F1Fh, Bit 6 = REPEAT. 3F1Fh, Bit 5 = -. 3F1Fh, Bit 4 = -. 3F1Fh, Bit 3 = . 3F1Fh, Bit 2 = . 3F1Fh, Bit 1 = MODE. 3F1Fh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 0 = . 3F1Fh, Register on page = 382. 3F1Eh, Name = SMT1CON0. 3F1Eh, Bit 7 = EN. 3F1Eh, Bit 6 = -. 3F1Eh, Bit 5 = STP. 3F1Eh, Bit 4 = WPOL. 3F1Eh, Bit 3 = SPOL. 3F1Eh, Bit 2 = CPOL. 3F1Eh, Bit 1 = . 3F1Eh, Bit 0 = PS. 3F1Eh, Register on page = 381. 3F1Dh, Name = SMT1PRU. 3F1Dh, Bit 7 = PR. 3F1Dh, Bit 6 = PR. 3F1Dh, Bit 5 = PR. 3F1Dh, Bit 4 = PR. 3F1Dh, Bit 3 = PR. 3F1Dh, Bit 2 = PR. 3F1Dh, Bit 1 = PR. 3F1Dh, Bit 0 = PR. 3F1Dh, Register on page = 388.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F1Ch, Name = SMT1PRH. 3F1Ch, Bit 7 = PR. 3F1Ch, Bit 6 = PR. 3F1Ch, Bit 5 = PR. 3F1Ch, Bit 4 = PR. 3F1Ch, Bit 3 = PR. 3F1Ch, Bit 2 = PR. 3F1Ch, Bit 1 = PR. 3F1Ch, Bit 0 = PR. 3F1Ch, Register on page = 390. 3F1Bh, Name = SMT1PRL. 3F1Bh, Bit 7 = PR. 3F1Bh, Bit 6 = PR. 3F1Bh, Bit 5 = PR. 3F1Bh, Bit 4 = PR. 3F1Bh, Bit 3 = PR. 3F1Bh, Bit 2 = PR. 3F1Bh, Bit 1 = PR. 3F1Bh, Bit 0 = PR. 3F1Bh, Register on page = 390. 3F1Ah, Name = SMT1CPWU. 3F1Ah, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCPW. 3F1Ah, Bit 6 = CPW. 3F1Ah, Bit 5 = CPW. 3F1Ah, Bit 4 = CPW. 3F1Ah, Bit 3 = CPW. 3F1Ah, Bit 2 = CPW. 3F1Ah, Bit 1 = CPW. 3F1Ah, Bit 0 = CPW. 3F1Ah, Register on page = 389. 3F19h, Name = SMT1CPWH. 3F19h, Bit 7 = CPW. 3F19h, Bit 6 = CPW. 3F19h, Bit 5 = CPW. 3F19h, Bit 4 = CPW. 3F19h, Bit 3 = CPW. 3F19h, Bit 2 = CPW. 3F19h, Bit 1 = CPW. 3F19h, Bit 0 = CPW. 3F19h, Register on page = 389. 3F18h, Name = SMT1CPWL. 3F18h, Bit 7 = CPW.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F18h, Bit 6 = CPW. 3F18h, Bit 5 = CPW. 3F18h, Bit 4 = CPW. 3F18h, Bit 3 = CPW. 3F18h, Bit 2 = CPW. 3F18h, Bit 1 = CPW. 3F18h, Bit 0 = CPW. 3F18h, Register on page = 389. 3F17h, Name = SMT1CPRU. 3F17h, Bit 7 = CPR. 3F17h, Bit 6 = CPR. 3F17h, Bit 5 = CPR. 3F17h, Bit 4 = CPR. 3F17h, Bit 3 = CPR. 3F17h, Bit 2 = CPR. 3F17h, Bit 1 = CPR. 3F17h, Bit 0 = CPR. 3F17h, Register on page = 388. 3F16h, Name = SMT1CPRH. 3F16h, Bit 7 = CPR. 3F16h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 6 = CPR. 3F16h, Bit 5 = CPR. 3F16h, Bit 4 = CPR. 3F16h, Bit 3 = CPR. 3F16h, Bit 2 = CPR. 3F16h, Bit 1 = CPR. 3F16h, Bit 0 = CPR. 3F16h, Register on page = 388. 3F15h, Name = SMT1CPRL. 3F15h, Bit 7 = CPR. 3F15h, Bit 6 = CPR. 3F15h, Bit 5 = CPR. 3F15h, Bit 4 = CPR. 3F15h, Bit 3 = CPR. 3F15h, Bit 2 = . 3F15h, Bit 1 = . 3F15h, Bit 0 = . 3F15h, Register on page = 388. 3F14h, Name = SMT1TMRU. 3F14h, Bit 7 = TMR. 3F14h, Bit 6 = TMR.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F14h, Bit 5 = TMR. 3F14h, Bit 4 = TMR. 3F14h, Bit 3 = TMR. 3F14h, Bit 2 = TMR. 3F14h, Bit 1 = TMR. 3F14h, Bit 0 = TMR. 3F14h, Register on page = 387. 3F13h, Name = SMT1TMRH. 3F13h, Bit 7 = TMR. 3F13h, Bit 6 = TMR. 3F13h, Bit 5 = TMR. 3F13h, Bit 4 = TMR. 3F13h, Bit 3 = TMR. 3F13h, Bit 2 = TMR. 3F13h, Bit 1 = TMR. 3F13h, Bit 0 = TMR. 3F13h, Register on page = 387. 3F12h, Name = SMT1TMRL. 3F12h, Bit 7 = TMR.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F12h, Bit 6 = TMR. 3F12h, Bit 5 = TMR. 3F12h, Bit 4 = TMR. 3F12h, Bit 3 = TMR. 3F12h, Bit 2 = TMR. 3F12h, Bit 1 = TMR. 3F12h, Bit 0 = TMR. 3F12h, Register on page = 387. 3F11h, Name = SMT2WIN. 3F11h, Bit 7 = -. 3F11h, Bit 6 = -. 3F11h, Bit 5 = -. 3F11h, Bit 4 = WSEL. 3F11h, Bit 3 = WSEL. 3F11h, Bit 2 = WSEL. 3F11h, Bit 1 = WSEL. 3F11h, Bit 0 = WSEL. 3F11h, Register on page = 385. 3F10h, Name = SMT2SIG. 3F10h, Bit 7 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F10h, Bit 6 = -. 3F10h, Bit 5 = -. 3F10h, Bit 4 = SSEL. 3F10h, Bit 3 = SSEL. 3F10h, Bit 2 = SSEL. 3F10h, Bit 1 = SSEL. 3F10h, Bit 0 = SSEL. 3F10h, Register on page = 386. 3F0Fh, Name = SMT2CLK. 3F0Fh, Bit 7 = -. 3F0Fh, Bit 6 = -. 3F0Fh, Bit 5 = -. 3F0Fh, Bit 4 = -. 3F0Fh, Bit 3 = -. 3F0Fh, Bit 2 = CSEL. 3F0Fh, Bit 1 = CSEL. 3F0Fh, Bit 0 = CSEL. 3F0Fh, Register on page = 384. 3F0Eh, Name = SMT2STAT. 3F0Eh, Bit 7 = CPRUP.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F0Eh, Bit 6 = CPWUP. 3F0Eh, Bit 5 = RST. 3F0Eh, Bit 4 = -. 3F0Eh, Bit 3 = -. 3F0Eh, Bit 2 = TS. 3F0Eh, Bit 1 = WS. 3F0Eh, Bit 0 = AS. 3F0Eh, Register on page = 383. 3F0Dh, Name = SMT2CON1. 3F0Dh, Bit 7 = GO. 3F0Dh, Bit 6 = REPEAT. 3F0Dh, Bit 5 = -. 3F0Dh, Bit 4 = -. 3F0Dh, Bit 3 = . 3F0Dh, Bit 2 = MODE. 3F0Dh, Bit 1 = MODE. 3F0Dh, Bit 0 = MODE. 3F0Dh, Register on page = 382. 3F0Ch, Name = SMT2CON0. 3F0Ch, Bit 7 = EN. 3F0Ch, Bit 6 = -. 3F0Ch, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSTP. 3F0Ch, Bit 4 = WPOL. 3F0Ch, Bit 3 = SPOL. 3F0Ch, Bit 2 = CPOL. 3F0Ch, Bit 1 = . 3F0Ch, Bit 0 = PS. 3F0Ch, Register on page = 381. 3F0Bh, Name = SMT2PRU. 3F0Bh, Bit 7 = PR. 3F0Bh, Bit 6 = PR. 3F0Bh, Bit 5 = PR. 3F0Bh, Bit 4 = PR. 3F0Bh, Bit 3 = PR. 3F0Bh, Bit 2 = PR. 3F0Bh, Bit 1 = PR. 3F0Bh, Bit 0 = PR. 3F0Bh, Register on page = 388. 3F0Ah, Name = SMT2PRH. 3F0Ah, Bit 7 = PR. 3F0Ah, Bit 6 = PR. 3F0Ah, Bit 5 = PR. 3F0Ah, Bit 4 = PR. 3F0Ah, Bit 3",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= PR. 3F0Ah, Bit 2 = PR. 3F0Ah, Bit 1 = PR. 3F0Ah, Bit 0 = PR. 3F0Ah, Register on page = 390. 3F09h, Name = SMT2PRL. 3F09h, Bit 7 = PR. 3F09h, Bit 6 = PR. 3F09h, Bit 5 = PR. 3F09h, Bit 4 = PR. 3F09h, Bit 3 = PR. 3F09h, Bit 2 = PR. 3F09h, Bit 1 = PR. 3F09h, Bit 0 = PR. 3F09h, Register on page = 390. 3F08h, Name = SMT2CPWU. 3F08h, Bit 7 = CPW. 3F08h, Bit 6 = CPW. 3F08h, Bit 5 = CPW. 3F08h, Bit 4 = CPW. 3F08h, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCPW. 3F08h, Bit 2 = CPW. 3F08h, Bit 1 = CPW. 3F08h, Bit 0 = CPW. 3F08h, Register on page = 389. 3F07h, Name = SMT2CPWH. 3F07h, Bit 7 = CPW. 3F07h, Bit 6 = CPW. 3F07h, Bit 5 = CPW. 3F07h, Bit 4 = CPW. 3F07h, Bit 3 = CPW. 3F07h, Bit 2 = CPW. 3F07h, Bit 1 = CPW. 3F07h, Bit 0 = CPW. 3F07h, Register on page = 389. 3F06h, Name = SMT2CPWL. 3F06h, Bit 7 = CPW. 3F06h, Bit 6 = CPW. 3F06h, Bit 5 = CPW.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3F06h, Bit 4 = CPW. 3F06h, Bit 3 = CPW. 3F06h, Bit 2 = CPW. 3F06h, Bit 1 = CPW. 3F06h, Bit 0 = CPW. 3F06h, Register on page = 389. 3F05h, Name = SMT2CPRU. 3F05h, Bit 7 = CPR. 3F05h, Bit 6 = CPR. 3F05h, Bit 5 = CPR. 3F05h, Bit 4 = CPR. 3F05h, Bit 3 = CPR. 3F05h, Bit 2 = CPR. 3F05h, Bit 1 = CPR. 3F05h, Bit 0 = CPR. 3F05h, Register on page = 388. 3F04h, Name = SMT2CPRH. 3F04h, Bit 7 = CPR. 3F04h, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCPR. 3F04h, Bit 5 = CPR. 3F04h, Bit 4 = CPR. 3F04h, Bit 3 = CPR. 3F04h, Bit 2 = CPR. 3F04h, Bit 1 = CPR. 3F04h, Bit 0 = CPR. 3F04h, Register on page = 388. 3F03h, Name = SMT2CPRL. 3F03h, Bit 7 = CPR. 3F03h, Bit 6 = CPR. 3F03h, Bit 5 = CPR. 3F03h, Bit 4 = CPR. 3F03h, Bit 3 = CPR. 3F03h, Bit 2 = CPR. 3F03h, Bit 1 = CPR. 3F03h, Bit 0 = CPR. 3F03h, Register on page = 388. 3F02h, Name = SMT2TMRU. 3F02h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 7 = TMR. 3F02h, Bit 6 = TMR. 3F02h, Bit 5 = TMR. 3F02h, Bit 4 = TMR. 3F02h, Bit 3 = TMR. 3F02h, Bit 2 = TMR. 3F02h, Bit 1 = TMR. 3F02h, Bit 0 = TMR. 3F02h, Register on page = 387. 3F01h, Name = SMT2TMRH. 3F01h, Bit 7 = TMR. 3F01h, Bit 6 = TMR. 3F01h, Bit 5 = TMR. 3F01h, Bit 4 = TMR. 3F01h, Bit 3 = TMR. 3F01h, Bit 2 = TMR. 3F01h, Bit 1 = TMR. 3F01h, Bit 0 = TMR. 3F01h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n387. 3F00h, Name = SMT2TMRL. 3F00h, Bit 7 = TMR. 3F00h, Bit 6 = TMR. 3F00h, Bit 5 = TMR. 3F00h, Bit 4 = TMR. 3F00h, Bit 3 = TMR. 3F00h, Bit 2 = TMR. 3F00h, Bit 1 = TMR. 3F00h, Bit 0 = TMR. 3F00h, Register on page = 387. 3EFFh, Name = ADCLK. 3EFFh, Bit 7 = -. 3EFFh, Bit 6 = -. 3EFFh, Bit 5 = CS. 3EFFh, Bit 4 = CS. 3EFFh, Bit 3 = CS. 3EFFh, Bit 2 = CS. 3EFFh, Bit 1 = CS. 3EFFh, Bit 0 = CS. 3EFFh, Register on page = 676. 3EFEh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nName = ADACT. 3EFEh, Bit 7 = -. 3EFEh, Bit 6 = -. 3EFEh, Bit 5 = -. 3EFEh, Bit 4 = ACT. 3EFEh, Bit 3 = ACT. 3EFEh, Bit 2 = ACT. 3EFEh, Bit 1 = ACT. 3EFEh, Bit 0 = ACT. 3EFEh, Register on page = 676. 3EFDh, Name = ADREF. 3EFDh, Bit 7 = . 3EFDh, Bit 6 = NREF PREF. 3EFDh, Bit 5 = NREF PREF. 3EFDh, Bit 4 = NREF PREF. 3EFDh, Bit 3 = NREF PREF. 3EFDh, Bit 2 = NREF PREF. 3EFDh, Bit 1 = NREF PREF. 3EFDh, Bit 0 = NREF PREF. 3EFDh, Register on page = 676. 3EFCh, Name = ADSTAT. 3EFCh, Bit 7 = ADAOV. 3EFCh, Bit 6 = UTHR.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EFCh, Bit 5 = LTHR. 3EFCh, Bit 4 = MATH. 3EFCh, Bit 3 = -. 3EFCh, Bit 2 = . 3EFCh, Bit 1 = STAT. 3EFCh, Bit 0 = . 3EFCh, Register on page = 675. 3EFBh, Name = ADCON3. 3EFBh, Bit 7 = -. 3EFBh, Bit 6 = . 3EFBh, Bit 5 = CALC. 3EFBh, Bit 4 = . 3EFBh, Bit 3 = SOI. 3EFBh, Bit 2 = . 3EFBh, Bit 1 = TMD. 3EFBh, Bit 0 = . 3EFBh, Register on page = 674. 3EFAh, Name = ADCON2. 3EFAh, Bit 7 = PSIS. 3EFAh, Bit 6 = . 3EFAh, Bit 5 = CRS. 3EFAh, Bit 4 = . 3EFAh, Bit 3 = ACLR. 3EFAh, Bit 2 = . 3EFAh, Bit 1 = MODE.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EFAh, Bit 0 = . 3EFAh, Register on page = 673. 3EF9h, Name = ADCON1. 3EF9h, Bit 7 = PPOL. 3EF9h, Bit 6 = IPEN. 3EF9h, Bit 5 = GPOL. 3EF9h, Bit 4 = -. 3EF9h, Bit 3 = -. 3EF9h, Bit 2 = -. 3EF9h, Bit 1 = -. 3EF9h, Bit 0 = DSEN. 3EF9h, Register on page = 672. 3EF8h, Name = ADCON0. 3EF8h, Bit 7 = ON. 3EF8h, Bit 6 = CONT. 3EF8h, Bit 5 = -. 3EF8h, Bit 4 = CS FM. 3EF8h, Bit 3 = CS FM. 3EF8h, Bit 2 = CS FM. 3EF8h, Bit 1 = -. 3EF8h, Bit 0 = GO. 3EF8h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n671. 3EF7h, Name = ADPREH. 3EF7h, Bit 7 = -. 3EF7h, Bit 6 = -. 3EF7h, Bit 5 = -. 3EF7h, Bit 4 = PRE. 3EF7h, Bit 3 = PRE. 3EF7h, Bit 2 = PRE. 3EF7h, Bit 1 = PRE. 3EF7h, Bit 0 = PRE. 3EF7h, Register on page = 678 678. 3EF6h, Name = ADPREL. 3EF6h, Bit 7 = . 3EF6h, Bit 6 = . 3EF6h, Bit 5 = . 3EF6h, Bit 4 = PRE. 3EF6h, Bit 3 = PRE. 3EF6h, Bit 2 = PRE. 3EF6h, Bit 1 = PRE. 3EF6h, Bit 0 = PRE. 3EF6h, Register on page = . 3EF5h, Name = ADCAP. 3EF5h, Bit 7 = -. 3EF5h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 6 = -. 3EF5h, Bit 5 = -. 3EF5h, Bit 4 = ADCAP. 3EF5h, Bit 3 = ADCAP. 3EF5h, Bit 2 = ADCAP. 3EF5h, Bit 1 = ADCAP. 3EF5h, Bit 0 = ADCAP. 3EF5h, Register on page = 680. 3EF4h, Name = ADACQH. 3EF4h, Bit 7 = -. 3EF4h, Bit 6 = -. 3EF4h, Bit 5 = -. 3EF4h, Bit 4 = ACQ. 3EF4h, Bit 3 = ACQ. 3EF4h, Bit 2 = ACQ. 3EF4h, Bit 1 = ACQ. 3EF4h, Bit 0 = ACQ. 3EF4h, Register on page = 679\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nLegend: Note 1: Not present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nDS40001943C-page 773",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EF3h, Name = ADACQL. 3EF3h, Bit 7 = ACQ. 3EF3h, Bit 6 = ACQ. 3EF3h, Bit 5 = ACQ. 3EF3h, Bit 4 = ACQ. 3EF3h, Bit 3 = ACQ. 3EF3h, Bit 2 = ACQ. 3EF3h, Bit 1 = ACQ. 3EF3h, Bit 0 = ACQ. 3EF3h, Register on page = 679. 3EF2h, Name = -. 3EF2h, Bit 7 = Unimplemented. 3EF2h, Bit 6 = Unimplemented. 3EF2h, Bit 5 = Unimplemented. 3EF2h, Bit 4 = Unimplemented. 3EF2h, Bit 3 = Unimplemented. 3EF2h, Bit 2 = Unimplemented. 3EF2h, Bit 1 = Unimplemented. 3EF2h, Bit 0 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nUnimplemented. 3EF2h, Register on page = -. 3EF1h, Name = ADPCH. 3EF1h, Bit 7 = -. 3EF1h, Bit 6 = -. 3EF1h, Bit 5 = . 3EF1h, Bit 4 = . 3EF1h, Bit 3 = ADPCH. 3EF1h, Bit 2 = . 3EF1h, Bit 1 = . 3EF1h, Bit 0 = . 3EF1h, Register on page = 677. 3EF0h, Name = ADRESH. 3EF0h, Bit 7 = RES. 3EF0h, Bit 6 = RES. 3EF0h, Bit 5 = RES. 3EF0h, Bit 4 = RES. 3EF0h, Bit 3 = RES. 3EF0h, Bit 2 = RES. 3EF0h, Bit 1 = RES. 3EF0h, Bit 0 = RES. 3EF0h, Register on page = 682. 3EEFh, Name = ADRESL.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EEFh, Bit 7 = RES. 3EEFh, Bit 6 = RES. 3EEFh, Bit 5 = RES. 3EEFh, Bit 4 = RES. 3EEFh, Bit 3 = RES. 3EEFh, Bit 2 = RES. 3EEFh, Bit 1 = RES. 3EEFh, Bit 0 = RES. 3EEFh, Register on page = 682. 3EEEh, Name = ADPREVH. 3EEEh, Bit 7 = PREV. 3EEEh, Bit 6 = PREV. 3EEEh, Bit 5 = PREV. 3EEEh, Bit 4 = PREV. 3EEEh, Bit 3 = PREV. 3EEEh, Bit 2 = PREV. 3EEEh, Bit 1 = PREV. 3EEEh, Bit 0 = PREV. 3EEEh, Register on page = 684. 3EEDh, Name = ADPREVL. 3EEDh, Bit 7 = PREV. 3EEDh, Bit 6 = PREV. 3EEDh, Bit 5",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= PREV. 3EEDh, Bit 4 = PREV. 3EEDh, Bit 3 = PREV. 3EEDh, Bit 2 = PREV. 3EEDh, Bit 1 = PREV. 3EEDh, Bit 0 = PREV. 3EEDh, Register on page = 684. 3EECh, Name = ADRPT. 3EECh, Bit 7 = RPT. 3EECh, Bit 6 = RPT. 3EECh, Bit 5 = RPT. 3EECh, Bit 4 = RPT. 3EECh, Bit 3 = RPT. 3EECh, Bit 2 = RPT. 3EECh, Bit 1 = RPT. 3EECh, Bit 0 = RPT. 3EECh, Register on page = 680. 3EEBh, Name = ADCNT. 3EEBh, Bit 7 = CNT. 3EEBh, Bit 6 = CNT. 3EEBh, Bit 5 = CNT. 3EEBh, Bit 4 = CNT. 3EEBh, Bit 3 = CNT. 3EEBh, Bit 2",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= CNT. 3EEBh, Bit 1 = CNT. 3EEBh, Bit 0 = CNT. 3EEBh, Register on page = 681. 3EEAh, Name = ADACCU. 3EEAh, Bit 7 = ACC. 3EEAh, Bit 6 = ACC. 3EEAh, Bit 5 = ACC. 3EEAh, Bit 4 = ACC. 3EEAh, Bit 3 = ACC. 3EEAh, Bit 2 = ACC. 3EEAh, Bit 1 = ACC. 3EEAh, Bit 0 = ACC. 3EEAh, Register on page = 685. 3EE9h, Name = ADACCH. 3EE9h, Bit 7 = ACC. 3EE9h, Bit 6 = ACC. 3EE9h, Bit 5 = ACC. 3EE9h, Bit 4 = ACC. 3EE9h, Bit 3 = ACC. 3EE9h, Bit 2 = ACC. 3EE9h, Bit 1 = ACC. 3EE9h, Bit 0 = ACC. 3EE9h, Register on page = 685.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EE8h, Name = ADACCL. 3EE8h, Bit 7 = ACC. 3EE8h, Bit 6 = ACC. 3EE8h, Bit 5 = ACC. 3EE8h, Bit 4 = ACC. 3EE8h, Bit 3 = ACC. 3EE8h, Bit 2 = ACC. 3EE8h, Bit 1 = ACC. 3EE8h, Bit 0 = ACC. 3EE8h, Register on page = 685. 3EE7h, Name = ADFLTRH. 3EE7h, Bit 7 = FLTR. 3EE7h, Bit 6 = FLTR. 3EE7h, Bit 5 = FLTR. 3EE7h, Bit 4 = FLTR. 3EE7h, Bit 3 = FLTR. 3EE7h, Bit 2 = FLTR. 3EE7h, Bit 1 = FLTR. 3EE7h, Bit 0 = FLTR. 3EE7h, Register on page = 681. 3EE6h, Name = ADFLTRL.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EE6h, Bit 7 = FLTR. 3EE6h, Bit 6 = FLTR. 3EE6h, Bit 5 = FLTR. 3EE6h, Bit 4 = FLTR. 3EE6h, Bit 3 = FLTR. 3EE6h, Bit 2 = FLTR. 3EE6h, Bit 1 = FLTR. 3EE6h, Bit 0 = FLTR. 3EE6h, Register on page = 681. 3EE5h, Name = ADSTPTH. 3EE5h, Bit 7 = STPT. 3EE5h, Bit 6 = STPT. 3EE5h, Bit 5 = STPT. 3EE5h, Bit 4 = STPT. 3EE5h, Bit 3 = STPT. 3EE5h, Bit 2 = STPT. 3EE5h, Bit 1 = STPT. 3EE5h, Bit 0 = STPT. 3EE5h, Register on page = 686. 3EE4h, Name = ADSTPTL. 3EE4h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSTPT. 3EE4h, Bit 6 = STPT. 3EE4h, Bit 5 = STPT. 3EE4h, Bit 4 = STPT. 3EE4h, Bit 3 = STPT. 3EE4h, Bit 2 = STPT. 3EE4h, Bit 1 = STPT. 3EE4h, Bit 0 = STPT. 3EE4h, Register on page = 686. 3EE3h, Name = ADERRH. 3EE3h, Bit 7 = ERR. 3EE3h, Bit 6 = ERR. 3EE3h, Bit 5 = ERR. 3EE3h, Bit 4 = ERR. 3EE3h, Bit 3 = ERR. 3EE3h, Bit 2 = ERR. 3EE3h, Bit 1 = ERR. 3EE3h, Bit 0 = ERR. 3EE3h, Register on page = 687. 3EE2h, Name = ADERRL. 3EE2h, Bit 7 = ERR. 3EE2h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n6 = ERR. 3EE2h, Bit 5 = ERR. 3EE2h, Bit 4 = ERR. 3EE2h, Bit 3 = ERR. 3EE2h, Bit 2 = ERR. 3EE2h, Bit 1 = ERR. 3EE2h, Bit 0 = ERR. 3EE2h, Register on page = 687. 3EE1h, Name = ADUTHH. 3EE1h, Bit 7 = UTH. 3EE1h, Bit 6 = UTH. 3EE1h, Bit 5 = UTH. 3EE1h, Bit 4 = UTH. 3EE1h, Bit 3 = UTH. 3EE1h, Bit 2 = UTH. 3EE1h, Bit 1 = UTH. 3EE1h, Bit 0 = UTH. 3EE1h, Register on page = 688. 3EE0h, Name = ADUTHL. 3EE0h, Bit 7 = UTH. 3EE0h, Bit 6 = UTH.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EE0h, Bit 5 = UTH. 3EE0h, Bit 4 = UTH. 3EE0h, Bit 3 = UTH. 3EE0h, Bit 2 = UTH. 3EE0h, Bit 1 = UTH. 3EE0h, Bit 0 = UTH. 3EE0h, Register on page = 688. 3EDFh, Name = ADLTHH. 3EDFh, Bit 7 = LTH. 3EDFh, Bit 6 = LTH. 3EDFh, Bit 5 = LTH. 3EDFh, Bit 4 = LTH. 3EDFh, Bit 3 = LTH. 3EDFh, Bit 2 = LTH. 3EDFh, Bit 1 = LTH. 3EDFh, Bit 0 = LTH. 3EDFh, Register on page = 687. 3EDEh, Name = ADLTHL. 3EDEh, Bit 7 = LTH. 3EDEh, Bit 6 = LTH. 3EDEh, Bit 5 = LTH.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EDEh, Bit 4 = LTH. 3EDEh, Bit 3 = LTH. 3EDEh, Bit 2 = LTH. 3EDEh, Bit 1 = LTH. 3EDEh, Bit 0 = LTH. 3EDEh, Register on page = 688. 3EDDh - 3ED8h, Name = -. 3EDDh - 3ED8h, Bit 7 = Unimplemented. 3EDDh - 3ED8h, Bit 6 = Unimplemented. 3EDDh - 3ED8h, Bit 5 = Unimplemented. 3EDDh - 3ED8h, Bit 4 = Unimplemented. 3EDDh - 3ED8h, Bit 3 = Unimplemented. 3EDDh - 3ED8h, Bit 2 = Unimplemented. 3EDDh - 3ED8h, Bit 1 = Unimplemented. 3EDDh - 3ED8h, Bit 0 = Unimplemented. 3EDDh - 3ED8h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n-. 3ED7h, Name = ADCP. 3ED7h, Bit 7 = ON. 3ED7h, Bit 6 = -. 3ED7h, Bit 5 = -. 3ED7h, Bit 4 = -. 3ED7h, Bit 3 = -. 3ED7h, Bit 2 = -. 3ED7h, Bit 1 = -. 3ED7h, Bit 0 = CPRDY. 3ED7h, Register on page = 690. 3ED6h- 3ECBh, Name = -. 3ED6h- 3ECBh, Bit 7 = Unimplemented. 3ED6h- 3ECBh, Bit 6 = Unimplemented. 3ED6h- 3ECBh, Bit 5 = Unimplemented. 3ED6h- 3ECBh, Bit 4 = Unimplemented. 3ED6h- 3ECBh, Bit 3 = Unimplemented. 3ED6h- 3ECBh, Bit 2 = Unimplemented. 3ED6h-",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3ECBh, Bit 1 = Unimplemented. 3ED6h- 3ECBh, Bit 0 = Unimplemented. 3ED6h- 3ECBh, Register on page = -. 3ECAh, Name = HLVDCON1. 3ECAh, Bit 7 = -. 3ECAh, Bit 6 = -. 3ECAh, Bit 5 = -. 3ECAh, Bit 4 = -. 3ECAh, Bit 3 = . 3ECAh, Bit 2 = SEL. 3ECAh, Bit 1 = SEL. 3ECAh, Bit 0 = SEL. 3ECAh, Register on page = 712. 3EC9h, Name = HLVDCON0. 3EC9h, Bit 7 = EN. 3EC9h, Bit 6 = -. 3EC9h, Bit 5 = OUT. 3EC9h, Bit 4 = RDY. 3EC9h, Bit 3 = -. 3EC9h, Bit 2 = -. 3EC9h, Bit 1 = INTH.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EC9h, Bit 0 = INTL. 3EC9h, Register on page = 711. 3EC8h- 3EC4h, Name = -. 3EC8h- 3EC4h, Bit 7 = Unimplemented. 3EC8h- 3EC4h, Bit 6 = Unimplemented. 3EC8h- 3EC4h, Bit 5 = Unimplemented. 3EC8h- 3EC4h, Bit 4 = Unimplemented. 3EC8h- 3EC4h, Bit 3 = Unimplemented. 3EC8h- 3EC4h, Bit 2 = Unimplemented. 3EC8h- 3EC4h, Bit 1 = Unimplemented. 3EC8h- 3EC4h, Bit 0 = Unimplemented. 3EC8h- 3EC4h, Register on page = -. 3EC3h, Name = ZCDCON. 3EC3h, Bit 7 = SEN. 3EC3h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 6 = -. 3EC3h, Bit 5 = OUT. 3EC3h, Bit 4 = POL. 3EC3h, Bit 3 = -. 3EC3h, Bit 2 = -. 3EC3h, Bit 1 = INTP. 3EC3h, Bit 0 = INTN. 3EC3h, Register on page = 449. 3EC2h, Name = -. 3EC2h, Bit 7 = Unimplemented. 3EC2h, Bit 6 = Unimplemented. 3EC2h, Bit 5 = Unimplemented. 3EC2h, Bit 4 = Unimplemented. 3EC2h, Bit 3 = Unimplemented. 3EC2h, Bit 2 = Unimplemented. 3EC2h, Bit 1 = Unimplemented. 3EC2h, Bit 0 = Unimplemented. 3EC2h, Register on page = -. 3EC1h, Name = FVRCON. 3EC1h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nEN. 3EC1h, Bit 6 = RDY. 3EC1h, Bit 5 = TSEN. 3EC1h, Bit 4 = TSRNG. 3EC1h, Bit 3 = CDAFVR. 3EC1h, Bit 2 = CDAFVR. 3EC1h, Bit 1 = ADFVR. 3EC1h, Bit 0 = ADFVR. 3EC1h, Register on page = 651. 3EC0h, Name = CMOUT. 3EC0h, Bit 7 = -. 3EC0h, Bit 6 = -. 3EC0h, Bit 5 = -. 3EC0h, Bit 4 = -. 3EC0h, Bit 3 = -. 3EC0h, Bit 2 = -. 3EC0h, Bit 1 = C2OUT. 3EC0h, Bit 0 = C1OUT. 3EC0h, Register on page = 704. 3EBFh, Name = CM1PCH. 3EBFh, Bit 7 = -. 3EBFh, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n-. 3EBFh, Bit 5 = -. 3EBFh, Bit 4 = -. 3EBFh, Bit 3 = -. 3EBFh, Bit 2 = . 3EBFh, Bit 1 = PCH. 3EBFh, Bit 0 = . 3EBFh, Register on page = 704. 3EBEh, Name = CM1NCH. 3EBEh, Bit 7 = -. 3EBEh, Bit 6 = -. 3EBEh, Bit 5 = -. 3EBEh, Bit 4 = -. 3EBEh, Bit 3 = -. 3EBEh, Bit 2 = . 3EBEh, Bit 1 = NCH. 3EBEh, Bit 0 = . 3EBEh, Register on page = 703. 3EBDh, Name = CM1CON1. 3EBDh, Bit 7 = -. 3EBDh, Bit 6 = -. 3EBDh, Bit 5 = -. 3EBDh, Bit 4 = -. 3EBDh, Bit 3 = -. 3EBDh, Bit 2 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EBDh, Bit 1 = INTP. 3EBDh, Bit 0 = INTN. 3EBDh, Register on page = 703. 3EBCh, Name = CM1CON0. 3EBCh, Bit 7 = EN. 3EBCh, Bit 6 = OUT. 3EBCh, Bit 5 = -. 3EBCh, Bit 4 = POL. 3EBCh, Bit 3 = -. 3EBCh, Bit 2 = -. 3EBCh, Bit 1 = HYS. 3EBCh, Bit 0 = SYNC. 3EBCh, Register on page = 702. 3EBBh, Name = CM2PCH. 3EBBh, Bit 7 = -. 3EBBh, Bit 6 = -. 3EBBh, Bit 5 = -. 3EBBh, Bit 4 = -. 3EBBh, Bit 3 = -. 3EBBh, Bit 2 = . 3EBBh, Bit 1 = PCH. 3EBBh, Bit 0 = . 3EBBh, Register on page = 704. 3EBAh, Name = CM2NCH.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EBAh, Bit 7 = -. 3EBAh, Bit 6 = -. 3EBAh, Bit 5 = -. 3EBAh, Bit 4 = -. 3EBAh, Bit 3 = -. 3EBAh, Bit 2 = . 3EBAh, Bit 1 = NCH. 3EBAh, Bit 0 = . 3EBAh, Register on page = 703. 3EB9h, Name = CM2CON1. 3EB9h, Bit 7 = -. 3EB9h, Bit 6 = -. 3EB9h, Bit 5 = -. 3EB9h, Bit 4 = -. 3EB9h, Bit 3 = -. 3EB9h, Bit 2 = -. 3EB9h, Bit 1 = INTP. 3EB9h, Bit 0 = INTN. 3EB9h, Register on page = 703. 3EB8h, Name = CM2CON0. 3EB8h, Bit 7 = EN. 3EB8h, Bit 6 = OUT. 3EB8h, Bit 5 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3EB8h, Bit 4 = POL. 3EB8h, Bit 3 = -. 3EB8h, Bit 2 = -. 3EB8h, Bit 1 = HYS. 3EB8h, Bit 0 = SYNC. 3EB8h, Register on page = 702. 3EB7h- 3E9Fh, Name = -. 3EB7h- 3E9Fh, Bit 7 = Unimplemented. 3EB7h- 3E9Fh, Bit 6 = Unimplemented. 3EB7h- 3E9Fh, Bit 5 = Unimplemented. 3EB7h- 3E9Fh, Bit 4 = Unimplemented. 3EB7h- 3E9Fh, Bit 3 = Unimplemented. 3EB7h- 3E9Fh, Bit 2 = Unimplemented. 3EB7h- 3E9Fh, Bit 1 = Unimplemented. 3EB7h- 3E9Fh, Bit 0",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= Unimplemented. 3EB7h- 3E9Fh, Register on page = -. 3E9Eh, Name = DAC1CON0. 3E9Eh, Bit 7 = EN. 3E9Eh, Bit 6 = -. 3E9Eh, Bit 5 = OE1. 3E9Eh, Bit 4 = OE2. 3E9Eh, Bit 3 = . 3E9Eh, Bit 2 = PSS. 3E9Eh, Bit 1 = -. 3E9Eh, Bit 0 = NSS. 3E9Eh, Register on page = 694. 3E9Dh, Name = -. 3E9Dh, Bit 7 = Unimplemented. 3E9Dh, Bit 6 = Unimplemented. 3E9Dh, Bit 5 = Unimplemented. 3E9Dh, Bit 4 = Unimplemented. 3E9Dh, Bit 3 = Unimplemented. 3E9Dh, Bit 2 = Unimplemented.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3E9Dh, Bit 1 = Unimplemented. 3E9Dh, Bit 0 = Unimplemented. 3E9Dh, Register on page = -. 3E9Ch, Name = DAC1CON1. 3E9Ch, Bit 7 = -. 3E9Ch, Bit 6 = -. 3E9Ch, Bit 5 = -. 3E9Ch, Bit 4 = . 3E9Ch, Bit 3 = . 3E9Ch, Bit 2 = DATA. 3E9Ch, Bit 1 = . 3E9Ch, Bit 0 = . 3E9Ch, Register on page = 695. 3E9Bh-, Name = . 3E9Bh-, Bit 7 = Unimplemented. 3E9Bh-, Bit 6 = Unimplemented. 3E9Bh-, Bit 5 = Unimplemented. 3E9Bh-, Bit 4 = Unimplemented. 3E9Bh-, Bit 3 = Unimplemented. 3E9Bh-, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n2 = Unimplemented. 3E9Bh-, Bit 1 = Unimplemented. 3E9Bh-, Bit 0 = Unimplemented. 3E9Bh-, Register on page = . , Name = -. , Bit 7 = . , Bit 6 = . , Bit 5 = ABDOVE. , Bit 4 = . , Bit 3 = . , Bit 2 = RXBKIE. , Bit 1 = . , Bit 0 = . , Register on page = . 3DFBh, Name = . 3DFBh, Bit 7 = . 3DFBh, Bit 6 = . 3DFBh, Bit 5 = . 3DFBh, Bit 4 = . 3DFBh, Bit 3 = . 3DFBh, Bit 2 = . 3DFBh, Bit 1 = . 3DFBh, Bit 0 = . 3DFBh, Register on page = . 3DFAh, Name = U1ERRIE. 3DFAh, Bit 7 = TXMTIE. 3DFAh, Bit 6 = PERIE. 3DFAh, Bit 5 = . 3DFAh, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n4 = CERIE. 3DFAh, Bit 3 = FERIE. 3DFAh, Bit 2 = . 3DFAh, Bit 1 = RXFOIE. 3DFAh, Bit 0 = TXCIE. 3DFAh, Register on page = 488\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nLegend: Note 1: Not present in LF devices.\nDS40001943C-page 774",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DF9h, Name = U1ERRIR. 3DF9h, Bit 7 = TXMTIF. 3DF9h, Bit 6 = PERIF ABDOVF. 3DF9h, Bit 5 = . 3DF9h, Bit 4 = CERIF. 3DF9h, Bit 3 = FERIF. 3DF9h, Bit 2 = RXBKIF. 3DF9h, Bit 1 = RXFOIF. 3DF9h, Bit 0 = TXCIF. 3DF9h, Register on page = 487. 3DF8h, Name = U1UIR. 3DF8h, Bit 7 = WUIF. 3DF8h, Bit 6 = ABDIF. 3DF8h, Bit 5 = -. 3DF8h, Bit 4 = -. 3DF8h, Bit 3 = -. 3DF8h, Bit 2 = ABDIE. 3DF8h, Bit 1 = -. 3DF8h, Bit 0 = -. 3DF8h, Register on page = 489.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DF7h, Name = U1FIFO. 3DF7h, Bit 7 = TXWRE. 3DF7h, Bit 6 = STPMD. 3DF7h, Bit 5 = TXBE. 3DF7h, Bit 4 = TXBF. 3DF7h, Bit 3 = RXIDL. 3DF7h, Bit 2 = XON. 3DF7h, Bit 1 = RXBE. 3DF7h, Bit 0 = RXBF. 3DF7h, Register on page = 490. 3DF6h, Name = U1BRGH. 3DF6h, Bit 7 = BRGH. 3DF6h, Bit 6 = BRGH. 3DF6h, Bit 5 = BRGH. 3DF6h, Bit 4 = BRGH. 3DF6h, Bit 3 = BRGH. 3DF6h, Bit 2 = BRGH. 3DF6h, Bit 1 = BRGH. 3DF6h, Bit 0 = BRGH. 3DF6h, Register on page = 491.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DF5h, Name = U1BRGL. 3DF5h, Bit 7 = BRGL. 3DF5h, Bit 6 = BRGL. 3DF5h, Bit 5 = BRGL. 3DF5h, Bit 4 = BRGL. 3DF5h, Bit 3 = BRGL. 3DF5h, Bit 2 = BRGL. 3DF5h, Bit 1 = BRGL. 3DF5h, Bit 0 = BRGL. 3DF5h, Register on page = 491. 3DF4h, Name = U1CON2. 3DF4h, Bit 7 = RUNOVF. 3DF4h, Bit 6 = RXPOL. 3DF4h, Bit 5 = STP. 3DF4h, Bit 4 = STP. 3DF4h, Bit 3 = C0EN. 3DF4h, Bit 2 = TXPOL. 3DF4h, Bit 1 = FLO. 3DF4h, Bit 0 = FLO. 3DF4h, Register on page = 486.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DF3h, Name = U1CON1. 3DF3h, Bit 7 = ON. 3DF3h, Bit 6 = -. 3DF3h, Bit 5 = -. 3DF3h, Bit 4 = WUE. 3DF3h, Bit 3 = RXBIMD. 3DF3h, Bit 2 = -. 3DF3h, Bit 1 = BRKOVR. 3DF3h, Bit 0 = SENDB. 3DF3h, Register on page = 485. 3DF2h, Name = U1CON0. 3DF2h, Bit 7 = BRGS. 3DF2h, Bit 6 = ABDEN. 3DF2h, Bit 5 = TXEN. 3DF2h, Bit 4 = RXEN. 3DF2h, Bit 3 = . 3DF2h, Bit 2 = MODE. 3DF2h, Bit 1 = MODE. 3DF2h, Bit 0 = MODE. 3DF2h, Register on page = 484. 3DF1h, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nU1P3H. 3DF1h, Bit 7 = -. 3DF1h, Bit 6 = -. 3DF1h, Bit 5 = -. 3DF1h, Bit 4 = -. 3DF1h, Bit 3 = -. 3DF1h, Bit 2 = -. 3DF1h, Bit 1 = -. 3DF1h, Bit 0 = P3H. 3DF1h, Register on page = 495. 3DF0h, Name = U1P3L. 3DF0h, Bit 7 = . 3DF0h, Bit 6 = . 3DF0h, Bit 5 = . 3DF0h, Bit 4 = P3L. 3DF0h, Bit 3 = . 3DF0h, Bit 2 = . 3DF0h, Bit 1 = . 3DF0h, Bit 0 = . 3DF0h, Register on page = 495. 3DEFh, Name = U1P2H. 3DEFh, Bit 7 = -. 3DEFh, Bit 6 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DEFh, Bit 5 = -. 3DEFh, Bit 4 = -. 3DEFh, Bit 3 = -. 3DEFh, Bit 2 = -. 3DEFh, Bit 1 = -. 3DEFh, Bit 0 = P2H. 3DEFh, Register on page = 494. 3DEEh, Name = U1P2L. 3DEEh, Bit 7 = . 3DEEh, Bit 6 = . 3DEEh, Bit 5 = . 3DEEh, Bit 4 = P2L. 3DEEh, Bit 3 = . 3DEEh, Bit 2 = . 3DEEh, Bit 1 = . 3DEEh, Bit 0 = . 3DEEh, Register on page = 494. 3DEDh, Name = U1P1H. 3DEDh, Bit 7 = -. 3DEDh, Bit 6 = -. 3DEDh, Bit 5 = -. 3DEDh, Bit 4 = -. 3DEDh, Bit 3 = -. 3DEDh, Bit 2 = -. 3DEDh, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n-. 3DEDh, Bit 0 = P1H. 3DEDh, Register on page = 493. 3DECh, Name = U1P1L. 3DECh, Bit 7 = . 3DECh, Bit 6 = . 3DECh, Bit 5 = . 3DECh, Bit 4 = P1L. 3DECh, Bit 3 = . 3DECh, Bit 2 = . 3DECh, Bit 1 = . 3DECh, Bit 0 = . 3DECh, Register on page = 493. 3DEBh, Name = U1TXCHK. 3DEBh, Bit 7 = . 3DEBh, Bit 6 = . 3DEBh, Bit 5 = . 3DEBh, Bit 4 = TXCHK. 3DEBh, Bit 3 = . 3DEBh, Bit 2 = . 3DEBh, Bit 1 = . 3DEBh, Bit 0 = . 3DEBh, Register on page = 496. 3DEAh, Name = U1TXB. 3DEAh, Bit 7 = . 3DEAh, Bit 6 = . 3DEAh, Bit 5 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DEAh, Bit 4 = TXB. 3DEAh, Bit 3 = . 3DEAh, Bit 2 = . 3DEAh, Bit 1 = . 3DEAh, Bit 0 = . 3DEAh, Register on page = 492. 3DE9h, Name = U1RXCHK. 3DE9h, Bit 7 = . 3DE9h, Bit 6 = . 3DE9h, Bit 5 = . 3DE9h, Bit 4 = RXCHK. 3DE9h, Bit 3 = . 3DE9h, Bit 2 = . 3DE9h, Bit 1 = . 3DE9h, Bit 0 = . 3DE9h, Register on page = 496. 3DE8h, Name = U1RXB. 3DE8h, Bit 7 = . 3DE8h, Bit 6 = . 3DE8h, Bit 5 = . 3DE8h, Bit 4 = RXB. 3DE8h, Bit 3 = . 3DE8h, Bit 2 = . 3DE8h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n1 = . 3DE8h, Bit 0 = . 3DE8h, Register on page = 492. 3DE7h- 3DE3h, Name = -. 3DE7h- 3DE3h, Bit 7 = Unimplemented. 3DE7h- 3DE3h, Bit 6 = Unimplemented. 3DE7h- 3DE3h, Bit 5 = Unimplemented. 3DE7h- 3DE3h, Bit 4 = Unimplemented. 3DE7h- 3DE3h, Bit 3 = Unimplemented. 3DE7h- 3DE3h, Bit 2 = Unimplemented. 3DE7h- 3DE3h, Bit 1 = Unimplemented. 3DE7h- 3DE3h, Bit 0 = Unimplemented. 3DE7h- 3DE3h, Register on page = -. 3DE2h, Name = U2ERRIE. 3DE2h, Bit 7 = TXMTIE.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DE2h, Bit 6 = PERIE. 3DE2h, Bit 5 = ABDOVE. 3DE2h, Bit 4 = CERIE. 3DE2h, Bit 3 = FERIE. 3DE2h, Bit 2 = RXBKIE. 3DE2h, Bit 1 = RXFOIE. 3DE2h, Bit 0 = TXCIE. 3DE2h, Register on page = 488. 3DE1h, Name = U2ERRIR. 3DE1h, Bit 7 = TXMTIF. 3DE1h, Bit 6 = PERIF. 3DE1h, Bit 5 = ABDOVF. 3DE1h, Bit 4 = CERIF. 3DE1h, Bit 3 = FERIF. 3DE1h, Bit 2 = RXBKIF. 3DE1h, Bit 1 = RXFOIF. 3DE1h, Bit 0 = TXCIF. 3DE1h, Register on page = 487. 3DE0h, Name = U2UIR. 3DE0h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 7 = WUIF. 3DE0h, Bit 6 = ABDIF. 3DE0h, Bit 5 = -. 3DE0h, Bit 4 = -. 3DE0h, Bit 3 = -. 3DE0h, Bit 2 = ABDIE. 3DE0h, Bit 1 = -. 3DE0h, Bit 0 = -. 3DE0h, Register on page = 489. 3DDFh, Name = U2FIFO. 3DDFh, Bit 7 = TXWRE. 3DDFh, Bit 6 = STPMD. 3DDFh, Bit 5 = TXBE. 3DDFh, Bit 4 = TXBF. 3DDFh, Bit 3 = RXIDL. 3DDFh, Bit 2 = XON. 3DDFh, Bit 1 = RXBE. 3DDFh, Bit 0 = RXBF. 3DDFh, Register on page = 490. 3DDEh, Name = U2BRGH. 3DDEh, Bit 7 = BRGH. 3DDEh, Bit 6 = BRGH. 3DDEh, Bit 5 = BRGH.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DDEh, Bit 4 = BRGH. 3DDEh, Bit 3 = BRGH. 3DDEh, Bit 2 = BRGH. 3DDEh, Bit 1 = BRGH. 3DDEh, Bit 0 = BRGH. 3DDEh, Register on page = 491. 3DDDh, Name = U2BRGL. 3DDDh, Bit 7 = . 3DDDh, Bit 6 = . 3DDDh, Bit 5 = . 3DDDh, Bit 4 = BRGL. 3DDDh, Bit 3 = . 3DDDh, Bit 2 = . 3DDDh, Bit 1 = . 3DDDh, Bit 0 = . 3DDDh, Register on page = 491. 3DDCh, Name = U2CON2. 3DDCh, Bit 7 = RUNOVF. 3DDCh, Bit 6 = RXPOL. 3DDCh, Bit 5 = STP. 3DDCh, Bit 4 = . 3DDCh, Bit 3 = -. 3DDCh, Bit 2 = TXPOL. 3DDCh, Bit 1 = FLO. 3DDCh, Bit 0 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DDCh, Register on page = 486. 3DDBh, Name = U2CON1. 3DDBh, Bit 7 = ON. 3DDBh, Bit 6 = -. 3DDBh, Bit 5 = -. 3DDBh, Bit 4 = WUE. 3DDBh, Bit 3 = RXBIMD. 3DDBh, Bit 2 = -. 3DDBh, Bit 1 = BRKOVR. 3DDBh, Bit 0 = SENDB. 3DDBh, Register on page = 485. 3DDAh, Name = U2CON0. 3DDAh, Bit 7 = BRGS. 3DDAh, Bit 6 = ABDEN. 3DDAh, Bit 5 = TXEN. 3DDAh, Bit 4 = RXEN. 3DDAh, Bit 3 = . 3DDAh, Bit 2 = . 3DDAh, Bit 1 = MODE. 3DDAh, Bit 0 = . 3DDAh, Register on page = 484. 3DD9h, Name = U2P3H. 3DD9h, Bit 7 = -. 3DD9h, Bit 6 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DD9h, Bit 5 = -. 3DD9h, Bit 4 = -. 3DD9h, Bit 3 = -. 3DD9h, Bit 2 = -. 3DD9h, Bit 1 = -. 3DD9h, Bit 0 = P3H. 3DD9h, Register on page = 495. 3DD8h, Name = U2P3L. 3DD8h, Bit 7 = . 3DD8h, Bit 6 = . 3DD8h, Bit 5 = . 3DD8h, Bit 4 = P3L. 3DD8h, Bit 3 = . 3DD8h, Bit 2 = . 3DD8h, Bit 1 = . 3DD8h, Bit 0 = . 3DD8h, Register on page = 495. 3DD7h, Name = U2P2H. 3DD7h, Bit 7 = -. 3DD7h, Bit 6 = -. 3DD7h, Bit 5 = -. 3DD7h, Bit 4 = -. 3DD7h, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n-. 3DD7h, Bit 2 = -. 3DD7h, Bit 1 = -. 3DD7h, Bit 0 = P2H. 3DD7h, Register on page = 494. 3DD6h, Name = U2P2L. 3DD6h, Bit 7 = . 3DD6h, Bit 6 = . 3DD6h, Bit 5 = . 3DD6h, Bit 4 = P2L. 3DD6h, Bit 3 = . 3DD6h, Bit 2 = . 3DD6h, Bit 1 = . 3DD6h, Bit 0 = . 3DD6h, Register on page = 494. 3DD5h, Name = U2P1H. 3DD5h, Bit 7 = -. 3DD5h, Bit 6 = -. 3DD5h, Bit 5 = -. 3DD5h, Bit 4 = -. 3DD5h, Bit 3 = -. 3DD5h, Bit 2 = -. 3DD5h, Bit 1 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DD5h, Bit 0 = P1H. 3DD5h, Register on page = 493. 3DD4h, Name = U2P1L. 3DD4h, Bit 7 = . 3DD4h, Bit 6 = . 3DD4h, Bit 5 = . 3DD4h, Bit 4 = P1L. 3DD4h, Bit 3 = . 3DD4h, Bit 2 = . 3DD4h, Bit 1 = . 3DD4h, Bit 0 = . 3DD4h, Register on page = 493. 3DD3h, Name = U2TXCHK. 3DD3h, Bit 7 = . 3DD3h, Bit 6 = . 3DD3h, Bit 5 = . 3DD3h, Bit 4 = TXCHK. 3DD3h, Bit 3 = . 3DD3h, Bit 2 = . 3DD3h, Bit 1 = . 3DD3h, Bit 0 = . 3DD3h, Register on page = 496. 3DD2h, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nU2TXB. 3DD2h, Bit 7 = . 3DD2h, Bit 6 = . 3DD2h, Bit 5 = . 3DD2h, Bit 4 = TXB. 3DD2h, Bit 3 = . 3DD2h, Bit 2 = . 3DD2h, Bit 1 = . 3DD2h, Bit 0 = . 3DD2h, Register on page = 492. 3DD1h, Name = U2RXCHK. 3DD1h, Bit 7 = . 3DD1h, Bit 6 = . 3DD1h, Bit 5 = . 3DD1h, Bit 4 = RXCHK. 3DD1h, Bit 3 = . 3DD1h, Bit 2 = . 3DD1h, Bit 1 = . 3DD1h, Bit 0 = . 3DD1h, Register on page = 496. 3DD0h, Name = U2RXB. 3DD0h, Bit 7 = . 3DD0h, Bit 6 = . 3DD0h, Bit 5 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3DD0h, Bit 4 = RXB. 3DD0h, Bit 3 = . 3DD0h, Bit 2 = . 3DD0h, Bit 1 = . 3DD0h, Bit 0 = . 3DD0h, Register on page = 492. 3DCFh, Name = . 3DCFh, Bit 7 = . 3DCFh, Bit 6 = . 3DCFh, Bit 5 = . 3DCFh, Bit 4 = Unimplemented. 3DCFh, Bit 3 = . 3DCFh, Bit 2 = . 3DCFh, Bit 1 = . 3DCFh, Bit 0 = . 3DCFh, Register on page = -. - 3D7Dh, Name = -. - 3D7Dh, Bit 7 = . - 3D7Dh, Bit 6 = . - 3D7Dh, Bit 5 = . - 3D7Dh, Bit 4 = . - 3D7Dh, Bit 3 = . - 3D7Dh, Bit 2 = . - 3D7Dh, Bit 1 = . -",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3D7Dh, Bit 0 = . - 3D7Dh, Register on page = . 3D7Ch, Name = I2C1BTO. 3D7Ch, Bit 7 = . 3D7Ch, Bit 6 = . 3D7Ch, Bit 5 = . 3D7Ch, Bit 4 = BTO. 3D7Ch, Bit 3 = . 3D7Ch, Bit 2 = . 3D7Ch, Bit 1 = . 3D7Ch, Bit 0 = . 3D7Ch, Register on page = 569. 3D7Bh, Name = I2C1CLK. 3D7Bh, Bit 7 = . 3D7Bh, Bit 6 = . 3D7Bh, Bit 5 = . 3D7Bh, Bit 4 = CLK. 3D7Bh, Bit 3 = . 3D7Bh, Bit 2 = . 3D7Bh, Bit 1 = . 3D7Bh, Bit 0 = . 3D7Bh, Register on page = 568. 3D7Ah, Name = I2C1PIE. 3D7Ah, Bit 7 = CNTIE. 3D7Ah, Bit 6 = ACKTIE.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3D7Ah, Bit 5 = -. 3D7Ah, Bit 4 = WRIE. 3D7Ah, Bit 3 = ADRIE. 3D7Ah, Bit 2 = PCIE. 3D7Ah, Bit 1 = RSCIE. 3D7Ah, Bit 0 = SCIE. 3D7Ah, Register on page = 575. 3D79h, Name = I2C1PIR. 3D79h, Bit 7 = CNTIF. 3D79h, Bit 6 = ACKTIF. 3D79h, Bit 5 = -. 3D79h, Bit 4 = WRIF. 3D79h, Bit 3 = ADRIF. 3D79h, Bit 2 = PCIF. 3D79h, Bit 1 = RSCIF. 3D79h, Bit 0 = SCIF. 3D79h, Register on page = 574. 3D78h, Name = I2C1STAT1. 3D78h, Bit 7 = TXWE. 3D78h, Bit 6 = -. 3D78h, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nTXBE. 3D78h, Bit 4 = -. 3D78h, Bit 3 = RXRE D. 3D78h, Bit 2 = CLRBF. 3D78h, Bit 1 = -. 3D78h, Bit 0 = RXBF -. 3D78h, Register on page = 571 570. 3D76h, Name = I2C1ERR. 3D76h, Bit 7 = -. 3D76h, Bit 6 = BTOIF. 3D76h, Bit 5 = BCLIF. 3D76h, Bit 4 = NACKIF. 3D76h, Bit 3 = . 3D76h, Bit 2 = BTOIE. 3D76h, Bit 1 = BCLIE. 3D76h, Bit 0 = NACKIE. 3D76h, Register on page = 572. 3D77h, Name = I2C1STAT0. 3D77h, Bit 7 = BFRE. 3D77h, Bit 6 = SMA.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3D77h, Bit 5 = MMA. 3D77h, Bit 4 = R. 3D77h, Bit 3 = -. 3D77h, Bit 2 = -. 3D77h, Bit 1 = -. 3D77h, Bit 0 = . 3D77h, Register on page = 567. 3D75h, Name = I2C1CON2. 3D75h, Bit 7 = ACNT. 3D75h, Bit 6 = GCEN. 3D75h, Bit 5 = FME. 3D75h, Bit 4 = ABD. 3D75h, Bit 3 = . 3D75h, Bit 2 = SDAHT. 3D75h, Bit 1 = . 3D75h, Bit 0 = BFRET. 3D75h, Register on page = \nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition Note 1: Not present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3D73h, Name = I2C1CON0. 3D73h, Bit 7 = EN. 3D73h, Bit 6 = RSEN. 3D73h, Bit 5 = S. 3D73h, Bit 4 = CSTR. 3D73h, Bit 3 = MDR. 3D73h, Bit 2 = . 3D73h, Bit 1 = MODE. 3D73h, Bit 0 = . 3D73h, Register on page = 564. 3D72h, Name = I2C1ADR3. 3D72h, Bit 7 = . 3D72h, Bit 6 = . 3D72h, Bit 5 = . 3D72h, Bit 4 = ADR. 3D72h, Bit 3 = . 3D72h, Bit 2 = . 3D72h, Bit 1 = . 3D72h, Bit 0 = -. 3D72h, Register on page = 579. 3D71h, Name = I2C1ADR2. 3D71h, Bit 7",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= . 3D71h, Bit 6 = . 3D71h, Bit 5 = . 3D71h, Bit 4 = ADR. 3D71h, Bit 3 = . 3D71h, Bit 2 = . 3D71h, Bit 1 = . 3D71h, Bit 0 = . 3D71h, Register on page = 578. 3D70h, Name = I2C1ADR1. 3D70h, Bit 7 = . 3D70h, Bit 6 = . 3D70h, Bit 5 = . 3D70h, Bit 4 = ADR. 3D70h, Bit 3 = . 3D70h, Bit 2 = . 3D70h, Bit 1 = . 3D70h, Bit 0 = -. 3D70h, Register on page = 577. 3D6Fh, Name = I2C1ADR0. 3D6Fh, Bit 7 = . 3D6Fh, Bit 6 = . 3D6Fh, Bit 5 = . 3D6Fh, Bit 4 = ADR. 3D6Fh, Bit 3",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= . 3D6Fh, Bit 2 = . 3D6Fh, Bit 1 = . 3D6Fh, Bit 0 = . 3D6Fh, Register on page = 576. 3D6Eh, Name = I2C1ADB1. 3D6Eh, Bit 7 = . 3D6Eh, Bit 6 = . 3D6Eh, Bit 5 = . 3D6Eh, Bit 4 = ADB. 3D6Eh, Bit 3 = . 3D6Eh, Bit 2 = . 3D6Eh, Bit 1 = . 3D6Eh, Bit 0 = . 3D6Eh, Register on page = 581. 3D6Dh, Name = I2C1ADB0. 3D6Dh, Bit 7 = . 3D6Dh, Bit 6 = . 3D6Dh, Bit 5 = . 3D6Dh, Bit 4 = ADB. 3D6Dh, Bit 3 = . 3D6Dh, Bit 2 = . 3D6Dh, Bit 1 = . 3D6Dh, Bit 0 = . 3D6Dh, Register on page = 580. 3D6Ch, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nI2C1CNT. 3D6Ch, Bit 7 = . 3D6Ch, Bit 6 = . 3D6Ch, Bit 5 = . 3D6Ch, Bit 4 = CNT. 3D6Ch, Bit 3 = . 3D6Ch, Bit 2 = . 3D6Ch, Bit 1 = . 3D6Ch, Bit 0 = . 3D6Ch, Register on page = 573. 3D6Bh, Name = I2C1TXB. 3D6Bh, Bit 7 = . 3D6Bh, Bit 6 = . 3D6Bh, Bit 5 = . 3D6Bh, Bit 4 = TXB. 3D6Bh, Bit 3 = . 3D6Bh, Bit 2 = . 3D6Bh, Bit 1 = . 3D6Bh, Bit 0 = . 3D6Bh, Register on page = -. 3D6Ah, Name = I2C1RXB. 3D6Ah, Bit 7 = . 3D6Ah, Bit 6 = . 3D6Ah, Bit 5 = . 3D6Ah, Bit 4 = RXB. 3D6Ah, Bit 3 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3D6Ah, Bit 2 = . 3D6Ah, Bit 1 = . 3D6Ah, Bit 0 = . 3D6Ah, Register on page = -. 3D69h - 3D67h, Name = -. 3D69h - 3D67h, Bit 7 = . 3D69h - 3D67h, Bit 6 = . 3D69h - 3D67h, Bit 5 = . 3D69h - 3D67h, Bit 4 = Unimplemented. 3D69h - 3D67h, Bit 3 = . 3D69h - 3D67h, Bit 2 = . 3D69h - 3D67h, Bit 1 = . 3D69h - 3D67h, Bit 0 = . 3D69h - 3D67h, Register on page = -. 3D66h, Name = I2C2BTO. 3D66h, Bit 7 = . 3D66h, Bit 6 = . 3D66h, Bit 5 = . 3D66h, Bit 4 = BTO.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3D66h, Bit 3 = . 3D66h, Bit 2 = . 3D66h, Bit 1 = . 3D66h, Bit 0 = . 3D66h, Register on page = 569. 3D65h, Name = I2C2CLK. 3D65h, Bit 7 = . 3D65h, Bit 6 = . 3D65h, Bit 5 = . 3D65h, Bit 4 = CLK. 3D65h, Bit 3 = . 3D65h, Bit 2 = . 3D65h, Bit 1 = . 3D65h, Bit 0 = . 3D65h, Register on page = 568. 3D64h, Name = I2C2PIE. 3D64h, Bit 7 = CNTIE. 3D64h, Bit 6 = ACKTIE. 3D64h, Bit 5 = -. 3D64h, Bit 4 = WRIE. 3D64h, Bit 3 = ADRIE. 3D64h, Bit 2 = PCIE. 3D64h, Bit 1 = RSCIE. 3D64h, Bit 0 = SCIE. 3D64h, Register on",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\npage = 575. 3D63h, Name = I2C2PIR. 3D63h, Bit 7 = CNTIF. 3D63h, Bit 6 = ACKTIF. 3D63h, Bit 5 = -. 3D63h, Bit 4 = WRIF. 3D63h, Bit 3 = ADRIF. 3D63h, Bit 2 = PCIF. 3D63h, Bit 1 = RSCIF. 3D63h, Bit 0 = SCIF. 3D63h, Register on page = 574. 3D62h, Name = I2C2STAT1. 3D62h, Bit 7 = TXWE. 3D62h, Bit 6 = -. 3D62h, Bit 5 = TXBE. 3D62h, Bit 4 = -. 3D62h, Bit 3 = RXRE. 3D62h, Bit 2 = CLRBF. 3D62h, Bit 1 = -. 3D62h, Bit 0 = RXBF. 3D62h, Register",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\non page = 571. 3D61h, Name = I2C2STAT0. 3D61h, Bit 7 = BFRE. 3D61h, Bit 6 = SMA. 3D61h, Bit 5 = MMA. 3D61h, Bit 4 = R. 3D61h, Bit 3 = D. 3D61h, Bit 2 = -. 3D61h, Bit 1 = -. 3D61h, Bit 0 = -. 3D61h, Register on page = 570. 3D60h, Name = I2C2ERR. 3D60h, Bit 7 = -. 3D60h, Bit 6 = BTOIF. 3D60h, Bit 5 = BCLIF. 3D60h, Bit 4 = NACKIF. 3D60h, Bit 3 = -. 3D60h, Bit 2 = BTOIE. 3D60h, Bit 1 = BCLIE. 3D60h, Bit 0 = NACKIE. 3D60h, Register on page = 572. 3D5Fh, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nI2C2CON2. 3D5Fh, Bit 7 = ACNT. 3D5Fh, Bit 6 = GCEN. 3D5Fh, Bit 5 = FME. 3D5Fh, Bit 4 = ABD. 3D5Fh, Bit 3 = . 3D5Fh, Bit 2 = SDAHT. 3D5Fh, Bit 1 = . 3D5Fh, Bit 0 = BFRET. 3D5Fh, Register on page = 567. 3D5Eh, Name = I2C2CON1. 3D5Eh, Bit 7 = ACKCNT. 3D5Eh, Bit 6 = ACKDT. 3D5Eh, Bit 5 = ACKSTAT. 3D5Eh, Bit 4 = ACKT. 3D5Eh, Bit 3 = -. 3D5Eh, Bit 2 = RXO. 3D5Eh, Bit 1 = TXU. 3D5Eh, Bit 0 = CSD. 3D5Eh, Register on page = 566. 3D5Dh, Name = I2C2CON0. 3D5Dh, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nEN. 3D5Dh, Bit 6 = RSEN. 3D5Dh, Bit 5 = S. 3D5Dh, Bit 4 = CSTR. 3D5Dh, Bit 3 = MDR. 3D5Dh, Bit 2 = . 3D5Dh, Bit 1 = MODE. 3D5Dh, Bit 0 = . 3D5Dh, Register on page = 564. 3D5Ch, Name = I2C2ADR3. 3D5Ch, Bit 7 = . 3D5Ch, Bit 6 = . 3D5Ch, Bit 5 = . 3D5Ch, Bit 4 = ADR. 3D5Ch, Bit 3 = . 3D5Ch, Bit 2 = . 3D5Ch, Bit 1 = . 3D5Ch, Bit 0 = -. 3D5Ch, Register on page = 579. 3D5Bh, Name = I2C2ADR2. 3D5Bh, Bit 7 = . 3D5Bh, Bit 6 = . 3D5Bh, Bit 5 = . 3D5Bh, Bit 4 = ADR. 3D5Bh, Bit 3 = . 3D5Bh, Bit 2",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= . 3D5Bh, Bit 1 = . 3D5Bh, Bit 0 = . 3D5Bh, Register on page = 578. 3D5Ah, Name = I2C2ADR1. 3D5Ah, Bit 7 = . 3D5Ah, Bit 6 = . 3D5Ah, Bit 5 = . 3D5Ah, Bit 4 = ADR. 3D5Ah, Bit 3 = . 3D5Ah, Bit 2 = . 3D5Ah, Bit 1 = . 3D5Ah, Bit 0 = -. 3D5Ah, Register on page = 577. 3D59h, Name = I2C2ADR0. 3D59h, Bit 7 = . 3D59h, Bit 6 = . 3D59h, Bit 5 = . 3D59h, Bit 4 = ADR. 3D59h, Bit 3 = . 3D59h, Bit 2 = . 3D59h, Bit 1 = . 3D59h, Bit 0 = . 3D59h, Register on page = 576. 3D58h, Name = I2C2ADB1. 3D58h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n7 = . 3D58h, Bit 6 = . 3D58h, Bit 5 = . 3D58h, Bit 4 = ADB. 3D58h, Bit 3 = . 3D58h, Bit 2 = . 3D58h, Bit 1 = . 3D58h, Bit 0 = . 3D58h, Register on page = 581. 3D57h, Name = I2C2ADB0. 3D57h, Bit 7 = . 3D57h, Bit 6 = . 3D57h, Bit 5 = . 3D57h, Bit 4 = ADB. 3D57h, Bit 3 = . 3D57h, Bit 2 = . 3D57h, Bit 1 = . 3D57h, Bit 0 = . 3D57h, Register on page = 580. 3D56h, Name = I2C2CNT. 3D56h, Bit 7 = . 3D56h, Bit 6 = . 3D56h, Bit 5 = . 3D56h, Bit 4 = CNT. 3D56h, Bit 3 = . 3D56h, Bit 2 = . 3D56h, Bit 1",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= . 3D56h, Bit 0 = . 3D56h, Register on page = 573. 3D55h, Name = I2C2TXB. 3D55h, Bit 7 = . 3D55h, Bit 6 = . 3D55h, Bit 5 = . 3D55h, Bit 4 = TXB. 3D55h, Bit 3 = . 3D55h, Bit 2 = . 3D55h, Bit 1 = . 3D55h, Bit 0 = . 3D55h, Register on page = -. 3D54h, Name = I2C2RXB. 3D54h, Bit 7 = . 3D54h, Bit 6 = . 3D54h, Bit 5 = . 3D54h, Bit 4 = RXB. 3D54h, Bit 3 = . 3D54h, Bit 2 = . 3D54h, Bit 1 = . 3D54h, Bit 0 = . 3D54h, Register on page = -. 3D53h - 3D1Dh, Name = -. 3D53h - 3D1Dh, Bit 7 = . 3D53h -",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3D1Dh, Bit 6 = . 3D53h - 3D1Dh, Bit 5 = . 3D53h - 3D1Dh, Bit 4 = Unimplemented. 3D53h - 3D1Dh, Bit 3 = . 3D53h - 3D1Dh, Bit 2 = . 3D53h - 3D1Dh, Bit 1 = . 3D53h - 3D1Dh, Bit 0 = . 3D53h - 3D1Dh, Register on page = -. 3D1Ch, Name = SPI1CLK. 3D1Ch, Bit 7 = CLKSEL. 3D1Ch, Bit 6 = CLKSEL. 3D1Ch, Bit 5 = CLKSEL. 3D1Ch, Bit 4 = CLKSEL. 3D1Ch, Bit 3 = CLKSEL. 3D1Ch, Bit 2 = CLKSEL. 3D1Ch, Bit 1 = CLKSEL. 3D1Ch, Bit 0 = CLKSEL. 3D1Ch, Register on page = 528. 3D1Bh, Name = SPI1INTE. 3D1Bh, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSRMTIE. 3D1Bh, Bit 6 = TCZIE. 3D1Bh, Bit 5 = SOSIE. 3D1Bh, Bit 4 = EOSIE. 3D1Bh, Bit 3 = -. 3D1Bh, Bit 2 = RXOIE. 3D1Bh, Bit 1 = TXUIE. 3D1Bh, Bit 0 = -. 3D1Bh, Register on page = 522. 3D1Ah, Name = SPI1INTF. 3D1Ah, Bit 7 = SRMTIF. 3D1Ah, Bit 6 = TCZIF. 3D1Ah, Bit 5 = SOSIF. 3D1Ah, Bit 4 = EOSIF. 3D1Ah, Bit 3 = -. 3D1Ah, Bit 2 = RXOIF. 3D1Ah, Bit 1 = TXUIF. 3D1Ah, Bit 0 = -. 3D1Ah, Register on page = 521. 3D19h, Name = SPI1BAUD. 3D19h, Bit 7 = BAUD. 3D19h, Bit 6 = BAUD. 3D19h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n5 = BAUD. 3D19h, Bit 4 = BAUD. 3D19h, Bit 3 = BAUD. 3D19h, Bit 2 = . 3D19h, Bit 1 = . 3D19h, Bit 0 = . 3D19h, Register on page = 524. 3D18h, Name = SPI1TWIDTH. 3D18h, Bit 7 = -. 3D18h, Bit 6 = -. 3D18h, Bit 5 = -. 3D18h, Bit 4 = -. 3D18h, Bit 3 = -. 3D18h, Bit 2 = . 3D18h, Bit 1 = TWIDTH. 3D18h, Bit 0 = . 3D18h, Register on page = 523. 3D17h, Name = SPI1STATUS. 3D17h, Bit 7 = TXWE. 3D17h, Bit 6 = -. 3D17h, Bit 5 = TXBE. 3D17h, Bit 4 = -. 3D17h, Bit 3 = RXRE. 3D17h, Bit 2 = CLRBF.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3D17h, Bit 1 = -. 3D17h, Bit 0 = RXBF. 3D17h, Register on page = 527. 3D16h, Name = SPI1CON2. 3D16h, Bit 7 = BUSY. 3D16h, Bit 6 = SSFLT. 3D16h, Bit 5 = -. 3D16h, Bit 4 = -. 3D16h, Bit 3 = -. 3D16h, Bit 2 = SSET. 3D16h, Bit 1 = TXR. 3D16h, Bit 0 = RXR. 3D16h, Register on page = 526. 3D15h, Name = SPI1CON1. 3D15h, Bit 7 = SMP. 3D15h, Bit 6 = CKE. 3D15h, Bit 5 = CKP. 3D15h, Bit 4 = FST. 3D15h, Bit 3 = -. 3D15h, Bit 2 = SSP. 3D15h, Bit 1 = SDIP. 3D15h, Bit 0 = SDOP. 3D15h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n525. 3D14h, Name = SPI1CON0. 3D14h, Bit 7 = EN. 3D14h, Bit 6 = -. 3D14h, Bit 5 = -. 3D14h, Bit 4 = -. 3D14h, Bit 3 = -. 3D14h, Bit 2 = LSBF. 3D14h, Bit 1 = MST. 3D14h, Bit 0 = BMODE. 3D14h, Register on page = 524. 3D13h, Name = SPI1TCNTH. 3D13h, Bit 7 = -. 3D13h, Bit 6 = -. 3D13h, Bit 5 = -. 3D13h, Bit 4 = -. 3D13h, Bit 3 = -. 3D13h, Bit 2 = . 3D13h, Bit 1 = TCNTH. 3D13h, Bit 0 = . 3D13h, Register on page = 523. 3D12h, Name = SPI1TCNTL. 3D12h, Bit 7 = . 3D12h, Bit 6 = . 3D12h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 5 = . 3D12h, Bit 4 = TCNTL. 3D12h, Bit 3 = . 3D12h, Bit 2 = . 3D12h, Bit 1 = . 3D12h, Bit 0 = . 3D12h, Register on page = 522. 3D11h, Name = SPI1TXB. 3D11h, Bit 7 = . 3D11h, Bit 6 = . 3D11h, Bit 5 = . 3D11h, Bit 4 = TXB. 3D11h, Bit 3 = . 3D11h, Bit 2 = . 3D11h, Bit 1 = . 3D11h, Bit 0 = . 3D11h, Register on page = 528. 3D10h, Name = SPI1RXB. 3D10h, Bit 7 = . 3D10h, Bit 6 = . 3D10h, Bit 5 = . 3D10h, Bit 4 = RXB. 3D10h, Bit 3 = . 3D10h, Bit 2 = . 3D10h, Bit 1 = . 3D10h, Bit 0 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3D10h, Register on page = 527. 3D0Fh- 3CFFh, Name = -. 3D0Fh- 3CFFh, Bit 7 = . 3D0Fh- 3CFFh, Bit 6 = . 3D0Fh- 3CFFh, Bit 5 = . 3D0Fh- 3CFFh, Bit 4 = Unimplemented. 3D0Fh- 3CFFh, Bit 3 = . 3D0Fh- 3CFFh, Bit 2 = . 3D0Fh- 3CFFh, Bit 1 = . 3D0Fh- 3CFFh, Bit 0 = . 3D0Fh- 3CFFh, Register on page = -. 3CFEh, Name = MD1CARH. 3CFEh, Bit 7 = -. 3CFEh, Bit 6 = -. 3CFEh, Bit 5 = -. 3CFEh, Bit 4 = . 3CFEh, Bit 3 = . 3CFEh, Bit 2 = CH.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3CFEh, Bit 1 = . 3CFEh, Bit 0 = . 3CFEh, Register on page = 458. 3CFDh, Name = MD1CARL. 3CFDh, Bit 7 = -. 3CFDh, Bit 6 = -. 3CFDh, Bit 5 = -. 3CFDh, Bit 4 = . 3CFDh, Bit 3 = . 3CFDh, Bit 2 = CL. 3CFDh, Bit 1 = . 3CFDh, Bit 0 = . 3CFDh, Register on page = 458\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition Note 1: Not present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3CFCh, Name = MD1SRC. 3CFCh, Bit 7 = -. 3CFCh, Bit 6 = -. 3CFCh, Bit 5 = -. 3CFCh, Bit 4 = . 3CFCh, Bit 3 = . 3CFCh, Bit 2 = MS. 3CFCh, Bit 1 = MS. 3CFCh, Bit 0 = MS. 3CFCh, Register on page = 459. 3CFBh, Name = MD1CON1. 3CFBh, Bit 7 = -. 3CFBh, Bit 6 = -. 3CFBh, Bit 5 = CHPOL. 3CFBh, Bit 4 = CHSYNC. 3CFBh, Bit 3 = -. 3CFBh, Bit 2 = -. 3CFBh, Bit 1 = CLPOL. 3CFBh, Bit 0 = CLSYNC. 3CFBh, Register on page = 457. 3CFAh, Name = MD1CON0. 3CFAh, Bit 7",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= EN. 3CFAh, Bit 6 = -. 3CFAh, Bit 5 = OUT. 3CFAh, Bit 4 = OPOL. 3CFAh, Bit 3 = -. 3CFAh, Bit 2 = -. 3CFAh, Bit 1 = -. 3CFAh, Bit 0 = BIT. 3CFAh, Register on page = 456. 3CF9h- 3CE7h, Name = -. 3CF9h- 3CE7h, Bit 7 = Unimplemented. 3CF9h- 3CE7h, Bit 6 = Unimplemented. 3CF9h- 3CE7h, Bit 5 = Unimplemented. 3CF9h- 3CE7h, Bit 4 = Unimplemented. 3CF9h- 3CE7h, Bit 3 = Unimplemented. 3CF9h- 3CE7h, Bit 2 = Unimplemented. 3CF9h-",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3CE7h, Bit 1 = Unimplemented. 3CF9h- 3CE7h, Bit 0 = Unimplemented. 3CF9h- 3CE7h, Register on page = -. 3CE6h, Name = CLKRCLK. 3CE6h, Bit 7 = -. 3CE6h, Bit 6 = -. 3CE6h, Bit 5 = -. 3CE6h, Bit 4 = -. 3CE6h, Bit 3 = -. 3CE6h, Bit 2 = CLK. 3CE6h, Bit 1 = CLK. 3CE6h, Bit 0 = CLK. 3CE6h, Register on page = 104. 3CE5h, Name = CLKRCON. 3CE5h, Bit 7 = EN. 3CE5h, Bit 6 = -. 3CE5h, Bit 5 = -. 3CE5h, Bit 4 = DC. 3CE5h, Bit 3 = DC. 3CE5h, Bit 2 = DIV.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3CE5h, Bit 1 = DIV. 3CE5h, Bit 0 = DIV. 3CE5h, Register on page = 103. 3CE4h- 3C7Fh, Name = -. 3CE4h- 3C7Fh, Bit 7 = Unimplemented. 3CE4h- 3C7Fh, Bit 6 = Unimplemented. 3CE4h- 3C7Fh, Bit 5 = Unimplemented. 3CE4h- 3C7Fh, Bit 4 = Unimplemented. 3CE4h- 3C7Fh, Bit 3 = Unimplemented. 3CE4h- 3C7Fh, Bit 2 = Unimplemented. 3CE4h- 3C7Fh, Bit 1 = Unimplemented. 3CE4h- 3C7Fh, Bit 0 = Unimplemented. 3CE4h- 3C7Fh, Register on page = -. 3C7Eh, Name",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= CLCDATA0. 3C7Eh, Bit 7 = -. 3C7Eh, Bit 6 = -. 3C7Eh, Bit 5 = -. 3C7Eh, Bit 4 = -. 3C7Eh, Bit 3 = CLC4OUT. 3C7Eh, Bit 2 = CLC3OUT. 3C7Eh, Bit 1 = CLC2OUT. 3C7Eh, Bit 0 = CLC1OUT. 3C7Eh, Register on page = 434. 3C7Dh, Name = CLC1GLS3. 3C7Dh, Bit 7 = G4D4T. 3C7Dh, Bit 6 = G4D4N. 3C7Dh, Bit 5 = G4D3T. 3C7Dh, Bit 4 = G4D3N. 3C7Dh, Bit 3 = G4D2T. 3C7Dh, Bit 2 = G4D2N. 3C7Dh, Bit 1 = G4D1T. 3C7Dh, Bit 0 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nG4D1N. 3C7Dh, Register on page = 433. 3C7Ch, Name = CLC1GLS2. 3C7Ch, Bit 7 = G3D4T. 3C7Ch, Bit 6 = G3D4N. 3C7Ch, Bit 5 = G3D3T. 3C7Ch, Bit 4 = G3D3N. 3C7Ch, Bit 3 = G3D2T. 3C7Ch, Bit 2 = G3D2N. 3C7Ch, Bit 1 = G3D1T. 3C7Ch, Bit 0 = G3D1N. 3C7Ch, Register on page = 432. 3C7Bh, Name = CLC1GLS1. 3C7Bh, Bit 7 = G2D4T. 3C7Bh, Bit 6 = G2D4N. 3C7Bh, Bit 5 = G2D3T. 3C7Bh, Bit 4 = G2D3N. 3C7Bh, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nG2D2T. 3C7Bh, Bit 2 = G2D2N. 3C7Bh, Bit 1 = G2D1T. 3C7Bh, Bit 0 = G2D1N. 3C7Bh, Register on page = 431. 3C7Ah, Name = CLC1GLS0. 3C7Ah, Bit 7 = G1D4T. 3C7Ah, Bit 6 = G1D4N. 3C7Ah, Bit 5 = G1D3T. 3C7Ah, Bit 4 = G1D3N. 3C7Ah, Bit 3 = G1D2T. 3C7Ah, Bit 2 = G1D2N. 3C7Ah, Bit 1 = G1D1T. 3C7Ah, Bit 0 = G1D1N. 3C7Ah, Register on page = 430. 3C79h, Name = CLC1SEL3. 3C79h, Bit 7 = D4S. 3C79h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n6 = D4S. 3C79h, Bit 5 = D4S. 3C79h, Bit 4 = D4S. 3C79h, Bit 3 = D4S. 3C79h, Bit 2 = D4S. 3C79h, Bit 1 = D4S. 3C79h, Bit 0 = D4S. 3C79h, Register on page = 429. 3C78h, Name = CLC1SEL2. 3C78h, Bit 7 = D3S. 3C78h, Bit 6 = D3S. 3C78h, Bit 5 = D3S. 3C78h, Bit 4 = D3S. 3C78h, Bit 3 = D3S. 3C78h, Bit 2 = D3S. 3C78h, Bit 1 = D3S. 3C78h, Bit 0 = D3S. 3C78h, Register on page = 429.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3C77h, Name = CLC1SEL1. 3C77h, Bit 7 = D2S. 3C77h, Bit 6 = D2S. 3C77h, Bit 5 = D2S. 3C77h, Bit 4 = D2S. 3C77h, Bit 3 = D2S. 3C77h, Bit 2 = D2S. 3C77h, Bit 1 = D2S. 3C77h, Bit 0 = D2S. 3C77h, Register on page = 429. 3C76h, Name = CLC1SEL0. 3C76h, Bit 7 = . 3C76h, Bit 6 = . 3C76h, Bit 5 = . 3C76h, Bit 4 = D1S. 3C76h, Bit 3 = . 3C76h, Bit 2 = . 3C76h, Bit 1 = . 3C76h, Bit 0 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3C76h, Register on page = 429. 3C75h, Name = CLC1POL. 3C75h, Bit 7 = POL. 3C75h, Bit 6 = -. 3C75h, Bit 5 = -. 3C75h, Bit 4 = -. 3C75h, Bit 3 = G4POL. 3C75h, Bit 2 = G3POL. 3C75h, Bit 1 = G2POL. 3C75h, Bit 0 = G1POL. 3C75h, Register on page = 428. 3C74h, Name = CLC1CON. 3C74h, Bit 7 = EN. 3C74h, Bit 6 = OE. 3C74h, Bit 5 = OUT. 3C74h, Bit 4 = INTP. 3C74h, Bit 3 = INTN. 3C74h, Bit 2 = . 3C74h, Bit 1 = MODE. 3C74h, Bit 0 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3C74h, Register on page = 427. 3C73h, Name = CLC2GLS3. 3C73h, Bit 7 = G4D4T. 3C73h, Bit 6 = G4D4N. 3C73h, Bit 5 = G4D3T. 3C73h, Bit 4 = G4D3N. 3C73h, Bit 3 = G4D2T. 3C73h, Bit 2 = G4D2N. 3C73h, Bit 1 = G4D1T. 3C73h, Bit 0 = G4D1N. 3C73h, Register on page = 433. 3C72h, Name = CLC2GLS2. 3C72h, Bit 7 = G3D4T. 3C72h, Bit 6 = G3D4N. 3C72h, Bit 5 = G3D3T. 3C72h, Bit 4 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nG3D3N. 3C72h, Bit 3 = G3D2T. 3C72h, Bit 2 = G3D2N. 3C72h, Bit 1 = G3D1T. 3C72h, Bit 0 = G3D1N. 3C72h, Register on page = 432. 3C71h, Name = CLC2GLS1. 3C71h, Bit 7 = G2D4T. 3C71h, Bit 6 = G2D4N. 3C71h, Bit 5 = G2D3T. 3C71h, Bit 4 = G2D3N. 3C71h, Bit 3 = G2D2T. 3C71h, Bit 2 = G2D2N. 3C71h, Bit 1 = G2D1T. 3C71h, Bit 0 = G2D1N. 3C71h, Register on page = 431. 3C70h, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCLC2GLS0. 3C70h, Bit 7 = G1D4T. 3C70h, Bit 6 = G1D4N. 3C70h, Bit 5 = G1D3T. 3C70h, Bit 4 = G1D3N. 3C70h, Bit 3 = G1D2T. 3C70h, Bit 2 = G1D2N. 3C70h, Bit 1 = G1D1T. 3C70h, Bit 0 = G1D1N. 3C70h, Register on page = 430. 3C6Fh, Name = CLC2SEL3. 3C6Fh, Bit 7 = D4S. 3C6Fh, Bit 6 = D4S. 3C6Fh, Bit 5 = D4S. 3C6Fh, Bit 4 = D4S. 3C6Fh, Bit 3 = D4S. 3C6Fh, Bit 2 = D4S. 3C6Fh, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nD4S. 3C6Fh, Bit 0 = D4S. 3C6Fh, Register on page = 429. 3C6Eh, Name = CLC2SEL2. 3C6Eh, Bit 7 = D3S. 3C6Eh, Bit 6 = D3S. 3C6Eh, Bit 5 = D3S. 3C6Eh, Bit 4 = D3S. 3C6Eh, Bit 3 = D3S. 3C6Eh, Bit 2 = D3S. 3C6Eh, Bit 1 = D3S. 3C6Eh, Bit 0 = D3S. 3C6Eh, Register on page = 429. 3C6Dh, Name = CLC2SEL1. 3C6Dh, Bit 7 = D2S. 3C6Dh, Bit 6 = D2S. 3C6Dh, Bit 5 = D2S. 3C6Dh, Bit 4 = D2S. 3C6Dh, Bit 3 = D2S. 3C6Dh, Bit 2",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= D2S. 3C6Dh, Bit 1 = D2S. 3C6Dh, Bit 0 = D2S. 3C6Dh, Register on page = 429. 3C6Ch, Name = CLC2SEL0. 3C6Ch, Bit 7 = D1S. 3C6Ch, Bit 6 = D1S. 3C6Ch, Bit 5 = D1S. 3C6Ch, Bit 4 = D1S. 3C6Ch, Bit 3 = D1S. 3C6Ch, Bit 2 = D1S. 3C6Ch, Bit 1 = D1S. 3C6Ch, Bit 0 = D1S. 3C6Ch, Register on page = 429. 3C6Bh, Name = CLC2POL. 3C6Bh, Bit 7 = POL. 3C6Bh, Bit 6 = -. 3C6Bh, Bit 5 = -. 3C6Bh, Bit 4 = -. 3C6Bh, Bit 3 = G4POL. 3C6Bh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 2 = G3POL. 3C6Bh, Bit 1 = G2POL. 3C6Bh, Bit 0 = G1POL. 3C6Bh, Register on page = 428. 3C6Ah, Name = CLC2CON. 3C6Ah, Bit 7 = EN. 3C6Ah, Bit 6 = OE. 3C6Ah, Bit 5 = OUT. 3C6Ah, Bit 4 = INTP. 3C6Ah, Bit 3 = INTN. 3C6Ah, Bit 2 = . 3C6Ah, Bit 1 = MODE. 3C6Ah, Bit 0 = . 3C6Ah, Register on page = 427. 3C69h, Name = CLC3GLS3. 3C69h, Bit 7 = G4D4T. 3C69h, Bit 6 = G4D4N. 3C69h, Bit 5 = G4D3T. 3C69h, Bit 4 = G4D3N. 3C69h, Bit 3",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= G4D2T. 3C69h, Bit 2 = G4D2N. 3C69h, Bit 1 = G4D1T. 3C69h, Bit 0 = G4D1N. 3C69h, Register on page = 433. 3C68h, Name = CLC3GLS2. 3C68h, Bit 7 = G3D4T. 3C68h, Bit 6 = G3D4N. 3C68h, Bit 5 = G3D3T. 3C68h, Bit 4 = G3D3N. 3C68h, Bit 3 = G3D2T. 3C68h, Bit 2 = G3D2N. 3C68h, Bit 1 = G3D1T. 3C68h, Bit 0 = G3D1N. 3C68h, Register on page = 432. 3C67h, Name = CLC3GLS1. 3C67h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nG2D4T. 3C67h, Bit 6 = G2D4N. 3C67h, Bit 5 = G2D3T. 3C67h, Bit 4 = G2D3N. 3C67h, Bit 3 = G2D2T. 3C67h, Bit 2 = G2D2N. 3C67h, Bit 1 = G2D1T. 3C67h, Bit 0 = G2D1N. 3C67h, Register on page = 431. 3C66h, Name = CLC3GLS0. 3C66h, Bit 7 = G1D4T. 3C66h, Bit 6 = G1D4N. 3C66h, Bit 5 = G1D3T. 3C66h, Bit 4 = G1D3N. 3C66h, Bit 3 = G1D2T. 3C66h, Bit 2 = G1D2N. 3C66h, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nG1D1T. 3C66h, Bit 0 = G1D1N. 3C66h, Register on page = 430. 3C65h, Name = CLC3SEL3. 3C65h, Bit 7 = D4S. 3C65h, Bit 6 = D4S. 3C65h, Bit 5 = D4S. 3C65h, Bit 4 = D4S. 3C65h, Bit 3 = D4S. 3C65h, Bit 2 = D4S. 3C65h, Bit 1 = D4S. 3C65h, Bit 0 = D4S. 3C65h, Register on page = 429. 3C64h, Name = CLC3SEL2. 3C64h, Bit 7 = D3S. 3C64h, Bit 6 = D3S. 3C64h, Bit 5 = D3S. 3C64h, Bit 4 = D3S. 3C64h, Bit 3 = D3S. 3C64h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n2 = D3S. 3C64h, Bit 1 = D3S. 3C64h, Bit 0 = D3S. 3C64h, Register on page = 429. 3C63h, Name = CLC3SEL1. 3C63h, Bit 7 = D2S. 3C63h, Bit 6 = D2S. 3C63h, Bit 5 = D2S. 3C63h, Bit 4 = D2S. 3C63h, Bit 3 = D2S. 3C63h, Bit 2 = D2S. 3C63h, Bit 1 = D2S. 3C63h, Bit 0 = D2S. 3C63h, Register on page = 429. 3C62h, Name = CLC3SEL0. 3C62h, Bit 7 = D1S. 3C62h, Bit 6 = D1S. 3C62h, Bit 5 = D1S.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3C62h, Bit 4 = D1S. 3C62h, Bit 3 = D1S. 3C62h, Bit 2 = D1S. 3C62h, Bit 1 = D1S. 3C62h, Bit 0 = D1S. 3C62h, Register on page = 430. 3C61h, Name = CLC3POL. 3C61h, Bit 7 = POL. 3C61h, Bit 6 = -. 3C61h, Bit 5 = -. 3C61h, Bit 4 = -. 3C61h, Bit 3 = G4POL. 3C61h, Bit 2 = G3POL. 3C61h, Bit 1 = G2POL. 3C61h, Bit 0 = G1POL. 3C61h, Register on page = 428. 3C60h, Name = CLC3CON. 3C60h, Bit 7 = EN. 3C60h, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nOE. 3C60h, Bit 5 = OUT. 3C60h, Bit 4 = INTP. 3C60h, Bit 3 = INTN. 3C60h, Bit 2 = . 3C60h, Bit 1 = MODE. 3C60h, Bit 0 = . 3C60h, Register on page = 427. 3C5Fh, Name = CLC4GLS3. 3C5Fh, Bit 7 = G4D4T. 3C5Fh, Bit 6 = G4D4N. 3C5Fh, Bit 5 = G4D3T. 3C5Fh, Bit 4 = G4D3N. 3C5Fh, Bit 3 = G4D2T. 3C5Fh, Bit 2 = G4D2N. 3C5Fh, Bit 1 = G4D1T. 3C5Fh, Bit 0 = G4D1N. 3C5Fh, Register on page = 433. 3C5Eh, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCLC4GLS2. 3C5Eh, Bit 7 = G3D4T. 3C5Eh, Bit 6 = G3D4N. 3C5Eh, Bit 5 = G3D3T. 3C5Eh, Bit 4 = G3D3N. 3C5Eh, Bit 3 = G3D2T. 3C5Eh, Bit 2 = G3D2N. 3C5Eh, Bit 1 = G3D1T. 3C5Eh, Bit 0 = G3D1N. 3C5Eh, Register on page = 432. 3C5Dh, Name = CLC4GLS1. 3C5Dh, Bit 7 = G2D4T. 3C5Dh, Bit 6 = G2D4N. 3C5Dh, Bit 5 = G2D3T. 3C5Dh, Bit 4 = G2D3N. 3C5Dh, Bit 3 = G2D2T. 3C5Dh, Bit 2 = G2D2N. 3C5Dh, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nG2D1T. 3C5Dh, Bit 0 = G2D1N. 3C5Dh, Register on page = 431. 3C5Ch, Name = CLC4GLS0. 3C5Ch, Bit 7 = G1D4T. 3C5Ch, Bit 6 = G1D4N. 3C5Ch, Bit 5 = G1D3T. 3C5Ch, Bit 4 = G1D3N. 3C5Ch, Bit 3 = G1D2T. 3C5Ch, Bit 2 = G1D2N. 3C5Ch, Bit 1 = G1D1T. 3C5Ch, Bit 0 = G1D1N. 3C5Ch, Register on page = 430. 3C5Bh, Name = CLC4SEL3. 3C5Bh, Bit 7 = D4S. 3C5Bh, Bit 6 = D4S. 3C5Bh, Bit 5 = D4S. 3C5Bh, Bit 4 = D4S.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3C5Bh, Bit 3 = D4S. 3C5Bh, Bit 2 = D4S. 3C5Bh, Bit 1 = D4S. 3C5Bh, Bit 0 = D4S. 3C5Bh, Register on page = 429. 3C5Ah, Name = CLC4SEL2. 3C5Ah, Bit 7 = D3S. 3C5Ah, Bit 6 = D3S. 3C5Ah, Bit 5 = D3S. 3C5Ah, Bit 4 = D3S. 3C5Ah, Bit 3 = D3S. 3C5Ah, Bit 2 = D3S. 3C5Ah, Bit 1 = D3S. 3C5Ah, Bit 0 = D3S. 3C5Ah, Register on page = 429. 3C59h, Name = CLC4SEL1. 3C59h, Bit 7 = D2S D1S. 3C59h, Bit 6 = D2S D1S. 3C59h, Bit 5",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= D2S D1S. 3C59h, Bit 4 = D2S D1S. 3C59h, Bit 3 = D2S D1S. 3C59h, Bit 2 = D2S D1S. 3C59h, Bit 1 = D2S D1S. 3C59h, Bit 0 = D2S D1S. 3C59h, Register on page = 429 430. 3C58h 3C57h, Name = CLC4SEL0 CLC4POL. 3C58h 3C57h, Bit 7 = POL. 3C58h 3C57h, Bit 6 = -. 3C58h 3C57h, Bit 5 = -. 3C58h 3C57h, Bit 4 = -. 3C58h 3C57h, Bit 3 = G4POL. 3C58h 3C57h, Bit 2 = G3POL. 3C58h 3C57h, Bit 1 = G2POL. 3C58h 3C57h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n0 = G1POL. 3C58h 3C57h, Register on page = 428. 3C56h, Name = CLC4CON. 3C56h, Bit 7 = EN. 3C56h, Bit 6 = OE. 3C56h, Bit 5 = OUT. 3C56h, Bit 4 = INTP. 3C56h, Bit 3 = INTN. 3C56h, Bit 2 = . 3C56h, Bit 1 = MODE. 3C56h, Bit 0 = . 3C56h, Register on page = 427\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition Note 1: Not present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3C55h - 3C00h, Name = - Unimplemented. 3C55h - 3C00h, Bit 7 = - Unimplemented. 3C55h - 3C00h, Bit 6 = - Unimplemented. 3C55h - 3C00h, Bit 5 = - Unimplemented. 3C55h - 3C00h, Bit 4 = - Unimplemented. 3C55h - 3C00h, Bit 3 = - Unimplemented. 3C55h - 3C00h, Bit 2 = - Unimplemented. 3C55h - 3C00h, Bit 1 = - Unimplemented. 3C55h - 3C00h, Bit 0 = - Unimplemented. 3C55h - 3C00h, Register on page = -. 3BFFh, Name = DMA1SIRQ SIRQ. 3BFFh, Bit 7 = DMA1SIRQ SIRQ. 3BFFh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 6 = DMA1SIRQ SIRQ. 3BFFh, Bit 5 = DMA1SIRQ SIRQ. 3BFFh, Bit 4 = DMA1SIRQ SIRQ. 3BFFh, Bit 3 = DMA1SIRQ SIRQ. 3BFFh, Bit 2 = DMA1SIRQ SIRQ. 3BFFh, Bit 1 = DMA1SIRQ SIRQ. 3BFFh, Bit 0 = DMA1SIRQ SIRQ. 3BFFh, Register on page = 247. 3BFEh, Name = DMA1AIRQ AIRQ. 3BFEh, Bit 7 = DMA1AIRQ AIRQ. 3BFEh, Bit 6 = DMA1AIRQ AIRQ. 3BFEh, Bit 5 = DMA1AIRQ AIRQ. 3BFEh, Bit 4 = DMA1AIRQ AIRQ. 3BFEh, Bit 3 = DMA1AIRQ AIRQ. 3BFEh, Bit 2 = DMA1AIRQ AIRQ. 3BFEh, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nDMA1AIRQ AIRQ. 3BFEh, Bit 0 = DMA1AIRQ AIRQ. 3BFEh, Register on page = 247. 3BFDh, Name = DMA1CON1 DMODE. 3BFDh, Bit 7 = DMA1CON1 DMODE. 3BFDh, Bit 6 = DMA1CON1 DMODE. 3BFDh, Bit 5 = DSTP. 3BFDh, Bit 4 = SMR. 3BFDh, Bit 3 = SMR. 3BFDh, Bit 2 = SMODE SSTP. 3BFDh, Bit 1 = SMODE SSTP. 3BFDh, Bit 0 = SMODE SSTP. 3BFDh, Register on page = 240. 3BFCh, Name = DMA1CON0. 3BFCh, Bit 7 = EN. 3BFCh, Bit 6 = SIRQEN. 3BFCh, Bit 5 = DGO. 3BFCh, Bit 4 = -. 3BFCh, Bit 3 = -. 3BFCh, Bit 2 = AIRQEN. 3BFCh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 1 = -. 3BFCh, Bit 0 = XIP. 3BFCh, Register on page = 239. 3BFBh, Name = DMA1SSAU. 3BFBh, Bit 7 = -. 3BFBh, Bit 6 = -. 3BFBh, Bit 5 = . 3BFBh, Bit 4 = . 3BFBh, Bit 3 = . 3BFBh, Bit 2 = SSA. 3BFBh, Bit 1 = . 3BFBh, Bit 0 = . 3BFBh, Register on page = 242. 3BFAh, Name = DMA1SSAH SSA. 3BFAh, Bit 7 = DMA1SSAH SSA. 3BFAh, Bit 6 = DMA1SSAH SSA. 3BFAh, Bit 5 = DMA1SSAH SSA. 3BFAh, Bit 4 = DMA1SSAH SSA. 3BFAh, Bit 3 = DMA1SSAH SSA. 3BFAh, Bit 2 = DMA1SSAH SSA. 3BFAh, Bit 1 = DMA1SSAH",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSSA. 3BFAh, Bit 0 = DMA1SSAH SSA. 3BFAh, Register on page = 241. 3BF9h, Name = DMA1SSAL. 3BF9h, Bit 7 = DMA1SSAL. 3BF9h, Bit 6 = DMA1SSAL. 3BF9h, Bit 5 = DMA1SSAL. 3BF9h, Bit 4 = SSA. 3BF9h, Bit 3 = SSA. 3BF9h, Bit 2 = SSA. 3BF9h, Bit 1 = SSA. 3BF9h, Bit 0 = SSA. 3BF9h, Register on page = 241. 3BF8h, Name = DMA1SSZH. 3BF8h, Bit 7 = -. 3BF8h, Bit 6 = -. 3BF8h, Bit 5 = -. 3BF8h, Bit 4 = - SSZ. 3BF8h, Bit 3 = - SSZ. 3BF8h, Bit 2 = - SSZ.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BF8h, Bit 1 = - SSZ. 3BF8h, Bit 0 = - SSZ. 3BF8h, Register on page = 243. 3BF7h, Name = DMA1SSZL. 3BF7h, Bit 7 = . 3BF7h, Bit 6 = . 3BF7h, Bit 5 = . 3BF7h, Bit 4 = SSZ. 3BF7h, Bit 3 = SSZ. 3BF7h, Bit 2 = SSZ. 3BF7h, Bit 1 = SSZ. 3BF7h, Bit 0 = SSZ. 3BF7h, Register on page = 243. 3BF6h, Name = DMA1SPTRU. 3BF6h, Bit 7 = -. 3BF6h, Bit 6 = -. 3BF6h, Bit 5 = . 3BF6h, Bit 4 = SPTR. 3BF6h, Bit 3 = SPTR. 3BF6h, Bit 2 = SPTR. 3BF6h, Bit 1 = SPTR.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BF6h, Bit 0 = SPTR. 3BF6h, Register on page = 243. 3BF5h, Name = DMA1SPTRH. 3BF5h, Bit 7 = DMA1SPTRH. 3BF5h, Bit 6 = DMA1SPTRH. 3BF5h, Bit 5 = DMA1SPTRH. 3BF5h, Bit 4 = SPTR. 3BF5h, Bit 3 = SPTR. 3BF5h, Bit 2 = SPTR. 3BF5h, Bit 1 = SPTR. 3BF5h, Bit 0 = SPTR. 3BF5h, Register on page = 242. 3BF4h, Name = DMA1SPTRL. 3BF4h, Bit 7 = DMA1SPTRL. 3BF4h, Bit 6 = DMA1SPTRL. 3BF4h, Bit 5 = DMA1SPTRL. 3BF4h, Bit 4 = SPTR. 3BF4h, Bit 3 = SPTR.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BF4h, Bit 2 = SPTR. 3BF4h, Bit 1 = SPTR. 3BF4h, Bit 0 = SPTR. 3BF4h, Register on page = 242. 3BF3h, Name = DMA1SCNTH. 3BF3h, Bit 7 = -. 3BF3h, Bit 6 = -. 3BF3h, Bit 5 = -. 3BF3h, Bit 4 = - SCNT. 3BF3h, Bit 3 = - SCNT. 3BF3h, Bit 2 = - SCNT. 3BF3h, Bit 1 = - SCNT. 3BF3h, Bit 0 = - SCNT. 3BF3h, Register on page = 244. 3BF2h, Name = DMA1SCNTL. 3BF2h, Bit 7 = DMA1SCNTL. 3BF2h, Bit 6 = DMA1SCNTL. 3BF2h, Bit 5 = DMA1SCNTL. 3BF2h, Bit 4 = SCNT.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BF2h, Bit 3 = SCNT. 3BF2h, Bit 2 = SCNT. 3BF2h, Bit 1 = SCNT. 3BF2h, Bit 0 = SCNT. 3BF2h, Register on page = 244. 3BF1h, Name = DMA1DSAH. 3BF1h, Bit 7 = DMA1DSAH. 3BF1h, Bit 6 = DMA1DSAH. 3BF1h, Bit 5 = DMA1DSAH. 3BF1h, Bit 4 = DSA. 3BF1h, Bit 3 = DSA. 3BF1h, Bit 2 = DSA. 3BF1h, Bit 1 = DSA. 3BF1h, Bit 0 = DSA. 3BF1h, Register on page = 245. 3BF0h, Name = DMA1DSAL. 3BF0h, Bit 7 = DMA1DSAL. 3BF0h, Bit 6 = DMA1DSAL. 3BF0h, Bit 5 = DMA1DSAL.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BF0h, Bit 4 = SSA. 3BF0h, Bit 3 = SSA. 3BF0h, Bit 2 = SSA. 3BF0h, Bit 1 = SSA. 3BF0h, Bit 0 = SSA. 3BF0h, Register on page = 244. 3BEFh, Name = DMA1DSZH. 3BEFh, Bit 7 = -. 3BEFh, Bit 6 = -. 3BEFh, Bit 5 = -. 3BEFh, Bit 4 = - DSZ. 3BEFh, Bit 3 = - DSZ. 3BEFh, Bit 2 = - DSZ. 3BEFh, Bit 1 = - DSZ. 3BEFh, Bit 0 = - DSZ. 3BEFh, Register on page = 246. 3BEEh, Name = . 3BEEh, Bit 7 = . 3BEEh, Bit 6 = . 3BEEh, Bit 5 = . 3BEEh, Bit 4 = DSZ. 3BEEh, Bit 3 = DSZ.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BEEh, Bit 2 = DSZ. 3BEEh, Bit 1 = DSZ. 3BEEh, Bit 0 = DSZ. 3BEEh, Register on page = 246. 3BEDh, Name = DMA1DSZL DMA1DPTRH. 3BEDh, Bit 7 = DMA1DSZL DMA1DPTRH. 3BEDh, Bit 6 = DMA1DSZL DMA1DPTRH. 3BEDh, Bit 5 = DMA1DSZL DMA1DPTRH. 3BEDh, Bit 4 = DPTR. 3BEDh, Bit 3 = DPTR. 3BEDh, Bit 2 = DPTR. 3BEDh, Bit 1 = DPTR. 3BEDh, Bit 0 = DPTR. 3BEDh, Register on page = 245. 3BECh, Name = DMA1DPTRL. 3BECh, Bit 7 = DMA1DPTRL. 3BECh, Bit 6 = DMA1DPTRL. 3BECh, Bit 5",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= DMA1DPTRL. 3BECh, Bit 4 = DPTR. 3BECh, Bit 3 = DPTR. 3BECh, Bit 2 = DPTR. 3BECh, Bit 1 = DPTR. 3BECh, Bit 0 = DPTR. 3BECh, Register on page = 245. 3BEBh, Name = DMA1DCNTH. 3BEBh, Bit 7 = -. 3BEBh, Bit 6 = -. 3BEBh, Bit 5 = -. 3BEBh, Bit 4 = - DCNT. 3BEBh, Bit 3 = - DCNT. 3BEBh, Bit 2 = - DCNT. 3BEBh, Bit 1 = - DCNT. 3BEBh, Bit 0 = - DCNT. 3BEBh, Register on page = 244. 3BEAh, Name = DMA1DCNTL. 3BEAh, Bit 7 = DMA1DCNTL. 3BEAh, Bit 6 = DMA1DCNTL. 3BEAh, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nDMA1DCNTL. 3BEAh, Bit 4 = DCNT. 3BEAh, Bit 3 = DCNT. 3BEAh, Bit 2 = DCNT. 3BEAh, Bit 1 = DCNT. 3BEAh, Bit 0 = DCNT. 3BEAh, Register on page = 246. 3BE9h, Name = DMA1BUF. 3BE9h, Bit 7 = DMA1BUF. 3BE9h, Bit 6 = DMA1BUF. 3BE9h, Bit 5 = DMA1BUF. 3BE9h, Bit 4 = BUF. 3BE9h, Bit 3 = BUF. 3BE9h, Bit 2 = BUF. 3BE9h, Bit 1 = BUF. 3BE9h, Bit 0 = BUF. 3BE9h, Register on page = 241. 3BE8h- 3BE0h, Name = -. 3BE8h- 3BE0h, Bit 7 = . 3BE8h- 3BE0h, Bit 6 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BE8h- 3BE0h, Bit 5 = . 3BE8h- 3BE0h, Bit 4 = Unimplemented. 3BE8h- 3BE0h, Bit 3 = Unimplemented. 3BE8h- 3BE0h, Bit 2 = Unimplemented. 3BE8h- 3BE0h, Bit 1 = Unimplemented. 3BE8h- 3BE0h, Bit 0 = Unimplemented. 3BE8h- 3BE0h, Register on page = -. 3BDFh, Name = DMA2SIRQ -. 3BDFh, Bit 7 = DMA2SIRQ -. 3BDFh, Bit 6 = DMA2SIRQ -. 3BDFh, Bit 5 = DMA2SIRQ -. 3BDFh, Bit 4 = SIRQ. 3BDFh, Bit 3 = SIRQ. 3BDFh, Bit 2 = SIRQ. 3BDFh, Bit 1 = SIRQ.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BDFh, Bit 0 = SIRQ. 3BDFh, Register on page = 247. 3BDEh, Name = DMA2AIRQ -. 3BDEh, Bit 7 = DMA2AIRQ -. 3BDEh, Bit 6 = DMA2AIRQ -. 3BDEh, Bit 5 = DMA2AIRQ -. 3BDEh, Bit 4 = AIRQ. 3BDEh, Bit 3 = AIRQ. 3BDEh, Bit 2 = AIRQ. 3BDEh, Bit 1 = AIRQ. 3BDEh, Bit 0 = AIRQ. 3BDEh, Register on page = 247. 3BDDh, Name = DMA2CON1 DMODE DSTP. 3BDDh, Bit 7 = DMA2CON1 DMODE DSTP. 3BDDh, Bit 6 = DMA2CON1 DMODE DSTP. 3BDDh, Bit 5 = DMA2CON1 DMODE DSTP. 3BDDh, Bit 4 = SMR SMODE SSTP.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BDDh, Bit 3 = SMR SMODE SSTP. 3BDDh, Bit 2 = SMR SMODE SSTP. 3BDDh, Bit 1 = SMR SMODE SSTP. 3BDDh, Bit 0 = SMR SMODE SSTP. 3BDDh, Register on page = . 3BDCh, Name = DMA2CON0 EN. 3BDCh, Bit 7 = . 3BDCh, Bit 6 = . 3BDCh, Bit 5 = . 3BDCh, Bit 4 = -. 3BDCh, Bit 3 = . 3BDCh, Bit 2 = . 3BDCh, Bit 1 = . 3BDCh, Bit 0 = . 3BDCh, Register on page = 240 239. , Name = DMA2SSAU. , Bit 7 = . , Bit 6 = SIRQEN. , Bit 5 = DGO. , Bit 4 = - AIRQEN - XIP SSA. , Bit 3 = - AIRQEN - XIP SSA. , Bit 2 = -",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nAIRQEN - XIP SSA. , Bit 1 = - AIRQEN - XIP SSA. , Bit 0 = - AIRQEN - XIP SSA. , Register on page = 242. 3BDBh 3BDAh, Name = - - DMA2SSAH. 3BDBh 3BDAh, Bit 7 = - - DMA2SSAH. 3BDBh 3BDAh, Bit 6 = - - DMA2SSAH. 3BDBh 3BDAh, Bit 5 = - - DMA2SSAH. 3BDBh 3BDAh, Bit 4 = SSA. 3BDBh 3BDAh, Bit 3 = SSA. 3BDBh 3BDAh, Bit 2 = SSA. 3BDBh 3BDAh, Bit 1 = SSA. 3BDBh 3BDAh, Bit 0 = SSA. 3BDBh 3BDAh, Register on page = 241. 3BD9h, Name = DMA2SSAL. 3BD9h, Bit 7 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BD9h, Bit 6 = . 3BD9h, Bit 5 = . 3BD9h, Bit 4 = SSA. 3BD9h, Bit 3 = SSA. 3BD9h, Bit 2 = SSA. 3BD9h, Bit 1 = SSA. 3BD9h, Bit 0 = SSA. 3BD9h, Register on page = 241. 3BD8h, Name = DMA2SSZH. 3BD8h, Bit 7 = . 3BD8h, Bit 6 = . 3BD8h, Bit 5 = . 3BD8h, Bit 4 = - SSZ. 3BD8h, Bit 3 = - SSZ. 3BD8h, Bit 2 = - SSZ. 3BD8h, Bit 1 = - SSZ. 3BD8h, Bit 0 = - SSZ. 3BD8h, Register on page = 243. 3BD7h, Name = - - - DMA2SSZL.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BD7h, Bit 7 = - - - DMA2SSZL. 3BD7h, Bit 6 = - - - DMA2SSZL. 3BD7h, Bit 5 = - - - DMA2SSZL. 3BD7h, Bit 4 = SSZ. 3BD7h, Bit 3 = SSZ. 3BD7h, Bit 2 = SSZ. 3BD7h, Bit 1 = SSZ. 3BD7h, Bit 0 = SSZ. 3BD7h, Register on page = 243. 3BD6h, Name = DMA2SPTRU - -. 3BD6h, Bit 7 = DMA2SPTRU - -. 3BD6h, Bit 6 = DMA2SPTRU - -. 3BD6h, Bit 5 = DMA2SPTRU - -. 3BD6h, Bit 4 = SPTR. 3BD6h, Bit 3 = SPTR. 3BD6h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n2 = SPTR. 3BD6h, Bit 1 = SPTR. 3BD6h, Bit 0 = SPTR. 3BD6h, Register on page = 243. 3BD5h, Name = DMA2SPTRH. 3BD5h, Bit 7 = . 3BD5h, Bit 6 = . 3BD5h, Bit 5 = . 3BD5h, Bit 4 = SPTR. 3BD5h, Bit 3 = SPTR. 3BD5h, Bit 2 = SPTR. 3BD5h, Bit 1 = SPTR. 3BD5h, Bit 0 = SPTR. 3BD5h, Register on page = 242. 3BD4h, Name = DMA2SPTRL. 3BD4h, Bit 7 = . 3BD4h, Bit 6 = . 3BD4h, Bit 5 = . 3BD4h, Bit 4 = SPTR. 3BD4h, Bit 3 = SPTR.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BD4h, Bit 2 = SPTR. 3BD4h, Bit 1 = SPTR. 3BD4h, Bit 0 = SPTR. 3BD4h, Register on page = 242. 3BD3h, Name = DMA2SCNTH - - -. 3BD3h, Bit 7 = DMA2SCNTH - - -. 3BD3h, Bit 6 = DMA2SCNTH - - -. 3BD3h, Bit 5 = DMA2SCNTH - - -. 3BD3h, Bit 4 = - SCNT SCNT. 3BD3h, Bit 3 = - SCNT SCNT. 3BD3h, Bit 2 = - SCNT SCNT. 3BD3h, Bit 1 = - SCNT SCNT. 3BD3h, Bit 0 = - SCNT SCNT. 3BD3h, Register on page = 244. 3BD2h, Name = DMA2SCNTL. 3BD2h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 7 = . 3BD2h, Bit 6 = . 3BD2h, Bit 5 = . 3BD2h, Bit 4 = . 3BD2h, Bit 3 = . 3BD2h, Bit 2 = . 3BD2h, Bit 1 = . 3BD2h, Bit 0 = . 3BD2h, Register on page = 244. , Name = . , Bit 7 = . , Bit 6 = . , Bit 5 = . , Bit 4 = DSA SSA. , Bit 3 = DSA SSA. , Bit 2 = DSA SSA. , Bit 1 = DSA SSA. , Bit 0 = DSA SSA. , Register on page = . 3BD0h, Name = DMA2DSAL. 3BD0h, Bit 7 = . 3BD0h, Bit 6 = . 3BD0h, Bit 5 = . 3BD0h, Bit 4 = . 3BD0h, Bit 3 = . 3BD0h, Bit 2 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BD0h, Bit 1 = . 3BD0h, Bit 0 = . 3BD0h, Register on page = 244. 3BCFh, Name = DMA2DSZH. 3BCFh, Bit 7 = -. 3BCFh, Bit 6 = -. 3BCFh, Bit 5 = -. 3BCFh, Bit 4 = -. 3BCFh, Bit 3 = . 3BCFh, Bit 2 = . 3BCFh, Bit 1 = . 3BCFh, Bit 0 = . 3BCFh, Register on page = 246. 3BCDh, Name = DMA2DPTRH. 3BCDh, Bit 7 = DMA2DPTRH. 3BCDh, Bit 6 = DMA2DPTRH. 3BCDh, Bit 5 = DMA2DPTRH. 3BCDh, Bit 4 = DPTR. 3BCDh, Bit 3 = DPTR. 3BCDh, Bit 2 = DPTR. 3BCDh, Bit 1 = DPTR.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BCDh, Bit 0 = DPTR. 3BCDh, Register on page = 245. 3BCCh, Name = . 3BCCh, Bit 7 = . 3BCCh, Bit 6 = . 3BCCh, Bit 5 = . 3BCCh, Bit 4 = . 3BCCh, Bit 3 = . 3BCCh, Bit 2 = . 3BCCh, Bit 1 = . 3BCCh, Bit 0 = . 3BCCh, Register on page = . , Name = . , Bit 7 = . , Bit 6 = . , Bit 5 = . , Bit 4 = . , Bit 3 = . , Bit 2 = . , Bit 1 = . , Bit 0 = . , Register on page = 245. 3BCBh, Name = DMA2DPTRL. 3BCBh, Bit 7 = DMA2DPTRL. 3BCBh, Bit 6 = DMA2DPTRL. 3BCBh, Bit 5 = DMA2DPTRL. 3BCBh, Bit 4 = DPTR -. 3BCBh, Bit 3 = DPTR -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BCBh, Bit 2 = DPTR -. 3BCBh, Bit 1 = DPTR -. 3BCBh, Bit 0 = DPTR -. 3BCBh, Register on page = 244. , Name = DMA2DCNTH - - - DMA2DCNTL. , Bit 7 = DMA2DCNTH - - - DMA2DCNTL. , Bit 6 = DMA2DCNTH - - - DMA2DCNTL. , Bit 5 = DMA2DCNTH - - - DMA2DCNTL. , Bit 4 = DCNT DCNT. , Bit 3 = DCNT DCNT. , Bit 2 = DCNT DCNT. , Bit 1 = DCNT DCNT. , Bit 0 = DCNT DCNT. , Register on page = . 3BC9h, Name = DMA2BUF. 3BC9h, Bit 7 = DMA2BUF. 3BC9h, Bit 6 = DMA2BUF. 3BC9h, Bit 5 = DMA2BUF.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BC9h, Bit 4 = BUF. 3BC9h, Bit 3 = BUF. 3BC9h, Bit 2 = BUF. 3BC9h, Bit 1 = BUF. 3BC9h, Bit 0 = BUF. 3BC9h, Register on page = 241\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: Not present in LF devices.\nDS40001943C-page 778",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3BC8h- 3AEEh, Name = - Unimplemented. 3BC8h- 3AEEh, Bit 7 = - Unimplemented. 3BC8h- 3AEEh, Bit 6 = - Unimplemented. 3BC8h- 3AEEh, Bit 5 = - Unimplemented. 3BC8h- 3AEEh, Bit 4 = - Unimplemented. 3BC8h- 3AEEh, Bit 3 Bit 2 = - Unimplemented. 3BC8h- 3AEEh, Bit 0 = - Unimplemented. 3BC8h- 3AEEh, Register on page = -. 3AEDh, Name = CANRXPPS. 3AEDh, Bit 7 = -. 3AEDh, Bit 6 = -. 3AEDh, Bit 5 = -. 3AEDh, Bit 4 = . 3AEDh, Bit 3 Bit 2 = CANRXPPS. 3AEDh, Bit 0 = . 3AEDh, Register on page = 265. 3AECh, Name",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= - Unimplemented. 3AECh, Bit 7 = - Unimplemented. 3AECh, Bit 6 = - Unimplemented. 3AECh, Bit 5 = - Unimplemented. 3AECh, Bit 4 = - Unimplemented. 3AECh, Bit 3 Bit 2 = - Unimplemented. 3AECh, Bit 0 = - Unimplemented. 3AECh, Register on page = -. 3AEBh, Name = U2CTSPPS. 3AEBh, Bit 7 = -. 3AEBh, Bit 6 = -. 3AEBh, Bit 5 = -. 3AEBh, Bit 4 = . 3AEBh, Bit 3 Bit 2 = U2CTSPPS. 3AEBh, Bit 0 = . 3AEBh, Register on page = 265. 3AEAh, Name = U2RXPPS. 3AEAh, Bit 7 = -. 3AEAh, Bit 6 = -. 3AEAh, Bit 5 = -. 3AEAh, Bit 4 = . 3AEAh, Bit 3 Bit 2 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nU2RXPPS. 3AEAh, Bit 0 = . 3AEAh, Register on page = 265. 3AE9h, Name = - Unimplemented. 3AE9h, Bit 7 = - Unimplemented. 3AE9h, Bit 6 = - Unimplemented. 3AE9h, Bit 5 = - Unimplemented. 3AE9h, Bit 4 = - Unimplemented. 3AE9h, Bit 3 Bit 2 = - Unimplemented. 3AE9h, Bit 0 = - Unimplemented. 3AE9h, Register on page = -. 3AE8h, Name = U1CTSPPS. 3AE8h, Bit 7 = -. 3AE8h, Bit 6 = -. 3AE8h, Bit 5 = -. 3AE8h, Bit 4 = . 3AE8h, Bit 3 Bit 2 = U1CTSPPS. 3AE8h, Bit 0 = . 3AE8h, Register on page = 265. 3AE7h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nName = U1RXPPS. 3AE7h, Bit 7 = -. 3AE7h, Bit 6 = -. 3AE7h, Bit 5 = -. 3AE7h, Bit 4 = . 3AE7h, Bit 3 Bit 2 = U1RXPPS. 3AE7h, Bit 0 = . 3AE7h, Register on page = 265. 3AE6h, Name = I2C2SDAPPS. 3AE6h, Bit 7 = -. 3AE6h, Bit 6 = -. 3AE6h, Bit 5 = -. 3AE6h, Bit 4 = . 3AE6h, Bit 3 Bit 2 = I2C2SDAPPS. 3AE6h, Bit 0 = . 3AE6h, Register on page = 265. 3AE5h, Name = I2C2SCLPPS. 3AE5h, Bit 7 = -. 3AE5h, Bit 6 = -. 3AE5h, Bit 5 = -. 3AE5h, Bit 4 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3AE5h, Bit 3 Bit 2 = I2C2SCLPPS. 3AE5h, Bit 0 = . 3AE5h, Register on page = 265. 3AE4h, Name = I2C1SDAPPS. 3AE4h, Bit 7 = -. 3AE4h, Bit 6 = -. 3AE4h, Bit 5 = -. 3AE4h, Bit 4 = . 3AE4h, Bit 3 Bit 2 = I2C1SDAPPS. 3AE4h, Bit 0 = . 3AE4h, Register on page = 265. 3AE3h, Name = I2C1SCLPPS. 3AE3h, Bit 7 = -. 3AE3h, Bit 6 = -. 3AE3h, Bit 5 = -. 3AE3h, Bit 4 = . 3AE3h, Bit 3 Bit 2 = I2C1SCLPPS. 3AE3h, Bit 0 = . 3AE3h, Register on page = 265. 3AE2h, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSPI1SSPPS. 3AE2h, Bit 7 = -. 3AE2h, Bit 6 = -. 3AE2h, Bit 5 = -. 3AE2h, Bit 4 = . 3AE2h, Bit 3 Bit 2 = SPI1SSPPS. 3AE2h, Bit 0 = . 3AE2h, Register on page = 265. 3AE1h, Name = SPI1SDIPPS. 3AE1h, Bit 7 = -. 3AE1h, Bit 6 = -. 3AE1h, Bit 5 = -. 3AE1h, Bit 4 = . 3AE1h, Bit 3 Bit 2 = SPI1SDIPPS. 3AE1h, Bit 0 = . 3AE1h, Register on page = 265. 3AE0h, Name = SPI1SCKPPS. 3AE0h, Bit 7 = -. 3AE0h, Bit 6 = -. 3AE0h, Bit 5 = -. 3AE0h, Bit 4 = . 3AE0h, Bit 3",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 2 = SPI1SCKPPS. 3AE0h, Bit 0 = . 3AE0h, Register on page = 265. 3ADFh, Name = ADACTPPS. 3ADFh, Bit 7 = -. 3ADFh, Bit 6 = -. 3ADFh, Bit 5 = -. 3ADFh, Bit 4 = . 3ADFh, Bit 3 Bit 2 = ADACTPPS. 3ADFh, Bit 0 = . 3ADFh, Register on page = 265. 3ADEh, Name = CLCIN3PPS. 3ADEh, Bit 7 = -. 3ADEh, Bit 6 = -. 3ADEh, Bit 5 = -. 3ADEh, Bit 4 = . 3ADEh, Bit 3 Bit 2 = CLCIN3PPS. 3ADEh, Bit 0 = . 3ADEh, Register on page = 265. 3ADDh, Name = CLCIN2PPS. 3ADDh, Bit 7 = -. 3ADDh, Bit 6 = -. 3ADDh, Bit 5 = -. 3ADDh, Bit 4 = . 3ADDh, Bit 3 Bit 2 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCLCIN2PPS. 3ADDh, Bit 0 = . 3ADDh, Register on page = 265. 3ADCh, Name = CLCIN1PPS. 3ADCh, Bit 7 = -. 3ADCh, Bit 6 = -. 3ADCh, Bit 5 = -. 3ADCh, Bit 4 = . 3ADCh, Bit 3 Bit 2 = CLCIN1PPS. 3ADCh, Bit 0 = . 3ADCh, Register on page = 265. 3ADBh, Name = CLCIN0PPS. 3ADBh, Bit 7 = -. 3ADBh, Bit 6 = -. 3ADBh, Bit 5 = -. 3ADBh, Bit 4 = . 3ADBh, Bit 3 Bit 2 = CLCIN0PPS. 3ADBh, Bit 0 = . 3ADBh, Register on page = 265. 3ADAh, Name = MD1SRCPPS. 3ADAh, Bit 7 = -. 3ADAh, Bit 6 = -. 3ADAh, Bit 5 = -. 3ADAh, Bit 4 = . 3ADAh, Bit 3 Bit 2 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nMD1SRCPPS. 3ADAh, Bit 0 = . 3ADAh, Register on page = 265. 3AD9h, Name = MD1CARHPPS. 3AD9h, Bit 7 = -. 3AD9h, Bit 6 = -. 3AD9h, Bit 5 = -. 3AD9h, Bit 4 = . 3AD9h, Bit 3 Bit 2 = MD1CARHPPS. 3AD9h, Bit 0 = . 3AD9h, Register on page = 265. 3AD8h, Name = MD1CARLPPS. 3AD8h, Bit 7 = -. 3AD8h, Bit 6 = -. 3AD8h, Bit 5 = -. 3AD8h, Bit 4 = . 3AD8h, Bit 3 Bit 2 = MD1CARLPPS. 3AD8h, Bit 0 = . 3AD8h, Register on page = 265. 3AD7h, Name = CWG3INPPS. 3AD7h, Bit 7 = -. 3AD7h, Bit 6 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3AD7h, Bit 5 = -. 3AD7h, Bit 4 = . 3AD7h, Bit 3 Bit 2 = CWG3INPPS. 3AD7h, Bit 0 = . 3AD7h, Register on page = 265. 3AD6h, Name = CWG2INPPS. 3AD6h, Bit 7 = -. 3AD6h, Bit 6 = -. 3AD6h, Bit 5 = -. 3AD6h, Bit 4 = . 3AD6h, Bit 3 Bit 2 = CWG2INPPS. 3AD6h, Bit 0 = . 3AD6h, Register on page = 265. 3AD5h, Name = CWG1INPPS. 3AD5h, Bit 7 = -. 3AD5h, Bit 6 = -. 3AD5h, Bit 5 = -. 3AD5h, Bit 4 = . 3AD5h, Bit 3 Bit 2 = CWG1INPPS. 3AD5h, Bit 0 = . 3AD5h, Register on page = 265.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3AD4h, Name = SMT2SIGPPS. 3AD4h, Bit 7 = -. 3AD4h, Bit 6 = -. 3AD4h, Bit 5 = -. 3AD4h, Bit 4 = . 3AD4h, Bit 3 Bit 2 = SMT2SIGPPS. 3AD4h, Bit 0 = . 3AD4h, Register on page = 265. 3AD3h, Name = SMT2WINPPS. 3AD3h, Bit 7 = -. 3AD3h, Bit 6 = -. 3AD3h, Bit 5 = -. 3AD3h, Bit 4 = . 3AD3h, Bit 3 Bit 2 = SMT2WINPPS. 3AD3h, Bit 0 = . 3AD3h, Register on page = 265. 3AD2h, Name = SMT1SIGPPS. 3AD2h, Bit 7 = -. 3AD2h, Bit 6 = -. 3AD2h, Bit 5 = -. 3AD2h, Bit 4 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3AD2h, Bit 3 Bit 2 = SMT1SIGPPS. 3AD2h, Bit 0 = . 3AD2h, Register on page = 265. 3AD1h, Name = SMT1WINPPS. 3AD1h, Bit 7 = -. 3AD1h, Bit 6 = -. 3AD1h, Bit 5 = -. 3AD1h, Bit 4 = . 3AD1h, Bit 3 Bit 2 = SMT1WINPPS. 3AD1h, Bit 0 = . 3AD1h, Register on page = 265. 3AD0h, Name = CCP4PPS. 3AD0h, Bit 7 = -. 3AD0h, Bit 6 = -. 3AD0h, Bit 5 = -. 3AD0h, Bit 4 = . 3AD0h, Bit 3 Bit 2 = CCP4PPS. 3AD0h, Bit 0 = . 3AD0h, Register on page = 265. 3ACFh, Name = CCP3PPS. 3ACFh, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n-. 3ACFh, Bit 6 = -. 3ACFh, Bit 5 = -. 3ACFh, Bit 4 = . 3ACFh, Bit 3 Bit 2 = CCP3PPS. 3ACFh, Bit 0 = . 3ACFh, Register on page = 265. 3ACEh, Name = CCP2PPS. 3ACEh, Bit 7 = -. 3ACEh, Bit 6 = -. 3ACEh, Bit 5 = -. 3ACEh, Bit 4 = . 3ACEh, Bit 3 Bit 2 = CCP2PPS. 3ACEh, Bit 0 = . 3ACEh, Register on page = 265. 3ACDh, Name = CCP1PPS. 3ACDh, Bit 7 = -. 3ACDh, Bit 6 = -. 3ACDh, Bit 5 = -. 3ACDh, Bit 4 = . 3ACDh, Bit 3 Bit 2 = CCP1PPS. 3ACDh, Bit 0 = . 3ACDh, Register on page = 265. 3ACCh, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nT6INPPS. 3ACCh, Bit 7 = -. 3ACCh, Bit 6 = -. 3ACCh, Bit 5 = -. 3ACCh, Bit 4 = . 3ACCh, Bit 3 Bit 2 = T6INPPS. 3ACCh, Bit 0 = . 3ACCh, Register on page = 265. 3ACBh, Name = T4INPPS. 3ACBh, Bit 7 = -. 3ACBh, Bit 6 = -. 3ACBh, Bit 5 = -. 3ACBh, Bit 4 = . 3ACBh, Bit 3 Bit 2 = T4INPPS. 3ACBh, Bit 0 = . 3ACBh, Register on page = 265. 3ACAh, Name = T2INPPS. 3ACAh, Bit 7 = -. 3ACAh, Bit 6 = -. 3ACAh, Bit 5 = -. 3ACAh, Bit 4 = . 3ACAh, Bit 3 Bit 2 = T2INPPS. 3ACAh, Bit 0 = . 3ACAh, Register on page = 265.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3AC9h, Name = T5GPPS. 3AC9h, Bit 7 = -. 3AC9h, Bit 6 = -. 3AC9h, Bit 5 = -. 3AC9h, Bit 4 = . 3AC9h, Bit 3 Bit 2 = T5GPPS. 3AC9h, Bit 0 = . 3AC9h, Register on page = 265. 3AC8h, Name = T5CLKIPPS. 3AC8h, Bit 7 = -. 3AC8h, Bit 6 = -. 3AC8h, Bit 5 = -. 3AC8h, Bit 4 = . 3AC8h, Bit 3 Bit 2 = T5CLKIPPS. 3AC8h, Bit 0 = . 3AC8h, Register on page = 265. 3AC7h, Name = T3GPPS. 3AC7h, Bit 7 = -. 3AC7h, Bit 6 = -. 3AC7h, Bit 5 = -. 3AC7h, Bit 4 = . 3AC7h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3 Bit 2 = T3GPPS. 3AC7h, Bit 0 = . 3AC7h, Register on page = 265. 3AC6h, Name = T3CLKIPPS. 3AC6h, Bit 7 = -. 3AC6h, Bit 6 = -. 3AC6h, Bit 5 = -. 3AC6h, Bit 4 = . 3AC6h, Bit 3 Bit 2 = T3CLKIPPS. 3AC6h, Bit 0 = . 3AC6h, Register on page = 265. 3AC5h, Name = T1GPPS. 3AC5h, Bit 7 = -. 3AC5h, Bit 6 = -. 3AC5h, Bit 5 = - -. 3AC5h, Bit 4 = . 3AC5h, Bit 3 Bit 2 = T1GPPS. 3AC5h, Bit 0 = . 3AC5h, Register on page = 265. 3AC4h, Name = T1CKIPPS. 3AC4h, Bit 7 = -. 3AC4h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 6 = - -. 3AC4h, Bit 5 = -. 3AC4h, Bit 4 = . 3AC4h, Bit 3 Bit 2 = T1CKIPPS. 3AC4h, Bit 0 = . 3AC4h, Register on page = 265. 3AC3h, Name = T0CKIPPS. 3AC3h, Bit 7 = -. 3AC3h, Bit 6 = . 3AC3h, Bit 5 = -. 3AC3h, Bit 4 = . 3AC3h, Bit 3 Bit 2 = T0CKIPPS. 3AC3h, Bit 0 = . 3AC3h, Register on page = 265. 3AC2h 3AC1h, Name = INT2PPS INT1PPS. 3AC2h 3AC1h, Bit 7 = - -. 3AC2h 3AC1h, Bit 6 = - -. 3AC2h 3AC1h, Bit 5 = -. 3AC2h 3AC1h, Bit 4 = . 3AC2h 3AC1h, Bit 3",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 2 = INT2PPS INT1PPS. 3AC2h 3AC1h, Bit 0 = . 3AC2h 3AC1h, Register on page = 265 265. 3AC0h, Name = INT0PPS. 3AC0h, Bit 7 = -. 3AC0h, Bit 6 = -. 3AC0h, Bit 5 = -. 3AC0h, Bit 4 = . 3AC0h, Bit 3 Bit 2 = INT0PPS. 3AC0h, Bit 0 = . 3AC0h, Register on page = 265. 3ABFh, Name = PPSLOCK. 3ABFh, Bit 7 = -. 3ABFh, Bit 6 = -. 3ABFh, Bit 5 = -. 3ABFh, Bit 4 = - -. 3ABFh, Bit 3 Bit 2 = -. 3ABFh, Bit 0 = PPSLOCKED. 3ABFh, Register on page = 269",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition Note 1: Not present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3ABEh -, Name = - Unimplemented. 3ABEh -, Bit 7 = - Unimplemented. 3ABEh -, Bit 6 = - Unimplemented. 3ABEh -, Bit 5 = - Unimplemented. 3ABEh -, Bit 4 = - Unimplemented. 3ABEh -, Bit 3 = - Unimplemented. 3ABEh -, Bit 2 = - Unimplemented. 3ABEh -, Bit 1 = - Unimplemented. 3ABEh -, Bit 0 = - Unimplemented. 3ABEh -, Register on page = -. 3A87h, Name = IOCEF. 3A87h, Bit 7 = -. 3A87h, Bit 6 = -. 3A87h, Bit 5 = -. 3A87h, Bit 4 = -. 3A87h, Bit 3 = IOCEF3. 3A87h, Bit 2 = -. 3A87h, Bit 1 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A87h, Bit 0 = -. 3A87h, Register on page = 273. 3A86h, Name = IOCEN. 3A86h, Bit 7 = -. 3A86h, Bit 6 = -. 3A86h, Bit 5 = -. 3A86h, Bit 4 = -. 3A86h, Bit 3 = IOCEN3. 3A86h, Bit 2 = -. 3A86h, Bit 1 = -. 3A86h, Bit 0 = -. 3A86h, Register on page = 273. 3A85h, Name = IOCEP. 3A85h, Bit 7 = -. 3A85h, Bit 6 = -. 3A85h, Bit 5 = -. 3A85h, Bit 4 = -. 3A85h, Bit 3 = IOCEP3. 3A85h, Bit 2 = -. 3A85h, Bit 1 = -. 3A85h, Bit 0 = -. 3A85h, Register on page = 273. 3A84h, Name = INLVLE. 3A84h, Bit 7 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A84h, Bit 6 = -. 3A84h, Bit 5 = -. 3A84h, Bit 4 = -. 3A84h, Bit 3 = INLVLE3. 3A84h, Bit 2 = -. 3A84h, Bit 1 = -. 3A84h, Bit 0 = -. 3A84h, Register on page = 260. 3A83h, Name = - Unimplemented. 3A83h, Bit 7 = - Unimplemented. 3A83h, Bit 6 = - Unimplemented. 3A83h, Bit 5 = - Unimplemented. 3A83h, Bit 4 = - Unimplemented. 3A83h, Bit 3 = - Unimplemented. 3A83h, Bit 2 = - Unimplemented. 3A83h, Bit 1 = - Unimplemented. 3A83h, Bit 0 = - Unimplemented. 3A83h, Register on page = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A82h, Name = - Unimplemented. 3A82h, Bit 7 = - Unimplemented. 3A82h, Bit 6 = - Unimplemented. 3A82h, Bit 5 = - Unimplemented. 3A82h, Bit 4 = - Unimplemented. 3A82h, Bit 3 = - Unimplemented. 3A82h, Bit 2 = - Unimplemented. 3A82h, Bit 1 = - Unimplemented. 3A82h, Bit 0 = - Unimplemented. 3A82h, Register on page = -. 3A81h, Name = WPUE. 3A81h, Bit 7 = -. 3A81h, Bit 6 = -. 3A81h, Bit 5 = -. 3A81h, Bit 4 = -. 3A81h, Bit 3 = WPUE3. 3A81h, Bit 2 = -. 3A81h, Bit 1 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A81h, Bit 0 = -. 3A81h, Register on page = 257. 3A80h- 3A6Ch, Name = - Unimplemented. 3A80h- 3A6Ch, Bit 7 = - Unimplemented. 3A80h- 3A6Ch, Bit 6 = - Unimplemented. 3A80h- 3A6Ch, Bit 5 = - Unimplemented. 3A80h- 3A6Ch, Bit 4 = - Unimplemented. 3A80h- 3A6Ch, Bit 3 = - Unimplemented. 3A80h- 3A6Ch, Bit 2 = - Unimplemented. 3A80h- 3A6Ch, Bit 1 = - Unimplemented. 3A80h- 3A6Ch, Bit 0 = - Unimplemented. 3A80h- 3A6Ch, Register on page = -. 3A6Bh, Name = RC4I2C. 3A6Bh, Bit 7 = -. 3A6Bh, Bit 6 = SLEW. 3A6Bh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 5 = . 3A6Bh, Bit 4 = PU. 3A6Bh, Bit 3 = -. 3A6Bh, Bit 2 = -. 3A6Bh, Bit 1 = TH. 3A6Bh, Bit 0 = TH. 3A6Bh, Register on page = 253. 3A6Ah, Name = RC3I2C. 3A6Ah, Bit 7 = -. 3A6Ah, Bit 6 = SLEW. 3A6Ah, Bit 5 = . 3A6Ah, Bit 4 = PU. 3A6Ah, Bit 3 = -. 3A6Ah, Bit 2 = -. 3A6Ah, Bit 1 = TH. 3A6Ah, Bit 0 = TH. 3A6Ah, Register on page = 253. 3A69h, Name = - Unimplemented. 3A69h, Bit 7 = - Unimplemented. 3A69h, Bit 6 = - Unimplemented. 3A69h, Bit 5 = - Unimplemented. 3A69h, Bit 4 = - Unimplemented.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A69h, Bit 3 = - Unimplemented. 3A69h, Bit 2 = - Unimplemented. 3A69h, Bit 1 = - Unimplemented. 3A69h, Bit 0 = - Unimplemented. 3A69h, Register on page = -. 3A68h, Name = - Unimplemented. 3A68h, Bit 7 = - Unimplemented. 3A68h, Bit 6 = - Unimplemented. 3A68h, Bit 5 = - Unimplemented. 3A68h, Bit 4 = - Unimplemented. 3A68h, Bit 3 = - Unimplemented. 3A68h, Bit 2 = - Unimplemented. 3A68h, Bit 1 = - Unimplemented. 3A68h, Bit 0 = - Unimplemented. 3A68h, Register on page = -. 3A67h, Name = IOCCF.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A67h, Bit 7 = IOCCF7. 3A67h, Bit 6 = IOCCF6. 3A67h, Bit 5 = IOCCF5. 3A67h, Bit 4 = IOCCF4. 3A67h, Bit 3 = IOCCF3. 3A67h, Bit 2 = IOCCF2. 3A67h, Bit 1 = IOCCF1. 3A67h, Bit 0 = IOCCF0. 3A67h, Register on page = 273. 3A66h, Name = IOCCN. 3A66h, Bit 7 = IOCCN7. 3A66h, Bit 6 = IOCCN6. 3A66h, Bit 5 = IOCCN5. 3A66h, Bit 4 = IOCCN4. 3A66h, Bit 3 = IOCCN3. 3A66h, Bit 2 = IOCCN2. 3A66h, Bit 1 = IOCCN1. 3A66h, Bit 0 = IOCCN0. 3A66h, Register on page = 273.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A65h, Name = IOCCP. 3A65h, Bit 7 = IOCCP7. 3A65h, Bit 6 = IOCCP6. 3A65h, Bit 5 = IOCCP5. 3A65h, Bit 4 = IOCCP4. 3A65h, Bit 3 = IOCCP3. 3A65h, Bit 2 = IOCCP2. 3A65h, Bit 1 = IOCCP1. 3A65h, Bit 0 = IOCCP0. 3A65h, Register on page = 273. 3A64h, Name = INLVLC. 3A64h, Bit 7 = INLVLC7. 3A64h, Bit 6 = INLVLC6. 3A64h, Bit 5 = INLVLC5. 3A64h, Bit 4 = INLVLC4. 3A64h, Bit 3 = INLVLC3. 3A64h, Bit 2 = INLVLC2. 3A64h, Bit 1 = INLVLC1. 3A64h, Bit 0 = INLVLC0. 3A64h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n260. 3A63h, Name = SLRCONC. 3A63h, Bit 7 = SLRC7. 3A63h, Bit 6 = SLRC6. 3A63h, Bit 5 = SLRC5. 3A63h, Bit 4 = SLRC4. 3A63h, Bit 3 = SLRC3. 3A63h, Bit 2 = SLRC2. 3A63h, Bit 1 = SLRC1. 3A63h, Bit 0 = SLRC0. 3A63h, Register on page = 259. 3A62h, Name = ODCONC. 3A62h, Bit 7 = ODCC7. 3A62h, Bit 6 = ODCC6. 3A62h, Bit 5 = ODCC5. 3A62h, Bit 4 = ODCC4. 3A62h, Bit 3 = ODCC3. 3A62h, Bit 2 = ODCC2. 3A62h, Bit 1 = ODCC1. 3A62h, Bit 0 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nODCC0. 3A62h, Register on page = 258. 3A61h, Name = WPUC. 3A61h, Bit 7 = WPUC7. 3A61h, Bit 6 = WPUC6. 3A61h, Bit 5 = WPUC5. 3A61h, Bit 4 = WPUC4. 3A61h, Bit 3 = WPUC3. 3A61h, Bit 2 = WPUC2. 3A61h, Bit 1 = WPUC1. 3A61h, Bit 0 = WPUC0. 3A61h, Register on page = 257. 3A60h, Name = ANSELC. 3A60h, Bit 7 = ANSELC7. 3A60h, Bit 6 = ANSELC6. 3A60h, Bit 5 = ANSELC5. 3A60h, Bit 4 = ANSELC4. 3A60h, Bit 3 = ANSELC3. 3A60h, Bit 2 = ANSELC2. 3A60h, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nANSELC1. 3A60h, Bit 0 = ANSELC0. 3A60h, Register on page = 256. 3A5Fh - 3A5Ch, Name = Unimplemented. 3A5Fh - 3A5Ch, Bit 7 = Unimplemented. 3A5Fh - 3A5Ch, Bit 6 = Unimplemented. 3A5Fh - 3A5Ch, Bit 5 = Unimplemented. 3A5Fh - 3A5Ch, Bit 4 = Unimplemented. 3A5Fh - 3A5Ch, Bit 3 = Unimplemented. 3A5Fh - 3A5Ch, Bit 2 = Unimplemented. 3A5Fh - 3A5Ch, Bit 1 = Unimplemented. 3A5Fh - 3A5Ch, Bit 0 = Unimplemented. 3A5Fh - 3A5Ch, Register on page = -. 3A5Bh, Name = -. 3A5Bh, Bit 7 = -. 3A5Bh, Bit 6 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A5Bh, Bit 5 = -. 3A5Bh, Bit 4 = -. 3A5Bh, Bit 3 = -. 3A5Bh, Bit 2 = -. 3A5Bh, Bit 1 = -. 3A5Bh, Bit 0 = -. 3A5Bh, Register on page = . , Name = RB2I2C. , Bit 7 = -. , Bit 6 = SLEW. , Bit 5 = . , Bit 4 = PU. , Bit 3 = -. , Bit 2 = -. , Bit 1 = TH. , Bit 0 = TH. , Register on page = 253. 3A5Ah, Name = RB1I2C. 3A5Ah, Bit 7 = -. 3A5Ah, Bit 6 = SLEW. 3A5Ah, Bit 5 = . 3A5Ah, Bit 4 = PU. 3A5Ah, Bit 3 = -. 3A5Ah, Bit 2 = -. 3A5Ah, Bit 1 = TH. 3A5Ah, Bit 0 = TH. 3A5Ah, Register on page = 253. 3A59h, Name = -",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nUnimplemented. 3A59h, Bit 7 = - Unimplemented. 3A59h, Bit 6 = - Unimplemented. 3A59h, Bit 5 = - Unimplemented. 3A59h, Bit 4 = - Unimplemented. 3A59h, Bit 3 = - Unimplemented. 3A59h, Bit 2 = - Unimplemented. 3A59h, Bit 1 = - Unimplemented. 3A59h, Bit 0 = - Unimplemented. 3A59h, Register on page = -. 3A58h, Name = - Unimplemented. 3A58h, Bit 7 = - Unimplemented. 3A58h, Bit 6 = - Unimplemented. 3A58h, Bit 5 = - Unimplemented. 3A58h, Bit 4 = - Unimplemented. 3A58h, Bit 3 = - Unimplemented. 3A58h, Bit 2 = - Unimplemented. 3A58h, Bit 1",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= - Unimplemented. 3A58h, Bit 0 = - Unimplemented. 3A58h, Register on page = -. 3A57h, Name = IOCBF. 3A57h, Bit 7 = IOCBF7. 3A57h, Bit 6 = IOCBF6. 3A57h, Bit 5 = IOCBF5. 3A57h, Bit 4 = IOCBF4. 3A57h, Bit 3 = IOCBF3. 3A57h, Bit 2 = IOCBF2. 3A57h, Bit 1 = IOCBF1. 3A57h, Bit 0 = IOCBF0. 3A57h, Register on page = 273. 3A56h, Name = IOCBN. 3A56h, Bit 7 = IOCBN7. 3A56h, Bit 6 = IOCBN6. 3A56h, Bit 5 = IOCBN5. 3A56h, Bit 4 = IOCBN4. 3A56h, Bit 3 = IOCBN3. 3A56h, Bit 2 = IOCBN2. 3A56h, Bit 1 = IOCBN1. 3A56h, Bit 0",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= IOCBN0. 3A56h, Register on page = 273. 3A55h, Name = IOCBP. 3A55h, Bit 7 = IOCBP7. 3A55h, Bit 6 = IOCBP6. 3A55h, Bit 5 = IOCBP5. 3A55h, Bit 4 = IOCBP4. 3A55h, Bit 3 = IOCBP3. 3A55h, Bit 2 = IOCBP2. 3A55h, Bit 1 = IOCBP1. 3A55h, Bit 0 = IOCBP0. 3A55h, Register on page = 273. 3A54h, Name = INLVLB. 3A54h, Bit 7 = INLVLB7. 3A54h, Bit 6 = INLVLB6. 3A54h, Bit 5 = INLVLB5. 3A54h, Bit 4 = INLVLB4. 3A54h, Bit 3 = INLVLB3. 3A54h, Bit 2 = INLVLB2. 3A54h, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nINLVLB1. 3A54h, Bit 0 = INLVLB0. 3A54h, Register on page = 260. 3A53h, Name = SLRCONB. 3A53h, Bit 7 = SLRB7. 3A53h, Bit 6 = SLRB6. 3A53h, Bit 5 = SLRB5. 3A53h, Bit 4 = SLRB4. 3A53h, Bit 3 = SLRB3. 3A53h, Bit 2 = SLRB2. 3A53h, Bit 1 = SLRB1. 3A53h, Bit 0 = SLRB0. 3A53h, Register on page = 259. 3A52h, Name = ODCONB. 3A52h, Bit 7 = ODCB7. 3A52h, Bit 6 = ODCB6. 3A52h, Bit 5 = ODCB5. 3A52h, Bit 4 = ODCB4. 3A52h, Bit 3 = ODCB3. 3A52h, Bit 2 = ODCB2. 3A52h, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nODCB1. 3A52h, Bit 0 = ODCB0. 3A52h, Register on page = 258. 3A51h, Name = WPUB. 3A51h, Bit 7 = WPUB7. 3A51h, Bit 6 = WPUB6. 3A51h, Bit 5 = WPUB5. 3A51h, Bit 4 = WPUB4. 3A51h, Bit 3 = WPUB3. 3A51h, Bit 2 = WPUB2. 3A51h, Bit 1 = WPUB1. 3A51h, Bit 0 = WPUB0. 3A51h, Register on page = 257. 3A50h, Name = ANSELB. 3A50h, Bit 7 = ANSELB7. 3A50h, Bit 6 = ANSELB6. 3A50h, Bit 5 = ANSELB5. 3A50h, Bit 4 = ANSELB4. 3A50h, Bit 3 = ANSELB3. 3A50h, Bit 2 = ANSELB2. 3A50h, Bit 1",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= ANSELB1. 3A50h, Bit 0 = ANSELB0. 3A50h, Register on page = 256. 3A4Fh - 3A48h, Name = - Unimplemented. 3A4Fh - 3A48h, Bit 7 = - Unimplemented. 3A4Fh - 3A48h, Bit 6 = - Unimplemented. 3A4Fh - 3A48h, Bit 5 = - Unimplemented. 3A4Fh - 3A48h, Bit 4 = - Unimplemented. 3A4Fh - 3A48h, Bit 3 = - Unimplemented. 3A4Fh - 3A48h, Bit 2 = - Unimplemented. 3A4Fh - 3A48h, Bit 1 = - Unimplemented. 3A4Fh - 3A48h, Bit 0 = - Unimplemented. 3A4Fh - 3A48h, Register on page = -. 3A47h, Name = IOCAF. 3A47h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nIOCAF7. 3A47h, Bit 6 = IOCAF6. 3A47h, Bit 5 = IOCAF5. 3A47h, Bit 4 = IOCAF4. 3A47h, Bit 3 = IOCAF3. 3A47h, Bit 2 = IOCAF2. 3A47h, Bit 1 = IOCAF1. 3A47h, Bit 0 = IOCAF0. 3A47h, Register on page = 273. 3A46h, Name = IOCAN. 3A46h, Bit 7 = IOCAN7. 3A46h, Bit 6 = IOCAN6. 3A46h, Bit 5 = IOCAN5. 3A46h, Bit 4 = IOCAN4. 3A46h, Bit 3 = IOCAN3. 3A46h, Bit 2 = IOCAN2. 3A46h, Bit 1 = IOCAN1. 3A46h, Bit 0 = IOCAN0. 3A46h, Register on page = 273. 3A45h, Name = IOCAP. 3A45h, Bit 7 = IOCAP7. 3A45h, Bit 6 = IOCAP6.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A45h, Bit 5 = IOCAP5. 3A45h, Bit 4 = IOCAP4. 3A45h, Bit 3 = IOCAP3. 3A45h, Bit 2 = IOCAP2. 3A45h, Bit 1 = IOCAP1. 3A45h, Bit 0 = IOCAP0. 3A45h, Register on page = 273. 3A44h, Name = INLVLA. 3A44h, Bit 7 = INLVLA7. 3A44h, Bit 6 = INLVLA6. 3A44h, Bit 5 = INLVLA5. 3A44h, Bit 4 = INLVLA4. 3A44h, Bit 3 = INLVLA3. 3A44h, Bit 2 = INLVLA2. 3A44h, Bit 1 = INLVLA1. 3A44h, Bit 0 = INLVLA0. 3A44h, Register on page = 260. 3A43h, Name = SLRCONA. 3A43h, Bit 7 = SLRA7. 3A43h, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSLRA6. 3A43h, Bit 5 = SLRA5. 3A43h, Bit 4 = SLRA4. 3A43h, Bit 3 = SLRA3. 3A43h, Bit 2 = SLRA2. 3A43h, Bit 1 = SLRA1. 3A43h, Bit 0 = SLRA0. 3A43h, Register on page = 259. 3A42h, Name = ODCONA. 3A42h, Bit 7 = ODCA7. 3A42h, Bit 6 = ODCA6. 3A42h, Bit 5 = ODCA5. 3A42h, Bit 4 = ODCA4. 3A42h, Bit 3 = ODCA3. 3A42h, Bit 2 = ODCA2. 3A42h, Bit 1 = ODCA1. 3A42h, Bit 0 = ODCA0. 3A42h, Register on page = 258. 3A41h, Name = WPUA. 3A41h, Bit 7 = WPUA7. 3A41h, Bit 6 = WPUA6.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A41h, Bit 5 = WPUA5. 3A41h, Bit 4 = WPUA4. 3A41h, Bit 3 = WPUA3. 3A41h, Bit 2 = WPUA2. 3A41h, Bit 1 = WPUA1. 3A41h, Bit 0 = WPUA0. 3A41h, Register on page = 257. 3A40h, Name = ANSELA. 3A40h, Bit 7 = ANSELA7. 3A40h, Bit 6 = ANSELA6. 3A40h, Bit 5 = ANSELA5. 3A40h, Bit 4 = ANSELA4. 3A40h, Bit 3 = ANSELA3. 3A40h, Bit 2 = ANSELA2. 3A40h, Bit 1 = ANSELA1. 3A40h, Bit 0 = ANSELA0. 3A40h, Register on page = 256. 3A3Fh - 3A18h, Name = - Unimplemented. 3A3Fh - 3A18h, Bit 7 = -",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nUnimplemented. 3A3Fh - 3A18h, Bit 6 = - Unimplemented. 3A3Fh - 3A18h, Bit 5 = - Unimplemented. 3A3Fh - 3A18h, Bit 4 = - Unimplemented. 3A3Fh - 3A18h, Bit 3 = - Unimplemented. 3A3Fh - 3A18h, Bit 2 = - Unimplemented. 3A3Fh - 3A18h, Bit 1 = - Unimplemented. 3A3Fh - 3A18h, Bit 0 = - Unimplemented. 3A3Fh - 3A18h, Register on page = -. 3A17h, Name = RC7PPS. 3A17h, Bit 7 = -. 3A17h, Bit 6 = -. 3A17h, Bit 5 = RC7PPS5. 3A17h, Bit 4 = RC7PPS4. 3A17h, Bit 3 = RC7PPS3. 3A17h, Bit 2 = RC7PPS2.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A17h, Bit 1 = RC7PPS1. 3A17h, Bit 0 = RC7PPS0. 3A17h, Register on page = 267. 3A16h, Name = RC6PPS. 3A16h, Bit 7 = -. 3A16h, Bit 6 = -. 3A16h, Bit 5 = RC6PPS5. 3A16h, Bit 4 = RC6PPS4. 3A16h, Bit 3 = RC6PPS3. 3A16h, Bit 2 = RC6PPS2. 3A16h, Bit 1 = RC6PPS1. 3A16h, Bit 0 = RC6PPS0. 3A16h, Register on page = 267\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1:\nNot present in LF devices.\nDS40001943C-page 780",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A15h, Name = RC5PPS. 3A15h, Bit 7 = -. 3A15h, Bit 6 = -. 3A15h, Bit 5 = RC5PPS5. 3A15h, Bit 4 = RC5PPS4. 3A15h, Bit 3 = RC5PPS3. 3A15h, Bit 2 = RC5PPS2. 3A15h, Bit 1 = RC5PPS1. 3A15h, Bit 0 = RC5PPS0. 3A15h, Register on page = 267. 3A14h, Name = RC4PPS. 3A14h, Bit 7 = -. 3A14h, Bit 6 = -. 3A14h, Bit 5 = RC4PPS5. 3A14h, Bit 4 = RC4PPS4. 3A14h, Bit 3 = RC4PPS3. 3A14h, Bit 2 = RC4PPS2. 3A14h, Bit 1 = RC4PPS1. 3A14h, Bit 0 = RC4PPS0. 3A14h, Register on page = 267. 3A13h, Name = RC3PPS.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A13h, Bit 7 = -. 3A13h, Bit 6 = -. 3A13h, Bit 5 = RC3PPS5. 3A13h, Bit 4 = RC3PPS4. 3A13h, Bit 3 = RC3PPS3. 3A13h, Bit 2 = RC3PPS2. 3A13h, Bit 1 = RC3PPS1. 3A13h, Bit 0 = RC3PPS0. 3A13h, Register on page = 267. 3A12h, Name = RC2PPS. 3A12h, Bit 7 = -. 3A12h, Bit 6 = -. 3A12h, Bit 5 = RC2PPS5. 3A12h, Bit 4 = RC2PPS4. 3A12h, Bit 3 = RC2PPS3. 3A12h, Bit 2 = RC2PPS2. 3A12h, Bit 1 = RC2PPS1. 3A12h, Bit 0 = RC2PPS0. 3A12h, Register on page = 267. 3A11h, Name = RC1PPS. 3A11h, Bit 7 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A11h, Bit 6 = -. 3A11h, Bit 5 = RC1PPS5. 3A11h, Bit 4 = RC1PPS4. 3A11h, Bit 3 = RC1PPS3. 3A11h, Bit 2 = RC1PPS2. 3A11h, Bit 1 = RC1PPS1. 3A11h, Bit 0 = RC1PPS0. 3A11h, Register on page = 267. 3A10h, Name = RC0PPS. 3A10h, Bit 7 = -. 3A10h, Bit 6 = -. 3A10h, Bit 5 = RC0PPS5. 3A10h, Bit 4 = RC0PPS4. 3A10h, Bit 3 = RC0PPS3. 3A10h, Bit 2 = RC0PPS2. 3A10h, Bit 1 = RC0PPS1. 3A10h, Bit 0 = RC0PPS0. 3A10h, Register on page = 267. 3A0Fh, Name = RB7PPS. 3A0Fh, Bit 7 = -. 3A0Fh, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n-. 3A0Fh, Bit 5 = RB7PPS5. 3A0Fh, Bit 4 = RB7PPS4. 3A0Fh, Bit 3 = RB7PPS3. 3A0Fh, Bit 2 = RB7PPS2. 3A0Fh, Bit 1 = RB7PPS1. 3A0Fh, Bit 0 = RB7PPS0. 3A0Fh, Register on page = 267. 3A0Eh, Name = RB6PPS. 3A0Eh, Bit 7 = -. 3A0Eh, Bit 6 = -. 3A0Eh, Bit 5 = RB6PPS5. 3A0Eh, Bit 4 = RB6PPS4. 3A0Eh, Bit 3 = RB6PPS3. 3A0Eh, Bit 2 = RB6PPS2. 3A0Eh, Bit 1 = RB6PPS1. 3A0Eh, Bit 0 = RB6PPS0. 3A0Eh, Register on page = 267. 3A0Dh, Name = RB5PPS. 3A0Dh, Bit 7 = -. 3A0Dh, Bit 6 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A0Dh, Bit 5 = RB5PPS5. 3A0Dh, Bit 4 = RB5PPS4. 3A0Dh, Bit 3 = RB5PPS3. 3A0Dh, Bit 2 = RB5PPS2. 3A0Dh, Bit 1 = RB5PPS1. 3A0Dh, Bit 0 = RB5PPS0. 3A0Dh, Register on page = 267. 3A0Ch, Name = RB4PPS. 3A0Ch, Bit 7 = -. 3A0Ch, Bit 6 = -. 3A0Ch, Bit 5 = RB4PPS5. 3A0Ch, Bit 4 = RB4PPS4. 3A0Ch, Bit 3 = RB4PPS3. 3A0Ch, Bit 2 = RB4PPS2. 3A0Ch, Bit 1 = RB4PPS1. 3A0Ch, Bit 0 = RB4PPS0. 3A0Ch, Register on page = 267. 3A0Bh, Name = RB3PPS. 3A0Bh, Bit 7 = -. 3A0Bh, Bit 6 = -. 3A0Bh, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRB3PPS5. 3A0Bh, Bit 4 = RB3PPS4. 3A0Bh, Bit 3 = RB3PPS3. 3A0Bh, Bit 2 = RB3PPS2. 3A0Bh, Bit 1 = RB3PPS1. 3A0Bh, Bit 0 = RB3PPS0. 3A0Bh, Register on page = 267. 3A0Ah, Name = RB2PPS. 3A0Ah, Bit 7 = -. 3A0Ah, Bit 6 = -. 3A0Ah, Bit 5 = RB2PPS5. 3A0Ah, Bit 4 = RB2PPS4. 3A0Ah, Bit 3 = RB2PPS3. 3A0Ah, Bit 2 = RB2PPS2. 3A0Ah, Bit 1 = RB2PPS1. 3A0Ah, Bit 0 = RB2PPS0. 3A0Ah, Register on page = 267. 3A09h, Name = RB1PPS. 3A09h, Bit 7 = -. 3A09h, Bit 6 = -. 3A09h, Bit 5 = RB1PPS5.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A09h, Bit 4 = RB1PPS4. 3A09h, Bit 3 = RB1PPS3. 3A09h, Bit 2 = RB1PPS2. 3A09h, Bit 1 = RB1PPS1. 3A09h, Bit 0 = RB1PPS0. 3A09h, Register on page = 267. 3A08h, Name = RB0PPS. 3A08h, Bit 7 = -. 3A08h, Bit 6 = -. 3A08h, Bit 5 = RB0PPS5. 3A08h, Bit 4 = RB0PPS4. 3A08h, Bit 3 = RB0PPS3. 3A08h, Bit 2 = RB0PPS2. 3A08h, Bit 1 = RB0PPS1. 3A08h, Bit 0 = RB0PPS0. 3A08h, Register on page = 267. 3A07h, Name = RA7PPS. 3A07h, Bit 7 = -. 3A07h, Bit 6 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A07h, Bit 5 = RA7PPS5. 3A07h, Bit 4 = RA7PPS4. 3A07h, Bit 3 = RA7PPS3. 3A07h, Bit 2 = RA7PPS2. 3A07h, Bit 1 = RA7PPS1. 3A07h, Bit 0 = RA7PPS0. 3A07h, Register on page = 267. 3A06h, Name = RA6PPS. 3A06h, Bit 7 = -. 3A06h, Bit 6 = -. 3A06h, Bit 5 = RA6PPS5. 3A06h, Bit 4 = RA6PPS4. 3A06h, Bit 3 = RA6PPS3. 3A06h, Bit 2 = RA6PPS2. 3A06h, Bit 1 = RA6PPS1. 3A06h, Bit 0 = RA6PPS0. 3A06h, Register on page = 267. 3A05h, Name = RA5PPS. 3A05h, Bit 7 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A05h, Bit 6 = -. 3A05h, Bit 5 = RA5PPS5. 3A05h, Bit 4 = RA5PPS4. 3A05h, Bit 3 = RA5PPS3. 3A05h, Bit 2 = RA5PPS2. 3A05h, Bit 1 = RA5PPS1. 3A05h, Bit 0 = RA5PPS0. 3A05h, Register on page = 267. 3A04h, Name = RA4PPS. 3A04h, Bit 7 = -. 3A04h, Bit 6 = -. 3A04h, Bit 5 = RA4PPS5. 3A04h, Bit 4 = RA4PPS4. 3A04h, Bit 3 = RA4PPS3. 3A04h, Bit 2 = RA4PPS2. 3A04h, Bit 1 = RA4PPS1. 3A04h, Bit 0 = RA4PPS0. 3A04h, Register on page = 267. 3A03h, Name = RA3PPS.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A03h, Bit 7 = -. 3A03h, Bit 6 = -. 3A03h, Bit 5 = RA3PPS5. 3A03h, Bit 4 = RA3PPS4. 3A03h, Bit 3 = RA3PPS3. 3A03h, Bit 2 = RA3PPS2. 3A03h, Bit 1 = RA3PPS1. 3A03h, Bit 0 = RA3PPS0. 3A03h, Register on page = 267. 3A02h, Name = RA2PPS. 3A02h, Bit 7 = -. 3A02h, Bit 6 = -. 3A02h, Bit 5 = RA2PPS5. 3A02h, Bit 4 = RA2PPS4. 3A02h, Bit 3 = RA2PPS3. 3A02h, Bit 2 = RA2PPS2. 3A02h, Bit 1 = RA2PPS1. 3A02h, Bit 0 = RA2PPS0. 3A02h, Register on page = 267.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3A01h, Name = RA1PPS. 3A01h, Bit 7 = -. 3A01h, Bit 6 = -. 3A01h, Bit 5 = RA1PPS5. 3A01h, Bit 4 = RA1PPS4. 3A01h, Bit 3 = RA1PPS3. 3A01h, Bit 2 = RA1PPS2. 3A01h, Bit 1 = RA1PPS1. 3A01h, Bit 0 = RA1PPS0. 3A01h, Register on page = 267. 3A00h, Name = RA0PPS. 3A00h, Bit 7 = -. 3A00h, Bit 6 = -. 3A00h, Bit 5 = RA0PPS5. 3A00h, Bit 4 = RA0PPS4. 3A00h, Bit 3 = RA0PPS3. 3A00h, Bit 2 = RA0PPS2. 3A00h, Bit 1 = RA0PPS1. 3A00h, Bit 0 = RA0PPS0. 3A00h, Register on page = 267. 39FFh - 39F8h, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n-. 39FFh - 39F8h, Bit 7 = Unimplemented. 39FFh - 39F8h, Bit 6 = Unimplemented. 39FFh - 39F8h, Bit 5 = Unimplemented. 39FFh - 39F8h, Bit 4 = Unimplemented. 39FFh - 39F8h, Bit 3 = Unimplemented. 39FFh - 39F8h, Bit 2 = Unimplemented. 39FFh - 39F8h, Bit 1 = Unimplemented. 39FFh - 39F8h, Bit 0 = Unimplemented. 39FFh - 39F8h, Register on page = -. 39F7h, Name = SCANPR. 39F7h, Bit 7 = -. 39F7h, Bit 6 = -. 39F7h, Bit 5 = -. 39F7h, Bit 4 = -. 39F7h, Bit 3 = -. 39F7h, Bit 2 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n39F7h, Bit 1 = PR. 39F7h, Bit 0 = . 39F7h, Register on page = 21. 39F6h - 39F5h, Name = - Unimplemented. 39F6h - 39F5h, Bit 7 = - Unimplemented. 39F6h - 39F5h, Bit 6 = - Unimplemented. 39F6h - 39F5h, Bit 5 = - Unimplemented. 39F6h - 39F5h, Bit 4 = - Unimplemented. 39F6h - 39F5h, Bit 3 = - Unimplemented. 39F6h - 39F5h, Bit 2 = - Unimplemented. 39F6h - 39F5h, Bit 1 = - Unimplemented. 39F6h - 39F5h, Bit 0 = - Unimplemented. 39F6h - 39F5h, Register on page = -. 39F4h, Name",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= DMA2PR. 39F4h, Bit 7 = -. 39F4h, Bit 6 = -. 39F4h, Bit 5 = -. 39F4h, Bit 4 = -. 39F4h, Bit 3 = -. 39F4h, Bit 2 = . 39F4h, Bit 1 = PR. 39F4h, Bit 0 = . 39F4h, Register on page = 21. 39F3h, Name = DMA1PR. 39F3h, Bit 7 = -. 39F3h, Bit 6 = -. 39F3h, Bit 5 = -. 39F3h, Bit 4 = -. 39F3h, Bit 3 = -. 39F3h, Bit 2 = . 39F3h, Bit 1 = PR. 39F3h, Bit 0 = . 39F3h, Register on page = 20. 39F2h, Name = MAINPR. 39F2h, Bit 7 = -. 39F2h, Bit 6 = -. 39F2h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 5 = -. 39F2h, Bit 4 = -. 39F2h, Bit 3 = -. 39F2h, Bit 2 = . 39F2h, Bit 1 = PR. 39F2h, Bit 0 = . 39F2h, Register on page = 20. 39F1h, Name = ISRPR. 39F1h, Bit 7 = -. 39F1h, Bit 6 = -. 39F1h, Bit 5 = -. 39F1h, Bit 4 = -. 39F1h, Bit 3 = -. 39F1h, Bit 2 = . 39F1h, Bit 1 = PR. 39F1h, Bit 0 = . 39F1h, Register on page = 20. 39F0h, Name = - Unimplemented. 39F0h, Bit 7 = - Unimplemented. 39F0h, Bit 6 = - Unimplemented. 39F0h, Bit 5 = - Unimplemented. 39F0h, Bit 4 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n- Unimplemented. 39F0h, Bit 3 = - Unimplemented. 39F0h, Bit 2 = - Unimplemented. 39F0h, Bit 1 = - Unimplemented. 39F0h, Bit 0 = - Unimplemented. 39F0h, Register on page = -. 39EFh, Name = PRLOCK. 39EFh, Bit 7 = -. 39EFh, Bit 6 = -. 39EFh, Bit 5 = -. 39EFh, Bit 4 = -. 39EFh, Bit 3 = -. 39EFh, Bit 2 = -. 39EFh, Bit 1 = -. 39EFh, Bit 0 = PRLOCKED. 39EFh, Register on page = 21. 39EEh- 39E7h, Name = - Unimplemented. 39EEh- 39E7h, Bit 7 = - Unimplemented. 39EEh- 39E7h, Bit 6 = - Unimplemented. 39EEh-",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n39E7h, Bit 5 = - Unimplemented. 39EEh- 39E7h, Bit 4 = - Unimplemented. 39EEh- 39E7h, Bit 3 = - Unimplemented. 39EEh- 39E7h, Bit 2 = - Unimplemented. 39EEh- 39E7h, Bit 1 = - Unimplemented. 39EEh- 39E7h, Bit 0 = - Unimplemented. 39EEh- 39E7h, Register on page = -. 39E6h, Name = NVMCON2 NVMCON2. 39E6h, Bit 7 = NVMCON2 NVMCON2. 39E6h, Bit 6 = NVMCON2 NVMCON2. 39E6h, Bit 5 = NVMCON2 NVMCON2. 39E6h, Bit 4 = NVMCON2 NVMCON2. 39E6h, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nNVMCON2 NVMCON2. 39E6h, Bit 2 = NVMCON2 NVMCON2. 39E6h, Bit 1 = NVMCON2 NVMCON2. 39E6h, Bit 0 = NVMCON2 NVMCON2. 39E6h, Register on page = 201. 39E5h, Name = NVMCON1. 39E5h, Bit 7 = REG. 39E5h, Bit 6 = REG. 39E5h, Bit 5 = -. 39E5h, Bit 4 = FREE. 39E5h, Bit 3 = WRERR. 39E5h, Bit 2 = WREN. 39E5h, Bit 1 = WR. 39E5h, Bit 0 = RD. 39E5h, Register on page = 200. 39E4h, Name = - Unimplemented. 39E4h, Bit 7 = - Unimplemented. 39E4h, Bit 6 = - Unimplemented.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n39E4h, Bit 5 = - Unimplemented. 39E4h, Bit 4 = - Unimplemented. 39E4h, Bit 3 = - Unimplemented. 39E4h, Bit 2 = - Unimplemented. 39E4h, Bit 1 = - Unimplemented. 39E4h, Bit 0 = - Unimplemented. 39E4h, Register on page = -. 39E3h, Name = NVMDAT DAT. 39E3h, Bit 7 = NVMDAT DAT. 39E3h, Bit 6 = NVMDAT DAT. 39E3h, Bit 5 = NVMDAT DAT. 39E3h, Bit 4 = NVMDAT DAT. 39E3h, Bit 3 = NVMDAT DAT. 39E3h, Bit 2 = NVMDAT DAT. 39E3h, Bit 1 = NVMDAT DAT. 39E3h, Bit 0 = NVMDAT DAT. 39E3h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRegister on page = 202. 39E2h, Name = - Unimplemented. 39E2h, Bit 7 = - Unimplemented. 39E2h, Bit 6 = - Unimplemented. 39E2h, Bit 5 = - Unimplemented. 39E2h, Bit 4 = - Unimplemented. 39E2h, Bit 3 = - Unimplemented. 39E2h, Bit 2 = - Unimplemented. 39E2h, Bit 1 = - Unimplemented. 39E2h, Bit 0 = - Unimplemented. 39E2h, Register on page = -. 39E1h, Name = - Unimplemented. 39E1h, Bit 7 = - Unimplemented. 39E1h, Bit 6 = - Unimplemented. 39E1h, Bit 5 = - Unimplemented. 39E1h, Bit 4 = - Unimplemented. 39E1h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3 = - Unimplemented. 39E1h, Bit 2 = - Unimplemented. 39E1h, Bit 1 = - Unimplemented. 39E1h, Bit 0 = - Unimplemented. 39E1h, Register on page = -. 39E0h, Name = NVMADRL ADR. 39E0h, Bit 7 = NVMADRL ADR. 39E0h, Bit 6 = NVMADRL ADR. 39E0h, Bit 5 = NVMADRL ADR. 39E0h, Bit 4 = NVMADRL ADR. 39E0h, Bit 3 = NVMADRL ADR. 39E0h, Bit 2 = NVMADRL ADR. 39E0h, Bit 1 = NVMADRL ADR. 39E0h, Bit 0 = NVMADRL ADR. 39E0h, Register on page = 201. 39DFh, Name = OSCFRQ. 39DFh, Bit 7 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n39DFh, Bit 6 = -. 39DFh, Bit 5 = -. 39DFh, Bit 4 = -. 39DFh, Bit 3 = FRQ. 39DFh, Bit 2 = FRQ. 39DFh, Bit 1 = FRQ. 39DFh, Bit 0 = FRQ. 39DFh, Register on page = 97. 39DEh, Name = OSCTUNE. 39DEh, Bit 7 = -. 39DEh, Bit 6 = -. 39DEh, Bit 5 = . 39DEh, Bit 4 = . 39DEh, Bit 3 = TUN. 39DEh, Bit 2 = TUN. 39DEh, Bit 1 = TUN. 39DEh, Bit 0 = TUN. 39DEh, Register on page = 98. 39DDh, Name = OSCEN. 39DDh, Bit 7 = EXTOEN. 39DDh, Bit 6 = HFOEN. 39DDh, Bit 5 = MFOEN. 39DDh, Bit 4 = LFOEN. 39DDh, Bit 3 = SOSCEN. 39DDh, Bit 2 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nADOEN. 39DDh, Bit 1 = -. 39DDh, Bit 0 = -. 39DDh, Register on page = 99. 39DCh 39DBh, Name = OSCSTAT OSCCON3. 39DCh 39DBh, Bit 7 = EXTOR CSWHOLD. 39DCh 39DBh, Bit 6 = HFOR SOSCPWR. 39DCh 39DBh, Bit 5 = MFOR -. 39DCh 39DBh, Bit 4 = LFOR ORDY. 39DCh 39DBh, Bit 3 = SOR NOSCR. 39DCh 39DBh, Bit 2 = ADOR. 39DCh 39DBh, Bit 1 = - -. 39DCh 39DBh, Bit 0 = PLLR -. 39DCh 39DBh, Register on page = 96 95. 39DAh, Name = OSCCON2. 39DAh, Bit 7 = -. 39DAh, Bit 6 = . 39DAh, Bit 5 = COSC. 39DAh, Bit 4 = . 39DAh, Bit 3 = . 39DAh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 2 = -. 39DAh, Bit 1 = CDIV. 39DAh, Bit 0 = . 39DAh, Register on page = 95. 39D9h, Name = OSCCON1. 39D9h, Bit 7 = -. 39D9h, Bit 6 = . 39D9h, Bit 5 = NOSC. 39D9h, Bit 4 = . 39D9h, Bit 3 = NDIV. 39D9h, Bit 2 = NDIV. 39D9h, Bit 1 = NDIV. 39D9h, Bit 0 = NDIV. 39D9h, Register on page = 94. 39D8h, Name = CPUDOZE. 39D8h, Bit 7 = IDLEN. 39D8h, Bit 6 = DOZEN. 39D8h, Bit 5 = ROI. 39D8h, Bit 4 = DOE. 39D8h, Bit 3 = - DOZE. 39D8h, Bit 2 = - DOZE. 39D8h, Bit 1 = - DOZE.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n39D8h, Bit 0 = - DOZE. 39D8h, Register on page = 167\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition Note 1: Not present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n39D2h, Name = -. 39D2h, Bit 7 = 39D7h -. 39D2h, Bit 6 = 39D7h -. 39D2h, Bit 5 = 39D7h -. 39D2h, Bit 4 = Unimplemented. 39D2h, Bit 3 = 39D7h -. 39D2h, Bit 2 = 39D7h -. 39D2h, Bit 1 = 39D7h -. 39D2h, Bit 0 = 39D7h -. 39D2h, Register on page = -. 39D1h, Name = VREGCON (1). 39D1h, Bit 7 = -. 39D1h, Bit 6 = -. 39D1h, Bit 5 = -. 39D1h, Bit 4 = -. 39D1h, Bit 3 = -. 39D1h, Bit 2 = -. 39D1h, Bit 1 = VREGPM. 39D1h, Bit 0 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n39D1h, Register on page = 166. 39D0h, Name = BORCON. 39D0h, Bit 7 = SBOREN. 39D0h, Bit 6 = -. 39D0h, Bit 5 = -. 39D0h, Bit 4 = -. 39D0h, Bit 3 = -. 39D0h, Bit 2 = -. 39D0h, Bit 1 = -. 39D0h, Bit 0 = BORRDY. 39D0h, Register on page = 75. 39C8h, Name = . 39C8h, Bit 7 = 39CFh- - Unimplemented. 39C8h, Bit 6 = 39CFh- - Unimplemented. 39C8h, Bit 5 = 39CFh- - Unimplemented. 39C8h, Bit 4 = 39CFh- - Unimplemented. 39C8h, Bit 3 = 39CFh- - Unimplemented. 39C8h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n2 = 39CFh- - Unimplemented. 39C8h, Bit 1 = 39CFh- - Unimplemented. 39C8h, Bit 0 = 39CFh- - Unimplemented. 39C8h, Register on page = -. 39C7h, Name = PMD7. 39C7h, Bit 7 = CANMD. 39C7h, Bit 6 = -. 39C7h, Bit 5 = -. 39C7h, Bit 4 = -. 39C7h, Bit 3 = -. 39C7h, Bit 2 = -. 39C7h, Bit 1 = DMA2MD. 39C7h, Bit 0 = DMA1MD. 39C7h, Register on page = 283. 39C6h, Name = PMD6. 39C6h, Bit 7 = -. 39C6h, Bit 6 = SMT2MD. 39C6h, Bit 5 = SMT1MD. 39C6h, Bit 4 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCLC4MD. 39C6h, Bit 3 = CLC3MD. 39C6h, Bit 2 = CLC2MD. 39C6h, Bit 1 = CLC1MD. 39C6h, Bit 0 = DSMMD. 39C6h, Register on page = 282. 39C5h, Name = PMD5. 39C5h, Bit 7 = -. 39C5h, Bit 6 = -. 39C5h, Bit 5 = U2MD. 39C5h, Bit 4 = U1MD. 39C5h, Bit 3 = -. 39C5h, Bit 2 = SPI1MD. 39C5h, Bit 1 = I2C2MD. 39C5h, Bit 0 = I2C1MD. 39C5h, Register on page = 281. 39C4h, Name = PMD4. 39C4h, Bit 7 = CWG3MD. 39C4h, Bit 6 = CWG2MD. 39C4h, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCWG1MD. 39C4h, Bit 4 = -. 39C4h, Bit 3 = -. 39C4h, Bit 2 = -. 39C4h, Bit 1 = -. 39C4h, Bit 0 = -. 39C4h, Register on page = 280. 39C3h, Name = PMD3. 39C3h, Bit 7 = PWM8MD. 39C3h, Bit 6 = PWM7MD. 39C3h, Bit 5 = PWM6MD. 39C3h, Bit 4 = PWM5MD. 39C3h, Bit 3 = CCP4MD. 39C3h, Bit 2 = CCP3MD. 39C3h, Bit 1 = CCP2MD. 39C3h, Bit 0 = CCP1MD. 39C3h, Register on page = 279. 39C2h, Name = PMD2. 39C2h, Bit 7 = -. 39C2h, Bit 6 = DACMD.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n39C2h, Bit 5 = ADCMD. 39C2h, Bit 4 = -. 39C2h, Bit 3 = -. 39C2h, Bit 2 = CMP2MD. 39C2h, Bit 1 = CMP1MD. 39C2h, Bit 0 = ZCDMD. 39C2h, Register on page = 278. 39C1h, Name = PMD1. 39C1h, Bit 7 = NCO1MD. 39C1h, Bit 6 = TMR6MD. 39C1h, Bit 5 = TMR5MD. 39C1h, Bit 4 = TMR4MD. 39C1h, Bit 3 = TMR3MD. 39C1h, Bit 2 = TMR2MD. 39C1h, Bit 1 = TMR1MD. 39C1h, Bit 0 = TMR0MD. 39C1h, Register on page = 277. 39C0h, Name = PMD0. 39C0h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n7 = SYSCMD. 39C0h, Bit 6 = FVRMD. 39C0h, Bit 5 = HLVDMD. 39C0h, Bit 4 = CRCMD. 39C0h, Bit 3 = SCANMD. 39C0h, Bit 2 = NVMMD. 39C0h, Bit 1 = CLKRMD. 39C0h, Bit 0 = IOCMD. 39C0h, Register on page = 276. , Name = . , Bit 7 = 39BFh - 39AAh -. , Bit 6 = 39BFh - 39AAh -. , Bit 5 = 39BFh - 39AAh -. , Bit 4 = Unimplemented. , Bit 3 = 39BFh - 39AAh -. , Bit 2 = 39BFh - 39AAh -. , Bit 1 = 39BFh - 39AAh -. , Bit 0 = 39BFh - 39AAh -. , Register on page = -. 39A9h, Name = PIR9. 39A9h, Bit 7",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= -. 39A9h, Bit 6 = CLC4IF. 39A9h, Bit 5 = CCP4IF. 39A9h, Bit 4 = CLC3IF. 39A9h, Bit 3 = CWG3IF. 39A9h, Bit 2 = CCP3IF. 39A9h, Bit 1 = TMR6IF. 39A9h, Bit 0 = TMR5IF. 39A9h, Register on page = 136. 39A8h, Name = PIR8. 39A8h, Bit 7 = TMR5IF. 39A8h, Bit 6 = INT2IF. 39A8h, Bit 5 = CLC2IF. 39A8h, Bit 4 = CWG2IF. 39A8h, Bit 3 = CCP2IF. 39A8h, Bit 2 = TMR4IF. 39A8h, Bit 1 = TMR3GIF. 39A8h, Bit 0 = TMR3IF. 39A8h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRegister on page = 135. 39A7h, Name = PIR7. 39A7h, Bit 7 = U2IF. 39A7h, Bit 6 = U2EIF. 39A7h, Bit 5 = U2TXIF. 39A7h, Bit 4 = U2RXIF. 39A7h, Bit 3 = I2C2EIF. 39A7h, Bit 2 = I2C2IF. 39A7h, Bit 1 = I2C2TXIF. 39A7h, Bit 0 = I2C2RXIF. 39A7h, Register on page = 134. 39A6h, Name = PIR6. 39A6h, Bit 7 = DMA2AIF. 39A6h, Bit 6 = DMA2ORIF. 39A6h, Bit 5 = DMA2DCNTIF. 39A6h, Bit 4 = DMA2SCNTIF. 39A6h, Bit 3 = SMT2PWAIF. 39A6h, Bit 2 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSMT2PRAIF. 39A6h, Bit 1 = SMT2IF. 39A6h, Bit 0 = C2IF. 39A6h, Register on page = 133. 39A5h, Name = PIR5. 39A5h, Bit 7 = IRXIF. 39A5h, Bit 6 = WAKIF. 39A5h, Bit 5 = ERRIF. 39A5h, Bit 4 = TXB2IF/ TXBnIF. 39A5h, Bit 3 = TXB1IF. 39A5h, Bit 2 = TXB0IF. 39A5h, Bit 1 = RXB1IF/ RXBnIF. 39A5h, Bit 0 = RXB0IF/ FIFOFIF. 39A5h, Register on page = 132. 39A4h, Name = PIR4. 39A4h, Bit 7 = INT1IF. 39A4h, Bit 6 = CLC1IF. 39A4h, Bit 5 = CWG1IF.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n39A4h, Bit 4 = NCO1IF. 39A4h, Bit 3 = CCP1IF. 39A4h, Bit 2 = TMR2IF. 39A4h, Bit 1 = TMR1GIF. 39A4h, Bit 0 = TMR1IF. 39A4h, Register on page = 131. 39A3h, Name = PIR3. 39A3h, Bit 7 = TMR0IF. 39A3h, Bit 6 = U1IF. 39A3h, Bit 5 = U1EIF. 39A3h, Bit 4 = U1TXIF. 39A3h, Bit 3 = U1RXIF. 39A3h, Bit 2 = I2C1EIF. 39A3h, Bit 1 = I2C1IF. 39A3h, Bit 0 = I2C1TXIF. 39A3h, Register on page = 130. 39A2h, Name = PIR2. 39A2h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n7 = I2C1RXIF. 39A2h, Bit 6 = SPI1IF. 39A2h, Bit 5 = SPI1TXIF. 39A2h, Bit 4 = SPI1RXIF. 39A2h, Bit 3 = DMA1AIF. 39A2h, Bit 2 = DMA1ORIF. 39A2h, Bit 1 = DMA1DCNTIF. 39A2h, Bit 0 = DMA1SCNTIF. 39A2h, Register on page = 128. 39A1h, Name = PIR1. 39A1h, Bit 7 = SMT1PWAIF. 39A1h, Bit 6 = SMT1PRAIF. 39A1h, Bit 5 = SMT1IF. 39A1h, Bit 4 = C1IF. 39A1h, Bit 3 = ADTIF. 39A1h, Bit 2 = ADIF. 39A1h, Bit 1 = ZCDIF. 39A1h, Bit 0 = INT0IF. 39A1h, Register on",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\npage = 128. 39A0h, Name = PIR0. 39A0h, Bit 7 = IOCIF. 39A0h, Bit 6 = CRCIF. 39A0h, Bit 5 = SCANIF. 39A0h, Bit 4 = NVMIF. 39A0h, Bit 3 = CSWIF. 39A0h, Bit 2 = OSFIF. 39A0h, Bit 1 = HLVDIF. 39A0h, Bit 0 = SWIF. 39A0h, Register on page = 127. 399Ah, Name = . 399Ah, Bit 7 = 399Fh - - Unimplemented. 399Ah, Bit 6 = 399Fh - - Unimplemented. 399Ah, Bit 5 = 399Fh - - Unimplemented. 399Ah, Bit 4 = 399Fh - - Unimplemented. 399Ah, Bit 3 = 399Fh - - Unimplemented. 399Ah, Bit 2 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n399Fh - - Unimplemented. 399Ah, Bit 1 = 399Fh - - Unimplemented. 399Ah, Bit 0 = 399Fh - - Unimplemented. 399Ah, Register on page = -. 3999h, Name = PIE9. 3999h, Bit 7 = -. 3999h, Bit 6 = CLC4IE. 3999h, Bit 5 = CCP4IE. 3999h, Bit 4 = CLC3IE. 3999h, Bit 3 = CWG3IE. 3999h, Bit 2 = CCP3IE. 3999h, Bit 1 = TMR6IE. 3999h, Bit 0 = TMR5IE. 3999h, Register on page = 146. 3998h, Name = PIE8. 3998h, Bit 7 = TMR5IE. 3998h, Bit 6 = INT2IE. 3998h, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCLC2IE. 3998h, Bit 4 = CWG2IE. 3998h, Bit 3 = CCP2IE. 3998h, Bit 2 = TMR4IE. 3998h, Bit 1 = TMR3GIE. 3998h, Bit 0 = TMR3IE. 3998h, Register on page = 145. 3997h, Name = PIE7. 3997h, Bit 7 = U2IE. 3997h, Bit 6 = U2EIE. 3997h, Bit 5 = U2TXIE. 3997h, Bit 4 = U2RXIE. 3997h, Bit 3 = I2C2EIE. 3997h, Bit 2 = I2C2IE. 3997h, Bit 1 = I2C2TXIE. 3997h, Bit 0 = I2C2RXIE. 3997h, Register on page = 144. 3996h, Name = PIE6. 3996h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nDMA2AIE. 3996h, Bit 6 = DMA2ORIE. 3996h, Bit 5 = DMA2DCNTIE. 3996h, Bit 4 = DMA2SCNTIE. 3996h, Bit 3 = SMT2PWAIE. 3996h, Bit 2 = SMT2PRAIE. 3996h, Bit 1 = SMT2IE. 3996h, Bit 0 = C2IE. 3996h, Register on page = 143. 3995h, Name = PIE5. 3995h, Bit 7 = IRXIE. 3995h, Bit 6 = WAKIE. 3995h, Bit 5 = ERRIE. 3995h, Bit 4 = TXB2IE/ TXBnIE. 3995h, Bit 3 = TXB1IE. 3995h, Bit 2 = TXB0IE. 3995h, Bit 1 = RXB1IE/ RXBnIE. 3995h, Bit 0 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRXB0IF/ FIFOFIF. 3995h, Register on page = 142. 3994h, Name = PIE4. 3994h, Bit 7 = INT1IE. 3994h, Bit 6 = CLC1IE. 3994h, Bit 5 = CWG1IE. 3994h, Bit 4 = NCO1IE. 3994h, Bit 3 = CCP1IE. 3994h, Bit 2 = TMR2IE. 3994h, Bit 1 = TMR1GIE. 3994h, Bit 0 = TMR1IE. 3994h, Register on page = 141. 3993h, Name = PIE3. 3993h, Bit 7 = TMR0IE. 3993h, Bit 6 = U1IE. 3993h, Bit 5 = U1EIE. 3993h, Bit 4 = U1TXIE. 3993h, Bit 3 = U1RXIE. 3993h, Bit 2",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= I2C1EIE. 3993h, Bit 1 = I2C1IE. 3993h, Bit 0 = I2C1TXIE. 3993h, Register on page = 140. 3992h, Name = PIE2. 3992h, Bit 7 = I2C1RXIE. 3992h, Bit 6 = SPI1IE. 3992h, Bit 5 = SPI1TXIE. 3992h, Bit 4 = SPI1RXIE. 3992h, Bit 3 = DMA1AIE. 3992h, Bit 2 = DMA1ORIE. 3992h, Bit 1 = DMA1DCNTIE. 3992h, Bit 0 = DMA1SCNTIE. 3992h, Register on page = 139. 3991h, Name = PIE1. 3991h, Bit 7 = SMT1PWAIE. 3991h, Bit 6 = SMT1PRAIE. 3991h, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSMT1IE. 3991h, Bit 4 = C1IE. 3991h, Bit 3 = ADTIE. 3991h, Bit 2 = ADIE. 3991h, Bit 1 = ZCDIE. 3991h, Bit 0 = INT0IE. 3991h, Register on page = 138. 3990h, Name = PIE0. 3990h, Bit 7 = IOCIE. 3990h, Bit 6 = CRCIE. 3990h, Bit 5 = SCANIE. 3990h, Bit 4 = NVMIE. 3990h, Bit 3 = CSWIE. 3990h, Bit 2 = OSFIE. 3990h, Bit 1 = HLVDIE. 3990h, Bit 0 = SWIE. 3990h, Register on page = 137. 398Ah, Name = . 398Ah, Bit 7 = 398Fh - -. 398Ah, Bit 6 = 398Fh - -. 398Ah, Bit 5 = 398Fh - -. 398Ah, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n4 = Unimplemented. 398Ah, Bit 3 = 398Fh - -. 398Ah, Bit 2 = 398Fh - -. 398Ah, Bit 1 = 398Fh - -. 398Ah, Bit 0 = 398Fh - -. 398Ah, Register on page = -. 3989h, Name = IPR9. 3989h, Bit 7 = -. 3989h, Bit 6 = CLC4IP. 3989h, Bit 5 = CCP4IP. 3989h, Bit 4 = CLC3IP. 3989h, Bit 3 = CWG3IP. 3989h, Bit 2 = CCP3IP. 3989h, Bit 1 = TMR6IP. 3989h, Bit 0 = TMR5IP. 3989h, Register on page = 156. 3988h, Name = IPR8. 3988h, Bit 7 = TMR5IP. 3988h, Bit 6",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= INT2IP. 3988h, Bit 5 = CLC2IP. 3988h, Bit 4 = CWG2IP. 3988h, Bit 3 = CCP2IP. 3988h, Bit 2 = TMR4IP. 3988h, Bit 1 = TMR3GIP. 3988h, Bit 0 = TMR3IP. 3988h, Register on page = 155. 3987h, Name = IPR7. 3987h, Bit 7 = U2IP. 3987h, Bit 6 = U2EIP. 3987h, Bit 5 = U2TXIP. 3987h, Bit 4 = U2RXIP. 3987h, Bit 3 = I2C2EIP. 3987h, Bit 2 = I2C2IP. 3987h, Bit 1 = I2C2TXIP. 3987h, Bit 0 = I2C2RXIP. 3987h, Register on page = 154.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3986h, Name = IPR6. 3986h, Bit 7 = DMA2AIP. 3986h, Bit 6 = DMA2ORIP. 3986h, Bit 5 = DMA2DCNTIP. 3986h, Bit 4 = DMA2SCNTIP. 3986h, Bit 3 = SMT2PWAIP. 3986h, Bit 2 = SMT2PRAIP. 3986h, Bit 1 = SMT2IP. 3986h, Bit 0 = C2IP. 3986h, Register on page = 153. 3985h, Name = IPR5. 3985h, Bit 7 = IRXIP. 3985h, Bit 6 = WAKIP. 3985h, Bit 5 = ERRIP. 3985h, Bit 4 = TXB2IP/ TXBnIP. 3985h, Bit 3 = TXB1IP. 3985h, Bit 2 = TXB0IP. 3985h, Bit 1 = RXB1IP/ RXBnIP. 3985h, Bit 0 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRXB0IP/ FIFOFIP. 3985h, Register on page = 152. 3984h, Name = IPR4. 3984h, Bit 7 = INT1IP. 3984h, Bit 6 = CLC1IP. 3984h, Bit 5 = CWG1IP. 3984h, Bit 4 = NCO1IP. 3984h, Bit 3 = CCP1IP. 3984h, Bit 2 = TMR2IP. 3984h, Bit 1 = TMR1GIP. 3984h, Bit 0 = TMR1IP. 3984h, Register on page = 151. 3983h, Name = IPR3. 3983h, Bit 7 = TMR0IP. 3983h, Bit 6 = U1IP. 3983h, Bit 5 = U1EIP. 3983h, Bit 4 = U1TXIP. 3983h, Bit 3 = U1RXIP.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3983h, Bit 2 = I2C1EIP. 3983h, Bit 1 = I2C1IP. 3983h, Bit 0 = I2C1TXIP. 3983h, Register on page = 150. 3982h, Name = IPR2. 3982h, Bit 7 = I2C1RXIP. 3982h, Bit 6 = SPI1IP. 3982h, Bit 5 = SPI1TXIP. 3982h, Bit 4 = SPI1RXIP. 3982h, Bit 3 = DMA1AIP. 3982h, Bit 2 = DMA1ORIP. 3982h, Bit 1 = DMA1DCNTIP. 3982h, Bit 0 = DMA1SCNTIP. 3982h, Register on page = 149. 3981h, Name = IPR1. 3981h, Bit 7 = SMT1PWAIP. 3981h, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSMT1PRAIP. 3981h, Bit 5 = SMT1IP. 3981h, Bit 4 = C1IP. 3981h, Bit 3 = ADTIP. 3981h, Bit 2 = ADIP. 3981h, Bit 1 = ZCDIP. 3981h, Bit 0 = INT0IP. 3981h, Register on page = 148\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: Not present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3980h, Name = IPR0. 3980h, Bit 7 = IOCIP. 3980h, Bit 6 = CRCIP. 3980h, Bit 5 = SCANIP. 3980h, Bit 4 = NVMIP. 3980h, Bit 3 = CSWIP. 3980h, Bit 2 = OSFIP. 3980h, Bit 1 = HLVDIP. 3980h, Bit 0 = SWIP. 3980h, Register on page = 147. 397Fh - 397Eh, Name = -. 397Fh - 397Eh, Bit 7 = Unimplemented. 397Fh - 397Eh, Bit 6 = Unimplemented. 397Fh - 397Eh, Bit 5 = Unimplemented. 397Fh - 397Eh, Bit 4 = Unimplemented. 397Fh - 397Eh, Bit 3 = Unimplemented. 397Fh - 397Eh, Bit 2 = Unimplemented.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n397Fh - 397Eh, Bit 1 = Unimplemented. 397Fh - 397Eh, Bit 0 = Unimplemented. 397Fh - 397Eh, Register on page = -. 397Dh, Name = SCANTRIG. 397Dh, Bit 7 = -. 397Dh, Bit 6 = -. 397Dh, Bit 5 = -. 397Dh, Bit 4 = -. 397Dh, Bit 3 = . 397Dh, Bit 2 = . 397Dh, Bit 1 = TSEL. 397Dh, Bit 0 = . 397Dh, Register on page = 216. 397Ch, Name = SCANCON0. 397Ch, Bit 7 = EN. 397Ch, Bit 6 = TRIGEN. 397Ch, Bit 5 = SGO. 397Ch, Bit 4 = -. 397Ch, Bit 3 = -. 397Ch, Bit 2 = MREG. 397Ch, Bit 1 = BURSTMD. 397Ch, Bit 0 = BUSY. 397Ch,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRegister on page = 212. 397Bh, Name = SCANHADRU. 397Bh, Bit 7 = -. 397Bh, Bit 6 = -. 397Bh, Bit 5 = . 397Bh, Bit 4 = . 397Bh, Bit 3 = . 397Bh, Bit 2 = HADR. 397Bh, Bit 1 = . 397Bh, Bit 0 = . 397Bh, Register on page = 214. 397Ah, Name = SCANHADRH. 397Ah, Bit 7 = HADR. 397Ah, Bit 6 = HADR. 397Ah, Bit 5 = HADR. 397Ah, Bit 4 = HADR. 397Ah, Bit 3 = HADR. 397Ah, Bit 2 = HADR. 397Ah, Bit 1 = HADR. 397Ah, Bit 0 = HADR. 397Ah, Register on page = 215. 3979h, Name = SCANHADRL. 3979h, Bit 7 = HADR. 3979h, Bit 6 = HADR.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3979h, Bit 5 = HADR. 3979h, Bit 4 = HADR. 3979h, Bit 3 = HADR. 3979h, Bit 2 = HADR. 3979h, Bit 1 = HADR. 3979h, Bit 0 = HADR. 3979h, Register on page = 215. 3978h, Name = SCANLADRU. 3978h, Bit 7 = - - LADR. 3978h, Bit 6 = - - LADR. 3978h, Bit 5 = - - LADR. 3978h, Bit 4 = - - LADR. 3978h, Bit 3 = - - LADR. 3978h, Bit 2 = - - LADR. 3978h, Bit 1 = - - LADR. 3978h, Bit 0 = - - LADR. 3978h, Register on page = 213. 3977h, Name = SCANLADRH. 3977h, Bit 7 = LADR. 3977h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n6 = LADR. 3977h, Bit 5 = LADR. 3977h, Bit 4 = LADR. 3977h, Bit 3 = LADR. 3977h, Bit 2 = LADR. 3977h, Bit 1 = LADR. 3977h, Bit 0 = LADR. 3977h, Register on page = 213. 3976h, Name = SCANLADRL. 3976h, Bit 7 = LADR. 3976h, Bit 6 = LADR. 3976h, Bit 5 = LADR. 3976h, Bit 4 = LADR. 3976h, Bit 3 = LADR. 3976h, Bit 2 = LADR. 3976h, Bit 1 = LADR. 3976h, Bit 0 = LADR. 3976h, Register on page = 214. 3975h - 396Ah, Name = -. 3975h - 396Ah, Bit 7 = Unimplemented. 3975h - 396Ah, Bit 6",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= Unimplemented. 3975h - 396Ah, Bit 5 = Unimplemented. 3975h - 396Ah, Bit 4 = Unimplemented. 3975h - 396Ah, Bit 3 = Unimplemented. 3975h - 396Ah, Bit 2 = Unimplemented. 3975h - 396Ah, Bit 1 = Unimplemented. 3975h - 396Ah, Bit 0 = Unimplemented. 3975h - 396Ah, Register on page = -. 3969h, Name = CRCCON1. 3969h, Bit 7 = DLEN. 3969h, Bit 6 = DLEN. 3969h, Bit 5 = DLEN. 3969h, Bit 4 = DLEN. 3969h, Bit 3 = . 3969h, Bit 2 = . 3969h, Bit 1 = PLEN. 3969h, Bit 0 = . 3969h, Register on page = 208.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3968h, Name = CRCCON0. 3968h, Bit 7 = EN. 3968h, Bit 6 = CRCGO. 3968h, Bit 5 = BUSY. 3968h, Bit 4 = ACCM. 3968h, Bit 3 = -. 3968h, Bit 2 = -. 3968h, Bit 1 = SHIFTM. 3968h, Bit 0 = FULL. 3968h, Register on page = 208. 3967h, Name = CRCXORH. 3967h, Bit 7 = X15. 3967h, Bit 6 = X14. 3967h, Bit 5 = X13. 3967h, Bit 4 = X12. 3967h, Bit 3 = X11. 3967h, Bit 2 = X10. 3967h, Bit 1 = X9. 3967h, Bit 0 = X8. 3967h, Register on page = 211. 3966h, Name = CRCXORL.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3966h, Bit 7 = X7. 3966h, Bit 6 = X6. 3966h, Bit 5 = X5. 3966h, Bit 4 = X4. 3966h, Bit 3 = X3. 3966h, Bit 2 = X2. 3966h, Bit 1 = X1. 3966h, Bit 0 = -. 3966h, Register on page = 211. 3965h, Name = CRCSHIFTH. 3965h, Bit 7 = SHFT15. 3965h, Bit 6 = SHFT14. 3965h, Bit 5 = SHFT13. 3965h, Bit 4 = SHFT12. 3965h, Bit 3 = SHFT11. 3965h, Bit 2 = SHFT10. 3965h, Bit 1 = SHFT9. 3965h, Bit 0 = SHFT8. 3965h, Register on page = 210. 3964h, Name = CRCSHIFTL. 3964h, Bit 7 = SHFT7. 3964h, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSHFT6. 3964h, Bit 5 = SHFT5. 3964h, Bit 4 = SHFT4. 3964h, Bit 3 = SHFT3. 3964h, Bit 2 = SHFT2. 3964h, Bit 1 = SHFT1. 3964h, Bit 0 = SHFT0. 3964h, Register on page = 210. 3963h, Name = CRCACCH. 3963h, Bit 7 = ACC15. 3963h, Bit 6 = ACC14. 3963h, Bit 5 = ACC13. 3963h, Bit 4 = ACC12. 3963h, Bit 3 = ACC11. 3963h, Bit 2 = ACC10. 3963h, Bit 1 = ACC9. 3963h, Bit 0 = ACC8. 3963h, Register on page = 209. 3962h, Name = CRCACCL. 3962h, Bit 7 = ACC7. 3962h, Bit 6 = ACC6. 3962h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n5 = ACC5. 3962h, Bit 4 = ACC4. 3962h, Bit 3 = ACC3. 3962h, Bit 2 = ACC2. 3962h, Bit 1 = ACC1. 3962h, Bit 0 = ACC0. 3962h, Register on page = 210. 3961h, Name = CRCDATH. 3961h, Bit 7 = DATA15. 3961h, Bit 6 = DATA14. 3961h, Bit 5 = DATA13. 3961h, Bit 4 = DATA12. 3961h, Bit 3 = DATA11. 3961h, Bit 2 = DATA10. 3961h, Bit 1 = DATA9. 3961h, Bit 0 = DATA8. 3961h, Register on page = 209. 3960h, Name = CRCDATL. 3960h, Bit 7 = DATA7. 3960h, Bit 6 = DATA6. 3960h, Bit 5 = DATA5. 3960h, Bit 4 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nDATA4. 3960h, Bit 3 = DATA3. 3960h, Bit 2 = DATA2. 3960h, Bit 1 = DATA1. 3960h, Bit 0 = DATA0. 3960h, Register on page = 209. 395Fh, Name = WDTTMR. 395Fh, Bit 7 = WDTTMR. 395Fh, Bit 6 = WDTTMR. 395Fh, Bit 5 = WDTTMR. 395Fh, Bit 4 = WDTTMR. 395Fh, Bit 3 = WDTTMR. 395Fh, Bit 2 = STATE. 395Fh, Bit 1 = PSCNT. 395Fh, Bit 0 = PSCNT. 395Fh, Register on page = 175. 395Eh, Name = WDTPSH. 395Eh, Bit 7 = PSCNT. 395Eh, Bit 6 = PSCNT. 395Eh, Bit 5 = PSCNT. 395Eh, Bit 4 = PSCNT. 395Eh, Bit 3 = PSCNT. 395Eh, Bit 2 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nPSCNT. 395Eh, Bit 1 = PSCNT. 395Eh, Bit 0 = PSCNT. 395Eh, Register on page = 174. 395Dh, Name = WDTPSL. 395Dh, Bit 7 = PSCNT. 395Dh, Bit 6 = PSCNT. 395Dh, Bit 5 = PSCNT. 395Dh, Bit 4 = PSCNT. 395Dh, Bit 3 = PSCNT. 395Dh, Bit 2 = PSCNT. 395Dh, Bit 1 = PSCNT. 395Dh, Bit 0 = PSCNT. 395Dh, Register on page = . , Name = WDTCON1. , Bit 7 = . , Bit 6 = . , Bit 5 = . , Bit 4 = . , Bit 3 = . , Bit 2 = . , Bit 1 = . , Bit 0 = . , Register on page = 174 173. 395Ch 395Bh, Name = WDTCON0. 395Ch 395Bh, Bit 7 = - WDTCS - WINDOW - -. 395Ch 395Bh, Bit 6 = - WDTCS - WINDOW -",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n-. 395Ch 395Bh, Bit 5 = - WDTCS - WINDOW - -. 395Ch 395Bh, Bit 4 = - WDTCS - WINDOW - -. 395Ch 395Bh, Bit 3 = - WDTCS - WINDOW - -. 395Ch 395Bh, Bit 2 = - WDTCS - WINDOW - -. 395Ch 395Bh, Bit 1 = - WDTCS - WINDOW - -. 395Ch 395Bh, Bit 0 = - WDTCS - WINDOW - -. 395Ch 395Bh, Register on page = 172. 395Ah -, Name = . 395Ah -, Bit 7 = WDTPS SEN Unimplemented. 395Ah -, Bit 6 = WDTPS SEN Unimplemented. 395Ah -, Bit 5 = WDTPS SEN Unimplemented. 395Ah -, Bit 4 = WDTPS SEN Unimplemented. 395Ah -, Bit 3 = WDTPS SEN Unimplemented. 395Ah -, Bit 2 = WDTPS SEN Unimplemented. 395Ah -, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nWDTPS SEN Unimplemented. 395Ah -, Bit 0 = WDTPS SEN Unimplemented. 395Ah -, Register on page = -. 38A0h, Name = -. 38A0h, Bit 7 = AD. 38A0h, Bit 6 = AD. 38A0h, Bit 5 = AD. 38A0h, Bit 4 = AD. 38A0h, Bit 3 = AD. 38A0h, Bit 2 = AD. 38A0h, Bit 1 = AD. 38A0h, Bit 0 = AD. 38A0h, Register on page = . 389Eh, Name = IVTADH. 389Eh, Bit 7 = AD. 389Eh, Bit 6 = AD. 389Eh, Bit 5 = AD. 389Eh, Bit 4 = AD. 389Eh, Bit 3 = AD. 389Eh, Bit 2 = AD. 389Eh, Bit 1 = AD. 389Eh, Bit 0 = AD. 389Eh, Register on page = 158.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n389Dh, Name = IVTADL. 389Dh, Bit 7 = AD. 389Dh, Bit 6 = AD. 389Dh, Bit 5 = AD. 389Dh, Bit 4 = AD. 389Dh, Bit 3 = AD. 389Dh, Bit 2 = AD. 389Dh, Bit 1 = AD. 389Dh, Bit 0 = AD. 389Dh, Register on page = 158. 389Ch - 3891h, Name = -. 389Ch - 3891h, Bit 7 = Unimplemented. 389Ch - 3891h, Bit 6 = Unimplemented. 389Ch - 3891h, Bit 5 = Unimplemented. 389Ch - 3891h, Bit 4 = Unimplemented. 389Ch - 3891h, Bit 3 = Unimplemented. 389Ch - 3891h, Bit 2 = Unimplemented. 389Ch - 3891h, Bit 1 = Unimplemented.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n389Ch - 3891h, Bit 0 = Unimplemented. 389Ch - 3891h, Register on page = -. 3890h, Name = PRODH_SHAD. 3890h, Bit 7 = PRODH. 3890h, Bit 6 = PRODH. 3890h, Bit 5 = PRODH. 3890h, Bit 4 = PRODH. 3890h, Bit 3 = PRODH. 3890h, Bit 2 = PRODH. 3890h, Bit 1 = PRODH. 3890h, Bit 0 = PRODH. 3890h, Register on page = 115. 388Fh, Name = PRODL_SHAD. 388Fh, Bit 7 = PRODL. 388Fh, Bit 6 = PRODL. 388Fh, Bit 5 = PRODL. 388Fh, Bit 4 = PRODL. 388Fh, Bit 3 = PRODL. 388Fh, Bit 2 = PRODL. 388Fh, Bit 1 = PRODL. 388Fh, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n0 = PRODL. 388Fh, Register on page = 115. 388Eh, Name = FSR2H_SHAD. 388Eh, Bit 7 = - - FSR2H. 388Eh, Bit 6 = - - FSR2H. 388Eh, Bit 5 = - - FSR2H. 388Eh, Bit 4 = - - FSR2H. 388Eh, Bit 3 = - - FSR2H. 388Eh, Bit 2 = - - FSR2H. 388Eh, Bit 1 = - - FSR2H. 388Eh, Bit 0 = - - FSR2H. 388Eh, Register on page = 115. 388Dh, Name = FSR2L_SHAD. 388Dh, Bit 7 = . 388Dh, Bit 6 = . 388Dh, Bit 5 = . 388Dh, Bit 4 = FSR2L. 388Dh, Bit 3 = . 388Dh, Bit 2 = . 388Dh, Bit 1 = . 388Dh, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n0 = . 388Dh, Register on page = 115. 388Ch 388Bh, Name = FSR1H_SHAD FSR1L_SHAD. 388Ch 388Bh, Bit 7 = - - FSR1H FSR1L. 388Ch 388Bh, Bit 6 = - - FSR1H FSR1L. 388Ch 388Bh, Bit 5 = - - FSR1H FSR1L. 388Ch 388Bh, Bit 4 = - - FSR1H FSR1L. 388Ch 388Bh, Bit 3 = - - FSR1H FSR1L. 388Ch 388Bh, Bit 2 = - - FSR1H FSR1L. 388Ch 388Bh, Bit 1 = - - FSR1H FSR1L. 388Ch 388Bh, Bit 0 = - - FSR1H FSR1L. 388Ch 388Bh, Register on page = 115 115. 388Ah, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nFSR0H_SHAD. 388Ah, Bit 7 = -. 388Ah, Bit 6 = -. 388Ah, Bit 5 = -. 388Ah, Bit 4 = -. 388Ah, Bit 3 = -. 388Ah, Bit 2 = -. 388Ah, Bit 1 = -. 388Ah, Bit 0 = -. 388Ah, Register on page = . 3889h, Name = FSR0L_SHAD. 3889h, Bit 7 = - FSR0H FSR0L. 3889h, Bit 6 = - FSR0H FSR0L. 3889h, Bit 5 = - FSR0H FSR0L. 3889h, Bit 4 = - FSR0H FSR0L. 3889h, Bit 3 = - FSR0H FSR0L. 3889h, Bit 2 = - FSR0H FSR0L. 3889h, Bit 1 = - FSR0H FSR0L.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3889h, Bit 0 = - FSR0H FSR0L. 3889h, Register on page = 115. , Name = . , Bit 7 = . , Bit 6 = . , Bit 5 = . , Bit 4 = . , Bit 3 = . , Bit 2 = . , Bit 1 = . , Bit 0 = . , Register on page = 115. 3888h, Name = PCLATU_SHAD. 3888h, Bit 7 = -. 3888h, Bit 6 = -. 3888h, Bit 5 = -. 3888h, Bit 4 = -. 3888h, Bit 3 = -. 3888h, Bit 2 = PCU. 3888h, Bit 1 = -. 3888h, Bit 0 = -. 3888h, Register on page = 115. 3887h, Name = PCLATH_SHAD. 3887h, Bit 7 = . 3887h, Bit 6 = . 3887h, Bit 5 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3887h, Bit 4 = PCH. 3887h, Bit 3 = . 3887h, Bit 2 = . 3887h, Bit 1 = . 3887h, Bit 0 = . 3887h, Register on page = 115. 3886h, Name = BSR_SHAD. 3886h, Bit 7 = -. 3886h, Bit 6 = -. 3886h, Bit 5 = -. 3886h, Bit 4 = -. 3886h, Bit 3 = -. 3886h, Bit 2 = -. 3886h, Bit 1 = -. 3886h, Bit 0 = -. 3886h, Register on page = 115. 3885h, Name = . 3885h, Bit 7 = - BSR. 3885h, Bit 6 = - BSR. 3885h, Bit 5 = - BSR. 3885h, Bit 4 = - BSR. 3885h, Bit 3 = - BSR. 3885h, Bit 2 = - BSR. 3885h, Bit 1",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= - BSR. 3885h, Bit 0 = - BSR. 3885h, Register on page = . , Name = WREG_SHAD. , Bit 7 = . , Bit 6 = . , Bit 5 = . , Bit 4 = WREG. , Bit 3 = . , Bit 2 = . , Bit 1 = . , Bit 0 = . , Register on page = 115. 3884h, Name = STATUS_SHAD. 3884h, Bit 7 = -. 3884h, Bit 6 = TO. 3884h, Bit 5 = PD. 3884h, Bit 4 = N. 3884h, Bit 3 = OV. 3884h, Bit 2 = Z. 3884h, Bit 1 = DC. 3884h, Bit 0 = C. 3884h, Register on page = 115. 3883h, Name = SHADCON. 3883h, Bit 7 = -. 3883h, Bit 6 = -. 3883h, Bit 5 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3883h, Bit 4 = -. 3883h, Bit 3 = -. 3883h, Bit 2 = -. 3883h, Bit 1 = -. 3883h, Bit 0 = SHADLO. 3883h, Register on page = 159. 3882h, Name = BSR_CSHAD. 3882h, Bit 7 = - - BSR. 3882h, Bit 6 = - - BSR. 3882h, Bit 5 = - - BSR. 3882h, Bit 4 = - - BSR. 3882h, Bit 3 = - - BSR. 3882h, Bit 2 = - - BSR. 3882h, Bit 1 = - - BSR. 3882h, Bit 0 = - - BSR. 3882h, Register on page = 47. 3881h, Name = WREG_CSHAD. 3881h, Bit 7 = WREG. 3881h, Bit 6 = WREG. 3881h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 5 = WREG. 3881h, Bit 4 = WREG. 3881h, Bit 3 = WREG. 3881h, Bit 2 = WREG. 3881h, Bit 1 = WREG. 3881h, Bit 0 = WREG. 3881h, Register on page = 47\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1:\nNot present in LF devices.\nDS40001943C-page 783",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3880h, Name = STATUS_CSHAD. 3880h, Bit 7 = -. 3880h, Bit 6 = TO. 3880h, Bit 5 = PD. 3880h, Bit 4 = N. 3880h, Bit 3 = OV. 3880h, Bit 2 = Z. 3880h, Bit 1 = DC. 3880h, Bit 0 = C. 3880h, Register on page = 47. 387Fh - 3800h, Name = -. 387Fh - 3800h, Bit 7 = Unimplemented. 387Fh - 3800h, Bit 6 = Unimplemented. 387Fh - 3800h, Bit 5 = Unimplemented. 387Fh - 3800h, Bit 4 = Unimplemented. 387Fh - 3800h, Bit 3 = Unimplemented. 387Fh - 3800h, Bit 2 = Unimplemented. 387Fh - 3800h, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nUnimplemented. 387Fh - 3800h, Bit 0 = Unimplemented. 387Fh - 3800h, Register on page = -. 37FFh, Name = CANCON_RO0. 37FFh, Bit 7 = CANCON_RO0. 37FFh, Bit 6 = CANCON_RO0. 37FFh, Bit 5 = CANCON_RO0. 37FFh, Bit 4 = CANCON_RO0. 37FFh, Bit 3 = CANCON_RO0. 37FFh, Bit 2 = CANCON_RO0. 37FFh, Bit 1 = CANCON_RO0. 37FFh, Bit 0 = CANCON_RO0. 37FFh, Register on page = 604. 37FEh, Name = CANSTAT_RO0. 37FEh, Bit 7 = CANSTAT_RO0. 37FEh, Bit 6 = CANSTAT_RO0. 37FEh, Bit 5 = CANSTAT_RO0. 37FEh, Bit 4 = CANSTAT_RO0.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37FEh, Bit 3 = CANSTAT_RO0. 37FEh, Bit 2 = CANSTAT_RO0. 37FEh, Bit 1 = CANSTAT_RO0. 37FEh, Bit 0 = CANSTAT_RO0. 37FEh, Register on page = 605. 37FDh, Name = RXB1D7. 37FDh, Bit 7 = RXB1D7. 37FDh, Bit 6 = RXB1D7. 37FDh, Bit 5 = RXB1D7. 37FDh, Bit 4 = RXB1D7. 37FDh, Bit 3 = RXB1D7. 37FDh, Bit 2 = RXB1D7. 37FDh, Bit 1 = RXB1D7. 37FDh, Bit 0 = RXB1D7. 37FDh, Register on page = 621. 37FCh, Name = RXB1D6. 37FCh, Bit 7 = RXB1D6. 37FCh, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n6 = RXB1D6. 37FCh, Bit 5 = RXB1D6. 37FCh, Bit 4 = RXB1D6. 37FCh, Bit 3 = RXB1D6. 37FCh, Bit 2 = RXB1D6. 37FCh, Bit 1 = RXB1D6. 37FCh, Bit 0 = RXB1D6. 37FCh, Register on page = 621. 37FBh, Name = RXB1D5. 37FBh, Bit 7 = RXB1D5. 37FBh, Bit 6 = RXB1D5. 37FBh, Bit 5 = RXB1D5. 37FBh, Bit 4 = RXB1D5. 37FBh, Bit 3 = RXB1D5. 37FBh, Bit 2 = RXB1D5. 37FBh, Bit 1 = RXB1D5. 37FBh, Bit 0 = RXB1D5.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37FBh, Register on page = 621. 37FAh, Name = RXB1D4. 37FAh, Bit 7 = RXB1D4. 37FAh, Bit 6 = RXB1D4. 37FAh, Bit 5 = RXB1D4. 37FAh, Bit 4 = RXB1D4. 37FAh, Bit 3 = RXB1D4. 37FAh, Bit 2 = RXB1D4. 37FAh, Bit 1 = RXB1D4. 37FAh, Bit 0 = RXB1D4. 37FAh, Register on page = 621. 37F9h, Name = RXB1D3. 37F9h, Bit 7 = RXB1D3. 37F9h, Bit 6 = RXB1D3. 37F9h, Bit 5 = RXB1D3. 37F9h, Bit 4 = RXB1D3. 37F9h, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRXB1D3. 37F9h, Bit 2 = RXB1D3. 37F9h, Bit 1 = RXB1D3. 37F9h, Bit 0 = RXB1D3. 37F9h, Register on page = 621. 37F8h, Name = RXB1D2. 37F8h, Bit 7 = RXB1D2. 37F8h, Bit 6 = RXB1D2. 37F8h, Bit 5 = RXB1D2. 37F8h, Bit 4 = RXB1D2. 37F8h, Bit 3 = RXB1D2. 37F8h, Bit 2 = RXB1D2. 37F8h, Bit 1 = RXB1D2. 37F8h, Bit 0 = RXB1D2. 37F8h, Register on page = 621. 37F7h, Name = RXB1D1. 37F7h, Bit 7",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= RXB1D1. 37F7h, Bit 6 = RXB1D1. 37F7h, Bit 5 = RXB1D1. 37F7h, Bit 4 = RXB1D1. 37F7h, Bit 3 = RXB1D1. 37F7h, Bit 2 = RXB1D1. 37F7h, Bit 1 = RXB1D1. 37F7h, Bit 0 = RXB1D1. 37F7h, Register on page = 621. 37F6h, Name = RXB1D0. 37F6h, Bit 7 = RXB1D0. 37F6h, Bit 6 = RXB1D0. 37F6h, Bit 5 = RXB1D0. 37F6h, Bit 4 = RXB1D0. 37F6h, Bit 3 = RXB1D0. 37F6h, Bit 2 = RXB1D0.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37F6h, Bit 1 = RXB1D0. 37F6h, Bit 0 = RXB1D0. 37F6h, Register on page = 621. 37F5h, Name = RXB1DLC. 37F5h, Bit 7 = -. 37F5h, Bit 6 = RXRTR. 37F5h, Bit 5 = RB1. 37F5h, Bit 4 = R0. 37F5h, Bit 3 = DLC3. 37F5h, Bit 2 = DLC2. 37F5h, Bit 1 = DLC1. 37F5h, Bit 0 = DLC0. 37F5h, Register on page = 621. 37F4h, Name = RXB1EIDL. 37F4h, Bit 7 = EID7. 37F4h, Bit 6 = EID6. 37F4h, Bit 5 = EID5. 37F4h, Bit 4 = EID4. 37F4h, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nEID3. 37F4h, Bit 2 = EID2. 37F4h, Bit 1 = EID1. 37F4h, Bit 0 = EID0. 37F4h, Register on page = 620. 37F3h, Name = RXB1EIDH. 37F3h, Bit 7 = EID15. 37F3h, Bit 6 = EID14. 37F3h, Bit 5 = EID13. 37F3h, Bit 4 = EID12. 37F3h, Bit 3 = EID11. 37F3h, Bit 2 = EID10. 37F3h, Bit 1 = EID9. 37F3h, Bit 0 = EID8. 37F3h, Register on page = 620. 37F2h, Name = RXB1SIDL. 37F2h, Bit 7 = SID2. 37F2h, Bit 6 = SID1. 37F2h, Bit 5 = SID0. 37F2h, Bit 4 = SRR.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37F2h, Bit 3 = EXID. 37F2h, Bit 2 = -. 37F2h, Bit 1 = EID17. 37F2h, Bit 0 = EID16. 37F2h, Register on page = 620. 37F1h, Name = RXB1SIDH. 37F1h, Bit 7 = SID10. 37F1h, Bit 6 = SID9. 37F1h, Bit 5 = SID8. 37F1h, Bit 4 = SID7. 37F1h, Bit 3 = SID6. 37F1h, Bit 2 = SID5. 37F1h, Bit 1 = SID4. 37F1h, Bit 0 = SID3. 37F1h, Register on page = 619. 37F0h, Name = RXB1CON. 37F0h, Bit 7 = RXFUL. 37F0h, Bit 6 = RXM1. 37F0h, Bit 5 = RXM0. 37F0h, Bit 4 = -.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37F0h, Bit 3 = RXRTRRO. 37F0h, Bit 2 = FILHIT2. 37F0h, Bit 1 = FILHIT1. 37F0h, Bit 0 = FILHIT0. 37F0h, Register on page = 618. 37F0h, Name = RXB1CON. 37F0h, Bit 7 = RXFUL. 37F0h, Bit 6 = RXM1. 37F0h, Bit 5 = RTRRO. 37F0h, Bit 4 = FILHIT4. 37F0h, Bit 3 = FILHIT3. 37F0h, Bit 2 = FILHIT2. 37F0h, Bit 1 = FILHIT1. 37F0h, Bit 0 = FILHIT0. 37F0h, Register on page = 618. 37EFh, Name = CANCON_RO1. 37EFh, Bit 7 = CANCON_RO1. 37EFh, Bit 6 = CANCON_RO1.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37EFh, Bit 5 = CANCON_RO1. 37EFh, Bit 4 = CANCON_RO1. 37EFh, Bit 3 = CANCON_RO1. 37EFh, Bit 2 = CANCON_RO1. 37EFh, Bit 1 = CANCON_RO1. 37EFh, Bit 0 = CANCON_RO1. 37EFh, Register on page = 604. 37EEh, Name = CANSTAT_RO1. 37EEh, Bit 7 = CANSTAT_RO1. 37EEh, Bit 6 = CANSTAT_RO1. 37EEh, Bit 5 = CANSTAT_RO1. 37EEh, Bit 4 = CANSTAT_RO1. 37EEh, Bit 3 = CANSTAT_RO1. 37EEh, Bit 2 = CANSTAT_RO1. 37EEh, Bit 1 = CANSTAT_RO1. 37EEh, Bit 0 = CANSTAT_RO1. 37EEh, Register on page = 605. 37EDh, Name = TXB0D7.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37EDh, Bit 7 = TXB0D7. 37EDh, Bit 6 = TXB0D7. 37EDh, Bit 5 = TXB0D7. 37EDh, Bit 4 = TXB0D7. 37EDh, Bit 3 = TXB0D7. 37EDh, Bit 2 = TXB0D7. 37EDh, Bit 1 = TXB0D7. 37EDh, Bit 0 = TXB0D7. 37EDh, Register on page = 612. 37ECh, Name = TXB0D6. 37ECh, Bit 7 = TXB0D6. 37ECh, Bit 6 = TXB0D6. 37ECh, Bit 5 = TXB0D6. 37ECh, Bit 4 = TXB0D6. 37ECh, Bit 3 = TXB0D6. 37ECh, Bit 2 = TXB0D6. 37ECh, Bit 1 = TXB0D6. 37ECh, Bit 0 = TXB0D6. 37ECh, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n612. 37EBh, Name = TXB0D5. 37EBh, Bit 7 = TXB0D5. 37EBh, Bit 6 = TXB0D5. 37EBh, Bit 5 = TXB0D5. 37EBh, Bit 4 = TXB0D5. 37EBh, Bit 3 = TXB0D5. 37EBh, Bit 2 = TXB0D5. 37EBh, Bit 1 = TXB0D5. 37EBh, Bit 0 = TXB0D5. 37EBh, Register on page = 612. 37EAh, Name = TXB0D4. 37EAh, Bit 7 = TXB0D4. 37EAh, Bit 6 = TXB0D4. 37EAh, Bit 5 = TXB0D4. 37EAh, Bit 4 = TXB0D4. 37EAh, Bit 3 = TXB0D4. 37EAh, Bit 2 = TXB0D4. 37EAh, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nTXB0D4. 37EAh, Bit 0 = TXB0D4. 37EAh, Register on page = 612. 37E9h, Name = TXB0D3. 37E9h, Bit 7 = TXB0D3. 37E9h, Bit 6 = TXB0D3. 37E9h, Bit 5 = TXB0D3. 37E9h, Bit 4 = TXB0D3. 37E9h, Bit 3 = TXB0D3. 37E9h, Bit 2 = TXB0D3. 37E9h, Bit 1 = TXB0D3. 37E9h, Bit 0 = TXB0D3. 37E9h, Register on page = 612. 37E8h, Name = TXB0D2. 37E8h, Bit 7 = TXB0D2. 37E8h, Bit 6 = TXB0D2. 37E8h, Bit 5 = TXB0D2. 37E8h, Bit 4 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nTXB0D2. 37E8h, Bit 3 = TXB0D2. 37E8h, Bit 2 = TXB0D2. 37E8h, Bit 1 = TXB0D2. 37E8h, Bit 0 = TXB0D2. 37E8h, Register on page = 612. 37E7h, Name = TXB0D1. 37E7h, Bit 7 = TXB0D1. 37E7h, Bit 6 = TXB0D1. 37E7h, Bit 5 = TXB0D1. 37E7h, Bit 4 = TXB0D1. 37E7h, Bit 3 = TXB0D1. 37E7h, Bit 2 = TXB0D1. 37E7h, Bit 1 = TXB0D1. 37E7h, Bit 0 = TXB0D1. 37E7h, Register on page = 612. 37E6h, Name = TXB0D0. 37E6h, Bit 7",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= TXB0D0. 37E6h, Bit 6 = TXB0D0. 37E6h, Bit 5 = TXB0D0. 37E6h, Bit 4 = TXB0D0. 37E6h, Bit 3 = TXB0D0. 37E6h, Bit 2 = TXB0D0. 37E6h, Bit 1 = TXB0D0. 37E6h, Bit 0 = TXB0D0. 37E6h, Register on page = 612. 37E5h, Name = TXB0DLC. 37E5h, Bit 7 = -. 37E5h, Bit 6 = TXRTR. 37E5h, Bit 5 = -. 37E5h, Bit 4 = -. 37E5h, Bit 3 = DLC3. 37E5h, Bit 2 = DLC2. 37E5h, Bit 1 = DLC1. 37E5h, Bit 0 = DLC0. 37E5h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n613. 37E4h, Name = TXB0EIDL. 37E4h, Bit 7 = EID7. 37E4h, Bit 6 = EID6. 37E4h, Bit 5 = EID5. 37E4h, Bit 4 = EID4. 37E4h, Bit 3 = EID3. 37E4h, Bit 2 = EID2. 37E4h, Bit 1 = EID1. 37E4h, Bit 0 = EID0. 37E4h, Register on page = 612. 37E3h, Name = TXB0EIDH. 37E3h, Bit 7 = EID15. 37E3h, Bit 6 = EID14. 37E3h, Bit 5 = EID13. 37E3h, Bit 4 = EID12. 37E3h, Bit 3 = EID11. 37E3h, Bit 2 = EID10. 37E3h, Bit 1 = EID9. 37E3h, Bit 0 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nEID8. 37E3h, Register on page = 611. 37E2h, Name = TXB0SIDL. 37E2h, Bit 7 = SID2. 37E2h, Bit 6 = SID1. 37E2h, Bit 5 = SID0. 37E2h, Bit 4 = -. 37E2h, Bit 3 = EXIDE. 37E2h, Bit 2 = -. 37E2h, Bit 1 = EID17. 37E2h, Bit 0 = EID16. 37E2h, Register on page = 611. 37E1h, Name = TXB0SIDH. 37E1h, Bit 7 = SID10. 37E1h, Bit 6 = SID9. 37E1h, Bit 5 = SID8. 37E1h, Bit 4 = SID7. 37E1h, Bit 3 = SID6. 37E1h, Bit 2 = SID5. 37E1h, Bit 1 = SID4. 37E1h, Bit 0 = SID3.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37E1h, Register on page = 611. 37E0h 37DFh, Name = TXB0CON CANCON_RO2. 37E0h 37DFh, Bit 7 = TXBIF TXABT TXLARB TXERR TXREQ - TXPRI1 TXPRI0 CANCON_RO2. 37E0h 37DFh, Bit 6 = TXBIF TXABT TXLARB TXERR TXREQ - TXPRI1 TXPRI0 CANCON_RO2. 37E0h 37DFh, Bit 5 = TXBIF TXABT TXLARB TXERR TXREQ - TXPRI1 TXPRI0 CANCON_RO2. 37E0h 37DFh, Bit 4 = TXBIF TXABT TXLARB TXERR TXREQ - TXPRI1 TXPRI0 CANCON_RO2. 37E0h 37DFh, Bit 3 = TXBIF TXABT TXLARB TXERR TXREQ - TXPRI1 TXPRI0",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCANCON_RO2. 37E0h 37DFh, Bit 2 = TXBIF TXABT TXLARB TXERR TXREQ - TXPRI1 TXPRI0 CANCON_RO2. 37E0h 37DFh, Bit 1 = TXBIF TXABT TXLARB TXERR TXREQ - TXPRI1 TXPRI0 CANCON_RO2. 37E0h 37DFh, Bit 0 = TXBIF TXABT TXLARB TXERR TXREQ - TXPRI1 TXPRI0 CANCON_RO2. 37E0h 37DFh, Register on page = 610 604. 37DEh, Name = CANSTAT_RO2. 37DEh, Bit 7 = CANSTAT_RO2. 37DEh, Bit 6 = CANSTAT_RO2. 37DEh, Bit 5 = CANSTAT_RO2. 37DEh, Bit 4 = CANSTAT_RO2. 37DEh, Bit 3 = CANSTAT_RO2. 37DEh, Bit 2 = CANSTAT_RO2. 37DEh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 1 = CANSTAT_RO2. 37DEh, Bit 0 = CANSTAT_RO2. 37DEh, Register on page = 605. 37DDh, Name = TXB1D7. 37DDh, Bit 7 = TXB1D7. 37DDh, Bit 6 = TXB1D7. 37DDh, Bit 5 = TXB1D7. 37DDh, Bit 4 = TXB1D7. 37DDh, Bit 3 = TXB1D7. 37DDh, Bit 2 = TXB1D7. 37DDh, Bit 1 = TXB1D7. 37DDh, Bit 0 = TXB1D7. 37DDh, Register on page = 612. 37DCh, Name = TXB1D6. 37DCh, Bit 7 = TXB1D6. 37DCh, Bit 6 = TXB1D6. 37DCh, Bit 5 = TXB1D6. 37DCh, Bit 4 = TXB1D6. 37DCh, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nTXB1D6. 37DCh, Bit 2 = TXB1D6. 37DCh, Bit 1 = TXB1D6. 37DCh, Bit 0 = TXB1D6. 37DCh, Register on page = 612. 37DBh, Name = TXB1D5. 37DBh, Bit 7 = TXB1D5. 37DBh, Bit 6 = TXB1D5. 37DBh, Bit 5 = TXB1D5. 37DBh, Bit 4 = TXB1D5. 37DBh, Bit 3 = TXB1D5. 37DBh, Bit 2 = TXB1D5. 37DBh, Bit 1 = TXB1D5. 37DBh, Bit 0 = TXB1D5. 37DBh, Register on page = 612. 37DAh, Name = TXB1D4. 37DAh, Bit 7 = TXB1D4. 37DAh, Bit 6 = TXB1D4. 37DAh, Bit 5 = TXB1D4.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37DAh, Bit 4 = TXB1D4. 37DAh, Bit 3 = TXB1D4. 37DAh, Bit 2 = TXB1D4. 37DAh, Bit 1 = TXB1D4. 37DAh, Bit 0 = TXB1D4. 37DAh, Register on page = 612. 37D9h, Name = TXB1D3. 37D9h, Bit 7 = TXB1D3. 37D9h, Bit 6 = TXB1D3. 37D9h, Bit 5 = TXB1D3. 37D9h, Bit 4 = TXB1D3. 37D9h, Bit 3 = TXB1D3. 37D9h, Bit 2 = TXB1D3. 37D9h, Bit 1 = TXB1D3. 37D9h, Bit 0 = TXB1D3. 37D9h, Register on page = 612. 37D8h, Name = . 37D8h, Bit 7 = TXB1D2.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37D8h, Bit 6 = TXB1D2. 37D8h, Bit 5 = TXB1D2. 37D8h, Bit 4 = TXB1D2. 37D8h, Bit 3 = TXB1D2. 37D8h, Bit 2 = TXB1D2. 37D8h, Bit 1 = TXB1D2. 37D8h, Bit 0 = TXB1D2. 37D8h, Register on page = 612. 37D7h, Name = TXB1D2 TXB1D1. 37D7h, Bit 7 = TXB1D1. 37D7h, Bit 6 = TXB1D1. 37D7h, Bit 5 = TXB1D1. 37D7h, Bit 4 = TXB1D1. 37D7h, Bit 3 = TXB1D1. 37D7h, Bit 2 = TXB1D1. 37D7h, Bit 1 = TXB1D1. 37D7h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 0 = TXB1D1. 37D7h, Register on page = 612. 37D6h, Name = TXB1D0. 37D6h, Bit 7 = TXB1D0. 37D6h, Bit 6 = TXB1D0. 37D6h, Bit 5 = TXB1D0. 37D6h, Bit 4 = TXB1D0. 37D6h, Bit 3 = TXB1D0. 37D6h, Bit 2 = TXB1D0. 37D6h, Bit 1 = TXB1D0. 37D6h, Bit 0 = TXB1D0. 37D6h, Register on page = 612. 37D5h, Name = TXB1DLC. 37D5h, Bit 7 = -. 37D5h, Bit 6 = TXRTR. 37D5h, Bit 5 = -. 37D5h, Bit 4 = -. 37D5h, Bit 3 = DLC3. 37D5h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n2 = DLC2. 37D5h, Bit 1 = DLC1. 37D5h, Bit 0 = DLC0. 37D5h, Register on page = 613. 37D4h, Name = TXB1EIDL. 37D4h, Bit 7 = EID7. 37D4h, Bit 6 = EID6. 37D4h, Bit 5 = EID5. 37D4h, Bit 4 = EID4. 37D4h, Bit 3 = EID3. 37D4h, Bit 2 = EID2. 37D4h, Bit 1 = EID1. 37D4h, Bit 0 = EID0. 37D4h, Register on page = 612. 37D3h, Name = TXB1EIDH. 37D3h, Bit 7 = EID15. 37D3h, Bit 6 = EID14. 37D3h, Bit 5 = EID13. 37D3h, Bit 4 = EID12. 37D3h, Bit 3",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= EID11. 37D3h, Bit 2 = EID10. 37D3h, Bit 1 = EID9. 37D3h, Bit 0 = EID8. 37D3h, Register on page = 611\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: Not present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37D2h, Name = TXB1SIDL. 37D2h, Bit 7 = SID2. 37D2h, Bit 6 = SID1. 37D2h, Bit 5 = SID0. 37D2h, Bit 4 = -. 37D2h, Bit 3 = EXIDE. 37D2h, Bit 2 = -. 37D2h, Bit 1 = EID17. 37D2h, Bit 0 = EID16. 37D2h, Register on page = 611. 37D1h, Name = TXB1SIDH. 37D1h, Bit 7 = SID10. 37D1h, Bit 6 = SID9. 37D1h, Bit 5 = SID8. 37D1h, Bit 4 = SID7. 37D1h, Bit 3 = SID6. 37D1h, Bit 2 = SID5. 37D1h, Bit 1 = SID4. 37D1h, Bit 0 = SID3. 37D1h, Register on page = 611. 37D0h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nName = TXB1CON. 37D0h, Bit 7 = TXBIF. 37D0h, Bit 6 = TXABT. 37D0h, Bit 5 = TXLARB. 37D0h, Bit 4 = TXERR. 37D0h, Bit 3 = TXREQ. 37D0h, Bit 2 = -. 37D0h, Bit 1 = TXPRI1. 37D0h, Bit 0 = TXPRI0. 37D0h, Register on page = 610. 37CFh, Name = CANCON_R03. 37CFh, Bit 7 = . 37CFh, Bit 6 = . 37CFh, Bit 5 = . 37CFh, Bit 4 = CANCON_RO3. 37CFh, Bit 3 = CANCON_RO3. 37CFh, Bit 2 = . 37CFh, Bit 1 = . 37CFh, Bit 0 = . 37CFh, Register on page = 604. 37CEh, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCANSTAT_R03. 37CEh, Bit 7 = . 37CEh, Bit 6 = . 37CEh, Bit 5 = . 37CEh, Bit 4 = CANSTAT_RO3. 37CEh, Bit 3 = CANSTAT_RO3. 37CEh, Bit 2 = . 37CEh, Bit 1 = . 37CEh, Bit 0 = . 37CEh, Register on page = 605. 37CDh, Name = TXB2D7. 37CDh, Bit 7 = . 37CDh, Bit 6 = . 37CDh, Bit 5 = . 37CDh, Bit 4 = TXB2D7. 37CDh, Bit 3 = TXB2D7. 37CDh, Bit 2 = . 37CDh, Bit 1 = . 37CDh, Bit 0 = . 37CDh, Register on page = 612. 37CCh, Name = TXB2D6. 37CCh, Bit 7 = . 37CCh, Bit 6 = . 37CCh, Bit 5 = . 37CCh, Bit 4",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= TXB2D6. 37CCh, Bit 3 = TXB2D6. 37CCh, Bit 2 = . 37CCh, Bit 1 = . 37CCh, Bit 0 = . 37CCh, Register on page = 612. 37CBh, Name = TXB2D5. 37CBh, Bit 7 = . 37CBh, Bit 6 = . 37CBh, Bit 5 = . 37CBh, Bit 4 = TXB2D5. 37CBh, Bit 3 = TXB2D5. 37CBh, Bit 2 = . 37CBh, Bit 1 = . 37CBh, Bit 0 = . 37CBh, Register on page = 612. 37CAh, Name = TXB2D4. 37CAh, Bit 7 = . 37CAh, Bit 6 = . 37CAh, Bit 5 = . 37CAh, Bit 4 = TXB2D4. 37CAh, Bit 3 = TXB2D4. 37CAh, Bit 2 = . 37CAh, Bit 1 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37CAh, Bit 0 = . 37CAh, Register on page = 612. 37C9h, Name = TXB2D3. 37C9h, Bit 7 = . 37C9h, Bit 6 = . 37C9h, Bit 5 = . 37C9h, Bit 4 = TXB2D3. 37C9h, Bit 3 = TXB2D3. 37C9h, Bit 2 = . 37C9h, Bit 1 = . 37C9h, Bit 0 = . 37C9h, Register on page = 612. 37C8h, Name = TXB2D2. 37C8h, Bit 7 = . 37C8h, Bit 6 = . 37C8h, Bit 5 = . 37C8h, Bit 4 = TXB2D2. 37C8h, Bit 3 = TXB2D2. 37C8h, Bit 2 = . 37C8h, Bit 1 = . 37C8h, Bit 0 = . 37C8h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n612. 37C7h, Name = TXB2D1. 37C7h, Bit 7 = . 37C7h, Bit 6 = . 37C7h, Bit 5 = . 37C7h, Bit 4 = TXB2D1. 37C7h, Bit 3 = TXB2D1. 37C7h, Bit 2 = . 37C7h, Bit 1 = . 37C7h, Bit 0 = . 37C7h, Register on page = 612. 37C6h, Name = TXB2D0. 37C6h, Bit 7 = . 37C6h, Bit 6 = . 37C6h, Bit 5 = . 37C6h, Bit 4 = TXB2D0. 37C6h, Bit 3 = TXB2D0. 37C6h, Bit 2 = . 37C6h, Bit 1 = . 37C6h, Bit 0 = . 37C6h, Register on page = 612. 37C5h, Name = TXB2DLC.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37C5h, Bit 7 = -. 37C5h, Bit 6 = TXRTR. 37C5h, Bit 5 = -. 37C5h, Bit 4 = -. 37C5h, Bit 3 = DLC3. 37C5h, Bit 2 = DLC2. 37C5h, Bit 1 = DLC1. 37C5h, Bit 0 = DLC0. 37C5h, Register on page = 613. 37C4h, Name = TXB2EIDL. 37C4h, Bit 7 = EID7. 37C4h, Bit 6 = EID6. 37C4h, Bit 5 = EID5. 37C4h, Bit 4 = EID4. 37C4h, Bit 3 = EID3. 37C4h, Bit 2 = EID2. 37C4h, Bit 1 = EID1. 37C4h, Bit 0 = EID0. 37C4h, Register on page = 612. 37C3h, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nTXB2EIDH. 37C3h, Bit 7 = EID15. 37C3h, Bit 6 = EID14. 37C3h, Bit 5 = EID13. 37C3h, Bit 4 = EID12. 37C3h, Bit 3 = EID11. 37C3h, Bit 2 = EID10. 37C3h, Bit 1 = EID9. 37C3h, Bit 0 = EID8. 37C3h, Register on page = 611. 37C2h, Name = TXB2SIDL. 37C2h, Bit 7 = SID2. 37C2h, Bit 6 = SID1. 37C2h, Bit 5 = SID0. 37C2h, Bit 4 = -. 37C2h, Bit 3 = EXIDE. 37C2h, Bit 2 = -. 37C2h, Bit 1 = EID17. 37C2h, Bit 0 = EID16. 37C2h, Register on page = 611.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37C1h, Name = TXB2SIDH. 37C1h, Bit 7 = SID10. 37C1h, Bit 6 = SID9. 37C1h, Bit 5 = SID8. 37C1h, Bit 4 = SID7. 37C1h, Bit 3 = SID6. 37C1h, Bit 2 = SID5. 37C1h, Bit 1 = SID4. 37C1h, Bit 0 = SID3. 37C1h, Register on page = 611. 37C0h, Name = TXB2CON. 37C0h, Bit 7 = TXBIF. 37C0h, Bit 6 = TXABT. 37C0h, Bit 5 = TXLARB. 37C0h, Bit 4 = TXERR. 37C0h, Bit 3 = TXREQ. 37C0h, Bit 2 = -. 37C0h, Bit 1 = TXPRI1. 37C0h, Bit 0 = TXPRI0. 37C0h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n610. 37BFh, Name = RXM1EIDL. 37BFh, Bit 7 = EID7. 37BFh, Bit 6 = EID6. 37BFh, Bit 5 = EID5. 37BFh, Bit 4 = EID4. 37BFh, Bit 3 = EID3. 37BFh, Bit 2 = EID2. 37BFh, Bit 1 = EID1. 37BFh, Bit 0 = EID0. 37BFh, Register on page = 634. 37BEh, Name = RXM1EIDH. 37BEh, Bit 7 = EID15. 37BEh, Bit 6 = EID14. 37BEh, Bit 5 = EID13. 37BEh, Bit 4 = EID12. 37BEh, Bit 3 = EID11. 37BEh, Bit 2 = EID10. 37BEh, Bit 1 = EID9. 37BEh, Bit 0 = EID8. 37BEh, Register on page = 633. 37BDh, Name",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= RXM1SIDL. 37BDh, Bit 7 = SID2. 37BDh, Bit 6 = SID1. 37BDh, Bit 5 = SID0. 37BDh, Bit 4 = -. 37BDh, Bit 3 = EXIDEN. 37BDh, Bit 2 = -. 37BDh, Bit 1 = EID17. 37BDh, Bit 0 = EID16. 37BDh, Register on page = 633. 37BCh, Name = RXM1SIDH. 37BCh, Bit 7 = SID10. 37BCh, Bit 6 = SID9. 37BCh, Bit 5 = SID8. 37BCh, Bit 4 = SID7. 37BCh, Bit 3 = SID6. 37BCh, Bit 2 = SID5. 37BCh, Bit 1 = SID4. 37BCh, Bit 0 = SID3. 37BCh, Register on page = 632. 37BBh, Name = RXM0EIDL. 37BBh, Bit 7 = EID7.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37BBh, Bit 6 = EID6. 37BBh, Bit 5 = EID5. 37BBh, Bit 4 = EID4. 37BBh, Bit 3 = EID3. 37BBh, Bit 2 = EID2. 37BBh, Bit 1 = EID1. 37BBh, Bit 0 = EID0. 37BBh, Register on page = 634. 37BAh, Name = RXM0EIDH. 37BAh, Bit 7 = EID15. 37BAh, Bit 6 = EID14. 37BAh, Bit 5 = EID13. 37BAh, Bit 4 = EID12. 37BAh, Bit 3 = EID11. 37BAh, Bit 2 = EID10. 37BAh, Bit 1 = EID9. 37BAh, Bit 0 = EID8. 37BAh, Register on page = 633. 37B9h, Name = RXM0SIDL. 37B9h, Bit 7 = SID2. 37B9h, Bit 6 = SID1. 37B9h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 5 = SID0. 37B9h, Bit 4 = -. 37B9h, Bit 3 = EXIDEN. 37B9h, Bit 2 = -. 37B9h, Bit 1 = EID17. 37B9h, Bit 0 = EID16. 37B9h, Register on page = 632. 37B8h, Name = RXM0SIDH. 37B8h, Bit 7 = SID10. 37B8h, Bit 6 = SID9. 37B8h, Bit 5 = SID8. 37B8h, Bit 4 = SID7. 37B8h, Bit 3 = SID6. 37B8h, Bit 2 = SID5. 37B8h, Bit 1 = SID4. 37B8h, Bit 0 = SID3. 37B8h, Register on page = 632. 37B7h, Name = RXF5EIDL. 37B7h, Bit 7 = EID7. 37B7h, Bit 6 = EID6. 37B7h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 5 = EID5. 37B7h, Bit 4 = EID4. 37B7h, Bit 3 = EID3. 37B7h, Bit 2 = EID2. 37B7h, Bit 1 = EID1. 37B7h, Bit 0 = EID0. 37B7h, Register on page = 632. 37B6h, Name = RXF5EIDH. 37B6h, Bit 7 = EID15. 37B6h, Bit 6 = EID14. 37B6h, Bit 5 = EID13. 37B6h, Bit 4 = EID12. 37B6h, Bit 3 = EID11. 37B6h, Bit 2 = EID10. 37B6h, Bit 1 = EID9. 37B6h, Bit 0 = EID8. 37B6h, Register on page = 632. 37B5h, Name = RXF5SIDL. 37B5h, Bit 7 = SID2. 37B5h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 6 = SID1. 37B5h, Bit 5 = SID0. 37B5h, Bit 4 = -. 37B5h, Bit 3 = EXIDEN. 37B5h, Bit 2 = -. 37B5h, Bit 1 = EID17. 37B5h, Bit 0 = EID16. 37B5h, Register on page = 631. 37B4h, Name = RXF5SIDH. 37B4h, Bit 7 = SID10. 37B4h, Bit 6 = SID9. 37B4h, Bit 5 = SID8. 37B4h, Bit 4 = SID7. 37B4h, Bit 3 = SID6. 37B4h, Bit 2 = SID5. 37B4h, Bit 1 = SID4. 37B4h, Bit 0 = SID3. 37B4h, Register on page = 631. 37B3h, Name = RXF4EIDL. 37B3h, Bit 7 = EID7. 37B3h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n6 = EID6. 37B3h, Bit 5 = EID5. 37B3h, Bit 4 = EID4. 37B3h, Bit 3 = EID3. 37B3h, Bit 2 = EID2. 37B3h, Bit 1 = EID1. 37B3h, Bit 0 = EID0. 37B3h, Register on page = 632. 37B2h, Name = RXF4EIDH. 37B2h, Bit 7 = EID15. 37B2h, Bit 6 = EID14. 37B2h, Bit 5 = EID13. 37B2h, Bit 4 = EID12. 37B2h, Bit 3 = EID11. 37B2h, Bit 2 = EID10. 37B2h, Bit 1 = EID9. 37B2h, Bit 0 = EID8. 37B2h, Register on page = 632. 37B1h, Name = RXF4SIDL. 37B1h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 7 = SID2. 37B1h, Bit 6 = SID1. 37B1h, Bit 5 = SID0. 37B1h, Bit 4 = -. 37B1h, Bit 3 = EXIDEN. 37B1h, Bit 2 = -. 37B1h, Bit 1 = EID17. 37B1h, Bit 0 = EID16. 37B1h, Register on page = 631. 37B0h, Name = RXF4SIDH. 37B0h, Bit 7 = SID10. 37B0h, Bit 6 = SID9. 37B0h, Bit 5 = SID8. 37B0h, Bit 4 = SID7. 37B0h, Bit 3 = SID6. 37B0h, Bit 2 = SID5. 37B0h, Bit 1 = SID4. 37B0h, Bit 0 = SID3. 37B0h, Register on page = 631. 37AFh, Name = RXF3EIDL. 37AFh, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nEID7. 37AFh, Bit 6 = EID6. 37AFh, Bit 5 = EID5. 37AFh, Bit 4 = EID4. 37AFh, Bit 3 = EID3. 37AFh, Bit 2 = EID2. 37AFh, Bit 1 = EID1. 37AFh, Bit 0 = EID0. 37AFh, Register on page = 632. 37AEh, Name = RXF3EIDH. 37AEh, Bit 7 = EID15. 37AEh, Bit 6 = EID14. 37AEh, Bit 5 = EID13. 37AEh, Bit 4 = EID12. 37AEh, Bit 3 = EID11. 37AEh, Bit 2 = EID10. 37AEh, Bit 1 = EID9. 37AEh, Bit 0 = EID8. 37AEh, Register on page = 632. 37ADh, Name = RXF3SIDL. 37ADh, Bit 7 = SID2. 37ADh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 6 = SID1. 37ADh, Bit 5 = SID0. 37ADh, Bit 4 = -. 37ADh, Bit 3 = EXIDEN. 37ADh, Bit 2 = -. 37ADh, Bit 1 = EID17. 37ADh, Bit 0 = EID16. 37ADh, Register on page = 631. 37ACh, Name = RXF3SIDH. 37ACh, Bit 7 = SID10. 37ACh, Bit 6 = SID9. 37ACh, Bit 5 = SID8. 37ACh, Bit 4 = SID7. 37ACh, Bit 3 = SID6. 37ACh, Bit 2 = SID5. 37ACh, Bit 1 = SID4. 37ACh, Bit 0 = SID3. 37ACh, Register on page = 631. 37ABh, Name = RXF2EIDL. 37ABh, Bit 7 = EID7. 37ABh, Bit 6 = EID6. 37ABh, Bit 5 = EID5. 37ABh, Bit 4 = EID4.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37ABh, Bit 3 = EID3. 37ABh, Bit 2 = EID2. 37ABh, Bit 1 = EID1. 37ABh, Bit 0 = EID0. 37ABh, Register on page = 632. 37AAh, Name = RXF2EIDH. 37AAh, Bit 7 = EID15. 37AAh, Bit 6 = EID14. 37AAh, Bit 5 = EID13. 37AAh, Bit 4 = EID12. 37AAh, Bit 3 = EID11. 37AAh, Bit 2 = EID10. 37AAh, Bit 1 = EID9. 37AAh, Bit 0 = EID8. 37AAh, Register on page = 632. 37A9h, Name = RXF2SIDL. 37A9h, Bit 7 = SID2. 37A9h, Bit 6 = SID1. 37A9h, Bit 5 = SID0. 37A9h, Bit 4 = -. 37A9h, Bit 3",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= EXIDEN. 37A9h, Bit 2 = -. 37A9h, Bit 1 = EID17. 37A9h, Bit 0 = EID16. 37A9h, Register on page = 631. 37A8h, Name = RXF2SIDH. 37A8h, Bit 7 = SID10. 37A8h, Bit 6 = SID9. 37A8h, Bit 5 = SID8. 37A8h, Bit 4 = SID7. 37A8h, Bit 3 = SID6. 37A8h, Bit 2 = SID5. 37A8h, Bit 1 = SID4. 37A8h, Bit 0 = SID3. 37A8h, Register on page = 631. 37A7h, Name = RXF1EIDL. 37A7h, Bit 7 = EID7. 37A7h, Bit 6 = EID6. 37A7h, Bit 5 = EID5. 37A7h, Bit 4 = EID4.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37A7h, Bit 3 = EID3. 37A7h, Bit 2 = EID2. 37A7h, Bit 1 = EID1. 37A7h, Bit 0 = EID0. 37A7h, Register on page = 632. 37A6h, Name = RXF1EIDH. 37A6h, Bit 7 = EID15. 37A6h, Bit 6 = EID14. 37A6h, Bit 5 = EID13. 37A6h, Bit 4 = EID12. 37A6h, Bit 3 = EID11. 37A6h, Bit 2 = EID10. 37A6h, Bit 1 = EID9. 37A6h, Bit 0 = EID8. 37A6h, Register on page = 632. 37A5h, Name = RXF1SIDL. 37A5h, Bit 7 = SID2. 37A5h, Bit 6 = SID1. 37A5h, Bit 5 = SID0.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37A5h, Bit 4 = -. 37A5h, Bit 3 = EXIDEN. 37A5h, Bit 2 = -. 37A5h, Bit 1 = EID17. 37A5h, Bit 0 = EID16. 37A5h, Register on page = 631. 37A4h, Name = RXF1SIDH. 37A4h, Bit 7 = SID10. 37A4h, Bit 6 = SID9. 37A4h, Bit 5 = SID8. 37A4h, Bit 4 = SID7. 37A4h, Bit 3 = SID6. 37A4h, Bit 2 = SID5. 37A4h, Bit 1 = SID4. 37A4h, Bit 0 = SID3. 37A4h, Register on page = 631. 37A3h, Name = RXF0EIDL. 37A3h, Bit 7 = EID7. 37A3h, Bit 6 = EID6. 37A3h, Bit 5 = EID5",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nEID13. 37A3h, Bit 4 = EID4 EID12. 37A3h, Bit 3 = EID3. 37A3h, Bit 2 = EID2. 37A3h, Bit 1 = EID1. 37A3h, Bit 0 = EID0. 37A3h, Register on page = 632. 37A2h, Name = RXF0EIDH. 37A2h, Bit 7 = EID15. 37A2h, Bit 6 = EID14. 37A2h, Bit 5 = . 37A2h, Bit 4 = . 37A2h, Bit 3 = EID11. 37A2h, Bit 2 = EID10. 37A2h, Bit 1 = EID9. 37A2h, Bit 0 = EID8. 37A2h, Register on page = 632. 37A1h, Name = RXF0SIDL. 37A1h, Bit 7 = SID2. 37A1h, Bit 6 = SID1.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37A1h, Bit 5 = SID0. 37A1h, Bit 4 = -. 37A1h, Bit 3 = EXIDEN. 37A1h, Bit 2 = -. 37A1h, Bit 1 = EID17. 37A1h, Bit 0 = EID16. 37A1h, Register on page = 631\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: Not present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n37A0h, Name = RXF0SIDH. 37A0h, Bit 7 = SID10. 37A0h, Bit 6 = SID9. 37A0h, Bit 5 = SID8. 37A0h, Bit 4 = SID7. 37A0h, Bit 3 = SID6. 37A0h, Bit 2 = SID5. 37A0h, Bit 1 = SID4. 37A0h, Bit 0 = SID3. 37A0h, Register on page = 631. 379Fh, Name = CANCON_RO4. 379Fh, Bit 7 = . 379Fh, Bit 6 = . 379Fh, Bit 5 = . 379Fh, Bit 4 = CANCON_RO4. 379Fh, Bit 3 = CANCON_RO4. 379Fh, Bit 2 = . 379Fh, Bit 1 = . 379Fh, Bit 0 = . 379Fh, Register on page = 604. 379Eh, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCANSTAT_RO4. 379Eh, Bit 7 = . 379Eh, Bit 6 = . 379Eh, Bit 5 = . 379Eh, Bit 4 = CANSTAT_RO4. 379Eh, Bit 3 = CANSTAT_RO4. 379Eh, Bit 2 = . 379Eh, Bit 1 = . 379Eh, Bit 0 = . 379Eh, Register on page = 605. 379Dh, Name = B5D7. 379Dh, Bit 7 = . 379Dh, Bit 6 = . 379Dh, Bit 5 = . 379Dh, Bit 4 = B5D7. 379Dh, Bit 3 = B5D7. 379Dh, Bit 2 = . 379Dh, Bit 1 = . 379Dh, Bit 0 = . 379Dh, Register on page = 628. 379Ch, Name = B5D6. 379Ch, Bit 7 = . 379Ch, Bit 6 = . 379Ch, Bit 5 = . 379Ch, Bit 4 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nB5D6. 379Ch, Bit 3 = B5D6. 379Ch, Bit 2 = . 379Ch, Bit 1 = . 379Ch, Bit 0 = . 379Ch, Register on page = 628. 379Bh, Name = B5D5. 379Bh, Bit 7 = . 379Bh, Bit 6 = . 379Bh, Bit 5 = . 379Bh, Bit 4 = B5D5. 379Bh, Bit 3 = B5D5. 379Bh, Bit 2 = . 379Bh, Bit 1 = . 379Bh, Bit 0 = . 379Bh, Register on page = 628. 379Ah, Name = B5D4. 379Ah, Bit 7 = . 379Ah, Bit 6 = . 379Ah, Bit 5 = . 379Ah, Bit 4 = B5D4. 379Ah, Bit 3 = B5D4. 379Ah, Bit 2 = . 379Ah, Bit 1 = . 379Ah, Bit 0 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n379Ah, Register on page = 628. 3799h, Name = B5D3. 3799h, Bit 7 = . 3799h, Bit 6 = . 3799h, Bit 5 = . 3799h, Bit 4 = B5D3. 3799h, Bit 3 = B5D3. 3799h, Bit 2 = . 3799h, Bit 1 = . 3799h, Bit 0 = . 3799h, Register on page = 628. 3798h, Name = B5D2. 3798h, Bit 7 = . 3798h, Bit 6 = . 3798h, Bit 5 = . 3798h, Bit 4 = B5D2. 3798h, Bit 3 = B5D2. 3798h, Bit 2 = . 3798h, Bit 1 = . 3798h, Bit 0 = . 3798h, Register on page = 628. 3797h, Name = B5D1.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3797h, Bit 7 = . 3797h, Bit 6 = . 3797h, Bit 5 = . 3797h, Bit 4 = B5D1. 3797h, Bit 3 = B5D1. 3797h, Bit 2 = . 3797h, Bit 1 = . 3797h, Bit 0 = . 3797h, Register on page = 628. 3796h, Name = B5D0. 3796h, Bit 7 = . 3796h, Bit 6 = . 3796h, Bit 5 = . 3796h, Bit 4 = B5D0. 3796h, Bit 3 = B5D0. 3796h, Bit 2 = . 3796h, Bit 1 = . 3796h, Bit 0 = . 3796h, Register on page = 628. 3795h, Name = B5DLC. 3795h, Bit 7 = -. 3795h, Bit 6 = RXRTR.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3795h, Bit 5 = RB1. 3795h, Bit 4 = RB0. 3795h, Bit 3 = DLC3. 3795h, Bit 2 = DLC2. 3795h, Bit 1 = DLC1. 3795h, Bit 0 = DLC0. 3795h, Register on page = 629. 3795h, Name = B5DLC. 3795h, Bit 7 = -. 3795h, Bit 6 = TXRTR. 3795h, Bit 5 = -. 3795h, Bit 4 = -. 3795h, Bit 3 = DLC3. 3795h, Bit 2 = DLC2. 3795h, Bit 1 = DLC1. 3795h, Bit 0 = DLC0. 3795h, Register on page = 630. 3794h, Name = B5EIDL. 3794h, Bit 7 = EID7. 3794h, Bit 6 = EID6.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3794h, Bit 5 = EID5. 3794h, Bit 4 = EID4. 3794h, Bit 3 = EID3. 3794h, Bit 2 = EID2. 3794h, Bit 1 = EID1. 3794h, Bit 0 = EID0. 3794h, Register on page = 627. 3793h, Name = B5EIDH. 3793h, Bit 7 = EID15. 3793h, Bit 6 = EID14. 3793h, Bit 5 = EID13. 3793h, Bit 4 = EID12. 3793h, Bit 3 = EID11. 3793h, Bit 2 = EID10. 3793h, Bit 1 = EID9. 3793h, Bit 0 = EID8. 3793h, Register on page = 627. 3792h, Name = B5SIDL. 3792h, Bit 7 = SID2.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3792h, Bit 6 = SID1. 3792h, Bit 5 = SID0. 3792h, Bit 4 = SRR. 3792h, Bit 3 = EXIDE. 3792h, Bit 2 = -. 3792h, Bit 1 = EID17. 3792h, Bit 0 = EID16. 3792h, Register on page = 626. 3791h, Name = B5SIDH. 3791h, Bit 7 = SID10. 3791h, Bit 6 = SID9. 3791h, Bit 5 = SID8. 3791h, Bit 4 = SID7. 3791h, Bit 3 = SID6. 3791h, Bit 2 = SID5. 3791h, Bit 1 = SID4. 3791h, Bit 0 = SID3. 3791h, Register on page = 625. 3790h, Name = B5CON. 3790h, Bit 7 = RXFUL. 3790h, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRXM1. 3790h, Bit 5 = RXRTRRO. 3790h, Bit 4 = FILHIT4. 3790h, Bit 3 = FILHIT3. 3790h, Bit 2 = FILHIT2. 3790h, Bit 1 = FILHIT1. 3790h, Bit 0 = FILHIT0. 3790h, Register on page = 623. 3790h, Name = B5CON. 3790h, Bit 7 = TXBIF. 3790h, Bit 6 = TXABT. 3790h, Bit 5 = TXLARB. 3790h, Bit 4 = TXERR. 3790h, Bit 3 = TXREQ. 3790h, Bit 2 = RTREN. 3790h, Bit 1 = TXPRI1. 3790h, Bit 0 = TXPRI0. 3790h, Register on page = 624. 378Fh, Name = CANCON_RO5. 378Fh, Bit 7 = . 378Fh, Bit 6 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n378Fh, Bit 5 = . 378Fh, Bit 4 = CANCON_RO5. 378Fh, Bit 3 = CANCON_RO5. 378Fh, Bit 2 = . 378Fh, Bit 1 = . 378Fh, Bit 0 = . 378Fh, Register on page = 604. 378Eh, Name = CANSTAT_RO5. 378Eh, Bit 7 = . 378Eh, Bit 6 = . 378Eh, Bit 5 = . 378Eh, Bit 4 = CANSTAT_RO5. 378Eh, Bit 3 = CANSTAT_RO5. 378Eh, Bit 2 = . 378Eh, Bit 1 = . 378Eh, Bit 0 = . 378Eh, Register on page = 605. 378Dh, Name = B4D7. 378Dh, Bit 7 = . 378Dh, Bit 6 = . 378Dh, Bit 5 = . 378Dh, Bit 4 = B4D7. 378Dh, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nB4D7. 378Dh, Bit 2 = . 378Dh, Bit 1 = . 378Dh, Bit 0 = . 378Dh, Register on page = 628. 378Ch, Name = B4D6. 378Ch, Bit 7 = . 378Ch, Bit 6 = . 378Ch, Bit 5 = . 378Ch, Bit 4 = B4D6. 378Ch, Bit 3 = B4D6. 378Ch, Bit 2 = . 378Ch, Bit 1 = . 378Ch, Bit 0 = . 378Ch, Register on page = 628. 378Bh, Name = B4D5. 378Bh, Bit 7 = . 378Bh, Bit 6 = . 378Bh, Bit 5 = . 378Bh, Bit 4 = B4D5. 378Bh, Bit 3 = B4D5. 378Bh, Bit 2 = . 378Bh, Bit 1 = . 378Bh, Bit 0 = . 378Bh, Register on page = 628.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n378Ah, Name = B4D4. 378Ah, Bit 7 = . 378Ah, Bit 6 = . 378Ah, Bit 5 = . 378Ah, Bit 4 = B4D4. 378Ah, Bit 3 = B4D4. 378Ah, Bit 2 = . 378Ah, Bit 1 = . 378Ah, Bit 0 = . 378Ah, Register on page = 628. 3789h, Name = B4D3. 3789h, Bit 7 = . 3789h, Bit 6 = . 3789h, Bit 5 = . 3789h, Bit 4 = B4D3. 3789h, Bit 3 = B4D3. 3789h, Bit 2 = . 3789h, Bit 1 = . 3789h, Bit 0 = . 3789h, Register on page = 628. 3788h, Name = B4D2. 3788h, Bit 7 = . 3788h, Bit 6 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3788h, Bit 5 = . 3788h, Bit 4 = B4D2. 3788h, Bit 3 = B4D2. 3788h, Bit 2 = . 3788h, Bit 1 = . 3788h, Bit 0 = . 3788h, Register on page = 628. 3787h, Name = B4D1. 3787h, Bit 7 = . 3787h, Bit 6 = . 3787h, Bit 5 = . 3787h, Bit 4 = B4D1. 3787h, Bit 3 = B4D1. 3787h, Bit 2 = . 3787h, Bit 1 = . 3787h, Bit 0 = . 3787h, Register on page = 628. 3786h, Name = B4D0. 3786h, Bit 7 = . 3786h, Bit 6 = . 3786h, Bit 5 = . 3786h, Bit 4 = B4D0. 3786h, Bit 3",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= B4D0. 3786h, Bit 2 = . 3786h, Bit 1 = . 3786h, Bit 0 = . 3786h, Register on page = 628. 3785h, Name = B4DLC. 3785h, Bit 7 = -. 3785h, Bit 6 = RXRTR. 3785h, Bit 5 = RB1. 3785h, Bit 4 = RB0. 3785h, Bit 3 = DLC3. 3785h, Bit 2 = DLC2. 3785h, Bit 1 = DLC1. 3785h, Bit 0 = DLC0. 3785h, Register on page = 629. 3785h, Name = B4DLC. 3785h, Bit 7 = -. 3785h, Bit 6 = TXRTR. 3785h, Bit 5 = -. 3785h, Bit 4 = -. 3785h, Bit 3 = DLC3. 3785h, Bit 2 = DLC2. 3785h, Bit 1 = DLC1.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3785h, Bit 0 = DLC0. 3785h, Register on page = 630. 3784h, Name = B4EIDL. 3784h, Bit 7 = EID7. 3784h, Bit 6 = EID6. 3784h, Bit 5 = EID5. 3784h, Bit 4 = EID4. 3784h, Bit 3 = EID3. 3784h, Bit 2 = EID2. 3784h, Bit 1 = EID1. 3784h, Bit 0 = EID0. 3784h, Register on page = 627. 3783h, Name = B4EIDH. 3783h, Bit 7 = EID15. 3783h, Bit 6 = EID14. 3783h, Bit 5 = EID13. 3783h, Bit 4 = EID12. 3783h, Bit 3 = EID11. 3783h, Bit 2 = EID10. 3783h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n1 = EID9. 3783h, Bit 0 = EID8. 3783h, Register on page = 627. 3782h, Name = B4SIDL. 3782h, Bit 7 = SID2. 3782h, Bit 6 = SID1. 3782h, Bit 5 = SID0. 3782h, Bit 4 = SRR. 3782h, Bit 3 = EXIDE. 3782h, Bit 2 = -. 3782h, Bit 1 = EID17. 3782h, Bit 0 = EID16. 3782h, Register on page = 626. 3781h, Name = B4SIDH. 3781h, Bit 7 = SID10. 3781h, Bit 6 = SID9. 3781h, Bit 5 = SID8. 3781h, Bit 4 = SID7. 3781h, Bit 3 = SID6. 3781h, Bit 2 = SID5. 3781h, Bit 1 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSID4. 3781h, Bit 0 = SID3. 3781h, Register on page = 625. 3780h, Name = B4CON. 3780h, Bit 7 = RXFUL. 3780h, Bit 6 = RXM1. 3780h, Bit 5 = RXRTRRO. 3780h, Bit 4 = FILHIT4. 3780h, Bit 3 = FILHIT3. 3780h, Bit 2 = FILHIT2. 3780h, Bit 1 = FILHIT1. 3780h, Bit 0 = FILHIT0. 3780h, Register on page = 623. 3780h, Name = B4CON. 3780h, Bit 7 = TXBIF. 3780h, Bit 6 = TXABT. 3780h, Bit 5 = TXLARB. 3780h, Bit 4 = TXERR. 3780h, Bit 3 = TXREQ. 3780h, Bit 2 = RTREN. 3780h, Bit 1 = TXPRI1.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3780h, Bit 0 = TXPRI0. 3780h, Register on page = 624. 377Fh, Name = CANCON_RO6. 377Fh, Bit 7 = . 377Fh, Bit 6 = . 377Fh, Bit 5 = . 377Fh, Bit 4 = CANCON_RO6. 377Fh, Bit 3 = CANCON_RO6. 377Fh, Bit 2 = . 377Fh, Bit 1 = . 377Fh, Bit 0 = . 377Fh, Register on page = 604. 377Eh, Name = CANSTAT_RO6. 377Eh, Bit 7 = . 377Eh, Bit 6 = . 377Eh, Bit 5 = . 377Eh, Bit 4 = CANSTAT_RO6. 377Eh, Bit 3 = CANSTAT_RO6. 377Eh, Bit 2 = . 377Eh, Bit 1 = . 377Eh, Bit 0 = . 377Eh, Register on page = 605. 377Dh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nName = B3D7. 377Dh, Bit 7 = . 377Dh, Bit 6 = . 377Dh, Bit 5 = . 377Dh, Bit 4 = B3D7. 377Dh, Bit 3 = B3D7. 377Dh, Bit 2 = . 377Dh, Bit 1 = . 377Dh, Bit 0 = . 377Dh, Register on page = 628. 377Ch, Name = B3D6. 377Ch, Bit 7 = . 377Ch, Bit 6 = . 377Ch, Bit 5 = . 377Ch, Bit 4 = B3D6. 377Ch, Bit 3 = B3D6. 377Ch, Bit 2 = . 377Ch, Bit 1 = . 377Ch, Bit 0 = . 377Ch, Register on page = 628. 377Bh, Name = B3D5. 377Bh, Bit 7 = . 377Bh, Bit 6 = . 377Bh, Bit 5 = . 377Bh, Bit 4 = B3D5. 377Bh, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nB3D5. 377Bh, Bit 2 = . 377Bh, Bit 1 = . 377Bh, Bit 0 = . 377Bh, Register on page = 628. 377Ah, Name = B3D4. 377Ah, Bit 7 = . 377Ah, Bit 6 = . 377Ah, Bit 5 = . 377Ah, Bit 4 = B3D4. 377Ah, Bit 3 = B3D4. 377Ah, Bit 2 = . 377Ah, Bit 1 = . 377Ah, Bit 0 = . 377Ah, Register on page = 628. 3779h, Name = B3D3. 3779h, Bit 7 = . 3779h, Bit 6 = . 3779h, Bit 5 = . 3779h, Bit 4 = B3D3. 3779h, Bit 3 = B3D3. 3779h, Bit 2 = . 3779h, Bit 1 = . 3779h, Bit 0 = . 3779h, Register on page = 628.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3778h, Name = B3D2. 3778h, Bit 7 = . 3778h, Bit 6 = . 3778h, Bit 5 = . 3778h, Bit 4 = B3D2. 3778h, Bit 3 = B3D2. 3778h, Bit 2 = . 3778h, Bit 1 = . 3778h, Bit 0 = . 3778h, Register on page = 628. 3777h, Name = B3D1. 3777h, Bit 7 = . 3777h, Bit 6 = . 3777h, Bit 5 = . 3777h, Bit 4 = B3D1. 3777h, Bit 3 = B3D1. 3777h, Bit 2 = . 3777h, Bit 1 = . 3777h, Bit 0 = . 3777h, Register on page = 628. 3776h, Name = B3D0. 3776h, Bit 7 = . 3776h, Bit 6 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3776h, Bit 5 = . 3776h, Bit 4 = B3D0. 3776h, Bit 3 = B3D0. 3776h, Bit 2 = . 3776h, Bit 1 = . 3776h, Bit 0 = . 3776h, Register on page = 628. 3775h, Name = B3DLC. 3775h, Bit 7 = -. 3775h, Bit 6 = RXRTR. 3775h, Bit 5 = RB1. 3775h, Bit 4 = RB0. 3775h, Bit 3 = DLC3. 3775h, Bit 2 = DLC2. 3775h, Bit 1 = DLC1. 3775h, Bit 0 = DLC0. 3775h, Register on page = 629. 3775h, Name = B3DLC. 3775h, Bit 7 = -. 3775h, Bit 6 = TXRTR. 3775h, Bit 5 = -. 3775h, Bit 4 = -. 3775h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3 = DLC3. 3775h, Bit 2 = DLC2. 3775h, Bit 1 = DLC1. 3775h, Bit 0 = DLC0. 3775h, Register on page = 630. 3774h, Name = B3EIDL. 3774h, Bit 7 = EID7. 3774h, Bit 6 = EID6. 3774h, Bit 5 = EID5. 3774h, Bit 4 = EID4. 3774h, Bit 3 = EID3. 3774h, Bit 2 = EID2. 3774h, Bit 1 = EID1. 3774h, Bit 0 = EID0. 3774h, Register on page = 627\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1:\nNot present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3773h, Name = B3EIDH. 3773h, Bit 7 = EID15. 3773h, Bit 6 = EID14. 3773h, Bit 5 = EID13. 3773h, Bit 4 = EID12. 3773h, Bit 3 = EID11. 3773h, Bit 2 = EID10. 3773h, Bit 1 = EID9. 3773h, Bit 0 = EID8. 3773h, Register on page = 627. 3772h, Name = B3SIDL. 3772h, Bit 7 = SID2. 3772h, Bit 6 = SID1. 3772h, Bit 5 = SID0. 3772h, Bit 4 = SRR. 3772h, Bit 3 = EXIDE. 3772h, Bit 2 = -. 3772h, Bit 1 = EID17. 3772h, Bit 0 = EID16. 3772h, Register on page =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n626. 3771h, Name = B3SIDH. 3771h, Bit 7 = SID10. 3771h, Bit 6 = SID9. 3771h, Bit 5 = SID8. 3771h, Bit 4 = SID7. 3771h, Bit 3 = SID6. 3771h, Bit 2 = SID5. 3771h, Bit 1 = SID4. 3771h, Bit 0 = SID3. 3771h, Register on page = 625. 3770h, Name = B3CON. 3770h, Bit 7 = RXFUL. 3770h, Bit 6 = RXM1. 3770h, Bit 5 = RXRTRRO. 3770h, Bit 4 = FILHIT4. 3770h, Bit 3 = FILHIT3. 3770h, Bit 2 = FILHIT2. 3770h, Bit 1 = FILHIT1. 3770h, Bit 0 = FILHIT0. 3770h, Register on page = 623.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3770h, Name = B3CON. 3770h, Bit 7 = TXBIF. 3770h, Bit 6 = TXABT. 3770h, Bit 5 = TXLARB. 3770h, Bit 4 = TXERR. 3770h, Bit 3 = TXREQ. 3770h, Bit 2 = RTREN. 3770h, Bit 1 = TXPRI1. 3770h, Bit 0 = TXPRI0. 3770h, Register on page = 624. 376Fh, Name = . 376Fh, Bit 7 = CANCON_RO7 CANCON_RO7. 376Fh, Bit 6 = CANCON_RO7 CANCON_RO7. 376Fh, Bit 5 = CANCON_RO7 CANCON_RO7. 376Fh, Bit 4 = CANCON_RO7 CANCON_RO7. 376Fh, Bit 3 = CANCON_RO7 CANCON_RO7. 376Fh, Bit 2 = CANCON_RO7",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCANCON_RO7. 376Fh, Bit 1 = CANCON_RO7 CANCON_RO7. 376Fh, Bit 0 = CANCON_RO7 CANCON_RO7. 376Fh, Register on page = 604. , Name = . , Bit 7 = 376Eh CANSTAT_RO7 CANSTAT_RO7. , Bit 6 = 376Eh CANSTAT_RO7 CANSTAT_RO7. , Bit 5 = 376Eh CANSTAT_RO7 CANSTAT_RO7. , Bit 4 = 376Eh CANSTAT_RO7 CANSTAT_RO7. , Bit 3 = 376Eh CANSTAT_RO7 CANSTAT_RO7. , Bit 2 = 376Eh CANSTAT_RO7 CANSTAT_RO7. , Bit 1 = 376Eh CANSTAT_RO7 CANSTAT_RO7. , Bit 0 = 376Eh CANSTAT_RO7 CANSTAT_RO7. , Register on page = 605. 376Dh, Name = B2D7. 376Dh, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nB2D7. 376Dh, Bit 6 = B2D7. 376Dh, Bit 5 = B2D7. 376Dh, Bit 4 = B2D7. 376Dh, Bit 3 = B2D7. 376Dh, Bit 2 = B2D7. 376Dh, Bit 1 = B2D7. 376Dh, Bit 0 = B2D7. 376Dh, Register on page = 628. 376Ch, Name = . 376Ch, Bit 7 = B2D6 B2D6. 376Ch, Bit 6 = B2D6 B2D6. 376Ch, Bit 5 = B2D6 B2D6. 376Ch, Bit 4 = B2D6 B2D6. 376Ch, Bit 3 = B2D6 B2D6. 376Ch, Bit 2 = B2D6 B2D6. 376Ch, Bit 1 = B2D6 B2D6. 376Ch, Bit 0 = B2D6",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nB2D6. 376Ch, Register on page = 628. 376Bh, Name = . 376Bh, Bit 7 = B2D5 B2D5. 376Bh, Bit 6 = B2D5 B2D5. 376Bh, Bit 5 = B2D5 B2D5. 376Bh, Bit 4 = B2D5 B2D5. 376Bh, Bit 3 = B2D5 B2D5. 376Bh, Bit 2 = B2D5 B2D5. 376Bh, Bit 1 = B2D5 B2D5. 376Bh, Bit 0 = B2D5 B2D5. 376Bh, Register on page = 628. 376Ah, Name = B2D4. 376Ah, Bit 7 = B2D4. 376Ah, Bit 6 = B2D4. 376Ah, Bit 5 = B2D4. 376Ah, Bit 4 = B2D4. 376Ah, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nB2D4. 376Ah, Bit 2 = B2D4. 376Ah, Bit 1 = B2D4. 376Ah, Bit 0 = B2D4. 376Ah, Register on page = 628. 3769h, Name = B2D3. 3769h, Bit 7 = B2D3. 3769h, Bit 6 = B2D3. 3769h, Bit 5 = B2D3. 3769h, Bit 4 = B2D3. 3769h, Bit 3 = B2D3. 3769h, Bit 2 = B2D3. 3769h, Bit 1 = B2D3. 3769h, Bit 0 = B2D3. 3769h, Register on page = 628. 3768h, Name = B2D2. 3768h, Bit 7 = B2D2. 3768h, Bit 6 = B2D2. 3768h, Bit 5 = B2D2.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3768h, Bit 4 = B2D2. 3768h, Bit 3 = B2D2. 3768h, Bit 2 = B2D2. 3768h, Bit 1 = B2D2. 3768h, Bit 0 = B2D2. 3768h, Register on page = 628. 3767h, Name = B2D1. 3767h, Bit 7 = B2D1. 3767h, Bit 6 = B2D1. 3767h, Bit 5 = B2D1. 3767h, Bit 4 = B2D1. 3767h, Bit 3 = B2D1. 3767h, Bit 2 = B2D1. 3767h, Bit 1 = B2D1. 3767h, Bit 0 = B2D1. 3767h, Register on page = 628. 3766h, Name = . 3766h, Bit 7 = B2D0 B2D0.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3766h, Bit 6 = B2D0 B2D0. 3766h, Bit 5 = B2D0 B2D0. 3766h, Bit 4 = B2D0 B2D0. 3766h, Bit 3 = B2D0 B2D0. 3766h, Bit 2 = B2D0 B2D0. 3766h, Bit 1 = B2D0 B2D0. 3766h, Bit 0 = B2D0 B2D0. 3766h, Register on page = 628. 3765h, Name = B2DLC. 3765h, Bit 7 = -. 3765h, Bit 6 = RXRTR. 3765h, Bit 5 = RB1. 3765h, Bit 4 = RB0. 3765h, Bit 3 = DLC3. 3765h, Bit 2 = DLC2. 3765h, Bit 1 = DLC1. 3765h, Bit 0 = DLC0. 3765h, Register on page = 629.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3765h, Name = B2DLC. 3765h, Bit 7 = -. 3765h, Bit 6 = TXRTR. 3765h, Bit 5 = -. 3765h, Bit 4 = -. 3765h, Bit 3 = DLC3. 3765h, Bit 2 = DLC2. 3765h, Bit 1 = DLC1. 3765h, Bit 0 = DLC0. 3765h, Register on page = 630. 3764h, Name = B2EIDL. 3764h, Bit 7 = EID7. 3764h, Bit 6 = EID6. 3764h, Bit 5 = EID5. 3764h, Bit 4 = EID4. 3764h, Bit 3 = EID3. 3764h, Bit 2 = EID2. 3764h, Bit 1 = EID1. 3764h, Bit 0 = EID0. 3764h, Register on page = 627. 3763h, Name = B2EIDH. 3763h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n7 = EID15. 3763h, Bit 6 = EID14. 3763h, Bit 5 = EID13. 3763h, Bit 4 = EID12. 3763h, Bit 3 = EID11. 3763h, Bit 2 = EID10. 3763h, Bit 1 = EID9. 3763h, Bit 0 = EID8. 3763h, Register on page = 627. 3762h, Name = B2SIDL. 3762h, Bit 7 = SID2. 3762h, Bit 6 = SID1. 3762h, Bit 5 = SID0. 3762h, Bit 4 = SRR. 3762h, Bit 3 = EXIDE. 3762h, Bit 2 = -. 3762h, Bit 1 = EID17. 3762h, Bit 0 = EID16. 3762h, Register on page = 626. 3761h, Name = B2SIDH.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3761h, Bit 7 = SID10. 3761h, Bit 6 = SID9. 3761h, Bit 5 = SID8. 3761h, Bit 4 = SID7. 3761h, Bit 3 = SID6. 3761h, Bit 2 = SID5. 3761h, Bit 1 = SID4. 3761h, Bit 0 = SID3. 3761h, Register on page = 625. 3760h, Name = B2CON. 3760h, Bit 7 = RXFUL. 3760h, Bit 6 = RXM1. 3760h, Bit 5 = RXRTRRO. 3760h, Bit 4 = FILHIT4. 3760h, Bit 3 = FILHIT3. 3760h, Bit 2 = FILHIT2. 3760h, Bit 1 = FILHIT1. 3760h, Bit 0 = FILHIT0. 3760h, Register on page = 623. 3760h, Name = B2CON. 3760h, Bit 7",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= TXBIF. 3760h, Bit 6 = TXABT. 3760h, Bit 5 = TXLARB. 3760h, Bit 4 = TXERR. 3760h, Bit 3 = TXREQ. 3760h, Bit 2 = RTREN. 3760h, Bit 1 = TXPRI1. 3760h, Bit 0 = TXPRI0. 3760h, Register on page = 624. 375Fh, Name = CANCON_RO8. 375Fh, Bit 7 = CANCON_RO8. 375Fh, Bit 6 = CANCON_RO8. 375Fh, Bit 5 = CANCON_RO8. 375Fh, Bit 4 = CANCON_RO8. 375Fh, Bit 3 = CANCON_RO8. 375Fh, Bit 2 = CANCON_RO8. 375Fh, Bit 1 = CANCON_RO8. 375Fh, Bit 0 = CANCON_RO8. 375Fh, Register on page = 604. 375Eh, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCANSTAT_RO8. 375Eh, Bit 7 = CANSTAT_RO8. 375Eh, Bit 6 = CANSTAT_RO8. 375Eh, Bit 5 = CANSTAT_RO8. 375Eh, Bit 4 = CANSTAT_RO8. 375Eh, Bit 3 = CANSTAT_RO8. 375Eh, Bit 2 = CANSTAT_RO8. 375Eh, Bit 1 = CANSTAT_RO8. 375Eh, Bit 0 = CANSTAT_RO8. 375Eh, Register on page = 605. 375Dh, Name = B1D7. 375Dh, Bit 7 = B1D7. 375Dh, Bit 6 = B1D7. 375Dh, Bit 5 = B1D7. 375Dh, Bit 4 = B1D7. 375Dh, Bit 3 = B1D7. 375Dh, Bit 2 = B1D7. 375Dh, Bit 1 = B1D7. 375Dh, Bit 0 = B1D7. 375Dh, Register on page = 628. 375Ch, Name = B1D6. 375Ch, Bit 7 = B1D6.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n375Ch, Bit 6 = B1D6. 375Ch, Bit 5 = B1D6. 375Ch, Bit 4 = B1D6. 375Ch, Bit 3 = B1D6. 375Ch, Bit 2 = B1D6. 375Ch, Bit 1 = B1D6. 375Ch, Bit 0 = B1D6. 375Ch, Register on page = 628. , Name = B1D5. , Bit 7 = 375Bh B1D5. , Bit 6 = 375Bh B1D5. , Bit 5 = 375Bh B1D5. , Bit 4 = 375Bh B1D5. , Bit 3 = 375Bh B1D5. , Bit 2 = 375Bh B1D5. , Bit 1 = 375Bh B1D5. , Bit 0 = 375Bh B1D5. , Register on page = 628. 375Ah, Name = B1D4. 375Ah, Bit 7 = B1D4. 375Ah, Bit 6 = B1D4. 375Ah, Bit 5 = B1D4. 375Ah, Bit 4 = B1D4. 375Ah, Bit 3 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nB1D4. 375Ah, Bit 2 = B1D4. 375Ah, Bit 1 = B1D4. 375Ah, Bit 0 = B1D4. 375Ah, Register on page = 628. 3759h, Name = B1D3. 3759h, Bit 7 = B1D3. 3759h, Bit 6 = B1D3. 3759h, Bit 5 = B1D3. 3759h, Bit 4 = B1D3. 3759h, Bit 3 = B1D3. 3759h, Bit 2 = B1D3. 3759h, Bit 1 = B1D3. 3759h, Bit 0 = B1D3. 3759h, Register on page = 628. 3758h, Name = B1D2. 3758h, Bit 7 = B1D2. 3758h, Bit 6 = B1D2. 3758h, Bit 5 = B1D2. 3758h, Bit 4 = B1D2. 3758h, Bit 3 = B1D2. 3758h, Bit 2 = B1D2.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3758h, Bit 1 = B1D2. 3758h, Bit 0 = B1D2. 3758h, Register on page = 628. 3757h, Name = . 3757h, Bit 7 = B1D1 B1D1. 3757h, Bit 6 = B1D1 B1D1. 3757h, Bit 5 = B1D1 B1D1. 3757h, Bit 4 = B1D1 B1D1. 3757h, Bit 3 = B1D1 B1D1. 3757h, Bit 2 = B1D1 B1D1. 3757h, Bit 1 = B1D1 B1D1. 3757h, Bit 0 = B1D1 B1D1. 3757h, Register on page = 628. 3756h, Name = B1D0. 3756h, Bit 7 = B1D0. 3756h, Bit 6 = B1D0. 3756h, Bit 5 = B1D0. 3756h, Bit 4 = B1D0. 3756h, Bit 3 = B1D0.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3756h, Bit 2 = B1D0. 3756h, Bit 1 = B1D0. 3756h, Bit 0 = B1D0. 3756h, Register on page = 628. 3755h, Name = B1DLC. 3755h, Bit 7 = -. 3755h, Bit 6 = RXRTR. 3755h, Bit 5 = RB1. 3755h, Bit 4 = RB0. 3755h, Bit 3 = DLC3. 3755h, Bit 2 = DLC2. 3755h, Bit 1 = DLC1. 3755h, Bit 0 = DLC0. 3755h, Register on page = 629. 3755h, Name = B1DLC. 3755h, Bit 7 = -. 3755h, Bit 6 = TXRTR. 3755h, Bit 5 = -. 3755h, Bit 4 = -. 3755h, Bit 3 = DLC3. 3755h, Bit 2 = DLC2. 3755h, Bit 1 = DLC1.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3755h, Bit 0 = DLC0. 3755h, Register on page = 630. 3754h, Name = B1EIDL. 3754h, Bit 7 = EID7. 3754h, Bit 6 = EID6. 3754h, Bit 5 = EID5. 3754h, Bit 4 = EID4. 3754h, Bit 3 = EID3. 3754h, Bit 2 = EID2. 3754h, Bit 1 = EID1. 3754h, Bit 0 = EID0. 3754h, Register on page = 627. 3753h, Name = B1EIDH. 3753h, Bit 7 = EID15. 3753h, Bit 6 = EID14. 3753h, Bit 5 = EID13. 3753h, Bit 4 = EID12. 3753h, Bit 3 = EID11. 3753h, Bit 2 = EID10. 3753h, Bit 1 = EID9. 3753h, Bit 0 = EID8.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3753h, Register on page = 627. 3752h, Name = B1SIDL. 3752h, Bit 7 = SID2. 3752h, Bit 6 = SID1. 3752h, Bit 5 = SID0. 3752h, Bit 4 = SRR. 3752h, Bit 3 = EXIDE. 3752h, Bit 2 = -. 3752h, Bit 1 = EID17. 3752h, Bit 0 = EID16. 3752h, Register on page = 626. 3751h, Name = B1SIDH. 3751h, Bit 7 = SID10. 3751h, Bit 6 = SID9. 3751h, Bit 5 = SID8. 3751h, Bit 4 = SID7. 3751h, Bit 3 = SID6. 3751h, Bit 2 = SID5. 3751h, Bit 1 = SID4. 3751h, Bit 0 = SID3. 3751h, Register on page = 625. 3750h, Name = B1CON. 3750h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRXFUL. 3750h, Bit 6 = RXM1. 3750h, Bit 5 = RXRTRRO. 3750h, Bit 4 = FILHIT4. 3750h, Bit 3 = FILHIT3. 3750h, Bit 2 = FILHIT2. 3750h, Bit 1 = FILHIT1. 3750h, Bit 0 = FILHIT0. 3750h, Register on page = 623. 3750h, Name = B1CON. 3750h, Bit 7 = TXBIF. 3750h, Bit 6 = TXABT. 3750h, Bit 5 = TXLARB. 3750h, Bit 4 = TXERR. 3750h, Bit 3 = TXREQ. 3750h, Bit 2 = RTREN. 3750h, Bit 1 = TXPRI1. 3750h, Bit 0 = TXPRI0. 3750h, Register on page = 624. 374Fh, Name = . 374Fh, Bit 7 = CANCON_RO9",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nCANCON_RO9. 374Fh, Bit 6 = CANCON_RO9 CANCON_RO9. 374Fh, Bit 5 = CANCON_RO9 CANCON_RO9. 374Fh, Bit 4 = CANCON_RO9 CANCON_RO9. 374Fh, Bit 3 = CANCON_RO9 CANCON_RO9. 374Fh, Bit 2 = CANCON_RO9 CANCON_RO9. 374Fh, Bit 1 = CANCON_RO9 CANCON_RO9. 374Fh, Bit 0 = CANCON_RO9 CANCON_RO9. 374Fh, Register on page = 604. 374Eh, Name = . 374Eh, Bit 7 = CANSTAT_RO9 CANSTAT_RO9. 374Eh, Bit 6 = CANSTAT_RO9 CANSTAT_RO9. 374Eh, Bit 5 = CANSTAT_RO9 CANSTAT_RO9. 374Eh, Bit 4 = CANSTAT_RO9 CANSTAT_RO9.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n374Eh, Bit 3 = CANSTAT_RO9 CANSTAT_RO9. 374Eh, Bit 2 = CANSTAT_RO9 CANSTAT_RO9. 374Eh, Bit 1 = CANSTAT_RO9 CANSTAT_RO9. 374Eh, Bit 0 = CANSTAT_RO9 CANSTAT_RO9. 374Eh, Register on page = 605. 374Dh, Name = B0D7. 374Dh, Bit 7 = B0D7. 374Dh, Bit 6 = B0D7. 374Dh, Bit 5 = B0D7. 374Dh, Bit 4 = B0D7. 374Dh, Bit 3 = B0D7. 374Dh, Bit 2 = B0D7. 374Dh, Bit 1 = B0D7. 374Dh, Bit 0 = B0D7. 374Dh, Register on page = 628. 374Ch, Name = B0D6. 374Ch, Bit 7 = B0D6. 374Ch, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nB0D6. 374Ch, Bit 5 = B0D6. 374Ch, Bit 4 = B0D6. 374Ch, Bit 3 = B0D6. 374Ch, Bit 2 = B0D6. 374Ch, Bit 1 = B0D6. 374Ch, Bit 0 = B0D6. 374Ch, Register on page = 628. 374Bh, Name = B0D5. 374Bh, Bit 7 = B0D5. 374Bh, Bit 6 = B0D5. 374Bh, Bit 5 = B0D5. 374Bh, Bit 4 = B0D5. 374Bh, Bit 3 = B0D5. 374Bh, Bit 2 = B0D5. 374Bh, Bit 1 = B0D5. 374Bh, Bit 0 = B0D5. 374Bh, Register on page = 628. 374Ah, Name = B0D4. 374Ah, Bit 7 = B0D4.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n374Ah, Bit 6 = B0D4. 374Ah, Bit 5 = B0D4. 374Ah, Bit 4 = B0D4. 374Ah, Bit 3 = B0D4. 374Ah, Bit 2 = B0D4. 374Ah, Bit 1 = B0D4. 374Ah, Bit 0 = B0D4. 374Ah, Register on page = 628. 3749h, Name = B0D3. 3749h, Bit 7 = B0D3. 3749h, Bit 6 = B0D3. 3749h, Bit 5 = B0D3. 3749h, Bit 4 = B0D3. 3749h, Bit 3 = B0D3. 3749h, Bit 2 = B0D3. 3749h, Bit 1 = B0D3. 3749h, Bit 0 = B0D3. 3749h, Register on page = 628. 3748h, Name = B0D2. 3748h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nB0D2. 3748h, Bit 6 = B0D2. 3748h, Bit 5 = B0D2. 3748h, Bit 4 = B0D2. 3748h, Bit 3 = B0D2. 3748h, Bit 2 = B0D2. 3748h, Bit 1 = B0D2. 3748h, Bit 0 = B0D2. 3748h, Register on page = 628. 3747h, Name = B0D1. 3747h, Bit 7 = B0D1. 3747h, Bit 6 = B0D1. 3747h, Bit 5 = B0D1. 3747h, Bit 4 = B0D1. 3747h, Bit 3 = B0D1. 3747h, Bit 2 = B0D1. 3747h, Bit 1 = B0D1. 3747h, Bit 0 = B0D1. 3747h, Register on page = 628\nLegend:",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1:\nNot present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3746h, Name = . 3746h, Bit 7 = B0D0. 3746h, Bit 6 = B0D0. 3746h, Bit 5 = B0D0. 3746h, Bit 4 = B0D0. 3746h, Bit 3 = B0D0. 3746h, Bit 2 = B0D0. 3746h, Bit 1 = B0D0. 3746h, Bit 0 = B0D0. 3746h, Register on page = 628. 3745h, Name = B0DLC. 3745h, Bit 7 = -. 3745h, Bit 6 = RXRTR. 3745h, Bit 5 = RB1. 3745h, Bit 4 = RB0. 3745h, Bit 3 = DLC3. 3745h, Bit 2 = DLC2. 3745h, Bit 1 = DLC1. 3745h, Bit 0 = DLC0. 3745h, Register on page = 629. 3745h, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nB0DLC. 3745h, Bit 7 = -. 3745h, Bit 6 = TXRTR. 3745h, Bit 5 = -. 3745h, Bit 4 = -. 3745h, Bit 3 = DLC3. 3745h, Bit 2 = DLC2. 3745h, Bit 1 = DLC1. 3745h, Bit 0 = DLC0. 3745h, Register on page = 630. 3744h, Name = B0EIDL. 3744h, Bit 7 = EID7. 3744h, Bit 6 = EID6. 3744h, Bit 5 = EID5. 3744h, Bit 4 = EID4. 3744h, Bit 3 = EID3. 3744h, Bit 2 = EID2. 3744h, Bit 1 = EID1. 3744h, Bit 0 = EID0. 3744h, Register on page = 627. 3743h, Name = B0EIDH. 3743h, Bit 7 = EID15.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3743h, Bit 6 = EID14. 3743h, Bit 5 = EID13. 3743h, Bit 4 = EID12. 3743h, Bit 3 = EID11. 3743h, Bit 2 = EID10. 3743h, Bit 1 = EID9. 3743h, Bit 0 = EID8. 3743h, Register on page = 627. 3742h, Name = B0SIDL. 3742h, Bit 7 = SID2. 3742h, Bit 6 = SID1. 3742h, Bit 5 = SID0. 3742h, Bit 4 = SRR. 3742h, Bit 3 = EXIDE. 3742h, Bit 2 = -. 3742h, Bit 1 = EID17. 3742h, Bit 0 = EID16. 3742h, Register on page = 626. 3741h, Name = B0SIDH. 3741h, Bit 7 = SID10. 3741h, Bit 6 = SID9. 3741h, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSID8. 3741h, Bit 4 = SID7. 3741h, Bit 3 = SID6. 3741h, Bit 2 = SID5. 3741h, Bit 1 = SID4. 3741h, Bit 0 = SID3. 3741h, Register on page = 625. 3740h, Name = B0CON. 3740h, Bit 7 = RXFUL. 3740h, Bit 6 = RXM1. 3740h, Bit 5 = RXRTRRO. 3740h, Bit 4 = FILHIT4. 3740h, Bit 3 = FILHIT3. 3740h, Bit 2 = FILHIT2. 3740h, Bit 1 = FILHIT1. 3740h, Bit 0 = FILHIT0. 3740h, Register on page = 623. 3740h, Name = B0CON. 3740h, Bit 7 = TXBIF. 3740h, Bit 6 = TXABT. 3740h, Bit 5 = TXLARB. 3740h, Bit 4 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nTXERR. 3740h, Bit 3 = TXREQ. 3740h, Bit 2 = RTREN. 3740h, Bit 1 = TXPRI1. 3740h, Bit 0 = TXPRI0. 3740h, Register on page = 624. 373Fh, Name = TXBIE. 373Fh, Bit 7 = -. 373Fh, Bit 6 = -. 373Fh, Bit 5 = -. 373Fh, Bit 4 = TXB2IE. 373Fh, Bit 3 = TXB1IE. 373Fh, Bit 2 = TXB0IE. 373Fh, Bit 1 = -. 373Fh, Bit 0 = -. 373Fh, Register on page = 648. 373Eh, Name = BIE0. 373Eh, Bit 7 = B5IE. 373Eh, Bit 6 = B4IE. 373Eh, Bit 5 = B3IE. 373Eh, Bit 4 = B2IE. 373Eh, Bit 3",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= B1IE. 373Eh, Bit 2 = B0IE. 373Eh, Bit 1 = RXB1IE. 373Eh, Bit 0 = RXB0IE. 373Eh, Register on page = 649. 373Dh, Name = BSEL0. 373Dh, Bit 7 = B5TXEN. 373Dh, Bit 6 = B4TXEN. 373Dh, Bit 5 = B3TXEN. 373Dh, Bit 4 = B2TXEN. 373Dh, Bit 3 = B1TXEN. 373Dh, Bit 2 = B0TXEN. 373Dh, Bit 1 = -. 373Dh, Bit 0 = -. 373Dh, Register on page = 630. 373Ch, Name = MSEL3. 373Ch, Bit 7 = FIL15_1. 373Ch, Bit 6 = FIL15_0. 373Ch, Bit 5 = FIL14_1. 373Ch, Bit 4 = FIL14_0.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n373Ch, Bit 3 = FIL13_1. 373Ch, Bit 2 = FIL13_0. 373Ch, Bit 1 = FIL12_1. 373Ch, Bit 0 = FIL12_0. 373Ch, Register on page = 640. 373Bh, Name = MSEL2. 373Bh, Bit 7 = FIL11_1. 373Bh, Bit 6 = FIL11_0. 373Bh, Bit 5 = FIL10_1. 373Bh, Bit 4 = FIL10_0. 373Bh, Bit 3 = FIL9_1. 373Bh, Bit 2 = FIL9_0. 373Bh, Bit 1 = FIL8_1. 373Bh, Bit 0 = FIL8_0. 373Bh, Register on page = 639. 373Ah, Name = MSEL1. 373Ah, Bit 7 = FIL7_1. 373Ah, Bit 6 = FIL7_0. 373Ah, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nFIL6_1. 373Ah, Bit 4 = FIL6_0. 373Ah, Bit 3 = FIL5_1. 373Ah, Bit 2 = FIL5_0. 373Ah, Bit 1 = FIL4_1. 373Ah, Bit 0 = FIL4_0. 373Ah, Register on page = 638. 3739h, Name = MSEL0. 3739h, Bit 7 = FIL3_1. 3739h, Bit 6 = FIL3_0. 3739h, Bit 5 = FIL2_1. 3739h, Bit 4 = FIL2_0. 3739h, Bit 3 = FIL1_1. 3739h, Bit 2 = FIL1_0. 3739h, Bit 1 = FIL0_1. 3739h, Bit 0 = FIL0_0. 3739h, Register on page = 640. 3738h, Name = RXFBCON7. 3738h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nF15BP_3. 3738h, Bit 6 = F15BP_2. 3738h, Bit 5 = F15BP_1. 3738h, Bit 4 = F15BP_0. 3738h, Bit 3 = F14BP_3. 3738h, Bit 2 = F14BP_2. 3738h, Bit 1 = F14BP_1. 3738h, Bit 0 = F14BP_0. 3738h, Register on page = 636. 3737h, Name = RXFBCON6. 3737h, Bit 7 = F13BP_3. 3737h, Bit 6 = F13BP_2. 3737h, Bit 5 = F13BP_1. 3737h, Bit 4 = F13BP_0. 3737h, Bit 3 = F12BP_3. 3737h, Bit 2 = F12BP_2. 3737h, Bit 1 = F12BP_1. 3737h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n0 = F12BP_0. 3737h, Register on page = 636. 3736h, Name = RXFBCON5 RXFBCON4. 3736h, Bit 7 = F11BP_3 F9BP_3. 3736h, Bit 6 = F11BP_2 F9BP_2. 3736h, Bit 5 = F11BP_1 F9BP_1. 3736h, Bit 4 = F11BP_0 F9BP_0. 3736h, Bit 3 = F10BP_3 F8BP_3. 3736h, Bit 2 = F10BP_2 F8BP_2. 3736h, Bit 1 = F10BP_1 F8BP_1. 3736h, Bit 0 = F10BP_0 F8BP_0. 3736h, Register on page = 636 636. 3735h, Name = RXFBCON3. 3735h, Bit 7 = .",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3735h, Bit 6 = . 3735h, Bit 5 = . 3735h, Bit 4 = . 3735h, Bit 3 = . 3735h, Bit 2 = . 3735h, Bit 1 = . 3735h, Bit 0 = . 3735h, Register on page = . 3734h, Name = . 3734h, Bit 7 = F7BP_3. 3734h, Bit 6 = F7BP_2. 3734h, Bit 5 = F7BP_1. 3734h, Bit 4 = F7BP_0. 3734h, Bit 3 = F6BP_3. 3734h, Bit 2 = F6BP_2. 3734h, Bit 1 = F6BP_1. 3734h, Bit 0 = F6BP_0. 3734h, Register on page = 636. 3733h, Name = RXFBCON2. 3733h, Bit 7 = F5BP_3. 3733h, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nF5BP_2. 3733h, Bit 5 = F5BP_1. 3733h, Bit 4 = F5BP_0. 3733h, Bit 3 = F4BP_3. 3733h, Bit 2 = F4BP_2. 3733h, Bit 1 = F4BP_1. 3733h, Bit 0 = F4BP_0. 3733h, Register on page = 636. 3732h, Name = RXFBCON1. 3732h, Bit 7 = F3BP_3. 3732h, Bit 6 = F3BP_2. 3732h, Bit 5 = F3BP_1. 3732h, Bit 4 = F3BP_0. 3732h, Bit 3 = F2BP_3. 3732h, Bit 2 = F2BP_2. 3732h, Bit 1 = F2BP_1. 3732h, Bit 0 = F2BP_0. 3732h, Register",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\non page = 636. 3731h, Name = RXFBCON0. 3731h, Bit 7 = F1BP_3. 3731h, Bit 6 = F1BP_2. 3731h, Bit 5 = F1BP_1. 3731h, Bit 4 = F1BP_0. 3731h, Bit 3 = F0BP_3. 3731h, Bit 2 = F0BP_2. 3731h, Bit 1 = F0BP_1. 3731h, Bit 0 = F0BP_0. 3731h, Register on page = 636. 3730h, Name = SDFLC. 3730h, Bit 7 = -. 3730h, Bit 6 = -. 3730h, Bit 5 = -. 3730h, Bit 4 = FLC4. 3730h, Bit 3 = FLC3. 3730h, Bit 2 = FLC2. 3730h, Bit 1 = FLC1. 3730h, Bit 0 = FLC0.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3730h, Register on page = 635. 372Fh, Name = RXF15EIDL. 372Fh, Bit 7 = EID7. 372Fh, Bit 6 = EID6. 372Fh, Bit 5 = EID5. 372Fh, Bit 4 = EID4. 372Fh, Bit 3 = EID3. 372Fh, Bit 2 = EID2. 372Fh, Bit 1 = EID1. 372Fh, Bit 0 = EID0. 372Fh, Register on page = 632. 372Eh, Name = RXF15EIDH. 372Eh, Bit 7 = EID15. 372Eh, Bit 6 = EID14. 372Eh, Bit 5 = EID13. 372Eh, Bit 4 = EID12. 372Eh, Bit 3 = EID11. 372Eh, Bit 2 = EID10. 372Eh, Bit 1 = EID9. 372Eh, Bit 0 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nEID8. 372Eh, Register on page = 632. 372Dh, Name = RXF15SIDL. 372Dh, Bit 7 = SID2. 372Dh, Bit 6 = SID1. 372Dh, Bit 5 = SID0. 372Dh, Bit 4 = -. 372Dh, Bit 3 = EXIDEN. 372Dh, Bit 2 = -. 372Dh, Bit 1 = EID17. 372Dh, Bit 0 = EID16. 372Dh, Register on page = 631. 372Ch, Name = RXF15SIDH. 372Ch, Bit 7 = SID10. 372Ch, Bit 6 = SID9. 372Ch, Bit 5 = SID8. 372Ch, Bit 4 = SID7. 372Ch, Bit 3 = SID6. 372Ch, Bit 2 = SID5. 372Ch, Bit 1 = SID4. 372Ch, Bit 0 = SID3. 372Ch, Register on page = 631. 372Bh, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRXF14EIDL. 372Bh, Bit 7 = EID7. 372Bh, Bit 6 = EID6. 372Bh, Bit 5 = EID5. 372Bh, Bit 4 = EID4. 372Bh, Bit 3 = EID3. 372Bh, Bit 2 = EID2. 372Bh, Bit 1 = EID1. 372Bh, Bit 0 = EID0. 372Bh, Register on page = 632. 372Ah, Name = RXF14EIDH. 372Ah, Bit 7 = EID15. 372Ah, Bit 6 = EID14. 372Ah, Bit 5 = EID13. 372Ah, Bit 4 = EID12. 372Ah, Bit 3 = EID11. 372Ah, Bit 2 = EID10. 372Ah, Bit 1 = EID9. 372Ah, Bit 0 = EID8. 372Ah, Register on page = 632. 3729h, Name = RXF14SIDL.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3729h, Bit 7 = SID2. 3729h, Bit 6 = SID1. 3729h, Bit 5 = SID0. 3729h, Bit 4 = -. 3729h, Bit 3 = EXIDEN. 3729h, Bit 2 = -. 3729h, Bit 1 = EID17. 3729h, Bit 0 = EID16. 3729h, Register on page = 631. 3728h, Name = RXF14SIDH. 3728h, Bit 7 = SID10. 3728h, Bit 6 = SID9. 3728h, Bit 5 = SID8. 3728h, Bit 4 = SID7. 3728h, Bit 3 = SID6. 3728h, Bit 2 = SID5. 3728h, Bit 1 = SID4. 3728h, Bit 0 = SID3. 3728h, Register on page = 631. 3727h, Name = RXF13EIDL. 3727h, Bit 7 = EID7. 3727h, Bit 6 = EID6.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3727h, Bit 5 = EID5. 3727h, Bit 4 = EID4. 3727h, Bit 3 = EID3. 3727h, Bit 2 = EID2. 3727h, Bit 1 = EID1. 3727h, Bit 0 = EID0. 3727h, Register on page = 632. 3726h, Name = RXF13EIDH. 3726h, Bit 7 = EID15. 3726h, Bit 6 = EID14. 3726h, Bit 5 = EID13. 3726h, Bit 4 = EID12. 3726h, Bit 3 = EID11. 3726h, Bit 2 = EID10. 3726h, Bit 1 = EID9. 3726h, Bit 0 = EID8. 3726h, Register on page = 632. 3725h, Name = RXF13SIDL. 3725h, Bit 7 = SID2. 3725h, Bit 6 = SID1. 3725h, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSID0. 3725h, Bit 4 = -. 3725h, Bit 3 = EXIDEN. 3725h, Bit 2 = -. 3725h, Bit 1 = EID17. 3725h, Bit 0 = EID16. 3725h, Register on page = 631. 3724h, Name = RXF13SIDH. 3724h, Bit 7 = SID10. 3724h, Bit 6 = SID9. 3724h, Bit 5 = SID8. 3724h, Bit 4 = SID7. 3724h, Bit 3 = SID6. 3724h, Bit 2 = SID5. 3724h, Bit 1 = SID4. 3724h, Bit 0 = SID3. 3724h, Register on page = 631. 3723h, Name = RXF12EIDL. 3723h, Bit 7 = EID7. 3723h, Bit 6 = EID6. 3723h, Bit 5 = EID5. 3723h, Bit 4 = EID4. 3723h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3 = EID3. 3723h, Bit 2 = EID2. 3723h, Bit 1 = EID1. 3723h, Bit 0 = EID0. 3723h, Register on page = 632. 3722h, Name = RXF12EIDH. 3722h, Bit 7 = EID15. 3722h, Bit 6 = EID14. 3722h, Bit 5 = EID13. 3722h, Bit 4 = EID12. 3722h, Bit 3 = EID11. 3722h, Bit 2 = EID10. 3722h, Bit 1 = EID9. 3722h, Bit 0 = EID8. 3722h, Register on page = 632. 3721h, Name = RXF12SIDL. 3721h, Bit 7 = SID2. 3721h, Bit 6 = SID1. 3721h, Bit 5 = SID0. 3721h, Bit 4 = -. 3721h, Bit 3 = EXIDEN. 3721h, Bit 2",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n= -. 3721h, Bit 1 = EID17. 3721h, Bit 0 = EID16. 3721h, Register on page = 631. 3720h, Name = RXF12SIDH. 3720h, Bit 7 = SID10. 3720h, Bit 6 = SID9. 3720h, Bit 5 = SID8. 3720h, Bit 4 = SID7. 3720h, Bit 3 = SID6. 3720h, Bit 2 = SID5. 3720h, Bit 1 = SID4. 3720h, Bit 0 = SID3. 3720h, Register on page = 631. 371Fh, Name = RXF11EIDL. 371Fh, Bit 7 = EID7. 371Fh, Bit 6 = EID6. 371Fh, Bit 5 = EID5. 371Fh, Bit 4 = EID4. 371Fh, Bit 3 = EID3. 371Fh, Bit 2 = EID2. 371Fh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 1 = EID1. 371Fh, Bit 0 = EID0. 371Fh, Register on page = 632. 371Eh, Name = RXF11EIDH. 371Eh, Bit 7 = EID15. 371Eh, Bit 6 = EID14. 371Eh, Bit 5 = EID13. 371Eh, Bit 4 = EID12. 371Eh, Bit 3 = EID11. 371Eh, Bit 2 = EID10. 371Eh, Bit 1 = EID9. 371Eh, Bit 0 = EID8. 371Eh, Register on page = 632. 371Dh 371Ch, Name = RXF11SIDL RXF11SIDH. 371Dh 371Ch, Bit 7 = SID2 SID10. 371Dh 371Ch, Bit 6 = SID1 SID9. 371Dh 371Ch, Bit 5 = SID0 SID8. 371Dh 371Ch, Bit 4 = - SID7. 371Dh 371Ch,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 3 = EXIDEN SID6. 371Dh 371Ch, Bit 2 = - SID5. 371Dh 371Ch, Bit 1 = EID17 SID4. 371Dh 371Ch, Bit 0 = EID16 SID3. 371Dh 371Ch, Register on page = 631 631. 371Bh, Name = RXF10EIDL. 371Bh, Bit 7 = EID7. 371Bh, Bit 6 = EID6. 371Bh, Bit 5 = EID5. 371Bh, Bit 4 = EID4. 371Bh, Bit 3 = EID3. 371Bh, Bit 2 = EID2. 371Bh, Bit 1 = EID1. 371Bh, Bit 0 = EID0. 371Bh, Register on page = 632. 371Ah 3719h, Name = RXF10EIDH RXF10SIDL. 371Ah 3719h, Bit 7 = EID15 SID2. 371Ah 3719h, Bit 6 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nEID14 SID1. 371Ah 3719h, Bit 5 = EID13 SID0. 371Ah 3719h, Bit 4 = EID12 -. 371Ah 3719h, Bit 3 = EID11 EXIDEN. 371Ah 3719h, Bit 2 = EID10 -. 371Ah 3719h, Bit 1 = EID9 EID17. 371Ah 3719h, Bit 0 = EID8 EID16. 371Ah 3719h, Register on page = 632 631. 3718h, Name = RXF10SIDH. 3718h, Bit 7 = SID10. 3718h, Bit 6 = SID9. 3718h, Bit 5 = SID8. 3718h, Bit 4 = SID7. 3718h, Bit 3 = SID6. 3718h, Bit 2 = SID5. 3718h, Bit 1 = SID4. 3718h, Bit 0 = SID3. 3718h, Register on page = 631. 3717h, Name =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nRXF9EIDL. 3717h, Bit 7 = EID7. 3717h, Bit 6 = EID6. 3717h, Bit 5 = EID5. 3717h, Bit 4 = EID4. 3717h, Bit 3 = EID3. 3717h, Bit 2 = EID2. 3717h, Bit 1 = EID1. 3717h, Bit 0 = EID0. 3717h, Register on page = 632\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: Not present in LF devices.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3716h, Name = RXF9EIDH. 3716h, Bit 7 = EID15. 3716h, Bit 6 = EID14. 3716h, Bit 5 = EID13. 3716h, Bit 4 = EID12. 3716h, Bit 3 = EID11. 3716h, Bit 2 = EID10. 3716h, Bit 1 = EID9. 3716h, Bit 0 = EID8. 3716h, Register on page = 632. 3715h, Name = RXF9SIDL. 3715h, Bit 7 = SID2. 3715h, Bit 6 = SID1. 3715h, Bit 5 = SID0. 3715h, Bit 4 = -. 3715h, Bit 3 = EXIDEN. 3715h, Bit 2 = -. 3715h, Bit 1 = EID17. 3715h, Bit 0 = EID16. 3715h, Register on page = 631. 3714h, Name = RXF9SIDH.",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n3714h, Bit 7 = SID10. 3714h, Bit 6 = SID9. 3714h, Bit 5 = SID8. 3714h, Bit 4 = SID7. 3714h, Bit 3 = SID6. 3714h, Bit 2 = SID5. 3714h, Bit 1 = SID4. 3714h, Bit 0 = SID3. 3714h, Register on page = 631. 3713h, Name = RXF8EIDL. 3713h, Bit 7 = EID7. 3713h, Bit 6 = EID6. 3713h, Bit 5 = EID5. 3713h, Bit 4 = EID4. 3713h, Bit 3 = EID3. 3713h, Bit 2 = EID2. 3713h, Bit 1 = EID1. 3713h, Bit 0 = EID0. 3713h, Register on page = 632. 3712h, Name = RXF8EIDH. 3712h, Bit 7 = EID15. 3712h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 6 = EID14. 3712h, Bit 5 = EID13. 3712h, Bit 4 = EID12. 3712h, Bit 3 = EID11. 3712h, Bit 2 = EID10. 3712h, Bit 1 = EID9. 3712h, Bit 0 = EID8. 3712h, Register on page = 632. 3711h, Name = RXF8SIDL. 3711h, Bit 7 = SID2. 3711h, Bit 6 = SID1. 3711h, Bit 5 = SID0. 3711h, Bit 4 = -. 3711h, Bit 3 = EXIDEN. 3711h, Bit 2 = -. 3711h, Bit 1 = EID17. 3711h, Bit 0 = EID16. 3711h, Register on page = 631. 3710h, Name = RXF8SIDH. 3710h, Bit 7 = SID10. 3710h, Bit 6 = SID9. 3710h, Bit 5 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSID8. 3710h, Bit 4 = SID7. 3710h, Bit 3 = SID6. 3710h, Bit 2 = SID5. 3710h, Bit 1 = SID4. 3710h, Bit 0 = SID3. 3710h, Register on page = 631. 370Fh, Name = RXF7EIDL. 370Fh, Bit 7 = EID7. 370Fh, Bit 6 = EID6. 370Fh, Bit 5 = EID5. 370Fh, Bit 4 = EID4. 370Fh, Bit 3 = EID3. 370Fh, Bit 2 = EID2. 370Fh, Bit 1 = EID1. 370Fh, Bit 0 = EID0. 370Fh, Register on page = 632. 370Eh, Name = RXF7EIDH. 370Eh, Bit 7 = EID15. 370Eh, Bit 6 = EID14. 370Eh, Bit 5 = EID13. 370Eh, Bit 4 = EID12. 370Eh,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 3 = EID11. 370Eh, Bit 2 = EID10. 370Eh, Bit 1 = EID9. 370Eh, Bit 0 = EID8. 370Eh, Register on page = 632. 370Dh, Name = RXF7SIDL. 370Dh, Bit 7 = SID2. 370Dh, Bit 6 = SID1. 370Dh, Bit 5 = SID0. 370Dh, Bit 4 = -. 370Dh, Bit 3 = EXIDEN. 370Dh, Bit 2 = -. 370Dh, Bit 1 = EID17. 370Dh, Bit 0 = EID16. 370Dh, Register on page = 631. 370Ch, Name = RXF7SIDH. 370Ch, Bit 7 = SID10. 370Ch, Bit 6 = SID9. 370Ch, Bit 5 = SID8. 370Ch, Bit 4 = SID7. 370Ch, Bit 3 = SID6. 370Ch, Bit 2 = SID5. 370Ch, Bit 1 = SID4. 370Ch, Bit 0 = SID3. 370Ch, Register on",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\npage = 631. 370Bh, Name = RXF6EIDL. 370Bh, Bit 7 = EID7. 370Bh, Bit 6 = EID6. 370Bh, Bit 5 = EID5. 370Bh, Bit 4 = EID4. 370Bh, Bit 3 = EID3. 370Bh, Bit 2 = EID2. 370Bh, Bit 1 = EID1. 370Bh, Bit 0 = EID0. 370Bh, Register on page = 632. 370Ah, Name = RXF6EIDH. 370Ah, Bit 7 = EID15. 370Ah, Bit 6 = EID14. 370Ah, Bit 5 = EID13. 370Ah, Bit 4 = EID12. 370Ah, Bit 3 = EID11. 370Ah, Bit 2 = EID10. 370Ah, Bit 1 = EID9. 370Ah, Bit 0 = EID8. 370Ah, Register on page = 632. 3709h, Name = RXF6SIDL. 3709h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSID2. 3709h, Bit 6 = SID1. 3709h, Bit 5 = SID0. 3709h, Bit 4 = -. 3709h, Bit 3 = EXIDEN. 3709h, Bit 2 = -. 3709h, Bit 1 = EID17. 3709h, Bit 0 = EID16. 3709h, Register on page = 631. 3708h, Name = RXF6SIDH. 3708h, Bit 7 = SID10. 3708h, Bit 6 = SID9. 3708h, Bit 5 = SID8. 3708h, Bit 4 = SID7. 3708h, Bit 3 = SID6. 3708h, Bit 2 = SID5. 3708h, Bit 1 = SID4. 3708h, Bit 0 = SID3. 3708h, Register on page = 631. 3707h, Name = RXFCON1. 3707h, Bit 7 = RXF15EN. 3707h, Bit 6 = RXF14EN. 3707h,",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nBit 5 = RXF13EN. 3707h, Bit 4 = RXF12EN. 3707h, Bit 3 = RXF11EN. 3707h, Bit 2 = RXF10EN. 3707h, Bit 1 = RXF9EN. 3707h, Bit 0 = RXF8EN. 3707h, Register on page = 634. 3706h, Name = RXFCON0. 3706h, Bit 7 = RXF7EN. 3706h, Bit 6 = RXF6EN. 3706h, Bit 5 = RXF5EN. 3706h, Bit 4 = RXF4EN. 3706h, Bit 3 = RXF3EN. 3706h, Bit 2 = RXF2EN. 3706h, Bit 1 = RXF1EN. 3706h, Bit 0 = RXF0EN. 3706h, Register on page = 634. 3705h, Name = BRGCON3. 3705h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nWAKDIS. 3705h, Bit 6 = WAKFIL. 3705h, Bit 5 = -. 3705h, Bit 4 = -. 3705h, Bit 3 = -. 3705h, Bit 2 = SEG2PH2. 3705h, Bit 1 = SEG2PH1. 3705h, Bit 0 = SEG2PH0. 3705h, Register on page = 643. 3704h, Name = BRGCON2. 3704h, Bit 7 = SEG2PHTS. 3704h, Bit 6 = SAM. 3704h, Bit 5 = SEG1PH2. 3704h, Bit 4 = SEG1PH1. 3704h, Bit 3 = SEG1PH0. 3704h, Bit 2 = PRSEG2. 3704h, Bit 1 = PRSEG1. 3704h, Bit 0 = PRSEG0. 3704h, Register on page = 642. 3703h, Name = BRGCON1. 3703h, Bit 7 =",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\nSJW1. 3703h, Bit 6 = SJW0. 3703h, Bit 5 = BRP5. 3703h, Bit 4 = BRP4. 3703h, Bit 3 = BRP3. 3703h, Bit 2 = BRP2. 3703h, Bit 1 = BRP1. 3703h, Bit 0 = BRP0. 3703h, Register on page = 641. 3702h, Name = TXERRCNT. 3702h, Bit 7 = TEC7. 3702h, Bit 6 = TEC6. 3702h, Bit 5 = TEC5. 3702h, Bit 4 = TEC4. 3702h, Bit 3 = TEC3. 3702h, Bit 2 = TEC2. 3702h, Bit 1 = TEC1. 3702h, Bit 0 = TEC0. 3702h, Register on page = 613. 3701h, Name = RXERRCNT. 3701h, Bit 7 = REC7. 3701h, Bit",
    "TABLE 43-1: REGISTER FILE SUMMARY FOR PIC18(L)F25/26K83 DEVICES (CONTINUED)\n6 = REC6. 3701h, Bit 5 = REC5. 3701h, Bit 4 = REC4. 3701h, Bit 3 = REC3. 3701h, Bit 2 = REC2. 3701h, Bit 1 = REC1. 3701h, Bit 0 = REC0. 3701h, Register on page = 622. 3700h, Name = CIOCON. 3700h, Bit 7 = TX1SRC. 3700h, Bit 6 = -. 3700h, Bit 5 = -. 3700h, Bit 4 = -. 3700h, Bit 3 = -. 3700h, Bit 2 = -. 3700h, Bit 1 = -. 3700h, Bit 0 = CLKSEL. 3700h, Register on page = 644\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: Not present in LF devices.",
    "44.0 DEVELOPMENT SUPPORT\nThe PIC \u00ae   microcontrollers  (MCU)  and  dsPIC \u00ae   digital signal controllers (DSC) are supported with a full range of software and hardware development tools:\n\u00b7 Integrated Development Environment\n-MPLAB \u00ae  X IDE Software\n\u00b7 Compilers/Assemblers/Linkers\n-MPLAB XC Compiler\n-MPASM TM  Assembler\n-MPLINK TM  Object Linker/ MPLIB TM  Object Librarian\n-MPLAB Assembler/Linker/Librarian for Various Device Families\n\u00b7 Simulators\n-MPLAB X SIM Software Simulator\n\u00b7 Emulators\n-MPLAB REAL ICE\u2122 In-Circuit Emulator\n\u00b7 In-Circuit Debuggers/Programmers\n-MPLAB ICD 3\n-PICkit\u2122 3\n\u00b7 Device Programmers\n-MPLAB PM3 Device Programmer\n\u00b7 Low-Cost Demonstration/Development Boards, Evaluation Kits and Starter Kits\n\u00b7 Third-party development tools",
    "44.1 MPLAB X Integrated Development Environment Software\nThe MPLAB X IDE is a single, unified graphical user interface  for  Microchip  and  third-party  software,  and hardware  development  tool  that  runs  on  Windows \u00ae , Linux and Mac OS \u00ae  X. Based on the NetBeans IDE, MPLAB X IDE is an entirely new IDE with a host of free software components and plug-ins for highperformance application development and debugging. Moving  between  tools  and  upgrading  from  software simulators  to  hardware  debugging  and  programming tools is simple with the seamless user interface.\nWith complete project management, visual call graphs, a configurable watch window and a feature-rich editor that  includes  code  completion  and  context  menus, MPLAB X IDE is flexible and friendly enough for new users.  With  the  ability  to  support  multiple  tools  on multiple projects with simultaneous debugging, MPLAB X  IDE  is  also  suitable  for  the  needs  of  experienced users.",
    "Feature-Rich Editor:\n\u00b7 Color syntax highlighting\n\u00b7 Smart code completion makes suggestions and provides hints as you type\n\u00b7 Automatic code formatting based on user-defined rules\n\u00b7 Live parsing\nUser-Friendly, Customizable Interface:\n\u00b7 Fully customizable interface: toolbars, toolbar buttons, windows, window placement, etc.\n\u00b7 Call graph window\nProject-Based Workspaces:\n\u00b7 Multiple projects\n\u00b7 Multiple tools\n\u00b7 Multiple configurations\n\u00b7 Simultaneous debugging sessions\nFile History and Bug Tracking:\n\u00b7 Local file history feature\n\u00b7 Built-in support for Bugzilla issue tracker",
    "44.2 MPLAB XC Compilers\nThe  MPLAB  XC  Compilers  are  complete  ANSI  C compilers for all of Microchip's 8, 16, and 32-bit MCU and DSC devices. These compilers provide powerful integration capabilities, superior code optimization and ease of use. MPLAB XC Compilers run on Windows, Linux or MAC OS X.\nFor easy source level debugging, the compilers provide debug information that is optimized to the  MPLAB X IDE.\nThe  free  MPLAB  XC  Compiler  editions  support  all devices  and  commands,  with  no  time  or  memory restrictions,  and  offer  sufficient  code  optimization  for most applications.\nMPLAB XC Compilers include an assembler, linker and utilities.  The  assembler  generates  relocatable  object files that can then be archived or linked with other relo -catable object files and archives to create an execut -able file. MPLAB XC Compiler uses the assembler to produce its object file. Notable features of the assem -bler include:\n\u00b7 Support for the entire device instruction set\n\u00b7 Support for fixed-point and floating-point data\n\u00b7 Command-line interface\n\u00b7 Rich directive set\n\u00b7 Flexible macro language\n\u00b7 MPLAB X IDE compatibility",
    "44.3 MPASM Assembler\nThe  MPASM Assembler  is  a  full-featured,  universal macro assembler for PIC10/12/16/18 MCUs.\nThe MPASM Assembler generates relocatable object files for the MPLINK Object Linker, Intel \u00ae  standard HEX files,  MAP  files  to  detail  memory  usage  and  symbol reference, absolute LST files that contain source lines and  generated  machine  code,  and  COFF  files  for debugging.\nThe MPASM Assembler features include:\n\u00b7 Integration into MPLAB X IDE projects\n\u00b7 User-defined macros to streamline assembly code\n\u00b7 Conditional assembly for multipurpose source files\n\u00b7 Directives that allow complete control over the assembly process",
    "44.4 MPLINK Object Linker/ MPLIB Object Librarian\nThe  MPLINK  Object  Linker  combines  relocatable objects created by the MPASM Assembler. It can link relocatable  objects  from  precompiled  libraries,  using directives from a linker script.\nThe MPLIB Object Librarian manages the creation and modification of library files of precompiled code. When a routine from a library is called from a source file, only the modules that contain that routine will be linked in with  the  application. This  allows  large  libraries  to  be used efficiently in many different applications.\nThe object linker/library features include:\n\u00b7 Efficient linking of single libraries instead of many smaller files\n\u00b7 Enhanced code maintainability by grouping related modules together\n\u00b7 Flexible creation of libraries with easy module listing, replacement, deletion and extraction",
    "44.5 MPLAB Assembler, Linker and Librarian for Various Device Families\nMPLAB  Assembler produces relocatable machine code  from  symbolic  assembly  language  for  PIC24, PIC32 and dsPIC DSC devices. MPLAB XC Compiler uses  the  assembler  to  produce  its  object  file.  The assembler generates relocatable object files that can then be archived or linked with other relocatable object files and archives to create an executable file. Notable features of the assembler include:\n\u00b7 Support for the entire device instruction set\n\u00b7 Support for fixed-point and floating-point data\n\u00b7 Command-line interface\n\u00b7 Rich directive set\n\u00b7 Flexible macro language\n\u00b7 MPLAB X IDE compatibility",
    "44.6 MPLAB X SIM Software Simulator\nThe  MPLAB  X  SIM  Software  Simulator  allows  code development in a PC-hosted environment by simulat -ing the PIC MCUs and dsPIC DSCs on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a comprehensive stimulus controller. Registers can be logged to files for further run-time analysis. The trace buffer and logic analyzer display extend the power of the simulator to record and track program execution, actions on I/O, most peripherals and internal registers.\nThe MPLAB X SIM Software Simulator fully supports symbolic debugging using the MPLAB XC Compilers, and  the  MPASM  and  MPLAB Assemblers. The  soft -ware  simulator  offers  the  flexibility  to  develop  and debug code outside of the hardware laboratory envi -ronment, making it an excellent, economical software development tool.",
    "44.7 MPLAB REAL ICE In-Circuit Emulator System\nThe MPLAB REAL ICE In-Circuit Emulator System is Microchip's  next  generation  high-speed  emulator  for Microchip Flash DSC and MCU devices. It debugs and programs all 8, 16 and 32-bit MCU, and DSC devices with the easy-to-use, powerful graphical user interface of the MPLAB X IDE.\nThe emulator is connected to the design engineer's PC  using  a  high-speed  USB  2.0  interface  and  is connected  to  the  target  with either a connector compatible with in-circuit debugger systems (RJ-11) or  with  the  new  high-speed,  noise  tolerant,  LowVoltage  Differential  Signal  (LVDS)  interconnection (CAT5).\nThe emulator is field upgradable through future firmware downloads in MPLAB X IDE. MPLAB REAL ICE offers significant advantages over competitive emulators including full-speed emulation, run-time variable watches,  trace  analysis,  complex  breakpoints,  logic probes,  a  ruggedized  probe  interface  and  long  (up  to three meters) interconnection cables.",
    "44.8 MPLAB ICD 3 In-Circuit Debugger System\nThe  MPLAB  ICD  3  In-Circuit  Debugger  System  is Microchip's most cost-effective, high-speed hardware debugger/programmer  for  Microchip  Flash  DSC  and MCU  devices.  It  debugs  and  programs  PIC  Flash microcontrollers  and  dsPIC  DSCs  with  the  powerful, yet easy-to-use graphical user interface of the MPLAB IDE.\nThe  MPLAB  ICD  3  In-Circuit  Debugger  probe  is connected to the design engineer's PC using a highspeed USB 2.0 interface and is connected to the target with a connector compatible with the MPLAB ICD 2 or MPLAB  REAL  ICE  systems  (RJ-11).  MPLAB  ICD  3 supports all MPLAB ICD 2 headers.",
    "44.9 PICkit 3 In-Circuit Debugger/ Programmer\nThe MPLAB PICkit 3 allows debugging and program -ming of PIC and dsPIC Flash microcontrollers at a most affordable price point using the powerful graphical user interface of the MPLAB IDE. The MPLAB PICkit 3 is connected  to  the  design  engineer's  PC  using  a  fullspeed USB interface and can be connected to the tar -get via a Microchip debug (RJ-11) connector (compati -ble with MPLAB ICD 3 and MPLAB REAL ICE). The connector uses two device I/O pins and the Reset line to implement in-circuit debugging and In-Circuit Serial Programming\u2122 (ICSP\u2122).",
    "44.10 MPLAB PM3 Device Programmer\nThe MPLAB PM3 Device Programmer is a universal, CE compliant device programmer with programmable voltage verification at VDDMIN and VDDMAX for maximum  reliability.  It  features  a  large  LCD  display (128 x 64) for menus and error messages, and a mod -ular,  detachable  socket  assembly  to  support  various package types. The ICSP cable assembly is included as a standard item. In Stand-Alone mode, the MPLAB PM3 Device Programmer can read, verify and program PIC devices without a PC connection. It can also set code  protection in this mode.  The  MPLAB  PM3 connects to the host PC via an RS-232 or USB cable. The MPLAB PM3 has high-speed communications and optimized  algorithms  for  quick  programming  of  large memory devices, and incorporates an MMC card for file storage and data applications.",
    "44.11 Demonstration/Development Boards, Evaluation Kits, and Starter Kits\nA  wide  variety  of  demonstration,  development  and evaluation  boards  for  various  PIC  MCUs  and  dsPIC DSCs  allows  quick  application  development  on  fully functional  systems.  Most  boards  include  prototyping areas for adding custom circuitry and provide applica -tion  firmware  and  source  code  for  examination  and modification.\nThe boards support a variety of features, including LEDs, temperature sensors, switches, speakers, RS-232 interfaces, LCD displays, potentiometers and additional EEPROM memory.\nThe  demonstration  and  development  boards  can  be used in teaching environments, for prototyping custom circuits and for learning about various microcontroller applications.\nIn addition to the PICDEM\u2122  and  dsPICDEM\u2122 demonstration/development  board  series  of  circuits, Microchip has a line of evaluation kits and demonstra -tion software for analog filter design, KEELOQ \u00ae security ICs,  CAN,  IrDA \u00ae ,  PowerSmart  battery  management, SEEVAL \u00ae   evaluation  system,  Sigma-Delta ADC,  flow rate sensing, plus many more.\nAlso available are starter kits that contain everything needed to experience the specified device. This usually includes a single application and debug capability, all on one board.",
    "44.11 Demonstration/Development Boards, Evaluation Kits, and Starter Kits\nCheck the Microchip web page (www.microchip.com) for  the  complete  list  of  demonstration,  development and evaluation kits.",
    "44.12 Third-Party Development Tools\nMicrochip  also  offers  a  great  collection  of  tools  from third-party vendors. These tools are carefully selected to offer good value and unique functionality.\n\u00b7 Device Programmers and Gang Programmers from companies, such as SoftLog and CCS\n\u00b7 Software Tools from companies, such as Gimpel and Trace Systems\n\u00b7 Protocol Analyzers from companies, such as Saleae and Total Phase\n\u00b7 Demonstration Boards from companies, such as MikroElektronika, Digilent \u00ae  and Olimex\n\u00b7 Embedded Ethernet Solutions from companies, such as EZ Web Lynx, WIZnet and IPLogika \u00ae",
    "45.1 Absolute Maximum Ratings (\u2020)\nAmbient temperature under bias......................................................................................................  -40\u00b0C to +125\u00b0C\nStorage temperature ........................................................................................................................  -65\u00b0C to +150\u00b0C",
    "45.1 Absolute Maximum Ratings (\u2020)\nVoltage on pins with respect to VSS\non VDD pin\nPIC18F25/26K83  ......................................................................................................  -0.3V to +6.5V",
    "45.1 Absolute Maximum Ratings (\u2020)\nPIC18LF25/26K83  ....................................................................................................  -0.3V to +4.0V",
    "45.1 Absolute Maximum Ratings (\u2020)\non MCLR pin  ...........................................................................................................................  -0.3V to +9.0V",
    "45.1 Absolute Maximum Ratings (\u2020)\non all other pins ............................................................................................................  -0.3V to (VDD + 0.3V)\nMaximum current\non VSS pin (1)\n-40\u00b0C \uf0a3 TA \uf0a3",
    "45.1 Absolute Maximum Ratings (\u2020)\n+85\u00b0C ..............................................................................................................  350 mA\n85\u00b0C \uf03c TA \uf0a3\n+125\u00b0C .............................................................................................................  120 mA\non VDD pin for 28-Pin devices (1)",
    "45.1 Absolute Maximum Ratings (\u2020)\n-40\u00b0C \uf0a3 TA \uf0a3\n+85\u00b0C ..............................................................................................................  250 mA\n85\u00b0C \uf03c TA \uf0a3\n+125\u00b0C ...............................................................................................................  85 mA",
    "45.1 Absolute Maximum Ratings (\u2020)\non any standard I/O pin  ......................................................................................................................\n\uf0b1 50 mA\nClamp current, IK (VPIN < 0 or VPIN > VDD) ...................................................................................................\n\uf0b1 20 mA",
    "45.1 Absolute Maximum Ratings (\u2020)\nTotal power dissipation (2)\n................................................................................................................................ 800 mW\nNote 1: Maximum current rating requires even load distribution across I/O pins. Maximum current rating may be limited by the device package power dissipation characterizations, see Table 45-6 to calculate device specifications.\n2: Power dissipation is calculated as follows:\nPDIS = VDD x {IDD -\uf053\uf020 IOH} + \uf053\uf020\uf07b\uf028 VDD - VOH) x IOH} + \uf053\uf020\uf028 VOI x IOL \uf029",
    "45.1 Absolute Maximum Ratings (\u2020)\n\u2020 NOTICE: Stresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure above maximum rating conditions for extended periods may affect device reliability.",
    "45.2 Standard Operating Conditions\nThe standard operating conditions for any device are defined as:",
    "45.2 Standard Operating Conditions\nOperating Voltage:, 1 = Operating Voltage:. Operating Voltage:, 2 = Operating Voltage:. Operating Voltage:, 3 = VDDMIN \uf0a3\uf020 VDD \uf0a3\uf020 VDDMAX. Operating Voltage:, 4 = . Operating Temperature:, 1 = Operating Temperature:. Operating Temperature:, 2 = Operating Temperature:. Operating Temperature:, 3 = TA_MIN \uf0a3\uf020 TA \uf0a3\uf020 TA_MAX. Operating Temperature:, 4 = . VDD -Operating Supply Voltage (1), 1 = VDD -Operating Supply Voltage (1). VDD -Operating Supply Voltage (1), 2 = VDD -Operating Supply Voltage (1). VDD -Operating Supply Voltage (1), 3 = VDD -Operating Supply Voltage (1). VDD -Operating Supply Voltage (1), 4 = . PIC18LF25/26K83, 1 = PIC18LF25/26K83. PIC18LF25/26K83, 2 = PIC18LF25/26K83. PIC18LF25/26K83, 3 = PIC18LF25/26K83. PIC18LF25/26K83, 4 = . , 1 = . , 2 =",
    "45.2 Standard Operating Conditions\nVDDMIN (Fosc \uf0a3 16 MHz) .......................................................................................................... , 3 = VDDMIN (Fosc \uf0a3 16 MHz) .......................................................................................................... , 4 = +1.8V. , 1 = . , 2",
    "45.2 Standard Operating Conditions\n= VDDMIN (Fosc \uf0a3 32 MHz) .......................................................................................................... , 3 = VDDMIN (Fosc \uf0a3 32 MHz) .......................................................................................................... , 4 = +2.5V. , 1 = . ,",
    "45.2 Standard Operating Conditions\n2 = VDDMIN (Fosc \uf0a3 64 MHz) .......................................................................................................... , 3 = VDDMIN (Fosc \uf0a3 64 MHz) .......................................................................................................... , 4 = +2.7V. , 1 = .",
    "45.2 Standard Operating Conditions\n, 2 = VDDMAX ..................................................................................................................................... , 3 = VDDMAX",
    "45.2 Standard Operating Conditions\n..................................................................................................................................... , 4 = +3.6V. PIC18F25/26K83, 1 = PIC18F25/26K83. PIC18F25/26K83, 2 = PIC18F25/26K83. PIC18F25/26K83, 3 = PIC18F25/26K83. PIC18F25/26K83, 4 = . , 1 = . , 2 = VDDMIN (Fosc \uf0a3 16 MHz)",
    "45.2 Standard Operating Conditions\n.......................................................................................................... , 3 = VDDMIN (Fosc \uf0a3 16 MHz) .......................................................................................................... , 4 = +2.3V. , 1 = . , 2 = VDDMIN (Fosc \uf0a3 32",
    "45.2 Standard Operating Conditions\nMHz) .......................................................................................................... , 3 = VDDMIN (Fosc \uf0a3 32 MHz) .......................................................................................................... , 4 = +2.5V. , 1 = . , 2 = VDDMIN (Fosc \uf0a3",
    "45.2 Standard Operating Conditions\n64 MHz) .......................................................................................................... , 3 = VDDMIN (Fosc \uf0a3 64 MHz) .......................................................................................................... , 4 = +3.0V. , 1 = . , 2 = VDDMAX",
    "45.2 Standard Operating Conditions\n..................................................................................................................................... , 3 = VDDMAX",
    "45.2 Standard Operating Conditions\n..................................................................................................................................... , 4 = +5.5V. TA -Operating Ambient Temperature Range, 1 = TA -Operating Ambient Temperature Range. TA -Operating Ambient Temperature Range, 2 = TA -Operating Ambient Temperature Range. TA -Operating Ambient Temperature Range, 3 = TA -Operating Ambient Temperature Range. TA -Operating Ambient Temperature Range, 4 = . Industrial Temperature, 1 = Industrial Temperature. Industrial Temperature, 2 = Industrial Temperature. Industrial Temperature, 3 = Industrial Temperature. Industrial Temperature, 4 = . , 1 = . , 2 = TA_MIN",
    "45.2 Standard Operating Conditions\n...................................................................................................................................... , 3 = TA_MIN",
    "45.2 Standard Operating Conditions\n...................................................................................................................................... , 4 = -40\u00b0C. , 1 = . , 2 =",
    "45.2 Standard Operating Conditions\nTA_MAX..................................................................................................................................... , 3 =",
    "45.2 Standard Operating Conditions\nTA_MAX..................................................................................................................................... , 4 = +85\u00b0C. Extended Temperature, 1 = Extended Temperature. Extended Temperature, 2 = Extended Temperature. Extended Temperature, 3 = Extended Temperature. Extended Temperature, 4 = . , 1 = . , 2 = TA_MIN",
    "45.2 Standard Operating Conditions\n...................................................................................................................................... , 3 = TA_MIN",
    "45.2 Standard Operating Conditions\n...................................................................................................................................... , 4 = -40\u00b0C. , 1 = . , 2 =",
    "45.2 Standard Operating Conditions\nTA_MAX................................................................................................................................... , 3 =",
    "45.2 Standard Operating Conditions\nTA_MAX................................................................................................................................... , 4 = +125\u00b0C. Note, 1 = 1:. Note, 2 = See Parameter Supply Voltage, DS Characteristics: Supply Voltage.. Note, 3 = See Parameter Supply Voltage, DS Characteristics: Supply Voltage.. Note, 4 = ",
    "PIC18(L)F25/26K83\nFIGURE 45-2: VOLTAGE FREQUENCY GRAPH, -40\u00b0C   TA \uf0a3 \uf0a3\uf020 +125\u00b0C, PIC18LF25/26K83 ONLY",
    "TABLE 45-1: SUPPLY VOLTAGE\nPIC18F25/26K83, PIC18LF25/26K83 = PIC18F25/26K83. PIC18F25/26K83, PIC18LF25/26K83 = PIC18F25/26K83. PIC18F25/26K83, Standard Operating Conditions (unless otherwise stated) = . PIC18F25/26K83, Standard Operating Conditions (unless otherwise stated) = . PIC18F25/26K83, Standard Operating Conditions (unless otherwise stated) = . PIC18F25/26K83, Standard Operating Conditions (unless otherwise stated) = . PIC18F25/26K83, Standard Operating Conditions (unless otherwise stated) = . Param. No., PIC18LF25/26K83 = Sym.. Param. No., PIC18LF25/26K83 = Characteristic. Param. No., Standard Operating Conditions (unless otherwise stated) = Min.. Param. No., Standard Operating Conditions (unless otherwise stated) = Typ.\u2020. Param. No., Standard Operating Conditions (unless otherwise",
    "TABLE 45-1: SUPPLY VOLTAGE\nstated) = Max.. Param. No., Standard Operating Conditions (unless otherwise stated) = Units. Param. No., Standard Operating Conditions (unless otherwise stated) = Conditions. Supply Voltage, PIC18LF25/26K83 = Supply Voltage. Supply Voltage, PIC18LF25/26K83 = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated) = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated) = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated) = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated) = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated) = Supply Voltage. D002, PIC18LF25/26K83 = VDD. D002, PIC18LF25/26K83 = . D002, Standard Operating Conditions (unless otherwise stated) = 2.3 1.8 2.5 2.7. D002, Standard Operating Conditions (unless otherwise stated) = - - - -. D002, Standard Operating Conditions (unless otherwise stated) = 3.6 3.6 3.6 3.6.",
    "TABLE 45-1: SUPPLY VOLTAGE\nD002, Standard Operating Conditions (unless otherwise stated) = V V V V. D002, Standard Operating Conditions (unless otherwise stated) = FOSC \uf0a3 16 MHz (-40\u00b0C <+ 25\u00b0C) FOSC \uf0a3 16 MHz ( \u2265 25\u00b0C to 125\u00b0C) FOSC \uf03e 16 MHz FOSC \uf03e 32 MHz. D002, PIC18LF25/26K83 = VDD. D002, PIC18LF25/26K83 = . D002, Standard Operating Conditions (unless otherwise stated) = 2.3 2.5 3.0. D002, Standard Operating Conditions (unless otherwise stated) = - - -. D002, Standard Operating Conditions (unless otherwise stated) = 5.5 5.5 5.5. D002, Standard Operating Conditions (unless otherwise stated) = V V V. D002, Standard Operating Conditions (unless otherwise stated) = FOSC \uf0a3 16 MHz FOSC \uf03e\uf020 16 MHz FOSC \uf03e 32 MHz. RAM Data Retention (1), PIC18LF25/26K83 = RAM Data Retention (1). RAM Data Retention (1),",
    "TABLE 45-1: SUPPLY VOLTAGE\nPIC18LF25/26K83 = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated) = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated) = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated) = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated) = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated) = RAM Data Retention (1). D003, PIC18LF25/26K83 = VDR. D003, PIC18LF25/26K83 = . D003, Standard Operating Conditions (unless otherwise stated) = 1.5. D003, Standard Operating Conditions (unless otherwise stated) = -. D003, Standard Operating Conditions (unless otherwise stated) = -. D003, Standard Operating Conditions (unless otherwise stated) = V. D003, Standard Operating Conditions (unless otherwise stated) = Device in Sleep mode. D003,",
    "TABLE 45-1: SUPPLY VOLTAGE\nPIC18LF25/26K83 = VDR. D003, PIC18LF25/26K83 = . D003, Standard Operating Conditions (unless otherwise stated) = 1.7. D003, Standard Operating Conditions (unless otherwise stated) = -. D003, Standard Operating Conditions (unless otherwise stated) = -. D003, Standard Operating Conditions (unless otherwise stated) = V. D003, Standard Operating Conditions (unless otherwise stated) = Device in Sleep mode. Power-on Reset Release Voltage (2), PIC18LF25/26K83 = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), PIC18LF25/26K83 = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated) = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated) = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated) = Power-on Reset",
    "TABLE 45-1: SUPPLY VOLTAGE\nRelease Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated) = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated) = Power-on Reset Release Voltage (2). D004, PIC18LF25/26K83 = VPOR. D004, PIC18LF25/26K83 = . D004, Standard Operating Conditions (unless otherwise stated) = -. D004, Standard Operating Conditions (unless otherwise stated) = 1.6. D004, Standard Operating Conditions (unless otherwise stated) = -. D004, Standard Operating Conditions (unless otherwise stated) = V. D004, Standard Operating Conditions (unless otherwise stated) = BOR or LPBOR disabled (3). D004, PIC18LF25/26K83 = VPOR. D004, PIC18LF25/26K83 = . D004, Standard Operating Conditions (unless otherwise stated) = -. D004, Standard Operating Conditions (unless otherwise stated) = 1.6. D004,",
    "TABLE 45-1: SUPPLY VOLTAGE\nStandard Operating Conditions (unless otherwise stated) = -. D004, Standard Operating Conditions (unless otherwise stated) = V. D004, Standard Operating Conditions (unless otherwise stated) = BOR or LPBOR disabled (3). Power-on Reset Rearm Voltage (2), PIC18LF25/26K83 = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), PIC18LF25/26K83 = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated) = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated) = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated) = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated) = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard",
    "TABLE 45-1: SUPPLY VOLTAGE\nOperating Conditions (unless otherwise stated) = Power-on Reset Rearm Voltage (2). D005, PIC18LF25/26K83 = VPORR. D005, PIC18LF25/26K83 = . D005, Standard Operating Conditions (unless otherwise stated) = -. D005, Standard Operating Conditions (unless otherwise stated) = 0.8. D005, Standard Operating Conditions (unless otherwise stated) = -. D005, Standard Operating Conditions (unless otherwise stated) = V. D005, Standard Operating Conditions (unless otherwise stated) = BOR or LPBOR disabled (3). D005, PIC18LF25/26K83 = VPORR. D005, PIC18LF25/26K83 = . D005, Standard Operating Conditions (unless otherwise stated) = -. D005, Standard Operating Conditions (unless otherwise stated) = 1.5. D005, Standard Operating Conditions (unless otherwise stated) = -. D005, Standard Operating Conditions (unless otherwise stated) = V. D005, Standard Operating Conditions (unless otherwise stated) = BOR or",
    "TABLE 45-1: SUPPLY VOLTAGE\nLPBOR disabled (3). VDD Rise Rate to ensure internal Power-on Reset signal (2), PIC18LF25/26K83 = VDD Rise Rate to ensure internal Power-on Reset signal (2). VDD Rise Rate to ensure internal Power-on Reset signal (2), PIC18LF25/26K83 = VDD Rise Rate to ensure internal Power-on Reset signal (2). VDD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated) = VDD Rise Rate to ensure internal Power-on Reset signal (2). VDD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated) = VDD Rise Rate to ensure internal Power-on Reset signal (2). VDD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated) = VDD Rise Rate to ensure internal Power-on Reset signal (2). VDD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated) = VDD Rise Rate to ensure internal Power-on",
    "TABLE 45-1: SUPPLY VOLTAGE\nReset signal (2). VDD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated) = VDD Rise Rate to ensure internal Power-on Reset signal (2). D006, PIC18LF25/26K83 = SVDD. D006, PIC18LF25/26K83 = . D006, Standard Operating Conditions (unless otherwise stated) = 0.05. D006, Standard Operating Conditions (unless otherwise stated) = -. D006, Standard Operating Conditions (unless otherwise stated) = -. D006, Standard Operating Conditions (unless otherwise stated) = V/ms. D006, Standard Operating Conditions (unless otherwise stated) = BOR or LPBOR disabled (3). D006, PIC18LF25/26K83 = SVDD. D006, PIC18LF25/26K83 = . D006, Standard Operating Conditions (unless otherwise stated) = 0.05. D006, Standard Operating Conditions (unless otherwise stated) = -. D006, Standard Operating Conditions (unless otherwise stated) = -. D006,",
    "TABLE 45-1: SUPPLY VOLTAGE\nStandard Operating Conditions (unless otherwise stated) = V/ms. D006, Standard Operating Conditions (unless otherwise stated) = BOR or LPBOR disabled (3)\n\u2020 Data in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: This is the limit to which VDD can be lowered in Sleep mode without losing RAM data.\n2: See Figure 45-3, POR and POR REARM with Slow Rising VDD.\n3: See Table 45-11 for BOR and LPBOR trip point information.",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\nPIC18LF25/26K83\nStandard Operating Conditions (unless otherwise stated)",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\nD100, PIC18F25/26K83.Symbol. = I DD XT4. D100, PIC18F25/26K83.Device Characteristics. = XT = 4 MHz. D100, Min.. = -. D100, Typ.\u2020. = 950. D100, Max.. = 1200. D100, Units. = \uf06d A. D100, Conditions.VDD = 3.0V. D100, Conditions.Note = . D100, PIC18F25/26K83.Symbol. = I DD XT4. D100, PIC18F25/26K83.Device Characteristics. = XT = 4 MHz. D100, Min.. = -. D100, Typ.\u2020. = 1004. D100, Max.. = 1300. D100, Units. = \uf06d A. D100, Conditions.VDD = 3.0V. D100, Conditions.Note = . D100A, PIC18F25/26K83.Symbol. = I DD XT4. D100A,",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\nPIC18F25/26K83.Device Characteristics. = XT = 4 MHz. D100A, Min.. = -. D100A, Typ.\u2020. = 468. D100A, Max.. = 850. D100A, Units. = \uf06d A. D100A, Conditions.VDD = 3.0V. D100A, Conditions.Note = PMD's all 1 's. D100A, PIC18F25/26K83.Symbol. = I DD XT4. D100A, PIC18F25/26K83.Device Characteristics. = XT = 4 MHz. D100A, Min.. = -. D100A, Typ.\u2020. = 620. D100A, Max.. = 950. D100A, Units. = \uf06d A. D100A, Conditions.VDD = 3.0V. D100A, Conditions.Note = PMD's all 1 's. D101, PIC18F25/26K83.Symbol. = I DD HFO16.",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\nD101, PIC18F25/26K83.Device Characteristics. = HFINTOSC = 16 MHz. D101, Min.. = -. D101, Typ.\u2020. = 4.1. D101, Max.. = 5.0. D101, Units. = mA. D101, Conditions.VDD = 3.0V. D101, Conditions.Note = . D101, PIC18F25/26K83.Symbol. = I DD HFO16. D101, PIC18F25/26K83.Device Characteristics. = HFINTOSC = 16 MHz. D101, Min.. = -. D101, Typ.\u2020. = 4.1. D101, Max.. = 5.1. D101, Units. = mA. D101, Conditions.VDD = 3.0V. D101, Conditions.Note = . D101A, PIC18F25/26K83.Symbol. = I DD HFO16.",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\nD101A, PIC18F25/26K83.Device Characteristics. = HFINTOSC = 16 MHz. D101A, Min.. = -. D101A, Typ.\u2020. = 2.4. D101A, Max.. = 3.2. D101A, Units. = mA. D101A, Conditions.VDD = 3.0V. D101A, Conditions.Note = PMD's all 1 's. D101A, PIC18F25/26K83.Symbol. = I DD HFO16. D101A, PIC18F25/26K83.Device Characteristics. = HFINTOSC = 16 MHz. D101A, Min.. = -. D101A, Typ.\u2020. = 2.4. D101A, Max.. = 3.5. D101A, Units. = mA. D101A, Conditions.VDD = 3.0V. D101A, Conditions.Note = PMD's all",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\n1 's. D102, PIC18F25/26K83.Symbol. = I DD HFOPLL. D102, PIC18F25/26K83.Device Characteristics. = HFINTOSC = 64 MHz. D102, Min.. = -. D102, Typ.\u2020. = 15.6. D102, Max.. = 18.5. D102, Units. = mA. D102, Conditions.VDD = 3.0V. D102, Conditions.Note = . D102, PIC18F25/26K83.Symbol. = I DD HFOPLL. D102, PIC18F25/26K83.Device Characteristics. = HFINTOSC = 64 MHz. D102, Min.. = -. D102, Typ.\u2020. = 16.7. D102, Max.. = 19. D102, Units. = mA. D102, Conditions.VDD = 3.0V. D102, Conditions.Note = .",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\nD102A, PIC18F25/26K83.Symbol. = I DD HFOPLL. D102A, PIC18F25/26K83.Device Characteristics. = HFINTOSC = 64 MHz. D102A, Min.. = -. D102A, Typ.\u2020. = 9. D102A, Max.. = 11. D102A, Units. = mA. D102A, Conditions.VDD = 3.0V. D102A, Conditions.Note = PMD's all 1 's. D102A, PIC18F25/26K83.Symbol. = I DD HFOPLL. D102A, PIC18F25/26K83.Device Characteristics. = HFINTOSC = 64 MHz. D102A, Min.. = -. D102A, Typ.\u2020. = 9. D102A, Max.. = 11.5. D102A, Units. = mA. D102A, Conditions.VDD",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\n= 3.0V. D102A, Conditions.Note = PMD's all 1 's. D103, PIC18F25/26K83.Symbol. = I DD HSPLL64. D103, PIC18F25/26K83.Device Characteristics. = HS+PLL = 64 MHz. D103, Min.. = -. D103, Typ.\u2020. = 14.8. D103, Max.. = 19. D103, Units. = mA. D103, Conditions.VDD = 3.0V. D103, Conditions.Note = . D103, PIC18F25/26K83.Symbol. = I DD HSPLL64. D103, PIC18F25/26K83.Device Characteristics. = HS+PLL = 64 MHz. D103, Min.. = -. D103, Typ.\u2020. = 14.8. D103, Max.. = 20. D103, Units. = mA. D103,",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\nConditions.VDD = 3.0V. D103, Conditions.Note = . D103A, PIC18F25/26K83.Symbol. = I DD HSPLL64. D103A, PIC18F25/26K83.Device Characteristics. = HS+PLL = 64 MHz. D103A, Min.. = -. D103A, Typ.\u2020. = 7.3. D103A, Max.. = 10. D103A, Units. = mA. D103A, Conditions.VDD = 3.0V. D103A, Conditions.Note = PMD's all 1 's. D103A, PIC18F25/26K83.Symbol. = I DD HSPLL64. D103A, PIC18F25/26K83.Device Characteristics. = HS+PLL = 64 MHz. D103A, Min.. = -. D103A, Typ.\u2020. = 7.3. D103A, Max.. =",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\n10. D103A, Units. = mA. D103A, Conditions.VDD = 3.0V. D103A, Conditions.Note = PMD's all 1 's. D104, PIC18F25/26K83.Symbol. = I DD IDLE. D104, PIC18F25/26K83.Device Characteristics. = IDLE mode, HFINTOSC = 16 MHz. D104, Min.. = -. D104, Typ.\u2020. = 2.8. D104, Max.. = 4.5. D104, Units. = mA. D104, Conditions.VDD = 3.0V. D104, Conditions.Note = . D104, PIC18F25/26K83.Symbol. = I DD IDLE. D104, PIC18F25/26K83.Device Characteristics. = IDLE mode, HFINTOSC = 16 MHz. D104, Min.. = -. D104, Typ.\u2020. = 2.9.",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\nD104, Max.. = 4.5. D104, Units. = mA. D104, Conditions.VDD = 3.0V. D104, Conditions.Note = . D105, PIC18F25/26K83.Symbol. = I DD DOZE (3). D105, PIC18F25/26K83.Device Characteristics. = DOZE mode, HFINTOSC = 16 MHz, Doze Ratio = 16. D105, Min.. = -. D105, Typ.\u2020. = 2.9. D105, Max.. = -. D105, Units. = mA. D105, Conditions.VDD = 3.0V. D105, Conditions.Note = . D105, PIC18F25/26K83.Symbol. = I DD DOZE (3). D105, PIC18F25/26K83.Device Characteristics. = DOZE mode, HFINTOSC = 16 MHz, Doze Ratio = 16. D105,",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\nMin.. = -. D105, Typ.\u2020. = 3. D105, Max.. = -. D105, Units. = mA. D105, Conditions.VDD = 3.0V. D105, Conditions.Note = \n- \u2020 Data in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: The test conditions for all IDD measurements in active operation mode are: OSC1 = external square wave, from",
    "TABLE 45-2: SUPPLY CURRENT (IDD) (1,2,4)\nrail-to-rail; all I/O pins are outputs driven low; MCLR = VDD; WDT disabled.\n2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switch -ing rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\n3: IDD DOZE  = [IDD IDLE *(N-1)/N] + IDD HFO 16/N where N = DOZE Ratio (Register 10-2).\n4: PMD bits are all in the default state, no modules are disabled.",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\nPIC18LF25/26K83\nStandard Operating Conditions (unless otherwise stated)\nPIC18F25/26K83\nStandard Operating Conditions (unless otherwise stated) VREGPM = 1",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\nD200, Symbol.Symbol = I PD. D200, Device Characteristics.Device Characteristics = I PD Base. D200, Min..Min. = -. D200, Typ.\u2020.Typ.\u2020 = 0.07. D200, Max. +85\u00b0C.Max. +85\u00b0C = 2. D200, Max. +125\u00b0C.Max. +125\u00b0C = 6. D200, Units.Units = \uf06d A. D200, Conditions.VDD = 3.0V. D200, Conditions.Note = . D200 D200A, Symbol.Symbol = I PD. D200 D200A, Device Characteristics.Device Characteristics = I PD Base. D200 D200A, Min..Min. = -. D200 D200A, Typ.\u2020.Typ.\u2020 = 0.4. D200 D200A, Max. +85\u00b0C.Max. +85\u00b0C = 2.5. D200 D200A, Max. +125\u00b0C.Max. +125\u00b0C = 8. D200 D200A, Units.Units = \uf06d",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\nA. D200 D200A, Conditions.VDD = 3.0V. D200 D200A, Conditions.Note = . D200 D200A, Symbol.Symbol = I PD. D200 D200A, Device Characteristics.Device Characteristics = I PD Base. D200 D200A, Min..Min. = -. D200 D200A, Typ.\u2020.Typ.\u2020 = 20. D200 D200A, Max. +85\u00b0C.Max. +85\u00b0C = 37. D200 D200A, Max. +125\u00b0C.Max. +125\u00b0C = 45. D200 D200A, Units.Units = \uf06d A. D200 D200A, Conditions.VDD = 3.0V. D200 D200A, Conditions.Note = VREGPM = 0. D201, Symbol.Symbol = I PD_WDT. D201, Device Characteristics.Device Characteristics = Low-Frequency Internal Oscillator/ WDT. D201, Min..Min. = -. D201,",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\nTyp.\u2020.Typ.\u2020 = 0.9. D201, Max. +85\u00b0C.Max. +85\u00b0C = 2.9. D201, Max. +125\u00b0C.Max. +125\u00b0C = 9. D201, Units.Units = \uf06d A. D201, Conditions.VDD = 3.0V. D201, Conditions.Note = . D201, Symbol.Symbol = I PD_WDT. D201, Device Characteristics.Device Characteristics = Low-Frequency Internal Oscillator/ WDT. D201, Min..Min. = -. D201, Typ.\u2020.Typ.\u2020 = 1.1. D201, Max. +85\u00b0C.Max. +85\u00b0C = 3.3. D201, Max. +125\u00b0C.Max. +125\u00b0C = 9. D201, Units.Units = \uf06d A. D201, Conditions.VDD = 3.0V. D201, Conditions.Note = . D202, Symbol.Symbol =",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\nI PD_SOSC. D202, Device Characteristics.Device Characteristics = Secondary Oscillator (S OSC). D202, Min..Min. = -. D202, Typ.\u2020.Typ.\u2020 = 0.6. D202, Max. +85\u00b0C.Max. +85\u00b0C = 2.8. D202, Max. +125\u00b0C.Max. +125\u00b0C = 13. D202, Units.Units = \uf06d A. D202, Conditions.VDD = 3.0V. D202, Conditions.Note = LP mode. D202, Symbol.Symbol = I PD_SOSC. D202, Device Characteristics.Device Characteristics = Secondary Oscillator (S OSC). D202, Min..Min. = -. D202, Typ.\u2020.Typ.\u2020 = 0.8. D202, Max. +85\u00b0C.Max. +85\u00b0C = 3.2. D202, Max. +125\u00b0C.Max. +125\u00b0C",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\n= 15. D202, Units.Units = \uf06d A. D202, Conditions.VDD = 3.0V. D202, Conditions.Note = LP mode. D203, Symbol.Symbol = I PD_FVR. D203, Device Characteristics.Device Characteristics = FVR. D203, Min..Min. = -. D203, Typ.\u2020.Typ.\u2020 = 37. D203, Max. +85\u00b0C.Max. +85\u00b0C = 70. D203, Max. +125\u00b0C.Max. +125\u00b0C = 75. D203, Units.Units = \uf06d A. D203, Conditions.VDD = 3.0V. D203, Conditions.Note = FVRCON = 0x81 or 0x84. D203, Symbol.Symbol = I PD_FVR. D203, Device Characteristics.Device Characteristics = FVR. D203, Min..Min. = -. D203, Typ.\u2020.Typ.\u2020 = 30. D203,",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\nMax. +85\u00b0C.Max. +85\u00b0C = 70. D203, Max. +125\u00b0C.Max. +125\u00b0C = 76. D203, Units.Units = \uf06d A. D203, Conditions.VDD = 3.0V. D203, Conditions.Note = FVRCON = 0x81 or 0x84. D204, Symbol.Symbol = I PD_BOR. D204, Device Characteristics.Device Characteristics = Brown-out Reset (BOR). D204, Min..Min. = -. D204, Typ.\u2020.Typ.\u2020 = 9.4. D204, Max. +85\u00b0C.Max. +85\u00b0C = 16. D204, Max. +125\u00b0C.Max. +125\u00b0C = 20. D204, Units.Units = \uf06d A. D204, Conditions.VDD = 3.0V. D204, Conditions.Note = . D204, Symbol.Symbol = I PD_BOR. D204, Device",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\nCharacteristics.Device Characteristics = Brown-out Reset (BOR). D204, Min..Min. = -. D204, Typ.\u2020.Typ.\u2020 = 9.4. D204, Max. +85\u00b0C.Max. +85\u00b0C = 17. D204, Max. +125\u00b0C.Max. +125\u00b0C = 21. D204, Units.Units = \uf06d A. D204, Conditions.VDD = 3.0V. D204, Conditions.Note = . D205, Symbol.Symbol = I PD_LPBOR. D205, Device Characteristics.Device Characteristics = Low-Power Brown-out Reset (LPBOR). D205, Min..Min. = -. D205, Typ.\u2020.Typ.\u2020 = 0.2. D205, Max. +85\u00b0C.Max. +85\u00b0C = 3. D205, Max. +125\u00b0C.Max. +125\u00b0C = 9. D205, Units.Units = \uf06d A. D205,",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\nConditions.VDD = 3.0V. D205, Conditions.Note = . D205, Symbol.Symbol = I PD_LPBOR. D205, Device Characteristics.Device Characteristics = Low-Power Brown-out Reset (LPBOR). D205, Min..Min. = -. D205, Typ.\u2020.Typ.\u2020 = 0.5. D205, Max. +85\u00b0C.Max. +85\u00b0C = 3. D205, Max. +125\u00b0C.Max. +125\u00b0C = 9. D205, Units.Units = \uf06d A. D205, Conditions.VDD = 3.0V. D205, Conditions.Note = . D206, Symbol.Symbol = I PD_HLVD. D206, Device Characteristics.Device Characteristics = High/Low Voltage Detect (HLVD). D206, Min..Min. = -. D206, Typ.\u2020.Typ.\u2020 = 9.5. D206, Max. +85\u00b0C.Max.",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\n+85\u00b0C = 16. D206, Max. +125\u00b0C.Max. +125\u00b0C = 19. D206, Units.Units = \uf06d A. D206, Conditions.VDD = 3.0V. D206, Conditions.Note = . D206, Symbol.Symbol = I PD_HLVD. D206, Device Characteristics.Device Characteristics = High/Low Voltage Detect (HLVD). D206, Min..Min. = -. D206, Typ.\u2020.Typ.\u2020 = 9.7. D206, Max. +85\u00b0C.Max. +85\u00b0C = 17. D206, Max. +125\u00b0C.Max. +125\u00b0C = 20. D206, Units.Units = \uf06d A. D206, Conditions.VDD = 3.0V. D206, Conditions.Note = . D207, Symbol.Symbol = I PD_ADCA. D207, Device Characteristics.Device Characteristics = ADC - Active. D207, Min..Min. =",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\n-. D207, Typ.\u2020.Typ.\u2020 = 400. D207, Max. +85\u00b0C.Max. +85\u00b0C = -. D207, Max. +125\u00b0C.Max. +125\u00b0C = -. D207, Units.Units = \uf06d A. D207, Conditions.VDD = 3.0V. D207, Conditions.Note = ADC is converting (4). D207, Symbol.Symbol = I PD_ADCA. D207, Device Characteristics.Device Characteristics = ADC - Active. D207, Min..Min. = -. D207, Typ.\u2020.Typ.\u2020 = 400. D207, Max. +85\u00b0C.Max. +85\u00b0C = -. D207, Max. +125\u00b0C.Max. +125\u00b0C = -. D207, Units.Units = \uf06d A. D207, Conditions.VDD = 3.0V. D207, Conditions.Note = ADC is converting (4).",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\nD208, Symbol.Symbol = I PD_CMP. D208, Device Characteristics.Device Characteristics = Comparator. D208, Min..Min. = -. D208, Typ.\u2020.Typ.\u2020 = 33. D208, Max. +85\u00b0C.Max. +85\u00b0C = 50. D208, Max. +125\u00b0C.Max. +125\u00b0C = 55. D208, Units.Units = \uf06d A. D208, Conditions.VDD = 3.0V. D208, Conditions.Note = . D208, Symbol.Symbol = I PD_CMP. D208, Device Characteristics.Device Characteristics = Comparator. D208, Min..Min. = -. D208, Typ.\u2020.Typ.\u2020 = 30. D208, Max. +85\u00b0C.Max. +85\u00b0C = 50. D208, Max. +125\u00b0C.Max. +125\u00b0C = 60. D208, Units.Units = \uf06d A.",
    "TABLE 45-3: POWER-DOWN CURRENT (IPD) (1,2)\nD208, Conditions.VDD = 3.0V. D208, Conditions.Note = \n\u2020 Data in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: The peripheral current is the sum of the base IDD and the additional current consumed when this peripheral is enabled. The peripheral \u2206 current can be determined by subtracting the base IDD or IPD current from this limit. Max. values should be used when calculating total current consumption.\n2: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode with all I/O pins in high-impedance state and tied to VSS.\n3: All peripheral currents listed are on a per-peripheral basis if more than one instance of a peripheral is available.\n4: ADC clock source is FRC.",
    "Standard Operating Conditions (unless otherwise stated)\n, Sym. = VIL. , Characteristic = Input Low Voltage. , Min. = Input Low Voltage. , Typ\u2020 = Input Low Voltage. , Max. = Input Low Voltage. , Units = Input Low Voltage. , Conditions = Input Low Voltage. , Sym. = VIL. , Characteristic = I/O PORT:. , Min. = I/O PORT:. , Typ\u2020 = I/O PORT:. , Max. = I/O PORT:. , Units = I/O PORT:. , Conditions = I/O PORT:. D300, Sym. = . D300, Characteristic = with TTL buffer. D300, Min. = -. D300, Typ\u2020 = -. D300, Max. = 0.8. D300, Units = V. D300, Conditions = 4.5V \uf0a3 VDD \uf0a3 5.5V. D301, Sym. = . D301, Characteristic = . D301, Min. = -. D301, Typ\u2020 = -. D301, Max. = 0.15 VDD. D301, Units",
    "Standard Operating Conditions (unless otherwise stated)\n= V. D301, Conditions = 1.8V \uf0a3 VDD \uf0a3 4.5V. D302, Sym. = . D302, Characteristic = with Schmitt Trigger buffer. D302, Min. = -. D302, Typ\u2020 = -. D302, Max. = 0.2 VDD. D302, Units = V. D302, Conditions = 2.0V \uf0a3 VDD \uf0a3 5.5V. D303, Sym. = . D303, Characteristic = with I 2 C levels. D303, Min. = -. D303, Typ\u2020 = -. D303, Max. = 0.3 VDD. D303, Units = V. D303, Conditions = . D304, Sym. = . D304, Characteristic = with SMBus 2.0. D304, Min. = -. D304, Typ\u2020 = -. D304, Max. = 0.8. D304, Units = V. D304, Conditions = 2.7V \uf0a3 VDD \uf0a3 5.5V. D305,",
    "Standard Operating Conditions (unless otherwise stated)\nSym. = . D305, Characteristic = with SMBus 3.0. D305, Min. = -. D305, Typ\u2020 = -. D305, Max. = 0.8. D305, Units = V. D305, Conditions = 1.8V \uf0a3 VDD \uf0a3 5.5V. D306, Sym. = . D306, Characteristic = MCLR. D306, Min. = -. D306, Typ\u2020 = -. D306, Max. = 0.2 VDD. D306, Units = V. D306, Conditions = . , Sym. = VIH. , Characteristic = Input High Voltage. , Min. = Input High Voltage. , Typ\u2020 = Input High Voltage. , Max. = Input High Voltage. , Units = Input High Voltage. , Conditions = Input High Voltage. , Sym. = VIH. , Characteristic = I/O PORT:. , Min. = I/O PORT:. , Typ\u2020 = I/O PORT:. , Max. = I/O PORT:. , Units = I/O",
    "Standard Operating Conditions (unless otherwise stated)\nPORT:. , Conditions = I/O PORT:. D320, Sym. = . D320, Characteristic = with TTL buffer. D320, Min. = 2.0. D320, Typ\u2020 = -. D320, Max. = -. D320, Units = V. D320, Conditions = 4.5V \uf0a3 VDD \uf020\uf0a3 5.5V. D321, Sym. = . D321, Characteristic = . D321, Min. = 0.25 VDD + 0.8. D321, Typ\u2020 = -. D321, Max. = -. D321, Units = V. D321, Conditions = 1.8V \uf0a3 VDD \uf0a3 4.5V. D322, Sym. = . D322, Characteristic = with Schmitt Trigger buffer. D322, Min. = 0.8 VDD. D322, Typ\u2020 = -. D322, Max. = -. D322, Units = V. D322, Conditions = 2.0V \uf0a3 VDD \uf0a3 5.5V. D323,",
    "Standard Operating Conditions (unless otherwise stated)\nSym. = . D323, Characteristic = with I 2 C levels. D323, Min. = 0.7 VDD. D323, Typ\u2020 = -. D323, Max. = -. D323, Units = V. D323, Conditions = . D324, Sym. = . D324, Characteristic = with SMBus 2.0. D324, Min. = 2.1. D324, Typ\u2020 = -. D324, Max. = -. D324, Units = V. D324, Conditions = 2.7V \uf0a3 VDD \uf0a3 5.5V. D325, Sym. = . D325, Characteristic = with SMBus 3.0. D325, Min. = 1.35. D325, Typ\u2020 = -. D325, Max. = -. D325, Units = V. D325, Conditions = 1.8V \uf0a3 VDD \uf0a3 5.5V. D326, Sym. = . D326, Characteristic = MCLR. D326, Min. = 0.7",
    "Standard Operating Conditions (unless otherwise stated)\nVDD. D326, Typ\u2020 = -. D326, Max. = -. D326, Units = V. D326, Conditions = . , Sym. = I IL. , Characteristic = Input Leakage Current (1). , Min. = Input Leakage Current (1). , Typ\u2020 = Input Leakage Current (1). , Max. = Input Leakage Current (1). , Units = Input Leakage Current (1). , Conditions = Input Leakage Current (1). D340, Sym. = . D340, Characteristic = I/O Ports. D340, Min. = -. D340, Typ\u2020 = \u00b1 5. D340, Max. = \u00b1 125. D340, Units = nA. D340, Conditions = VSS \uf0a3 VPIN \uf0a3 VDD, Pin at high-impedance, 85\u00b0C. D341, Sym. = . D341, Characteristic = . D341, Min. = -. D341, Typ\u2020 = \u00b1 5. D341, Max. = \u00b1 1000. D341, Units",
    "Standard Operating Conditions (unless otherwise stated)\n= nA. D341, Conditions = VSS \uf0a3 VPIN \uf0a3 VDD, Pin at high-impedance, 125\u00b0C. D342, Sym. = . D342, Characteristic = MCLR (2). D342, Min. = -. D342, Typ\u2020 = \u00b1 50. D342, Max. = \u00b1 200. D342, Units = nA. D342, Conditions = VSS \uf0a3 VPIN \uf0a3 VDD, Pin at high-impedance, 85\u00b0C. D350, Sym. = I PUR. D350, Characteristic = Weak Pull-up Current. D350, Min. = Weak Pull-up Current. D350, Typ\u2020 = Weak Pull-up Current. D350, Max. = Weak Pull-up Current. D350, Units = Weak Pull-up Current. D350, Conditions = Weak Pull-up Current. , Sym. = . , Characteristic = . , Min. = 25. , Typ\u2020 = 120. , Max. = 200. , Units = \uf06d A. , Conditions = VDD = 3.0V, VPIN =",
    "Standard Operating Conditions (unless otherwise stated)\nVSS. D360, Sym. = VOL. D360, Characteristic = Output Low Voltage. D360, Min. = Output Low Voltage. D360, Typ\u2020 = Output Low Voltage. D360, Max. = Output Low Voltage. D360, Units = Output Low Voltage. D360, Conditions = Output Low Voltage. , Sym. = . , Characteristic = I/O ports. , Min. = -. , Typ\u2020 = -. , Max. = 0.6. , Units = V. , Conditions = I OL = 10.0mA, VDD = 3.0V. , Sym. = VOH. , Characteristic = Output High Voltage. , Min. = Output High Voltage. , Typ\u2020 = Output High Voltage. , Max. = Output High Voltage. , Units = Output High Voltage. , Conditions = Output High Voltage. D370, Sym. = . D370, Characteristic = I/O ports. D370, Min. = VDD - 0.7. D370, Typ\u2020 = -. D370, Max. = -. D370, Units",
    "Standard Operating Conditions (unless otherwise stated)\n= V. D370, Conditions = I OH = 6.0 mA, VDD = 3.0V. D380, Sym. = CIO. D380, Characteristic = All I/O pins. D380, Min. = -. D380, Typ\u2020 = 5. D380, Max. = 50. D380, Units = pF. D380, Conditions = \n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: Negative current is defined as current sourced by the pin.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.",
    "TABLE 45-5: MEMORY PROGRAMMING SPECIFICATIONS\nStandard Operating Conditions (unless otherwise stated)",
    "TABLE 45-5: MEMORY PROGRAMMING SPECIFICATIONS\nData EEPROM Memory Specifications, Sym. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Characteristic = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Min. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Typ\u2020 = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Max. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Units = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Conditions = Data EEPROM Memory Specifications. MEM20, Sym. = E D. MEM20, Characteristic = DataEE Byte Endurance. MEM20, Min. = 100k. MEM20, Typ\u2020 = -. MEM20, Max. = -. MEM20, Units = E/W. MEM20, Conditions = -40 \uf0b0 C \uf0a3 TA \uf0a3 +85 \uf0b0 C. MEM21, Sym. = T D_RET. MEM21, Characteristic = Characteristic Retention. MEM21, Min. = -. MEM21, Typ\u2020 = 40. MEM21, Max. = -. MEM21,",
    "TABLE 45-5: MEMORY PROGRAMMING SPECIFICATIONS\nUnits = Year. MEM21, Conditions = Provided no other specifications are violated. MEM22, Sym. = N D_REF. MEM22, Characteristic = Total Erase/Write Cycles before Refresh. MEM22, Min. = 1M 500k. MEM22, Typ\u2020 = 10M -. MEM22, Max. = - -. MEM22, Units = E/W. MEM22, Conditions = -40 \uf0b0 C \uf0a3 TA \uf0a3 +60 \uf0b0 C -40 \uf0b0 C \uf0a3 TA \uf0a3 +85 \uf0b0 C. MEM23, Sym. = V D_RW. MEM23, Characteristic = VDD for Read or Erase/Write operation. MEM23, Min. = VDDMIN. MEM23, Typ\u2020 = -. MEM23, Max. = VDDMAX. MEM23, Units = V. MEM23, Conditions = . MEM24, Sym. = T D_BEW. MEM24, Characteristic = Byte Erase and Write Cycle Time. MEM24, Min. = -. MEM24, Typ\u2020 = 4.0. MEM24, Max. = 5.0.",
    "TABLE 45-5: MEMORY PROGRAMMING SPECIFICATIONS\nMEM24, Units = ms. MEM24, Conditions = . Program Flash Memory Specifications, Sym. = Program Flash Memory Specifications. Program Flash Memory Specifications, Characteristic = Program Flash Memory Specifications. Program Flash Memory Specifications, Min. = Program Flash Memory Specifications. Program Flash Memory Specifications, Typ\u2020 = Program Flash Memory Specifications. Program Flash Memory Specifications, Max. = Program Flash Memory Specifications. Program Flash Memory Specifications, Units = Program Flash Memory Specifications. Program Flash Memory Specifications, Conditions = Program Flash Memory Specifications. MEM30, Sym. = E P. MEM30, Characteristic = Memory Cell Endurance. MEM30, Min. = 10k. MEM30, Typ\u2020 = -. MEM30, Max. = -. MEM30, Units = E/W. MEM30, Conditions = -40 \uf0b0 C \uf0a3 TA \uf0a3 +85 \uf0b0 C ( Note 1 ). MEM32, Sym. = T P_RET. MEM32, Characteristic = Characteristic Retention. MEM32, Min. = -. MEM32, Typ\u2020 = 40. MEM32, Max. = -. MEM32, Units = Year. MEM32, Conditions =",
    "TABLE 45-5: MEMORY PROGRAMMING SPECIFICATIONS\nProvided no other specifications are violated. MEM33, Sym. = V P_RD. MEM33, Characteristic = VDD for Read operation. MEM33, Min. = VDDMIN. MEM33, Typ\u2020 = -. MEM33, Max. = VDDMAX. MEM33, Units = V. MEM33, Conditions = . MEM34, Sym. = V P_REW. MEM34, Characteristic = VDD for Row Erase or Write operation. MEM34, Min. = VDDMIN. MEM34, Typ\u2020 = -. MEM34, Max. = VDDMAX. MEM34, Units = V. MEM34, Conditions = . MEM35, Sym. = T P_REW. MEM35, Characteristic = Self-Timed Row Erase or Self-Timed Write. MEM35, Min. = -. MEM35, Typ\u2020 = 2.0. MEM35, Max. = 2.5. MEM35, Units = ms. MEM35, Conditions = ",
    "TABLE 45-5: MEMORY PROGRAMMING SPECIFICATIONS\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: Memory Cell Endurance for the Program memory is defined as: One Row Erase operation and one Self-Timed Write.",
    "Standard Operating Conditions (unless otherwise stated)\nTH01, Sym. = \uf071 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 60. TH01, Units = \uf0b0 C/W. TH01, Conditions = 28-pin SPDIP package. TH01, Sym. = \uf071 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 80. TH01, Units = \uf0b0 C/W. TH01, Conditions = 28-pin SOIC package. TH01, Sym. = \uf071 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 90. TH01, Units = \uf0b0 C/W. TH01, Conditions = 28-pin SSOP package. TH01, Sym. = \uf071 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 27.5. TH01, Units = \uf0b0 C/W. TH01, Conditions = 28-pin UQFN 4x4 mm package. TH01, Sym. = \uf071 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 27.5. TH01, Units = \uf0b0 C/W.",
    "Standard Operating Conditions (unless otherwise stated)\nTH01, Conditions = 28-pin QFN 6x6mm package. TH02, Sym. = \uf071 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = 31.4. TH02, Units = \uf0b0 C/W. TH02, Conditions = 28-pin SPDIP package. TH02, Sym. = \uf071 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = 24. TH02, Units = \uf0b0 C/W. TH02, Conditions = 28-pin SOIC package. TH02, Sym. = \uf071 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = 24. TH02, Units = \uf0b0 C/W. TH02, Conditions = 28-pin SSOP package. TH02, Sym. = \uf071 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = 24. TH02, Units = \uf0b0 C/W. TH02, Conditions = 28-pin UQFN 4x4mm package.",
    "Standard Operating Conditions (unless otherwise stated)\nTH02, Sym. = \uf071 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = 24. TH02, Units = \uf0b0 C/W. TH02, Conditions = 28-pin QFN 6x6mm package. TH03, Sym. = TJMAX. TH03, Characteristic = Maximum Junction Temperature. TH03, Typ. = 150. TH03, Units = \uf0b0 C. TH03, Conditions = . TH04, Sym. = PD. TH04, Characteristic = Power Dissipation. TH04, Typ. = -. TH04, Units = W. TH04, Conditions = PD = PINTERNAL + PI / O (3). TH05, Sym. = PINTERNAL. TH05, Characteristic = Internal Power Dissipation. TH05, Typ. = -. TH05, Units = W. TH05, Conditions = PINTERNAL = I DD x VDD (1). TH06, Sym. = PI / O. TH06, Characteristic =",
    "Standard Operating Conditions (unless otherwise stated)\nI/O Power Dissipation. TH06, Typ. = -. TH06, Units = W. TH06, Conditions = PI / O = \uf053 (I OL * VOL) + \uf053 (I OH * (V DD - VOH)). TH07, Sym. = PDER. TH07, Characteristic = Derated Power. TH07, Typ. = -. TH07, Units = W. TH07, Conditions = PDER = PDMAX (T J - TA)/ \uf071 JA (2)\nNote 1:\nIDD is current to run the chip alone without driving any load on the output pins.\n2: TA = Ambient Temperature, TJ = Junction Temperature\n3: See absolute maximum ratings for total power dissipation.",
    "Standard Operating Conditions (unless otherwise stated)\nECL Oscillator, Sym. = ECL Oscillator. ECL Oscillator, Characteristic = ECL Oscillator. ECL Oscillator, Min. = ECL Oscillator. ECL Oscillator, Typ\u2020 = ECL Oscillator. ECL Oscillator, Max. = ECL Oscillator. ECL Oscillator, Units = ECL Oscillator. ECL Oscillator, Conditions = ECL Oscillator. OS1, Sym. = F ECL. OS1, Characteristic = Clock Frequency. OS1, Min. = -. OS1, Typ\u2020 = -. OS1, Max. = 500. OS1, Units = kHz. OS1, Conditions = . OS2, Sym. = T ECL_DC. OS2, Characteristic = Clock Duty Cycle. OS2, Min. = 40. OS2, Typ\u2020 = -. OS2, Max. = 60. OS2, Units = %. OS2, Conditions = . ECM Oscillator, Sym. = ECM",
    "Standard Operating Conditions (unless otherwise stated)\nOscillator. ECM Oscillator, Characteristic = ECM Oscillator. ECM Oscillator, Min. = ECM Oscillator. ECM Oscillator, Typ\u2020 = ECM Oscillator. ECM Oscillator, Max. = ECM Oscillator. ECM Oscillator, Units = ECM Oscillator. ECM Oscillator, Conditions = ECM Oscillator. OS3, Sym. = F ECM. OS3, Characteristic = Clock Frequency. OS3, Min. = -. OS3, Typ\u2020 = -. OS3, Max. = 4. OS3, Units = MHz. OS3, Conditions = . OS4, Sym. = T ECM_DC. OS4, Characteristic = Clock Duty Cycle. OS4, Min. = 40. OS4, Typ\u2020 = -. OS4, Max. = 60. OS4, Units = %. OS4, Conditions = . ECH Oscillator, Sym. = ECH Oscillator. ECH Oscillator, Characteristic",
    "Standard Operating Conditions (unless otherwise stated)\n= ECH Oscillator. ECH Oscillator, Min. = ECH Oscillator. ECH Oscillator, Typ\u2020 = ECH Oscillator. ECH Oscillator, Max. = ECH Oscillator. ECH Oscillator, Units = ECH Oscillator. ECH Oscillator, Conditions = ECH Oscillator. OS5, Sym. = F ECH. OS5, Characteristic = Clock Frequency. OS5, Min. = -. OS5, Typ\u2020 = -. OS5, Max. = 64. OS5, Units = MHz. OS5, Conditions = . OS6, Sym. = T ECH_DC. OS6, Characteristic = Clock Duty Cycle. OS6, Min. = 40. OS6, Typ\u2020 = -. OS6, Max. = 60. OS6, Units = %. OS6, Conditions = . LP Oscillator, Sym. = LP Oscillator. LP Oscillator, Characteristic = LP Oscillator. LP Oscillator, Min. =",
    "Standard Operating Conditions (unless otherwise stated)\nLP Oscillator. LP Oscillator, Typ\u2020 = LP Oscillator. LP Oscillator, Max. = LP Oscillator. LP Oscillator, Units = LP Oscillator. LP Oscillator, Conditions = LP Oscillator. OS7, Sym. = F LP. OS7, Characteristic = Clock Frequency. OS7, Min. = -. OS7, Typ\u2020 = -. OS7, Max. = 100. OS7, Units = kHz. OS7, Conditions = Note 4. XT Oscillator, Sym. = XT Oscillator. XT Oscillator, Characteristic = XT Oscillator. XT Oscillator, Min. = XT Oscillator. XT Oscillator, Typ\u2020 = XT Oscillator. XT Oscillator, Max. = XT Oscillator. XT Oscillator, Units = XT Oscillator. XT Oscillator, Conditions = XT Oscillator. OS8, Sym. =",
    "Standard Operating Conditions (unless otherwise stated)\nF XT. OS8, Characteristic = Clock Frequency. OS8, Min. = -. OS8, Typ\u2020 = -. OS8, Max. = 4. OS8, Units = MHz. OS8, Conditions = Note 4. HS Oscillator, Sym. = HS Oscillator. HS Oscillator, Characteristic = HS Oscillator. HS Oscillator, Min. = HS Oscillator. HS Oscillator, Typ\u2020 = HS Oscillator. HS Oscillator, Max. = HS Oscillator. HS Oscillator, Units = HS Oscillator. HS Oscillator, Conditions = HS Oscillator. OS9, Sym. = F HS. OS9, Characteristic = Clock Frequency. OS9, Min. = -. OS9, Typ\u2020 = -. OS9, Max. = 20. OS9, Units = MHz. OS9, Conditions = Note 4. Secondary Oscillator, Sym. = Secondary Oscillator. Secondary Oscillator, Characteristic = Secondary Oscillator. Secondary",
    "Standard Operating Conditions (unless otherwise stated)\nOscillator, Min. = Secondary Oscillator. Secondary Oscillator, Typ\u2020 = Secondary Oscillator. Secondary Oscillator, Max. = Secondary Oscillator. Secondary Oscillator, Units = Secondary Oscillator. Secondary Oscillator, Conditions = Secondary Oscillator. OS10, Sym. = F SEC. OS10, Characteristic = Clock Frequency. OS10, Min. = 32.4. OS10, Typ\u2020 = 32.768. OS10, Max. = 33.1. OS10, Units = kHz. OS10, Conditions = . System Oscillator, Sym. = System Oscillator. System Oscillator, Characteristic = System Oscillator. System Oscillator, Min. = System Oscillator. System Oscillator, Typ\u2020 = System Oscillator. System Oscillator, Max. = System Oscillator. System Oscillator, Units = System Oscillator. System Oscillator, Conditions = System Oscillator. OS20, Sym. = F",
    "Standard Operating Conditions (unless otherwise stated)\nOSC. OS20, Characteristic = System Clock Frequency. OS20, Min. = -. OS20, Typ\u2020 = -. OS20, Max. = 64. OS20, Units = MHz. OS20, Conditions = (Note 2, Note 3)",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\n1: Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When an external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all devices.\n2: The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in Section 10.0 'Power-Saving Operation Modes' .\n3: The system clock frequency (FOSC) must meet the voltage requirements defined in the Section 45.2 'Standard Operating Conditions' .",
    "Standard Operating Conditions (unless otherwise stated)\n4: LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.\nNote\nNote\nOS21, Sym. = F CY. OS21, Characteristic = Instruction Frequency. OS21, Min. = -. OS21, Typ\u2020 = FOSC/4. OS21, Max. = -. OS21, Units = MHz. OS21, Conditions = . OS22, Sym. = T CY. OS22, Characteristic = Instruction Period. OS22, Min. = 62.5. OS22, Typ\u2020 = 1/F CY. OS22, Max. = -. OS22, Units = ns. OS22, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\n1: Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When an external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all devices.\n2: The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in Section 10.0 'Power-Saving Operation Modes' .\n3: The system clock frequency (FOSC) must meet the voltage requirements defined in the Section 45.2 'Standard Operating Conditions' .",
    "Standard Operating Conditions (unless otherwise stated)\n4: LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.",
    "Standard Operating Conditions (unless otherwise stated)\nOS50, Sym. = FHFOSC. OS50, Characteristic = Precision Calibrated HFINTOSC Frequency. OS50, Min. = -. OS50, Typ\u2020 = 4 8 12 16 48 64. OS50, Max. = -. OS50, Units = MHz. OS50, Conditions = ( Note 2 ). OS51, Sym. = FHFOSCLP. OS51, Characteristic = Low-Power Optimized HFINTOSC Frequency. OS51, Min. = 0.93 1.86. OS51, Typ\u2020 = 1 2. OS51, Max. = 1.07 2.14. OS51, Units = MHz MHz. OS51, Conditions = . OS53*, Sym. = FLFOSC. OS53*, Characteristic = Internal LFINTOSC Frequency. OS53*, Min. = -. OS53*, Typ\u2020 = 31. OS53*, Max. = -. OS53*, Units = kHz. OS53*, Conditions = . OS54*, Sym. = THFOSCST. OS54*, Characteristic = HFINTOSC Wake-up",
    "Standard Operating Conditions (unless otherwise stated)\nfrom Sleep Start-up Time. OS54*, Min. = - -. OS54*, Typ\u2020 = 11 50. OS54*, Max. = 20 -. OS54*, Units = \uf06d s \uf06d s. OS54*, Conditions = VREGPM = 0 VREGPM = 1. OS56, Sym. = TLFOSCST. OS56, Characteristic = LFINTOSC Wake-up from Sleep Start-up Time. OS56, Min. = -. OS56, Typ\u2020 = 0.2. OS56, Max. = -. OS56, Units = ms. OS56, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: To ensure these oscillator frequency tolerances, VDD and VSS must be capacitively decoupled as close to the device as possible. 0.1 \uf06d F and 0.01 \uf06d F values in parallel are recommended.\n2: See Figure 45-6: Precision Calibrated HFINTOSC Frequency Accuracy Over Device VDD and Tempera -ture.",
    "Standard Operating Conditions (unless otherwise stated) VDD \uf0b3\uf020 2.5V\nPLL01, Sym. = FPLLIN. PLL01, Characteristic = PLL Input Frequency Range. PLL01, Min. = 4. PLL01, Typ\u2020 = -. PLL01, Max. = 16. PLL01, Units = MHz. PLL01, Conditions = . PLL02, Sym. = FPLLOUT. PLL02, Characteristic = PLL Output Frequency Range. PLL02, Min. = 16. PLL02, Typ\u2020 = -. PLL02, Max. = 64. PLL02, Units = MHz. PLL02, Conditions = Note 1. PLL03, Sym. = TPLLST. PLL03, Characteristic = PLL Lock Time from Start-up. PLL03, Min. = -. PLL03, Typ\u2020 = 200. PLL03, Max. = -. PLL03, Units = \uf06d s. PLL03, Conditions = . PLL04, Sym. = FPLLJIT. PLL04, Characteristic",
    "Standard Operating Conditions (unless otherwise stated) VDD \uf0b3\uf020 2.5V\n= PLL Output Frequency Stability (Jitter). PLL04, Min. = -0.25. PLL04, Typ\u2020 = -. PLL04, Max. = 0.25. PLL04, Units = %. PLL04, Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 5V, 25 C unless otherwise stated. These parameters are for design guidance \uf0b0 only and are not tested.\nNote 1: The output frequency of the PLL must meet the FOSC requirements listed in Parameter D002.\nFIGURE 45-7:\nCLKOUT AND I/O TIMING",
    "Standard Operating Conditions (unless otherwise stated)\nIO1*, Sym. = T CLKOUTH. IO1*, Characteristic = CLKOUT rising edge delay (rising edge Fosc (Q1 cycle) to falling edge CLKOUT. IO1*, Min. = -. IO1*, Typ\u2020 = -. IO1*, Max. = 70. IO1*, Units = ns. IO1*, Conditions = . IO2*, Sym. = T CLKOUTL. IO2*, Characteristic = CLKOUT falling edge delay (rising edge Fosc (Q3 cycle) to rising edge CLKOUT. IO2*, Min. = -. IO2*, Typ\u2020 = -. IO2*, Max. = 72. IO2*, Units = ns. IO2*, Conditions = . IO3*, Sym. = T IO_VALID. IO3*, Characteristic = Port output valid time (rising edge Fosc (Q1 cycle) to port valid). IO3*, Min. = -. IO3*, Typ\u2020 = 50. IO3*, Max. = 70. IO3*, Units = ns.",
    "Standard Operating Conditions (unless otherwise stated)\nIO3*, Conditions = . IO4*, Sym. = T IO_SETUP. IO4*, Characteristic = Port input setup time (Setup time before rising edge Fosc - Q2 cycle). IO4*, Min. = 20. IO4*, Typ\u2020 = -. IO4*, Max. = -. IO4*, Units = ns. IO4*, Conditions = . IO5*, Sym. = T IO_HOLD. IO5*, Characteristic = Port input hold time (Hold time after rising edge Fosc - Q2 cycle). IO5*, Min. = 50. IO5*, Typ\u2020 = -. IO5*, Max. = -. IO5*, Units = ns. IO5*, Conditions = . IO6*, Sym. = T IOR_SLREN. IO6*, Characteristic = Port I/O rise time, slew rate enabled. IO6*, Min. = -. IO6*, Typ\u2020 = 25. IO6*, Max. = -. IO6*, Units = ns. IO6*, Conditions = VDD =",
    "Standard Operating Conditions (unless otherwise stated)\n3.0V. IO7*, Sym. = T IOR_SLRDIS. IO7*, Characteristic = Port I/O rise time, slew rate disabled. IO7*, Min. = -. IO7*, Typ\u2020 = 5. IO7*, Max. = -. IO7*, Units = ns. IO7*, Conditions = VDD = 3.0V. IO8*, Sym. = T IOF_SLREN. IO8*, Characteristic = Port I/O fall time, slew rate enabled. IO8*, Min. = -. IO8*, Typ\u2020 = 25. IO8*, Max. = -. IO8*, Units = ns. IO8*, Conditions = VDD = 3.0V. IO9*, Sym. = T IOF_SLRDIS. IO9*, Characteristic = Port I/O fall time, slew rate disabled. IO9*, Min. = -. IO9*, Typ\u2020 = 5. IO9*, Max. = -. IO9*, Units = ns. IO9*, Conditions =",
    "Standard Operating Conditions (unless otherwise stated)\nVDD = 3.0V. IO10*, Sym. = T INT. IO10*, Characteristic = INT pin high or low time to trigger an interrupt. IO10*, Min. = 25. IO10*, Typ\u2020 = -. IO10*, Max. = -. IO10*, Units = ns. IO10*, Conditions = . IO11*, Sym. = T IOC. IO11*, Characteristic = Interrupt-on-Change minimum high or low time to trigger interrupt. IO11*, Min. = 25. IO11*, Typ\u2020 = -. IO11*, Max. = -. IO11*, Units = ns. IO11*, Conditions = \n- *These parameters are characterized but not tested.",
    "FIGURE 45-9: BROWN-OUT RESET TIMING AND CHARACTERISTICS\nNote 1: Delay depends on PWRTS<1:0> Configuration bits.",
    "Standard Operating Conditions (unless otherwise stated)\nRST01*, Sym. = TMCLR. RST01*, Characteristic = MCLR Pulse Width Low to ensure Reset. RST01*, Min. = 2. RST01*, Typ\u2020 = -. RST01*, Max. = -. RST01*, Units = \uf06d s. RST01*, Conditions = . RST02*, Sym. = TIOZ. RST02*, Characteristic = I/O high-impedance from Reset detection. RST02*, Min. = -. RST02*, Typ\u2020 = -. RST02*, Max. = 2. RST02*, Units = \uf06d s. RST02*, Conditions = . RST03, Sym. = TWDT. RST03, Characteristic = Watchdog Timer Time-out Period. RST03, Min. = -. RST03, Typ\u2020 = 16. RST03, Max. = -. RST03, Units = ms. RST03, Conditions = 1:512 Prescaler.",
    "Standard Operating Conditions (unless otherwise stated)\nRST04*, Sym. = TPWRT. RST04*, Characteristic = Power-up Timer Period. RST04*, Min. = -. RST04*, Typ\u2020 = 1 16 64. RST04*, Max. = -. RST04*, Units = ms ms ms. RST04*, Conditions = PWRTS = 00 PWRTS = 01 PWRTS = 10. RST05, Sym. = TOST. RST05, Characteristic = Oscillator Start-up Timer Period (1,2). RST05, Min. = -. RST05, Typ\u2020 = 1024. RST05, Max. = -. RST05, Units = TOSC. RST05, Conditions = . RST06, Sym. = VBOR. RST06, Characteristic = Brown-out Reset Voltage (4). RST06, Min. = 2.7 2.55 2.3 2.3 1.8. RST06, Typ\u2020 = 2.85",
    "Standard Operating Conditions (unless otherwise stated)\n2.7 2.45 2.45 1.9. RST06, Max. = 3.0 2.85 2.6 2.6 2.05. RST06, Units = V V V V V. RST06, Conditions = BORV = 00 BORV = 01 BORV = 10 11 (PIC18Fxxx) 11 (PIC18LFxxx). RST07, Sym. = VBORHYS. RST07, Characteristic = Brown-out Reset Hysteresis. RST07, Min. = -. RST07, Typ\u2020 = 40. RST07, Max. = -. RST07, Units = mV. RST07, Conditions = . RST08, Sym. = TBORDC. RST08, Characteristic = Brown-out Reset Response Time. RST08, Min. = -. RST08, Typ\u2020 = 3. RST08, Max. = -. RST08, Units = \uf06d s. RST08, Conditions = . RST09,",
    "Standard Operating Conditions (unless otherwise stated)\nSym. = VLPBOR. RST09, Characteristic = Low-Power Brown-out Reset Voltage. RST09, Min. = 1.8. RST09, Typ\u2020 = 1.9. RST09, Max. = 2.2. RST09, Units = V. RST09, Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: By design, the Oscillator Start-up Timer (OST) counts the first 1024 cycles, independent of frequency.\n2: To ensure these voltage tolerances, VDD and VSS must be capacitively decoupled as close to the device as possible. 0.1 \uf06d F and 0.01 \uf06d F values in parallel are recommended.",
    "Standard Operating Conditions (unless otherwise stated)\nHLVD01, Symbol = V DET. HLVD01, Characteristic = Voltage Detection. HLVD01, Min. = -. HLVD01, Typ\u2020 = 1.90. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = SEL<3:0>= 0000. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 2.10. , Max. = -. , Units = V. , Conditions = SEL<3:0>= 0001. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 2.25. , Max. = -. , Units = V. , Conditions = SEL<3:0>= 0010. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 2.50. , Max. = -. , Units = V. , Conditions = SEL<3:0>= 0011. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 2.60. ,",
    "Standard Operating Conditions (unless otherwise stated)\nMax. = -. , Units = V. , Conditions = SEL<3:0>= 0100. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 2.75. , Max. = -. , Units = V. , Conditions = SEL<3:0>= 0101. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 2.90. , Max. = -. , Units = V. , Conditions = SEL<3:0>= 0110. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 3.15. , Max. = -. , Units = V. , Conditions = SEL<3:0>= 0111. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 3.35. , Max. = -. , Units = V. , Conditions = SEL<3:0>= 1000. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 3.60. , Max. = -. , Units =",
    "Standard Operating Conditions (unless otherwise stated)\nV. , Conditions = SEL<3:0>= 1001. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 3.75. , Max. = -. , Units = V. , Conditions = SEL<3:0>= 1010. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 4.00. , Max. = -. , Units = V. , Conditions = SEL<3:0>= 1011. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 4.20. , Max. = -. , Units = V. , Conditions = SEL<3:0>= 1100. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 4.35. , Max. = -. , Units = V. , Conditions = SEL<3:0>= 1101. , Symbol = . , Characteristic = . , Min. = -. , Typ\u2020 = 4.65. , Max. = -. , Units = V. , Conditions =",
    "Standard Operating Conditions (unless otherwise stated)\nSEL<3:0>= 1110",
    "TABLE 45-13: ANALOG-TO-DIGITAL CONVERTER (ADC) ACCURACY SPECIFICATIONS (1,2) :\nOperating Conditions (unless otherwise stated)\nVDD = 3.0V, TA = 25\u00b0C, TAD = 1 \uf06d s",
    "TABLE 45-13: ANALOG-TO-DIGITAL CONVERTER (ADC) ACCURACY SPECIFICATIONS (1,2) :\nAD01, Sym. = NR. AD01, Characteristic = Resolution. AD01, Min. = -. AD01, Typ\u2020 = -. AD01, Max. = 12. AD01, Units = bit. AD01, Conditions = . AD02, Sym. = EIL. AD02, Characteristic = Integral Error. AD02, Min. = -. AD02, Typ\u2020 = \u00b10.1. AD02, Max. = \u00b12.0. AD02, Units = LSb. AD02, Conditions = ADCREF+ = 3.0V, ADCREF-= 0V. AD03, Sym. = EDL. AD03, Characteristic = Differential Error. AD03, Min. = -. AD03, Typ\u2020 = \u00b10.1. AD03, Max. = \u00b11.0. AD03, Units = LSb. AD03, Conditions = ADCREF+ = 3.0V, ADCREF-= 0V. AD04,",
    "TABLE 45-13: ANALOG-TO-DIGITAL CONVERTER (ADC) ACCURACY SPECIFICATIONS (1,2) :\nSym. = EOFF. AD04, Characteristic = Offset Error. AD04, Min. = -. AD04, Typ\u2020 = 0.5. AD04, Max. = 6.0. AD04, Units = LSb. AD04, Conditions = ADCREF+ = 3.0V, ADCREF-= 0V. AD05, Sym. = EGN. AD05, Characteristic = Gain Error. AD05, Min. = -. AD05, Typ\u2020 = \u00b10.2. AD05, Max. = \u00b16.0. AD05, Units = LSb. AD05, Conditions = ADCREF+ = 3.0V, ADCREF-= 0V. AD06, Sym. = VADREF. AD06, Characteristic = ADC Reference Voltage (ADREF+ - ADREF-). AD06, Min. = 1.8. AD06, Typ\u2020 = -. AD06, Max. =",
    "TABLE 45-13: ANALOG-TO-DIGITAL CONVERTER (ADC) ACCURACY SPECIFICATIONS (1,2) :\nVDD. AD06, Units = V. AD06, Conditions = . AD07, Sym. = VAIN. AD07, Characteristic = Full-Scale Range. AD07, Min. = ADREF-. AD07, Typ\u2020 = -. AD07, Max. = ADREF+. AD07, Units = V. AD07, Conditions = . AD08, Sym. = ZAIN. AD08, Characteristic = Recommended Impedance of Analog Voltage Source. AD08, Min. = -. AD08, Typ\u2020 = 10. AD08, Max. = -. AD08, Units = k \uf057. AD08, Conditions = . AD09, Sym. = RVREF. AD09, Characteristic = ADC Voltage Reference Ladder Impedance. AD09, Min. = -. AD09, Typ\u2020 = 50. AD09, Max. = -. AD09, Units = k \uf057. AD09, Conditions = Note 3",
    "TABLE 45-13: ANALOG-TO-DIGITAL CONVERTER (ADC) ACCURACY SPECIFICATIONS (1,2) :\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1:\nTotal Absolute Error is the sum of the offset, gain and integral non-linearity (INL) errors.\n2: The ADC conversion result never decreases with an increase in the input and has no missing codes.\n3: This is the impedance seen by the VREF pads when the external reference pads are selected.",
    "Standard Operating Conditions (unless otherwise stated)\nAD20, Sym. = TAD. AD20, Characteristic = ADC Clock Period. AD20, Min. = 0.5. AD20, Typ\u2020 = -. AD20, Max. = 9. AD20, Units = \uf06d s. AD20, Conditions = Using FOSC as the ADC clock source ADCS = 0. AD21, Sym. = TAD. AD21, Characteristic = ADC Clock Period. AD21, Min. = -. AD21, Typ\u2020 = 2. AD21, Max. = -. AD21, Units = \uf06d s. AD21, Conditions = Using ADCRC as the ADC clock source ADCS = 1. AD22, Sym. = TCNV. AD22, Characteristic = Conversion Time (1). AD22, Min. = -. AD22, Typ\u2020 = 14 TAD+2 TCY. AD22, Max. = -. AD22, Units = -. AD22, Conditions = Using FOSC as the ADC clock source ADCS = 1. AD22, Sym. = TCNV. AD22, Characteristic = Conversion Time (1). AD22,",
    "Standard Operating Conditions (unless otherwise stated)\nMin. = -. AD22, Typ\u2020 = 16 TAD+2 TCY. AD22, Max. = -. AD22, Units = -. AD22, Conditions = Using ADCRC as the ADC clock source ADCS = 0. AD24, Sym. = THCD. AD24, Characteristic = Sample and Hold Capacitor Disconnect Time. AD24, Min. = -. AD24, Typ\u2020 = 2 T AD+1 TCY. AD24, Max. = -. AD24, Units = -. AD24, Conditions = Using FOSC as the ADC clock source ADCS = 1. AD24, Sym. = THCD. AD24, Characteristic = Sample and Hold Capacitor Disconnect Time. AD24, Min. = -. AD24, Typ\u2020 = 3 TAD+2 TCY. AD24, Max. = -. AD24, Units = -. AD24, Conditions = Using ADCRC as the ADC clock source ADCS = 0",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: Does not apply for the ADCRC oscillator.",
    "FIGURE 45-10: ADC CONVERSION TIMING (ADC CLOCK FOSC-BASED)\n6/1/2017",
    "ADC CONVERSION TIMING (ADC CLOCK FROM ADCRC)\nNote 1: If the ADC clock source is selected as ADCRC, a time of TCY is added before the ADC clock starts. This allows the SLEEP instruction to be executed.",
    "TABLE 45-15: COMPARATOR SPECIFICATIONS\nOperating Conditions (unless otherwise stated)\nVDD = 3.0V, TA = 25\u00b0C",
    "TABLE 45-15: COMPARATOR SPECIFICATIONS\nCM01, Sym. = VIOFF. CM01, Characteristics = Input Offset Voltage. CM01, Min. = -. CM01, Typ. = -. CM01, Max. = \u00b140. CM01, Comments = VICM = VDD/2. CM02, Sym. = VICM. CM02, Characteristics = Input Common Mode Range. CM02, Min. = GND. CM02, Typ. = -. CM02, Max. = VDD. CM02, Comments = V. CM03, Sym. = CMRR. CM03, Characteristics = Common Mode Input Rejection Ratio. CM03, Min. = -. CM03, Typ. = 50. CM03, Max. = -. CM03, Comments = dB. CM04, Sym. = VHYST. CM04, Characteristics = Comparator Hysteresis. CM04, Min. = 10. CM04, Typ. = 25. CM04, Max. = 40. CM04, Comments = mV. CM05, Sym. =",
    "TABLE 45-15: COMPARATOR SPECIFICATIONS\nTRESP (1). CM05, Characteristics = Response Time, Rising Edge. CM05, Min. = -. CM05, Typ. = 300. CM05, Max. = 600. CM05, Comments = ns. , Sym. = . , Characteristics = Response Time, Falling Edge. , Min. = -. , Typ. = 220. , Max. = 500. , Comments = ns\n- * These parameters are characterized but not tested.\nNote\n1: Response time measured with one comparator input at VDD/2, while the other input transitions from VSS to VDD.\n2: A mode change includes changing any of the control register values, including module enable.",
    "TABLE 45-16: 5-BIT DAC SPECIFICATIONS\nStandard Operating Conditions (unless otherwise stated)\nVDD = 3.0V, TA = 25\u00b0C",
    "TABLE 45-16: 5-BIT DAC SPECIFICATIONS\nDSB01, Sym. = VLSB. DSB01, Characteristics = Step Size. DSB01, Min. = -. DSB01, Typ. = (V DACREF + -V DACREF -) 32. DSB01, Max. = -. DSB01, Units = V. DSB01, Comments = . DSB01, Sym. = VACC. DSB01, Characteristics = Absolute Accuracy. DSB01, Min. = -. DSB01, Typ. = -. DSB01, Max. = \uf0b1 0.5. DSB01, Units = LSb. DSB01, Comments = . DSB03*, Sym. = RUNIT. DSB03*, Characteristics = Unit Resistor Value. DSB03*, Min. = -. DSB03*, Typ. = 5000. DSB03*, Max. = -. DSB03*, Units = \uf057. DSB03*, Comments = . DSB04*, Sym. = TST. DSB04*, Characteristics = Settling Time",
    "TABLE 45-16: 5-BIT DAC SPECIFICATIONS\n(1). DSB04*, Min. = -. DSB04*, Typ. = -. DSB04*, Max. = 10. DSB04*, Units = \uf06d s. DSB04*, Comments = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote\n- 1: Settling time measured while DACR<4:0> transitions from ' 00000 ' to ' 01111 '.",
    "TABLE 45-17: FIXED VOLTAGE REFERENCE (FVR) SPECIFICATIONS\nStandard Operating Conditions (unless otherwise stated)",
    "TABLE 45-17: FIXED VOLTAGE REFERENCE (FVR) SPECIFICATIONS\nFVR01, Symbol = VFVR1. FVR01, Characteristic = 1x Gain (1.024V). FVR01, Min. = -4. FVR01, Typ. = -. FVR01, Max. = +4. FVR01, Units = %. FVR01, Conditions = VDD \uf0b3 2.5V, -40\u00b0C to 85\u00b0C. FVR02, Symbol = VFVR2. FVR02, Characteristic = 2x Gain (2.048V). FVR02, Min. = -4. FVR02, Typ. = -. FVR02, Max. = +4. FVR02, Units = %. FVR02, Conditions = VDD \uf0b3 2.5V, -40\u00b0C to 85\u00b0C. FVR03, Symbol = VFVR4. FVR03, Characteristic = 4x Gain (4.096V). FVR03, Min. = -5. FVR03, Typ. = -. FVR03, Max. =",
    "TABLE 45-17: FIXED VOLTAGE REFERENCE (FVR) SPECIFICATIONS\n+5. FVR03, Units = %. FVR03, Conditions = VDD \uf0b3 4.75V, -40\u00b0C to 85\u00b0C. FVR04, Symbol = TFVRST. FVR04, Characteristic = FVR Start-up Time. FVR04, Min. = -. FVR04, Typ. = 25. FVR04, Max. = -. FVR04, Units = us. FVR04, Conditions = ",
    "TABLE 45-18: ZERO CROSS DETECT (ZCD) SPECIFICATIONS\nStandard Operating Conditions (unless otherwise stated)\nVDD = 3.0V, TA = 25\u00b0C",
    "TABLE 45-18: ZERO CROSS DETECT (ZCD) SPECIFICATIONS\nZC01, Sym. = VPINZC. ZC01, Characteristics = Voltage on Zero Cross Pin. ZC01, Min = -. ZC01, Typ\u2020 = 0.75. ZC01, Max = -. ZC01, Units = V. ZC01, Comments = . ZC02, Sym. = I ZCD _ MAX. ZC02, Characteristics = Maximum source or sink current. ZC02, Min = -. ZC02, Typ\u2020 = -. ZC02, Max = 600. ZC02, Units = \uf06d A. ZC02, Comments = . ZC03, Sym. = TRESPH. ZC03, Characteristics = Response Time, Rising Edge. ZC03, Min = -. ZC03, Typ\u2020 = 1. ZC03, Max = -. ZC03, Units = \uf06d s. ZC03, Comments = . , Sym. = TRESPL. , Characteristics = Response Time, Falling Edge. , Min = -. , Typ\u2020 = 1. ,",
    "TABLE 45-18: ZERO CROSS DETECT (ZCD) SPECIFICATIONS\nMax = -. , Units = \uf06d s. , Comments = \n- \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Standard Operating Conditions (unless otherwise stated)\nOperating Temperature  -40\u00b0C \uf0a3\uf020 TA \uf0a3\uf020 +125\u00b0C",
    "Standard Operating Conditions (unless otherwise stated)\n40*, Sym. = TT0H. 40*, Characteristic = T0CKI High Pulse Width No Prescaler. 40*, Characteristic = T0CKI High Pulse Width No Prescaler. 40*, Min. = 0.5 TCY + 20. 40*, Typ\u2020 = -. 40*, Max. = -. 40*, Units = ns. 40*, Conditions = . 40*, Sym. = TT0H. 40*, Characteristic = . 40*, Characteristic = . 40*, Min. = 10. 40*, Typ\u2020 = -. 40*, Max. = -. 40*, Units = ns. 40*, Conditions = . 41*, Sym. = TT0L. 41*, Characteristic = T0CKI Low Pulse Width No Prescaler. 41*, Characteristic = T0CKI Low Pulse Width No Prescaler. 41*, Min. = 0.5 TCY + 20. 41*, Typ\u2020 = -. 41*, Max. = -. 41*, Units = ns. 41*, Conditions = . 41*, Sym. = TT0L.",
    "Standard Operating Conditions (unless otherwise stated)\n41*, Characteristic = . 41*, Characteristic = . 41*, Min. = 10. 41*, Typ\u2020 = -. 41*, Max. = -. 41*, Units = ns. 41*, Conditions = . 42*, Sym. = TT0P. 42*, Characteristic = T0CKI Period. 42*, Characteristic = T0CKI Period. 42*, Min. = Greater of: 20 or TCY + 40 N. 42*, Typ\u2020 = -. 42*, Max. = -. 42*, Units = ns. 42*, Conditions = N = prescale value. 45*, Sym. = TT1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Synchronous, No Prescaler. 45*, Min. = 0.5 TCY + 20. 45*, Typ\u2020 = -. 45*, Max. = -. 45*, Units = ns. 45*, Conditions = . 45*, Sym. = TT1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Synchronous, with",
    "Standard Operating Conditions (unless otherwise stated)\nPrescaler. 45*, Min. = 15. 45*, Typ\u2020 = -. 45*, Max. = -. 45*, Units = ns. 45*, Conditions = . 45*, Sym. = TT1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Asynchronous. 45*, Min. = 30. 45*, Typ\u2020 = -. 45*, Max. = -. 45*, Units = ns. 45*, Conditions = . 46*, Sym. = TT1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Synchronous, No Prescaler. 46*, Min. = 0.5 TCY + 20. 46*, Typ\u2020 = -. 46*, Max. = -. 46*, Units = ns. 46*, Conditions = . 46*, Sym. = TT1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Synchronous, with Prescaler. 46*, Min. = 15. 46*, Typ\u2020 = -.",
    "Standard Operating Conditions (unless otherwise stated)\n46*, Max. = -. 46*, Units = ns. 46*, Conditions = . 46*, Sym. = TT1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Asynchronous. 46*, Min. = 30. 46*, Typ\u2020 = -. 46*, Max. = -. 46*, Units = ns. 46*, Conditions = . 47*, Sym. = TT1P. 47*, Characteristic = T1CKI Input Period. 47*, Characteristic = Synchronous. 47*, Min. = Greater of: 30 or TCY + 40 N. 47*, Typ\u2020 = -. 47*, Max. = -. 47*, Units = ns. 47*, Conditions = N = prescale value. 47*, Sym. = TT1P. 47*, Characteristic = T1CKI Input Period. 47*, Characteristic = Asynchronous. 47*, Min. = 60. 47*, Typ\u2020 = -. 47*, Max. = -. 47*, Units = ns. 47*, Conditions = .",
    "Standard Operating Conditions (unless otherwise stated)\n49*, Sym. = TCKEZTMR1. 49*, Characteristic = Delay from External Clock Edge to Timer Increment. 49*, Characteristic = Delay from External Clock Edge to Timer Increment. 49*, Min. = 2 TOSC. 49*, Typ\u2020 = -. 49*, Max. = 7 TOSC. 49*, Units = -. 49*, Conditions = Timers in Sync mode\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nOperating Temperature -40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C",
    "Standard Operating Conditions (unless otherwise stated)\nCC01*, Sym. = TccL. CC01*, Characteristic = CCPx Input Low Time. CC01*, Characteristic = No Prescaler. CC01*, Min. = 0.5T CY + 20. CC01*, Typ\u2020 = -. CC01*, Max. = -. CC01*, Conditions = ns. , Sym. = . , Characteristic = . , Characteristic = With Prescaler. , Min. = 20. , Typ\u2020 = -. , Max. = -. , Conditions = ns. CC02*, Sym. = TccH. CC02*, Characteristic = CCPx Input High Time. CC02*, Characteristic = No Prescaler. CC02*, Min. = 0.5T CY + 20. CC02*, Typ\u2020 = -. CC02*, Max. = -. CC02*, Conditions = ns. , Sym. = . , Characteristic = . , Characteristic = With Prescaler. , Min. = 20. , Typ\u2020 = -. , Max. = -. , Conditions = ns.",
    "Standard Operating Conditions (unless otherwise stated)\nCC03*, Sym. = TccP. CC03*, Characteristic = CCPx Input Period. CC03*, Characteristic = . CC03*, Min. = 3TCY + 40 N. CC03*, Typ\u2020 = -. CC03*, Max. = -. CC03*, Conditions = N = prescale value\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFIGURE 45-14: SPI MASTER MODE TIMING (CKE = 0 , SMP = 0 )\nNote: Refer to Figure 45-4 for load conditions.\nFIGURE 45-15: SPI MASTER MODE TIMING (CKE = 1 , SMP = 1 )",
    "TABLE 45-21: SPI MODE REQUIREMENTS (MASTER MODE)\nStandard Operating Conditions (unless otherwise stated)",
    "TABLE 45-21: SPI MODE REQUIREMENTS (MASTER MODE)\n, Symbol = TSCK. , Characteristic = SCK Cycle Time (2x Prescaled). , Min. = 61. , Typ\u2020 = -. , Max. = -. , Units = ns. , Conditions = Transmit only mode. , Symbol = TSCK. , Characteristic = SCK Cycle Time (2x Prescaled). , Min. = -. , Typ\u2020 = 16 (1). , Max. = -. , Units = MHz. , Conditions = Transmit only mode. , Symbol = TSCK. , Characteristic = SCK Cycle Time (2x Prescaled). , Min. = 95. , Typ\u2020 = -. , Max. = -. , Units = ns. , Conditions = Full-duplex mode. , Symbol = TSCK. , Characteristic = SCK Cycle Time (2x Prescaled). , Min. = -. , Typ\u2020 = 10 (1). , Max. = -. , Units = MHz. , Conditions = Full-duplex mode. SP70*, Symbol = TSSL2SCH, TSSL2SCL. SP70*, Characteristic = SDO",
    "TABLE 45-21: SPI MODE REQUIREMENTS (MASTER MODE)\nto SCK \uf0af or SCK \uf0ad input. SP70*, Min. = TSCK. SP70*, Typ\u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = FST = 0. SP70*, Symbol = TSSL2SCH, TSSL2SCL. SP70*, Characteristic = SDO to SCK \uf0af or SCK \uf0ad input. SP70*, Min. = 0. SP70*, Typ\u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = FST = 1. SP71*, Symbol = TSCH. SP71*, Characteristic = SCK output high time. SP71*, Min. = 0.5 TSCK - 12. SP71*, Typ\u2020 = -. SP71*, Max. = 0.5 TSCK + 12. SP71*, Units = ns. SP71*, Conditions = . SP72*, Symbol = TSCL. SP72*, Characteristic = SCK output low time.",
    "TABLE 45-21: SPI MODE REQUIREMENTS (MASTER MODE)\nSP72*, Min. = 0.5 TSCK - 12. SP72*, Typ\u2020 = -. SP72*, Max. = 0.5 TSCK + 12. SP72*, Units = ns. SP72*, Conditions = . SP73*, Symbol = TDI V2SCH, TDI V2SCL. SP73*, Characteristic = Setup time of SDI data input to SCK edge. SP73*, Min. = 85. SP73*, Typ\u2020 = -. SP73*, Max. = -. SP73*, Units = ns. SP73*, Conditions = . SP74*, Symbol = TSCH2DIL, TSCL2DI L. SP74*, Characteristic = Hold time of SDI data input to SCK edge. SP74*, Min. = 0. SP74*, Typ\u2020 = -. SP74*, Max. = -. SP74*, Units = ns. SP74*, Conditions = . SP74*, Symbol =",
    "TABLE 45-21: SPI MODE REQUIREMENTS (MASTER MODE)\nTSCH2DIL, TSCL2DI L. SP74*, Characteristic = Hold time of SDI data input to final SCK. SP74*, Min. = 0.5 TSCK. SP74*, Typ\u2020 = -. SP74*, Max. = -. SP74*, Units = ns. SP74*, Conditions = CKE = 0 , SMP = 1. SP75*, Symbol = TDOR. SP75*, Characteristic = SDO data output rise time. SP75*, Min. = -. SP75*, Typ\u2020 = 10. SP75*, Max. = 25. SP75*, Units = ns. SP75*, Conditions = CL = 50 pF. SP76*, Symbol = TDOF. SP76*, Characteristic = SDO data output fall time. SP76*, Min. = -. SP76*, Typ\u2020 = 10. SP76*, Max. = 25. SP76*, Units = ns. SP76*, Conditions = CL = 50 pF.",
    "TABLE 45-21: SPI MODE REQUIREMENTS (MASTER MODE)\nSP78*, Symbol = TSCR. SP78*, Characteristic = SCK output rise time. SP78*, Min. = -. SP78*, Typ\u2020 = 10. SP78*, Max. = 25. SP78*, Units = ns. SP78*, Conditions = CL = 50 pF. SP79*, Symbol = TSCF. SP79*, Characteristic = SCK output fall time. SP79*, Min. = -. SP79*, Typ\u2020 = 10. SP79*, Max. = 25. SP79*, Units = ns. SP79*, Conditions = CL = 50 pF. SP80*, Symbol = TSCH2DOV, TSCL2DOV. SP80*, Characteristic = SDO data output valid after SCK edge. SP80*, Min. = - 15. SP80*, Typ\u2020 = -. SP80*, Max. = 15. SP80*, Units = ns. SP80*, Conditions = CL = 20 pF. SP81*, Symbol =",
    "TABLE 45-21: SPI MODE REQUIREMENTS (MASTER MODE)\nTDOV2SCH, TDOV2SCL. SP81*, Characteristic = SDO data output valid to first SCK edge. SP81*, Min. = TSCK - 10. SP81*, Typ\u2020 = -. SP81*, Max. = -. SP81*, Units = ns. SP81*, Conditions = CL = 20 pF CKE = 1. SP82*, Symbol = TSSL2DOV. SP82*, Characteristic = SDO data output valid after SS \uf0af edge. SP82*, Min. = -. SP82*, Typ\u2020 = -. SP82*, Max. = 50. SP82*, Units = ns. SP82*, Conditions = CL = 20 pF. SP83*, Symbol = TSCH2SSH, TSCL2SSH. SP83*, Characteristic = SS \uf0ad\uf020 after last SCK edge. SP83*, Min. = 0.5 TSCK - 10. SP83*, Typ\u2020 = -. SP83*, Max. = -.",
    "TABLE 45-21: SPI MODE REQUIREMENTS (MASTER MODE)\nSP83*, Units = ns. SP83*, Conditions = . SP84*, Symbol = TSSH2SSL. SP84*, Characteristic = SS \uf0ad\uf020 to \uf020 SS \uf0af\uf020 edge. SP84*, Min. = 0.5 TSCK - 10. SP84*, Typ\u2020 = -. SP84*, Max. = -. SP84*, Units = ns. SP84*, Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: SPIxCON1.SMP bit must be set and the slew rate control must be disabled on the clock and data pins (clear the corre -sponding bits in SLRCONx register) for SPI to operate over 4 MHz.",
    "Standard Operating Conditions (unless otherwise stated)\n, Symbol = TSCK. , Characteristic = SCK Total Cycle Time. , Min. = 47. , Typ\u2020 = -. , Max. = -. , Units = ns. , Conditions = Receive only mode. , Symbol = TSCK. , Characteristic = SCK Total Cycle Time. , Min. = -. , Typ\u2020 = 20 (1). , Max. = -. , Units = MHz. , Conditions = Receive only mode. , Symbol = TSCK. , Characteristic = SCK Total Cycle Time. , Min. = 95. , Typ\u2020 = -. , Max. = -. , Units = ns. , Conditions = Full duplex mode. , Symbol = TSCK. , Characteristic = SCK Total Cycle Time. , Min. = -. , Typ\u2020 = 10 (1). , Max. = -. , Units = MHz. , Conditions = Full duplex mode. SP70*, Symbol = TSSL2SCH, TSSL2SCL. SP70*, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad input. SP70*, Min. = 0. SP70*, Typ\u2020 = -. SP70*,",
    "Standard Operating Conditions (unless otherwise stated)\nMax. = -. SP70*, Units = ns. SP70*, Conditions = CKE = 0. SP70*, Symbol = TSSL2SCH, TSSL2SCL. SP70*, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad input. SP70*, Min. = 25. SP70*, Typ\u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = CKE = 1. SP71*, Symbol = TSCH. SP71*, Characteristic = SCK input high time. SP71*, Min. = 20. SP71*, Typ\u2020 = -. SP71*, Max. = -. SP71*, Units = ns. SP71*, Conditions = . SP72*, Symbol = TSCL. SP72*, Characteristic = SCK input low time. SP72*, Min. = 20. SP72*, Typ\u2020 = -. SP72*, Max. = -. SP72*, Units = ns. SP72*, Conditions = .",
    "Standard Operating Conditions (unless otherwise stated)\nSP73*, Symbol = TDI V2SCH, TDI V2SCL. SP73*, Characteristic = Setup time of SDI data input to SCK edge. SP73*, Min. = 10. SP73*, Typ\u2020 = -. SP73*, Max. = -. SP73*, Units = ns. SP73*, Conditions = . SP74*, Symbol = TSCH2DIL, TSCL2DI L. SP74*, Characteristic = Hold time of SDI data input to SCK edge. SP74*, Min. = 0. SP74*, Typ\u2020 = -. SP74*, Max. = -. SP74*, Units = ns. SP74*, Conditions = . SP75*, Symbol = TDOR. SP75*, Characteristic = SDO data output rise time. SP75*, Min. = -. SP75*, Typ\u2020 = 10. SP75*, Max. = 25. SP75*, Units = ns. SP75*, Conditions = CL = 50 pF. SP76*,",
    "Standard Operating Conditions (unless otherwise stated)\nSymbol = TDOF. SP76*, Characteristic = SDO data output fall time. SP76*, Min. = -. SP76*, Typ\u2020 = 10. SP76*, Max. = 25. SP76*, Units = ns. SP76*, Conditions = CL = 50 pF. SP77*, Symbol = TSSH2DOZ. SP77*, Characteristic = SS \uf0ad to SDO output high-impedance. SP77*, Min. = -. SP77*, Typ\u2020 = -. SP77*, Max. = 85. SP77*, Units = ns. SP77*, Conditions = . SP80*, Symbol = TSCH2DOV, TSCL2DOV. SP80*, Characteristic = SDO data output valid after SCK edge. SP80*, Min. = -. SP80*, Typ\u2020 = -. SP80*, Max. = 85. SP80*, Units = ns. SP80*, Conditions = . SP82*, Symbol = TSSL2DOV. SP82*, Characteristic =",
    "Standard Operating Conditions (unless otherwise stated)\nSDO data output valid after SS \uf0af edge. SP82*, Min. = -. SP82*, Typ\u2020 = -. SP82*, Max. = 85. SP82*, Units = ns. SP82*, Conditions = . SP83*, Symbol = TSCH2SSH, TSCL2SSH. SP83*, Characteristic = SS \uf0ad\uf020 after SCK edge. SP83*, Min. = 20. SP83*, Typ\u2020 = -. SP83*, Max. = -. SP83*, Units = ns. SP83*, Conditions = . SP84*, Symbol = TSSH2SSL. SP84*, Characteristic = SS \uf0ad\uf020 to \uf020 SS \uf0af\uf020 edge. SP84*, Min. = 47. SP84*, Typ\u2020 = -. SP84*, Max. = -. SP84*, Units = ns. SP84*, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: SPIxCON1.SMP bit must be set and the slew rate control must be disabled on the clock and data pins (clear the corre -sponding bits in SLRCONx register) for SPI to operate over 4 MHz.",
    "Standard Operating Conditions (unless otherwise stated)\nSP90*, Symbol = TSU: STA. SP90*, Characteristic = Start condition Setup time. SP90*, Characteristic = 100 kHz mode. SP90*, Min. = 4700. SP90*, Typ = -. SP90*, Max. = -. SP90*, Units = ns. SP90*, Conditions = Only relevant for Repeated Start condition. SP90*, Symbol = TSU: STA. SP90*, Characteristic = Start condition Setup time. SP90*, Characteristic = 400 kHz mode. SP90*, Min. = 600. SP90*, Typ = -. SP90*, Max. = -. SP90*, Units = ns. SP90*, Conditions = Only relevant for Repeated Start condition. SP90*, Symbol = TSU: STA. SP90*, Characteristic = Start condition Setup time. SP90*, Characteristic = 1 MHz mode. SP90*, Min. = 260. SP90*, Typ = -. SP90*, Max. = -. SP90*, Units = ns. SP90*, Conditions = Only relevant for Repeated Start condition.",
    "Standard Operating Conditions (unless otherwise stated)\nSP91*, Symbol = THD: STA. SP91*, Characteristic = Start condition Hold time. SP91*, Characteristic = 100 kHz mode. SP91*, Min. = 4000. SP91*, Typ = -. SP91*, Max. = -. SP91*, Units = ns. SP91*, Conditions = After this period, the first clock pulse is generated. SP91*, Symbol = THD: STA. SP91*, Characteristic = Start condition Hold time. SP91*, Characteristic = 400 kHz mode. SP91*, Min. = 600. SP91*, Typ = -. SP91*, Max. = -. SP91*, Units = ns. SP91*, Conditions = After this period, the first clock pulse is generated. SP91*, Symbol = THD: STA. SP91*, Characteristic = Start condition Hold time. SP91*, Characteristic = 1 MHz mode. SP91*, Min. = 260. SP91*, Typ = -. SP91*,",
    "Standard Operating Conditions (unless otherwise stated)\nMax. = -. SP91*, Units = ns. SP91*, Conditions = After this period, the first clock pulse is generated. SP92*, Symbol = TSU: STO. SP92*, Characteristic = Stop condition. SP92*, Characteristic = 100 kHz mode. SP92*, Min. = 4000. SP92*, Typ = -. SP92*, Max. = -. SP92*, Units = ns. SP92*, Conditions = . SP92*, Symbol = TSU: STO. SP92*, Characteristic = Setup time. SP92*, Characteristic = 400 kHz mode. SP92*, Min. = 600. SP92*, Typ = -. SP92*, Max. = -. SP92*, Units = ns. SP92*, Conditions = . SP92*, Symbol = TSU: STO. SP92*, Characteristic = Setup time. SP92*, Characteristic = 1 MHz mode. SP92*, Min. = 260. SP92*, Typ = -.",
    "Standard Operating Conditions (unless otherwise stated)\nSP92*, Max. = -. SP92*, Units = ns. SP92*, Conditions = . SP93, Symbol = THD: STO. SP93, Characteristic = Stop condition. SP93, Characteristic = 100 kHz mode. SP93, Min. = 4700. SP93, Typ = -. SP93, Max. = -. SP93, Units = ns. SP93, Conditions = . SP93, Symbol = THD: STO. SP93, Characteristic = Hold time. SP93, Characteristic = 400 kHz mode. SP93, Min. = 1300. SP93, Typ = -. SP93, Max. = -. SP93, Units = ns. SP93, Conditions = . SP93, Symbol = THD: STO. SP93, Characteristic = Hold time. SP93, Characteristic = 1 MHz mode. SP93, Min. = 500. SP93, Typ = -. SP93, Max. = -. SP93, Units = ns. SP93, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\n- * These parameters are characterized but not tested.",
    "Standard Operating Conditions (unless otherwise stated)\nSP100*, Symbol = THIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = 100 kHz mode. SP100*, Min. = 4000. SP100*, Max. = -. SP100*, Units = ns. SP100*, Conditions = Device must operate at a minimum of 1.5 MHz. SP100*, Symbol = THIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = 400 kHz mode. SP100*, Min. = 600. SP100*, Max. = -. SP100*, Units = ns. SP100*, Conditions = Device must operate at a minimum of 10 MHz. SP100*, Symbol = THIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = 1 MHz mode. SP100*, Min. = 260. SP100*, Max. = -. SP100*, Units = ns. SP100*, Conditions = Device must operate at a minimum of 10 MHz. SP101*, Symbol = TLOW. SP101*, Characteristic = Clock low time. SP101*, Characteristic = 100 kHz mode.",
    "Standard Operating Conditions (unless otherwise stated)\nSP101*, Min. = 4700. SP101*, Max. = -. SP101*, Units = ns. SP101*, Conditions = Device must operate at a minimum of 1.5 MHz. SP101*, Symbol = TLOW. SP101*, Characteristic = Clock low time. SP101*, Characteristic = 400 kHz mode. SP101*, Min. = 1300. SP101*, Max. = -. SP101*, Units = ns. SP101*, Conditions = Device must operate at a minimum of 10 MHz. SP101*, Symbol = TLOW. SP101*, Characteristic = Clock low time. SP101*, Characteristic = 1 MHz mode. SP101*, Min. = 500. SP101*, Max. = -. SP101*, Units = -. SP101*, Conditions = Device must operate at a minimum of 10 MHz. SP102*, Symbol = TR. SP102*, Characteristic = SDAand SCL rise time. SP102*, Characteristic = 100 kHz mode. SP102*, Min. =",
    "Standard Operating Conditions (unless otherwise stated)\n-. SP102*, Max. = 1000. SP102*, Units = ns. SP102*, Conditions = . SP102*, Symbol = TR. SP102*, Characteristic = SDAand SCL rise time. SP102*, Characteristic = 400 kHz mode. SP102*, Min. = 20. SP102*, Max. = 300. SP102*, Units = ns. SP102*, Conditions = CB is specified to be from 10-400 pF. SP102*, Symbol = TR. SP102*, Characteristic = SDAand SCL rise time. SP102*, Characteristic = 1 MHz mode. SP102*, Min. = -. SP102*, Max. = 120. SP102*, Units = ns. SP102*, Conditions = . SP103*, Symbol = TF. SP103*, Characteristic = SDAand SCL fall time. SP103*, Characteristic = 100 kHz mode. SP103*, Min. = -. SP103*, Max. = 250. SP103*, Units =",
    "Standard Operating Conditions (unless otherwise stated)\nns. SP103*, Conditions = . SP103*, Symbol = TF. SP103*, Characteristic = SDAand SCL fall time. SP103*, Characteristic = 400 kHz mode. SP103*, Min. = 20 X (V DD/ 5.5V). SP103*, Max. = 250. SP103*, Units = ns. SP103*, Conditions = CB is specified to be from 10-400 pF. SP103*, Symbol = TF. SP103*, Characteristic = SDAand SCL fall time. SP103*, Characteristic = 1 MHz mode. SP103*, Min. = 20 X (V DD/ 5.5V). SP103*, Max. = 120. SP103*, Units = ns. SP103*, Conditions = . SP106*, Symbol = THD: DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 100 kHz mode. SP106*, Min. = 0. SP106*, Max. = -. SP106*, Units",
    "Standard Operating Conditions (unless otherwise stated)\n= ns. SP106*, Conditions = . SP106*, Symbol = THD: DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 400 kHz mode. SP106*, Min. = 0. SP106*, Max. = -. SP106*, Units = ns. SP106*, Conditions = . SP106*, Symbol = THD: DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 1 MHz mode. SP106*, Min. = 0. SP106*, Max. = -. SP106*, Units = ns. SP106*, Conditions = . SP107*, Symbol = TSU: DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 100 kHz mode. SP107*, Min. = 250. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = ( 2 ). SP107*, Symbol = TSU: DAT. SP107*, Characteristic",
    "Standard Operating Conditions (unless otherwise stated)\n= Data input setup time. SP107*, Characteristic = 400 kHz mode. SP107*, Min. = 100. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = . SP107*, Symbol = TSU: DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 1 MHz mode. SP107*, Min. = 50. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = . SP109*, Symbol = TAA. SP109*, Characteristic = Output valid from clock. SP109*, Characteristic = 100 kHz mode. SP109*, Min. = -. SP109*, Max. = 3450. SP109*, Units = ns. SP109*, Conditions = ( 1 ). SP109*, Symbol = TAA. SP109*, Characteristic = Output valid from clock. SP109*, Characteristic = 400 kHz mode. SP109*, Min. = -. SP109*,",
    "Standard Operating Conditions (unless otherwise stated)\nMax. = 900. SP109*, Units = ns. SP109*, Conditions = ( 1 ). SP109*, Symbol = TAA. SP109*, Characteristic = Output valid from clock. SP109*, Characteristic = 1 MHz mode. SP109*, Min. = -. SP109*, Max. = 450. SP109*, Units = ns. SP109*, Conditions = ( 1 ). SP110*, Symbol = TBUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 100 kHz mode. SP110*, Min. = 4700. SP110*, Max. = -. SP110*, Units = ns. SP110*, Conditions = Time the bus must be free before a new transmission can start. SP110*, Symbol = TBUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 400 kHz mode. SP110*, Min. = 1300. SP110*, Max. = -. SP110*, Units = ns. SP110*, Conditions =",
    "Standard Operating Conditions (unless otherwise stated)\nTime the bus must be free before a new transmission can start. SP110*, Symbol = TBUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 1 MHz mode. SP110*, Min. = 500. SP110*, Max. = -. SP110*, Units = ns. SP110*, Conditions = . SP111, Symbol = CB. SP111, Characteristic = Bus capacitive loading. SP111, Characteristic = Bus capacitive loading. SP111, Min. = -. SP111, Max. = 400. SP111, Units = pF. SP111, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\nNote 1: As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2: A Fast mode (400 kHz) I 2 C bus device can be used in a Standard mode (100 kHz) I 2 C bus system, but the requirement TSU:DAT \uf0b3\uf020 250 ns must then be met. This will automatically be the case if the device does not stretch the low period of the SCL signal. If such a device does stretch the low period of the SCL signal, it must output the next data bit to the SDA line TR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification), before the SCL line is released.",
    "Standard Operating Conditions (unless otherwise stated)\nTS01*, Symbol = TACQMIN. TS01*, Characteristic = Minimum ADCAcquisition Time Delay. TS01*, Characteristic = Minimum ADCAcquisition Time Delay. TS01*, Min. = -. TS01*, Typ\u2020 = 25. TS01*, Max. = -. TS01*, Units = \u00b5s. TS01*, Conditions = . TS02*, Symbol = MV. TS02*, Characteristic = Voltage Sensitivity. TS02*, Characteristic = High Range. TS02*, Min. = -. TS02*, Typ\u2020 = -3.684. TS02*, Max. = -. TS02*, Units = mV/\u00b0C. TS02*, Conditions = TSRNG = 1. TS02*, Symbol = MV. TS02*, Characteristic = Voltage Sensitivity. TS02*, Characteristic = Low Range. TS02*, Min. = -. TS02*, Typ\u2020 = -2.456. TS02*, Max. = -. TS02*, Units =",
    "Standard Operating Conditions (unless otherwise stated)\nmV/\u00b0C. TS02*, Conditions = TSRNG = 0\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "46.0 DC AND AC CHARACTERISTICS GRAPHS AND CHARTS\nThe graphs and tables provided in this section are for design guidance and are not tested .\nIn  some graphs or tables, the data presented are outside specified operating range (i.e.,  outside  specified  VDD range). This is for information only and devices are ensured to operate properly only within the specified range.\nUnless otherwise noted, all graphs apply to both the L and LF devices.\nNote:\nThe graphs and tables provided following this note are a statistical summary based on a limited number of samples and are provided for informational purposes only. The performance characteristics listed herein are not tested or guaranteed. In some graphs or tables, the data presented may be outside the specified operating range (e.g., outside specified power supply range) and therefore, outside the warranted range.\n'Typical' represents the mean of the distribution at 25 C. 'Maximum', 'Max.', 'Minimum' or 'Min.' \uf0b0 represents  (mean + 3 \uf073 )  or  (mean - 3 \uf073 )  respectively,  where \uf073 is  a  standard  deviation,  over  each temperature range.\nFIGURE 46-1: IDD, XT Oscillator, 4 MHz, PIC18LF25/26K83 Only.",
    "46.0 DC AND AC CHARACTERISTICS GRAPHS AND CHARTS\nFIGURE 46-2: IDD, XT Oscillator, 4 MHz, PIC18F25/26K83 Only.\nFIGURE 46-3: IDD, XT Oscillator, 4 MHz, PMD's All ' 1 's, PIC18LF25/26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-4: IDD, XT Oscillator, 4 MHz, PMD's All ' 1 's, PIC18F25/26K83 Only.\nFIGURE 46-5: IDD, HS+PLL Oscillator, 64 MHz, PIC18LF25/26K83 Only.\nFIGURE 46-6: IDD, HS+PLL Oscillator, 64 MHz, PIC18F25/26K83 Only.\nFIGURE 46-7: IDD, HS+PLL Oscillator, 64 MHz, PMD's All ' 1 's, PIC18LF25/26K83 Only.\nFIGURE 46-8: IDD, HS+PLL Oscillator, 64 MHz, PMD's All ' 1 's, PIC18F25/26K83 Only.\nFIGURE 46-9: IDD, HFINTOSC Mode, Fosc = 64 MHz, PIC18LF25/26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-10: IDD, HFINTOSC Mode, Fosc = 64 MHz, PIC18F25/26K83 Only.\nFIGURE 46-11: IDD, HFINTOSC Mode, Fosc = 64 MHz, PMD's All ' 1 's, PIC18LF25/ 26K83 Only.\nFIGURE 46-12: IDD, HFINTOSC Mode, Fosc = 16 MHz, PIC18F25/26K83 Only.\nFIGURE 46-13: IDD, HFINTOSC Mode, Fosc = 16 MHz, PIC18LF25/26K83 Only.\nFIGURE 46-14: IDD, HFINTOSC Mode, Fosc = 16 MHz, PIC18F25/26K83 Only.\nFIGURE 46-15: IDD, HFINTOSC Mode, Fosc = 16 MHz, PMD's All ' 1 's, PIC18LF25/ 26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-16: IDD, HFINTOSC Mode, Fosc = 16 MHz, PMD's All ' 1 's, PIC18F25/26K83 Only.\nFIGURE 46-17: IDD, HFINTOSC Idle Mode, Fosc = 16 MHz, PIC18LF25/26K83 Only.\nFIGURE 46-18: IDD, HFINTOSC Idle Mode, Fosc = 16 MHz, PIC18F25/26K83 Only.\nFIGURE 46-19: IDD, HFINTOSC Doze Mode, Fosc = 16 MHz, PIC18LF25/26K83 Only.\nFIGURE 46-20: IDD, HFINTOSC Doze Mode, Fosc = 16 MHz, PIC18F25/26K83 Only.\nFIGURE 46-21: IDD, XT Oscillator 4 MHz, PIC18LF25/26K83 Only\nFIGURE 46-22: IDD, XT Oscillator 4 MHz, PIC18F25/26K83 Only",
    "PIC18(L)F25/26K83\nFIGURE 46-23: IDD, XT Oscillator 4 MHz, PMD's All ' 1 's, PIC18LF25/26K83 Only\nFIGURE 46-24: IDD, XT Oscillator 4 MHz, PMD's All ' 1 's, PIC18F25/26K83 Only\nFIGURE 46-25: IDD, HS+PLL Oscillator, 64 MHz, PIC18LF25/26K83 Only.\nFIGURE 46-26: IDD, HS+PLL Oscillator, 64 MHz, PIC18F25/26K83 Only.\nFIGURE 46-27: IDD, HS+PLL Oscillator, 64 MHz, PMD's All ' 1 's, PIC18LF25/26K83 Only.\nFIGURE 46-28: IDD, HS+PLL Oscillator, 64 MHz, PMD's All ' 1 's, PIC18F25/26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-29: IDD, HFINTOSC Mode, FOSC = 64 MHz, PIC18LF25/26K83 Only.\nFIGURE 46-30: IDD, HFINTOSC Mode, FOSC = 64 MHz, PIC18F25/26K83 Only.\nFIGURE 46-31: IDD, HFINTOSC Mode, Fosc = 64 MHz, PMD's All ' 1 's, PIC18LF25/26K83 Only.\nFIGURE 46-32: IDD, HFINTOSC Mode, Fosc = 64 MHz, PMD's All ' 1 's, PIC18F25/26K83 Only.\nFIGURE 46-33: IDD, HFINTOSC Mode, FOSC = 16 MHz, PIC18LF25/26K83 Only.\nFIGURE 46-34: IDD, HFINTOSC Mode, FOSC = 16 MHz, PIC18F25/26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-35: IDD, HFINTOSC Mode, Fosc = 16 MHz, PMD's All ' 1 's, PIC18LF25/26K83 Only.\nFIGURE 46-36: IDD, HFINTOSC Mode, FOSC = 16 MHz, PMD's All ' 1 's, PIC18F25/ 26K83 Only.\nFIGURE 46-37: IDD, HFINTOSC Idle Mode, Fosc = 16 MHz, PIC18LF25/26K83 Only.\nFIGURE 46-38: IDD, HFINTOSC Idle Mode, Fosc = 16 MHz, PIC18F25/26K83 Only.\nFIGURE 46-39: IDD, HFINTOSC Doze Mode, Fosc = 16 MHz, PIC18LF25/26K83 Only.\nFIGURE 46-40: IDD, HFINTOSC Doze Mode, Fosc = 16 MHz, PIC18F25/26K83 Only.\nFIGURE 46-41: IPD, Base, LP Sleep Mode, PIC18LF25/26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-42: IPD, Watchdog Timer (WDT), PIC18LF25/26K83 Only.\nFIGURE 46-43: IPD, Watchdog Timer (WDT), PIC18F25/26K83 Only.\nFIGURE 46-44: IPD, Fixed Voltage Reference (FVR), PIC18LF25/26K83 Only.\nFIGURE 46-45: IPD, Fixed Voltage Reference (FVR), PIC18F25/26K83 Only.\nFIGURE 46-46: IPD, Brown-Out Reset (BOR), PIC18LF25/26K83 Only.\nFIGURE 46-47: IPD, Brown-Out Reset (BOR), PIC18F25/26K83 Only.\nFIGURE 46-48: IPD, Low-Power Brown-Out Reset (LPBOR), PIC18LF25/26K83 Only.\nFIGURE 46-49: IPD, Low-Power Brown-Out Reset (LPBOR), PIC18F25/26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-50: IPD, Comparator, PIC18LF25/26K83 Only.\nFIGURE 46-51: IPD, Comparator, PIC18F25/26K83 Only.\nFIGURE 46-52: IPD Base, NP Sleep Mode, PIC18F25/26K83 Only.\nFIGURE 46-53: IPD Base, LP Sleep Mode, PIC18F25/26K83 Only\nFIGURE 46-54: IPD, High/Low Voltage detect (HLVD), PIC18LF25/26K83 Only.\nFIGURE 46-55: IPD, High/Low Voltage detect (HLVD), PIC18F25/26K83 Only.\nFIGURE 46-56: IPD, Secondary Oscillator (SOSC), PIC18LF25/26K83 Only.\nFIGURE 46-57: IPD, Secondary Oscillator (SOSC), PIC18F25/26K83 Only.\nFIGURE 46-58: Calibrated HFINTOSC, Typical Frequency Error, PIC18LF25/26K83 only.",
    "PIC18(L)F25/26K83\nFIGURE 46-59: Calibrated HFINTOSC, Typical Frequency Error, PIC18F25/26K83 only.\nFIGURE 46-60: HFINTOSC Frequency Error, VDD = 3.0V.\nFIGURE 46-61: LFINTOSC Typical Frequency Error, PIC18LF25/26K83 Only.\nFIGURE 46-62: LFINTOSC Typical Frequency Error, PIC18F25/26K83 Only.\nFIGURE 46-63: Low-Power Optimized HFINTOSC Typical Frequency Error, PIC18LF25/26K83 Only.\nFIGURE 46-64: Low-Power Optimized HFINTOSC Typical Frequency Error, PIC18F25/26K83 Only.\nFIGURE 46-65: Low-Power Optimized HFINTOSC Frequency Error, VDD = 3.0V.\nFIGURE 46-66: Weak Pull-Up Current, PIC18F25/26K83 Only.\nFIGURE 46-67: Weak Pull-Up Current, PIC18LF25/26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-68: VOH vs. IOH Over Temperature, VDD = 5.5V, PIC18F25/26K83 Only.\nFIGURE 46-69:\nVOL vs. IOL Over\nTemperature, VDD = 5.5V, PIC18F25/26K83 Only.\nFIGURE 46-70: VOH vs. IOH Over Temperature, VDD = 3.0V.\nFIGURE 46-71: VOL vs. IOL Over Temperature, VDD = 3.0V.\nFIGURE 46-72: VOH vs. IOH Over Temperature, VDD = 1.8V, PIC18LF25/26K83 Only.\nFIGURE 46-73: VOL vs. IOL Over Temperature, VDD = 1.8V, PIC18LF25/26K83 Only\nFIGURE 46-74: Brown-Out Reset Voltage, Trip Point (BORV = 00 ).\nFIGURE 46-75: Brown-Out Reset, Hysteresis, Trip Point (BORV = 00 ).\nFIGURE 46-76: Brown-Out Reset Voltage, Trip Point (BORV = 01 ).",
    "PIC18(L)F25/26K83\nFIGURE 46-77: Brown-Out Reset Hysteresis, Trip Point (BORV = 01 ).\nFIGURE 46-78: Brown-Out Reset Voltage, Trip Point (BORV = 10 ).\nFIGURE 46-79: Brown-Out Reset Hysteresis, Trip Point (BORV = 10 ).\nFIGURE 46-80: Brown-Out Reset Voltage, Trip Point (BORV = 11 ), PIC18LF25/26K83 Only.\nFIGURE 46-81: Brown-Out Reset Hysteresis, Trip Point (BORV = 11 ), PIC18LF25/26K83 Only.\nFIGURE 46-82: LPBOR Reset Voltage.\nFIGURE 46-83: LPBOR Reset Hysteresis.\nFIGURE 46-84: High/Low-Voltage Detect Trip Voltage.\nFIGURE 46-85: High/Low-Voltage Detect Hysteresis.\nFIGURE 46-86: High/Low-Voltage Detect Trip Voltage, Typical Error (HLVDSEL[3:0] = 0001) .",
    "PIC18(L)F25/26K83\nFIGURE 46-87: High/Low-Voltage Detect Trip Voltage, Typical Error (HLVDSEL[3:0] = 0000) .\nFIGURE 46-88: BOR Response Time, PIC18LF25/26K83 Only.\nFIGURE 46-89: BOR Response Time, PIC18F25/26K83 Only.\nFIGURE 46-90: ADC 12-Bit Mode, SingleEnded, Typical DNL, VDD = 3.0V, VREF = 3.0V, TAD = 0.5 uS, 25\u00baC, All devices.\nFIGURE 46-91: ADC 12-bit Mode, SingleEnded DNL, VDD = 3.0V, VREF = 3.0V, TAD = 1 \uf06d S, CP OFF, 25\u00b0C.\nFIGURE 46-92: ADC 12-bit Mode, SingleEnded DNL, VDD = 3.0V, VREF = 3.0V, TAD = 1 \uf06d S, CP ON, 25\u00b0C.",
    "PIC18(L)F25/26K83\nFIGURE 46-93: ADC 12-bit Mode, SingleEnded DNL, VDD = 2.3V, VREF = 2.3V, TAD = 1 \uf06d S, CP ON, 25\u00b0C.\nFIGURE 46-94: ADC 12-bit Mode, SingleEnded INL, VDD = 3.0V, VREF = 3.0V, TAD = 1 \uf06d S, CP OFF, 25\u00b0C.\nFIGURE 46-95: ADC 12-Bit Mode, SingleEnded, Typical INL, VDD = 3.0V, VREF = 3.0V, TAD = 0.5 uS, 25\u00baC, All devices.\nFIGURE 46-96: ADC 12-bit Mode, SingleEnded INL, VDD = 3.0V, VREF = 3.0V, TAD = 1 \uf06d S, CP ON, 25\u00b0C.\nFIGURE 46-97: ADC 12-bit Mode, SingleEnded INL, VDD = 2.3V, VREF = 2.3V, TAD = 1 \uf06d S, CP ON, 25\u00b0C.",
    "PIC18(L)F25/26K83\nFIGURE 46-98: ADC 12-bit Mode, SingleEnded Typical DNL, VDD = 3.0V, TAD = 1 \uf06d S, CPON\nFIGURE 46-99: ADC 12-bit Mode, SingleEnded Typical INL, VDD = 3.0V, TAD = 1 \uf06d S, CPON.\nFIGURE 46-100: ADC RC Oscillator Period, PIC18LF25/26K83 Only.\nFIGURE 46-101: ADC RC Oscillator Period, PIC18F25/26K83 Only.\nFIGURE 46-102: Typical DAC DNL Error, VDD = 3.0V, VREF = External 3.0V.\nFIGURE 46-103: Typical DAC INL Error, VDD = 3.0V, VREF = External 3.0V.\nFIGURE 46-104: Typical DAC DNL Error, VDD = 5.0V, VREF = External 5.0V, PIC18F25/26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-105: Typical DAC INL Error, VDD = 5.0V, VREF = External 5.0V PIC18F25/26K83 Only.\nFIGURE 46-106: DAC INL Error, VDD = 3.0V, PIC18LF25/26K83 Only.\nFIGURE 46-107: Absolute Value of DAC DNL Error, VDD = 3.0V, VREF = VDD.\nFIGURE 46-108: Absolute Value of DAC INL Error, VDD = 3.0V, VREF = VDD.\nFIGURE 46-109: Absolute Value of DAC DNL Error, VDD = 5.0V, VREF = VDD, PIC18F25/26K83 Only\nFIGURE 46-110: Absolute Value of DAC INL Error, VDD = 5.0V, VREF = VDD, PIC18F25/26K83 Only.\nFIGURE 46-111: Comparator Hysteresis, NP Mode (CxSP = 1 ), VDD = 3.0V, Typical Measured Values.",
    "PIC18(L)F25/26K83\nFIGURE 46-112: Comparator Offset, NP Mode (CxSP = 1 ), VDD = 3.0V, Typical Measured Values at 25\u00b0C.\nFIGURE 46-113: Comparator Offset, NP Mode (CxSP = 1 ), VDD = 3.0V, Typical Measured Values from -40\u00b0C to 125\u00b0C.\nFIGURE 46-114: Comparator Hysteresis, NP Mode (CxSP = 1 ), VDD = 5.5V, Typical Measured Values,PIC18F25/26K83 Only.\nFIGURE 46-115: Comparator Offset, NP Mode (CxSP = 1 ), VDD = 5.0V, Typical Measured Values at 25\u00b0C, PIC18F25/26K83 Only\nFIGURE 46-116: Comparator Offset, NP Mode (CxSP = 1 ), VDD = 5.5V, Typical Measured Values from -40\u00b0C to 125\u00b0C, PIC18F25/26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-117: Comparator Response Time Over Voltage, NP Mode (CxSP = 1 ), Typical Measured Values, PIC18LF25/26K83 Only.\nFIGURE 46-118: Comparator Response Time Over Voltage, NP Mode (CxSP = 1 ), Typical Measured Values, PIC18F25/26K83 Only\nFIGURE 46-119: Comparator Output Filter Delay Time Over Temp., NP Mode (CxSP = 1 ), Typical Measured Values, PIC18LF25/26K83 Only.\nFIGURE 46-120: Comparator Output Filter Delay Time Over Temp., NP Mode (CxSP = 1 ), Typical Measured Values, PIC18F25/26K83 Only.\nFIGURE 46-121: Comparator Response Time Falling Edge, PIC18LF25/26K83 Only.\nFIGURE 46-122: Comparator Response Time Falling Edge, PIC18F25/26K83 Only.\nFIGURE 46-123: Comparator Response Time Rising Edge, PIC18LF25/26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-124: Comparator Response Time Rising Edge, PIC18F25/26K83 Only.\nFIGURE 46-125: Band Gap Ready Time, PIC18LF25/26K83 Only.\nFIGURE 46-126: FVR Stabilization Period, PIC18LF25/26K83 Only.\nFIGURE 46-127: Typical FVR Voltage 1x, PIC18LF25/26K83 Only.\nFIGURE 46-128: FVR Voltage Error 1x, PIC18F25/26K83 Only.\nFIGURE 46-129: FVR Voltage Error 2x, PIC18LF25/26K83 Only.\nFIGURE 46-130: FVR Voltage Error 2x, PIC18F25/26K83 Only.\nFIGURE 46-131: FVR Voltage Error 4x, PIC18F25/26K83 Only.\nFIGURE 46-132: Schmitt Trigger High Values.\nFIGURE 46-133: Schmitt Trigger Low Values.\np\nFIGURE 46-135: Rise Time, Slew Rate Control Enabled.\nFIGURE 46-134: Input Level TTL.\nFIGURE 46-136: Fall Time, Slew Rate Control Enabled.",
    "PIC18(L)F25/26K83\nFIGURE 46-137: Rise Time, Slew Rate Control Disabled.\nFIGURE 46-138: Fall Time, Slew Rate Control Disabled.\nFIGURE 46-139: OSCTUNE Center Frequency, PIC18LF25/26K83 Only.\nFIGURE 46-140:\nPOR Release Voltage.\nFIGURE 46-141: POR Rearm Voltage, NP Mode, PIC18F25/26K83 Only.\nFIGURE 46-142: PWRT Period, PIC18F25/ 26K83 Only.\nFIGURE 46-143: PWRT Period, PIC18LF25/ 26K83 Only.\nFIGURE 46-144: Wake from Sleep, VREGPM = 0 , HFINTOSC = 4 MHz, PIC18F25/26K83 Only.\nFIGURE 46-145: Wake from Sleep, VREGPM = 1 , HFINTOSC = 4 MHz, PIC18F25/26K83 Only.\nFIGURE 46-146: Wake from Sleep, VREGPM = 0 , HFINTOSC = 16 MHz, PIC18F25/26K83 Only.",
    "PIC18(L)F25/26K83\nFIGURE 46-147: Wake from Sleep, VREGPM = 1 , HFINTOSC = 16 MHz, PIC18F25/26K83 Only.\nFIGURE 46-148: Wake from Sleep, VREGPM = 1 , PIC18F25/26K83 Only.\nFIGURE 46-149: Wake from Sleep, PIC18LF25/26K83 Only.\nFIGURE 46-150: WDT Time-Out Period, PIC18F25/26K83 Only.\nFIGURE 46-151: WDT Time-Out Period, PIC18LF25/26K83 Only.\nFIGURE 46-152: High Range Temperature Indicator Voltage Sensitivity Across Temperature.\nFIGURE 46-153: Low Range Temperature Indicator Voltage Sensitivity Across Temperature\nFIGURE 46-154: Temperature Indicator Performance Over Temperature",
    "Package Marking Information\n28-Lead SPDIP (.300')\n28-Lead SOIC (7.50 mm)\n28-Lead SSOP (5.30 mm)\nExample\nExample\nExample\nLegend:\nXX...X\nCustomer-specific information or Microchip part number\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\nPb-free JEDEC \u00ae  designator for Matte Tin (Sn)\n*\nThis package is Pb-free. The Pb-free JEDEC designator (      ) 3 e\ncan be found on the outer packaging for this package.\nNote :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.\n3\ne",
    "Package Marking Information (Continued)\n28-Lead QFN (6x6 mm)\n28-Lead UQFN (6x6x0.5 mm)\nExample\nExample",
    "Legend:\nXX...X\nCustomer-specific information or Microchip part number\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\nPb-free JEDEC \u00ae  designator for Matte Tin (Sn)\n*\nThis package is Pb-free. The Pb-free JEDEC designator (      ) 3 e\ncan be found on the outer packaging for this package.\nNote :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.\n3\ne",
    "47.1 Package Details\nThe following sections give the technical details of the packages.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\n/g49/g82/g87/g72/g29",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\n/g41/g82/g85/g3/g87/g75/g72/g3/g80/g82/g86/g87",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\n/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\ng3/g70/g88/g85/g85/g72/g81/g87/g3/g83/g68/g70",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\n/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\ng78/g68/g74/g72/g3/g71/g85/g68/g90/g76/g81/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\ng74/g86/g15/g3/g83/g79/g72/g68/g86/g72/g3/g86",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\n/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\ng72/g72/g3/g87/g75/g72/g3/g48/g76/g70/g85/g82",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\n/\ng70/g75/g76/g83/g3/g51/g68/g70/g78/g68/g74/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\ng76/g81/g74/g3/g54",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\n/g83/g72/g70/g76/g73/g76/g70/g68/g87/g76/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\ng82/g81/g3/g79/g82/g70/g68/g87/g72/g71/g3/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\ng68/g87/g3",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\n/g75/g87/g87/g83/g29/g18/g18/g90/g90/g90",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\n/g17/g80/g76/g70/g85/g82/g70/g75/g76/g83/g17/g70/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\ng82/g80/g18/g83/g68/g70/g78/g68/g74/g76/g81/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g54/g78/g76/g81/g81/g92/g3/g51/g79/g68/g86/g87/g76/g70/g3/g39/g88/g68/g79/g3/g44/g81/g16/g47/g76/g81/g72/g3/g11/g54/g51/g12/g3/g177/g3/g22/g19/g19/g3/g80/g76/g79/g3/g37/g82/g71/g92/g3/g62/g54/g51/g39/g44/g51/g64\ng74",
    "/g49/g82/g87/g72/g86/g29\n/g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g51/g76/g81/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g49. /g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g51/g76/g81/g86, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g21/g27.",
    "/g49/g82/g87/g72/g86/g29\n/g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g51/g76/g81/g86, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g21/g27. /g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g51/g76/g81/g86, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g21/g27. /g51/g76/g87/g70/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g72. /g51/g76/g87/g70/g75, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g17/g20/g19/g19/g3/g37/g54/g38. /g51/g76/g87/g70/g75, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g17/g20/g19/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g51/g76/g87/g70/g75, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g17/g20/g19/g19/g3/g37/g54/g38. /g55 /g82/g83/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g36. /g55",
    "/g49/g82/g87/g72/g86/g29\n/g82/g83/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g177. /g55 /g82/g83/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g177. /g55",
    "/g49/g82/g87/g72/g86/g29\n/g82/g83/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g17/g21/g19/g19. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g36/g21. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g17/g20/g21/g19.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g17/g20/g22/g24. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86,",
    "/g49/g82/g87/g72/g86/g29\n/g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g17/g20/g24/g19. /g37/g68/g86/g72/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g36/g20.",
    "/g49/g82/g87/g72/g86/g29\n/g37/g68/g86/g72/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g17/g19/g20/g24. /g37/g68/g86/g72/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g177.",
    "/g49/g82/g87/g72/g86/g29\n/g37/g68/g86/g72/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g177. /g54/g75/g82/g88/g79/g71/g72/g85/g3/g87/g82/g3/g54/g75/g82/g88/g79/g71/g72/g85/g3/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g40. /g54/g75/g82/g88/g79/g71/g72/g85/g3/g87/g82/g3/g54/g75/g82/g88/g79/g71/g72/g85/g3/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g17/g21/g28/g19.",
    "/g49/g82/g87/g72/g86/g29\n/g54/g75/g82/g88/g79/g71/g72/g85/g3/g87/g82/g3/g54/g75/g82/g88/g79/g71/g72/g85/g3/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g17/g22/g20/g19. /g54/g75/g82/g88/g79/g71/g72/g85/g3/g87/g82/g3/g54/g75/g82/g88/g79/g71/g72/g85/g3/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g17/g22/g22/g24. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g40/g20.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g17/g21/g23/g19. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g17/g21/g27/g24.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g17/g21/g28/g24. /g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g39. /g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g20/g17/g22/g23/g24. /g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g20/g17/g22/g25/g24. /g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g20/g17/g23/g19/g19. /g55/g76/g83/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g47. /g55/g76/g83/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g17/g20 /g20/g19.",
    "/g49/g82/g87/g72/g86/g29\n/g55/g76/g83/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g17/g20/g22/g19. /g55/g76/g83/g3/g87/g82/g3/g54/g72/g68/g87/g76/g81/g74/g3/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g17/g20/g24/g19.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g70. /g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g17/g19/g19/g27.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g17/g19/g20/g19. /g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g17/g19/g20/g24.",
    "/g49/g82/g87/g72/g86/g29\n/g56/g83/g83/g72/g85/g3/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g69/g20. /g56/g83/g83/g72/g85/g3/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/g29\n/g17/g19/g23/g19. /g56/g83/g83/g72/g85/g3/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g17/g19/g24/g19. /g56/g83/g83/g72/g85/g3/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g17/g19/g26/g19.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g82/g90/g72/g85/g3/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g69. /g47/g82/g90/g72/g85/g3/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/g29\n/g17/g19/g20/g23. /g47/g82/g90/g72/g85/g3/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g17/g19/g20/g27. /g47/g82/g90/g72/g85/g3/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g17/g19/g21/g21.",
    "/g49/g82/g87/g72/g86/g29\n/g50/g89/g72/g85/g68/g79/g79/g3/g53/g82/g90/g3/g54/g83/g68/g70/g76/g81/g74/g3/g3/g134, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g72/g37.",
    "/g49/g82/g87/g72/g86/g29\n/g50/g89/g72/g85/g68/g79/g79/g3/g53/g82/g90/g3/g54/g83/g68/g70/g76/g81/g74/g3/g3/g134, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g177. /g50/g89/g72/g85/g68/g79/g79/g3/g53/g82/g90/g3/g54/g83/g68/g70/g76/g81/g74/g3/g3/g134, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g177.",
    "/g49/g82/g87/g72/g86/g29\n/g50/g89/g72/g85/g68/g79/g79/g3/g53/g82/g90/g3/g54/g83/g68/g70/g76/g81/g74/g3/g3/g134, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g17/g23/g22/g19",
    "/g49/g82/g87/g72/g86/g29\n/g20/g17 /g51/g76/g81/g3/g20/g3/g89/g76/g86/g88/g68/g79/g3/g76/g81/g71/g72/g91/g3/g73/g72/g68/g87/g88/g85/g72/g3/g80/g68/g92/g3/g89/g68/g85/g92",
    "/g49/g82/g87/g72/g86/g29\n/g15/g3/g69/g88/g87/g3/g80/g88/g86/g87/g3/g69/g72/g3/g79/g82/g70/g68/g87/g72/g71/g3/g90/g76/g87/g75/g76/g81/g3/g87/g75/g72/g3/g75/g68/g87/g70/g75/g72/g71/g3/g68/g85/g72/g68/g17",
    "/g49/g82/g87/g72/g86/g29\n/g21/g17 /g134/g3/g54/g76/g74/g81/g76/g73/g76/g70/g68/g81/g87/g3/g38/g75/g68/g85/g68/g70/g87/g72/g85/g76/g86/g87/g76/g70/g17\n/g22/g17",
    "/g49/g82/g87/g72/g86/g29\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g86/g3/g39/g3/g68/g81/g71/g3/g40/g20/g3/g71/g82/g3/g81/g82/g87/g3/g76/g81/g70/g79/g88/g71/g72/g3/g80/g82/g79/g71/g3/g73/g79/g68/g86/g75/g3/g82/g85/g3/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/g17/g3/g48/g82/g79/g71",
    "/g49/g82/g87/g72/g86/g29\n/\ng3/g73/g79/g68/g86/g75/g3/g82/g85/g3/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/g3/g86/g75/g68/g79/g79/g3/g81/g82/g87/g3/g72/g91/g70/g72/g72/g71/g3/g17/g19/g20/g19/g5/g3/g83/g72/g85/g3/g86/g76/g71/g72/g17",
    "/g49/g82/g87/g72/g86/g29\n/g23/g17 /g39/g76/g80/g72/g81/g86/g76/g82/g81/g76/g81/g74/g3/g68/g81/g71/g3/g87/g82/g79/g72/g85/g68/g81/g70/g76/g81/g74/g3/g83/g72/g85/g3/g36/g54/g48/g40/g3/g60/g20/g23/g17/g24/g48/g17\n/g37/g54/g38/g29",
    "/g49/g82/g87/g72/g86/g29\n/g37/g68/g86/g76/g70/g3/g39/g76/g80/g72/g81/g86/g76/g82/g81/g17/g3/g55/g75/g72/g82/g85/g72/g87/g76/g70/g68/g79/g79/g92/g3/g72/g91/g68/g70/g87/g3/g89/g68/g79/g88/g72/g3/g86/g75/g82/g90/g81/g3/g90/g76/g87/g75/g82/g88/g87/g3/g87/g82/g79/g72/g85/g68/g81/g70/",
    "/g49/g82/g87/g72/g86/g29\ng72/g86/g17\n/g48/g76/g70/g85/g82/g70/g75/g76/g83 /g55 /g72/g70/g75/g81/g82/g79/g82/g74/g92 /g39/g85/g68/g90/g76/g81/g74 /g38/g19/g23/g16/g19/g26/g19/g37\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g51/g76/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng81/g86,\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86\n= /g49.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g51/g76/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng81/g86,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g21/g27.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g51/g76/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng81/g86,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g21/g27.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g51/g76/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng81/g86,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g21/g27. /g51/g76/g87/g70/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86\n= /g72. /g51/g76/g87/g70/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g17/g25/g24/g3/g37/g54/g38.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g51/g76/g87/g70/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g17/g25/g24/g3/g37/g54/g38.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g51/g76/g87/g70/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g17/g25/g24/g3/g37/g54/g38.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng74/g75/g87,\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86\n= /g36.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng74/g75/g87,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g177.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng74/g75/g87,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g177.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng74/g75/g87,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g21/g17/g19/g19.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng86,\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86\n= /g36/g21.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng86,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g20/g17/g25/g24.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng86,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g20/g17/g26/g24.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng86,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g20/g17/g27/g24.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g54/g87/g68/g81/g71/g82/g73/g73/g3,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g36/g20. /g54/g87/g68/g81/g71/g82/g73/g73/g3,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g17/g19/g24.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g54/g87/g68/g81/g71/g82/g73/g73/g3,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g177. /g54/g87/g68/g81/g71/g82/g73/g73/g3,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g177.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng87/g75,\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86\n= /g40.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g26/g17/g23/g19.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g26/g17/g27/g19.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g27/g17/g21/g19.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng68/g74/g72/g3/g58/g76/g71/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86\n= /g40/g20.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng68/g74/g72/g3/g58/g76/g71/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g24/g17/g19/g19.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng68/g74/g72/g3/g58/g76/g71/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g24/g17/g22/g19.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng68/g74/g72/g3/g58/g76/g71/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g24/g17/g25/g19.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng74/g87/g75,\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86\n= /g39.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng74/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g28/g17/g28/g19.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng74/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g20/g19/g17/g21/g19.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\ng74/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g20/g19/g17/g24/g19.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86\n= /g47.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g17/g24/g24.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g17/g26/g24.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g17/g28/g24.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g41/g82/g82/g87/g83/g85/g76/g81/g87,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g47/g20. /g41/g82/g82/g87/g83/g85/g76/g81/g87,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g20/g17/g21/g24/g3/g53/g40/g41.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g41/g82/g82/g87/g83/g85/g76/g81/g87,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g20/g17/g21/g24/g3/g53/g40/g41.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g41/g82/g82/g87/g83/g85/g76/g81/g87,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g20/g17/g21/g24/g3/g53/g40/g41.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng86/g86,\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86\n= /g70.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng86/g86,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g17/g19/g28.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng86/g86,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g177.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng86/g86,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g17/g21/g24.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g41/g82/g82/g87/g3/g36/g81/g74/g79/g72,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86\n= /g73.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g41/g82/g82/g87/g3/g36/g81/g74/g79/g72,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g131.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g41/g82/g82/g87/g3/g36/g81/g74/g79/g72,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g23/g131.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g41/g82/g82/g87/g3/g36/g81/g74/g79/g72,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g27/g131.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g56/g81/g76/g87/g86.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/\ng80/g76/g87/g86",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g69. /g47/g72/g68/g71/g3/g58/g76/g71/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g17/g21/g21.",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g177. /g47/g72/g68/g71/g3/g58/g76/g71/g87/g75,",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59",
    "/g21/g27/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g54/g75/g85/g76/g81/g78/g3/g54/g80/g68/g79/g79/g3/g50/g88/g87/g79/g76/g81/g72/g3/g11/g54/g54/g12/g3/g177/g3/g24/g17/g22/g19/g3/g80/g80/g3/g37/g82/g71/g92/g3/g62/g54/g54/g50/g51/g64\n= /g19/g17/g22/g27",
    "/g49/g82/g87/g72/g86/g29\n/g20/g17 /g51/g76/g81/g3/g20/g3/g89/g76/g86/g88/g68/g79/g3/g76/g81/g71/g72/g91/g3/g73/g72/g68/g87/g88/g85/g72/g3/g80/g68/g92/g3/g89/g68/g85/g92",
    "/g49/g82/g87/g72/g86/g29\n/g15/g3/g69/g88/g87/g3/g80/g88/g86/g87/g3/g69/g72/g3/g79/g82/g70/g68/g87/g72/g71/g3/g90/g76/g87/g75/g76/g81/g3/g87/g75/g72/g3/g75/g68/g87/g70/g75/g72/g71/g3/g68/g85/g72/g68/g17\n/g21/g17",
    "/g49/g82/g87/g72/g86/g29\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g86/g3/g39/g3/g68/g81/g71/g3/g40/g20/g3/g71/g82/g3/g81/g82/g87/g3/g76/g81/g70/g79/g88/g71/g72/g3/g80/g82/g79/g71/g3/g73/g79/g68/g86/g75/g3/g82/g85/g3/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/g17/g3/g48/g82/g79/g71",
    "/g49/g82/g87/g72/g86/g29\n/\ng3/g73/g79/g68/g86/g75/g3/g82/g85/g3/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/g3/g86/g75/g68/g79/g79/g3/g81/g82/g87/g3/g72/g91/g70/g72/g72/g71/g3/g19/g17/g21/g19/g3/g80/g80/g3/g83/g72/g85/g3/g86/g76/g71/g72/g17",
    "/g49/g82/g87/g72/g86/g29\n/g22/g17 /g39/g76/g80/g72/g81/g86/g76/g82/g81/g76/g81/g74/g3/g68/g81/g71/g3/g87/g82/g79/g72/g85/g68/g81/g70/g76/g81/g74/g3/g83/g72/g85/g3/g36/g54/g48/g40/g3/g60/g20/g23/g17/g24/g48/g17\n/g37/g54/g38/g29",
    "/g49/g82/g87/g72/g86/g29\n/g37/g68/g86/g76/g70/g3/g39/g76/g80/g72/g81/g86/g76/g82/g81/g17/g3/g55/g75/g72/g82/g85/g72/g87/g76/g70/g68/g79/g79/g92/g3/g72/g91/g68/g70/g87/g3/g89/g68/g79/g88/g72/g3/g86/g75/g82/g90/g81/g3/g90/g76/g87/g75/g82/g88/g87/g3/g87/g82/g79/g72/g85/g68/g81/g70/",
    "/g49/g82/g87/g72/g86/g29\ng72/g86/g17\n/g53/g40/g41/g29",
    "/g49/g82/g87/g72/g86/g29\n/g53/g72/g73/g72/g85/g72/g81/g70/g72/g3/g39/g76/g80/g72/g81/g86/g76/g82/g81/g15/g3/g88/g86/g88/g68/g79/g79/g92/g3/g90/g76/g87/g75/g82/g88/g87/g3/g87/g82/g79/g72/g85/g68/g81/g70/g72/g15/g3/g73/g82/g85/g3/g76/g81/g73/g82/g85/g80/g68/g87/g76/g82/g81/g3/",
    "/g49/g82/g87/g72/g86/g29\ng83/g88/g85/g83/g82/g86/g72/g86/g3/g82/g81/g79/g92\n/g17\n/g48/g76/g70/g85/g82/g70/g75/g76/g83 /g55 /g72/g70/g75/g81/g82/g79/g82/g74/g92 /g39/g85/g68/g90/g76/g81/g74 /g38/g19/g23/g16/g19/g26/g22/g37\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "28-Lead Plastic Quad Flat, No Lead Package (MX) - 6x6x0.5mm Body [UQFN] Ultra-Thin with 0.40 x 0.60 mm Terminal Width/Length and Corner Anchors\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "28-Lead Plastic Quad Flat, No Lead Package (MX) - 6x6x0.5mm Body [UQFN] Ultra-Thin with 0.40 x 0.60 mm Terminal Width/Length and Corner Anchors\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, MILLIMETERS.MIN = . Number of Pins, MILLIMETERS.NOM = 28. Number of Pins, MILLIMETERS.MAX = . Pitch, Units.Dimension Limits = e. Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 0.65 BSC. Pitch, MILLIMETERS.MAX = . Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = 0.40. Overall Height, MILLIMETERS.NOM = 0.50. Overall Height, MILLIMETERS.MAX = 0.60. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.00. Standoff, MILLIMETERS.NOM = 0.02. Standoff, MILLIMETERS.MAX = 0.05. Terminal Thickness, Units.Dimension Limits = (A3). Terminal Thickness, MILLIMETERS.MIN = . Terminal Thickness, MILLIMETERS.NOM =",
    "28-Lead Plastic Quad Flat, No Lead Package (MX) - 6x6x0.5mm Body [UQFN] Ultra-Thin with 0.40 x 0.60 mm Terminal Width/Length and Corner Anchors\n0.127 REF. Terminal Thickness, MILLIMETERS.MAX = . Overall Width, Units.Dimension Limits = E. Overall Width, MILLIMETERS.MIN = . Overall Width, MILLIMETERS.NOM = 6.00 BSC. Overall Width, MILLIMETERS.MAX = . Exposed Pad Width, Units.Dimension Limits = E2. Exposed Pad Width, MILLIMETERS.MIN = . Exposed Pad Width, MILLIMETERS.NOM = 4.00. Exposed Pad Width, MILLIMETERS.MAX = . Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = . Overall Length, MILLIMETERS.NOM = 6.00 BSC. Overall Length, MILLIMETERS.MAX = . Exposed Pad Length, Units.Dimension Limits = D2. Exposed Pad Length, MILLIMETERS.MIN = . Exposed Pad Length, MILLIMETERS.NOM = 4.00. Exposed Pad Length, MILLIMETERS.MAX = . Terminal Width, Units.Dimension Limits = b. Terminal Width, MILLIMETERS.MIN =",
    "28-Lead Plastic Quad Flat, No Lead Package (MX) - 6x6x0.5mm Body [UQFN] Ultra-Thin with 0.40 x 0.60 mm Terminal Width/Length and Corner Anchors\n0.35. Terminal Width, MILLIMETERS.NOM = 0.40. Terminal Width, MILLIMETERS.MAX = 0.45. Corner Pad, Units.Dimension Limits = b1. Corner Pad, MILLIMETERS.MIN = 0.55. Corner Pad, MILLIMETERS.NOM = 0.60. Corner Pad, MILLIMETERS.MAX = 0.65. Corner Pad, Metal Free Zone, Units.Dimension Limits = b2. Corner Pad, Metal Free Zone, MILLIMETERS.MIN = 0.15. Corner Pad, Metal Free Zone, MILLIMETERS.NOM = 0.20. Corner Pad, Metal Free Zone, MILLIMETERS.MAX = 0.25. Terminal Length, Units.Dimension Limits = L. Terminal Length, MILLIMETERS.MIN = 0.55. Terminal Length, MILLIMETERS.NOM = 0.60. Terminal Length, MILLIMETERS.MAX = 0.65. Terminal-to-Exposed Pad, Units.Dimension Limits = K. Terminal-to-Exposed Pad,",
    "28-Lead Plastic Quad Flat, No Lead Package (MX) - 6x6x0.5mm Body [UQFN] Ultra-Thin with 0.40 x 0.60 mm Terminal Width/Length and Corner Anchors\nMILLIMETERS.MIN = 0.20. Terminal-to-Exposed Pad, MILLIMETERS.NOM = -. Terminal-to-Exposed Pad, MILLIMETERS.MAX = -",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated\n3. Dimensioning and tolerancing per ASME Y14.5M\nREF: Reference Dimension, usually without tolerance, for information purposes only. BSC: Basic Dimension. Theoretically exact value shown without tolerances.\n4. Outermost portions of corner structures may vary slightly.\nMicrochip Technology Drawing  C04-0209 Rev C Sheet 2 of 2",
    "Note:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.65 BSC. Contact Pitch, MILLIMETERS.MAX = . Optional Center Pad Width, Units.Limits = W1. Optional Center Pad Width, MILLIMETERS.MIN = . Optional Center Pad Width, MILLIMETERS.NOM = . Optional Center Pad Width, MILLIMETERS.MAX = 4.05. Optional Center Pad Length, Units.Limits = T2. Optional Center Pad Length, MILLIMETERS.MIN = . Optional Center Pad Length, MILLIMETERS.NOM = . Optional Center Pad Length, MILLIMETERS.MAX = 4.05. Contact Pad Spacing, Units.Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.70. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.70. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X28), Units.Limits = X1. Contact Pad Width",
    "RECOMMENDED LAND PATTERN\n(X28), MILLIMETERS.MIN = . Contact Pad Width (X28), MILLIMETERS.NOM = . Contact Pad Width (X28), MILLIMETERS.MAX = 0.45. Contact Pad Length (X28), Units.Limits = Y1. Contact Pad Length (X28), MILLIMETERS.MIN = . Contact Pad Length (X28), MILLIMETERS.NOM = . Contact Pad Length (X28), MILLIMETERS.MAX = 1.00. Corner Pad Width (X4), Units.Limits = X2. Corner Pad Width (X4), MILLIMETERS.MIN = . Corner Pad Width (X4), MILLIMETERS.NOM = . Corner Pad Width (X4), MILLIMETERS.MAX = 0.90. Corner Pad Length (X4), Units.Limits = Y2. Corner Pad Length (X4), MILLIMETERS.MIN = . Corner Pad Length (X4), MILLIMETERS.NOM = . Corner Pad Length (X4), MILLIMETERS.MAX = 0.90. Distance Between Pads, Units.Limits = G. Distance Between Pads, MILLIMETERS.MIN = 0.20. Distance Between Pads,",
    "RECOMMENDED LAND PATTERN\nMILLIMETERS.NOM = . Distance Between Pads, MILLIMETERS.MAX = ",
    "Notes:\n- BSC: Basic Dimension. Theoretically exact value shown without tolerances. 1. Dimensioning and tolerancing per ASME Y14.5M\nMicrochip Technology Drawing No. C04-2209B",
    "Revision C (06/2020)\nUpdated Electrical Specifications data and added the temperature information to the DC and AC Character -istics Graphs and Tables chapter; other minor correc -tions.",
    "Revision B (02/2019)\nUpdated Digital Peripherals section in cover pages.\nUpdated Example 9-3; Figures 15-2, 32-1, 32-2, 36-1, and 45-1; Registers 5-1, 5-2, 5-3, 5-4, 9-8, 13-3, 13-4, 25-3, and 37-5; Sections 1.1, 4.2.3, 4.5.6, 5.7.3, 7.1, 7.2.1.1, 13.1.2.4, 13.1.6, 13.1.6.1, 13.2, 13.2.1, 15.12, 31.6, 32.2, 36.0, 36.1, 36.2, 36.2.1.2, 36.2.2, and 36.3; Tables 1, 4-3, 5-3, 6-13, 15-8, 45-1, 45-12, 45-21, 4523 and 45-24.\nAdded Table  45-22:  SPI  Mode  Requirements  (Slave Mode).  Added  Table  45-25:  Temperature  Indicator Requirements.",
    "Revision B (02/2019)\nRemoved  Section  36.2.1.1:  Single-Point  Calibration. Removed Section 36.6: DIA Information.",
    "Revision A (8/2017)\nInitial release of the document.",
    "THE MICROCHIP WEBSITE\nMicrochip provides online support via our WWW site at www.microchip.com. This website is used as a means to make  files and  information  easily available to customers. Accessible by using your favorite Internet browser, the website contains the following information:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQ), technical support requests, online discussion groups, Microchip consultant program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "CUSTOMER CHANGE NOTIFICATION SERVICE\nMicrochip's  customer  notification  service  helps  keep customers current on Microchip products. Subscribers will receive  e-mail  notification  whenever  there  are changes,  updates,  revisions  or  errata  related  to  a specified product family or development tool of interest.\nTo register, access the Microchip website at www.microchip.com. Under 'Support', click on 'Customer Change  Notification' and follow the registration instructions.",
    "CUSTOMER SUPPORT\nUsers  of  Microchip  products  can  receive  assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Field Application Engineer (FAE)\n\u00b7 Technical Support\nCustomers should contact their distributor, representative or Field Application Engineer (FAE) for support. Local sales offices are also available to help customers. A  listing  of  sales  offices  and  locations  is included in the back of this document.\nTechnical support is available through the website at: http://microchip.com/support",
    "PRODUCT IDENTIFICATION SYSTEM\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.",
    "PRODUCT IDENTIFICATION SYSTEM\nDevice:, [X] (2) Tape and Reel Option - = PIC18F25K83, PIC18LF25K83 PIC18F26K83, PIC18LF26K83. Device:, X Temperature Range = PIC18F25K83, PIC18LF25K83 PIC18F26K83, PIC18LF26K83. Device:, /XX Package = PIC18F25K83, PIC18LF25K83 PIC18F26K83, PIC18LF26K83. Device:, XXX Pattern = PIC18F25K83, PIC18LF25K83 PIC18F26K83, PIC18LF26K83. Tape and Reel Option:, [X] (2) Tape and Reel Option - = Blank = standard packaging (tube or tray) T = Tape and Reel (1), (2). Tape and Reel Option:, X Temperature Range = Blank = standard packaging (tube or tray) T = Tape and Reel (1), (2). Tape and Reel Option:, /XX Package = Blank = standard packaging (tube or tray) T =",
    "PRODUCT IDENTIFICATION SYSTEM\nTape and Reel (1), (2). Tape and Reel Option:, XXX Pattern = Blank = standard packaging (tube or tray) T = Tape and Reel (1), (2). Temperature Range:, [X] (2) Tape and Reel Option - = E I. Temperature Range:, X Temperature Range = = -40 \uf0b0 C to +125 \uf0b0 C = -40 \uf0b0 C to +85 \uf0b0 C. Temperature Range:, /XX Package = (Extended) (Industrial). Temperature Range:, XXX Pattern = . Package:, [X] (2) Tape and Reel Option - = ML = 28-lead QFN 6x6mm MV = 28-lead UQFN 4x4x0.5mm SO = 28-lead SOIC SP = 28-lead Skinny Plastic DIP SS = 28-lead SSOP. Package:, X Temperature Range = ML = 28-lead QFN 6x6mm MV = 28-lead UQFN 4x4x0.5mm SO = 28-lead SOIC SP = 28-lead Skinny Plastic DIP SS = 28-lead SSOP. Package:, /XX Package = ML = 28-lead QFN",
    "PRODUCT IDENTIFICATION SYSTEM\n6x6mm MV = 28-lead UQFN 4x4x0.5mm SO = 28-lead SOIC SP = 28-lead Skinny Plastic DIP SS = 28-lead SSOP. Package:, XXX Pattern = ML = 28-lead QFN 6x6mm MV = 28-lead UQFN 4x4x0.5mm SO = 28-lead SOIC SP = 28-lead Skinny Plastic DIP SS = 28-lead SSOP. Pattern:, [X] (2) Tape and Reel Option - = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern:, X Temperature Range = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern:, /XX Package = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern:, XXX Pattern = QTP, SQTP, Code or Special Requirements (blank otherwise)",
    "Examples:\na) PIC18F25K83-E/P 301 = Extended temp., SPDIP package, QTP pattern #301.\nb) PIC18F26K83-E/SO = Extended temp., SOIC package.\nc) PIC18F25K83T-I/ML = Tape and reel, Industrial temp., QFN package.\nNote 1: Tape and Reel option is available for ML, MV, SO and SS packages with industrial Temperature Range only.\n2: Tape and Reel identifier only appears in catalog part number description. This identifier is used for ordering purposes and is not printed on the device package.",
    "Note the following details of the code protection feature on Microchip devices:\n\u00b7 Microchip products meet the specification contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is one of the most secure families of its kind on the market today, when used in the intended manner and under normal conditions.\n\u00b7 There are dishonest and possibly illegal methods used to breach the code protection feature. All of these methods, to our knowledge, require using the Microchip products in a manner outside the operating specifications contained in Microchip's Data Sheets. Most likely, the person doing so is engaged in theft of intellectual property.\n\u00b7 Microchip is willing to work with the customer who is concerned about the integrity of their code.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of their code. Code protection does not mean that we are guaranteeing the product as 'unbreakable.'",
    "Note the following details of the code protection feature on Microchip devices:\nCode protection is constantly evolving. We at Microchip are committed to continuously improving the code protection features of our products. Attempts to break Microchip's code protection feature may be a violation of the Digital Millennium Copyright Act. If such acts allow unauthorized access to your software or other copyrighted work, you may have a right to sue for relief under that Act.",
    "Note the following details of the code protection feature on Microchip devices:\nInformation  contained  in  this  publication  regarding  device applications and the like is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure  that  your  application  meets  with  your  specifications. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES  OF  ANY  KIND  WHETHER  EXPRESS  OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION, INCLUDING  BUT  NOT  LIMITED  TO ITS CONDITION, QUALITY, PERFORMANCE, MERCHANTABILITY OR FITNESS  FOR  PURPOSE . Microchip  disclaims  all  liability arising  from  this  information  and  its  use.  Use  of  Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold  harmless  Microchip  from  any  and  all  damages,  claims, suits,  or  expenses  resulting  from  such  use.  No  licenses  are conveyed, implicitly or otherwise, under any Microchip intellectual property rights unless otherwise stated.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, Adaptec, AnyRate, AVR, AVR logo, AVR Freaks, BesTime, BitCloud, chipKIT, chipKIT logo, CryptoMemory, CryptoRF, dsPIC, FlashFlex, flexPWR, HELDO, IGLOO, JukeBlox, KeeLoq, Kleer, LANCheck, LinkMD, maXStylus, maXTouch, MediaLB, megaAVR, Microsemi, Microsemi logo, MOST, MOST logo, MPLAB, OptoLyzer, PackeTime, PIC, picoPower, PICSTART, PIC32 logo, PolarFire, Prochip Designer, QTouch, SAM-BA, SenGenuity, SpyNIC, SST, SST Logo, SuperFlash, Symmetricom, SyncServer, Tachyon, TempTrackr, TimeSource, tinyAVR, UNI/O, Vectron, and XMEGA are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.",
    "Trademarks\nAPT, ClockWorks, The Embedded Control Solutions Company, EtherSynch, FlashTec, Hyper Speed Control, HyperLight Load, IntelliMOS, Libero, motorBench, mTouch, Powermite 3, Precision Edge, ProASIC, ProASIC Plus, ProASIC Plus logo, Quiet-Wire, SmartFusion, SyncWorld, Temux, TimeCesium, TimeHub, TimePictra, TimeProvider, Vite, WinPath, and ZL are registered trademarks of Microchip Technology Incorporated in the U.S.A.",
    "Trademarks\nAdjacent Key Suppression, AKS, Analog-for-the-Digital Age, Any Capacitor, AnyIn, AnyOut, BlueSky, BodyCom, CodeGuard, CryptoAuthentication, CryptoAutomotive, CryptoCompanion, CryptoController, dsPICDEM, dsPICDEM.net, Dynamic Average Matching, DAM, ECAN, EtherGREEN, In-Circuit Serial Programming, ICSP, INICnet, Inter-Chip Connectivity, JitterBlocker, KleerNet, KleerNet logo, memBrain, Mindi, MiWi, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, MultiTRAK, NetDetach, Omniscient Code Generation, PICDEM, PICDEM.net, PICkit, PICtail, PowerSmart, PureSilicon, QMatrix, REAL ICE, Ripple Blocker, SAM-ICE, Serial Quad I/O, SMART-I.S., SQI, SuperSwitcher, SuperSwitcher II, Total Endurance, TSHARC, USBCheck, VariSense, ViewSpan, WiperLock, Wireless DNA, and ZENA are",
    "Trademarks\ntrademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nThe Adaptec logo, Frequency on Demand, Silicon Storage Technology, and Symmcom are registered trademarks of Microchip Technology Inc. in other countries.\nGestIC is a registered trademark of Microchip Technology Germany II GmbH & Co. KG, a subsidiary of Microchip Technology Inc., in other countries.\nAll other trademarks mentioned herein are property of their respective companies.\n\u00a9 2017-2020, Microchip Technology Incorporated, All Rights Reserved.\nISBN: 978-1-5224-6389-4\nFor information regarding Microchip's Quality Management Systems, please visit www.microchip.com/quality.",
    "AMERICAS\nCorporate Office 2355 West Chandler Blvd. Chandler, AZ 85224-6199 Tel: 480-792-7200 Fax: 480-792-7277 Technical Support: http://www.microchip.com/\nsupport\nWeb Address:\nwww.microchip.com\nAtlanta Duluth, GA Tel: 678-957-9614 Fax: 678-957-1455\nAustin, TX Tel: 512-257-3370",
    "Boston\nWestborough, MA Tel: 774-760-0087 Fax: 774-760-0088\nChicago Itasca, IL Tel: 630-285-0071 Fax: 630-285-0075\nDallas Addison, TX Tel: 972-818-7423 Fax: 972-818-2924\nDetroit Novi, MI Tel: 248-848-4000\nHouston, TX Tel: 281-894-5983\nIndianapolis Noblesville, IN Tel: 317-773-8323 Fax: 317-773-5453 Tel: 317-536-2380\nLos Angeles Mission Viejo, CA Tel: 949-462-9523 Fax: 949-462-9608 Tel: 951-273-7800\nRaleigh, NC Tel: 919-844-7510\nNew York, NY Tel: 631-435-6000\nSan Jose, CA Tel: 408-735-9110 Tel: 408-436-4270\nCanada - Toronto Tel: 905-695-1980 Fax: 905-695-2078",
    "ASIA/PACIFIC\nAustralia - Sydney Tel: 61-2-9868-6733\nChina - Beijing Tel: 86-10-8569-7000\nChina - Chengdu Tel: 86-28-8665-5511\nChina - Chongqing Tel: 86-23-8980-9588\nChina - Dongguan Tel: 86-769-8702-9880\nChina - Guangzhou Tel: 86-20-8755-8029\nChina - Hangzhou Tel: 86-571-8792-8115\nChina - Hong Kong SAR Tel: 852-2943-5100\nChina - Nanjing Tel: 86-25-8473-2460\nChina - Qingdao Tel: 86-532-8502-7355\nChina - Shanghai Tel: 86-21-3326-8000\nChina - Shenyang Tel: 86-24-2334-2829\nChina - Shenzhen Tel: 86-755-8864-2200\nChina - Suzhou Tel: 86-186-6233-1526\nChina - Wuhan Tel: 86-27-5980-5300\nChina - Xian Tel: 86-29-8833-7252\nChina - Xiamen",
    "ASIA/PACIFIC\nTel: 86-592-2388138\nChina - Zhuhai\nTel: 86-756-3210040\nIndia - Bangalore Tel: 91-80-3090-4444\nIndia - New Delhi Tel: 91-11-4160-8631\nIndia - Pune Tel: 91-20-4121-0141\nJapan - Osaka Tel: 81-6-6152-7160\nJapan - Tokyo Tel: 81-3-6880- 3770\nKorea - Daegu Tel: 82-53-744-4301\nKorea - Seoul Tel: 82-2-554-7200\nMalaysia - Kuala Lumpur Tel: 60-3-7651-7906\nMalaysia - Penang Tel: 60-4-227-8870\nPhilippines - Manila Tel: 63-2-634-9065\nSingapore Tel: 65-6334-8870\nTaiwan - Hsin Chu Tel: 886-3-577-8366\nTaiwan - Kaohsiung Tel: 886-7-213-7830\nTaiwan - Taipei Tel: 886-2-2508-8600\nThailand - Bangkok Tel: 66-2-694-1351\nVietnam - Ho Chi Minh",
    "ASIA/PACIFIC\nTel: 84-28-5448-2100",
    "EUROPE\nAustria - Wels Tel: 43-7242-2244-39 Fax: 43-7242-2244-393\nDenmark - Copenhagen Tel: 45-4485-5910 Fax: 45-4485-2829\nFinland - Espoo Tel: 358-9-4520-820\nFrance - Paris Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79\nGermany - Garching Tel: 49-8931-9700\nGermany - Haan Tel: 49-2129-3766400\nGermany - Heilbronn Tel: 49-7131-72400\nGermany - Karlsruhe Tel: 49-721-625370\nGermany - Munich Tel: 49-89-627-144-0 Fax: 49-89-627-144-44\nGermany - Rosenheim Tel: 49-8031-354-560\nIsrael - Ra'anana Tel: 972-9-744-7705\nItaly - Milan Tel: 39-0331-742611 Fax: 39-0331-466781\nItaly - Padova Tel: 39-049-7625286",
    "EUROPE\nNetherlands - Drunen Tel: 31-416-690399 Fax: 31-416-690340\nNorway - Trondheim Tel: 47-7288-4388\nPoland - Warsaw Tel: 48-22-3325737\nRomania - Bucharest Tel: 40-21-407-87-50\nSpain - Madrid Tel: 34-91-708-08-90 Fax: 34-91-708-08-91\nSweden - Gothenberg Tel: 46-31-704-60-40\nSweden - Stockholm Tel: 46-8-5090-4654\nUK - Wokingham Tel: 44-118-921-5800 Fax: 44-118-921-5820",
    "Mouser Electronics\nAuthorized Distributor\nClick to View Pricing, Inventory, Delivery & Lifecycle Information:",
    "Microchip:\nPIC18LF26K83-E/ML, PIC18F26K83-I/ML.PIC18F25K83-I/SO = PIC18LF26K83-E/ML. PIC18LF26K83-E/ML, PIC18F25K83-I/SP.PIC18F25K83-I/SO = PIC18LF25K83-E/SS. PIC18LF26K83-E/ML, PIC18F25K83-I/SP.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF25K83-E/SS. PIC18LF26K83-E/ML, PIC18F25K83-I/SS.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF26K83T-I/ML. PIC18LF26K83-E/ML, PIC18F26K83-I/SP. =",
    "Microchip:\nPIC18F26K83T-I/MX. PIC18LF26K83-E/ML, PIC18F25K83-I/ML. = PIC18F26K83T-I/MX. PIC18LF26K83-E/ML, PIC18F25K83-I/ML.PIC18F25K83T-I/MX PIC18F25K83-E/SO = . PIC18LF26K83-E/ML, PIC18F25K83T-I/MX PIC18F25K83-E/SO = PIC18F25K83T-I/SS. PIC18F26K83-I/MX, PIC18F26K83-I/ML.PIC18F25K83-I/SO = PIC18F26K83-I/MX. PIC18F26K83-I/MX, PIC18F25K83-I/SP.PIC18F25K83-I/SO = PIC18LF26K83-I/SO.",
    "Microchip:\nPIC18F26K83-I/MX, PIC18F25K83-I/SP.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF26K83-I/SO. PIC18F26K83-I/MX, PIC18F25K83-I/SS.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF25K83-E/ML. PIC18F26K83-I/MX, PIC18F26K83-I/SP. = PIC18LF26K83T-I/SS. PIC18F26K83-I/MX, PIC18F25K83-I/ML. = PIC18LF26K83T-I/SS. PIC18F26K83-I/MX, PIC18F25K83-I/ML.PIC18F25K83T-I/MX PIC18F25K83-E/SO = .",
    "Microchip:\nPIC18F26K83-I/MX, PIC18F25K83T-I/MX PIC18F25K83-E/SO = PIC18LF25K83-E/SP. PIC18LF26K83-I/SS, PIC18F26K83-I/ML.PIC18F25K83-I/SO = PIC18LF26K83-I/SS. PIC18LF26K83-I/SS, PIC18F25K83-I/SP.PIC18F25K83-I/SO = PIC18F25K83-E/MX. PIC18LF26K83-I/SS, PIC18F25K83-I/SP.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18F25K83-E/MX. PIC18LF26K83-I/SS, PIC18F25K83-I/SS.PIC18F26K83-I/SS PIC18LF25K83T-I/SO =",
    "Microchip:\nPIC18LF25K83-E/SO. PIC18LF26K83-I/SS, PIC18F26K83-I/SP. = PIC18LF26K83-E/SS. PIC18LF26K83-I/SS, PIC18F25K83-I/ML. = PIC18LF26K83-E/SS. PIC18LF26K83-I/SS, PIC18F25K83-I/ML.PIC18F25K83T-I/MX PIC18F25K83-E/SO = . PIC18LF26K83-I/SS, PIC18F25K83T-I/MX PIC18F25K83-E/SO = PIC18LF25K83-E/MX. PIC18F26K83T-I/ML, PIC18F26K83-I/ML.PIC18F25K83-I/SO = PIC18F26K83T-I/ML. PIC18F26K83T-I/ML,",
    "Microchip:\nPIC18F25K83-I/SP.PIC18F25K83-I/SO = PIC18F25K83T-I/SO. PIC18F26K83T-I/ML, PIC18F25K83-I/SP.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18F25K83T-I/SO. PIC18F26K83T-I/ML, PIC18F25K83-I/SS.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF25K83-I/SS. PIC18F26K83T-I/ML, PIC18F26K83-I/SP. = PIC18F25K83-E/ML. PIC18F26K83T-I/ML, PIC18F25K83-I/ML. = PIC18F25K83-E/ML. PIC18F26K83T-I/ML,",
    "Microchip:\nPIC18F25K83-I/ML.PIC18F25K83T-I/MX PIC18F25K83-E/SO = . PIC18F26K83T-I/ML, PIC18F25K83T-I/MX PIC18F25K83-E/SO = PIC18LF25K83-I/SO. PIC18LF26K83-I/SP, PIC18F26K83-I/ML.PIC18F25K83-I/SO = PIC18LF26K83-I/SP. PIC18LF26K83-I/SP, PIC18F25K83-I/SP.PIC18F25K83-I/SO = PIC18LF25K83T-I/MX. PIC18LF26K83-I/SP, PIC18F25K83-I/SP.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF25K83T-I/MX.",
    "Microchip:\nPIC18LF26K83-I/SP, PIC18F25K83-I/SS.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF26K83-E/SP. PIC18LF26K83-I/SP, PIC18F26K83-I/SP. = PIC18F25K83-E/SS. PIC18LF26K83-I/SP, PIC18F25K83-I/ML. = PIC18F25K83-E/SS. PIC18LF26K83-I/SP, PIC18F25K83-I/ML.PIC18F25K83T-I/MX PIC18F25K83-E/SO = . PIC18LF26K83-I/SP, PIC18F25K83T-I/MX PIC18F25K83-E/SO = PIC18F26K83-E/MX. PIC18F25K83-E/SP,",
    "Microchip:\nPIC18F26K83-I/ML.PIC18F25K83-I/SO = PIC18F25K83-E/SP. PIC18F25K83-E/SP, PIC18F25K83-I/SP.PIC18F25K83-I/SO = PIC18LF25K83-I/SP. PIC18F25K83-E/SP, PIC18F25K83-I/SP.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF25K83-I/SP. PIC18F25K83-E/SP, PIC18F25K83-I/SS.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF25K83-I/MX. PIC18F25K83-E/SP, PIC18F26K83-I/SP. = PIC18LF26K83T-I/SO.",
    "Microchip:\nPIC18F25K83-E/SP, PIC18F25K83-I/ML. = PIC18LF26K83T-I/SO. PIC18F25K83-E/SP, PIC18F25K83-I/ML.PIC18F25K83T-I/MX PIC18F25K83-E/SO = . PIC18F25K83-E/SP, PIC18F25K83T-I/MX PIC18F25K83-E/SO = PIC18F25K83-I/MX. PIC18F26K83T-I/SS, PIC18F26K83-I/ML.PIC18F25K83-I/SO = PIC18F26K83T-I/SS. PIC18F26K83T-I/SS, PIC18F25K83-I/SP.PIC18F25K83-I/SO = PIC18F26K83-E/ML. PIC18F26K83T-I/SS,",
    "Microchip:\nPIC18F25K83-I/SP.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18F26K83-E/ML. PIC18F26K83T-I/SS, PIC18F25K83-I/SS.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF25K83T-I/SS. PIC18F26K83T-I/SS, PIC18F26K83-I/SP. = PIC18LF26K83-I/ML. PIC18F26K83T-I/SS, PIC18F25K83-I/ML. = PIC18LF26K83-I/ML. PIC18F26K83T-I/SS, PIC18F25K83-I/ML.PIC18F25K83T-I/MX PIC18F25K83-E/SO = . PIC18F26K83T-I/SS,",
    "Microchip:\nPIC18F25K83T-I/MX PIC18F25K83-E/SO = PIC18LF26K83-E/SO. PIC18F26K83-E/SP, PIC18F26K83-I/ML.PIC18F25K83-I/SO = PIC18F26K83-E/SP. PIC18F26K83-E/SP, PIC18F25K83-I/SP.PIC18F25K83-I/SO = PIC18LF26K83T-I/MX. PIC18F26K83-E/SP, PIC18F25K83-I/SP.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF26K83T-I/MX. PIC18F26K83-E/SP, PIC18F25K83-I/SS.PIC18F26K83-I/SS PIC18LF25K83T-I/SO =",
    "Microchip:\nPIC18F26K83-E/SS. PIC18F26K83-E/SP, PIC18F26K83-I/SP. = PIC18LF26K83-E/MX. PIC18F26K83-E/SP, PIC18F25K83-I/ML. = PIC18LF26K83-E/MX. PIC18F26K83-E/SP, PIC18F25K83-I/ML.PIC18F25K83T-I/MX PIC18F25K83-E/SO = . PIC18F26K83-E/SP, PIC18F25K83T-I/MX PIC18F25K83-E/SO = PIC18LF25K83T-I/ML. PIC18F25K83T-I/ML, PIC18F26K83-I/ML.PIC18F25K83-I/SO = PIC18F25K83T-I/ML. PIC18F25K83T-I/ML,",
    "Microchip:\nPIC18F25K83-I/SP.PIC18F25K83-I/SO = PIC18LF25K83-I/ML. PIC18F25K83T-I/ML, PIC18F25K83-I/SP.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF25K83-I/ML. PIC18F25K83T-I/ML, PIC18F25K83-I/SS.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18LF26K83-I/MX. PIC18F25K83T-I/ML, PIC18F26K83-I/SP. = PIC18F26K83T-I/SO. PIC18F25K83T-I/ML, PIC18F25K83-I/ML. = PIC18F26K83T-I/SO. PIC18F25K83T-I/ML,",
    "Microchip:\nPIC18F25K83-I/ML.PIC18F25K83T-I/MX PIC18F25K83-E/SO = . PIC18F25K83T-I/ML, PIC18F25K83T-I/MX PIC18F25K83-E/SO = PIC18F26K83-E/SO. , PIC18F26K83-I/ML.PIC18F25K83-I/SO = . , PIC18F25K83-I/SP.PIC18F25K83-I/SO = . , PIC18F25K83-I/SP.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18F26K83-E/SSVAO. , PIC18F25K83-I/SS.PIC18F26K83-I/SS PIC18LF25K83T-I/SO = PIC18F26K83-E/SSVAO. , PIC18F26K83-I/SP. =",
    "Microchip:\n. , PIC18F25K83-I/ML. = . , PIC18F25K83-I/ML.PIC18F25K83T-I/MX PIC18F25K83-E/SO = PIC18F25K83-E/SSVAO. , PIC18F25K83T-I/MX PIC18F25K83-E/SO = PIC18F25K83-E/SSVAO"
]
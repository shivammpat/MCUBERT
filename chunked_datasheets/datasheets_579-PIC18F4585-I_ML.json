[
    "Power Managed Modes:\n-One, two or four PWM outputs\n\u00b7 Run: CPU on, peripherals on\n\u00b7 Idle: CPU off, peripherals on\n\u00b7 Sleep: CPU off, peripherals off\n\u00b7 Idle mode currents down to 5.8 \uf06d A typical\n\u00b7 Sleep mode currents down to 0.1 \uf06d A typical\n\u00b7 Watchdog Timer: 2.1 \uf06d A\n\u00b7 Timer1 Oscillator: 1.1 \uf06d A, 32 kHz, 2V\n\u00b7 Two-Speed Oscillator Start-up",
    "Flexible Oscillator Structure:\n\u00b7 Four Crystal modes, up to 40 MHz\n\u00b7 4x Phase Lock Loop (PLL) - available for crystal and internal oscillators\n\u00b7 Two External RC modes, up to 4 MHz\n\u00b7 Two External Clock modes, up to 40 MHz\n\u00b7 Internal oscillator block:\n-8 user selectable frequencies, from 31 kHz to 8 MHz\n-Provides a complete range of clock speeds, from 31 kHz to 32 MHz when used with PLL\n-User tunable to compensate for frequency drift\n\u00b7 Secondary oscillator using Timer1 @ 32 kHz\n\u00b7 Fail-Safe Clock Monitor\n-Allows for safe shutdown if peripheral clock stops",
    "Special Microcontroller Features:\n\u00b7 C compiler optimized architecture with optional extended instruction set\n\u00b7 100,000 erase/write cycle Enhanced Flash program memory typical\n\u00b7 1,000,000 erase/write cycle Data EEPROM memory typical\n\u00b7 Flash/Data EEPROM Retention: > 40 years\n\u00b7 Self-programmable under software control\n\u00b7 Priority levels for interrupts\n\u00b7 8 x 8 Single Cycle Hardware Multiplier\n\u00b7 Extended Watchdog Timer (WDT):\n-Programmable period from 41 ms to 131s\n\u00b7 Single-Supply 5V In-Circuit Serial Programming\u2122 (ICSP\u2122) via two pins\n\u00b7 In-Circuit Debug (ICD) via two pins\n\u00b7 Wide operating voltage range: 2.0V to 5.5V",
    "Peripheral Highlights:\n\u00b7 High current sink/source 25 mA/25 mA\n\u00b7 Three external interrupts\n\u00b7 One Capture/Compare/PWM (CCP1) module\n\u00b7 Enhanced Capture/Compare/PWM (ECCP1) module (40/44-pin devices only):\n-Selectable polarity\n-Programmable dead time\n-Auto-Shutdown and Auto-Restart\n\u00b7 Master Synchronous Serial Port (MSSP) module supporting 3-wire SPI (all 4 modes) and I 2 C\u2122 Master and Slave modes\n\u00b7 Enhanced Addressable USART module:\n-Supports RS-485, RS-232 and LIN 1.3\n-RS-232 operation using internal oscillator block (no external crystal required)\n-Auto-Wake-up on Start bit\n-Auto-Baud Detect\n\u00b7 10-bit, up to 11-channel Analog-to-Digital Converter module (A/D), up to 100 Ksps\n-Auto-acquisition capability\n-Conversion available during Sleep\n\u00b7 Dual analog comparators with input multiplexing",
    "ECAN Module Features:\n\u00b7 Message bit rates up to 1 Mbps\n\u00b7 Conforms to CAN 2.0B ACTIVE Specification\n\u00b7 Fully backward compatible with PIC18XXX8 CAN modules\n\u00b7 Three modes of operation:\n-Legacy, Enhanced Legacy, FIFO\n\u00b7 Three dedicated transmit buffers with prioritization\n\u00b7 Two dedicated receive buffers\n\u00b7 Six programmable receive/transmit buffers\n\u00b7 Three full 29-bit acceptance masks\n\u00b7 16 full 29-bit acceptance filters w/ dynamic association\n\u00b7 DeviceNet\u2122 data byte filter support\n\u00b7 Automatic remote frame handling\n\u00b7 Advanced error management features",
    "PIC18F2585/2680/4585/4680\nPIC18F2585, Program Memory.Flash (bytes) = 48K. PIC18F2585, Program Memory.# Single-Word Instructions = 24576. PIC18F2585, Data Memory.SRAM (bytes) = 3328. PIC18F2585, Data Memory.EEPROM (bytes) = 1024. PIC18F2585, I/O. = 28. PIC18F2585, 10-Bit A/D (ch). = 8. PIC18F2585, CCP1/ ECCP1 (PWM).CCP1/ ECCP1 (PWM) = 1/0. PIC18F2585, MSSP.SPI = Y. PIC18F2585, MSSP.Master I 2 C\u2122 = Y. PIC18F2585, EUSART. = 1. PIC18F2585, Comp. = 0. PIC18F2585, Timers 8/16-bit = 1/3. PIC18F2680, Program Memory.Flash (bytes) = 64K. PIC18F2680, Program Memory.#",
    "PIC18F2585/2680/4585/4680\nSingle-Word Instructions = 32768. PIC18F2680, Data Memory.SRAM (bytes) = 3328. PIC18F2680, Data Memory.EEPROM (bytes) = 1024. PIC18F2680, I/O. = 28. PIC18F2680, 10-Bit A/D (ch). = 8. PIC18F2680, CCP1/ ECCP1 (PWM).CCP1/ ECCP1 (PWM) = 1/0. PIC18F2680, MSSP.SPI = Y. PIC18F2680, MSSP.Master I 2 C\u2122 = Y. PIC18F2680, EUSART. = 1. PIC18F2680, Comp. = 0. PIC18F2680, Timers 8/16-bit = 1/3. PIC18F4585, Program Memory.Flash (bytes) = 48K. PIC18F4585, Program Memory.# Single-Word Instructions = 24576. PIC18F4585, Data Memory.SRAM (bytes) = 3328.",
    "PIC18F2585/2680/4585/4680\nPIC18F4585, Data Memory.EEPROM (bytes) = 1024. PIC18F4585, I/O. = 44. PIC18F4585, 10-Bit A/D (ch). = 11. PIC18F4585, CCP1/ ECCP1 (PWM).CCP1/ ECCP1 (PWM) = 1/1. PIC18F4585, MSSP.SPI = Y. PIC18F4585, MSSP.Master I 2 C\u2122 = Y. PIC18F4585, EUSART. = 1. PIC18F4585, Comp. = 2. PIC18F4585, Timers 8/16-bit = 1/3. PIC18F4680, Program Memory.Flash (bytes) = 64K. PIC18F4680, Program Memory.# Single-Word Instructions = 32768. PIC18F4680, Data Memory.SRAM (bytes) = 3328. PIC18F4680, Data Memory.EEPROM (bytes) = 1024. PIC18F4680,",
    "PIC18F2585/2680/4585/4680\nI/O. = 40/44. PIC18F4680, 10-Bit A/D (ch). = 11. PIC18F4680, CCP1/ ECCP1 (PWM).CCP1/ ECCP1 (PWM) = 1/1. PIC18F4680, MSSP.SPI = Y. PIC18F4680, MSSP.Master I 2 C\u2122 = Y. PIC18F4680, EUSART. = 1. PIC18F4680, Comp. = 2. PIC18F4680, Timers 8/16-bit = 1/3",
    "Table of Contents\n1.0\nDevice Overview .......................................................................................................................................................................... 7",
    "Table of Contents\n2.0, 1 = Oscillator Configurations ............................................................................................................................................................. 2.0, 2 = 23. 3.0, 1 = Power Managed Modes",
    "Table of Contents\n.............................................................................................................................................................. 3.0, 2 = 33. 4.0, 1 =",
    "Table of Contents\nReset........................................................................................................................................................................................... 4.0, 2 = 41. 5.0, 1 = Memory",
    "Table of Contents\nOrganization.................................................................................................................................................................. 5.0, 2 = 61. 6.0, 1 = Flash Program",
    "Table of Contents\nMemory............................................................................................................................................................... 6.0, 2 = 95. 7.0, 1 = Data EEPROM",
    "Table of Contents\nMemory............................................................................................................................................................ 7.0, 2 = 105. 8.0, 1 = 8 x 8 Hardware",
    "Table of Contents\nMultiplier........................................................................................................................................................... 8.0, 2 = 111. 9.0, 1 = Interrupts",
    "Table of Contents\n................................................................................................................................................................................... 9.0, 2 = 113. 10.0, 1 = I/O Ports",
    "Table of Contents\n.................................................................................................................................................................................... 10.0, 2 = 129. 11.0, 1 = Timer0 Module",
    "Table of Contents\n.......................................................................................................................................................................... 11.0, 2 = 147. 12.0, 1 = Timer1 Module",
    "Table of Contents\n.......................................................................................................................................................................... 12.0, 2 = 151. 13.0, 1 = Timer2 Module",
    "Table of Contents\n.......................................................................................................................................................................... 13.0, 2 = 157. 14.0, 1 = Timer3 Module",
    "Table of Contents\n.......................................................................................................................................................................... 14.0, 2 = 159. 15.0, 1 = Capture/Compare/PWM (CCP1) Modules",
    "Table of Contents\n................................................................................................................................ 15.0, 2 = 163. 16.0, 1 = Enhanced Capture/Compare/PWM (ECCP1)",
    "Table of Contents\nModule............................................................................................................... 16.0, 2 = 173. 17.0, 1 = Master Synchronous Serial Port (MSSP) Module",
    "Table of Contents\n..................................................................................................................... 17.0, 2 = 187. 18.0, 1 = Enhanced Universal Synchronous Receiver Transmitter (EUSART)........................................................................................ 18.0, 2 = 227. 19.0, 1 = 10-Bit",
    "Table of Contents\nAnalog-to-Digital Converter (A/D) Module ...................................................................................................................... 19.0, 2 = 247. 20.0, 1 = Comparator",
    "Table of Contents\nModule................................................................................................................................................................... 20.0, 2 = 257. 21.0, 1 = Comparator Voltage Reference",
    "Table of Contents\nModule.................................................................................................................................... 21.0, 2 = 263. 22.0, 1 = High/Low-Voltage Detect",
    "Table of Contents\n(HLVD).............................................................................................................................................. 22.0, 2 = 267. 23.0, 1 = ECAN\u2122 Technology",
    "Table of Contents\n................................................................................................................................................................. 23.0, 2 = 273. 24.0, 1 = Special Features of the",
    "Table of Contents\nCPU..................................................................................................................................................... 24.0, 2 = 343. 25.0, 1 = Instruction Set",
    "Table of Contents\nSummary........................................................................................................................................................... 25.0, 2 = 361. 26.0, 1 = Development",
    "Table of Contents\nSupport................................................................................................................................................................ 26.0, 2 = 411. 27.0, 1 = Electrical",
    "Table of Contents\nCharacteristics........................................................................................................................................................... 27.0, 2 = 415. 28.0, 1 = DC and AC Characteristics Graphs and",
    "Table of Contents\nTables........................................................................................................................ 28.0, 2 = 451. 29.0, 1 = Packaging",
    "Table of Contents\nInformation............................................................................................................................................................... 29.0, 2 = 453. Appendix, 1 = A: Revision",
    "Table of Contents\nHistory.............................................................................................................................................................. Appendix, 2 = 461. Appendix B: Device Differences",
    "Table of Contents\n........................................................................................................................................................, 1 = Appendix B: Device Differences",
    "Table of Contents\n......................................................................................................................................................... Appendix B: Device Differences",
    "Table of Contents\n........................................................................................................................................................, 2 = 461. Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 1 = Appendix C: Conversion Considerations",
    "Table of Contents\n............................................................................................................................................ Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 2 = 462. Appendix D: Migration From Baseline to Enhanced Devices",
    "Table of Contents\n............................................................................................................, 1 = Appendix D: Migration From Baseline to Enhanced Devices ............................................................................................................. Appendix D: Migration From Baseline to Enhanced Devices",
    "Table of Contents\n............................................................................................................, 2 = 462. Appendix E: Migration from Mid-Range to Enhanced Devices .........................................................................................................., 1 = Appendix E: Migration from Mid-Range to Enhanced Devices",
    "Table of Contents\n........................................................................................................... Appendix E: Migration from Mid-Range to Enhanced Devices .........................................................................................................., 2 = 463. Appendix F: Migration from High-End to Enhanced",
    "Table of Contents\nDevices............................................................................................................., 1 = Appendix F: Migration from High-End to Enhanced Devices.............................................................................................................. Appendix F: Migration from High-End to Enhanced",
    "Table of Contents\nDevices............................................................................................................., 2 = 463. The Microchip Web",
    "Table of Contents\nSite....................................................................................................................................................................., 1 = The Microchip Web",
    "Table of Contents\nSite...................................................................................................................................................................... The Microchip Web",
    "Table of Contents\nSite....................................................................................................................................................................., 2 = 477. Customer Change Notification Service",
    "Table of Contents\n.............................................................................................................................................., 1 = Customer Change Notification Service",
    "Table of Contents\n............................................................................................................................................... Customer Change Notification Service",
    "Table of Contents\n.............................................................................................................................................., 2 = 477. Customer",
    "Table of Contents\nSupport.............................................................................................................................................................................., 1 = Customer",
    "Table of Contents\nSupport............................................................................................................................................................................... Customer",
    "Table of Contents\nSupport.............................................................................................................................................................................., 2 = 477. Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 1 = Reader",
    "Table of Contents\nResponse............................................................................................................................................................................... Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 2 = 478. PIC18F2585/2680/4585/4680 Product Identification System",
    "Table of Contents\n............................................................................................................, 1 = PIC18F2585/2680/4585/4680 Product Identification System ............................................................................................................. PIC18F2585/2680/4585/4680 Product Identification",
    "Table of Contents\nSystem ............................................................................................................, 2 = 479",
    "TO OUR VALUED CUSTOMERS\nIt is our intention to provide our valued customers with the best documentation possible to ensure successful use of your Microchip products. To this end, we will continue to improve our publications to better suit your needs. Our publications will be refined and enhanced as new volumes and updates are introduced.\nIf you have any questions or comments regarding this publication, please contact the Marketing Communications Department via E-mail at docerrors@microchip.com . We welcome your feedback.",
    "Most Current Data Sheet\nTo obtain the most up-to-date version of this data sheet, please register at our Worldwide Website at:",
    "http://www.microchip.com\nYou can determine the version of a data sheet by examining its literature number found on the bottom outside corner of any page. The last character of the literature number is the version number, (e.g., DS30000000A is version A of document DS30000000).",
    "Errata\nAn errata sheet, describing minor operational differences from the data sheet and recommended workarounds, may exist for current devices. As device/documentation issues become known to us, we will publish an errata sheet. The errata will specify the revision of silicon and revision of document to which it applies.\nTo determine if an errata sheet exists for a particular device, please check with one of the following:\n\u00b7 Microchip's Worldwide Website; http://www.microchip.com\n\u00b7 Your local Microchip sales office (see last page)\nWhen contacting a sales office, please specify which device, revision of silicon and data sheet (include literature number) you are using.",
    "Customer Notification System\nRegister on our website at www.microchip.com to receive the most current information on all of our products.",
    "1.0 DEVICE OVERVIEW\nThis document contains device specific information for the following devices:\n\u00b7 PIC18F2585\n\u00b7 PIC18F2680\n\u00b7 PIC18F4585\n\u00b7 PIC18F4680\nThis family of devices offers the advantages of all PIC18 microcontrollers -namely, high computational performance at an economical price - with the addition of high-endurance, Enhanced Flash program memory. In addition to these features, the PIC18F2585/2680/4585/4680 family introduces design enhancements  that  make  these  microcontrollers a logical choice for many high-performance, power sensitive applications.",
    "1.1.1 TECHNOLOGY\nAll of the devices in the PIC18F2585/2680/4585/4680 family incorporate a range of features that can significantly  reduce  power  consumption  during  operation. Key items include:",
    "1.1.1 TECHNOLOGY\n\u00b7 Alternate Run Modes: By clocking the controller from the Timer1 source or the internal oscillator block, power consumption during code execution can be reduced by as much as 90%.\n\u00b7 Multiple Idle Modes: The controller can also run with its CPU core disabled but the peripherals still active. In these states, power consumption can be reduced even further, to as little as 4% of normal operation requirements.\n\u00b7 On-the-fly Mode Switching: The power managed modes are invoked by user code during operation, allowing the user to incorporate power-saving ideas into their application's software design.\n\u00b7 Lower Consumption in Key Modules: The power requirements for both Timer1 and the Watchdog Timer have been reduced by up to 80%, with typical values of 1.1 and 2.1 \uf06d A, respectively.\n\u00b7 Extended Instruction Set: In addition to the standard 75 instructions of the PIC18 instruction set, PIC18F2585/2680/4585/4680 devices also provide an optional extension to the core CPU functionality. The added features include eight additional instructions that augment indirect and indexed addressing operations and the implementation of Indexed Literal Offset Addressing mode for many of the standard PIC18 instructions.",
    "1.1.2 MULTIPLE OSCILLATOR OPTIONS AND FEATURES\nAll of the devices in the PIC18F2585/2680/4585/4680 family  offer  ten  different  oscillator  options,  allowing users a wide range of choices in developing application hardware. These include:\n\u00b7 Four Crystal modes, using crystals or ceramic resonators\n\u00b7 Two External Clock modes, offering the option of using two pins (oscillator input and a divide-by-4 clock output) or one pin (oscillator input, with the second pin reassigned as general I/O)\n\u00b7 Two External RC Oscillator modes with the same pin options as the External Clock modes\n\u00b7 An internal oscillator block which provides an 8 MHz clock (\u00b12% accuracy) and an INTRC source (approximately 31 kHz, stable over temperature and VDD), as well as a range of 6 user selectable clock frequencies, between 125 kHz to 4 MHz, for a total of 8 clock frequencies. This option frees the two oscillator pins for use as additional general purpose I/O.",
    "1.1.2 MULTIPLE OSCILLATOR OPTIONS AND FEATURES\n\u00b7 A Phase Lock Loop (PLL) frequency multiplier, available to both the high-speed crystal and internal oscillator modes, which allows clock speeds of up to 40 MHz. Used with the internal oscillator, the PLL gives users a complete selection of clock speeds, from 31 kHz to 32 MHz - all without using an external crystal or clock circuit.\nBesides its availability as a clock source, the internal oscillator block provides a stable reference source that gives the family additional features for robust operation:\n\u00b7 Fail-Safe Clock Monitor: This option constantly monitors the main clock source against a reference signal provided by the internal oscillator. If a clock failure occurs, the controller is switched to the internal oscillator block, allowing for continued low-speed operation or a safe application shutdown.\n\u00b7 Two-Speed Start-up: This option allows the internal oscillator to serve as the clock source from Power-on Reset, or wake-up from Sleep mode, until the primary clock source is available.",
    "1.2 Other Special Features\n\u00b7 Memory Endurance: The Enhanced Flash cells for both program memory and data EEPROM are rated to last for many thousands of erase/write cycles - up to 100,000 for program memory and 1,000,000 for EEPROM. Data retention without refresh is conservatively estimated to be greater than 40 years.\n\u00b7 Self-programmability: These devices can write to their own program memory spaces under internal software control. By using a bootloader routine located in the protected Boot Block at the top of program memory, it becomes possible to create an application that can update itself in the field.\n\u00b7 Extended Instruction Set: The PIC18F2585/2680/4585/4680 family introduces an optional extension to the PIC18 instruction set, which adds 8 new instructions and an Indexed Addressing mode. This extension, enabled as a device configuration option, has been specifically designed to optimize re-entrant application code originally developed in high-level languages, such as C.",
    "1.2 Other Special Features\n\u00b7 Enhanced CCP1 module: In PWM mode, this module provides 1, 2 or 4 modulated outputs for controlling half-bridge and full-bridge drivers. Other features include Auto-Shutdown, for disabling PWM outputs on interrupt or other select conditions and Auto-Restart, to reactivate outputs once the condition has cleared.\n\u00b7 Enhanced Addressable USART: This serial communication module is capable of standard RS-232 operation and provides support for the LIN bus protocol. Other enhancements include automatic baud rate detection and a 16-bit Baud Rate Generator for improved resolution. When the microcontroller is using the internal oscillator block, the EUSART provides stable operation for applications that talk to the outside world without using an external crystal (or its accompanying power requirement).\n\u00b7 10-bit A/D Converter: This module incorporates programmable acquisition time, allowing for a channel to be selected and a conversion to be initiated without waiting for a sampling period and thus, reduce code overhead.",
    "1.2 Other Special Features\n\u00b7 Extended Watchdog Timer (WDT): This enhanced version incorporates a 16-bit prescaler, allowing a time-out range from 4 ms to over 131 seconds, that is stable across operating voltage and temperature.",
    "1.3 Details on Individual Family Members\nDevices in the PIC18F2585/2680/4585/4680 family are available in 28-pin (PIC18F2X8X) and 40/44-pin (PIC18F4X8X) packages. Block diagrams for the two groups are shown in Figure 1-1 and Figure 1-2.\nThe devices are differentiated from each other in six ways:",
    "1.3 Details on Individual Family Members\n1. Flash program memory (48 Kbytes for PIC18FX585 devices, 64 Kbytes for PIC18FX680).\n2. A/D channels (8 for PIC18F2X8X devices, 11 for PIC18F4X8X devices).\n3. I/O ports (3 bidirectional ports and 1 input only port  on  PIC18F2X8X  devices,  5  bidirectional ports on PIC18F4X8X devices).\n4. CCP1  and  Enhanced  CCP1  implementation (PIC18F2X8X devices have 1 standard CCP1 module, PIC18F4X8X devices have one standard CCP1 module and one ECCP1 module).\n5. Parallel Slave Port (present only on PIC18F4X8X devices).\n6. PIC18F4X8X devices provide two comparators.\nAll other features for devices in this family are identical. These are summarized in Table 1-1.\nThe pinouts for all devices are listed in Table 1-2 and Table 1-3.",
    "1.3 Details on Individual Family Members\nLike  all  Microchip  PIC18  devices,  members  of  the PIC18F2585/2680/4585/4680  family  are  available  as both standard and low-voltage devices. Standard devices with Enhanced Flash memory, designated with an  'F'  in  the  part  number  (such  as  PIC18 F 2585), accommodate an operating VDD range of 4.2V to 5.5V. Low-voltage parts, designated by 'LF' (such as PIC18 LF 2585), function over an extended VDD range of 2.0V to 5.5V.",
    "TABLE 1-1: DEVICE FEATURES\nOperating Frequency, PIC18F2585 = DC - 40 MHz. Operating Frequency, PIC18F2680 = DC - 40 MHz. Operating Frequency, PIC18F4585 = DC - 40 MHz. Operating Frequency, PIC18F4680 = DC - 40 MHz. Program Memory (Bytes), PIC18F2585 = 49152. Program Memory (Bytes), PIC18F2680 = 65536. Program Memory (Bytes), PIC18F4585 = 49152. Program Memory (Bytes), PIC18F4680 = 65536. Program Memory (Instructions), PIC18F2585 = 24576. Program Memory (Instructions), PIC18F2680 = 32768. Program Memory (Instructions), PIC18F4585 = 24576. Program Memory (Instructions), PIC18F4680 = 32768. Data Memory (Bytes), PIC18F2585 = 3328. Data Memory (Bytes), PIC18F2680 = 3328. Data Memory (Bytes), PIC18F4585 = 3328. Data Memory (Bytes), PIC18F4680 = 3328. Data EEPROM Memory",
    "TABLE 1-1: DEVICE FEATURES\n(Bytes), PIC18F2585 = 1024. Data EEPROM Memory (Bytes), PIC18F2680 = 1024. Data EEPROM Memory (Bytes), PIC18F4585 = 1024. Data EEPROM Memory (Bytes), PIC18F4680 = 1024. Interrupt Sources, PIC18F2585 = 19. Interrupt Sources, PIC18F2680 = 19. Interrupt Sources, PIC18F4585 = 20. Interrupt Sources, PIC18F4680 = 20. I/O Ports, PIC18F2585 = Ports A, B, C, (E). I/O Ports, PIC18F2680 = Ports A, B, C, (E). I/O Ports, PIC18F4585 = Ports A, B, C, D, E. I/O Ports, PIC18F4680 = Ports A, B, C, D, E. Timers, PIC18F2585 = 4. Timers, PIC18F2680 = 4. Timers, PIC18F4585 = 4. Timers, PIC18F4680 = 4.",
    "TABLE 1-1: DEVICE FEATURES\nCapture/Compare/PWM Modules, PIC18F2585 = 1. Capture/Compare/PWM Modules, PIC18F2680 = 1. Capture/Compare/PWM Modules, PIC18F4585 = 1. Capture/Compare/PWM Modules, PIC18F4680 = 1. Enhanced Capture/ Compare/PWM Modules, PIC18F2585 = 0. Enhanced Capture/ Compare/PWM Modules, PIC18F2680 = 0. Enhanced Capture/ Compare/PWM Modules, PIC18F4585 = 1. Enhanced Capture/ Compare/PWM Modules, PIC18F4680 = 1. ECAN Module, PIC18F2585 = 1. ECAN Module, PIC18F2680 = 1. ECAN Module, PIC18F4585 = 1. ECAN Module, PIC18F4680 = 1. Serial Communications, PIC18F2585 = MSSP, Enhanced USART. Serial Communications, PIC18F2680 = MSSP, Enhanced USART. Serial Communications, PIC18F4585 = MSSP, Enhanced USART. Serial Communications, PIC18F4680 = MSSP, Enhanced",
    "TABLE 1-1: DEVICE FEATURES\nUSART. Parallel Communications (PSP), PIC18F2585 = No. Parallel Communications (PSP), PIC18F2680 = No. Parallel Communications (PSP), PIC18F4585 = Yes. Parallel Communications (PSP), PIC18F4680 = Yes. 10-bit Analog-to-Digital Module, PIC18F2585 = 8 Input Channels. 10-bit Analog-to-Digital Module, PIC18F2680 = 8 Input Channels. 10-bit Analog-to-Digital Module, PIC18F4585 = 11 Input Channels. 10-bit Analog-to-Digital Module, PIC18F4680 = 11 Input Channels. Comparators, PIC18F2585 = 0. Comparators, PIC18F2680 = 0. Comparators, PIC18F4585 = 2. Comparators, PIC18F4680 = 2. Resets (and Delays), PIC18F2585 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Resets (and Delays), PIC18F2680 =",
    "TABLE 1-1: DEVICE FEATURES\nPOR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Resets (and Delays), PIC18F4585 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Resets (and Delays), PIC18F4680 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Programmable High/Low-Voltage Detect, PIC18F2585 = Yes. Programmable High/Low-Voltage Detect, PIC18F2680 = Yes. Programmable High/Low-Voltage Detect, PIC18F4585 = Yes. Programmable High/Low-Voltage Detect, PIC18F4680 = Yes. Programmable Brown-out Reset, PIC18F2585 = Yes. Programmable Brown-out Reset, PIC18F2680 = Yes. Programmable Brown-out Reset, PIC18F4585 = Yes. Programmable Brown-out Reset, PIC18F4680 =",
    "TABLE 1-1: DEVICE FEATURES\nYes. Instruction Set, PIC18F2585 = 75 Instructions; 83 with Extended Instruction Set enabled. Instruction Set, PIC18F2680 = 75 Instructions; 83 with Extended Instruction Set enabled. Instruction Set, PIC18F4585 = 75 Instructions; 83 with Extended Instruction Set enabled. Instruction Set, PIC18F4680 = 75 Instructions; 83 with Extended Instruction Set enabled. Packages, PIC18F2585 = 28-pin PDIP 28-pin SOIC. Packages, PIC18F2680 = 28-pin PDIP 28-pin SOIC. Packages, PIC18F4585 = 40-pin PDIP 44-pin QFN 44-pin TQFP. Packages, PIC18F4680 = 40-pin PDIP 44-pin QFN 44-pin TQFP",
    "FIGURE 1-1: PIC18F2585/2680 (28-PIN) BLOCK DIAGRAM\nNote 1: RE3 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.\n2: OSC1/CLKI and OSC2/CLKO are only available in select oscillator modes and when these pins are not being used as digital I/O. Refer to Section 2.0 'Oscillator Configurations' for additional information.",
    "FIGURE 1-2: PIC18F4585/4680 (40/44-PIN) BLOCK DIAGRAM\nNote 1: RE3 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.\n2: OSC1/CLKI and OSC2/CLKO are only available in select oscillator modes and when these pins are not being used as digital I/O. Refer to Section 2.0 'Oscillator Configurations' for additional information.",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS\nMCLR/VPP/RE3, Pin Number.PDIP, SOIC = 1. MCLR/VPP/RE3, Pin Type. = . MCLR/VPP/RE3, Buffer Type. = . MCLR/VPP/RE3, Description. = Master Clear (input) or programming voltage (input).. MCLR, Pin Number.PDIP, SOIC = . MCLR, Pin Type. = I. MCLR, Buffer Type. = ST. MCLR, Description. = Master Clear (Reset) input. This pin is an active-low. VPP, Pin Number.PDIP, SOIC = . VPP, Pin Type. = P. VPP, Buffer Type. = . VPP, Description. = Reset to the device. Programming voltage input.. RE3, Pin Number.PDIP, SOIC = . RE3, Pin Type. = I. RE3, Buffer Type. = ST. RE3, Description. = Digital input.. OSC1/CLKI/RA7, Pin Number.PDIP, SOIC = 9.",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS\nOSC1/CLKI/RA7, Pin Type. = . OSC1/CLKI/RA7, Buffer Type. = . OSC1/CLKI/RA7, Description. = Oscillator crystal or external clock input.. OSC1, Pin Number.PDIP, SOIC = . OSC1, Pin Type. = I. OSC1, Buffer Type. = ST. OSC1, Description. = Oscillator crystal input or external clock source input. ST buffer when configured in RCmode; CMOSotherwise.. CLKI, Pin Number.PDIP, SOIC = . CLKI, Pin Type. = I. CLKI, Buffer Type. = CMOS. CLKI, Description. = External clock source input. Always associated with pin function OSC1. (See related OSC1/CLKI, OSC2/CLKO pins.). RA7, Pin Number.PDIP, SOIC = . RA7, Pin Type. = I/O. RA7, Buffer Type. = TTL. RA7, Description. = General purpose",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS\nI/O pin.. OSC2/CLKO/RA6, Pin Number.PDIP, SOIC = 10. OSC2/CLKO/RA6, Pin Type. = . OSC2/CLKO/RA6, Buffer Type. = . OSC2/CLKO/RA6, Description. = Oscillator crystal or clock output.. OSC2, Pin Number.PDIP, SOIC = . OSC2, Pin Type. = O. OSC2, Buffer Type. = -. OSC2, Description. = Oscillator crystal output. Connects to crystal or resonator in Crystal Oscillator mode.. CLKO, Pin Number.PDIP, SOIC = . CLKO, Pin Type. = O. CLKO, Buffer Type. = -. CLKO, Description. = In RC mode, OSC2 pin outputs CLKO which has 1/4 the frequency of OSC1 and denotes the instruction cycle rate.. RA6, Pin Number.PDIP, SOIC = . RA6, Pin Type. = I/O.",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS\nRA6, Buffer Type. = TTL. RA6, Description. = General purpose I/O pin.\nLegend:\nTTL = TTL compatible input CMOS= CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels I= Input\nO = Output P\n= Power",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRA0/AN0 RA0 AN0 RA1/AN1 RA1 AN1 RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+ RA3 AN3 VREF+ RA4/T0CKI RA4 T0CKI RA5/AN4/SS/HLVDIN RA5 AN4 SS HLVDIN RA6, Pin Number.PDIP, SOIC = 2 3 4 5 6 7. RA0/AN0 RA0 AN0 RA1/AN1 RA1 AN1 RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+ RA3 AN3 VREF+ RA4/T0CKI RA4 T0CKI RA5/AN4/SS/HLVDIN RA5 AN4 SS HLVDIN RA6, Pin Type. = I/O I I/O I I/O I I I/O I I I/O I I/O I I I. RA0/AN0 RA0 AN0 RA1/AN1",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRA1 AN1 RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+ RA3 AN3 VREF+ RA4/T0CKI RA4 T0CKI RA5/AN4/SS/HLVDIN RA5 AN4 SS HLVDIN RA6, Buffer Type. = TTL Analog TTL Analog TTL Analog Analog TTL Analog Analog TTL ST TTL Analog TTL Analog. RA0/AN0 RA0 AN0 RA1/AN1 RA1 AN1 RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+ RA3 AN3 VREF+ RA4/T0CKI RA4 T0CKI RA5/AN4/SS/HLVDIN RA5 AN4 SS HLVDIN RA6, Description. = PORTA is a bidirectional I/O port. Digital I/O. Analog input 0. Digital I/O. Analog input 1. Digital I/O. Analog input 2. A/D reference voltage",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\n(low) input. Digital I/O. Analog input 3. A/D reference voltage (high) input. Digital I/O. Timer0 external clock input. Digital I/O. Analog input 4. SPI slave select input. High/Low-Voltage Detect input. See the OSC2/CLKO/RA6 pin. See the OSC1/CLKI/RA7 pin.\nLegend:\nTTL = TTL compatible input CMOS= CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels I= Input\nO = Output P\n= Power",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB0/INT0/AN10, Pin Number.PDIP, SOIC = 21. RB0/INT0/AN10, Pin.Type = . RB0/INT0/AN10, Buffer Type. = . RB0/INT0/AN10, Description. = programmed for internal weak pull-ups on all inputs. Digital I/O.. RB0, Pin Number.PDIP, SOIC = . RB0, Pin.Type = I/O. RB0, Buffer Type. = TTL. RB0, Description. = External interrupt. INT0 AN10, Pin Number.PDIP, SOIC = . INT0 AN10, Pin.Type = I I. INT0 AN10, Buffer Type. = ST Analog. INT0 AN10, Description. = 0. Analog input 10.. RB1/INT1/AN8, Pin Number.PDIP, SOIC = 22. RB1/INT1/AN8, Pin.Type = . RB1/INT1/AN8, Buffer Type. = . RB1/INT1/AN8, Description. =",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. RB1, Pin Number.PDIP, SOIC = . RB1, Pin.Type = I/O. RB1, Buffer Type. = TTL. RB1, Description. = Digital I/O.. INT1, Pin Number.PDIP, SOIC = . INT1, Pin.Type = I. INT1, Buffer Type. = ST. INT1, Description. = External interrupt 1.. AN8, Pin Number.PDIP, SOIC = 23. AN8, Pin.Type = I I/O. AN8, Buffer Type. = Analog. AN8, Description. = Analog input 8.. RB2/INT2/CANTX RB2 INT2 CANTX, Pin Number.PDIP, SOIC = 24. RB2/INT2/CANTX RB2 INT2 CANTX, Pin.Type = I O. RB2/INT2/CANTX RB2 INT2 CANTX, Buffer Type. = TTL ST. RB2/INT2/CANTX RB2 INT2 CANTX, Description. = Digital",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. External interrupt 2.. RB3, Pin Number.PDIP, SOIC = . RB3, Pin.Type = I/O. RB3, Buffer Type. = TTL. RB3, Description. = CAN bus TX.. RB3/CANRX CANRX, Pin Number.PDIP, SOIC = . RB3/CANRX CANRX, Pin.Type = I. RB3/CANRX CANRX, Buffer Type. = TTL TTL. RB3/CANRX CANRX, Description. = Digital I/O. CAN bus RX.. RB4/KBI0/AN9 RB4, Pin Number.PDIP, SOIC = 25. RB4/KBI0/AN9 RB4, Pin.Type = I/O. RB4/KBI0/AN9 RB4, Buffer Type. = TTL. RB4/KBI0/AN9 RB4, Description. = Digital. KBI0, Pin Number.PDIP, SOIC = . KBI0, Pin.Type =",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI. KBI0, Buffer Type. = . KBI0, Description. = I/O.. AN9, Pin Number.PDIP, SOIC = . AN9, Pin.Type = I. AN9, Buffer Type. = TTL Analog. AN9, Description. = Interrupt-on-change pin. Analog input 9.. RB5/KBI1/PGM, Pin Number.PDIP, SOIC = 26. RB5/KBI1/PGM, Pin.Type = . RB5/KBI1/PGM, Buffer Type. = TTL. RB5/KBI1/PGM, Description. = Digital I/O.. RB5, Pin Number.PDIP, SOIC = . RB5, Pin.Type = I/O. RB5, Buffer Type. = TTL. RB5, Description. = . KBI1, Pin Number.PDIP, SOIC = . KBI1, Pin.Type = I I/O. KBI1, Buffer Type. = ST. KBI1, Description. = Low-Voltage",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nICSP\u2122 Programming enable. PGM, Pin Number.PDIP, SOIC = 27. PGM, Pin.Type = . PGM, Buffer Type. = . PGM, Description. = Interrupt-on-change pin.. RB6/KBI2/PGC RB6, Pin Number.PDIP, SOIC = . RB6/KBI2/PGC RB6, Pin.Type = I/O. RB6/KBI2/PGC RB6, Buffer Type. = TTL. RB6/KBI2/PGC RB6, Description. = Digital I/O.. KBI2, Pin Number.PDIP, SOIC = . KBI2, Pin.Type = I. KBI2, Buffer Type. = TTL. KBI2, Description. = Interrupt-on-change pin.. , Pin Number.PDIP, SOIC = . , Pin.Type = I/O. , Buffer Type. = ST. , Description. = In-Circuit Debugger and ICSP programming clock. PGC",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB7/KBI3/PGD, Pin Number.PDIP, SOIC = . PGC RB7/KBI3/PGD, Pin.Type = . PGC RB7/KBI3/PGD, Buffer Type. = . PGC RB7/KBI3/PGD, Description. = . , Pin Number.PDIP, SOIC = 28. , Pin.Type = I/O. , Buffer Type. = TTL. , Description. = Digital I/O.. RB7, Pin Number.PDIP, SOIC = . RB7, Pin.Type = I. RB7, Buffer Type. = . RB7, Description. = . KBI3, Pin Number.PDIP, SOIC = . KBI3, Pin.Type = I/O. KBI3, Buffer Type. = TTL ST. KBI3, Description. = Interrupt-on-change pin.. , Pin Number.PDIP, SOIC = . , Pin.Type = . , Buffer Type. = . , Description. = Debugger and ICSP programming data",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\npin.. PGD, Pin Number.PDIP, SOIC = . PGD, Pin.Type = . PGD, Buffer Type. = . PGD, Description. = In-Circuit\nLegend:\nTTL = TTL compatible input CMOS= CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels I= Input\nO = Output P\n= Power",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\n, Pin Number.PDIP, SOIC = 11. , Pin Type. = I/O. , Buffer Type. = ST -. , Description. = PORTC is a bidirectional I/O port. Digital I/O.. RC0/T1OSO/T13CKI RC0 T1OSO T13CKI RC1/T1OSI RC1 T1OSI RC2/CCP1 RC2 CCP1 RC3/SCK/SCL RC3 SCK, Pin Number.PDIP, SOIC = 12 13 14. RC0/T1OSO/T13CKI RC0 T1OSO T13CKI RC1/T1OSI RC1 T1OSI RC2/CCP1 RC2 CCP1 RC3/SCK/SCL RC3 SCK, Pin Type. = O I I/O I I/O I/O I/O I/O. RC0/T1OSO/T13CKI RC0 T1OSO T13CKI RC1/T1OSI RC1 T1OSI RC2/CCP1 RC2 CCP1",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC3/SCK/SCL RC3 SCK, Buffer Type. = ST ST CMOS ST ST ST ST ST ST. RC0/T1OSO/T13CKI RC0 T1OSO T13CKI RC1/T1OSI RC1 T1OSI RC2/CCP1 RC2 CCP1 RC3/SCK/SCL RC3 SCK, Description. = Timer1 oscillator output. Timer1/Timer3 external clock input. Digital I/O. Timer1 oscillator input. Digital I/O. Capture1 input/Compare1 output/PWM1 output. Digital I/O. Synchronous serial clock input/output for SPI mode. Synchronous serial clock input/output for I 2 C\u2122mode. Digital I/O. SPI data in. I 2 C data I/O.. SCL RC6/TX/CK RC6 TX, Pin Number.PDIP, SOIC = . SCL RC6/TX/CK RC6 TX, Pin Type. = I/O. SCL",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC6/TX/CK RC6 TX, Buffer Type. = ST - ST. SCL RC6/TX/CK RC6 TX, Description. = Digital I/O. EUSART asynchronous transmit. EUSART synchronous clock (see related RX/DT).. RC4/SDI/SDA RC4 SDI SDA RC5 SDO, Pin Number.PDIP, SOIC = 15. RC4/SDI/SDA RC4 SDI SDA RC5 SDO, Pin Type. = I/O I. RC4/SDI/SDA RC4 SDI SDA RC5 SDO, Buffer Type. = ST ST ST. RC4/SDI/SDA RC4 SDI SDA RC5 SDO, Description. = Digital I/O. SPI data out.. CK RC7/RX/DT, Pin Number.PDIP, SOIC = . CK RC7/RX/DT, Pin Type. = I/O. CK RC7/RX/DT, Buffer Type. = .",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nCK RC7/RX/DT, Description. = . RC5/SDO, Pin Number.PDIP, SOIC = 16. RC5/SDO, Pin Type. = I/O. RC5/SDO, Buffer Type. = . RC5/SDO, Description. = . , Pin Number.PDIP, SOIC = . , Pin Type. = O. , Buffer Type. = -. , Description. = . , Pin Number.PDIP, SOIC = . , Pin Type. = I/O. , Buffer Type. = . , Description. = . , Pin Number.PDIP, SOIC = 17 18. , Pin Type. = O I/O I/O I I/O. , Buffer Type. = ST ST -. , Description. = . RC7 RX DT, Pin Number.PDIP, SOIC = . RC7 RX DT, Pin Type. = -. RC7 RX DT, Buffer Type. = ST. RC7 RX DT, Description. = See MCLR/VPP/RE3 pin.. , Pin",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PDIP, SOIC = -. , Pin Type. = . , Buffer Type. = . , Description. = Digital I/O. EUSART asynchronous receive. EUSART synchronous data (see related. , Pin Number.PDIP, SOIC = . , Pin Type. = . , Buffer Type. = . , Description. = TX/CK).. RE3, Pin Number.PDIP, SOIC = . RE3, Pin Type. = . RE3, Buffer Type. = . RE3, Description. = . , Pin Number.PDIP, SOIC = . , Pin Type. = P. , Buffer Type. = . , Description. = . , Pin Number.PDIP, SOIC = 8, 19. , Pin Type. = . , Buffer Type. = . , Description. = . VSS, Pin Number.PDIP, SOIC = . VSS, Pin Type. = . VSS, Buffer Type. = -. VSS, Description. = Ground reference for logic and I/O pins.. VDD, Pin",
    "TABLE 1-2: PIC18F2585/2680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PDIP, SOIC = 20. VDD, Pin Type. = P. VDD, Buffer Type. = -. VDD, Description. = . , Pin Number.PDIP, SOIC = . , Pin Type. = . , Buffer Type. = . , Description. = Positive supply for logic and I/O pins.\nLegend:\nTTL = TTL compatible input CMOS= CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels I= Input\nO = Output P\n= Power",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS\nMCLR/VPP/RE3 MCLR, Pin Number.PDIP = 1. MCLR/VPP/RE3 MCLR, Pin Number.QFN = 18. MCLR/VPP/RE3 MCLR, Pin Number.TQFP = 18. MCLR/VPP/RE3 MCLR, Pin.Type = . MCLR/VPP/RE3 MCLR, Buffer.Type = . MCLR/VPP/RE3 MCLR, Description. = Master Clear (input) or programming voltage (input).. , Pin Number.PDIP = . , Pin Number.QFN = . , Pin Number.TQFP = . , Pin.Type = I. , Buffer.Type = ST. , Description. = Master Clear (Reset) input. This pin is an active-low Reset to the device.. VPP, Pin Number.PDIP = . VPP, Pin Number.QFN = . VPP, Pin Number.TQFP = . VPP, Pin.Type = P I. VPP, Buffer.Type = ST. VPP, Description. = Programming",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS\nvoltage input. Digital input.. RE3 OSC1/CLKI/RA7, Pin Number.PDIP = 13. RE3 OSC1/CLKI/RA7, Pin Number.QFN = 32. RE3 OSC1/CLKI/RA7, Pin Number.TQFP = 30. RE3 OSC1/CLKI/RA7, Pin.Type = I. RE3 OSC1/CLKI/RA7, Buffer.Type = ST. RE3 OSC1/CLKI/RA7, Description. = Oscillator crystal or external clock input. Oscillator crystal input or external clock source input.. CLKI, Pin Number.PDIP = . CLKI, Pin Number.QFN = . CLKI, Pin Number.TQFP = . CLKI, Pin.Type = I. CLKI, Buffer.Type = CMOS. CLKI, Description. = CMOSotherwise. External clock source input. Always associated with pin function OSC1. (See related OSC1/CLKI, OSC2/CLKO pins.).",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS\nRA7, Pin Number.PDIP = . RA7, Pin Number.QFN = . RA7, Pin Number.TQFP = . RA7, Pin.Type = I/O. RA7, Buffer.Type = TTL. RA7, Description. = General purpose I/O pin.. OSC2/CLKO/RA6 OSC2, Pin Number.PDIP = 14. OSC2/CLKO/RA6 OSC2, Pin Number.QFN = 33. OSC2/CLKO/RA6 OSC2, Pin Number.TQFP = 31. OSC2/CLKO/RA6 OSC2, Pin.Type = O. OSC2/CLKO/RA6 OSC2, Buffer.Type = . OSC2/CLKO/RA6 OSC2, Description. = Oscillator crystal or clock output. Oscillator crystal output. Connects to crystal. CLKO, Pin Number.PDIP = . CLKO, Pin Number.QFN = . CLKO, Pin Number.TQFP = . CLKO,",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS\nPin.Type = O. CLKO, Buffer.Type = -. CLKO, Description. = resonator in Crystal Oscillator mode. In RCmode, OSC2 pin outputs CLKO which has 1/4 the frequency of OSC1 and denotes the instruction. RA6, Pin Number.PDIP = . RA6, Pin Number.QFN = . RA6, Pin Number.TQFP = . RA6, Pin.Type = I/O. RA6, Buffer.Type = TTL. RA6, Description. = General purpose I/O pin.\nLegend:\nTTL = TTL compatible input CMOS= CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels I= Input\nO = Output P\n= Power",
    "TABLE 1-3:\nRA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1, Pin Number.PDIP = 2. RA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1, Pin Number.QFN = 19. RA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1, Pin Number.TQFP = 19. RA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1, Pin.Type = . RA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1, Buffer.Type = . RA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1, Description. = PORTA is a bidirectional I/O port.. , Pin Number.PDIP = 3. , Pin Number.QFN = 20. , Pin Number.TQFP = 20. , Pin.Type = . , Buffer.Type = . , Description. = . RA1, Pin Number.PDIP = . RA1, Pin Number.QFN = .",
    "TABLE 1-3:\nRA1, Pin Number.TQFP = . RA1, Pin.Type = I/O. RA1, Buffer.Type = TTL. RA1, Description. = Digital I/O. Analog input 0.. , Pin Number.PDIP = . , Pin Number.QFN = . , Pin Number.TQFP = . , Pin.Type = I. , Buffer.Type = Analog. , Description. = . , Pin Number.PDIP = . , Pin Number.QFN = . , Pin Number.TQFP = . , Pin.Type = O. , Buffer.Type = Analog. , Description. = Analog comparator reference output.. AN1, Pin Number.PDIP = . AN1, Pin Number.QFN = . AN1, Pin Number.TQFP = . AN1, Pin.Type = I/O. AN1, Buffer.Type = TTL. AN1, Description. = Digital I/O.. RA2/AN2/V REF -, Pin Number.PDIP = . RA2/AN2/V REF -, Pin Number.QFN = . RA2/AN2/V REF -,",
    "TABLE 1-3:\nPin Number.TQFP = 21. RA2/AN2/V REF -, Pin.Type = I. RA2/AN2/V REF -, Buffer.Type = Analog. RA2/AN2/V REF -, Description. = Analog input 1.. RA2, Pin Number.PDIP = 4. RA2, Pin Number.QFN = 21. RA2, Pin Number.TQFP = . RA2, Pin.Type = I/O. RA2, Buffer.Type = TTL Analog. RA2, Description. = Digital I/O. Analog input 2.. AN2, Pin Number.PDIP = . AN2, Pin Number.QFN = . AN2, Pin Number.TQFP = . AN2, Pin.Type = I I. AN2, Buffer.Type = Analog. AN2, Description. = A/D reference voltage. VREF-, Pin Number.PDIP = . VREF-, Pin Number.QFN = . VREF-, Pin Number.TQFP = . VREF-, Pin.Type = . VREF-, Buffer.Type = . VREF-, Description. =",
    "TABLE 1-3:\n(low) input.. RA3/AN3/VREF+, Pin Number.PDIP = 5. RA3/AN3/VREF+, Pin Number.QFN = 22. RA3/AN3/VREF+, Pin Number.TQFP = 22. RA3/AN3/VREF+, Pin.Type = . RA3/AN3/VREF+, Buffer.Type = . RA3/AN3/VREF+, Description. = . RA3, Pin Number.PDIP = . RA3, Pin Number.QFN = . RA3, Pin Number.TQFP = . RA3, Pin.Type = I/O. RA3, Buffer.Type = TTL. RA3, Description. = Digital I/O.. AN3, Pin Number.PDIP = . AN3, Pin Number.QFN = . AN3, Pin Number.TQFP = . AN3, Pin.Type = I. AN3, Buffer.Type = Analog. AN3, Description. = Analog input 3.. , Pin Number.PDIP = . , Pin Number.QFN = . , Pin",
    "TABLE 1-3:\nNumber.TQFP = . , Pin.Type = I. , Buffer.Type = Analog. , Description. = A/D reference voltage (high). VREF+, Pin Number.PDIP = . VREF+, Pin Number.QFN = . VREF+, Pin Number.TQFP = . VREF+, Pin.Type = . VREF+, Buffer.Type = . VREF+, Description. = input.. RA4/T0CKI, Pin Number.PDIP = . RA4/T0CKI, Pin Number.QFN = . RA4/T0CKI, Pin Number.TQFP = . RA4/T0CKI, Pin.Type = . RA4/T0CKI, Buffer.Type = . RA4/T0CKI, Description. = . RA4, Pin Number.PDIP = 6. RA4, Pin Number.QFN = 23. RA4, Pin Number.TQFP = 23. RA4, Pin.Type = I/O. RA4, Buffer.Type = TTL. RA4, Description. = Digital I/O. Timer0 external clock. T0CKI, Pin",
    "TABLE 1-3:\nNumber.PDIP = . T0CKI, Pin Number.QFN = . T0CKI, Pin Number.TQFP = . T0CKI, Pin.Type = I. T0CKI, Buffer.Type = ST. T0CKI, Description. = input.. RA5/AN4/SS/HLVDIN, Pin Number.PDIP = 7. RA5/AN4/SS/HLVDIN, Pin Number.QFN = 24. RA5/AN4/SS/HLVDIN, Pin Number.TQFP = 24. RA5/AN4/SS/HLVDIN, Pin.Type = . RA5/AN4/SS/HLVDIN, Buffer.Type = . RA5/AN4/SS/HLVDIN, Description. = . RA5, Pin Number.PDIP = . RA5, Pin Number.QFN = . RA5, Pin Number.TQFP = . RA5, Pin.Type = I/O. RA5, Buffer.Type = TTL. RA5, Description. = Digital I/O.. AN4, Pin Number.PDIP = .",
    "TABLE 1-3:\nAN4, Pin Number.QFN = . AN4, Pin Number.TQFP = . AN4, Pin.Type = I. AN4, Buffer.Type = Analog. AN4, Description. = Analog input 4.. SS, Pin Number.PDIP = . SS, Pin Number.QFN = . SS, Pin Number.TQFP = . SS, Pin.Type = I. SS, Buffer.Type = TTL. SS, Description. = SPI slave select input.. HLVDIN, Pin Number.PDIP = . HLVDIN, Pin Number.QFN = . HLVDIN, Pin Number.TQFP = . HLVDIN, Pin.Type = I. HLVDIN, Buffer.Type = Analog. HLVDIN, Description. = High/Low-Voltage Detect input.. RA6, Pin Number.PDIP = . RA6, Pin Number.QFN = . RA6, Pin Number.TQFP = . RA6, Pin.Type = . RA6, Buffer.Type = . RA6, Description. = See the OSC2/CLKO/RA6 pin..",
    "TABLE 1-3:\nRA7, Pin Number.PDIP = . RA7, Pin Number.QFN = . RA7, Pin Number.TQFP = . RA7, Pin.Type = . RA7, Buffer.Type = . RA7, Description. = See the OSC1/CLKI/RA7 pin.",
    "PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nLegend:\nTTL = TTL compatible input CMOS= CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels I= Input\nO = Output P\n= Power",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB0/INT0/FLT0/AN10 RB0 INT0 FLT0 AN10 RB1/INT1/AN8, Pin Number.PDIP = 33. RB0/INT0/FLT0/AN10 RB0 INT0 FLT0 AN10 RB1/INT1/AN8, Pin Number.QFN = 9. RB0/INT0/FLT0/AN10 RB0 INT0 FLT0 AN10 RB1/INT1/AN8, Pin Number.TQFP = 8. RB0/INT0/FLT0/AN10 RB0 INT0 FLT0 AN10 RB1/INT1/AN8, Pin.Type = I/O I I I. RB0/INT0/FLT0/AN10 RB0 INT0 FLT0 AN10 RB1/INT1/AN8, Buffer.Type = TTL ST ST Analog. RB0/INT0/FLT0/AN10 RB0 INT0 FLT0 AN10 RB1/INT1/AN8, Description = PORTB is a",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nbidirectional I/O port. PORTB can be software programmed for internal weak pull-ups on all inputs. Digital I/O. External interrupt 0. Enhanced PWM Fault input (ECCP1 module). Analog input 10.. RB1 INT1 AN8, Pin Number.PDIP = 34. RB1 INT1 AN8, Pin Number.QFN = 10. RB1 INT1 AN8, Pin Number.TQFP = 9. RB1 INT1 AN8, Pin.Type = I/O I I. RB1 INT1 AN8, Buffer.Type = TTL ST Analog. RB1 INT1 AN8, Description = Digital I/O. External interrupt 1. Analog input 8.. RB2/INT2/CANTX RB2 INT2 CANTX, Pin Number.PDIP = 35. RB2/INT2/CANTX RB2 INT2 CANTX, Pin Number.QFN = 11. RB2/INT2/CANTX RB2 INT2 CANTX, Pin Number.TQFP = 10.",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB2/INT2/CANTX RB2 INT2 CANTX, Pin.Type = I/O I O. RB2/INT2/CANTX RB2 INT2 CANTX, Buffer.Type = TTL ST TTL. RB2/INT2/CANTX RB2 INT2 CANTX, Description = Digital I/O. External interrupt 2. CAN bus TX.. RB3/CANRX RB3 CANRX, Pin Number.PDIP = 36. RB3/CANRX RB3 CANRX, Pin Number.QFN = 12. RB3/CANRX RB3 CANRX, Pin Number.TQFP = 11. RB3/CANRX RB3 CANRX, Pin.Type = I/O I. RB3/CANRX RB3 CANRX, Buffer.Type = TTL TTL. RB3/CANRX RB3 CANRX, Description = Digital I/O. CAN bus RX.. RB4/KBI0/AN9 RB4 KBI0 AN9, Pin",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PDIP = 37. RB4/KBI0/AN9 RB4 KBI0 AN9, Pin Number.QFN = 14. RB4/KBI0/AN9 RB4 KBI0 AN9, Pin Number.TQFP = 14. RB4/KBI0/AN9 RB4 KBI0 AN9, Pin.Type = I/O I I. RB4/KBI0/AN9 RB4 KBI0 AN9, Buffer.Type = TTL TTL Analog. RB4/KBI0/AN9 RB4 KBI0 AN9, Description = Digital I/O. Interrupt-on-change pin. Analog input 9.. RB5/KBI1/PGM RB5 KBI1 PGM RB6/KBI2/PGC RB6 KBI2 PGC, Pin Number.PDIP = 38. RB5/KBI1/PGM RB5 KBI1 PGM RB6/KBI2/PGC RB6 KBI2 PGC, Pin Number.QFN = 15.",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB5/KBI1/PGM RB5 KBI1 PGM RB6/KBI2/PGC RB6 KBI2 PGC, Pin Number.TQFP = 15. RB5/KBI1/PGM RB5 KBI1 PGM RB6/KBI2/PGC RB6 KBI2 PGC, Pin.Type = I/O I I/O. RB5/KBI1/PGM RB5 KBI1 PGM RB6/KBI2/PGC RB6 KBI2 PGC, Buffer.Type = TTL TTL ST. RB5/KBI1/PGM RB5 KBI1 PGM RB6/KBI2/PGC RB6 KBI2 PGC, Description = Digital I/O. Interrupt-on-change pin. Low-Voltage ICSP\u2122 Programming enable pin.. RB7/KBI3/PGD RB7, Pin Number.PDIP = 39. RB7/KBI3/PGD RB7, Pin Number.QFN = 16.",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB7/KBI3/PGD RB7, Pin Number.TQFP = 16. RB7/KBI3/PGD RB7, Pin.Type = I/O I I/O. RB7/KBI3/PGD RB7, Buffer.Type = TTL TTL ST. RB7/KBI3/PGD RB7, Description = Digital I/O. Interrupt-on-change pin. In-Circuit Debugger and ICSP programming clock pin.. KBI3 PGD, Pin Number.PDIP = 40. KBI3 PGD, Pin Number.QFN = 17. KBI3 PGD, Pin Number.TQFP = 17. KBI3 PGD, Pin.Type = I/O I I/O. KBI3 PGD, Buffer.Type = TTL TTL ST. KBI3 PGD, Description = Digital I/O. Interrupt-on-change pin. In-Circuit Debugger and ICSP programming data pin.\nLegend:\nTTL = TTL compatible input CMOS= CMOS compatible input or output",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nST = Schmitt Trigger input with CMOS levels I= Input\n- O = Output P\n= Power",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC0/T1OSO/T13CKI, Pin Number.PDIP = 15. RC0/T1OSO/T13CKI, Pin Number.QFN = 34. RC0/T1OSO/T13CKI, Pin Number.TQFP = 32. RC0/T1OSO/T13CKI, Pin.Type = . RC0/T1OSO/T13CKI, Buffer.Type = . RC0/T1OSO/T13CKI, Description = PORTC is a bidirectional I/O port.. RC0, Pin Number.PDIP = . RC0, Pin Number.QFN = . RC0, Pin Number.TQFP = . RC0, Pin.Type = I/O. RC0, Buffer.Type = ST. RC0, Description = Digital I/O.. T1OSO, Pin Number.PDIP = . T1OSO, Pin Number.QFN = . T1OSO, Pin Number.TQFP = . T1OSO, Pin.Type = O. T1OSO, Buffer.Type = -.",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nT1OSO, Description = Timer1 oscillator output.. T13CKI, Pin Number.PDIP = . T13CKI, Pin Number.QFN = . T13CKI, Pin Number.TQFP = . T13CKI, Pin.Type = I. T13CKI, Buffer.Type = ST. T13CKI, Description = Timer1/Timer3 external clock input.. RC1/T1OSI, Pin Number.PDIP = 16. RC1/T1OSI, Pin Number.QFN = 35. RC1/T1OSI, Pin Number.TQFP = 35. RC1/T1OSI, Pin.Type = . RC1/T1OSI, Buffer.Type = . RC1/T1OSI, Description = . RC1, Pin Number.PDIP = . RC1, Pin Number.QFN = . RC1, Pin Number.TQFP = . RC1, Pin.Type = I/O. RC1, Buffer.Type = ST. RC1, Description = Digital I/O.. T1OSI, Pin",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PDIP = . T1OSI, Pin Number.QFN = . T1OSI, Pin Number.TQFP = . T1OSI, Pin.Type = I. T1OSI, Buffer.Type = CMOS. T1OSI, Description = Timer1 oscillator input.. RC2/CCP1, Pin Number.PDIP = 17. RC2/CCP1, Pin Number.QFN = 36. RC2/CCP1, Pin Number.TQFP = 36. RC2/CCP1, Pin.Type = . RC2/CCP1, Buffer.Type = . RC2/CCP1, Description = . RC2, Pin Number.PDIP = . RC2, Pin Number.QFN = . RC2, Pin Number.TQFP = . RC2, Pin.Type = I/O. RC2, Buffer.Type = ST. RC2, Description = Digital I/O.. CCP1, Pin Number.PDIP = . CCP1, Pin Number.QFN = . CCP1,",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin Number.TQFP = . CCP1, Pin.Type = I/O. CCP1, Buffer.Type = ST. CCP1, Description = Capture1 input/Compare1 output/PWM1 output.. RC3/SCK/SCL, Pin Number.PDIP = 18. RC3/SCK/SCL, Pin Number.QFN = 37. RC3/SCK/SCL, Pin Number.TQFP = 37. RC3/SCK/SCL, Pin.Type = . RC3/SCK/SCL, Buffer.Type = . RC3/SCK/SCL, Description = . RC3, Pin Number.PDIP = . RC3, Pin Number.QFN = . RC3, Pin Number.TQFP = . RC3, Pin.Type = I/O. RC3, Buffer.Type = ST. RC3, Description = Digital I/O.. SCK, Pin Number.PDIP = . SCK, Pin Number.QFN = . SCK, Pin Number.TQFP =",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. SCK, Pin.Type = I/O. SCK, Buffer.Type = ST. SCK, Description = Synchronous serial clock input/output for SPI mode.. SCL, Pin Number.PDIP = . SCL, Pin Number.QFN = . SCL, Pin Number.TQFP = . SCL, Pin.Type = I/O. SCL, Buffer.Type = ST. SCL, Description = Synchronous serial clock input/output for I 2 C\u2122mode.. RC4/SDI/SDA, Pin Number.PDIP = 23. RC4/SDI/SDA, Pin Number.QFN = 42. RC4/SDI/SDA, Pin Number.TQFP = 42. RC4/SDI/SDA, Pin.Type = . RC4/SDI/SDA, Buffer.Type = . RC4/SDI/SDA, Description = . RC4, Pin Number.PDIP = . RC4, Pin Number.QFN = . RC4, Pin",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.TQFP = . RC4, Pin.Type = I/O. RC4, Buffer.Type = ST. RC4, Description = Digital I/O.. SDI, Pin Number.PDIP = . SDI, Pin Number.QFN = . SDI, Pin Number.TQFP = . SDI, Pin.Type = I. SDI, Buffer.Type = ST. SDI, Description = SPI data in.. SDA, Pin Number.PDIP = . SDA, Pin Number.QFN = . SDA, Pin Number.TQFP = . SDA, Pin.Type = I/O. SDA, Buffer.Type = ST. SDA, Description = I 2 C data I/O.. RC5/SDO, Pin Number.PDIP = 24. RC5/SDO, Pin Number.QFN = 43. RC5/SDO, Pin Number.TQFP = 43. RC5/SDO, Pin.Type = . RC5/SDO, Buffer.Type = . RC5/SDO, Description",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= . RC5, Pin Number.PDIP = . RC5, Pin Number.QFN = . RC5, Pin Number.TQFP = . RC5, Pin.Type = I/O. RC5, Buffer.Type = ST. RC5, Description = Digital I/O.. SDO, Pin Number.PDIP = . SDO, Pin Number.QFN = . SDO, Pin Number.TQFP = . SDO, Pin.Type = O. SDO, Buffer.Type = -. SDO, Description = SPI data out.. RC6/TX/CK, Pin Number.PDIP = 25. RC6/TX/CK, Pin Number.QFN = 44. RC6/TX/CK, Pin Number.TQFP = 44. RC6/TX/CK, Pin.Type = . RC6/TX/CK, Buffer.Type = . RC6/TX/CK, Description = . RC6, Pin Number.PDIP = . RC6, Pin Number.QFN = . RC6, Pin Number.TQFP =",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. RC6, Pin.Type = I/O. RC6, Buffer.Type = ST. RC6, Description = Digital I/O.. TX, Pin Number.PDIP = . TX, Pin Number.QFN = . TX, Pin Number.TQFP = . TX, Pin.Type = O. TX, Buffer.Type = -. TX, Description = EUSART asynchronous transmit.. CK, Pin Number.PDIP = . CK, Pin Number.QFN = . CK, Pin Number.TQFP = . CK, Pin.Type = I/O. CK, Buffer.Type = ST. CK, Description = EUSART synchronous clock (see related RX/DT).. RC7/RX/DT, Pin Number.PDIP = 26. RC7/RX/DT, Pin Number.QFN = 1. RC7/RX/DT, Pin Number.TQFP = 1. RC7/RX/DT, Pin.Type = . RC7/RX/DT, Buffer.Type = .",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC7/RX/DT, Description = . RC7, Pin Number.PDIP = . RC7, Pin Number.QFN = . RC7, Pin Number.TQFP = . RC7, Pin.Type = I/O. RC7, Buffer.Type = ST. RC7, Description = Digital I/O.. RX, Pin Number.PDIP = . RX, Pin Number.QFN = . RX, Pin Number.TQFP = . RX, Pin.Type = I. RX, Buffer.Type = ST. RX, Description = EUSART asynchronous receive.. DT, Pin Number.PDIP = . DT, Pin Number.QFN = . DT, Pin Number.TQFP = . DT, Pin.Type = I/O. DT, Buffer.Type = ST. DT, Description = EUSART synchronous data (see related TX/CK).\nLegend:\nTTL = TTL compatible input CMOS= CMOS compatible input or output",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nST = Schmitt Trigger input with CMOS levels I= Input\nO = Output P\n= Power",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD0/PSP0/C1IN+ RD0 PSP0 C1IN+, Pin Number.PDIP = 19. RD0/PSP0/C1IN+ RD0 PSP0 C1IN+, Pin Number.QFN = 38. RD0/PSP0/C1IN+ RD0 PSP0 C1IN+, Pin Number.TQFP = 38. RD0/PSP0/C1IN+ RD0 PSP0 C1IN+, Pin.Type = I/O I/O I. RD0/PSP0/C1IN+ RD0 PSP0 C1IN+, Buffer.Type = ST TTL Analog. RD0/PSP0/C1IN+ RD0 PSP0 C1IN+, Description = These pins have TTL input buffers when PSP module is enabled. Digital I/O. Parallel Slave Port data. Comparator 1 input (+).. RD1/PSP1/C1IN- RD1 PSP1, Pin Number.PDIP = 20. RD1/PSP1/C1IN- RD1",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPSP1, Pin Number.QFN = 39. RD1/PSP1/C1IN- RD1 PSP1, Pin Number.TQFP = 39. RD1/PSP1/C1IN- RD1 PSP1, Pin.Type = I/O I/O I. RD1/PSP1/C1IN- RD1 PSP1, Buffer.Type = ST TTL Analog. RD1/PSP1/C1IN- RD1 PSP1, Description = Digital I/O. Parallel Slave Port data. Comparator 1 input (-). RD2/PSP2/C2IN+ RD2 PSP2, Pin Number.PDIP = 21. RD2/PSP2/C2IN+ RD2 PSP2, Pin Number.QFN = 40. RD2/PSP2/C2IN+ RD2 PSP2, Pin Number.TQFP = 40. RD2/PSP2/C2IN+ RD2 PSP2, Pin.Type = I/O I/O I.",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD2/PSP2/C2IN+ RD2 PSP2, Buffer.Type = ST TTL Analog. RD2/PSP2/C2IN+ RD2 PSP2, Description = Digital I/O. Parallel Slave Port data. Comparator 2 input (+).. RD3/PSP3/C2IN- RD3 PSP3, Pin Number.PDIP = 22. RD3/PSP3/C2IN- RD3 PSP3, Pin Number.QFN = 41. RD3/PSP3/C2IN- RD3 PSP3, Pin Number.TQFP = 41. RD3/PSP3/C2IN- RD3 PSP3, Pin.Type = I/O I/O I. RD3/PSP3/C2IN- RD3 PSP3, Buffer.Type = ST TTL Analog. RD3/PSP3/C2IN- RD3 PSP3, Description = Digital I/O. Parallel Slave Port data.. C2IN- RD4/PSP4/ECCP1/",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nP1A RD4, Pin Number.PDIP = 27. C2IN- RD4/PSP4/ECCP1/ P1A RD4, Pin Number.QFN = 2. C2IN- RD4/PSP4/ECCP1/ P1A RD4, Pin Number.TQFP = 2. C2IN- RD4/PSP4/ECCP1/ P1A RD4, Pin.Type = I/O. C2IN- RD4/PSP4/ECCP1/ P1A RD4, Buffer.Type = . C2IN- RD4/PSP4/ECCP1/ P1A RD4, Description = Comparator 2 input (-).. PSP4 ECCP1 P1A, Pin Number.PDIP = . PSP4 ECCP1 P1A, Pin Number.QFN = . PSP4 ECCP1 P1A, Pin Number.TQFP = . PSP4 ECCP1 P1A, Pin.Type = I/O I/O. PSP4",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nECCP1 P1A, Buffer.Type = ST TTL ST TTL. PSP4 ECCP1 P1A, Description = Digital I/O. Parallel Slave Port data. Capture2 input/Compare2 output/PWM2 output. ECCP1 PWM output A.. RD5/PSP5/P1B RD5, Pin Number.PDIP = 28. RD5/PSP5/P1B RD5, Pin Number.QFN = 3. RD5/PSP5/P1B RD5, Pin Number.TQFP = 3. RD5/PSP5/P1B RD5, Pin.Type = I/O I/O O. RD5/PSP5/P1B RD5, Buffer.Type = ST TTL. RD5/PSP5/P1B RD5, Description = Digital I/O. Parallel Slave Port data.. PSP5 P1B RD6/PSP6/P1C RD6, Pin Number.PDIP = 29. PSP5 P1B",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD6/PSP6/P1C RD6, Pin Number.QFN = 4. PSP5 P1B RD6/PSP6/P1C RD6, Pin Number.TQFP = 4. PSP5 P1B RD6/PSP6/P1C RD6, Pin.Type = I/O. PSP5 P1B RD6/PSP6/P1C RD6, Buffer.Type = TTL ST. PSP5 P1B RD6/PSP6/P1C RD6, Description = ECCP1 PWM output B. Digital I/O.. PSP6, Pin Number.PDIP = . PSP6, Pin Number.QFN = . PSP6, Pin Number.TQFP = . PSP6, Pin.Type = I/O. PSP6, Buffer.Type = TTL. PSP6, Description = Parallel Slave Port data. ECCP1 PWM output C.. P1C RD7/PSP7/P1D, Pin",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PDIP = 30. P1C RD7/PSP7/P1D, Pin Number.QFN = 5. P1C RD7/PSP7/P1D, Pin Number.TQFP = 5. P1C RD7/PSP7/P1D, Pin.Type = O. P1C RD7/PSP7/P1D, Buffer.Type = TTL. P1C RD7/PSP7/P1D, Description = . RD7, Pin Number.PDIP = . RD7, Pin Number.QFN = . RD7, Pin Number.TQFP = . RD7, Pin.Type = I/O. RD7, Buffer.Type = . RD7, Description = Digital I/O.. PSP7, Pin Number.PDIP = . PSP7, Pin Number.QFN = . PSP7, Pin Number.TQFP = . PSP7, Pin.Type = I/O. PSP7, Buffer.Type = ST TTL. PSP7, Description",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= Parallel Slave Port data.\nLegend:\nTTL = TTL compatible input CMOS= CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels I= Input\nO = Output P\n= Power",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRE0/RD/AN5 RE0 RD AN5 RE1 WR AN6 C1OUT RE2 CS, Pin Number.PDIP = 8. RE0/RD/AN5 RE0 RD AN5 RE1 WR AN6 C1OUT RE2 CS, Pin Number.QFN = 25. RE0/RD/AN5 RE0 RD AN5 RE1 WR AN6 C1OUT RE2 CS, Pin Number.TQFP = 25. RE0/RD/AN5 RE0 RD AN5 RE1 WR AN6 C1OUT RE2 CS, Pin.Type = I/O I I I/O. RE0/RD/AN5 RE0 RD AN5 RE1 WR AN6 C1OUT RE2 CS, Buffer.Type = ST TTL Analog ST TTL Analog TTL. RE0/RD/AN5 RE0 RD AN5 RE1 WR AN6 C1OUT RE2 CS, Description. = PORTE is a bidirectional I/O port. Digital I/O. Read control for Parallel Slave Port (see also WR and CS pins). Analog input 5..",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRE1/WR/AN6/C1OUT, Pin Number.PDIP = 9. RE1/WR/AN6/C1OUT, Pin Number.QFN = 26. RE1/WR/AN6/C1OUT, Pin Number.TQFP = 26. RE1/WR/AN6/C1OUT, Pin.Type = I. RE1/WR/AN6/C1OUT, Buffer.Type = . RE1/WR/AN6/C1OUT, Description. = Digital I/O. Write control for Parallel Slave Port (see CS and RD pins).. RE2/CS/AN7/C2OUT AN7, Pin Number.PDIP = 10. RE2/CS/AN7/C2OUT AN7, Pin Number.QFN = 27. RE2/CS/AN7/C2OUT AN7, Pin Number.TQFP = 27. RE2/CS/AN7/C2OUT AN7, Pin.Type = I/O I I O. RE2/CS/AN7/C2OUT AN7, Buffer.Type = ST TTL Analog",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nTTL. RE2/CS/AN7/C2OUT AN7, Description. = Digital I/O. Chip select control for Parallel Slave Port (see related RD and WR). Analog input 7. Comparator 2 output.. RE3, Pin Number.PDIP = -. RE3, Pin Number.QFN = -. RE3, Pin Number.TQFP = -. RE3, Pin.Type = -. RE3, Buffer.Type = -. RE3, Description. = See MCLR/VPP/RE3 pin.. VSS, Pin Number.PDIP = 12, 31. VSS, Pin Number.QFN = 6, 30, 31. VSS, Pin Number.TQFP = 6, 29. VSS, Pin.Type = P. VSS, Buffer.Type = -. VSS, Description. = Ground reference for logic and I/O pins.. VDD, Pin Number.PDIP = 11, 32. VDD, Pin Number.QFN = 7, 8, 28, 29. VDD, Pin",
    "TABLE 1-3: PIC18F4585/4680 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.TQFP = 7, 28. VDD, Pin.Type = P. VDD, Buffer.Type = -. VDD, Description. = Positive supply for logic and I/O pins.. NC, Pin Number.PDIP = -. NC, Pin Number.QFN = 13. NC, Pin Number.TQFP = 12,13, 33, 34. NC, Pin.Type = -. NC, Buffer.Type = -. NC, Description. = No connect.\nLegend:\nTTL = TTL compatible input CMOS= CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels I= Input\nO = Output P\n= Power",
    "2.1 Oscillator Types\nPIC18F2585/2680/4585/4680 devices can be operated in ten different oscillator modes. The user can program the Configuration bits, FOSC3:FOSC0, in Configuration Register 1H to select one of these ten modes:\n1. LP\nLow-Power Crystal\n2. XT\nCrystal/Resonator\n3. HS\nHigh-Speed Crystal/Resonator\n4. HSPLL\nHigh-Speed Crystal/Resonator\nwith PLL enabled\n5. RC\nExternal Resistor/Capacitor with\nFOSC/4 output on RA6\n6. RCIO\nExternal Resistor/Capacitor with I/O on RA6\n7. INTIO1\nInternal Oscillator with FOSC/4 output on RA6 and I/O on RA7\n8. INTIO2\nInternal Oscillator with I/O on RA6 and RA7\n9. EC\nExternal Clock with FOSC/4 output\n10. ECIO\nExternal Clock with I/O on RA6",
    "2.2 Crystal Oscillator/Ceramic Resonators\nIn XT, LP, HS or HSPLL Oscillator modes, a crystal or ceramic  resonator  is  connected  to  the  OSC1  and OSC2 pins to establish  oscillation.  Figure 2-1  shows the pin connections.\nThe oscillator design requires the use of a parallel cut crystal.\nNote:\nUse  of  a  series  cut  crystal  may  give  a frequency out of the crystal manufacturer's specifications.",
    "FIGURE 2-1:\nCRYSTAL/CERAMIC RESONATOR OPERATION (XT, LP, HS OR HSPLL CONFIGURATION)\nNote 1: See Table 2-1 and Table 2-2 for initial values of\nC1 and C2.\n2: A series resistor (RS) may be required for AT strip cut crystals.\n3: RF varies with the oscillator mode chosen.",
    "Typical Capacitor Values Used:\nXT, Freq = 455 kHz. XT, OSC1 = 56 pF. XT, OSC2 = 56 pF. , Freq = 2.0 MHz. , OSC1 = 47 pF. , OSC2 = 47 pF. , Freq = 4.0 MHz. , OSC1 = 33 pF. , OSC2 = 33 pF. HS, Freq = 8.0 MHz. HS, OSC1 = 27 pF. HS, OSC2 = 27 pF. , Freq = 16.0 MHz. , OSC1 = 22 pF. , OSC2 = 22 pF\nCapacitor values are for design guidance only.\nThese  capacitors  were  tested  with  the  resonators listed below for basic start-up and operation. These values are not optimized .\nDifferent capacitor values may be required to produce acceptable oscillator operation. The user should test the performance of the oscillator over the expected VDD and temperature range for the application.\nSee the notes on page 22 for additional information.",
    "Resonators Used:\n455 kHz, 1 = 4.0 MHz. 2.0 MHz, 1 = 8.0 MHz. 16.0 MHz, 1 = 16.0 MHz\nNote:\nWhen using resonators with frequencies above  3.5  MHz,  the  use  of  HS  mode, rather  than  XT  mode,  is  recommended. HS  mode  may  be  used  at  any  VDD  for which  the  controller  is  rated.  If  HS  is selected, it is possible that the gain of the oscillator will overdrive the resonator. Therefore,  a  series  resistor  should  be placed  between  the  OSC2  pin  and  the resonator.  As  a  good  starting  point,  the recommended value of RS is 330 \uf057 .",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nAn external clock source may also be connected to the OSC1 pin in the HS mode, as shown in Figure 2-2.",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nLP, Crystal Freq.Crystal Freq = 32 kHz. LP, Typical Capacitor Values Tested:.C1 = 33 pF. LP, Typical Capacitor Values Tested:.C2 = 33 pF. LP, Crystal Freq.Crystal Freq = 200 kHz. LP, Typical Capacitor Values Tested:.C1 = 15 pF. LP, Typical Capacitor Values Tested:.C2 = 15 pF. XT, Crystal Freq.Crystal Freq = 1 MHz. XT, Typical Capacitor Values Tested:.C1 = 33 pF. XT, Typical Capacitor Values Tested:.C2 = 33 pF. XT, Crystal Freq.Crystal Freq = 4 MHz. XT, Typical Capacitor Values Tested:.C1 = 27 pF. XT, Typical Capacitor Values Tested:.C2 = 27 pF. HS, Crystal Freq.Crystal Freq = 4 MHz. HS, Typical Capacitor Values Tested:.C1 = 27 pF. HS, Typical Capacitor Values Tested:.C2 = 27 pF.",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nHS, Crystal Freq.Crystal Freq = 8 MHz. HS, Typical Capacitor Values Tested:.C1 = 22 pF. HS, Typical Capacitor Values Tested:.C2 = 22 pF. HS, Crystal Freq.Crystal Freq = 20 MHz. HS, Typical Capacitor Values Tested:.C1 = 15 pF. HS, Typical Capacitor Values Tested:.C2 = 15 pF\nCapacitor values are for design guidance only.\nThese capacitors were tested with the crystals listed below for basic start-up and operation. These values are not optimized.\nDifferent capacitor values may be required to produce acceptable oscillator operation. The user should test the performance of the oscillator over the expected VDD and temperature range for the application.\nSee  the  notes  following  this  table  for  additional information.\n32 kHz, Crystals Used: = 4 MHz. 200 kHz, Crystals Used: = 8 MHz. 1 MHz, Crystals Used: = 20 MHz",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nNote 1: Higher capacitance increases the stability of the oscillator but also increases the start-up time.\n2: When operating below 3V VDD, or when using certain ceramic resonators at any voltage, it may be necessary to use the HS mode or switch to a crystal oscillator.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer  for appropriate values of external components.\n4: Rs may be required to avoid overdriving crystals with low drive level specification.\n5: Always verify oscillator performance over the  VDD  and  temperature  range  that  is expected for the application.",
    "FIGURE 2-2:\nEXTERNAL CLOCK INPUT OPERATION (HS OSCILLATOR CONFIGURATION)",
    "2.3 External Clock Input\nThe EC and ECIO Oscillator modes require an external clock source to be connected to the OSC1 pin. There is no  oscillator  start-up  time  required  after  a  Power-on Reset or after an exit from Sleep mode.\nIn  the  EC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic. Figure 2-3 shows the pin connections for the EC Oscillator mode.",
    "EXTERNAL CLOCK INPUT OPERATION (EC CONFIGURATION)\nThe ECIO Oscillator mode functions like the EC mode, except  that  the  OSC2  pin  becomes  an  additional general purpose I/O pin. The I/O pin becomes bit 6 of PORTA (RA6). Figure 2-4 shows the pin connections for the ECIO Oscillator mode.",
    "2.4 RC Oscillator\nFor timing insensitive applications, the 'RC'  and 'RCIO'  device  options  offer  additional  cost  savings. The actual oscillator frequency is a function of several factors:\n\u00b7 supply voltage\n\u00b7 values of the external resistor (REXT) and capacitor (CEXT)\n\u00b7 operating temperature\nGiven the same device, operating voltage and temperature and component values, there will also be unit-to-unit frequency variations. These are due to factors such as:\n\u00b7 normal manufacturing variation\n\u00b7 difference in lead frame capacitance between package types (especially for low CEXT values)\n\u00b7 variations within the tolerance of limits of REXT and CEXT\nIn  the  RC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic.  Figure 2-5  shows  how  the  R/C  combination  is connected.",
    "FIGURE 2-5: RC OSCILLATOR MODE\nThe RCIO Oscillator mode (Figure 2-6) functions like the RC mode, except that the OSC2 pin becomes an additional general purpose I/O pin. The I/O pin becomes bit 6 of PORTA (RA6).",
    "2.5 PLL Frequency Multiplier\nA Phase Locked Loop (PLL) circuit is provided as an option  for  users  who  wish  to  use  a  lower  frequency oscillator circuit or to clock the device up to its highest rated frequency from a crystal oscillator. This may be useful for customers who are concerned with EMI due to high-frequency crystals or users who require higher clock speeds from an internal oscillator.",
    "2.5.1 HSPLL OSCILLATOR MODE\nThe HSPLL mode makes use of the HS mode oscillator for frequencies up to 10 MHz. A PLL then multiplies the oscillator output frequency by 4 to produce an internal clock frequency up to 40 MHz.\nThe PLL is only available to the crystal oscillator when the FOSC3:FOSC0 Configuration bits are programmed for HSPLL mode (= 0110 ).",
    "2.5.2 PLL AND INTOSC\nThe PLL is also available to the internal oscillator block in selected oscillator modes. In this configuration, the PLL  is  enabled  in  software  and  generates  a  clock output of up to 32 MHz. The operation of INTOSC with the PLL is described in Section 2.6.4 'PLL in INTOSC Modes' .",
    "2.6 Internal Oscillator Block\nThe  PIC18F2585/2680/4585/4680  devices  include  an internal  oscillator  block  which  generates  two  different clock signals; either can be used as the microcontroller's clock source. This may eliminate the need for external oscillator circuits on the OSC1 and/or OSC2 pins.\nThe main output (INTOSC) is an 8 MHz clock source, which can be used to directly drive the device clock. It also drives a postscaler, which can provide a range of clock frequencies from 31 kHz to 4 MHz. The INTOSC output is enabled when a clock frequency from 125 kHz to 8 MHz is selected.\nThe  other  clock  source  is  the  internal  RC  oscillator (INTRC),  which  provides  a  nominal  31 kHz  output. INTRC is enabled if it is selected as the device clock source; it is also enabled automatically when any of the following are enabled:\n\u00b7 Power-up Timer\n\u00b7 Fail-Safe Clock Monitor\n\u00b7 Watchdog Timer\n\u00b7 Two-Speed Start-up\nThese  features  are  discussed  in  greater  detail  in Section 24.0 'Special Features of the CPU' .",
    "2.6 Internal Oscillator Block\nThe  clock  source  frequency  (INTOSC  direct,  INTRC direct or INTOSC postscaler) is selected by configuring the IRCF bits of the OSCCON register (Register 2-2).",
    "2.6.1 INTIO MODES\nUsing  the internal oscillator as the clock source eliminates  the  need  for  up  to  two  external  oscillator pins, which can then be used for digital I/O. Two distinct configurations are available:\n\u00b7 In INTIO1 mode, the OSC2 pin outputs FOSC/4, while OSC1 functions as RA7 for digital input and output.\n\u00b7 In INTIO2 mode, OSC1 functions as RA7 and OSC2 functions as RA6, both for digital input and output.",
    "2.6.2 INTOSC OUTPUT FREQUENCY\nThe internal oscillator block is calibrated at the factory to produce an INTOSC output frequency of 8.0 MHz.\nThe  INTRC  oscillator  operates  independently  of  the INTOSC  source.  Any  changes  in  INTOSC  across voltage and temperature are not necessarily reflected by changes in INTRC and vice versa.",
    "2.6.3 OSCTUNE REGISTER\nThe internal oscillator's output has been calibrated at the factory but can be adjusted in the user's application. This is done by writing to the OSCTUNE register (Register 2-1). The tuning sensitivity is constant throughout the tuning range.\nWhen the OSCTUNE register is modified, the INTOSC and INTRC frequencies will begin shifting to the new frequency. The  INTRC  clock  will reach the new frequency within 8 clock cycles (approximately 8 * 32 \uf06d s = 256 \uf06d s).  The  INTOSC  clock  will  stabilize within 1 ms. Code execution continues during this shift. There is no indication that the shift has occurred.\nThe OSCTUNE register also implements the INTSRC and PLLEN bits, which control certain features of the internal oscillator block. The INTSRC bit allows users to  select  which  internal  oscillator  provides  the  clock source when the 31 kHz frequency option is selected. This  is  covered  in  greater  detail  in Section 2.7.1 'Oscillator Control Register' .\nThe PLLEN bit controls the operation of the frequency multiplier, PLL, in internal oscillator modes.",
    "2.6.4 PLL IN INTOSC MODES\nThe 4x frequency multiplier can be used with the internal  oscillator  block  to  produce  faster  device  clock speeds  than  are  normally  possible  with  an  internal oscillator.  When  enabled,  the  PLL  produces  a  clock speed of up to 32 MHz.\nUnlike HSPLL mode, the PLL is controlled through software. The control bit, PLLEN (OSCTUNE<6>), is used to enable or disable its operation.\nThe PLL is available when the device is configured to use  the  internal  oscillator  block  as  its  primary  clock source (FOSC3:FOSC0 = 1001 or 1000 ). Additionally, the PLL will only function when the selected output frequency is either 4 MHz or 8 MHz (OSCCON<6:4> = 111 or 110 ). If both of these conditions are not met, the PLL is disabled.\nThe PLLEN control bit is only functional in those internal oscillator modes where the PLL is available. In all other modes, it is forced to ' 0 ' and is effectively unavailable.",
    "2.6.5 INTOSC FREQUENCY DRIFT\nThe  factory  calibrates  the  internal  oscillator  block output (INTOSC) for 8 MHz. However, this frequency may drift as VDD or temperature changes, which can affect the controller operation in a variety of ways. It is possible to adjust the INTOSC frequency by modifying the value in the OSCTUNE register. This has no effect on the INTRC clock source frequency.\nTuning the INTOSC source requires knowing when to make the adjustment, in which direction it should be made  and  in  some  cases,  how  large  a  change  is needed. Three compensation techniques are discussed  in Section 2.6.5.1  'Compensating  with the EUSART' , Section 2.6.5.2 'Compensating with the  Timers' and Section 2.6.5.3  'Compensating with the CCP1 Module in Capture Mode' , but other techniques may be used.",
    "OSCTUNE: OSCILLATOR TUNING REGISTER\nR/W-0, 1 = R/W-0 (1). R/W-0, 2 = U-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. INTSRC, 1 = PLLEN (1). INTSRC, 2 = -. INTSRC, 3 = TUN4. INTSRC, 4 = TUN3. INTSRC, 5 = TUN2. INTSRC, 6 = TUN1. INTSRC, 7 = TUN0\nbit 7\nbit 0\nbit 7\nINTSRC: Internal Oscillator Low-Frequency Source Select bit\n1 0 = 31 kHz device clock derived directly from INTRC internal oscillator\n= 31.25 kHz device clock derived from 8 MHz INTOSC source (divide-by-256 enabled)\nbit 6 PLLEN: Frequency Multiplier PLL for INTOSC Enable bit (1)",
    "OSCTUNE: OSCILLATOR TUNING REGISTER\n1 = PLL enabled for INTOSC (4 MHz and 8 MHz only)\n0 = PLL disabled\nNote 1: Available only in certain oscillator configurations; otherwise, this bit is unavailable and reads as ' 0 '. See text for details.",
    "bit 4-0 TUN4:TUN0: Frequency Tuning bits\n01111 = Maximum frequency\n\u2022\n\u2022\n\u2022\n\u2022\n00001\n00000 = Center frequency. Oscillator module is running at the calibrated frequency.\n11111\n\u2022\n\u2022\n\u2022\n\u2022\n10000 = Minimum frequency",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "2.6.5.1 Compensating with the EUSART\nAn  adjustment  may  be  required  when  the  EUSART begins to generate framing errors or receives data with errors  while  in  Asynchronous  mode.  Framing  errors indicate that the device clock frequency is too high. To adjust  for  this,  decrement  the  value  in  OSCTUNE  to reduce the clock frequency. On the other hand, errors in data may suggest that the clock speed is too low. To compensate,  increment  OSCTUNE  to  increase  the clock frequency.",
    "2.6.5.2 Compensating with the Timers\nThis technique compares device clock speed to some reference clock. Two timers may be used; one timer is clocked  by  the  peripheral  clock,  while  the  other  is clocked by a fixed reference source, such as the Timer1 oscillator.\nBoth timers are cleared, but the timer clocked by the reference  generates  interrupts.  When  an  interrupt occurs,  the  internally  clocked  timer  is  read  and  both timers are cleared. If the internally clocked timer value is  greater  than  expected,  then  the  internal  oscillator block is running too fast. To adjust for this, decrement the OSCTUNE register.",
    "2.6.5.2 Compensating with the Timers\nThe  CCP1  module  can  use  free  running  Timer1  (or Timer3), clocked by the internal oscillator block and an external  event  with  a  known  period  (i.e.,  AC  power frequency). The time of the first event is captured in the CCPRxH:CCPRxL registers  and  is  recorded  for  use later.  When  the  second  event  causes  a  capture,  the time of the first event is subtracted from the time of the second event. Since the period of the external event is known,  the  time  difference  between  events  can  be calculated.\nIf the measured  time is much  greater than the calculated time, the internal oscillator block is running too  fast.  To  compensate,  decrement  the  OSCTUNE register.  If  the  measured  time  is  much  less  than  the calculated time, the internal oscillator block is running too  slow.  To  compensate,  increment  the  OSCTUNE register.",
    "2.7 Clock Sources and Oscillator Switching\nLike previous PIC18 devices, the PIC2585/2680/ 4585/4680  family  includes  a  feature  that  allows  the device  clock  source  to  be  switched  from  the  main oscillator  to  an  alternate  low-frequency  clock  source. PIC18F2585/2680/4585/4680 devices offer two alternate clock sources. When an alternate clock source is enabled, the various power managed operating modes are available.\nEssentially,  there  are  three  clock  sources  for  these devices:\n\u00b7 Primary oscillators\n\u00b7 Secondary oscillators\n\u00b7 Internal oscillator block\nThe primary oscillators include the External Crystal and  Resonator  modes,  the  External  RC  modes,  the External Clock modes and the internal oscillator block. The particular mode is defined by the FOSC3:FOSC0 Configuration  bits.  The  details  of  these  modes  are covered earlier in this chapter.\nThe secondary oscillators are those external sources not  connected  to  the  OSC1  or  OSC2  pins.  These sources  may  continue  to  operate  even  after  the controller is placed in a power managed mode.",
    "2.7 Clock Sources and Oscillator Switching\nPIC18F2585/2680/4585/4680 devices offer the Timer1 oscillator as a secondary oscillator. This oscillator, in all power  managed  modes,  is  often  the  time  base  for functions such as a real-time clock.\nMost often, a 32.768 kHz watch crystal is connected between  the  RC0/T1OSO/T13CKI  and  RC1/T1OSI pins. Like the LP  mode  oscillator  circuit, loading capacitors are also connected from each pin to ground.\nThe Timer1 oscillator is discussed in greater detail in Section 12.3 'Timer1 Oscillator' .\nIn addition to being a primary clock source, the internal oscillator  block is  available  as  a  power  managed mode clock source. The INTRC source is also used as the clock source for several special features, such as the WDT and Fail-Safe Clock Monitor.\nThe clock sources for the PIC18F2585/2680/4585/4680 devices  are  shown  in  Figure 2-8.  See Section 24.0 'Special  Features  of  the  CPU' for Configuration register details.",
    "2.7.1 OSCILLATOR CONTROL REGISTER\nThe OSCCON register (Register 2-2) controls several aspects  of  the  device  clock's  operation,  both  in  full power operation and in power managed modes.\nThe IDLEN bit determines if the device goes into Sleep mode  or  one  of  the  Idle  modes  when  the SLEEP instruction is executed.\nThe System Clock Select bits, SCS1:SCS0, select the clock  source.  The  available  clock  sources  are  the primary clock (defined by the FOSC3:FOSC0 Configuration bits), the secondary clock (Timer1 oscillator) and the internal oscillator block. The clock source changes immediately after one or more of the bits is written to, following a brief clock transition interval. The SCS bits are cleared on all forms of Reset.",
    "2.7.1 OSCILLATOR CONTROL REGISTER\nThe Internal Oscillator Frequency Select bits, IRCF2:IRCF0,  select  the  frequency  output  of  the internal oscillator block to drive the device clock. The choices  are  the  INTRC  source,  the  INTOSC  source (8 MHz)  or  one  of  the  frequencies  derived  from  the INTOSC postscaler (31 kHz to 4 MHz). If the internal oscillator block is supplying the device clock, changing the states of these bits will have an immediate change on the internal  oscillator's  output.  On  device  Resets, the  default  output  frequency  of  the  internal  oscillator block is set at 1 MHz.\nWhen  an  output  frequency  of  31 kHz  is  selected (IRCF2:IRCF0  = 000 ), users may  choose  which internal oscillator acts as the source. This is done with the INTSRC bit in the OSCTUNE register (OSCTUNE<7>). Setting this bit selects INTOSC as a 31.25 kHz clock source by enabling the divide-by-256 output  of  the  INTOSC  postscaler.  Clearing  INTSRC selects INTRC (nominally 31 kHz) as the clock source.",
    "2.7.1 OSCILLATOR CONTROL REGISTER\nThis option allows users to select the tunable and more precise INTOSC as a clock source, while maintaining power savings with a very low clock speed. Regardless of the setting of INTSRC, INTRC always remains the clock source for features such as the Watchdog Timer and the Fail-Safe Clock Monitor.\nThe OSTS, IOFS and T1RUN bits indicate which clock source  is  currently  providing  the  device  clock.  The OSTS bit indicates  that  the  Oscillator  Start-up  Timer has timed out and the primary clock is providing the device  clock  in  primary  clock  modes.  The  IOFS  bit indicates when the internal oscillator block has stabilized and is providing the device clock in RC Clock modes. The T1RUN bit (T1CON<6>) indicates when the  Timer1  oscillator  is  providing  the  device  clock  in secondary  clock  modes.  In  power  managed  modes, only one of these three bits will be set at any time. If none of these bits are set, the INTRC is providing the clock or the internal oscillator block has just started and is not yet stable.",
    "2.7.1 OSCILLATOR CONTROL REGISTER\nThe use of the flag and control bits in the OSCCON register  is  discussed  in  more  detail  in Section 3.0 'Power Managed Modes' .\nNote 1: The Timer1 oscillator must be enabled to select  the  secondary  clock  source.  The Timer1 oscillator is enabled by setting the T1OSCEN bit in the Timer1 Control register (T1CON<3>). If the Timer1 oscillator is not enabled, then any attempt to select a secondary clock source when executing a SLEEP instruction will be ignored.\n2: It is recommended that the Timer1 oscillator be operating and stable before executing  the SLEEP instruction,  or  a very long delay may occur while the Timer1 oscillator starts.",
    "2.7.2 OSCILLATOR TRANSITIONS\nPIC18F2585/2680/4585/4680 devices contain circuitry to  prevent  clock  'glitches'  when  switching  between clock sources. A short pause in the device clock occurs during the clock switch. The length of this pause is the sum of two cycles of the old clock source and three to four  cycles  of  the  new  clock  source.  This  formula assumes that the new clock source is stable.\nClock  transitions  are  discussed  in  greater  detail  in Section 3.1.2 'Entering Power Managed Modes' .",
    "OSCCON: OSCILLATOR CONTROL REGISTER\nR/W-0, 1 = R/W-1. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R (1). R/W-0, 5 = R-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IDLEN, 1 = IRCF2. IDLEN, 2 = IRCF1. IDLEN, 3 = IRCF0. IDLEN, 4 = OSTS. IDLEN, 5 = IOFS. IDLEN, 6 = SCS1. IDLEN, 7 = SCS0\nbit 7\nbit 0",
    "bit 7 IDLEN: Idle Enable bit\n1 = Device enters Idle mode on SLEEP instruction\n0 = Device enters Sleep mode on SLEEP instruction",
    "bit 6-4 IRCF2:IRCF0: Internal Oscillator Frequency Select bits\n111 = 8 MHz (INTOSC drives clock directly)\n110 = 4 MHz\n101 = 2 MHz\n100 = 1 MHz (3)\n011 = 500 kHz\n010 = 250 kHz\n001 = 125 kHz\n000 = 31 kHz (from either INTOSC/256 or INTRC directly) (2)",
    "bit 3 OSTS: Oscillator Start-up Time-out Status bit (1)\n1 = Oscillator start-up time-out timer has expired; primary oscillator is running\n0 = Oscillator start-up time-out timer is running; primary oscillator is not ready",
    "bit 2 IOFS: INTOSC Frequency Stable bit\n1 = INTOSC frequency is stable and the frequency is provided by one of the RC modes\n0 = INTOSC frequency is not stable",
    "bit 1-0 SCS1:SCS0: System Clock Select bits\n1x = Internal oscillator block\n01 = Timer1 oscillator\n00 = Primary oscillator\nNote 1: Depends on state of the IESO Configuration bit.\n2: Source selected by the INTSRC bit (OSCTUNE<7>), see text.\n3: Default output frequency of INTOSC on Reset.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "2.8 Effects of Power Managed Modes on the Various Clock Sources\nWhen  PRI_IDLE  mode  is  selected,  the  designated primary oscillator continues to run without interruption. For  all  other  power  managed  modes,  the  oscillator using the OSC1 pin is disabled. The OSC1 pin (and OSC2 pin, if used by the oscillator) will stop oscillating.\nIn  secondary  clock  modes  (SEC_RUN  and  SEC_I-DLE), the Timer1 oscillator is operating and providing the device clock. The Timer1 oscillator may also run in all power managed modes if required to clock Timer1 or Timer3.",
    "2.8 Effects of Power Managed Modes on the Various Clock Sources\nIn internal oscillator modes (RC_RUN and RC_IDLE), the internal oscillator block provides the device clock source. The 31 kHz INTRC output can be used directly to  provide  the  clock  and  may  be  enabled  to  support various  special  features,  regardless  of  the  power managed mode (see Section 24.2 'Watchdog Timer (WDT)' , Section 24.3  'Two-Speed  Start-up' and Section 24.4  'Fail-Safe  Clock  Monitor' for more information on WDT, Two-Speed Start-up and Fail-Safe Clock Monitor). The INTOSC output at 8 MHz may be used  directly  to  clock  the  device  or  may  be  divided down by the postscaler. The INTOSC output is disabled if the clock is provided directly from the INTRC output.\nIf  the  Sleep  mode  is  selected,  all  clock  sources  are stopped.  Since  all  the  transistor  switching  currents have been stopped, Sleep mode achieves the lowest current consumption  of the device (only leakage currents).",
    "2.8 Effects of Power Managed Modes on the Various Clock Sources\nreal-time clock. Other features may be operating that do not require a device clock source (i.e., SSP slave, PSP, INTn pins and others). Peripherals that may add significant current consumption are listed in Section 27.2 'DC  Characteristics:  Power  Down and Supply Current'.",
    "2.9 Power-up Delays\nPower-up delays are controlled by two timers, so that no external Reset circuitry is required for most applications.  The  delays  ensure  that  the  device  is  kept  in Reset until the device power supply is stable under normal circumstances and the primary clock is operating and  stable.  For  additional  information  on  power-up delays, see Section 4.5 'Device Reset Timers' .\nThe first timer is the Power-up Timer (PWRT), which provides  a  fixed  delay  on  power-up  (parameter  33, Table 27-10).  It is enabled  by  clearing  (= 0 ) the PWRTEN Configuration bit.\nThe  second  timer  is  the  Oscillator  Start-up  Timer (OST),  intended  to  keep  the  chip  in  Reset  until  the crystal oscillator is stable (LP, XT and HS modes). The OST  does  this  by  counting  1024  oscillator  cycles before allowing the oscillator to clock the device.\nWhen  the  HSPLL  Oscillator  mode  is  selected,  the device is kept in Reset for an additional 2 ms, following the HS mode OST delay, so the PLL can lock to the incoming clock frequency.",
    "2.9 Power-up Delays\nEnabling any on-chip feature that will operate during Sleep will increase the current consumed during Sleep. The INTRC is required to support WDT operation. The Timer1  oscillator may  be  operating  to support a\nThere  is  a  delay  of  interval  TCSD  (parameter  38, Table 27-10), following POR,  while the controller becomes ready to execute instructions. This delay runs concurrently  with  any  other  delays.  This  may  be  the only delay that occurs when any of the EC, RC or INTIO modes are used as the primary clock source.",
    "TABLE 2-3: OSC1 AND OSC2 PIN STATES IN SLEEP MODE\nRC, INTIO1, OSC1 Pin = Floating, external resistor should pull high. RC, INTIO1, OSC2 Pin = At logic low (clock/4 output). RCIO, INTIO2, OSC1 Pin = Floating, external resistor should pull high. RCIO, INTIO2, OSC2 Pin = Configured as PORTA, bit 6. ECIO, OSC1 Pin = Floating, pulled by external clock. ECIO, OSC2 Pin = Configured as PORTA, bit 6. EC, OSC1 Pin = Floating, pulled by external clock. EC, OSC2 Pin = At logic low (clock/4 output). LP, XT and HS, OSC1 Pin = Feedback inverter disabled at quiescent voltage level. LP, XT and HS, OSC2 Pin = Feedback inverter disabled at quiescent voltage level\nNote: See Table 4-2 in Section 4.0 'Reset' for time-outs due to Sleep and MCLR Reset.",
    "3.1.1 CLOCK SOURCES\nPIC18F2585/2680/4585/4680  devices  offer  a  total  of seven  operating modes  for more  efficient power management.  These  modes  provide  a  variety  of options for selective power conservation in applications where resources may be limited (i.e., battery-powered devices).\nThere are three categories of power managed modes:\n\u00b7 Run modes\n\u00b7 Idle modes\n\u00b7 Sleep mode\nThese categories define which portions of the device are clocked and sometimes, what speed. The Run and Idle modes may use any of the three available clock sources (primary, secondary or internal oscillator block); the Sleep mode does not use a clock source.\nThe  power  managed  modes  include  several  power saving features offered on previous PIC \u00ae  devices. One is  the  clock  switching feature, offered in other PIC18 devices,  allowing  the  controller  to  use  the  Timer1 oscillator in place of the primary oscillator. Also included is the Sleep mode, offered by all PIC devices, where all device clocks are stopped.",
    "3.1 Selecting Power Managed Modes\nSelecting a power managed mode requires two decisions:  if  the  CPU  is  to  be  clocked  or  not  and  the selection of a clock source. The IDLEN bit (OSCCON<7>) controls CPU clocking, while the SCS1:SCS0  bits  (OSCCON<1:0>)  select  the  clock source. The individual modes, bit settings, clock sources and affected modules are summarized in Table 3-1.\nThe SCS1:SCS0 bits allow the selection of one of three clock sources for power managed modes. They are:\n\u00b7 the primary clock, as defined by the FOSC3:FOSC0 Configuration bits\n\u00b7 the secondary clock (the Timer1 oscillator)\n\u00b7 the internal oscillator block (for RC modes)",
    "3.1.2 ENTERING POWER MANAGED MODES\nSwitching from one power managed mode to another begins by loading the OSCCON register. The SCS1:SCS0 bits select the clock source and determine which Run or Idle mode is to be used. Changing these bits  causes  an  immediate  switch  to  the  new  clock source,  assuming  that  it  is  running.  The  switch  may also  be  subject  to  clock  transition  delays.  These  are discussed  in Section 3.1.3  'Clock  Transitions  And Status Indicators' and subsequent sections.\nEntry to the Power Managed Idle or Sleep modes is triggered by the execution of a SLEEP instruction. The actual mode that results depends on the status of the IDLEN bit.\nDepending on the current mode and the mode being switched to, a change to a power managed mode does not  always  require  setting  all  of  these  bits.  Many transitions  may  be  done  by  changing  the  oscillator select bits, or changing the IDLEN bit, prior to issuing a SLEEP instruction. If the IDLEN bit is already configured  correctly,  it  may  only  be  necessary  to perform a SLEEP instruction  to  switch  to  the  desired mode.",
    "TABLE 3-1: POWER MANAGED MODES\nSleep, OSCCON Bits.IDLEN<7> (1) = 0. Sleep, OSCCON Bits.SCS1:SCS0<1:0> = N/A. Sleep, Module Clocking.CPU = Off. Sleep, Module Clocking.Peripherals = Off. Sleep, Available Clock and Oscillator Source.Available Clock and Oscillator Source = None - All clocks are disabled. PRI_RUN, OSCCON Bits.IDLEN<7> (1) = N/A. PRI_RUN, OSCCON Bits.SCS1:SCS0<1:0> = 00. PRI_RUN, Module Clocking.CPU = Clocked. PRI_RUN, Module Clocking.Peripherals = Clocked. PRI_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Primary - LP, XT, HS, HSPLL, RC, EC, INTRC (2) : This is the normal full power execution mode.. SEC_RUN, OSCCON Bits.IDLEN<7> (1) = N/A. SEC_RUN, OSCCON",
    "TABLE 3-1: POWER MANAGED MODES\nBits.SCS1:SCS0<1:0> = 01. SEC_RUN, Module Clocking.CPU = Clocked. SEC_RUN, Module Clocking.Peripherals = Clocked. SEC_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Secondary - Timer1 Oscillator. RC_RUN, OSCCON Bits.IDLEN<7> (1) = N/A. RC_RUN, OSCCON Bits.SCS1:SCS0<1:0> = 1x. RC_RUN, Module Clocking.CPU = Clocked. RC_RUN, Module Clocking.Peripherals = Clocked. RC_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Internal Oscillator Block (2). PRI_IDLE, OSCCON Bits.IDLEN<7> (1) = 1. PRI_IDLE, OSCCON Bits.SCS1:SCS0<1:0> = 00. PRI_IDLE, Module Clocking.CPU = Off. PRI_IDLE, Module Clocking.Peripherals =",
    "TABLE 3-1: POWER MANAGED MODES\nClocked. PRI_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Primary - LP, XT, HS, HSPLL, RC, EC. SEC_IDLE, OSCCON Bits.IDLEN<7> (1) = 1. SEC_IDLE, OSCCON Bits.SCS1:SCS0<1:0> = 01. SEC_IDLE, Module Clocking.CPU = Off. SEC_IDLE, Module Clocking.Peripherals = Clocked. SEC_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Secondary - Timer1 Oscillator. RC_IDLE, OSCCON Bits.IDLEN<7> (1) = 1. RC_IDLE, OSCCON Bits.SCS1:SCS0<1:0> = 1x. RC_IDLE, Module Clocking.CPU = Off. RC_IDLE, Module Clocking.Peripherals = Clocked. RC_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Internal Oscillator Block (2)",
    "TABLE 3-1: POWER MANAGED MODES\nNote 1: IDLEN reflects its value when the SLEEP instruction is executed.\n2: Includes INTOSC and INTOSC postscaler, as well as the INTRC source.",
    "3.1.3 CLOCK TRANSITIONS AND STATUS INDICATORS\nThe length of the transition between clock sources is the sum of two cycles of the old clock source and three to  four  cycles  of  the  new  clock  source.  This  formula assumes that the new clock source is stable.\nThree  bits  indicate  the  current  clock  source  and  its status. They are:\n\u00b7 OSTS (OSCCON<3>)\n\u00b7 IOFS (OSCCON<2>)\n\u00b7 T1RUN (T1CON<6>)\nIn general, only one of these bits will be set while in a given  power  managed mode. When the OSTS bit is set,  the  primary  clock  is  providing  the  device  clock. When the IOFS bit is set, the INTOSC output is providing  a  stable  8 MHz  clock  source  to  a  divider  that actually drives the device clock. When the T1RUN bit is set, the Timer1 oscillator is providing the clock. If none of  these  bits  are  set,  then  either  the  INTRC  clock source is clocking the device, or the INTOSC source is not yet stable.",
    "3.1.3 CLOCK TRANSITIONS AND STATUS INDICATORS\nIf the  internal  oscillator  block  is  configured  as  the primary clock source by the FOSC3:FOSC0 Configuration bits, then both the OSTS and IOFS bits may be set when in PRI_RUN or PRI_IDLE modes. This indicates that the primary clock (INTOSC output) is generating a stable  8 MHz  output.  Entering  another  RC  power managed mode at the same frequency would clear the OSTS bit.\nNote 1: Caution should be used when modifying a single IRCF bit. If VDD is less than 3V, it is possible to select a higher clock speed than is supported by the low VDD. Improper device operation may result if the VDD/FOSC specifications are violated.\n2: Executing a SLEEP instruction does not necessarily  place  the  device  into  Sleep mode. It acts as the trigger to place the controller  into  either  the  Sleep  mode  or one of the Idle modes, depending on the setting of the IDLEN bit.",
    "3.1.4 MULTIPLE SLEEP COMMANDS\nThe  power  managed  mode  that  is  invoked  with  the SLEEP instruction is determined by the setting of the IDLEN  bit  at  the  time  the  instruction  is  executed.  If another SLEEP instruction is executed, the device will enter the power managed mode specified by IDLEN at that time. If IDLEN has changed, the device will enter the new power managed mode specified by the new setting.",
    "3.2 Run Modes\nIn the  Run  modes,  clocks  to  both  the  core  and peripherals are active. The difference between these modes is the clock source.",
    "3.2.1 PRI_RUN MODE\nThe PRI_RUN mode is the normal, full power execution mode of  the  microcontroller.  This  is  also  the  default mode upon a device Reset, unless Two-Speed Start-up is enabled (see Section 24.3 'Two-Speed Start-up' for details). In this mode, the OSTS bit is set. The IOFS bit  may  be  set  if  the  internal  oscillator  block  is  the primary  clock  source  (see Section 2.7.1  'Oscillator Control Register' ).",
    "3.2.2 SEC_RUN MODE\nThe SEC_RUN mode is the compatible mode to the 'clock switching' feature offered in other PIC18 devices.  In  this  mode,  the  CPU  and  peripherals  are clocked from the Timer1 oscillator. This gives users the option of lower power consumption while still using a high accuracy clock source.\nSEC_RUN mode is entered by setting the SCS1:SCS0 bits to ' 01 '. The device clock source is switched to the Timer1 oscillator (see Figure 3-1), the primary oscillator is shut down, the T1RUN bit (T1CON<6>) is set and the OSTS bit is cleared.\nNote: The  Timer1  oscillator  should  already  be running prior to entering SEC_RUN mode. If the T1OSCEN bit is not set when the SCS1:SCS0 bits are set to ' 01 ', entry to  SEC_RUN mode will not occur. If the Timer1  oscillator  is  enabled  but  not  yet running, device clocks will be delayed until the  oscillator  has  started.  In  such  situations, initial oscillator operation is far from stable  and  unpredictable  operation  may result.",
    "3.2.2 SEC_RUN MODE\nOn transitions from SEC_RUN mode to PRI_RUN, the peripherals and CPU continue to be clocked from the Timer1  oscillator  while  the  primary  clock  is  started. When the primary clock becomes ready, a clock switch back  to  the  primary  clock  occurs  (see  Figure 3-2). When the clock switch is complete, the T1RUN bit is cleared, the OSTS bit is set and the primary clock is providing the clock. The IDLEN and SCS bits are not affected by the wake-up; the Timer1 oscillator continues to run.",
    "FIGURE 3-1: TRANSITION TIMING FOR ENTRY TO SEC_RUN MODE\nFIGURE 3-2: TRANSITION TIMING FROM SEC_RUN MODE TO PRI_RUN MODE (HSPLL)",
    "3.2.3 RC_RUN MODE\nIn RC_RUN  mode,  the  CPU  and  peripherals  are clocked  from  the  internal  oscillator  block  using  the INTOSC multiplexer; the primary clock is shut down. When using the INTRC source, this mode provides the best power conservation of all the Run modes, while still executing code. It works well for user applications which are not highly timing sensitive or do not require high-speed clocks at all times.\nIf  the  primary  clock  source  is  the  internal  oscillator block (either INTRC or INTOSC), there are no distinguishable differences between PRI_RUN and RC_RUN modes during execution. However, a clock switch  delay  will  occur  during  entry  to  and  exit  from RC_RUN mode. Therefore, if the primary clock source is  the  internal  oscillator  block,  the  use  of  RC_RUN mode is not recommended.",
    "3.2.3 RC_RUN MODE\nThis mode is entered by setting SCS1 to ' 1 '. Although it  is  ignored,  it  is  recommended  that  SCS0  also  be cleared; this is to maintain software compatibility with future devices. When the clock source is switched to the INTOSC multiplexer (see Figure 3-3), the primary oscillator is shut down and the OSTS bit is cleared. The IRCF bits may be modified at any time to immediately change the clock speed.",
    "Note:\nCaution should be used when modifying a single IRCF bit. If VDD is less than 3V, it is possible  to  select  a  higher  clock  speed than is supported by the low VDD. Improper  device  operation  may  result  if the VDD/FOSC specifications are violated.",
    "PIC18F2585/2680/4585/4680\nIf  the IRCF bits and the INTSRC bit are all clear, the INTOSC output is  not  enabled  and  the  IOFS  bit  will remain clear; there will be no indication of the current clock  source.  The  INTRC  source  is  providing  the device clocks.\nIf the  IRCF  bits  are  changed  from  all  clear  (thus, enabling the INTOSC output) or if INTSRC is set, the IOFS  bit becomes  set  after the INTOSC  output becomes stable. Clocks to the device continue while the  INTOSC  source  stabilizes  after  an  interval  of TIOBST.\nOn transitions from RC_RUN mode to PRI_RUN mode, the device continues to be clocked from the INTOSC multiplexer while the primary clock is started. When the primary  clock  becomes  ready,  a  clock  switch  to  the primary clock occurs (see Figure 3-4). When the clock switch is complete, the IOFS bit is cleared, the OSTS bit is set and the primary clock is providing the device clock. The IDLEN and SCS bits are not affected by the switch. The INTRC source will continue to run if either the WDT or the Fail-Safe Clock Monitor is enabled.",
    "PIC18F2585/2680/4585/4680\nIf the IRCF bits were previously at a non-zero value or if INTSRC  was  set  before  setting  SCS1  and  the INTOSC source was already stable, the IOFS bit will remain set.",
    "3.3 Sleep Mode\nThe Power Managed Sleep mode in the PIC18F2585/2680/4585/4680  devices  is  identical  to the legacy Sleep mode offered in all other PIC devices. It is entered by clearing the IDLEN bit (the default state on device Reset) and executing the SLEEP instruction. This shuts down the selected oscillator (Figure 3-5). All clock source status bits are cleared.\nEntering the Sleep mode from any other mode does not require a clock switch. This is because no clocks are needed once the controller has entered Sleep. If the WDT is selected,  the  INTRC  source  will  continue  to operate. If the Timer1 oscillator is enabled, it will also continue to run.",
    "3.3 Sleep Mode\nWhen a wake event occurs in Sleep mode (by interrupt, Reset or WDT time-out), the device will not be clocked until the clock source selected by the SCS1:SCS0 bits becomes ready (see Figure 3-6), or it will be clocked from the internal oscillator block if either the Two-Speed Start-up  or  the  Fail-Safe  Clock  Monitor  are  enabled (see Section 24.0 'Special Features of the CPU' ). In either case, the OSTS bit is set when the primary clock is providing the device clocks. The IDLEN and SCS bits are not affected by the wake-up.",
    "3.4 Idle Modes\nThe  Idle  modes  allow  the  controller's  CPU  to  be selectively shut down while the peripherals continue to operate. Selecting a particular Idle mode allows users to further manage power consumption.\nIf the IDLEN bit is set to a ' 1 ' when a SLEEP instruction is executed, the peripherals will be clocked from the clock source selected using the SCS1:SCS0 bits; however, the CPU will not be clocked. The clock source status bits are not  affected.  Setting  IDLEN  and  executing  a SLEEP instruction provides a quick method of switching from a given Run mode to its corresponding Idle mode.\nIf the WDT is selected, the INTRC source will continue to operate. If the Timer1 oscillator is enabled, it will also continue to run.",
    "3.4 Idle Modes\nSince the CPU is not executing instructions, the only exits from any of the Idle modes are by interrupt, WDT time-out or a Reset. When a wake event occurs, CPU execution is delayed by an interval of TCSD (parameter 38, Table 27-10) while it becomes ready to execute code. When the CPU begins executing code, it resumes with the same clock source for the current Idle mode. For example, when waking from RC_IDLE mode, the internal oscillator block will clock the CPU and peripherals (in other words, RC_RUN mode). The IDLEN and SCS bits are not affected by the wake-up.\nWhile  in  any  Idle  mode  or  the  Sleep  mode,  a  WDT time-out will result in a WDT wake-up to the Run mode currently specified by the SCS1:SCS0 bits.",
    "FIGURE 3-5: TRANSITION TIMING FOR ENTRY TO SLEEP MODE\nOSC1, Q4 Q3 Q2 Q1 Q1 = . OSC1,  = . CPU, Q4 Q3 Q2 Q1 Q1 = . CPU,  = . Clock, Q4 Q3 Q2 Q1 Q1 = . Clock,  = . Peripheral, Q4 Q3 Q2 Q1 Q1 = . Peripheral,  = . Clock, Q4 Q3 Q2 Q1 Q1 = . Clock,  = . Sleep, Q4 Q3 Q2 Q1 Q1 = . Sleep,  = . Program Counter, Q4 Q3 Q2 Q1 Q1 = . Program Counter,  = PC + 2. , Q4 Q3 Q2 Q1 Q1 = PC. ,  = \nFIGURE 3-6:",
    "3.4.1 PRI_IDLE MODE\nThis mode is unique among the three Low-Power Idle modes, in that it does not disable the primary device clock. For timing sensitive applications, this allows for the fastest resumption of device operation with its more accurate primary clock source, since the clock source does not have to 'warm up' or transition from another oscillator.\nPRI_IDLE mode is entered from PRI_RUN mode by setting the IDLEN bit and executing a SLEEP instruction. If the device is in another Run mode, set IDLEN first,  then  clear  the  SCS  bits  and  execute SLEEP . Although the CPU is disabled, the peripherals continue to be clocked from the primary clock source specified by the FOSC3:FOSC0 Configuration bits. The OSTS bit remains set (see Figure 3-7).",
    "3.4.2 SEC_IDLE MODE\nIn  SEC_IDLE  mode,  the  CPU  is  disabled  but  the peripherals  continue  to  be  clocked  from  the  Timer1 oscillator. This mode is entered from SEC_RUN by setting the IDLEN bit and executing a SLEEP instruction. If the device is in another Run mode, set the IDLEN bit first, then set the SCS1:SCS0 bits to ' 01 ' and execute SLEEP . When the clock source is switched to the Timer1 oscillator, the primary oscillator is shut down, the OSTS bit is cleared and the T1RUN bit is set.\nWhen a wake event occurs, the CPU is clocked from the primary  clock  source.  A  delay  of  interval  TCSD  is required  between  the  wake  event  and  when  code execution starts. This is required to allow the CPU to become ready to execute instructions. After the wake-up, the  OSTS bit  remains  set.  The  IDLEN  and SCS  bits are not affected by the wake-up  (see Figure 3-8).",
    "3.4.2 SEC_IDLE MODE\nWhen a wake event occurs, the peripherals continue to be clocked from the Timer1 oscillator. After an interval of TCSD following the wake event, the CPU  begins executing code being clocked by the Timer1 oscillator. The  IDLEN  and  SCS  bits  are  not  affected  by  the wake-up;  the  Timer1  oscillator  continues  to  run  (see Figure 3-8).\nNote:\nThe  Timer1  oscillator  should  already  be running prior to entering SEC_IDLE mode. If  the  T1OSCEN  bit  is  not  set  when  the SLEEP instruction is executed, the SLEEP instruction  will  be  ignored  and  entry  to SEC_IDLE mode will not occur. If the Timer1 oscillator is enabled but not yet running, peripheral clocks will  be  delayed  until  the oscillator has started. In such situations, initial oscillator operation is far from stable and unpredictable operation may result.",
    "3.4.3 RC_IDLE MODE\nIn RC_IDLE mode, the CPU is disabled but the peripherals continue to be clocked from the internal oscillator block using the INTOSC multiplexer. This mode allows for controllable power conservation during Idle periods.\nFrom  RC_RUN,  this  mode  is  entered  by  setting  the IDLEN  bit  and  executing  a SLEEP instruction.  If  the device is in another Run mode, first set IDLEN, then set the SCS1 bit and execute SLEEP . Although its value is ignored, it is recommended that SCS0 also be cleared; this  is  to  maintain  software  compatibility  with  future devices.  The  INTOSC  multiplexer  may  be  used  to select a higher clock frequency, by modifying the IRCF bits, before executing the SLEEP instruction. When the clock source is switched to the INTOSC multiplexer, the primary  oscillator  is  shut  down  and  the  OSTS  bit  is cleared.",
    "3.4.3 RC_IDLE MODE\nIf  the  IRCF bits are set to any non-zero value or the INTSRC bit is set, the INTOSC output is enabled. The IOFS  bit becomes  set,  after the INTOSC  output becomes stable, after an interval of TIOBST (parameter 39, Table 27-10). Clocks to the peripherals continue  while  the  INTOSC  source  stabilizes.  If  the IRCF  bits  were  previously  at  a  non-zero  value,  or INTSRC  was  set  before  the SLEEP instruction  was executed and the INTOSC source was already stable, the  IOFS  bit  will  remain  set.  If  the  IRCF  bits  and INTSRC are all clear, the INTOSC output will not be enabled, the IOFS bit will remain clear and there will be no indication of the current clock source.",
    "3.4.3 RC_IDLE MODE\nWhen a wake event occurs, the peripherals continue to be clocked from the INTOSC multiplexer. After a delay of  TCSD  following  the  wake  event,  the  CPU  begins executing  code  being  clocked  by  the  INTOSC  multiplexer. The IDLEN and SCS bits are not affected by the wake-up.  The  INTRC  source  will  continue  to  run  if either  the  WDT  or  the  Fail-Safe  Clock  Monitor  is enabled.",
    "3.5 Exiting Idle and Sleep Modes\nAn exit from Sleep mode or any of the Idle modes is triggered by an interrupt, a Reset or a WDT time-out. This  section  discusses  the  triggers  that  cause  exits from power managed modes. The clocking subsystem actions are discussed in each of the power managed modes (see Section 3.2 'Run Modes', Section 3.3 'Sleep Mode' and Section 3.4 'Idle Modes' ).",
    "3.5.1 EXIT BY INTERRUPT\nAny of the available interrupt sources can cause the device to exit from an Idle mode or the Sleep mode to a Run mode. To enable this functionality, an interrupt source must be enabled by setting its enable bit in one of the INTCON or PIE registers. The exit sequence is initiated when the corresponding interrupt flag bit is set.\nOn all exits from Idle or Sleep modes by interrupt, code execution branches  to  the interrupt vector if the GIE/GIEH  bit  (INTCON<7>)  is  set.  Otherwise,  code execution  continues  or  resumes  without  branching (see Section 9.0 'Interrupts' ).\nA fixed delay of interval TCSD following the wake event is required when leaving Sleep and Idle modes. This delay is required for the CPU to prepare for execution. Instruction execution resumes on the first clock cycle following this delay.",
    "3.5.2 EXIT BY WDT TIME-OUT\nA WDT time-out will cause different actions depending on which power managed mode the device is in when the time-out occurs.\nIf the device is not executing code (all Idle modes and Sleep mode), the time-out will result in an exit from the power managed mode (see Section 3.2 'Run Modes' and Section 3.3  'Sleep  Mode' ). If the  device  is executing code (all Run modes), the time-out will result in a WDT Reset (see Section 24.2 'Watchdog Timer (WDT)' ).\nThe WDT timer and postscaler are cleared by executing  a SLEEP or CLRWDT instruction,  the  loss  of  a currently selected clock source (if the Fail-Safe Clock Monitor is enabled) and modifying the IRCF bits in the OSCCON register if the internal oscillator block is the device clock source.",
    "3.5.3 EXIT BY RESET\nNormally, the device is held in Reset by the Oscillator Start-up Timer (OST) until the primary clock becomes ready. At that time, the OSTS bit is set and the device begins executing code. If the internal oscillator block is the new clock source, the IOFS bit is set instead.\nThe  exit  delay  time  from  Reset  to  the  start  of  code execution depends on both the clock sources before and after the wake-up and the type of oscillator if the new clock source is the primary clock. Exit delays are summarized in Table 3-2.",
    "3.5.3 EXIT BY RESET\nCode  execution  can  begin  before  the  primary  clock becomes ready. If either the Two-Speed Start-up (see Section 24.3  'Two-Speed  Start-up' ) or Fail-Safe Clock  Monitor  (see Section 24.4  'Fail-Safe  Clock Monitor' ) is enabled, the device may begin execution as soon as the Reset source has cleared. Execution is clocked  by  the  INTOSC  multiplexer  driven  by  the internal  oscillator  block.  Execution  is  clocked  by  the internal  oscillator  block  until  either  the  primary  clock becomes ready or a power managed mode is entered before the primary clock becomes ready; the primary clock is then shut down.",
    "3.5.4 EXIT WITHOUT AN OSCILLATOR START-UP DELAY\nCertain  exits  from  power  managed  modes  do  not invoke the OST at all. There are two cases:\n\u00b7 PRI_IDLE mode where the primary clock source is not stopped; and\n\u00b7 the primary clock source is not any of the LP, XT, HS or HSPLL modes.\nIn  these  instances,  the  primary  clock  source  either does not require an oscillator start-up delay, since it is already  running  (PRI_IDLE),  or  normally  does  not require an oscillator start-up delay (RC, EC and INTIO Oscillator  modes).  However, a fixed delay  of  interval TCSD  following  the  wake  event  is  still  required  when leaving Sleep and Idle modes to allow the CPU to prepare for execution. Instruction execution resumes on the first clock cycle following this delay.",
    "TABLE 3-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nPrimary Device Clock (PRI_IDLE mode), Clock Source After Wake-up = LP, XT, HS. Primary Device Clock (PRI_IDLE mode), Exit Delay = T CSD (2). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = OSTS. Primary Device Clock (PRI_IDLE mode), Clock Source After Wake-up = HSPLL. Primary Device Clock (PRI_IDLE mode), Exit Delay = T CSD (2). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = OSTS. Primary Device Clock (PRI_IDLE mode), Clock Source After Wake-up = EC, RC. Primary Device Clock (PRI_IDLE mode), Exit Delay = T CSD (2). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = OSTS. Primary Device Clock (PRI_IDLE mode), Clock Source After Wake-up = INTRC (1). Primary Device Clock (PRI_IDLE mode), Exit Delay =",
    "TABLE 3-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nT CSD (2). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = -. Primary Device Clock (PRI_IDLE mode), Clock Source After Wake-up = INTOSC (3). Primary Device Clock (PRI_IDLE mode), Exit Delay = T CSD (2). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = IOFS. T1OSC or INTRC (1), Clock Source After Wake-up = LP, XT, HS. T1OSC or INTRC (1), Exit Delay = T OST (4). T1OSC or INTRC (1), Clock Ready Status Bit (OSCCON) = OSTS. T1OSC or INTRC (1), Clock Source After Wake-up = HSPLL. T1OSC or INTRC (1), Exit Delay = T OST + t rc (4). T1OSC or INTRC (1), Clock Ready Status Bit (OSCCON)",
    "TABLE 3-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\n= OSTS. T1OSC or INTRC (1), Clock Source After Wake-up = EC, RC. T1OSC or INTRC (1), Exit Delay = (2). T1OSC or INTRC (1), Clock Ready Status Bit (OSCCON) = . T1OSC or INTRC (1), Clock Source After Wake-up = INTRC (1). T1OSC or INTRC (1), Exit Delay = T CSD. T1OSC or INTRC (1), Clock Ready Status Bit (OSCCON) = -. T1OSC or INTRC (1), Clock Source After Wake-up = INTOSC (2). T1OSC or INTRC (1), Exit Delay = TIOBST (5). T1OSC or INTRC (1), Clock Ready Status Bit (OSCCON) = IOFS. INTOSC (3), Clock Source After Wake-up = LP, XT, HS. INTOSC (3), Exit Delay = T",
    "TABLE 3-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nOST (5). INTOSC (3), Clock Ready Status Bit (OSCCON) = OSTS. INTOSC (3), Clock Source After Wake-up = HSPLL. INTOSC (3), Exit Delay = T OST + t rc (4). INTOSC (3), Clock Ready Status Bit (OSCCON) = OSTS. INTOSC (3), Clock Source After Wake-up = EC, RC. INTOSC (3), Exit Delay = (2). INTOSC (3), Clock Ready Status Bit (OSCCON) = . INTOSC (3), Clock Source After Wake-up = INTRC (1). INTOSC (3), Exit Delay = T CSD. INTOSC (3), Clock Ready Status Bit (OSCCON) = -. INTOSC (3), Clock Source After Wake-up = INTOSC (2). INTOSC (3), Exit Delay = None. INTOSC (3), Clock Ready Status Bit (OSCCON) = IOFS. None (Sleep",
    "TABLE 3-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nmode), Clock Source After Wake-up = LP, XT, HS. None (Sleep mode), Exit Delay = T OST (4). None (Sleep mode), Clock Ready Status Bit (OSCCON) = OSTS. None (Sleep mode), Clock Source After Wake-up = HSPLL. None (Sleep mode), Exit Delay = T OST + t rc (4). None (Sleep mode), Clock Ready Status Bit (OSCCON) = OSTS. None (Sleep mode), Clock Source After Wake-up = EC, RC. None (Sleep mode), Exit Delay = (2). None (Sleep mode), Clock Ready Status Bit (OSCCON) = . None (Sleep mode), Clock Source After Wake-up = INTRC (1). None (Sleep mode), Exit Delay = T CSD. None (Sleep mode), Clock Ready Status Bit (OSCCON) = -. None (Sleep mode), Clock Source After Wake-up = INTOSC (2). None (Sleep mode), Exit Delay",
    "TABLE 3-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\n= TIOBST (5). None (Sleep mode), Clock Ready Status Bit (OSCCON) = IOFS\nNote 1: In this instance, refers specifically to the 31 kHz INTRC clock source.\n2: TCSD (parameter 38) is a required delay when waking from Sleep and all Idle modes and runs concurrently with any other required delays (see Section 3.4 'Idle Modes' ).\n3: Includes both the INTOSC 8 MHz source and postscaler derived frequencies.\n4: TOST is the Oscillator Start-up Timer (parameter 32). t rc is the PLL Lock-out Timer (parameter F12); it is also designated as TPLL.\n5: Execution continues during TIOBST (parameter 39), the INTOSC stabilization period.",
    "4.0 RESET\nThe PIC18F2585/2680/4585/4680 devices differentiate between various kinds of Reset:\na) Power-on Reset (POR)\nb) MCLR Reset during normal operation\nc) MCLR Reset during power managed modes\nd) Watchdog Timer (WDT) Reset (during execution)\ne) Programmable Brown-out Reset (BOR)\nf) RESET Instruction\ng) Stack Full Reset\nh) Stack Underflow Reset\nThis  section  discusses  Resets  generated  by  MCLR, POR and BOR and covers the operation of the various start-up  timers.  Stack  Reset  events  are  covered  in Section 6.1.2.4 'Stack Full and Underflow Resets' . WDT Resets are covered in Section 24.2 'Watchdog Timer (WDT)' .\nA simplified block diagram of the On-Chip Reset Circuit is shown in Figure 4-1.",
    "4.1 RCON Register\nDevice Reset events are tracked through the RCON register (Register 4-1).  The  lower  five  bits of the register indicate that a specific Reset  event  has occurred. In most cases, these bits can only be cleared by the event and must be set by the application after the event. The state of these flag bits, taken together, can  be  read  to  indicate  the  type  of  Reset  that  just occurred. This is described in more detail in Section 4.6 'Reset State of Registers' .\nThe  RCON  register  also  has  control  bits  for  setting interrupt  priority  (IPEN)  and  software  control  of  the BOR  (SBOREN).  Interrupt  priority  is  discussed  in Section 9.0 'Interrupts' . BOR is covered in Section 4.4 'Brown-out Reset (BOR)' .",
    "SIMPLIFIED BLOCK DIAGRAM OF ON-CHIP RESET CIRCUIT\nNote 1: This is the INTRC source from the internal oscillator block and is separate from the RC oscillator of the CLKI pin.\n- 2: See Table 4-2 for time-out situations.",
    "RCON: RESET CONTROL REGISTER\nR/W-0, 1 = R/W-1 (1). R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R-1. R/W-0, 5 = R-1. R/W-0, 6 = R/W-0 (2). R/W-0, 7 = R/W-0. IPEN, 1 = SBOREN. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0",
    "bit 7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (16CXXX Compatibility mode)",
    "bit 6 SBOREN: BOR Software Enable bit (1)\nIf BOREN1:BOREN0 = 01 :\n1 = BOR is enabled\n0 = BOR is disabled\nIf BOREN1:BOREN0 = 00 10 , or 11 :\nBit is disabled and read as ' 0 '.",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nRI: RESET Instruction Flag bit\n1 = The RESET instruction was not executed (set by firmware only)\n0 = The RESET instruction was executed causing a device Reset (must be set in software after a Brown-out Reset occurs)\nTO: Watchdog Time-out Flag bit\n1 = Set by power-up, CLRWDT instruction or SLEEP instruction\n0 = A WDT time-out occurred",
    "bit 2 PD: Power-down Detection Flag bit\n1 = Set by power-up or by the CLRWDT instruction\n0 = Set by execution of the SLEEP instruction",
    "bit 1 POR: Power-on Reset Status bit (2)\n1 = A Power-on Reset has not occurred (set by firmware only)\n0 = A Power-on Reset occurred (must be set in software after a Power-on Reset occurs)\nBOR: Brown-out Reset Status bit\n1 = A Brown-out Reset has not occurred (set by firmware only)\n0 = A Brown-out Reset occurred (must be set in software after a Brown-out Reset occurs)\nNote 1: If SBOREN is enabled, its Reset state is ' 1 '; otherwise, it is ' 0 '.\n2: The actual Reset value of POR is determined by the type of device Reset. See the notes  following  this  register  and Section 4.6  'Reset  State  of  Registers' for additional information.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "bit 1 POR: Power-on Reset Status bit (2)\nNote 1:, 1 = It is recommended that the POR bit be set after a Power-on Reset has been detected so that subsequent Power-on Resets may be detected.. 2:, 1 = Brown-out Reset is said to have occurred when BOR is ' 0 ' and POR is ' 1 ' (assuming that POR was set to ' 1 ' by software immediately after POR).",
    "4.2 Master Clear Reset (MCLR)\nThe  MCLR  pin  provides  a  method  for  triggering  an external Reset of the device. A Reset is generated by holding the pin low. These devices have a noise filter in the MCLR Reset path which detects and ignores small pulses.\nThe MCLR pin is not driven low by any internal Resets, including the WDT.\nIn  PIC18F2585/2680/4585/4680  devices,  the  MCLR input can be disabled with the MCLRE Configuration bit. When MCLR is disabled, the pin becomes a digital input.  See Section 10.5 'PORTE, TRISE and LATE Registers' for more information.",
    "4.3 Power-on Reset (POR)\nA Power-on Reset pulse is generated on-chip whenever  VDD  rises  above  a  certain  threshold.  This allows the device to start in the initialized state when VDD is adequate for operation.\nTo take advantage of the POR circuitry, tie the MCLR pin through a resistor (1 k \uf057 to 10 k \uf057 ) to VDD. This will eliminate external RC components usually needed to create a Power-on Reset delay. A minimum rise rate for VDD  is  specified  (parameter  D004).  For  a  slow  rise time, see Figure 4-2.\nWhen the device starts normal operation (i.e., exits the Reset condition), device operating parameters (voltage, frequency, temperature, etc.) must be met to ensure operation. If these conditions are not met, the device  must  be  held  in  Reset  until  the  operating conditions are met.",
    "4.3 Power-on Reset (POR)\nPOR events are captured by the POR bit (RCON<1>). The state of the bit is set to ' 0 ' whenever a POR occurs; it does not change for any other Reset event. POR is not  reset  to  ' 1 '  by  any  hardware  event.  To  capture multiple events, the user manually resets the bit to ' 1 ' in software following any POR.",
    "EXTERNAL POWER-ON RESET CIRCUIT (FOR SLOW VDD POWER-UP)\nNote 1: External  Power-on  Reset  circuit  is  required only  if  the  VDD  power-up  slope  is  too  slow. The  diode  D  helps  discharge  the  capacitor quickly when VDD powers down.\n2: R < 40 k \uf057 is recommended to make sure that the  voltage  drop  across  R  does  not  violate the device's electrical specification.\n3: R1 \uf0b3 1  k \uf057 will  limit  any  current flowing into MCLR from external capacitor C, in the event of MCLR/VPP pin breakdown, due to Electrostatic Discharge (ESD) or Electrical Overstress (EOS).",
    "4.4 Brown-out Reset (BOR)\nPIC18F2585/2680/4585/4680 devices implement a BOR circuit that provides the user with a number of configuration and power-saving options. The BOR is controlled by the BORV1:BORV0 and BOREN1:BOREN0 Configuration  bits.  There  are  a  total  of  four  BOR  configurations which are summarized in Table 4-1.\nThe BOR threshold is set by the BORV1:BORV0 bits. If BOR  is  enabled  (any  values  of  BOREN1:BOREN0, except ' 00 '), any drop of VDD below VBOR (parameter D005) for greater than TBOR (parameter 35) will reset the device. A Reset may or may not occur if VDD falls below VBOR for less than TBOR. The chip will remain in Brown-out Reset until VDD rises above VBOR.",
    "4.4 Brown-out Reset (BOR)\nIf the Power-up Timer is enabled, it will be invoked after VDD  rises  above  VBOR;  it  then  will  keep  the  chip  in Reset for an additional time delay, TPWRT (parameter 33).  If  VDD  drops  below  VBOR  while  the Power-up Timer is running, the chip will go back into a Brown-out  Reset  and  the  Power-up  Timer  will  be initialized. Once VDD rises above VBOR, the Power-up Timer will execute the additional time delay.\nBOR and the Power-on Timer (PWRT) are independently configured. Enabling BOR Reset does not automatically enable the PWRT.",
    "4.4.1 SOFTWARE ENABLED BOR\nWhen  BOREN1:BOREN0  = 01 , the  BOR  can  be enabled  or  disabled  by  the  user  in  software.  This  is done  with the control bit, SBOREN  (RCON<6>). Setting  SBOREN  enables  the  BOR  to  function  as previously described. Clearing SBOREN disables the BOR entirely. The SBOREN bit operates only in this mode; otherwise it is read as ' 0 '.\nPlacing the BOR under software control gives the user the additional flexibility of tailoring the application to its environment without having to reprogram the device to change BOR configuration. It also allows the user to tailor device power consumption in software by eliminating the incremental current that the BOR consumes. While the BOR current is typically very small, it may have some impact in low-power applications.\nNote:\nEven when BOR is under software control, the BOR Reset voltage level is still set by the BORV1:BORV0 Configuration bits. It cannot be changed in software.",
    "4.4.2 DETECTING BOR\nWhen BOR is enabled, the BOR bit always resets to ' 0 ' on any BOR or POR event. This makes it difficult to determine if a BOR event has occurred just by reading the state of BOR alone. A more reliable method is to simultaneously check the state of both POR and BOR. This assumes that the POR bit is reset to ' 1 ' in software immediately after any POR event. IF BOR is ' 0 ' while POR is ' 1 ', it can be reliably assumed that a BOR event has occurred.",
    "4.4.3 DISABLING BOR IN SLEEP MODE\nWhen  BOREN1:BOREN0  = 10 , the  BOR  remains under  hardware  control  and  operates  as  previously described. Whenever the device enters Sleep mode, however, the BOR is automatically disabled. When the device  returns  to  any  other  operating  mode,  BOR  is automatically re-enabled.\nThis  mode  allows  for  applications  to  recover  from brown-out  situations,  while  actively  executing  code, when the device requires BOR protection the most. At the same time, it saves additional power in Sleep mode by eliminating the small incremental BOR current.",
    "4.4.3 DISABLING BOR IN SLEEP MODE\nTABLE 4-1: BOR CONFIGURATIONS\n\n0, BOR Configuration.BOREN0 = 0. 0, Status of SBOREN.(RCON<6>) = Unavailable. 0, BOR Operation = BOR disabled; must be enabled by reprogramming the Configuration bits.. 0, BOR Configuration.BOREN0 = 1. 0, Status of SBOREN.(RCON<6>) = Available. 0, BOR Operation = BOR enabled in software; operation controlled by SBOREN.. 1, BOR Configuration.BOREN0 = 0. 1, Status of SBOREN.(RCON<6>) = Unavailable. 1, BOR Operation = BOR enabled in hardware in Run and Idle modes, disabled during Sleep mode.. 1, BOR Configuration.BOREN0 = 1. 1, Status of SBOREN.(RCON<6>) = Unavailable. 1, BOR Operation = BOR enabled in hardware; must be disabled by reprogramming the Configuration bits.",
    "4.5 Device Reset Timers\nPIC18F2585/2680/4585/4680 devices incorporate three  separate  on-chip  timers  that  help  regulate  the Power-on  Reset  process.  Their  main  function  is  to ensure that the device clock is stable before code is executed. These timers are:\n\u00b7 Power-up Timer (PWRT)\n\u00b7 Oscillator Start-up Timer (OST)\n\u00b7 PLL Lock Time-out",
    "4.5.1 POWER-UP TIMER (PWRT)\nThe  Power-up  Timer  (PWRT)  of  PIC18F2585/2680/ 4585/4680 devices is an 11-bit counter which uses the INTRC  source  as  the  clock  input.  This  yields  an approximate  time  interval  of  2048 x 32 \uf06d s = 65.6 ms. While  the  PWRT  is  counting,  the  device  is  held  in Reset.\nThe power-up time delay depends on the INTRC clock and will vary from chip to chip due to temperature and process variation. See DC parameter 33 for details.\nThe  PWRT  is  enabled  by  clearing  the  PWRTEN Configuration bit.",
    "4.5.2 OSCILLATOR START-UP TIMER (OST)\nThe Oscillator Start-up Timer (OST) provides a 1024 oscillator  cycle  (from  OSC1  input)  delay  after  the PWRT delay is over (parameter 33). This ensures that the  crystal  oscillator  or  resonator  has  started  and stabilized.\nThe OST time-out is invoked only for XT, LP, HS and HSPLL modes and only on Power-on Reset or on exit from most power managed modes.",
    "TABLE 4-2: TIME-OUT IN VARIOUS SITUATIONS Table 6-1:\nHSPLL, Power-up and Brown-out.PWRTEN = 0 = 66 ms (1) + 1024 T OSC + 2 ms (2). HSPLL, Power-up and Brown-out.PWRTEN = 1 = 1024 T OSC + 2 ms (2). HSPLL, Exit from Power Managed Mode. = 1024 T OSC + 2 ms (2). HS, XT, LP, Power-up and Brown-out.PWRTEN = 0 = 66 ms (1) + 1024 T OSC. HS, XT, LP, Power-up and Brown-out.PWRTEN = 1 = 1024 T OSC. HS, XT, LP, Exit from Power Managed Mode. = 1024 T OSC. EC, ECIO, Power-up and Brown-out.PWRTEN = 0 = 66 ms (1). EC, ECIO, Power-up and Brown-out.PWRTEN = 1 = -. EC, ECIO, Exit from Power Managed Mode. = -. RC, RCIO, Power-up and",
    "TABLE 4-2: TIME-OUT IN VARIOUS SITUATIONS Table 6-1:\nBrown-out.PWRTEN = 0 = 66 ms (1). RC, RCIO, Power-up and Brown-out.PWRTEN = 1 = -. RC, RCIO, Exit from Power Managed Mode. = -. INTIO1, INTIO2, Power-up and Brown-out.PWRTEN = 0 = 66 ms (1). INTIO1, INTIO2, Power-up and Brown-out.PWRTEN = 1 = -. INTIO1, INTIO2, Exit from Power Managed Mode. = -\nNote 1: 66 ms (65.5 ms) is the nominal Power-up Timer (PWRT) delay.\n2: 2 ms is the nominal time required for the PLL to lock.",
    "4.5.3 PLL LOCK TIME-OUT\nWith  the  PLL  enabled  in  its  PLL  mode,  the  time-out sequence  following a Power-on  Reset  is slightly different from other oscillator modes. A separate timer is used to provide a fixed time-out that is sufficient for the PLL to lock to the main oscillator frequency. This PLL lock time-out (TPLL) is typically 2 ms and follows the oscillator start-up time-out.",
    "4.5.4 TIME-OUT SEQUENCE\nOn power-up, the time-out sequence is as follows:\n1. After the POR  pulse has cleared, PWRT time-out is invoked (if enabled).\n2. Then, the OST is activated.\nThe total time-out will vary based on oscillator configuration and the status of the PWRT.  Figure 4-3, Figure 4-4,  Figure 4-5,  Figure 4-6  and  Figure 4-7  all depict  time-out  sequences  on  power-up,  with  the Power-up Timer enabled and the device operating in HS Oscillator mode. Figures 4-3 through 4-6 also apply to devices operating in XT or LP modes. For devices in RC mode and with the PWRT disabled, on the other hand, there will be no time-out at all.\nSince the time-outs occur from the POR pulse, if MCLR is kept  low  long  enough,  all  time-outs  will  expire. Bringing MCLR high will begin execution immediately (Figure 4-5). This is useful for testing purposes or to synchronize more  than one PIC18FXXXX  device operating in parallel.",
    "TIME-OUT SEQUENCE ON POWER-UP (MCLR TIED TO VDD, VDD RISE < TPWRT)\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET",
    "FIGURE 4-6: SLOW RISE TIME (MCLR TIED TO VDD, VDD RISE > TPWRT)\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET\n0V\n1V\n5V\nTPWRT\nTOST",
    "FIGURE 4-7: TIME-OUT SEQUENCE ON POR W/PLL ENABLED (MCLR TIED TO VDD)\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET\nPLL TIME-OUT\nTPLL\nNote:\nTOST = 1024 clock cycles.\nTPLL \uf0bb 2 ms max. First three stages of the PWRT timer.",
    "4.6 Reset State of Registers\nMost registers are unaffected by a Reset. Their status is unknown  on  POR  and  unchanged  by  all  other Resets.  The  other  registers  are  forced  to  a  'Reset state' depending on the type of Reset that occurred.\nTable 4-4  describes  the  Reset  states  for  all  of  the Special Function Registers. These are categorized by Power-on  and  Brown-out  Resets,  Master  Clear  and WDT Resets and WDT wake-ups.\nMost  registers  are  not  affected  by  a  WDT  wake-up, since  this  is  viewed  as  the  resumption  of  normal operation. Status bits from the RCON register, RI, TO, PD,  POR  and  BOR,  are  set  or  cleared  differently  in different  Reset  situations,  as  indicated  in  Table 4-3. These bits are used in software to determine the nature of the Reset.",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nPower-on Reset, Program.Counter = 0000h. Power-on Reset, RCON Register.SBOREN = 1. Power-on Reset, RCON Register.RI = 1. Power-on Reset, RCON Register.TO = 1. Power-on Reset, RCON Register.PD = 1. Power-on Reset, RCON Register.POR = 0. Power-on Reset, RCON Register.BOR = 0. Power-on Reset, STKPTR Register.STKFUL = 0. Power-on Reset, STKPTR Register.STKUNF = 0. RESET Instruction, Program.Counter = 0000h. RESET Instruction, RCON Register.SBOREN = u (2). RESET Instruction, RCON Register.RI = 0. RESET Instruction, RCON Register.TO = u. RESET Instruction, RCON Register.PD = u. RESET Instruction, RCON Register.POR = u. RESET Instruction, RCON Register.BOR = u. RESET Instruction, STKPTR Register.STKFUL = u. RESET Instruction, STKPTR",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nRegister.STKUNF = u. Brown-out, Program.Counter = 0000h. Brown-out, RCON Register.SBOREN = u (2). Brown-out, RCON Register.RI = 1. Brown-out, RCON Register.TO = 1. Brown-out, RCON Register.PD = 1. Brown-out, RCON Register.POR = u. Brown-out, RCON Register.BOR = 0. Brown-out, STKPTR Register.STKFUL = u. Brown-out, STKPTR Register.STKUNF = u. MCLR during Power Managed Run modes, Program.Counter = 0000h. MCLR during Power Managed Run modes, RCON Register.SBOREN = u (2). MCLR during Power Managed Run modes, RCON Register.RI = u. MCLR during Power Managed Run modes, RCON Register.TO = 1. MCLR during Power Managed Run modes, RCON Register.PD = u. MCLR during Power Managed Run modes, RCON Register.POR = u. MCLR during Power",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nManaged Run modes, RCON Register.BOR = u. MCLR during Power Managed Run modes, STKPTR Register.STKFUL = u. MCLR during Power Managed Run modes, STKPTR Register.STKUNF = u. MCLR during Power Managed Idle modes and Sleep mode, Program.Counter = 0000h. MCLR during Power Managed Idle modes and Sleep mode, RCON Register.SBOREN = u (2). MCLR during Power Managed Idle modes and Sleep mode, RCON Register.RI = u. MCLR during Power Managed Idle modes and Sleep mode, RCON Register.TO = 1. MCLR during Power Managed Idle modes and Sleep mode, RCON Register.PD = 0. MCLR during Power Managed Idle modes and Sleep mode, RCON Register.POR = u. MCLR during Power Managed Idle modes and Sleep mode, RCON Register.BOR = u. MCLR during Power Managed Idle modes and Sleep mode, STKPTR Register.STKFUL = u. MCLR during Power Managed Idle modes and Sleep mode, STKPTR Register.STKUNF",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n= u. WDTTime-out during Full Power or Power Managed Run modes, Program.Counter = 0000h. WDTTime-out during Full Power or Power Managed Run modes, RCON Register.SBOREN = u (2). WDTTime-out during Full Power or Power Managed Run modes, RCON Register.RI = u. WDTTime-out during Full Power or Power Managed Run modes, RCON Register.TO = 0. WDTTime-out during Full Power or Power Managed Run modes, RCON Register.PD = u. WDTTime-out during Full Power or Power Managed Run modes, RCON Register.POR = u. WDTTime-out during Full Power or Power Managed Run modes, RCON Register.BOR = u. WDTTime-out during Full Power or Power Managed Run modes, STKPTR Register.STKFUL = u. WDTTime-out during Full Power or Power Managed Run modes, STKPTR Register.STKUNF = u. MCLR during Full Power Execution, Program.Counter = 0000h. MCLR during Full Power",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nExecution, RCON Register.SBOREN = u (2). MCLR during Full Power Execution, RCON Register.RI = u. MCLR during Full Power Execution, RCON Register.TO = u. MCLR during Full Power Execution, RCON Register.PD = u. MCLR during Full Power Execution, RCON Register.POR = u. MCLR during Full Power Execution, RCON Register.BOR = u. MCLR during Full Power Execution, STKPTR Register.STKFUL = u. MCLR during Full Power Execution, STKPTR Register.STKUNF = u. Stack Full Reset (STVREN = 1 ), Program.Counter = 0000h. Stack Full Reset (STVREN = 1 ), RCON Register.SBOREN = u (2). Stack Full Reset (STVREN = 1 ), RCON Register.RI = u. Stack Full Reset (STVREN = 1 ), RCON Register.TO = u. Stack Full Reset (STVREN = 1 ), RCON Register.PD = u. Stack Full Reset (STVREN",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n= 1 ), RCON Register.POR = u. Stack Full Reset (STVREN = 1 ), RCON Register.BOR = u. Stack Full Reset (STVREN = 1 ), STKPTR Register.STKFUL = 1. Stack Full Reset (STVREN = 1 ), STKPTR Register.STKUNF = u. Stack Underflow Reset (STVREN = 1 ), Program.Counter = 0000h. Stack Underflow Reset (STVREN = 1 ), RCON Register.SBOREN = u (2). Stack Underflow Reset (STVREN = 1 ), RCON Register.RI = u. Stack Underflow Reset (STVREN = 1 ), RCON Register.TO = u. Stack Underflow Reset (STVREN = 1 ), RCON Register.PD = u. Stack Underflow Reset (STVREN = 1 ), RCON Register.POR = u. Stack Underflow Reset (STVREN = 1 ), RCON Register.BOR = u. Stack Underflow Reset (STVREN = 1 ),",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nSTKPTR Register.STKFUL = u. Stack Underflow Reset (STVREN = 1 ), STKPTR Register.STKUNF = 1. Stack Underflow Error (not an actual Reset, STVREN = 0 ), Program.Counter = 0000h. Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register.SBOREN = u (2). Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register.RI = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register.TO = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register.PD = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register.POR = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register.BOR = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ),",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nSTKPTR Register.STKFUL = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), STKPTR Register.STKUNF = 1. WDT Time-out during Power Managed Idle or Sleep modes, Program.Counter = PC + 2. WDT Time-out during Power Managed Idle or Sleep modes, RCON Register.SBOREN = u (2). WDT Time-out during Power Managed Idle or Sleep modes, RCON Register.RI = u. WDT Time-out during Power Managed Idle or Sleep modes, RCON Register.TO = 0. WDT Time-out during Power Managed Idle or Sleep modes, RCON Register.PD = 0. WDT Time-out during Power Managed Idle or Sleep modes, RCON Register.POR = u. WDT Time-out during Power Managed Idle or Sleep modes, RCON Register.BOR = u. WDT Time-out during Power Managed Idle or Sleep modes, STKPTR Register.STKFUL = u. WDT Time-out during Power Managed Idle or Sleep modes, STKPTR",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nRegister.STKUNF = u. Interrupt Exit from Power Managed modes, Program.Counter = PC + 2 (1). Interrupt Exit from Power Managed modes, RCON Register.SBOREN = u (2). Interrupt Exit from Power Managed modes, RCON Register.RI = u. Interrupt Exit from Power Managed modes, RCON Register.TO = u. Interrupt Exit from Power Managed modes, RCON Register.PD = 0. Interrupt Exit from Power Managed modes, RCON Register.POR = u. Interrupt Exit from Power Managed modes, RCON Register.BOR = u. Interrupt Exit from Power Managed modes, STKPTR Register.STKFUL = u. Interrupt Exit from Power Managed modes, STKPTR Register.STKUNF = u\nLegend:\nu = unchanged",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nNote 1: When the wake-up is due to an interrupt and the GIEH or GIEL bits are set, the PC is loaded with the interrupt vector (008h or 0018h).\n2: Reset state is ' 1 ' for POR and unchanged for all other Resets when software BOR is enabled (BOREN1:BOREN0 Configuration bits = 01 and SBOREN = 1 ); otherwise, the Reset state is ' 0 '.",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTOSU, Applicable Devices = 2585. TOSU, Applicable Devices = 2680. TOSU, Applicable Devices = 4585. TOSU, Applicable Devices = 4680. TOSU, Power-on Reset, Brown-out Reset = ---0 0000. TOSU, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ---0 0000. TOSU, Wake-up via WDT or Interrupt = ---0 uuuu (3). TOSH, Applicable Devices = 2585. TOSH, Applicable Devices = 2680. TOSH, Applicable Devices = 4585. TOSH, Applicable Devices = 4680. TOSH, Power-on Reset, Brown-out Reset = 0000 0000. TOSH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. TOSH, Wake-up via WDT or Interrupt = uuuu uuuu (3). TOSL, Applicable Devices = 2585. TOSL, Applicable Devices = 2680. TOSL, Applicable Devices = 4585. TOSL, Applicable Devices = 4680. TOSL, Power-on",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nReset, Brown-out Reset = 0000 0000. TOSL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. TOSL, Wake-up via WDT or Interrupt = uuuu uuuu (3). STKPTR, Applicable Devices = 2585. STKPTR, Applicable Devices = 2680. STKPTR, Applicable Devices = 4585. STKPTR, Applicable Devices = 4680. STKPTR, Power-on Reset, Brown-out Reset = 00-0 0000. STKPTR, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uu-0 0000. STKPTR, Wake-up via WDT or Interrupt = uu-u uuuu (3). PCLATU, Applicable Devices = 2585. PCLATU, Applicable Devices = 2680. PCLATU, Applicable Devices = 4585. PCLATU, Applicable Devices = 4680. PCLATU, Power-on Reset, Brown-out Reset = ---0 0000. PCLATU, MCLR Resets,",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nWDT Reset, RESET Instruction, Stack Resets = ---0 0000. PCLATU, Wake-up via WDT or Interrupt = ---u uuuu. PCLATH, Applicable Devices = 2585. PCLATH, Applicable Devices = 2680. PCLATH, Applicable Devices = 4585. PCLATH, Applicable Devices = 4680. PCLATH, Power-on Reset, Brown-out Reset = 0000 0000. PCLATH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. PCLATH, Wake-up via WDT or Interrupt = uuuu uuuu. PCL, Applicable Devices = 2585. PCL, Applicable Devices = 2680. PCL, Applicable Devices = 4585. PCL, Applicable Devices = 4680. PCL, Power-on Reset, Brown-out Reset = 0000 0000. PCL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. PCL, Wake-up via WDT or Interrupt = PC + 2 (2). TBLPTRU, Applicable Devices",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\n= 2585. TBLPTRU, Applicable Devices = 2680. TBLPTRU, Applicable Devices = 4585. TBLPTRU, Applicable Devices = 4680. TBLPTRU, Power-on Reset, Brown-out Reset = --00 0000. TBLPTRU, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = --00 0000. TBLPTRU, Wake-up via WDT or Interrupt = --uu uuuu. TBLPTRH, Applicable Devices = 2585. TBLPTRH, Applicable Devices = 2680. TBLPTRH, Applicable Devices = 4585. TBLPTRH, Applicable Devices = 4680. TBLPTRH, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. TBLPTRH, Wake-up via WDT or Interrupt = uuuu uuuu. TBLPTRL, Applicable Devices = 2585. TBLPTRL, Applicable Devices = 2680. TBLPTRL, Applicable Devices",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\n= 4585. TBLPTRL, Applicable Devices = 4680. TBLPTRL, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. TBLPTRL, Wake-up via WDT or Interrupt = uuuu uuuu. TABLAT, Applicable Devices = 2585. TABLAT, Applicable Devices = 2680. TABLAT, Applicable Devices = 4585. TABLAT, Applicable Devices = 4680. TABLAT, Power-on Reset, Brown-out Reset = 0000 0000. TABLAT, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. TABLAT, Wake-up via WDT or Interrupt = uuuu uuuu. PRODH, Applicable Devices = 2585. PRODH, Applicable Devices = 2680. PRODH, Applicable Devices = 4585. PRODH, Applicable Devices = 4680. PRODH, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODH, MCLR Resets, WDT Reset, RESET",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nInstruction, Stack Resets = uuuu uuuu. PRODH, Wake-up via WDT or Interrupt = uuuu uuuu. PRODL, Applicable Devices = 2585. PRODL, Applicable Devices = 2680. PRODL, Applicable Devices = 4585. PRODL, Applicable Devices = 4680. PRODL, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. PRODL, Wake-up via WDT or Interrupt = uuuu uuuu. INTCON, Applicable Devices = 2585. INTCON, Applicable Devices = 2680. INTCON, Applicable Devices = 4585. INTCON, Applicable Devices = 4680. INTCON, Power-on Reset, Brown-out Reset = 0000 000x. INTCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 000u. INTCON, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON2, Applicable Devices =",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\n2585. INTCON2, Applicable Devices = 2680. INTCON2, Applicable Devices = 4585. INTCON2, Applicable Devices = 4680. INTCON2, Power-on Reset, Brown-out Reset = 1111 -1-1. INTCON2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111 -1-1. INTCON2, Wake-up via WDT or Interrupt = uuuu -u-u (1). INTCON3, Applicable Devices = 2585. INTCON3, Applicable Devices = 2680. INTCON3, Applicable Devices = 4585. INTCON3, Applicable Devices = 4680. INTCON3, Power-on Reset, Brown-out Reset = 11-0 0-00. INTCON3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 11-0 0-00. INTCON3, Wake-up via WDT or Interrupt = uu-u u-uu (1). INDF0, Applicable Devices = 2585. INDF0, Applicable Devices = 2680. INDF0, Applicable Devices = 4585.",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nINDF0, Applicable Devices = 4680. INDF0, Power-on Reset, Brown-out Reset = N/A. INDF0, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. INDF0, Wake-up via WDT or Interrupt = N/A. POSTINC0, Applicable Devices = 2585. POSTINC0, Applicable Devices = 2680. POSTINC0, Applicable Devices = 4585. POSTINC0, Applicable Devices = 4680. POSTINC0, Power-on Reset, Brown-out Reset = N/A. POSTINC0, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. POSTINC0, Wake-up via WDT or Interrupt = N/A. POSTDEC0, Applicable Devices = 2585. POSTDEC0, Applicable Devices = 2680. POSTDEC0, Applicable Devices = 4585. POSTDEC0, Applicable Devices = 4680. POSTDEC0, Power-on Reset, Brown-out Reset = N/A. POSTDEC0, MCLR Resets, WDT",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nReset, RESET Instruction, Stack Resets = N/A. POSTDEC0, Wake-up via WDT or Interrupt = N/A. PREINC0, Applicable Devices = 2585. PREINC0, Applicable Devices = 2680. PREINC0, Applicable Devices = 4585. PREINC0, Applicable Devices = 4680. PREINC0, Power-on Reset, Brown-out Reset = N/A. PREINC0, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. PREINC0, Wake-up via WDT or Interrupt = N/A. PLUSW0, Applicable Devices = 2585. PLUSW0, Applicable Devices = 2680. PLUSW0, Applicable Devices = 4585. PLUSW0, Applicable Devices = 4680. PLUSW0, Power-on Reset, Brown-out Reset = N/A. PLUSW0, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. PLUSW0, Wake-up via WDT or Interrupt = N/A. FSR0H, Applicable Devices = 2585.",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nFSR0H, Applicable Devices = 2680. FSR0H, Applicable Devices = 4585. FSR0H, Applicable Devices = 4680. FSR0H, Power-on Reset, Brown-out Reset = ---- 0000. FSR0H, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ---- 0000. FSR0H, Wake-up via WDT or Interrupt = ---- uuuu. FSR0L, Applicable Devices = 2585. FSR0L, Applicable Devices = 2680. FSR0L, Applicable Devices = 4585. FSR0L, Applicable Devices = 4680. FSR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR0L, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. FSR0L, Wake-up via WDT or Interrupt = uuuu uuuu. WREG, Applicable Devices = 2585. WREG, Applicable Devices = 2680. WREG, Applicable Devices = 4585.",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nWREG, Applicable Devices = 4680. WREG, Power-on Reset, Brown-out Reset = xxxx xxxx. WREG, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. WREG, Wake-up via WDT or Interrupt = uuuu uuuu. INDF1, Applicable Devices = 2585. INDF1, Applicable Devices = 2680. INDF1, Applicable Devices = 4585. INDF1, Applicable Devices = 4680. INDF1, Power-on Reset, Brown-out Reset = N/A. INDF1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. INDF1, Wake-up via WDT or Interrupt = N/A. POSTINC1, Applicable Devices = 2585. POSTINC1, Applicable Devices = 2680. POSTINC1, Applicable Devices = 4585. POSTINC1, Applicable Devices = 4680. POSTINC1, Power-on Reset, Brown-out Reset = N/A. POSTINC1, MCLR Resets, WDT",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nReset, RESET Instruction, Stack Resets = N/A. POSTINC1, Wake-up via WDT or Interrupt = N/A. POSTDEC1, Applicable Devices = 2585. POSTDEC1, Applicable Devices = 2680. POSTDEC1, Applicable Devices = 4585. POSTDEC1, Applicable Devices = 4680. POSTDEC1, Power-on Reset, Brown-out Reset = N/A. POSTDEC1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. POSTDEC1, Wake-up via WDT or Interrupt = N/A. PREINC1, Applicable Devices = 2585. PREINC1, Applicable Devices = 2680. PREINC1, Applicable Devices = 4585. PREINC1, Applicable Devices = 4680. PREINC1, Power-on Reset, Brown-out Reset = N/A. PREINC1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. PREINC1, Wake-up via WDT or Interrupt = N/A. PLUSW1, Applicable Devices =",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\n2585. PLUSW1, Applicable Devices = 2680. PLUSW1, Applicable Devices = 4585. PLUSW1, Applicable Devices = 4680. PLUSW1, Power-on Reset, Brown-out Reset = N/A. PLUSW1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. PLUSW1, Wake-up via WDT or Interrupt = N/A. FSR1L, Applicable Devices = 2585. FSR1L, Applicable Devices = 2680. FSR1L, Applicable Devices = 4585. FSR1L, Applicable Devices = 4680. FSR1L, Power-on Reset, Brown-out Reset = . FSR1L, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. FSR1L, Wake-up via WDT or Interrupt = uuuu uuuu. FSR1H, Applicable Devices = 2585. FSR1H, Applicable Devices = 2680. FSR1H, Applicable Devices = 4585. FSR1H, Applicable Devices = 4680.",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nFSR1H, Power-on Reset, Brown-out Reset = ---- 0000 xxxx xxxx. FSR1H, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ---- 0000. FSR1H, Wake-up via WDT or Interrupt = ---- uuuu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBSR, Applicable Devices = 2585. BSR, Applicable Devices = 2680. BSR, Applicable Devices = 4585. BSR, Applicable Devices = 4680. BSR, Power-on Reset, Brown-out Reset = ---- 0000. BSR, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ---- 0000. BSR, Wake-up via WDT or Interrupt = ---- uuuu. INDF2, Applicable Devices = 2585. INDF2, Applicable Devices = 2680. INDF2, Applicable Devices = 4585. INDF2, Applicable Devices = 4680. INDF2, Power-on Reset, Brown-out Reset = N/A. INDF2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. INDF2, Wake-up via WDT or Interrupt = N/A. POSTINC2, Applicable Devices = 2585. POSTINC2, Applicable Devices = 2680. POSTINC2, Applicable Devices = 4585. POSTINC2, Applicable Devices",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 4680. POSTINC2, Power-on Reset, Brown-out Reset = N/A. POSTINC2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. POSTINC2, Wake-up via WDT or Interrupt = N/A. POSTDEC2, Applicable Devices = 2585. POSTDEC2, Applicable Devices = 2680. POSTDEC2, Applicable Devices = 4585. POSTDEC2, Applicable Devices = 4680. POSTDEC2, Power-on Reset, Brown-out Reset = N/A. POSTDEC2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. POSTDEC2, Wake-up via WDT or Interrupt = N/A. PREINC2, Applicable Devices = 2585. PREINC2, Applicable Devices = 2680. PREINC2, Applicable Devices = 4585. PREINC2, Applicable Devices = 4680. PREINC2, Power-on Reset, Brown-out Reset = N/A. PREINC2, MCLR",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets, WDT Reset, RESET Instruction, Stack Resets = N/A. PREINC2, Wake-up via WDT or Interrupt = N/A. PLUSW2, Applicable Devices = 2585. PLUSW2, Applicable Devices = 2680. PLUSW2, Applicable Devices = 4585. PLUSW2, Applicable Devices = 4680. PLUSW2, Power-on Reset, Brown-out Reset = N/A. PLUSW2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = N/A. PLUSW2, Wake-up via WDT or Interrupt = N/A. FSR2H, Applicable Devices = 2585. FSR2H, Applicable Devices = 2680. FSR2H, Applicable Devices = 4585. FSR2H, Applicable Devices = 4680. FSR2H, Power-on Reset, Brown-out Reset = ---- 0000. FSR2H, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ---- 0000. FSR2H, Wake-up via WDT or Interrupt",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= ---- uuuu. FSR2L, Applicable Devices = 2585. FSR2L, Applicable Devices = 2680. FSR2L, Applicable Devices = 4585. FSR2L, Applicable Devices = 4680. FSR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR2L, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. FSR2L, Wake-up via WDT or Interrupt = uuuu uuuu. STATUS, Applicable Devices = 2585. STATUS, Applicable Devices = 2680. STATUS, Applicable Devices = 4585. STATUS, Applicable Devices = 4680. STATUS, Power-on Reset, Brown-out Reset = ---x xxxx. STATUS, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ---u uuuu. STATUS, Wake-up via WDT or Interrupt = ---u uuuu. TMR0H, Applicable Devices = 2585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR0H, Applicable Devices = 2680. TMR0H, Applicable Devices = 4585. TMR0H, Applicable Devices = 4680. TMR0H, Power-on Reset, Brown-out Reset = 0000 0000. TMR0H, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. TMR0H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR0L, Applicable Devices = 2585. TMR0L, Applicable Devices = 2680. TMR0L, Applicable Devices = 4585. TMR0L, Applicable Devices = 4680. TMR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR0L, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TMR0L, Wake-up via WDT or Interrupt = uuuu uuuu. T0CON, Applicable Devices = 2585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nT0CON, Applicable Devices = 2680. T0CON, Applicable Devices = 4585. T0CON, Applicable Devices = 4680. T0CON, Power-on Reset, Brown-out Reset = 1111 1111. T0CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111 1111. T0CON, Wake-up via WDT or Interrupt = uuuu uuuu. OSCCON, Applicable Devices = 2585. OSCCON, Applicable Devices = 2680. OSCCON, Applicable Devices = 4585. OSCCON, Applicable Devices = 4680. OSCCON, Power-on Reset, Brown-out Reset = 0100 q000. OSCCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0100 00q0. OSCCON, Wake-up via WDT or Interrupt = uuuu uuqu. HLVDCON, Applicable Devices = 2585. HLVDCON, Applicable Devices = 2680. HLVDCON, Applicable Devices = 4585. HLVDCON, Applicable",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = 4680. HLVDCON, Power-on Reset, Brown-out Reset = 0-00 0101. HLVDCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0-00 0101. HLVDCON, Wake-up via WDT or Interrupt = 0-uu uuuu. WDTCON, Applicable Devices = 2585. WDTCON, Applicable Devices = 2680. WDTCON, Applicable Devices = 4585. WDTCON, Applicable Devices = 4680. WDTCON, Power-on Reset, Brown-out Reset = ---- ---0. WDTCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ---- ---0. WDTCON, Wake-up via WDT or Interrupt = ---- ---u. RCON (4), Applicable Devices = 2585. RCON (4), Applicable Devices = 2680. RCON (4), Applicable Devices = 4585. RCON (4), Applicable Devices = 4680. RCON",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(4), Power-on Reset, Brown-out Reset = 0q-1 11q0. RCON (4), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0q-q qquu. RCON (4), Wake-up via WDT or Interrupt = uq-u qquu. TMR1H, Applicable Devices = 2585. TMR1H, Applicable Devices = 2680. TMR1H, Applicable Devices = 4585. TMR1H, Applicable Devices = 4680. TMR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1H, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TMR1H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR1L, Applicable Devices = 2585. TMR1L, Applicable Devices = 2680. TMR1L, Applicable Devices = 4585. TMR1L, Applicable",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = 4680. TMR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1L, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TMR1L, Wake-up via WDT or Interrupt = uuuu uuuu. T1CON, Applicable Devices = 2585. T1CON, Applicable Devices = 2680. T1CON, Applicable Devices = 4585. T1CON, Applicable Devices = 4680. T1CON, Power-on Reset, Brown-out Reset = 0000 0000. T1CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = u0uu uuuu. T1CON, Wake-up via WDT or Interrupt = uuuu uuuu. TMR2, Applicable Devices = 2585. TMR2, Applicable Devices = 2680. TMR2, Applicable Devices = 4585. TMR2, Applicable Devices = 4680. TMR2,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = 0000 0000. TMR2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. TMR2, Wake-up via WDT or Interrupt = uuuu uuuu. PR2, Applicable Devices = 2585. PR2, Applicable Devices = 2680. PR2, Applicable Devices = 4585. PR2, Applicable Devices = 4680. PR2, Power-on Reset, Brown-out Reset = 1111 1111. PR2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111 1111. PR2, Wake-up via WDT or Interrupt = 1111 1111. T2CON, Applicable Devices = 2585. T2CON, Applicable Devices = 2680. T2CON, Applicable Devices = 4585. T2CON, Applicable Devices = 4680. T2CON, Power-on Reset, Brown-out Reset = -000 0000. T2CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -000",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000. T2CON, Wake-up via WDT or Interrupt = -uuu uuuu. SSPBUF, Applicable Devices = 2585. SSPBUF, Applicable Devices = 2680. SSPBUF, Applicable Devices = 4585. SSPBUF, Applicable Devices = 4680. SSPBUF, Power-on Reset, Brown-out Reset = xxxx xxxx. SSPBUF, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. SSPBUF, Wake-up via WDT or Interrupt = uuuu uuuu. SSPADD, Applicable Devices = 2585. SSPADD, Applicable Devices = 2680. SSPADD, Applicable Devices = 4585. SSPADD, Applicable Devices = 4680. SSPADD, Power-on Reset, Brown-out Reset = 0000 0000. SSPADD, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. SSPADD, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. SSPSTAT, Applicable Devices = 2585. SSPSTAT, Applicable Devices = 2680. SSPSTAT, Applicable Devices = 4585. SSPSTAT, Applicable Devices = 4680. SSPSTAT, Power-on Reset, Brown-out Reset = 0000 0000. SSPSTAT, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. SSPSTAT, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON1, Applicable Devices = 2585. SSPCON1, Applicable Devices = 2680. SSPCON1, Applicable Devices = 4585. SSPCON1, Applicable Devices = 4680. SSPCON1, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. SSPCON1, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON2, Applicable Devices = 2585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nSSPCON2, Applicable Devices = 2680. SSPCON2, Applicable Devices = 4585. SSPCON2, Applicable Devices = 4680. SSPCON2, Power-on Reset, Brown-out Reset = . SSPCON2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. SSPCON2, Wake-up via WDT or Interrupt = uuuu uuuu. , Applicable Devices = . , Applicable Devices = . , Applicable Devices = . , Applicable Devices = . , Power-on Reset, Brown-out Reset = 0000 0000. , MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . , Wake-up via WDT or Interrupt = . ADRESH, Applicable Devices = 2585. ADRESH, Applicable Devices = 2680. ADRESH, Applicable Devices = 4585. ADRESH, Applicable Devices = 4680. ADRESH, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. ADRESH, Wake-up via WDT or Interrupt = uuuu uuuu. ADRESL, Applicable Devices = 2585. ADRESL, Applicable Devices = 2680. ADRESL, Applicable Devices = 4585. ADRESL, Applicable Devices = 4680. ADRESL, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. ADRESL, Wake-up via WDT or Interrupt = uuuu uuuu. ADCON0 ADCON1, Applicable Devices = 2585. ADCON0 ADCON1, Applicable Devices = 2680 2680. ADCON0 ADCON1, Applicable Devices = 4585 4585. ADCON0 ADCON1, Applicable Devices = 4680 4680. ADCON0 ADCON1, Power-on Reset, Brown-out Reset = --00 0000. ADCON0 ADCON1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n--00 0000. ADCON0 ADCON1, Wake-up via WDT or Interrupt = --uu uuuu u-uu uuuu. ADCON2, Applicable Devices = 2585 2585. ADCON2, Applicable Devices = 2680. ADCON2, Applicable Devices = 4585. ADCON2, Applicable Devices = 4680. ADCON2, Power-on Reset, Brown-out Reset = --00 0qqq 0-00 0000. ADCON2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = --00 0qqq 0-00 0000. ADCON2, Wake-up via WDT or Interrupt = --uu uuuu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCCPR1H, Applicable Devices = 2585. CCPR1H, Applicable Devices = 2680. CCPR1H, Applicable Devices = 4585. CCPR1H, Applicable Devices = 4680. CCPR1H, Power-on Reset, Brown-out Reset = xxxx. CCPR1H, Power-on Reset, Brown-out Reset = xxxx. CCPR1H, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. CCPR1H, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. CCPR1H, Wake-up via WDT or Interrupt = uuuu. CCPR1H, Wake-up via WDT or Interrupt = uuuu. CCPR1L, Applicable Devices = 2585. CCPR1L, Applicable Devices = 2680. CCPR1L, Applicable Devices = 4585. CCPR1L, Applicable Devices = 4680. CCPR1L, Power-on Reset, Brown-out Reset = xxxx. CCPR1L, Power-on Reset,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = xxxx. CCPR1L, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. CCPR1L, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. CCPR1L, Wake-up via WDT or Interrupt = uuuu. CCPR1L, Wake-up via WDT or Interrupt = uuuu. CCP1CON, Applicable Devices = 2585. CCP1CON, Applicable Devices = 2680. CCP1CON, Applicable Devices = 4585. CCP1CON, Applicable Devices = 4680. CCP1CON, Power-on Reset, Brown-out Reset = --00. CCP1CON, Power-on Reset, Brown-out Reset = 0000. CCP1CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = --00. CCP1CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. CCP1CON, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n--uu. CCP1CON, Wake-up via WDT or Interrupt = uuuu. ECCPR1H, Applicable Devices = 2585. ECCPR1H, Applicable Devices = 2680. ECCPR1H, Applicable Devices = 4585. ECCPR1H, Applicable Devices = 4680. ECCPR1H, Power-on Reset, Brown-out Reset = xxxx. ECCPR1H, Power-on Reset, Brown-out Reset = xxxx. ECCPR1H, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. ECCPR1H, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. ECCPR1H, Wake-up via WDT or Interrupt = uuuu. ECCPR1H, Wake-up via WDT or Interrupt = uuuu. ECCPR1L, Applicable Devices = 2585. ECCPR1L, Applicable Devices = 2680. ECCPR1L, Applicable Devices = 4585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nECCPR1L, Applicable Devices = 4680. ECCPR1L, Power-on Reset, Brown-out Reset = xxxx. ECCPR1L, Power-on Reset, Brown-out Reset = xxxx. ECCPR1L, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. ECCPR1L, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. ECCPR1L, Wake-up via WDT or Interrupt = uuuu. ECCPR1L, Wake-up via WDT or Interrupt = uuuu. ECCP1CON, Applicable Devices = 2585. ECCP1CON, Applicable Devices = 2680. ECCP1CON, Applicable Devices = 4585. ECCP1CON, Applicable Devices = 4680. ECCP1CON, Power-on Reset, Brown-out Reset = 0000. ECCP1CON, Power-on Reset, Brown-out Reset = 0000. ECCP1CON, MCLR Resets, WDT Reset, RESET Instruction, Stack",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = 0000. ECCP1CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. ECCP1CON, Wake-up via WDT or Interrupt = uuuu. ECCP1CON, Wake-up via WDT or Interrupt = uuuu. BAUDCON, Applicable Devices = 2585. BAUDCON, Applicable Devices = 2680. BAUDCON, Applicable Devices = 4585. BAUDCON, Applicable Devices = 4680. BAUDCON, Power-on Reset, Brown-out Reset = 01-0. BAUDCON, Power-on Reset, Brown-out Reset = 0-00. BAUDCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 01-0. BAUDCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0-00. BAUDCON, Wake-up via WDT or Interrupt = --uu. BAUDCON, Wake-up via WDT or Interrupt = uuuu. ECCP1DEL, Applicable Devices = 2585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nECCP1DEL, Applicable Devices = 2680. ECCP1DEL, Applicable Devices = 4585. ECCP1DEL, Applicable Devices = 4680. ECCP1DEL, Power-on Reset, Brown-out Reset = 0000. ECCP1DEL, Power-on Reset, Brown-out Reset = 0000. ECCP1DEL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. ECCP1DEL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. ECCP1DEL, Wake-up via WDT or Interrupt = uuuu. ECCP1DEL, Wake-up via WDT or Interrupt = uuuu. ECCP1AS, Applicable Devices = 2585. ECCP1AS, Applicable Devices = 2680. ECCP1AS, Applicable Devices = 4585. ECCP1AS, Applicable Devices = 4680. ECCP1AS, Power-on Reset, Brown-out Reset = 0000. ECCP1AS, Power-on Reset, Brown-out Reset = 0000. ECCP1AS, MCLR",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets, WDT Reset, RESET Instruction, Stack Resets = 0000. ECCP1AS, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. ECCP1AS, Wake-up via WDT or Interrupt = uuuu. ECCP1AS, Wake-up via WDT or Interrupt = uuuu. CVRCON, Applicable Devices = 2585. CVRCON, Applicable Devices = 2680. CVRCON, Applicable Devices = 4585. CVRCON, Applicable Devices = 4680. CVRCON, Power-on Reset, Brown-out Reset = 0000. CVRCON, Power-on Reset, Brown-out Reset = 0000. CVRCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. CVRCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. CVRCON, Wake-up via WDT or Interrupt = uuuu. CVRCON, Wake-up via WDT or Interrupt = uuuu. CMCON, Applicable Devices =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n2585. CMCON, Applicable Devices = 2680. CMCON, Applicable Devices = 4585. CMCON, Applicable Devices = 4680. CMCON, Power-on Reset, Brown-out Reset = 0000. CMCON, Power-on Reset, Brown-out Reset = 0111. CMCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. CMCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0111. CMCON, Wake-up via WDT or Interrupt = uuuu. CMCON, Wake-up via WDT or Interrupt = uuuu. TMR3H, Applicable Devices = 2585. TMR3H, Applicable Devices = 2680. TMR3H, Applicable Devices = 4585. TMR3H, Applicable Devices = 4680. TMR3H, Power-on Reset, Brown-out Reset = xxxx. TMR3H, Power-on Reset, Brown-out Reset = xxxx. TMR3H, MCLR Resets, WDT Reset, RESET",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInstruction, Stack Resets = uuuu. TMR3H, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. TMR3H, Wake-up via WDT or Interrupt = uuuu. TMR3H, Wake-up via WDT or Interrupt = uuuu. TMR3L, Applicable Devices = 2585. TMR3L, Applicable Devices = 2680. TMR3L, Applicable Devices = 4585. TMR3L, Applicable Devices = 4680. TMR3L, Power-on Reset, Brown-out Reset = xxxx. TMR3L, Power-on Reset, Brown-out Reset = xxxx. TMR3L, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. TMR3L, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. TMR3L, Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR3L, Wake-up via WDT or Interrupt = uuuu. T3CON, Applicable Devices = 2585. T3CON, Applicable Devices = 2680. T3CON, Applicable Devices = 4585. T3CON, Applicable Devices = 4680. T3CON, Power-on Reset, Brown-out Reset = 0000. T3CON, Power-on Reset, Brown-out Reset = 0000. T3CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. T3CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. T3CON, Wake-up via WDT or Interrupt = uuuu. T3CON, Wake-up via WDT or Interrupt = uuuu. SPBRGH, Applicable Devices = 2585. SPBRGH, Applicable Devices = 2680. SPBRGH, Applicable Devices = 4585. SPBRGH, Applicable Devices = 4680. SPBRGH, Power-on Reset, Brown-out Reset = 0000. SPBRGH,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = 0000. SPBRGH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. SPBRGH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. SPBRGH, Wake-up via WDT or Interrupt = uuuu. SPBRGH, Wake-up via WDT or Interrupt = uuuu. SPBRG, Applicable Devices = 2585. SPBRG, Applicable Devices = 2680. SPBRG, Applicable Devices = 4585. SPBRG, Applicable Devices = 4680. SPBRG, Power-on Reset, Brown-out Reset = 0000. SPBRG, Power-on Reset, Brown-out Reset = 0000. SPBRG, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. SPBRG, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. SPBRG, Wake-up via WDT or Interrupt = uuuu. SPBRG, Wake-up via",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu. RCREG, Applicable Devices = 2585. RCREG, Applicable Devices = 2680. RCREG, Applicable Devices = 4585. RCREG, Applicable Devices = 4680. RCREG, Power-on Reset, Brown-out Reset = 0000. RCREG, Power-on Reset, Brown-out Reset = 0000. RCREG, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. RCREG, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. RCREG, Wake-up via WDT or Interrupt = uuuu. RCREG, Wake-up via WDT or Interrupt = uuuu. TXREG, Applicable Devices = 2585. TXREG, Applicable Devices = 2680. TXREG, Applicable Devices = 4585. TXREG, Applicable Devices = 4680. TXREG, Power-on Reset, Brown-out Reset = 0000. TXREG, Power-on Reset, Brown-out Reset = 0000.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXREG, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. TXREG, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. TXREG, Wake-up via WDT or Interrupt = uuuu. TXREG, Wake-up via WDT or Interrupt = uuuu. TXSTA, Applicable Devices = 2585. TXSTA, Applicable Devices = 2680. TXSTA, Applicable Devices = 4585. TXSTA, Applicable Devices = 4680. TXSTA, Power-on Reset, Brown-out Reset = 0000. TXSTA, Power-on Reset, Brown-out Reset = 0010. TXSTA, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. TXSTA, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0010. TXSTA, Wake-up via WDT or Interrupt = uuuu. TXSTA, Wake-up via WDT or Interrupt = uuuu. RCSTA, Applicable Devices = 2585. RCSTA, Applicable Devices",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 2680. RCSTA, Applicable Devices = 4585. RCSTA, Applicable Devices = 4680. RCSTA, Power-on Reset, Brown-out Reset = 0000. RCSTA, Power-on Reset, Brown-out Reset = 000x. RCSTA, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. RCSTA, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 000x. RCSTA, Wake-up via WDT or Interrupt = uuuu. RCSTA, Wake-up via WDT or Interrupt = uuuu. EEADRH, Applicable Devices = 2585. EEADRH, Applicable Devices = 2680. EEADRH, Applicable Devices = 4585. EEADRH, Applicable Devices = 4680. EEADRH, Power-on Reset, Brown-out Reset = ----. EEADRH, Power-on Reset, Brown-out Reset = --00. EEADRH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ----. EEADRH, MCLR",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets, WDT Reset, RESET Instruction, Stack Resets = --00. EEADRH, Wake-up via WDT or Interrupt = ----. EEADRH, Wake-up via WDT or Interrupt = --uu. EEADR, Applicable Devices = 2585. EEADR, Applicable Devices = 2680. EEADR, Applicable Devices = 4585. EEADR, Applicable Devices = 4680. EEADR, Power-on Reset, Brown-out Reset = 0000. EEADR, Power-on Reset, Brown-out Reset = 0000. EEADR, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. EEADR, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. EEADR, Wake-up via WDT or Interrupt = uuuu. EEADR, Wake-up via WDT or Interrupt = uuuu. EEDATA, Applicable Devices = 2585. EEDATA, Applicable Devices = 2680. EEDATA, Applicable Devices = 4585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nEEDATA, Applicable Devices = 4680. EEDATA, Power-on Reset, Brown-out Reset = 0000. EEDATA, Power-on Reset, Brown-out Reset = 0000. EEDATA, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. EEDATA, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. EEDATA, Wake-up via WDT or Interrupt = uuuu. EEDATA, Wake-up via WDT or Interrupt = uuuu. EECON2, Applicable Devices = 2585. EECON2, Applicable Devices = 2680. EECON2, Applicable Devices = 4585. EECON2, Applicable Devices = 4680. EECON2, Power-on Reset, Brown-out Reset = 0000. EECON2, Power-on Reset, Brown-out Reset = 0000. EECON2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. EECON2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 0000. EECON2, Wake-up via WDT or Interrupt = 0000. EECON2, Wake-up via WDT or Interrupt = 0000. EECON1, Applicable Devices = 2585. EECON1, Applicable Devices = 2680. EECON1, Applicable Devices = 4585. EECON1, Applicable Devices = 4680. EECON1, Power-on Reset, Brown-out Reset = xx-0. EECON1, Power-on Reset, Brown-out Reset = x000. EECON1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uu-0. EECON1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = u000. EECON1, Wake-up via WDT or Interrupt = uu-0. EECON1, Wake-up via WDT or Interrupt = u000. IPR3, Applicable Devices = 2585. IPR3, Applicable Devices = 2680. IPR3, Applicable Devices = 4585. IPR3, Applicable Devices = 4680. IPR3,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = 1111. IPR3, Power-on Reset, Brown-out Reset = 1111. IPR3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. IPR3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. IPR3, Wake-up via WDT or Interrupt = uuuu. IPR3, Wake-up via WDT or Interrupt = uuuu. PIR3, Applicable Devices = 2585. PIR3, Applicable Devices = 2680. PIR3, Applicable Devices = 4585. PIR3, Applicable Devices = 4680. PIR3, Power-on Reset, Brown-out Reset = 0000. PIR3, Power-on Reset, Brown-out Reset = 0000. PIR3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. PIR3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. PIR3, Wake-up via WDT",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nor Interrupt = uuuu. PIR3, Wake-up via WDT or Interrupt = uuuu. PIE3, Applicable Devices = 2585. PIE3, Applicable Devices = 2680. PIE3, Applicable Devices = 4585. PIE3, Applicable Devices = 4680. PIE3, Power-on Reset, Brown-out Reset = 0000. PIE3, Power-on Reset, Brown-out Reset = 0000. PIE3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. PIE3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. PIE3, Wake-up via WDT or Interrupt = uuuu. PIE3, Wake-up via WDT or Interrupt = uuuu. IPR2, Applicable Devices = 2585. IPR2, Applicable Devices = 2680. IPR2, Applicable Devices = 4585. IPR2, Applicable Devices = 4680. IPR2, Power-on Reset, Brown-out Reset = 11-1. IPR2, Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset = 1111. IPR2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 11-1. IPR2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. IPR2, Wake-up via WDT or Interrupt = uu-u. IPR2, Wake-up via WDT or Interrupt = uuuu. , Applicable Devices = 2585. , Applicable Devices = 2680. , Applicable Devices = 4585. , Applicable Devices = 4680. , Power-on Reset, Brown-out Reset = 1--1. , Power-on Reset, Brown-out Reset = 111-. , MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1--1. , MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 111-. , Wake-up via WDT or Interrupt = u--u. , Wake-up via WDT or Interrupt = uuu-. PIR2, Applicable Devices = 2585. PIR2, Applicable Devices = 2680. PIR2,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = 4585. PIR2, Applicable Devices = 4680. PIR2, Power-on Reset, Brown-out Reset = 00-0. PIR2, Power-on Reset, Brown-out Reset = 0000. PIR2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 00-0. PIR2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. PIR2, Wake-up via WDT or Interrupt = uu-u. PIR2, Wake-up via WDT or Interrupt = uuuu (1). , Applicable Devices = 2585. , Applicable Devices = 2680. , Applicable Devices = 4585. , Applicable Devices = 4680. , Power-on Reset, Brown-out Reset = 0--0. , Power-on Reset, Brown-out Reset = 000-. , MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0--0. , MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 000-. , Wake-up via",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = u--u. , Wake-up via WDT or Interrupt = uuu- (1)\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.\nNote",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIE2, Applicable Devices = 2585. PIE2, Applicable Devices = 2680. PIE2, Applicable Devices = 4585. PIE2, Applicable Devices = 4680. PIE2, Power-on Reset, Brown-out Reset = 00-0. PIE2, Power-on Reset, Brown-out Reset = 0000. PIE2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 00-0. PIE2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. PIE2, Wake-up via WDT or Interrupt = uu-u. PIE2, Wake-up via WDT or Interrupt = uuuu. PIE2, Applicable Devices = 2585. PIE2, Applicable Devices = 2680. PIE2, Applicable Devices = 4585. PIE2, Applicable Devices = 4680. PIE2, Power-on Reset, Brown-out Reset = 0--0. PIE2, Power-on Reset, Brown-out Reset = 000-. PIE2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0--0.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIE2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 000-. PIE2, Wake-up via WDT or Interrupt = u--u. PIE2, Wake-up via WDT or Interrupt = uuu-. IPR1, Applicable Devices = 2585. IPR1, Applicable Devices = 2680. IPR1, Applicable Devices = 4585. IPR1, Applicable Devices = 4680. IPR1, Power-on Reset, Brown-out Reset = 1111. IPR1, Power-on Reset, Brown-out Reset = 1111. IPR1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. IPR1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. IPR1, Wake-up via WDT or Interrupt = uuuu. IPR1, Wake-up via WDT or Interrupt = uuuu. IPR1, Applicable Devices = 2585. IPR1, Applicable Devices = 2680. IPR1, Applicable Devices = 4585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nIPR1, Applicable Devices = 4680. IPR1, Power-on Reset, Brown-out Reset = -111. IPR1, Power-on Reset, Brown-out Reset = 1111. IPR1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -111. IPR1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. IPR1, Wake-up via WDT or Interrupt = -uuu. IPR1, Wake-up via WDT or Interrupt = uuuu. PIR1, Applicable Devices = 2585. PIR1, Applicable Devices = 2680. PIR1, Applicable Devices = 4585. PIR1, Applicable Devices = 4680. PIR1, Power-on Reset, Brown-out Reset = 0000. PIR1, Power-on Reset, Brown-out Reset = 0000. PIR1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. PIR1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 0000. PIR1, Wake-up via WDT or Interrupt = uuuu. PIR1, Wake-up via WDT or Interrupt = uuuu (1). PIR1, Applicable Devices = 2585. PIR1, Applicable Devices = 2680. PIR1, Applicable Devices = 4585. PIR1, Applicable Devices = 4680. PIR1, Power-on Reset, Brown-out Reset = -000. PIR1, Power-on Reset, Brown-out Reset = 0000. PIR1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -000. PIR1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. PIR1, Wake-up via WDT or Interrupt = -uuu. PIR1, Wake-up via WDT or Interrupt = uuuu. PIE1, Applicable Devices = 2585. PIE1, Applicable Devices = 2680. PIE1, Applicable Devices = 4585. PIE1, Applicable Devices = 4680. PIE1, Power-on",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset = 0000. PIE1, Power-on Reset, Brown-out Reset = 0000. PIE1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. PIE1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. PIE1, Wake-up via WDT or Interrupt = uuuu. PIE1, Wake-up via WDT or Interrupt = uuuu. PIE1, Applicable Devices = 2585. PIE1, Applicable Devices = 2680. PIE1, Applicable Devices = 4585. PIE1, Applicable Devices = 4680. PIE1, Power-on Reset, Brown-out Reset = -000. PIE1, Power-on Reset, Brown-out Reset = 0000. PIE1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -000. PIE1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. PIE1, Wake-up via WDT or Interrupt = -uuu. PIE1, Wake-up via WDT",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nor Interrupt = uuuu. OSCTUNE, Applicable Devices = 2585. OSCTUNE, Applicable Devices = 2680. OSCTUNE, Applicable Devices = 4585. OSCTUNE, Applicable Devices = 4680. OSCTUNE, Power-on Reset, Brown-out Reset = --00. OSCTUNE, Power-on Reset, Brown-out Reset = 0000. OSCTUNE, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = --00. OSCTUNE, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. OSCTUNE, Wake-up via WDT or Interrupt = --uu. OSCTUNE, Wake-up via WDT or Interrupt = uuuu. TRISE, Applicable Devices = 2585. TRISE, Applicable Devices = 2680. TRISE, Applicable Devices = 4585. TRISE, Applicable Devices = 4680. TRISE, Power-on Reset, Brown-out Reset = 0000. TRISE, Power-on Reset, Brown-out Reset = -111. TRISE, MCLR Resets,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset, RESET Instruction, Stack Resets = 0000. TRISE, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -111. TRISE, Wake-up via WDT or Interrupt = uuuu. TRISE, Wake-up via WDT or Interrupt = -uuu. TRISD, Applicable Devices = 2585. TRISD, Applicable Devices = 2680. TRISD, Applicable Devices = 4585. TRISD, Applicable Devices = 4680. TRISD, Power-on Reset, Brown-out Reset = 1111. TRISD, Power-on Reset, Brown-out Reset = 1111. TRISD, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. TRISD, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. TRISD, Wake-up via WDT or Interrupt = uuuu. TRISD, Wake-up via WDT or Interrupt = uuuu. TRISC, Applicable Devices = 2585. TRISC, Applicable Devices = 2680. TRISC, Applicable Devices =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n4585. TRISC, Applicable Devices = 4680. TRISC, Power-on Reset, Brown-out Reset = 1111. TRISC, Power-on Reset, Brown-out Reset = 1111. TRISC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. TRISC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. TRISC, Wake-up via WDT or Interrupt = uuuu. TRISC, Wake-up via WDT or Interrupt = uuuu. TRISB, Applicable Devices = 2585. TRISB, Applicable Devices = 2680. TRISB, Applicable Devices = 4585. TRISB, Applicable Devices = 4680. TRISB, Power-on Reset, Brown-out Reset = 1111. TRISB, Power-on Reset, Brown-out Reset = 1111. TRISB, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. TRISB, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. TRISB, Wake-up via",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu. TRISB, Wake-up via WDT or Interrupt = uuuu. TRISA (5), Applicable Devices = 2585. TRISA (5), Applicable Devices = 2680. TRISA (5), Applicable Devices = 4585. TRISA (5), Applicable Devices = 4680. TRISA (5), Power-on Reset, Brown-out Reset = 1111. TRISA (5), Power-on Reset, Brown-out Reset = 1111 (5). TRISA (5), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111. TRISA (5), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1111 (5). TRISA (5), Wake-up via WDT or Interrupt = uuuu. TRISA (5), Wake-up via WDT or Interrupt = uuuu (5). LATE, Applicable Devices = 2585. LATE, Applicable Devices = 2680. LATE, Applicable Devices = 4585. LATE, Applicable Devices =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n4680. LATE, Power-on Reset, Brown-out Reset = ----. LATE, Power-on Reset, Brown-out Reset = -xxx. LATE, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ----. LATE, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -uuu. LATE, Wake-up via WDT or Interrupt = ----. LATE, Wake-up via WDT or Interrupt = -uuu. LATD, Applicable Devices = 2585. LATD, Applicable Devices = 2680. LATD, Applicable Devices = 4585. LATD, Applicable Devices = 4680. LATD, Power-on Reset, Brown-out Reset = xxxx. LATD, Power-on Reset, Brown-out Reset = xxxx. LATD, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. LATD, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. LATD,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu. LATD, Wake-up via WDT or Interrupt = uuuu. LATC, Applicable Devices = 2585. LATC, Applicable Devices = 2680. LATC, Applicable Devices = 4585. LATC, Applicable Devices = 4680. LATC, Power-on Reset, Brown-out Reset = xxxx. LATC, Power-on Reset, Brown-out Reset = xxxx. LATC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. LATC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. LATC, Wake-up via WDT or Interrupt = uuuu. LATC, Wake-up via WDT or Interrupt = uuuu. LATB, Applicable Devices = 2585. LATB, Applicable Devices = 2680. LATB, Applicable Devices = 4585. LATB, Applicable Devices = 4680. LATB, Power-on Reset, Brown-out Reset = xxxx.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLATB, Power-on Reset, Brown-out Reset = xxxx. LATB, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. LATB, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. LATB, Wake-up via WDT or Interrupt = uuuu. LATB, Wake-up via WDT or Interrupt = uuuu. LATA (5), Applicable Devices = 2585. LATA (5), Applicable Devices = 2680. LATA (5), Applicable Devices = 4585. LATA (5), Applicable Devices = 4680. LATA (5), Power-on Reset, Brown-out Reset = xxxx. LATA (5), Power-on Reset, Brown-out Reset = xxxx (5). LATA (5), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. LATA (5), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu (5). LATA (5), Wake-up via WDT or Interrupt = uuuu. LATA (5), Wake-up via WDT or Interrupt = uuuu (5). PORTE, Applicable Devices = 2585. PORTE, Applicable Devices = 2680. PORTE, Applicable Devices = 4585. PORTE, Applicable Devices = 4680. PORTE, Power-on Reset, Brown-out Reset = ----. PORTE, Power-on Reset, Brown-out Reset = x000. PORTE, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ----. PORTE, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = x000. PORTE, Wake-up via WDT or Interrupt = ----. PORTE, Wake-up via WDT or Interrupt = uuuu. PORTD, Applicable Devices = 2585. PORTD, Applicable Devices = 2680. PORTD, Applicable Devices = 4585. PORTD, Applicable Devices = 4680. PORTD, Power-on Reset, Brown-out Reset =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nxxxx. PORTD, Power-on Reset, Brown-out Reset = xxxx. PORTD, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. PORTD, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. PORTD, Wake-up via WDT or Interrupt = uuuu. PORTD, Wake-up via WDT or Interrupt = uuuu. PORTC, Applicable Devices = 2585. PORTC, Applicable Devices = 2680. PORTC, Applicable Devices = 4585. PORTC, Applicable Devices = 4680. PORTC, Power-on Reset, Brown-out Reset = xxxx. PORTC, Power-on Reset, Brown-out Reset = xxxx. PORTC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. PORTC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. PORTC, Wake-up via WDT or Interrupt = uuuu. PORTC, Wake-up via",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu. PORTB, Applicable Devices = 2585. PORTB, Applicable Devices = 2680. PORTB, Applicable Devices = 4585. PORTB, Applicable Devices = 4680. PORTB, Power-on Reset, Brown-out Reset = xxxx. PORTB, Power-on Reset, Brown-out Reset = xxxx. PORTB, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. PORTB, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. PORTB, Wake-up via WDT or Interrupt = uuuu. PORTB, Wake-up via WDT or Interrupt = uuuu. PORTA (5), Applicable Devices = 2585. PORTA (5), Applicable Devices = 2680. PORTA (5), Applicable Devices = 4585. PORTA (5), Applicable Devices = 4680. PORTA (5), Power-on Reset, Brown-out Reset = xx0x. PORTA (5), Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset = 0000 (5). PORTA (5), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uu0u. PORTA (5), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 (5). PORTA (5), Wake-up via WDT or Interrupt = uuuu. PORTA (5), Wake-up via WDT or Interrupt = uuuu (5). ECANCON, Applicable Devices = 2585. ECANCON, Applicable Devices = 2680. ECANCON, Applicable Devices = 4585. ECANCON, Applicable Devices = 4680. ECANCON, Power-on Reset, Brown-out Reset = 0001. ECANCON, Power-on Reset, Brown-out Reset = 0000. ECANCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0001. ECANCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. ECANCON, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. ECANCON, Wake-up via WDT or Interrupt = uuuu. TXERRCNT, Applicable Devices = 2585. TXERRCNT, Applicable Devices = 2680. TXERRCNT, Applicable Devices = 4585. TXERRCNT, Applicable Devices = 4680. TXERRCNT, Power-on Reset, Brown-out Reset = 0000. TXERRCNT, Power-on Reset, Brown-out Reset = 0000. TXERRCNT, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. TXERRCNT, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. TXERRCNT, Wake-up via WDT or Interrupt = uuuu. TXERRCNT, Wake-up via WDT or Interrupt = uuuu. RXERRCNT, Applicable Devices = 2585. RXERRCNT, Applicable Devices = 2680. RXERRCNT, Applicable Devices = 4585. RXERRCNT, Applicable Devices = 4680.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXERRCNT, Power-on Reset, Brown-out Reset = 0000. RXERRCNT, Power-on Reset, Brown-out Reset = 0000. RXERRCNT, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. RXERRCNT, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. RXERRCNT, Wake-up via WDT or Interrupt = uuuu. RXERRCNT, Wake-up via WDT or Interrupt = uuuu. COMSTAT, Applicable Devices = 2585. COMSTAT, Applicable Devices = 2680. COMSTAT, Applicable Devices = 4585. COMSTAT, Applicable Devices = 4680. COMSTAT, Power-on Reset, Brown-out Reset = 0000. COMSTAT, Power-on Reset, Brown-out Reset = 0000. COMSTAT, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. COMSTAT, MCLR Resets, WDT Reset, RESET Instruction, Stack",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = 0000. COMSTAT, Wake-up via WDT or Interrupt = uuuu. COMSTAT, Wake-up via WDT or Interrupt = uuuu. CIOCON, Applicable Devices = 2585. CIOCON, Applicable Devices = 2680. CIOCON, Applicable Devices = 4585. CIOCON, Applicable Devices = 4680. CIOCON, Power-on Reset, Brown-out Reset = --00. CIOCON, Power-on Reset, Brown-out Reset = ----. CIOCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = --00. CIOCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ----. CIOCON, Wake-up via WDT or Interrupt = --uu. CIOCON, Wake-up via WDT or Interrupt = ----. BRGCON3, Applicable Devices = 2585. BRGCON3, Applicable Devices = 2680. BRGCON3, Applicable Devices = 4585. BRGCON3,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = 4680. BRGCON3, Power-on Reset, Brown-out Reset = 00--. BRGCON3, Power-on Reset, Brown-out Reset = -000. BRGCON3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 00--. BRGCON3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -000. BRGCON3, Wake-up via WDT or Interrupt = uu--. BRGCON3, Wake-up via WDT or Interrupt = -uuu. BRGCON2, Applicable Devices = 2585. BRGCON2, Applicable Devices = 2680. BRGCON2, Applicable Devices = 4585. BRGCON2, Applicable Devices = 4680. BRGCON2, Power-on Reset, Brown-out Reset = 0000. BRGCON2, Power-on Reset, Brown-out Reset = 0000. BRGCON2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. BRGCON2, MCLR",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets, WDT Reset, RESET Instruction, Stack Resets = 0000. BRGCON2, Wake-up via WDT or Interrupt = uuuu. BRGCON2, Wake-up via WDT or Interrupt = uuuu. BRGCON1, Applicable Devices = 2585. BRGCON1, Applicable Devices = 2680. BRGCON1, Applicable Devices = 4585. BRGCON1, Applicable Devices = 4680. BRGCON1, Power-on Reset, Brown-out Reset = 0000. BRGCON1, Power-on Reset, Brown-out Reset = 0000. BRGCON1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. BRGCON1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. BRGCON1, Wake-up via WDT or Interrupt = uuuu. BRGCON1, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCANCON, Applicable Devices = 2585. CANCON, Applicable Devices = 2680. CANCON, Applicable Devices = 4585. CANCON, Applicable Devices = 4680. CANCON, Power-on Reset, Brown-out Reset = 1000 000-. CANCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 1000. CANCON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 000-. CANCON, Wake-up via WDT or Interrupt = uuuu. CANCON, Wake-up via WDT or Interrupt = uuu-. CANSTAT, Applicable Devices = 2585. CANSTAT, Applicable Devices = 2680. CANSTAT, Applicable Devices = 4585. CANSTAT, Applicable Devices = 4680. CANSTAT, Power-on Reset, Brown-out Reset = 100-. CANSTAT, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 000-. CANSTAT, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 100- 000-. CANSTAT, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuu-. CANSTAT, Wake-up via WDT or Interrupt = uuu-. RXB0D7, Applicable Devices = 2585. RXB0D7, Applicable Devices = 2680. RXB0D7, Applicable Devices = 4585. RXB0D7, Applicable Devices = 4680. RXB0D7, Power-on Reset, Brown-out Reset = xxxx. RXB0D7, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0D7, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB0D7, Wake-up via WDT or Interrupt = uuuu. RXB0D7, Wake-up via WDT or Interrupt = uuuu. RXB0D6, Applicable Devices = 2585. RXB0D6, Applicable Devices = 2680. RXB0D6, Applicable Devices = 4585. RXB0D6, Applicable Devices",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 4680. RXB0D6, Power-on Reset, Brown-out Reset = xxxx. RXB0D6, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0D6, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB0D6, Wake-up via WDT or Interrupt = uuuu. RXB0D6, Wake-up via WDT or Interrupt = uuuu. RXB0D5, Applicable Devices = 2585. RXB0D5, Applicable Devices = 2680. RXB0D5, Applicable Devices = 4585. RXB0D5, Applicable Devices = 4680. RXB0D5, Power-on Reset, Brown-out Reset = xxxx. RXB0D5, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0D5, MCLR Resets, WDT Reset, RESET Instruction, Stack",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = uuuu uuuu. RXB0D5, Wake-up via WDT or Interrupt = uuuu. RXB0D5, Wake-up via WDT or Interrupt = uuuu. RXB0D4, Applicable Devices = 2585. RXB0D4, Applicable Devices = 2680. RXB0D4, Applicable Devices = 4585. RXB0D4, Applicable Devices = 4680. RXB0D4, Power-on Reset, Brown-out Reset = xxxx. RXB0D4, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0D4, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB0D4, Wake-up via WDT or Interrupt = uuuu. RXB0D4, Wake-up via WDT or Interrupt = uuuu. RXB0D3, Applicable Devices = 2585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0D3, Applicable Devices = 2680. RXB0D3, Applicable Devices = 4585. RXB0D3, Applicable Devices = 4680. RXB0D3, Power-on Reset, Brown-out Reset = xxxx. RXB0D3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0D3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB0D3, Wake-up via WDT or Interrupt = uuuu. RXB0D3, Wake-up via WDT or Interrupt = uuuu. RXB0D2, Applicable Devices = 2585. RXB0D2, Applicable Devices = 2680. RXB0D2, Applicable Devices = 4585. RXB0D2, Applicable Devices = 4680. RXB0D2, Power-on Reset, Brown-out Reset = xxxx. RXB0D2, MCLR",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0D2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB0D2, Wake-up via WDT or Interrupt = uuuu. RXB0D2, Wake-up via WDT or Interrupt = uuuu. RXB0D1, Applicable Devices = 2585. RXB0D1, Applicable Devices = 2680. RXB0D1, Applicable Devices = 4585. RXB0D1, Applicable Devices = 4680. RXB0D1, Power-on Reset, Brown-out Reset = xxxx. RXB0D1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0D1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB0D1, Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0D1, Wake-up via WDT or Interrupt = uuuu. RXB0D0, Applicable Devices = 2585. RXB0D0, Applicable Devices = 2680. RXB0D0, Applicable Devices = 4585. RXB0D0, Applicable Devices = 4680. RXB0D0, Power-on Reset, Brown-out Reset = xxxx. RXB0D0, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0D0, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB0D0, Wake-up via WDT or Interrupt = uuuu. RXB0D0, Wake-up via WDT or Interrupt = uuuu. RXB0DLC, Applicable Devices = 2585. RXB0DLC, Applicable Devices = 2680. RXB0DLC, Applicable Devices = 4585. RXB0DLC, Applicable Devices =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n4680. RXB0DLC, Power-on Reset, Brown-out Reset = -xxx. RXB0DLC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0DLC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -uuu uuuu. RXB0DLC, Wake-up via WDT or Interrupt = -uuu. RXB0DLC, Wake-up via WDT or Interrupt = uuuu. RXB0EIDL, Applicable Devices = 2585. RXB0EIDL, Applicable Devices = 2680. RXB0EIDL, Applicable Devices = 4585. RXB0EIDL, Applicable Devices = 4680. RXB0EIDL, Power-on Reset, Brown-out Reset = xxxx. RXB0EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = uuuu uuuu. RXB0EIDL, Wake-up via WDT or Interrupt = uuuu. RXB0EIDL, Wake-up via WDT or Interrupt = uuuu. RXB0EIDH, Applicable Devices = 2585. RXB0EIDH, Applicable Devices = 2680. RXB0EIDH, Applicable Devices = 4585. RXB0EIDH, Applicable Devices = 4680. RXB0EIDH, Power-on Reset, Brown-out Reset = xxxx. RXB0EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB0EIDH, Wake-up via WDT or Interrupt = uuuu. RXB0EIDH, Wake-up via WDT or Interrupt = uuuu. RXB0SIDL, Applicable Devices = 2585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0SIDL, Applicable Devices = 2680. RXB0SIDL, Applicable Devices = 4585. RXB0SIDL, Applicable Devices = 4680. RXB0SIDL, Power-on Reset, Brown-out Reset = xxxx. RXB0SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = x-xx. RXB0SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu u-uu. RXB0SIDL, Wake-up via WDT or Interrupt = uuuu. RXB0SIDL, Wake-up via WDT or Interrupt = u-uu. RXB0SIDH, Applicable Devices = 2585. RXB0SIDH, Applicable Devices = 2680. RXB0SIDH, Applicable Devices = 4585. RXB0SIDH, Applicable Devices = 4680. RXB0SIDH, Power-on Reset, Brown-out Reset = xxxx. RXB0SIDH, MCLR",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB0SIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB0SIDH, Wake-up via WDT or Interrupt = uuuu. RXB0SIDH, Wake-up via WDT or Interrupt = uuuu. RXB0CON, Applicable Devices = 2585. RXB0CON, Applicable Devices = 2680. RXB0CON, Applicable Devices = 4585. RXB0CON, Applicable Devices = 4680. RXB0CON, Power-on Reset, Brown-out Reset = 000-. RXB0CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. RXB0CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 000- 0000. RXB0CON, Wake-up via WDT or Interrupt = . RXB0CON, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuu- uuuu. RXB1D7, Applicable Devices = 2585. RXB1D7, Applicable Devices = 2680. RXB1D7, Applicable Devices = 4585. RXB1D7, Applicable Devices = 4680. RXB1D7, Power-on Reset, Brown-out Reset = xxxx. RXB1D7, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB1D7, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. RXB1D7, Wake-up via WDT or Interrupt = uuuu. RXB1D7, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1D6, Applicable Devices = 2585. RXB1D6, Applicable Devices = 2680. RXB1D6, Applicable Devices = 4585. RXB1D6, Applicable Devices = 4680. RXB1D6,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = xxxx. RXB1D6, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB1D6, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB1D6, Wake-up via WDT or Interrupt = uuuu. RXB1D6, Wake-up via WDT or Interrupt = uuuu. RXB1D5, Applicable Devices = 2585. RXB1D5, Applicable Devices = 2680. RXB1D5, Applicable Devices = 4585. RXB1D5, Applicable Devices = 4680. RXB1D5, Power-on Reset, Brown-out Reset = xxxx. RXB1D5, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB1D5, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. RXB1D5, Wake-up via WDT or Interrupt = uuuu. RXB1D5, Wake-up via WDT or Interrupt = uuuu. RXB1D4, Applicable Devices = 2585. RXB1D4, Applicable Devices = 2680. RXB1D4, Applicable Devices = 4585. RXB1D4, Applicable Devices = 4680. RXB1D4, Power-on Reset, Brown-out Reset = xxxx. RXB1D4, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB1D4, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB1D4, Wake-up via WDT or Interrupt = uuuu. RXB1D4, Wake-up via WDT or Interrupt = uuuu. RXB1D3, Applicable Devices = 2585. RXB1D3, Applicable Devices =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n2680. RXB1D3, Applicable Devices = 4585. RXB1D3, Applicable Devices = 4680. RXB1D3, Power-on Reset, Brown-out Reset = xxxx. RXB1D3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB1D3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB1D3, Wake-up via WDT or Interrupt = . RXB1D3, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1D2, Applicable Devices = 2585. RXB1D2, Applicable Devices = 2680. RXB1D2, Applicable Devices = 4585. RXB1D2, Applicable Devices = 4680. RXB1D2, Power-on Reset, Brown-out Reset = xxxx. RXB1D2, MCLR Resets, WDT Reset, RESET Instruction, Stack",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = xxxx. RXB1D2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB1D2, Wake-up via WDT or Interrupt = uuuu. RXB1D2, Wake-up via WDT or Interrupt = uuuu. RXB1D1, Applicable Devices = 2585. RXB1D1, Applicable Devices = 2680. RXB1D1, Applicable Devices = 4585. RXB1D1, Applicable Devices = 4680. RXB1D1, Power-on Reset, Brown-out Reset = xxxx. RXB1D1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB1D1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB1D1, Wake-up via WDT or Interrupt = uuuu. RXB1D1, Wake-up via",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu. RXB1D0, Applicable Devices = 2585. RXB1D0, Applicable Devices = 2680. RXB1D0, Applicable Devices = 4585. RXB1D0, Applicable Devices = 4680. RXB1D0, Power-on Reset, Brown-out Reset = xxxx. RXB1D0, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB1D0, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB1D0, Wake-up via WDT or Interrupt = uuuu. RXB1D0, Wake-up via WDT or Interrupt = uuuu. RXB1DLC, Applicable Devices = 2585. RXB1DLC, Applicable Devices = 2680. RXB1DLC, Applicable Devices = 4585. RXB1DLC, Applicable Devices = 4680. RXB1DLC,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = -xxx. RXB1DLC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB1DLC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -uuu uuuu. RXB1DLC, Wake-up via WDT or Interrupt = -uuu. RXB1DLC, Wake-up via WDT or Interrupt = uuuu. RXB1EIDL, Applicable Devices = 2585. RXB1EIDL, Applicable Devices = 2680. RXB1EIDL, Applicable Devices = 4585. RXB1EIDL, Applicable Devices = 4680. RXB1EIDL, Power-on Reset, Brown-out Reset = xxxx. RXB1EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB1EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. RXB1EIDL, Wake-up via WDT or Interrupt = uuuu. RXB1EIDL, Wake-up via WDT or Interrupt = uuuu. RXB1EIDH, Applicable Devices = 2585. RXB1EIDH, Applicable Devices = 2680. RXB1EIDH, Applicable Devices = 4585. RXB1EIDH, Applicable Devices = 4680. RXB1EIDH, Power-on Reset, Brown-out Reset = xxxx. RXB1EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. RXB1EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB1EIDH, Wake-up via WDT or Interrupt = uuuu. RXB1EIDH, Wake-up via WDT or Interrupt = uuuu. RXB1SIDL, Applicable Devices = 2585. RXB1SIDL, Applicable Devices =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n2680. RXB1SIDL, Applicable Devices = 4585. RXB1SIDL, Applicable Devices = 4680. RXB1SIDL, Power-on Reset, Brown-out Reset = xxxx. RXB1SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = x-xx. RXB1SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu u-uu. RXB1SIDL, Wake-up via WDT or Interrupt = uuuu. RXB1SIDL, Wake-up via WDT or Interrupt = u-uu. RXB1SIDH, Applicable Devices = 2585. RXB1SIDH, Applicable Devices = 2680. RXB1SIDH, Applicable Devices = 4585. RXB1SIDH, Applicable Devices = 4680 4680. RXB1SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1SIDH, MCLR Resets, WDT Reset,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRESET Instruction, Stack Resets = 0000. RXB1SIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXB1SIDH, Wake-up via WDT or Interrupt = uuu-. RXB1SIDH, Wake-up via WDT or Interrupt = uuuu uuuu uuuu. RXB1CON, Applicable Devices = 2585. RXB1CON, Applicable Devices = 2680. RXB1CON, Applicable Devices = 4585. RXB1CON, Applicable Devices = 4680. RXB1CON, Power-on Reset, Brown-out Reset = 000-. RXB1CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . RXB1CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 000- 0000. RXB1CON, Wake-up via WDT or Interrupt = . RXB1CON, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. TXB0D7, Applicable Devices = 2585. TXB0D7, Applicable Devices = 2680. TXB0D7, Applicable Devices = 4585. TXB0D7, Applicable Devices = 4680. TXB0D7, Power-on Reset, Brown-out Reset = xxxx. TXB0D7, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = xxxx. TXB0D7, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB0D7, Wake-up via WDT or Interrupt = uuuu. TXB0D7, Wake-up via WDT or Interrupt = uuuu. TXB0D6, Applicable Devices = 2585. TXB0D6, Applicable Devices = 2680. TXB0D6, Applicable Devices = 4585. TXB0D6, Applicable Devices = . TXB0D6, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D6,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . TXB0D6, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB0D6, Wake-up via WDT or Interrupt = . TXB0D6, Wake-up via WDT or Interrupt = uuuu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB0D5, Applicable Devices = 2585. TXB0D5, Applicable Devices = 2680. TXB0D5, Applicable Devices = 4585. TXB0D5, Applicable Devices = 4680. TXB0D5, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D5, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB0D5, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0D4, Applicable Devices = 2585. TXB0D4, Applicable Devices = 2680. TXB0D4, Applicable Devices = 4585. TXB0D4, Applicable Devices = 4680. TXB0D4, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D4, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB0D4, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. TXB0D3, Applicable Devices = 2585. TXB0D3, Applicable Devices = 2680. TXB0D3, Applicable Devices = 4585. TXB0D3, Applicable Devices = 4680. TXB0D3, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB0D3, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0D2, Applicable Devices = 2585. TXB0D2, Applicable Devices = 2680. TXB0D2, Applicable Devices = 4585. TXB0D2, Applicable Devices = 4680. TXB0D2, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB0D2, Wake-up",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nvia WDT or Interrupt = uuuu uuuu. TXB0D1, Applicable Devices = 2585. TXB0D1, Applicable Devices = 2680. TXB0D1, Applicable Devices = 4585. TXB0D1, Applicable Devices = 4680. TXB0D1, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB0D1, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0D0, Applicable Devices = 2585. TXB0D0, Applicable Devices = 2680. TXB0D0, Applicable Devices = 4585. TXB0D0, Applicable Devices = 4680. TXB0D0, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D0, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB0D0, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0DLC, Applicable Devices = 2585. TXB0DLC, Applicable Devices = 2680. TXB0DLC, Applicable Devices = 4585. TXB0DLC, Applicable Devices = 4680. TXB0DLC, Power-on Reset, Brown-out Reset = -x-- xxxx. TXB0DLC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -u-- uuuu. TXB0DLC, Wake-up via WDT or Interrupt = -u-- uuuu. TXB0EIDL, Applicable Devices = 2585. TXB0EIDL, Applicable Devices = 2680. TXB0EIDL, Applicable Devices = 4585. TXB0EIDL, Applicable Devices = 4680. TXB0EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. TXB0EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0EIDH, Applicable Devices = 2585. TXB0EIDH, Applicable Devices = 2680. TXB0EIDH, Applicable Devices = 4585. TXB0EIDH, Applicable Devices = 4680. TXB0EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB0EIDH, Wake-up via WDT or Interrupt = -uuu uuuu. TXB0SIDL, Applicable Devices = 2585. TXB0SIDL, Applicable Devices = 2680. TXB0SIDL, Applicable Devices = 4585. TXB0SIDL, Applicable Devices = 4680. TXB0SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. TXB0SIDL, MCLR Resets, WDT",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, RESET Instruction, Stack Resets = uuu- u-uu. TXB0SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. TXB0SIDH, Applicable Devices = 2585. TXB0SIDH, Applicable Devices = 2680. TXB0SIDH, Applicable Devices = 4585. TXB0SIDH, Applicable Devices = 4680. TXB0SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0SIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB0SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0CON, Applicable Devices = 2585. TXB0CON, Applicable Devices = 2680. TXB0CON, Applicable Devices = 4585. TXB0CON, Applicable Devices = 4680. TXB0CON, Power-on Reset, Brown-out Reset = 0000 0-00. TXB0CON, MCLR Resets,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset, RESET Instruction, Stack Resets = 0000 0-00. TXB0CON, Wake-up via WDT or Interrupt = uuuu u-uu. TXB1D7, Applicable Devices = 2585. TXB1D7, Applicable Devices = 2680. TXB1D7, Applicable Devices = 4585. TXB1D7, Applicable Devices = 4680. TXB1D7, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D7, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB1D7, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D6, Applicable Devices = 2585. TXB1D6, Applicable Devices = 2680. TXB1D6, Applicable Devices = 4585. TXB1D6, Applicable Devices = 4680. TXB1D6, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D6, MCLR",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB1D6, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D5, Applicable Devices = 2585. TXB1D5, Applicable Devices = 2680. TXB1D5, Applicable Devices = 4585. TXB1D5, Applicable Devices = 4680. TXB1D5, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D5, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB1D5, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D4, Applicable Devices = 2585. TXB1D4, Applicable Devices = 2680. TXB1D4, Applicable Devices = 4585. TXB1D4, Applicable Devices = 4680. TXB1D4, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB1D4, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB1D4, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D3, Applicable Devices = 2585. TXB1D3, Applicable Devices = 2680. TXB1D3, Applicable Devices = 4585. TXB1D3, Applicable Devices = 4680. TXB1D3, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB1D3, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D2, Applicable Devices = 2585. TXB1D2, Applicable Devices = 2680. TXB1D2, Applicable Devices = 4585. TXB1D2, Applicable Devices = 4680. TXB1D2, Power-on Reset, Brown-out Reset",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= xxxx xxxx. TXB1D2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB1D2, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D1, Applicable Devices = 2585. TXB1D1, Applicable Devices = 2680. TXB1D1, Applicable Devices = 4585. TXB1D1, Applicable Devices = 4680. TXB1D1, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB1D1, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D0, Applicable Devices = 2585. TXB1D0, Applicable Devices = 2680. TXB1D0, Applicable Devices = 4585. TXB1D0, Applicable Devices = 4680. TXB1D0, Power-on",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset = xxxx xxxx. TXB1D0, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB1D0, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1DLC, Applicable Devices = 2585. TXB1DLC, Applicable Devices = 2680. TXB1DLC, Applicable Devices = 4585. TXB1DLC, Applicable Devices = 4680. TXB1DLC, Power-on Reset, Brown-out Reset = -x-- xxxx. TXB1DLC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -u-- uuuu. TXB1DLC, Wake-up via WDT or Interrupt = -u-- uuuu. TXB1EIDL, Applicable Devices = 2585. TXB1EIDL, Applicable Devices = 2680. TXB1EIDL, Applicable Devices = 4585. TXB1EIDL, Applicable Devices = 4680.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB1EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB1EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1EIDH, Applicable Devices = 2585. TXB1EIDH, Applicable Devices = 2680. TXB1EIDH, Applicable Devices = 4585. TXB1EIDH, Applicable Devices = 4680. TXB1EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB1EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. , Applicable Devices = 2585. , Applicable Devices = 2680. , Applicable Devices = . , Applicable Devices = . , Power-on Reset, Brown-out Reset = . , MCLR Resets,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. , Wake-up via WDT or Interrupt = -uuu uuuu. TXB1SIDL, Applicable Devices = . TXB1SIDL, Applicable Devices = . TXB1SIDL, Applicable Devices = 4585. TXB1SIDL, Applicable Devices = 4680. TXB1SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. TXB1SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. TXB1SIDL, Wake-up via WDT or Interrupt = uuu- uu-u. TXB1SIDH, Applicable Devices = 2585. TXB1SIDH, Applicable Devices = 2680. TXB1SIDH, Applicable Devices = 4585. TXB1SIDH, Applicable Devices = 4680. TXB1SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1SIDH, MCLR Resets,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset, RESET Instruction, Stack Resets = . TXB1SIDH, Wake-up via WDT or Interrupt = . TXB1CON, Applicable Devices = 2585. TXB1CON, Applicable Devices = 2680. TXB1CON, Applicable Devices = 4585. TXB1CON, Applicable Devices = 4680. TXB1CON, Power-on Reset, Brown-out Reset = 0000 0-00. TXB1CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0-00. TXB1CON, Wake-up via WDT or Interrupt = uuuu u-uu. TXB2D7, Applicable Devices = 2585. TXB2D7, Applicable Devices = 2680. TXB2D7, Applicable Devices = 4585. TXB2D7, Applicable Devices = 4680. TXB2D7, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D7, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. TXB2D7, Wake-up via WDT or Interrupt = 0uuu uuuu. TXB2D6, Applicable Devices = 2585. TXB2D6, Applicable Devices = 2680. TXB2D6, Applicable Devices = 4585. TXB2D6, Applicable Devices = 4680. TXB2D6, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D6, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB2D6, Wake-up via WDT or Interrupt = 0uuu uuuu. TXB2D5, Applicable Devices = 2585 2585. TXB2D5, Applicable Devices = 2680. TXB2D5, Applicable Devices = 4585. TXB2D5, Applicable Devices = 4680 4680. TXB2D5, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D5, MCLR Resets, WDT Reset, RESET",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInstruction, Stack Resets = uuuu uuuu uuuu uuuu. TXB2D5, Wake-up via WDT or Interrupt = 0uuu uuuu. TXB2D2, Applicable Devices = 2585. TXB2D2, Applicable Devices = . TXB2D2, Applicable Devices = 4585. TXB2D2, Applicable Devices = . TXB2D2, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D2, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . TXB2D2, Wake-up via WDT or Interrupt = 0uuu uuuu. TXB2D4, Applicable Devices = . TXB2D4, Applicable Devices = 2680. TXB2D4, Applicable Devices = 4585. TXB2D4, Applicable Devices = . TXB2D4, Power-on Reset, Brown-out Reset = . TXB2D4, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. TXB2D4, Wake-up via WDT or Interrupt = . TXB2D3, Applicable Devices = 2585. TXB2D3, Applicable Devices = 2680 2680. TXB2D3, Applicable Devices = 4585. TXB2D3, Applicable Devices = 4680 4680. TXB2D3, Power-on Reset, Brown-out Reset = xxxx xxxx xxxx xxxx. TXB2D3, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB2D3, Wake-up via WDT or Interrupt = 0uuu uuuu 0uuu uuuu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition.\nShaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB2D1, Applicable Devices = 2585. TXB2D1, Applicable Devices = 2680. TXB2D1, Applicable Devices = 4585. TXB2D1, Applicable Devices = 4680. TXB2D1, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D1, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB2D1, Wake-up via WDT or Interrupt = 0uuu uuuu. TXB2D0, Applicable Devices = 2585. TXB2D0, Applicable Devices = 2680. TXB2D0, Applicable Devices = 4585. TXB2D0, Applicable Devices = 4680. TXB2D0, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D0, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB2D0, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0uuu uuuu. TXB2DLC, Applicable Devices = 2585. TXB2DLC, Applicable Devices = 2680. TXB2DLC, Applicable Devices = 4585. TXB2DLC, Applicable Devices = 4680. TXB2DLC, Power-on Reset, Brown-out Reset = -x-- xxxx. TXB2DLC, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -u-- uuuu. TXB2DLC, Wake-up via WDT or Interrupt = -u-- uuuu. TXB2EIDL, Applicable Devices = 2585. TXB2EIDL, Applicable Devices = 2680. TXB2EIDL, Applicable Devices = 4585. TXB2EIDL, Applicable Devices = 4680. TXB2EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB2EIDL,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu uuuu. TXB2EIDH, Applicable Devices = 2585. TXB2EIDH, Applicable Devices = 2680. TXB2EIDH, Applicable Devices = 4585. TXB2EIDH, Applicable Devices = 4680. TXB2EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. TXB2EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. TXB2SIDL, Applicable Devices = 2585. TXB2SIDL, Applicable Devices = 2680. TXB2SIDL, Applicable Devices = 4585. TXB2SIDL, Applicable Devices = 4680. TXB2SIDL, Power-on Reset, Brown-out Reset = xxxx x-xx. TXB2SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nu-uu. TXB2SIDL, Wake-up via WDT or Interrupt = -uuu uuuu. TXB2SIDH, Applicable Devices = 2585. TXB2SIDH, Applicable Devices = 2680. TXB2SIDH, Applicable Devices = 4585. TXB2SIDH, Applicable Devices = 4680. TXB2SIDH, Power-on Reset, Brown-out Reset = xxx- x-xx. TXB2SIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. TXB2SIDH, Wake-up via WDT or Interrupt = uuu- u-uu. TXB2CON, Applicable Devices = 2585. TXB2CON, Applicable Devices = 2680. TXB2CON, Applicable Devices = 4585. TXB2CON, Applicable Devices = 4680. TXB2CON, Power-on Reset, Brown-out Reset = 0000 0-00. TXB2CON, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000 0-00. TXB2CON, Wake-up via WDT or Interrupt = uuuu u-uu. RXM1EIDL, Applicable Devices = 2585. RXM1EIDL, Applicable Devices = 2680. RXM1EIDL, Applicable Devices = 4585. RXM1EIDL, Applicable Devices = 4680. RXM1EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM1EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXM1EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXM1EIDH, Applicable Devices = 2585. RXM1EIDH, Applicable Devices = 2680. RXM1EIDH, Applicable Devices = 4585. RXM1EIDH, Applicable Devices = 4680. RXM1EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM1EIDH,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXM1EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXM1SIDL, Applicable Devices = 2585. RXM1SIDL, Applicable Devices = 2680. RXM1SIDL, Applicable Devices = 4585. RXM1SIDL, Applicable Devices = 4680. RXM1SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXM1SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. RXM1SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXM1SIDH, Applicable Devices = 2585. RXM1SIDH, Applicable Devices = 2680. RXM1SIDH, Applicable Devices = 4585. RXM1SIDH, Applicable Devices = 4680. RXM1SIDH,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = xxxx xxxx. RXM1SIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXM1SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXM0EIDL, Applicable Devices = 2585. RXM0EIDL, Applicable Devices = 2680. RXM0EIDL, Applicable Devices = 4585. RXM0EIDL, Applicable Devices = 4680. RXM0EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM0EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXM0EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXM0EIDH, Applicable Devices = 2585. RXM0EIDH, Applicable Devices = 2680. RXM0EIDH, Applicable Devices = 4585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXM0EIDH, Applicable Devices = 4680. RXM0EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM0EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXM0EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXM0SIDL, Applicable Devices = 2585. RXM0SIDL, Applicable Devices = 2680. RXM0SIDL, Applicable Devices = 4585. RXM0SIDL, Applicable Devices = 4680. RXM0SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXM0SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. RXM0SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXM0SIDH, Applicable Devices = 2585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXM0SIDH, Applicable Devices = 2680. RXM0SIDH, Applicable Devices = 4585. RXM0SIDH, Applicable Devices = 4680. RXM0SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM0SIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXM0SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF5EIDL, Applicable Devices = 2585. RXF5EIDL, Applicable Devices = 2680. RXF5EIDL, Applicable Devices = 4585. RXF5EIDL, Applicable Devices = 4680. RXF5EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF5EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF5EIDL, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. RXF5EIDH, Applicable Devices = 2585. RXF5EIDH, Applicable Devices = 2680. RXF5EIDH, Applicable Devices = 4585. RXF5EIDH, Applicable Devices = 4680. RXF5EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF5EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF5EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF5SIDL, Applicable Devices = 2585. RXF5SIDL, Applicable Devices = 2680. RXF5SIDL, Applicable Devices = 4585. RXF5SIDL, Applicable Devices = 4680. RXF5SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF5SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuu- u-uu. RXF5SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF5SIDH, Applicable Devices = 2585. RXF5SIDH, Applicable Devices = 2680. RXF5SIDH, Applicable Devices = 4585. RXF5SIDH, Applicable Devices = 4680. RXF5SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF5SIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF5SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF4EIDL, Applicable Devices = 2585. RXF4EIDL, Applicable Devices = 2680. RXF4EIDL, Applicable Devices = 4585. RXF4EIDL, Applicable Devices = 4680. RXF4EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF4EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF4EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF4EIDH, Applicable Devices = 2585. RXF4EIDH, Applicable Devices = 2680. RXF4EIDH, Applicable Devices = 4585. RXF4EIDH, Applicable Devices = 4680. RXF4EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF4EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF4EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF4SIDL, Applicable Devices = 2585. RXF4SIDL, Applicable Devices = 2680. RXF4SIDL, Applicable Devices = 4585. RXF4SIDL, Applicable Devices = 4680.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF4SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF4SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. RXF4SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF4SIDH, Applicable Devices = 2585. RXF4SIDH, Applicable Devices = 2680. RXF4SIDH, Applicable Devices = 4585. RXF4SIDH, Applicable Devices = 4680. RXF4SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF4SIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF4SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. , Applicable Devices = . , Applicable Devices = 2680. , Applicable Devices = . , Applicable Devices = 4680. , Power-on Reset,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = xxxx xxxx. , MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. , Wake-up via WDT or Interrupt = uuu- u-uu. RXF3EIDL RXF3EIDH, Applicable Devices = 2585 2585. RXF3EIDL RXF3EIDH, Applicable Devices = 2680. RXF3EIDL RXF3EIDH, Applicable Devices = 4585 4585. RXF3EIDL RXF3EIDH, Applicable Devices = 4680 4680. RXF3EIDL RXF3EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF3EIDL RXF3EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF3EIDL RXF3EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. , Applicable Devices = . , Applicable Devices",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= . , Applicable Devices = . , Applicable Devices = . , Power-on Reset, Brown-out Reset = . , MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . , Wake-up via WDT or Interrupt = uuuu uuuu. RXF3SIDL, Applicable Devices = 2585. RXF3SIDL, Applicable Devices = 2680. RXF3SIDL, Applicable Devices = 4585. RXF3SIDL, Applicable Devices = . RXF3SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF3SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. RXF3SIDL, Wake-up via WDT or Interrupt = . RXF3SIDH, Applicable Devices = 2585. RXF3SIDH, Applicable Devices = 2680. RXF3SIDH, Applicable Devices = 4585. RXF3SIDH, Applicable Devices = 4680.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF3SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF3SIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF3SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF2EIDL, Applicable Devices = 2585. RXF2EIDL, Applicable Devices = 2680. RXF2EIDL, Applicable Devices = 4585. RXF2EIDL, Applicable Devices = 4680. RXF2EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF2EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu uuuu uuuu. RXF2EIDL, Wake-up via WDT or Interrupt = uuuu uuuu uuuu uuuu. RXF2EIDH, Applicable Devices = 2585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF2EIDH, Applicable Devices = 2680. RXF2EIDH, Applicable Devices = 4585. RXF2EIDH, Applicable Devices = 4680. RXF2EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF2EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . RXF2EIDH, Wake-up via WDT or Interrupt = uuu- u-uu. RXF2SIDL RXF2SIDH, Applicable Devices = 2585 2585. RXF2SIDL RXF2SIDH, Applicable Devices = 2680 2680. RXF2SIDL RXF2SIDH, Applicable Devices = 4585 4585. RXF2SIDL RXF2SIDH, Applicable Devices = 4680 4680. RXF2SIDL RXF2SIDH, Power-on Reset, Brown-out Reset = xxx- x-xx xxxx xxxx. RXF2SIDL RXF2SIDH,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu uuuu uuuu. RXF2SIDL RXF2SIDH, Wake-up via WDT or Interrupt = uuuu uuuu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF1EIDL, Applicable Devices = 2585. RXF1EIDL, Applicable Devices = 2680. RXF1EIDL, Applicable Devices = 4585. RXF1EIDL, Applicable Devices = 4680. RXF1EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF1EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF1EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF1EIDH, Applicable Devices = 2585. RXF1EIDH, Applicable Devices = 2680. RXF1EIDH, Applicable Devices = 4585. RXF1EIDH, Applicable Devices = 4680. RXF1EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF1EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF1EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF1SIDL, Applicable Devices = 2585. RXF1SIDL, Applicable Devices = 2680. RXF1SIDL, Applicable Devices = 4585. RXF1SIDL, Applicable Devices = 4680. RXF1SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF1SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. RXF1SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF1SIDH, Applicable Devices = 2585. RXF1SIDH, Applicable Devices = 2680. RXF1SIDH, Applicable Devices = 4585. RXF1SIDH, Applicable Devices = 4680. RXF1SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF1SIDH, MCLR",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF1SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF0EIDL, Applicable Devices = 2585. RXF0EIDL, Applicable Devices = 2680 4585. RXF0EIDL, Applicable Devices = 4680. RXF0EIDL, Applicable Devices = xxxx. RXF0EIDL, Power-on Reset, Brown-out Reset = xxxx. RXF0EIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF0EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF0EIDH, Applicable Devices = 2585. RXF0EIDH, Applicable Devices = 2680. RXF0EIDH, Applicable Devices = 4585. RXF0EIDH, Applicable Devices = 4680. RXF0EIDH, Power-on",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset = xxxx xxxx. RXF0EIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF0EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF0SIDL, Applicable Devices = 2585. RXF0SIDL, Applicable Devices = 2680 4585. RXF0SIDL, Applicable Devices = 4680. RXF0SIDL, Applicable Devices = . RXF0SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF0SIDL, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. RXF0SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF0SIDH, Applicable Devices = 2585. RXF0SIDH, Applicable Devices = 2680 4585. RXF0SIDH, Applicable Devices = .",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF0SIDH, Applicable Devices = 4680. RXF0SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF0SIDH, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF0SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. B5D7 (6), Applicable Devices = 2585. B5D7 (6), Applicable Devices = 2680. B5D7 (6), Applicable Devices = 4585. B5D7 (6), Applicable Devices = 4680. B5D7 (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D7 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B5D7 (6), Wake-up via WDT or Interrupt = uuuu uuuu. B5D6 (6), Applicable Devices =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n2585. B5D6 (6), Applicable Devices = 2680. B5D6 (6), Applicable Devices = 4585. B5D6 (6), Applicable Devices = 4680. B5D6 (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D6 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B5D6 (6), Wake-up via WDT or Interrupt = uuuu uuuu. B5D5 (6), Applicable Devices = 2585. B5D5 (6), Applicable Devices = 2680. B5D5 (6), Applicable Devices = 4585. B5D5 (6), Applicable Devices = 4680. B5D5 (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D5 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB5D5 (6), Wake-up via WDT or Interrupt = uuuu uuuu. B5D4 (6), Applicable Devices = 2585. B5D4 (6), Applicable Devices = 2680. B5D4 (6), Applicable Devices = 4585. B5D4 (6), Applicable Devices = 4680. B5D4 (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B5D4 (6), Wake-up via WDT or Interrupt = uuuu uuuu. B5D3 (6), Applicable Devices = 2585. B5D3 (6), Applicable Devices = 2680. B5D3 (6), Applicable Devices = 4585. B5D3 (6), Applicable Devices = 4680. B5D3 (6), Power-on Reset, Brown-out Reset = xxxx",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nxxxx. B5D3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B5D3 (6), Wake-up via WDT or Interrupt = uuuu uuuu. B5D2 (6), Applicable Devices = 2585. B5D2 (6), Applicable Devices = 2680. B5D2 (6), Applicable Devices = 4585. B5D2 (6), Applicable Devices = 4680. B5D2 (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B5D2 (6), Wake-up via WDT or Interrupt = uuuu uuuu. B5D1 (6), Applicable Devices = 2585. B5D1 (6), Applicable Devices = 2680. B5D1 (6), Applicable Devices = 4585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB5D1 (6), Applicable Devices = 4680. B5D1 (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B5D1 (6), Wake-up via WDT or Interrupt = uuuu uuuu. B5D0 (6), Applicable Devices = 2585. B5D0 (6), Applicable Devices = 2680. B5D0 (6), Applicable Devices = 4585. B5D0 (6), Applicable Devices = 4680. B5D0 (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B5D0 (6), Wake-up via WDT or Interrupt = uuuu uuuu. B5DLC (6),",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = 2585. B5DLC (6), Applicable Devices = 2680. B5DLC (6), Applicable Devices = 4585. B5DLC (6), Applicable Devices = 4680. B5DLC (6), Power-on Reset, Brown-out Reset = -xxx xxxx. B5DLC (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -uuu uuuu. B5DLC (6), Wake-up via WDT or Interrupt = -uuu uuuu. B5EIDL (6), Applicable Devices = 2585. B5EIDL (6), Applicable Devices = 2680. B5EIDL (6), Applicable Devices = 4585. B5EIDL (6), Applicable Devices = 4680. B5EIDL (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B5EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. B5EIDL (6), Wake-up via WDT or Interrupt = uuuu uuuu. B5EIDH (6), Applicable Devices = 2585. B5EIDH (6), Applicable Devices = 2680. B5EIDH (6), Applicable Devices = 4585. B5EIDH (6), Applicable Devices = 4680. B5EIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B5EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B5EIDH (6), Wake-up via WDT or Interrupt = uuuu uuuu. B5SIDL (6), Applicable Devices = 2585. B5SIDL (6), Applicable Devices = 2680. B5SIDL (6), Applicable Devices = 4585. B5SIDL (6), Applicable Devices = 4680. B5SIDL (6), Power-on Reset, Brown-out Reset",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= xxxx x-xx. B5SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu u-uu. B5SIDL (6), Wake-up via WDT or Interrupt = uuuu u-uu. B5SIDH (6), Applicable Devices = 2585. B5SIDH (6), Applicable Devices = 2680. B5SIDH (6), Applicable Devices = 4585. B5SIDH (6), Applicable Devices = 4680. B5SIDH (6), Power-on Reset, Brown-out Reset = xxxx x-xx. B5SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu u-uu. B5SIDH (6), Wake-up via WDT or Interrupt = uuuu u-uu. B5CON (6), Applicable Devices = 2585. B5CON (6), Applicable Devices = 2680. B5CON (6), Applicable Devices = .",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB5CON (6), Applicable Devices = . B5CON (6), Power-on Reset, Brown-out Reset = 0000 0000. B5CON (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000 0000. B5CON (6), Wake-up via WDT or Interrupt = uuuu uuuu. (6), Applicable Devices = . (6), Applicable Devices = . (6), Applicable Devices = 4585. (6), Applicable Devices = 4680. (6), Power-on Reset, Brown-out Reset = . (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. (6), Wake-up via WDT or Interrupt = uuuu uuuu. B4D7, Applicable Devices = 2585. B4D7, Applicable Devices = 2680 4585. B4D7, Applicable Devices = . B4D7, Applicable Devices = 4680. B4D7, Power-on Reset,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = xxxx xxxx. B4D7, MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . B4D7, Wake-up via WDT or Interrupt = uuuu uuuu. B4D6 (6), Applicable Devices = 2585 2585. B4D6 (6), Applicable Devices = 2680. B4D6 (6), Applicable Devices = 4585. B4D6 (6), Applicable Devices = 4680. B4D6 (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D6 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B4D6 (6), Wake-up via WDT or Interrupt = . B4D5 (6), Applicable Devices = . B4D5 (6), Applicable Devices = 2680. B4D5 (6), Applicable Devices = 4585. B4D5 (6), Applicable Devices = 4680.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB4D5 (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D5 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B4D5 (6), Wake-up via WDT or Interrupt = uuuu uuuu. B4D4 (6), Applicable Devices = 2585. B4D4 (6), Applicable Devices = 2680 4585. B4D4 (6), Applicable Devices = . B4D4 (6), Applicable Devices = 4680. B4D4 (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B4D4 (6), Wake-up via WDT or Interrupt = uuuu uuuu. B4D3 (6), Applicable Devices = 2585. B4D3 (6),",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = 2680. B4D3 (6), Applicable Devices = 4585 4680. B4D3 (6), Applicable Devices = 4680. B4D3 (6), Power-on Reset, Brown-out Reset = xxxx xxxx xxxx xxxx. B4D3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu uuuu uuuu. B4D3 (6), Wake-up via WDT or Interrupt = uuuu uuuu uuuu uuuu. B4D2 (6), Applicable Devices = 2585. B4D2 (6), Applicable Devices = 2680. B4D2 (6), Applicable Devices = 4585. B4D2 (6), Applicable Devices = . B4D2 (6), Power-on Reset, Brown-out Reset = . B4D2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . B4D2",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Wake-up via WDT or Interrupt = . B4D1 (6) (6), Applicable Devices = 2585. B4D1 (6) (6), Applicable Devices = 2680. B4D1 (6) (6), Applicable Devices = 4585. B4D1 (6) (6), Applicable Devices = 4680. B4D1 (6) (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D1 (6) (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B4D1 (6) (6), Wake-up via WDT or Interrupt = uuuu uuuu. B4D0 B4EIDL (6), Applicable Devices = 2585 2585. B4D0 B4EIDL (6), Applicable Devices = 2680. B4D0 B4EIDL (6), Applicable Devices = 4585 4680 4585. B4D0 B4EIDL",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Applicable Devices = 4680. B4D0 B4EIDL (6), Power-on Reset, Brown-out Reset = xxxx xxxx -xxx xxxx. B4D0 B4EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B4D0 B4EIDL (6), Wake-up via WDT or Interrupt = uuuu uuuu -uuu uuuu uuuu uuuu. B4DLC (6), Applicable Devices = 2585. B4DLC (6), Applicable Devices = 2680 2680. B4DLC (6), Applicable Devices = 4585. B4DLC (6), Applicable Devices = 4680. B4DLC (6), Power-on Reset, Brown-out Reset = xxxx xxxx. B4DLC (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -uuu uuuu uuuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. B4DLC (6), Wake-up via WDT or Interrupt = \nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB4EIDH (6), Applicable Devices = 2585. B4EIDH (6), Applicable Devices = 2680. B4EIDH (6), Applicable Devices = 4585. B4EIDH (6), Applicable Devices = 4680. B4EIDH (6), Power-on Reset, Brown-out Reset = xxxx. B4EIDH (6), Power-on Reset, Brown-out Reset = xxxx. B4EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B4EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B4EIDH (6), Wake-up via WDT or Interrupt = uuuu. B4EIDH (6), Wake-up via WDT or Interrupt = uuuu. B4SIDL (6), Applicable Devices = 2585. B4SIDL (6), Applicable Devices = 2680. B4SIDL (6), Applicable Devices = 4585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB4SIDL (6), Applicable Devices = 4680. B4SIDL (6), Power-on Reset, Brown-out Reset = xxxx. B4SIDL (6), Power-on Reset, Brown-out Reset = x-xx. B4SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B4SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = u-uu. B4SIDL (6), Wake-up via WDT or Interrupt = uuuu. B4SIDL (6), Wake-up via WDT or Interrupt = u-uu. B4SIDH (6), Applicable Devices = 2585. B4SIDH (6), Applicable Devices = 2680. B4SIDH (6), Applicable Devices = 4585. B4SIDH (6), Applicable Devices = 4680. B4SIDH (6), Power-on Reset, Brown-out Reset = xxxx. B4SIDH",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Power-on Reset, Brown-out Reset = xxxx. B4SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B4SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B4SIDH (6), Wake-up via WDT or Interrupt = uuuu. B4SIDH (6), Wake-up via WDT or Interrupt = uuuu. B4CON (6), Applicable Devices = 2585. B4CON (6), Applicable Devices = 2680. B4CON (6), Applicable Devices = 4585. B4CON (6), Applicable Devices = 4680. B4CON (6), Power-on Reset, Brown-out Reset = 0000. B4CON (6), Power-on Reset, Brown-out Reset = 0000. B4CON (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. B4CON",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. B4CON (6), Wake-up via WDT or Interrupt = uuuu. B4CON (6), Wake-up via WDT or Interrupt = uuuu. B3D7 (6), Applicable Devices = 2585. B3D7 (6), Applicable Devices = 2680. B3D7 (6), Applicable Devices = 4585. B3D7 (6), Applicable Devices = 4680. B3D7 (6), Power-on Reset, Brown-out Reset = xxxx. B3D7 (6), Power-on Reset, Brown-out Reset = xxxx. B3D7 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D7 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D7 (6), Wake-up via WDT or Interrupt = uuuu. B3D7 (6),",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu. B3D6 (6), Applicable Devices = 2585. B3D6 (6), Applicable Devices = 2680. B3D6 (6), Applicable Devices = 4585. B3D6 (6), Applicable Devices = 4680. B3D6 (6), Power-on Reset, Brown-out Reset = xxxx. B3D6 (6), Power-on Reset, Brown-out Reset = xxxx. B3D6 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D6 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D6 (6), Wake-up via WDT or Interrupt = uuuu. B3D6 (6), Wake-up via WDT or Interrupt = uuuu. B3D5 (6), Applicable Devices = 2585. B3D5 (6), Applicable Devices = 2680. B3D5 (6), Applicable Devices =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n4585. B3D5 (6), Applicable Devices = 4680. B3D5 (6), Power-on Reset, Brown-out Reset = xxxx. B3D5 (6), Power-on Reset, Brown-out Reset = xxxx. B3D5 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D5 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D5 (6), Wake-up via WDT or Interrupt = uuuu. B3D5 (6), Wake-up via WDT or Interrupt = uuuu. B3D4 (6), Applicable Devices = 2585. B3D4 (6), Applicable Devices = 2680. B3D4 (6), Applicable Devices = 4585. B3D4 (6), Applicable Devices = 4680. B3D4 (6), Power-on Reset, Brown-out Reset = xxxx. B3D4 (6), Power-on Reset, Brown-out Reset",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= xxxx. B3D4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D4 (6), Wake-up via WDT or Interrupt = uuuu. B3D4 (6), Wake-up via WDT or Interrupt = uuuu. B3D3 (6), Applicable Devices = 2585. B3D3 (6), Applicable Devices = 2680. B3D3 (6), Applicable Devices = 4585. B3D3 (6), Applicable Devices = 4680. B3D3 (6), Power-on Reset, Brown-out Reset = xxxx. B3D3 (6), Power-on Reset, Brown-out Reset = xxxx. B3D3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = uuuu. B3D3 (6), Wake-up via WDT or Interrupt = uuuu. B3D3 (6), Wake-up via WDT or Interrupt = uuuu. B3D2 (6), Applicable Devices = 2585. B3D2 (6), Applicable Devices = 2680. B3D2 (6), Applicable Devices = 4585. B3D2 (6), Applicable Devices = 4680. B3D2 (6), Power-on Reset, Brown-out Reset = xxxx. B3D2 (6), Power-on Reset, Brown-out Reset = xxxx. B3D2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D2 (6), Wake-up via WDT or Interrupt = uuuu. B3D2 (6), Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB3D1 (6), Applicable Devices = 2585. B3D1 (6), Applicable Devices = 2680. B3D1 (6), Applicable Devices = 4585. B3D1 (6), Applicable Devices = 4680. B3D1 (6), Power-on Reset, Brown-out Reset = xxxx. B3D1 (6), Power-on Reset, Brown-out Reset = xxxx. B3D1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D1 (6), Wake-up via WDT or Interrupt = uuuu. B3D1 (6), Wake-up via WDT or Interrupt = uuuu. B3D0 (6), Applicable Devices = 2585. B3D0 (6), Applicable Devices = 2680. B3D0 (6), Applicable Devices = 4585. B3D0 (6), Applicable Devices = 4680.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB3D0 (6), Power-on Reset, Brown-out Reset = xxxx. B3D0 (6), Power-on Reset, Brown-out Reset = xxxx. B3D0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3D0 (6), Wake-up via WDT or Interrupt = uuuu. B3D0 (6), Wake-up via WDT or Interrupt = uuuu. B3DLC (6), Applicable Devices = 2585. B3DLC (6), Applicable Devices = 2680. B3DLC (6), Applicable Devices = 4585. B3DLC (6), Applicable Devices = 4680. B3DLC (6), Power-on Reset, Brown-out Reset = -xxx. B3DLC (6), Power-on Reset, Brown-out Reset = xxxx. B3DLC (6), MCLR",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets, WDT Reset, RESET Instruction, Stack Resets = -uuu. B3DLC (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3DLC (6), Wake-up via WDT or Interrupt = -uuu. B3DLC (6), Wake-up via WDT or Interrupt = uuuu. B3EIDL (6), Applicable Devices = 2585. B3EIDL (6), Applicable Devices = 2680. B3EIDL (6), Applicable Devices = 4585. B3EIDL (6), Applicable Devices = 4680. B3EIDL (6), Power-on Reset, Brown-out Reset = xxxx. B3EIDL (6), Power-on Reset, Brown-out Reset = xxxx. B3EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. B3EIDL (6), Wake-up via WDT or Interrupt = uuuu. B3EIDL (6), Wake-up via WDT or Interrupt = uuuu. B3EIDH (6), Applicable Devices = 2585. B3EIDH (6), Applicable Devices = 2680. B3EIDH (6), Applicable Devices = 4585. B3EIDH (6), Applicable Devices = 4680. B3EIDH (6), Power-on Reset, Brown-out Reset = xxxx. B3EIDH (6), Power-on Reset, Brown-out Reset = xxxx. B3EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3EIDH (6), Wake-up via WDT or Interrupt = uuuu. B3EIDH (6), Wake-up via WDT or",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInterrupt = uuuu. B3SIDL (6), Applicable Devices = 2585. B3SIDL (6), Applicable Devices = 2680. B3SIDL (6), Applicable Devices = 4585. B3SIDL (6), Applicable Devices = 4680. B3SIDL (6), Power-on Reset, Brown-out Reset = xxxx. B3SIDL (6), Power-on Reset, Brown-out Reset = x-xx. B3SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = u-uu. B3SIDL (6), Wake-up via WDT or Interrupt = uuuu. B3SIDL (6), Wake-up via WDT or Interrupt = u-uu. B3SIDH (6), Applicable Devices = 2585. B3SIDH (6), Applicable Devices = 2680. B3SIDH",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Applicable Devices = 4585. B3SIDH (6), Applicable Devices = 4680. B3SIDH (6), Power-on Reset, Brown-out Reset = xxxx. B3SIDH (6), Power-on Reset, Brown-out Reset = xxxx. B3SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B3SIDH (6), Wake-up via WDT or Interrupt = uuuu. B3SIDH (6), Wake-up via WDT or Interrupt = uuuu. B3CON (6), Applicable Devices = 2585. B3CON (6), Applicable Devices = 2680. B3CON (6), Applicable Devices = 4585. B3CON (6), Applicable Devices = 4680. B3CON (6), Power-on Reset, Brown-out Reset = 0000.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB3CON (6), Power-on Reset, Brown-out Reset = 0000. B3CON (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. B3CON (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. B3CON (6), Wake-up via WDT or Interrupt = uuuu. B3CON (6), Wake-up via WDT or Interrupt = uuuu. B2D7 (6), Applicable Devices = 2585. B2D7 (6), Applicable Devices = 2680. B2D7 (6), Applicable Devices = 4585. B2D7 (6), Applicable Devices = 4680. B2D7 (6), Power-on Reset, Brown-out Reset = xxxx. B2D7 (6), Power-on Reset, Brown-out Reset = xxxx. B2D7 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB2D7 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D7 (6), Wake-up via WDT or Interrupt = uuuu. B2D7 (6), Wake-up via WDT or Interrupt = uuuu. B2D6 (6), Applicable Devices = 2585. B2D6 (6), Applicable Devices = 2680. B2D6 (6), Applicable Devices = 4585. B2D6 (6), Applicable Devices = 4680. B2D6 (6), Power-on Reset, Brown-out Reset = xxxx. B2D6 (6), Power-on Reset, Brown-out Reset = xxxx. B2D6 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D6 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D6 (6), Wake-up via",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu. B2D6 (6), Wake-up via WDT or Interrupt = uuuu. B2D5 (6), Applicable Devices = 2585. B2D5 (6), Applicable Devices = 2680. B2D5 (6), Applicable Devices = 4585. B2D5 (6), Applicable Devices = 4680. B2D5 (6), Power-on Reset, Brown-out Reset = xxxx. B2D5 (6), Power-on Reset, Brown-out Reset = xxxx. B2D5 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D5 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D5 (6), Wake-up via WDT or Interrupt = uuuu. B2D5 (6), Wake-up via WDT or Interrupt = uuuu. B2D4 (6), Applicable Devices",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 2585. B2D4 (6), Applicable Devices = 2680. B2D4 (6), Applicable Devices = 4585. B2D4 (6), Applicable Devices = 4680. B2D4 (6), Power-on Reset, Brown-out Reset = xxxx. B2D4 (6), Power-on Reset, Brown-out Reset = xxxx. B2D4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D4 (6), Wake-up via WDT or Interrupt = uuuu. B2D4 (6), Wake-up via WDT or Interrupt = uuuu. B2D3 (6), Applicable Devices = 2585. B2D3 (6), Applicable Devices = 2680. B2D3 (6), Applicable Devices = 4585. B2D3 (6), Applicable Devices",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 4680. B2D3 (6), Power-on Reset, Brown-out Reset = xxxx. B2D3 (6), Power-on Reset, Brown-out Reset = xxxx. B2D3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D3 (6), Wake-up via WDT or Interrupt = uuuu. B2D3 (6), Wake-up via WDT or Interrupt = uuuu. B2D2 (6), Applicable Devices = 2585. B2D2 (6), Applicable Devices = 2680. B2D2 (6), Applicable Devices = 4585. B2D2 (6), Applicable Devices = 4680. B2D2 (6), Power-on Reset, Brown-out Reset = xxxx. B2D2 (6), Power-on Reset, Brown-out Reset",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= xxxx. B2D2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D2 (6), Wake-up via WDT or Interrupt = uuuu. B2D2 (6), Wake-up via WDT or Interrupt = uuuu. B2D1 (6), Applicable Devices = 2585. B2D1 (6), Applicable Devices = 2680. B2D1 (6), Applicable Devices = 4585. B2D1 (6), Applicable Devices = 4680. B2D1 (6), Power-on Reset, Brown-out Reset = xxxx. B2D1 (6), Power-on Reset, Brown-out Reset = xxxx. B2D1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D1 (6),",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D1 (6), Wake-up via WDT or Interrupt = uuuu. B2D1 (6), Wake-up via WDT or Interrupt = uuuu. B2D0 (6), Applicable Devices = 2585. B2D0 (6), Applicable Devices = 2680. B2D0 (6), Applicable Devices = 4585. B2D0 (6), Applicable Devices = 4680. B2D0 (6), Power-on Reset, Brown-out Reset = xxxx. B2D0 (6), Power-on Reset, Brown-out Reset = xxxx. B2D0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2D0 (6), Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. B2D0 (6), Wake-up via WDT or Interrupt = uuuu. B2DLC (6), Applicable Devices = 2585. B2DLC (6), Applicable Devices = 2680. B2DLC (6), Applicable Devices = 4585. B2DLC (6), Applicable Devices = 4680. B2DLC (6), Power-on Reset, Brown-out Reset = -xxx. B2DLC (6), Power-on Reset, Brown-out Reset = xxxx. B2DLC (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -uuu. B2DLC (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2DLC (6), Wake-up via WDT or Interrupt = -uuu. B2DLC (6), Wake-up via WDT or Interrupt = uuuu. B2EIDL (6), Applicable Devices = 2585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB2EIDL (6), Applicable Devices = 2680. B2EIDL (6), Applicable Devices = 4585. B2EIDL (6), Applicable Devices = 4680. B2EIDL (6), Power-on Reset, Brown-out Reset = xxxx. B2EIDL (6), Power-on Reset, Brown-out Reset = xxxx. B2EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2EIDL (6), Wake-up via WDT or Interrupt = uuuu. B2EIDL (6), Wake-up via WDT or Interrupt = uuuu. B2EIDH (6), Applicable Devices = 2585. B2EIDH (6), Applicable Devices = 2680. B2EIDH (6), Applicable Devices = 4585. B2EIDH (6), Applicable Devices = 4680.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB2EIDH (6), Power-on Reset, Brown-out Reset = xxxx. B2EIDH (6), Power-on Reset, Brown-out Reset = xxxx. B2EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B2EIDH (6), Wake-up via WDT or Interrupt = uuuu. B2EIDH (6), Wake-up via WDT or Interrupt = uuuu. B2SIDL (6) B2SIDH (6), Applicable Devices = 2585. B2SIDL (6) B2SIDH (6), Applicable Devices = 2680. B2SIDL (6) B2SIDH (6), Applicable Devices = 4585. B2SIDL (6) B2SIDH (6), Applicable Devices = 4680. B2SIDL (6) B2SIDH",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Power-on Reset, Brown-out Reset = xxxx. B2SIDL (6) B2SIDH (6), Power-on Reset, Brown-out Reset = x-xx. B2SIDL (6) B2SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. B2SIDL (6) B2SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = u-uu uuuu. B2SIDL (6) B2SIDH (6), Wake-up via WDT or Interrupt = uuuu uuuu. B2SIDL (6) B2SIDH (6), Wake-up via WDT or Interrupt = u-uu. , Applicable Devices = 2585. , Applicable Devices = 2680. , Applicable Devices = 4585. , Applicable Devices = 4680. , Power-on Reset, Brown-out Reset = xxxx. , Power-on Reset, Brown-out Reset =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nxxxx. , MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . , MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . , Wake-up via WDT or Interrupt = . , Wake-up via WDT or Interrupt = uuuu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB2CON (6), Applicable Devices = 2585. B2CON (6), Applicable Devices = 2680. B2CON (6), Applicable Devices = 4585. B2CON (6), Applicable Devices = 4680. B2CON (6), Power-on Reset, Brown-out Reset = 0000. B2CON (6), Power-on Reset, Brown-out Reset = 0000. B2CON (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. B2CON (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. B2CON (6), Wake-up via WDT or Interrupt = uuuu. B2CON (6), Wake-up via WDT or Interrupt = uuuu. B1D7 (6), Applicable Devices = 2585. B1D7 (6), Applicable Devices = 2680. B1D7 (6), Applicable Devices = 4585. B1D7 (6), Applicable Devices = 4680. B1D7",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Power-on Reset, Brown-out Reset = xxxx. B1D7 (6), Power-on Reset, Brown-out Reset = xxxx. B1D7 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D7 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D7 (6), Wake-up via WDT or Interrupt = uuuu. B1D7 (6), Wake-up via WDT or Interrupt = uuuu. B1D6 (6), Applicable Devices = 2585. B1D6 (6), Applicable Devices = 2680. B1D6 (6), Applicable Devices = 4585. B1D6 (6), Applicable Devices = 4680. B1D6 (6), Power-on Reset, Brown-out Reset = xxxx. B1D6 (6), Power-on Reset, Brown-out Reset = xxxx. B1D6 (6), MCLR Resets, WDT",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, RESET Instruction, Stack Resets = uuuu. B1D6 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D6 (6), Wake-up via WDT or Interrupt = uuuu. B1D6 (6), Wake-up via WDT or Interrupt = uuuu. B1D5 (6), Applicable Devices = 2585. B1D5 (6), Applicable Devices = 2680. B1D5 (6), Applicable Devices = 4585. B1D5 (6), Applicable Devices = 4680. B1D5 (6), Power-on Reset, Brown-out Reset = xxxx. B1D5 (6), Power-on Reset, Brown-out Reset = xxxx. B1D5 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D5 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D5 (6), Wake-up",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nvia WDT or Interrupt = uuuu. B1D5 (6), Wake-up via WDT or Interrupt = uuuu. B1D4 (6), Applicable Devices = 2585. B1D4 (6), Applicable Devices = 2680. B1D4 (6), Applicable Devices = 4585. B1D4 (6), Applicable Devices = 4680. B1D4 (6), Power-on Reset, Brown-out Reset = xxxx. B1D4 (6), Power-on Reset, Brown-out Reset = xxxx. B1D4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D4 (6), Wake-up via WDT or Interrupt = uuuu. B1D4 (6), Wake-up via WDT or Interrupt = uuuu. B1D3 (6), Applicable Devices = 2585. B1D3 (6),",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = 2680. B1D3 (6), Applicable Devices = 4585. B1D3 (6), Applicable Devices = 4680. B1D3 (6), Power-on Reset, Brown-out Reset = xxxx. B1D3 (6), Power-on Reset, Brown-out Reset = xxxx. B1D3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D3 (6), Wake-up via WDT or Interrupt = uuuu. B1D3 (6), Wake-up via WDT or Interrupt = uuuu. B1D2 (6), Applicable Devices = 2585. B1D2 (6), Applicable Devices = 2680. B1D2 (6), Applicable Devices = 4585. B1D2 (6), Applicable Devices = 4680. B1D2 (6), Power-on Reset, Brown-out Reset = xxxx.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB1D2 (6), Power-on Reset, Brown-out Reset = xxxx. B1D2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D2 (6), Wake-up via WDT or Interrupt = uuuu. B1D2 (6), Wake-up via WDT or Interrupt = uuuu. B1D1 (6), Applicable Devices = 2585. B1D1 (6), Applicable Devices = 2680. B1D1 (6), Applicable Devices = 4585. B1D1 (6), Applicable Devices = 4680. B1D1 (6), Power-on Reset, Brown-out Reset = xxxx. B1D1 (6), Power-on Reset, Brown-out Reset = xxxx. B1D1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D1",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D1 (6), Wake-up via WDT or Interrupt = uuuu. B1D1 (6), Wake-up via WDT or Interrupt = uuuu. B1D0 (6), Applicable Devices = 2585. B1D0 (6), Applicable Devices = 2680. B1D0 (6), Applicable Devices = 4585. B1D0 (6), Applicable Devices = 4680. B1D0 (6), Power-on Reset, Brown-out Reset = xxxx. B1D0 (6), Power-on Reset, Brown-out Reset = xxxx. B1D0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1D0 (6), Wake-up via WDT or Interrupt = uuuu. B1D0",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Wake-up via WDT or Interrupt = uuuu. B1DLC (6), Applicable Devices = 2585. B1DLC (6), Applicable Devices = 2680. B1DLC (6), Applicable Devices = 4585. B1DLC (6), Applicable Devices = 4680. B1DLC (6), Power-on Reset, Brown-out Reset = -xxx. B1DLC (6), Power-on Reset, Brown-out Reset = xxxx. B1DLC (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -uuu. B1DLC (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1DLC (6), Wake-up via WDT or Interrupt = -uuu. B1DLC (6), Wake-up via WDT or Interrupt = uuuu. B1EIDL (6), Applicable Devices = 2585. B1EIDL (6), Applicable Devices = 2680. B1EIDL (6),",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = 4585. B1EIDL (6), Applicable Devices = 4680. B1EIDL (6), Power-on Reset, Brown-out Reset = xxxx. B1EIDL (6), Power-on Reset, Brown-out Reset = xxxx. B1EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1EIDL (6), Wake-up via WDT or Interrupt = uuuu. B1EIDL (6), Wake-up via WDT or Interrupt = uuuu. B1EIDH (6), Applicable Devices = 2585. B1EIDH (6), Applicable Devices = 2680. B1EIDH (6), Applicable Devices = 4585. B1EIDH (6), Applicable Devices = 4680. B1EIDH (6), Power-on Reset, Brown-out Reset = xxxx. B1EIDH (6), Power-on Reset,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = xxxx. B1EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1EIDH (6), Wake-up via WDT or Interrupt = uuuu. B1EIDH (6), Wake-up via WDT or Interrupt = uuuu. B1SIDL (6), Applicable Devices = 2585. B1SIDL (6), Applicable Devices = 2680. B1SIDL (6), Applicable Devices = 4585. B1SIDL (6), Applicable Devices = 4680. B1SIDL (6), Power-on Reset, Brown-out Reset = xxxx. B1SIDL (6), Power-on Reset, Brown-out Reset = x-xx. B1SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1SIDL (6), MCLR Resets, WDT",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, RESET Instruction, Stack Resets = u-uu. B1SIDL (6), Wake-up via WDT or Interrupt = uuuu. B1SIDL (6), Wake-up via WDT or Interrupt = u-uu. B1SIDH (6), Applicable Devices = 2585. B1SIDH (6), Applicable Devices = 2680. B1SIDH (6), Applicable Devices = 4585. B1SIDH (6), Applicable Devices = 4680. B1SIDH (6), Power-on Reset, Brown-out Reset = xxxx. B1SIDH (6), Power-on Reset, Brown-out Reset = xxxx. B1SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B1SIDH (6), Wake-up via WDT or Interrupt = uuuu. B1SIDH (6), Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. B1CON (6), Applicable Devices = 2585. B1CON (6), Applicable Devices = 2680. B1CON (6), Applicable Devices = 4585. B1CON (6), Applicable Devices = 4680. B1CON (6), Power-on Reset, Brown-out Reset = 0000. B1CON (6), Power-on Reset, Brown-out Reset = 0000. B1CON (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. B1CON (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. B1CON (6), Wake-up via WDT or Interrupt = uuuu. B1CON (6), Wake-up via WDT or Interrupt = uuuu. B0D7 (6), Applicable Devices = 2585. B0D7 (6), Applicable Devices = 2680. B0D7 (6), Applicable Devices = 4585. B0D7 (6), Applicable Devices = 4680. B0D7",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Power-on Reset, Brown-out Reset = xxxx. B0D7 (6), Power-on Reset, Brown-out Reset = xxxx. B0D7 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D7 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D7 (6), Wake-up via WDT or Interrupt = uuuu. B0D7 (6), Wake-up via WDT or Interrupt = uuuu. B0D6 (6), Applicable Devices = 2585. B0D6 (6), Applicable Devices = 2680. B0D6 (6), Applicable Devices = 4585. B0D6 (6), Applicable Devices = 4680. B0D6 (6), Power-on Reset, Brown-out Reset = xxxx. B0D6 (6), Power-on Reset, Brown-out Reset = xxxx. B0D6",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D6 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D6 (6), Wake-up via WDT or Interrupt = uuuu. B0D6 (6), Wake-up via WDT or Interrupt = uuuu. B0D5 (6), Applicable Devices = 2585. B0D5 (6), Applicable Devices = 2680. B0D5 (6), Applicable Devices = 4585. B0D5 (6), Applicable Devices = 4680. B0D5 (6), Power-on Reset, Brown-out Reset = xxxx. B0D5 (6), Power-on Reset, Brown-out Reset = xxxx. B0D5 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D5 (6), MCLR Resets, WDT Reset,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRESET Instruction, Stack Resets = uuuu. B0D5 (6), Wake-up via WDT or Interrupt = uuuu. B0D5 (6), Wake-up via WDT or Interrupt = uuuu. B0D4 (6), Applicable Devices = 2585. B0D4 (6), Applicable Devices = 2680. B0D4 (6), Applicable Devices = 4585. B0D4 (6), Applicable Devices = 4680. B0D4 (6), Power-on Reset, Brown-out Reset = xxxx. B0D4 (6), Power-on Reset, Brown-out Reset = xxxx. B0D4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D4 (6), Wake-up via WDT or Interrupt = uuuu. B0D4 (6),",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu. B0D3 (6), Applicable Devices = 2585. B0D3 (6), Applicable Devices = 2680. B0D3 (6), Applicable Devices = 4585. B0D3 (6), Applicable Devices = 4680. B0D3 (6), Power-on Reset, Brown-out Reset = xxxx. B0D3 (6), Power-on Reset, Brown-out Reset = xxxx. B0D3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D3 (6), Wake-up via WDT or Interrupt = uuuu. B0D3 (6), Wake-up via WDT or Interrupt = uuuu. B0D2 (6), Applicable Devices = 2585. B0D2 (6), Applicable Devices = 2680.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB0D2 (6), Applicable Devices = 4585. B0D2 (6), Applicable Devices = 4680. B0D2 (6), Power-on Reset, Brown-out Reset = xxxx. B0D2 (6), Power-on Reset, Brown-out Reset = xxxx. B0D2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D2 (6), Wake-up via WDT or Interrupt = uuuu. B0D2 (6), Wake-up via WDT or Interrupt = uuuu. B0D1 (6), Applicable Devices = 2585. B0D1 (6), Applicable Devices = 2680. B0D1 (6), Applicable Devices = 4585. B0D1 (6), Applicable Devices = 4680. B0D1 (6), Power-on Reset,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = xxxx. B0D1 (6), Power-on Reset, Brown-out Reset = xxxx. B0D1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D1 (6), Wake-up via WDT or Interrupt = uuuu. B0D1 (6), Wake-up via WDT or Interrupt = uuuu. B0D0 (6), Applicable Devices = 2585. B0D0 (6), Applicable Devices = 2680. B0D0 (6), Applicable Devices = 4585. B0D0 (6), Applicable Devices = 4680. B0D0 (6), Power-on Reset, Brown-out Reset = xxxx. B0D0 (6), Power-on Reset, Brown-out Reset = xxxx. B0D0 (6), MCLR Resets,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset, RESET Instruction, Stack Resets = uuuu. B0D0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0D0 (6), Wake-up via WDT or Interrupt = uuuu. B0D0 (6), Wake-up via WDT or Interrupt = uuuu. B0DLC (6), Applicable Devices = 2585. B0DLC (6), Applicable Devices = 2680. B0DLC (6), Applicable Devices = 4585. B0DLC (6), Applicable Devices = 4680. B0DLC (6), Power-on Reset, Brown-out Reset = -xxx. B0DLC (6), Power-on Reset, Brown-out Reset = xxxx. B0DLC (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = -uuu. B0DLC (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. B0DLC (6), Wake-up via WDT or Interrupt = -uuu. B0DLC (6), Wake-up via WDT or Interrupt = uuuu. B0EIDL (6), Applicable Devices = 2585. B0EIDL (6), Applicable Devices = 2680. B0EIDL (6), Applicable Devices = 4585. B0EIDL (6), Applicable Devices = 4680. B0EIDL (6), Power-on Reset, Brown-out Reset = xxxx. B0EIDL (6), Power-on Reset, Brown-out Reset = xxxx. B0EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0EIDL (6), Wake-up via WDT or Interrupt = uuuu. B0EIDL (6), Wake-up via WDT or",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInterrupt = uuuu. B0EIDH (6), Applicable Devices = 2585. B0EIDH (6), Applicable Devices = 2680. B0EIDH (6), Applicable Devices = 4585. B0EIDH (6), Applicable Devices = 4680. B0EIDH (6), Power-on Reset, Brown-out Reset = xxxx. B0EIDH (6), Power-on Reset, Brown-out Reset = xxxx. B0EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0EIDH (6), Wake-up via WDT or Interrupt = uuuu. B0EIDH (6), Wake-up via WDT or Interrupt = uuuu. B0SIDL (6), Applicable Devices = 2585. B0SIDL (6), Applicable Devices = 2680. B0SIDL",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Applicable Devices = 4585. B0SIDL (6), Applicable Devices = 4680. B0SIDL (6), Power-on Reset, Brown-out Reset = xxxx. B0SIDL (6), Power-on Reset, Brown-out Reset = x-xx. B0SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = u-uu. B0SIDL (6), Wake-up via WDT or Interrupt = uuuu. B0SIDL (6), Wake-up via WDT or Interrupt = u-uu. B0SIDH (6), Applicable Devices = 2585. B0SIDH (6), Applicable Devices = 2680. B0SIDH (6), Applicable Devices = 4585. B0SIDH (6), Applicable Devices = 4680. B0SIDH (6), Power-on Reset, Brown-out Reset",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= xxxx. B0SIDH (6), Power-on Reset, Brown-out Reset = xxxx. B0SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu. B0SIDH (6), Wake-up via WDT or Interrupt = uuuu. B0SIDH (6), Wake-up via WDT or Interrupt = uuuu. B0CON (6), Applicable Devices = 2585. B0CON (6), Applicable Devices = 2680. B0CON (6), Applicable Devices = 4585. B0CON (6), Applicable Devices = 4680. B0CON (6), Power-on Reset, Brown-out Reset = 0000. B0CON (6), Power-on Reset, Brown-out Reset = 0000. B0CON (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000. B0CON (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = 0000. B0CON (6), Wake-up via WDT or Interrupt = uuuu. B0CON (6), Wake-up via WDT or Interrupt = uuuu. TXBIE BIE0 (6), Applicable Devices = 2585 2585. TXBIE BIE0 (6), Applicable Devices = 2680. TXBIE BIE0 (6), Applicable Devices = 4585. TXBIE BIE0 (6), Applicable Devices = 4680. TXBIE BIE0 (6), Power-on Reset, Brown-out Reset = ---0. TXBIE BIE0 (6), Power-on Reset, Brown-out Reset = 00--. TXBIE BIE0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = ---u 0000. TXBIE BIE0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uu--",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000. TXBIE BIE0 (6), Wake-up via WDT or Interrupt = ---u uuuu. TXBIE BIE0 (6), Wake-up via WDT or Interrupt = uu--. , Applicable Devices = . , Applicable Devices = 2680. , Applicable Devices = 4585. , Applicable Devices = 4680. , Power-on Reset, Brown-out Reset = 0000. , Power-on Reset, Brown-out Reset = 0000. , MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . , MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = . , Wake-up via WDT or Interrupt = . , Wake-up via WDT or Interrupt = uuuu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMSEL3 (6), Applicable Devices.2585 = 2585. MSEL3 (6), Applicable Devices.2680 = 2680. MSEL3 (6), Applicable Devices.4585 = 4585. MSEL3 (6), Applicable Devices.4680 = 4680. MSEL3 (6), Power-on Reset, Brown-out Reset.0000 = 0000. MSEL3 (6), Power-on Reset, Brown-out Reset.00-- = 0000. MSEL3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0000. MSEL3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. MSEL3 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. MSEL3 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. MSEL2 (6), Applicable Devices.2585 = 2585. MSEL2",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Applicable Devices.2680 = 2680. MSEL2 (6), Applicable Devices.4585 = 4585. MSEL2 (6), Applicable Devices.4680 = 4680. MSEL2 (6), Power-on Reset, Brown-out Reset.0000 = 0000. MSEL2 (6), Power-on Reset, Brown-out Reset.00-- = 0000. MSEL2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0000. MSEL2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. MSEL2 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. MSEL2 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. MSEL1 (6), Applicable Devices.2585 = 2585. MSEL1 (6), Applicable Devices.2680 = 2680. MSEL1 (6),",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices.4585 = 4585. MSEL1 (6), Applicable Devices.4680 = 4680. MSEL1 (6), Power-on Reset, Brown-out Reset.0000 = 0000. MSEL1 (6), Power-on Reset, Brown-out Reset.00-- = 0101. MSEL1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0000. MSEL1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0101. MSEL1 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. MSEL1 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. MSEL0 (6), Applicable Devices.2585 = 2585. MSEL0 (6), Applicable Devices.2680 = 2680. MSEL0 (6), Applicable Devices.4585 = 4585. MSEL0 (6), Applicable",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices.4680 = 4680. MSEL0 (6), Power-on Reset, Brown-out Reset.0000 = 0101. MSEL0 (6), Power-on Reset, Brown-out Reset.00-- = 0000. MSEL0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0101. MSEL0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. MSEL0 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. MSEL0 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. SDFLC (6), Applicable Devices.2585 = 2585. SDFLC (6), Applicable Devices.2680 = 2680. SDFLC (6), Applicable Devices.4585 = 4585. SDFLC (6), Applicable Devices.4680 = 4680. SDFLC (6), Power-on Reset,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset.0000 = ---0. SDFLC (6), Power-on Reset, Brown-out Reset.00-- = 0000. SDFLC (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = ---0. SDFLC (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. SDFLC (6), Wake-up via WDT or Interrupt.uuuu = -u--. SDFLC (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXFCON1 (6), Applicable Devices.2585 = 2585. RXFCON1 (6), Applicable Devices.2680 = 2680. RXFCON1 (6), Applicable Devices.4585 = 4585. RXFCON1 (6), Applicable Devices.4680 = 4680. RXFCON1 (6), Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset.0000 = 0000. RXFCON1 (6), Power-on Reset, Brown-out Reset.00-- = 0000. RXFCON1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0000. RXFCON1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. RXFCON1 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXFCON1 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXFCON0 (6), Applicable Devices.2585 = 2585. RXFCON0 (6), Applicable Devices.2680 = 2680. RXFCON0 (6), Applicable Devices.4585 = 4585. RXFCON0 (6), Applicable Devices.4680 = 4680. RXFCON0 (6), Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset.0000 = 0000. RXFCON0 (6), Power-on Reset, Brown-out Reset.00-- = 0000. RXFCON0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0000. RXFCON0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. RXFCON0 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXFCON0 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXFBCON7 (6), Applicable Devices.2585 = 2585. RXFBCON7 (6), Applicable Devices.2680 = 2680. RXFBCON7 (6), Applicable Devices.4585 = 4585. RXFBCON7 (6), Applicable Devices.4680 = 4680. RXFBCON7 (6), Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset.0000 = 0000. RXFBCON7 (6), Power-on Reset, Brown-out Reset.00-- = 0000. RXFBCON7 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0000. RXFBCON7 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. RXFBCON7 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXFBCON7 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXFBCON6 (6), Applicable Devices.2585 = 2585. RXFBCON6 (6), Applicable Devices.2680 = 2680. RXFBCON6 (6), Applicable Devices.4585 = 4585. RXFBCON6 (6), Applicable Devices.4680 = 4680. RXFBCON6 (6), Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset.0000 = 0000. RXFBCON6 (6), Power-on Reset, Brown-out Reset.00-- = 0000. RXFBCON6 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0000. RXFBCON6 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. RXFBCON6 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXFBCON6 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXFBCON5 (6), Applicable Devices.2585 = 2585. RXFBCON5 (6), Applicable Devices.2680 = 2680. RXFBCON5 (6), Applicable Devices.4585 = 4585. RXFBCON5 (6), Applicable Devices.4680 = 4680. RXFBCON5 (6), Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset.0000 = 0000. RXFBCON5 (6), Power-on Reset, Brown-out Reset.00-- = 0000. RXFBCON5 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0000. RXFBCON5 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. RXFBCON5 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXFBCON5 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXFBCON4 (6), Applicable Devices.2585 = 2585. RXFBCON4 (6), Applicable Devices.2680 = 2680. RXFBCON4 (6), Applicable Devices.4585 = 4585. RXFBCON4 (6), Applicable Devices.4680 = 4680. RXFBCON4 (6), Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset.0000 = 0000. RXFBCON4 (6), Power-on Reset, Brown-out Reset.00-- = 0000. RXFBCON4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0000. RXFBCON4 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. RXFBCON4 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXFBCON4 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXFBCON3 (6), Applicable Devices.2585 = 2585. RXFBCON3 (6), Applicable Devices.2680 = 2680. RXFBCON3 (6), Applicable Devices.4585 = 4585. RXFBCON3 (6), Applicable Devices.4680 = 4680. RXFBCON3 (6), Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset.0000 = 0000. RXFBCON3 (6), Power-on Reset, Brown-out Reset.00-- = 0000. RXFBCON3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0000. RXFBCON3 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. RXFBCON3 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXFBCON3 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXFBCON2 (6), Applicable Devices.2585 = 2585. RXFBCON2 (6), Applicable Devices.2680 = 2680. RXFBCON2 (6), Applicable Devices.4585 = 4585. RXFBCON2 (6), Applicable Devices.4680 = 4680. RXFBCON2 (6), Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset.0000 = 0001. RXFBCON2 (6), Power-on Reset, Brown-out Reset.00-- = 0001. RXFBCON2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0001. RXFBCON2 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0001. RXFBCON2 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXFBCON2 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXFBCON1 (6), Applicable Devices.2585 = 2585. RXFBCON1 (6), Applicable Devices.2680 = 2680. RXFBCON1 (6), Applicable Devices.4585 = 4585. RXFBCON1 (6), Applicable Devices.4680 = 4680. RXFBCON1 (6), Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset.0000 = 0001. RXFBCON1 (6), Power-on Reset, Brown-out Reset.00-- = 0001. RXFBCON1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0001. RXFBCON1 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0001. RXFBCON1 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXFBCON1 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXFBCON0 (6), Applicable Devices.2585 = 2585. RXFBCON0 (6), Applicable Devices.2680 = 2680. RXFBCON0 (6), Applicable Devices.4585 = 4585. RXFBCON0 (6), Applicable Devices.4680 = 4680. RXFBCON0 (6), Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset.0000 = 0000. RXFBCON0 (6), Power-on Reset, Brown-out Reset.00-- = 0000. RXFBCON0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = 0000. RXFBCON0 (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = 0000. RXFBCON0 (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXFBCON0 (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXF15EIDL (6), Applicable Devices.2585 = 2585. RXF15EIDL (6), Applicable Devices.2680 = 2680. RXF15EIDL (6), Applicable Devices.4585 = 4585. RXF15EIDL (6), Applicable Devices.4680 = 4680. RXF15EIDL (6), Power-on",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset.0000 = xxxx. RXF15EIDL (6), Power-on Reset, Brown-out Reset.00-- = xxxx. RXF15EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuuu. RXF15EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = uuuu. RXF15EIDL (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXF15EIDL (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXF15EIDH (6), Applicable Devices.2585 = 2585. RXF15EIDH (6), Applicable Devices.2680 = 2680. RXF15EIDH (6), Applicable Devices.4585 = 4585. RXF15EIDH (6), Applicable Devices.4680 =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n4680. RXF15EIDH (6), Power-on Reset, Brown-out Reset.0000 = xxxx. RXF15EIDH (6), Power-on Reset, Brown-out Reset.00-- = xxxx. RXF15EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuuu. RXF15EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = uuuu. RXF15EIDH (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXF15EIDH (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXF15SIDL (6), Applicable Devices.2585 = 2585. RXF15SIDL (6), Applicable Devices.2680 = 2680. RXF15SIDL (6), Applicable Devices.4585 = 4585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF15SIDL (6), Applicable Devices.4680 = 4680. RXF15SIDL (6), Power-on Reset, Brown-out Reset.0000 = xxx-. RXF15SIDL (6), Power-on Reset, Brown-out Reset.00-- = x-xx. RXF15SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuu-. RXF15SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = u-uu. RXF15SIDL (6), Wake-up via WDT or Interrupt.uuuu = uuu-. RXF15SIDL (6), Wake-up via WDT or Interrupt.uu-- = u-uu. RXF15SIDH (6), Applicable Devices.2585 = 2585. RXF15SIDH (6), Applicable Devices.2680 = 2680.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF15SIDH (6), Applicable Devices.4585 = 4585. RXF15SIDH (6), Applicable Devices.4680 = 4680. RXF15SIDH (6), Power-on Reset, Brown-out Reset.0000 = xxxx. RXF15SIDH (6), Power-on Reset, Brown-out Reset.00-- = xxxx. RXF15SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuuu. RXF15SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = uuuu. RXF15SIDH (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXF15SIDH (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXF14EIDL (6), Applicable Devices.2585 = 2585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF14EIDL (6), Applicable Devices.2680 = 2680. RXF14EIDL (6), Applicable Devices.4585 = 4585. RXF14EIDL (6), Applicable Devices.4680 = 4680. RXF14EIDL (6), Power-on Reset, Brown-out Reset.0000 = xxxx. RXF14EIDL (6), Power-on Reset, Brown-out Reset.00-- = xxxx. RXF14EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuuu. RXF14EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = uuuu. RXF14EIDL (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXF14EIDL (6), Wake-up via WDT or Interrupt.uu-- = uuuu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF14EIDH (6), Applicable Devices.2585 = 2585. RXF14EIDH (6), Applicable Devices.2680 = 2680. RXF14EIDH (6), Applicable Devices.4585 = 4585. RXF14EIDH (6), Applicable Devices.4680 = 4680. RXF14EIDH (6), Power-on Reset, Brown-out Reset.0000 = xxxx. RXF14EIDH (6), Power-on Reset, Brown-out Reset.00-- = xxxx. RXF14EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuuu. RXF14EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = uuuu. RXF14EIDH (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXF14EIDH (6), Wake-up via",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt.uu-- = uuuu. RXF14SIDL (6), Applicable Devices.2585 = 2585. RXF14SIDL (6), Applicable Devices.2680 = 2680. RXF14SIDL (6), Applicable Devices.4585 = 4585. RXF14SIDL (6), Applicable Devices.4680 = 4680. RXF14SIDL (6), Power-on Reset, Brown-out Reset.0000 = xxx-. RXF14SIDL (6), Power-on Reset, Brown-out Reset.00-- = x-xx. RXF14SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuu-. RXF14SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = u-uu. RXF14SIDL (6), Wake-up via WDT or Interrupt.uuuu =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuu-. RXF14SIDL (6), Wake-up via WDT or Interrupt.uu-- = u-uu. RXF14SIDH (6), Applicable Devices.2585 = 2585. RXF14SIDH (6), Applicable Devices.2680 = 2680. RXF14SIDH (6), Applicable Devices.4585 = 4585. RXF14SIDH (6), Applicable Devices.4680 = 4680. RXF14SIDH (6), Power-on Reset, Brown-out Reset.0000 = xxxx. RXF14SIDH (6), Power-on Reset, Brown-out Reset.00-- = xxxx. RXF14SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuuu. RXF14SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = uuuu. RXF14SIDH (6),",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt.uuuu = uuuu. RXF14SIDH (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXF13EIDL (6), Applicable Devices.2585 = 2585. RXF13EIDL (6), Applicable Devices.2680 = 2680. RXF13EIDL (6), Applicable Devices.4585 = 4585. RXF13EIDL (6), Applicable Devices.4680 = 4680. RXF13EIDL (6), Power-on Reset, Brown-out Reset.0000 = xxxx. RXF13EIDL (6), Power-on Reset, Brown-out Reset.00-- = xxxx. RXF13EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuuu. RXF13EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. RXF13EIDL (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXF13EIDL (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXF13EIDH (6), Applicable Devices.2585 = 2585. RXF13EIDH (6), Applicable Devices.2680 = 2680. RXF13EIDH (6), Applicable Devices.4585 = 4585. RXF13EIDH (6), Applicable Devices.4680 = 4680. RXF13EIDH (6), Power-on Reset, Brown-out Reset.0000 = xxxx. RXF13EIDH (6), Power-on Reset, Brown-out Reset.00-- = xxxx. RXF13EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuuu. RXF13EIDH (6), MCLR Resets,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset, RESET Instruction, Stack Resets.00-- = uuuu. RXF13EIDH (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXF13EIDH (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXF13SIDL (6), Applicable Devices.2585 = 2585. RXF13SIDL (6), Applicable Devices.2680 = 2680. RXF13SIDL (6), Applicable Devices.4585 = 4585. RXF13SIDL (6), Applicable Devices.4680 = 4680. RXF13SIDL (6), Power-on Reset, Brown-out Reset.0000 = xxx-. RXF13SIDL (6), Power-on Reset, Brown-out Reset.00-- = x-xx. RXF13SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuu-. RXF13SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = u-uu. RXF13SIDL (6), Wake-up via WDT or Interrupt.uuuu = uuu-. RXF13SIDL (6), Wake-up via WDT or Interrupt.uu-- = u-uu. RXF13SIDH (6), Applicable Devices.2585 = 2585. RXF13SIDH (6), Applicable Devices.2680 = 2680. RXF13SIDH (6), Applicable Devices.4585 = 4585. RXF13SIDH (6), Applicable Devices.4680 = 4680. RXF13SIDH (6), Power-on Reset, Brown-out Reset.0000 = xxxx. RXF13SIDH (6), Power-on Reset, Brown-out Reset.00-- = xxxx. RXF13SIDH (6), MCLR Resets,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset, RESET Instruction, Stack Resets.0000 = uuuu. RXF13SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = uuuu. RXF13SIDH (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXF13SIDH (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXF12EIDL (6), Applicable Devices.2585 = 2585. RXF12EIDL (6), Applicable Devices.2680 = 2680. RXF12EIDL (6), Applicable Devices.4585 = 4585. RXF12EIDL (6), Applicable Devices.4680 = 4680. RXF12EIDL (6), Power-on Reset, Brown-out Reset.0000 = xxxx. RXF12EIDL (6), Power-on Reset, Brown-out Reset.00-- = xxxx.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF12EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuuu. RXF12EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = uuuu. RXF12EIDL (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXF12EIDL (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXF12EIDH (6), Applicable Devices.2585 = 2585. RXF12EIDH (6), Applicable Devices.2680 = 2680. RXF12EIDH (6), Applicable Devices.4585 = 4585. RXF12EIDH (6), Applicable Devices.4680 = 4680. RXF12EIDH (6), Power-on Reset, Brown-out Reset.0000 = xxxx. RXF12EIDH (6), Power-on",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset.00-- = xxxx. RXF12EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuuu. RXF12EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = uuuu. RXF12EIDH (6), Wake-up via WDT or Interrupt.uuuu = uuuu. RXF12EIDH (6), Wake-up via WDT or Interrupt.uu-- = uuuu. RXF12SIDL (6), Applicable Devices.2585 = 2585. RXF12SIDL (6), Applicable Devices.2680 = 2680. RXF12SIDL (6), Applicable Devices.4585 = 4585. RXF12SIDL (6), Applicable Devices.4680 = 4680. RXF12SIDL (6), Power-on Reset, Brown-out Reset.0000 =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nxxx-. RXF12SIDL (6), Power-on Reset, Brown-out Reset.00-- = x-xx. RXF12SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.0000 = uuu-. RXF12SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets.00-- = u-uu. RXF12SIDL (6), Wake-up via WDT or Interrupt.uuuu = uuu-. RXF12SIDL (6), Wake-up via WDT or Interrupt.uu-- = u-uu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF12SIDH (6), Applicable Devices = 2585. RXF12SIDH (6), Applicable Devices = 2680. RXF12SIDH (6), Applicable Devices = 4585. RXF12SIDH (6), Applicable Devices = 4680. RXF12SIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF12SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF12SIDH (6), Wake-up via WDT or Interrupt = uuuu uuuu. RXF11EIDL (6), Applicable Devices = 2585. RXF11EIDL (6), Applicable Devices = 2680. RXF11EIDL (6), Applicable Devices = 4585. RXF11EIDL (6), Applicable Devices = 4680. RXF11EIDL (6), Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF11EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF11EIDL (6), Wake-up via WDT or Interrupt = uuuu uuuu. RXF11EIDH (6), Applicable Devices = 2585. RXF11EIDH (6), Applicable Devices = 2680. RXF11EIDH (6), Applicable Devices = 4585. RXF11EIDH (6), Applicable Devices = 4680. RXF11EIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF11EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF11EIDH (6), Wake-up via WDT or Interrupt = uuuu uuuu. RXF11SIDL (6), Applicable Devices = 2585. RXF11SIDL (6), Applicable",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = 2680. RXF11SIDL (6), Applicable Devices = 4585. RXF11SIDL (6), Applicable Devices = 4680. RXF11SIDL (6), Power-on Reset, Brown-out Reset = xxx- x-xx. RXF11SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. RXF11SIDL (6), Wake-up via WDT or Interrupt = uuu- u-uu. RXF11SIDH (6), Applicable Devices = 2585. RXF11SIDH (6), Applicable Devices = 2680. RXF11SIDH (6), Applicable Devices = 4585. RXF11SIDH (6), Applicable Devices = 4680. RXF11SIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF11SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. RXF11SIDH (6), Wake-up via WDT or Interrupt = uuuu uuuu. RXF10EIDL (6), Applicable Devices = 2585. RXF10EIDL (6), Applicable Devices = 2680. RXF10EIDL (6), Applicable Devices = 4585. RXF10EIDL (6), Applicable Devices = 4680. RXF10EIDL (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF10EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF10EIDL (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF10EIDH (6), Applicable Devices = 2585. RXF10EIDH (6), Applicable Devices = 2680. RXF10EIDH (6), Applicable Devices = 4585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF10EIDH (6), Applicable Devices = 4680. RXF10EIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF10EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF10EIDH (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF10SIDL (6), Applicable Devices = 2585. RXF10SIDL (6), Applicable Devices = 2680. RXF10SIDL (6), Applicable Devices = 4585. RXF10SIDL (6), Applicable Devices = 4680. RXF10SIDL (6), Power-on Reset, Brown-out Reset = xxx- x-xx. RXF10SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. RXF10SIDL (6),",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = -uuu uuuu. RXF10SIDH (6), Applicable Devices = 2585. RXF10SIDH (6), Applicable Devices = 2680. RXF10SIDH (6), Applicable Devices = 4585. RXF10SIDH (6), Applicable Devices = 4680. RXF10SIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF10SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF10SIDH (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF9EIDL (6), Applicable Devices = 2585. RXF9EIDL (6), Applicable Devices = 2680. RXF9EIDL (6), Applicable Devices = 4585. RXF9EIDL (6), Applicable Devices = 4680. RXF9EIDL",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF9EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF9EIDL (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF9EIDH (6), Applicable Devices = 2585. RXF9EIDH (6), Applicable Devices = 2680. RXF9EIDH (6), Applicable Devices = 4585. RXF9EIDH (6), Applicable Devices = 4680. RXF9EIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF9EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF9EIDH (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF9SIDL",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Applicable Devices = 2585. RXF9SIDL (6), Applicable Devices = 2680. RXF9SIDL (6), Applicable Devices = 4585. RXF9SIDL (6), Applicable Devices = 4680. RXF9SIDL (6), Power-on Reset, Brown-out Reset = xxx- x-xx. RXF9SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. RXF9SIDL (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF9SIDH (6), Applicable Devices = 2585. RXF9SIDH (6), Applicable Devices = 2680. RXF9SIDH (6), Applicable Devices = 4585. RXF9SIDH (6), Applicable Devices = 4680. RXF9SIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF9SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF9SIDH (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF8EIDL (6), Applicable Devices = 2585. RXF8EIDL (6), Applicable Devices = 2680. RXF8EIDL (6), Applicable Devices = 4585. RXF8EIDL (6), Applicable Devices = 4680. RXF8EIDL (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF8EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF8EIDL (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF8EIDH (6), Applicable Devices = 2585. RXF8EIDH (6), Applicable",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = 2680. RXF8EIDH (6), Applicable Devices = 4585. RXF8EIDH (6), Applicable Devices = 4680. RXF8EIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF8EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF8EIDH (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF8SIDL (6), Applicable Devices = 2585. RXF8SIDL (6), Applicable Devices = 2680. RXF8SIDL (6), Applicable Devices = 4585. RXF8SIDL (6), Applicable Devices = 4680. RXF8SIDL (6), Power-on Reset, Brown-out Reset = xxx- x-xx. RXF8SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuu- u-uu. RXF8SIDL (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF8SIDH (6), Applicable Devices = 2585. RXF8SIDH (6), Applicable Devices = 2680. RXF8SIDH (6), Applicable Devices = 4585. RXF8SIDH (6), Applicable Devices = 4680. RXF8SIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF8SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF8SIDH (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF7EIDL (6), Applicable Devices = 2585. RXF7EIDL (6), Applicable Devices = 2680. RXF7EIDL (6), Applicable Devices = 4585.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF7EIDL (6), Applicable Devices = 4680. RXF7EIDL (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF7EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF7EIDL (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF7EIDH (6), Applicable Devices = 2585. RXF7EIDH (6), Applicable Devices = 2680. RXF7EIDH (6), Applicable Devices = 4585. RXF7EIDH (6), Applicable Devices = 4680. RXF7EIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF7EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF7EIDH (6), Wake-up via",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = -uuu uuuu. RXF7SIDL (6), Applicable Devices = 2585. RXF7SIDL (6), Applicable Devices = 2680. RXF7SIDL (6), Applicable Devices = 4585. RXF7SIDL (6), Applicable Devices = 4680. RXF7SIDL (6), Power-on Reset, Brown-out Reset = xxx- x-xx. RXF7SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. RXF7SIDL (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF7SIDH (6), Applicable Devices = 2585. RXF7SIDH (6), Applicable Devices = 2680. RXF7SIDH (6), Applicable Devices = 4585. RXF7SIDH (6), Applicable Devices = 4680. RXF7SIDH (6),",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = xxxx xxxx. RXF7SIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF7SIDH (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF6EIDL (6), Applicable Devices = 2585. RXF6EIDL (6), Applicable Devices = 2680. RXF6EIDL (6), Applicable Devices = 4585. RXF6EIDL (6), Applicable Devices = 4680. RXF6EIDL (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF6EIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF6EIDL (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF6EIDH (6), Applicable Devices",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 2585. RXF6EIDH (6), Applicable Devices = 2680. RXF6EIDH (6), Applicable Devices = 4585. RXF6EIDH (6), Applicable Devices = 4680. RXF6EIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF6EIDH (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF6EIDH (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF6SIDH (6), Applicable Devices = 2585. RXF6SIDH (6), Applicable Devices = 2680. RXF6SIDH (6), Applicable Devices = 4585. RXF6SIDH (6), Applicable Devices = 4680. RXF6SIDH (6), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF6SIDH (6), MCLR",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets, WDT Reset, RESET Instruction, Stack Resets = uuuu uuuu. RXF6SIDH (6), Wake-up via WDT or Interrupt = -uuu uuuu. RXF6SIDL (6), Applicable Devices = 2585. RXF6SIDL (6), Applicable Devices = 2680. RXF6SIDL (6), Applicable Devices = 4585. RXF6SIDL (6), Applicable Devices = 4680. RXF6SIDL (6), Power-on Reset, Brown-out Reset = xxx- x-xx. RXF6SIDL (6), MCLR Resets, WDT Reset, RESET Instruction, Stack Resets = uuu- u-uu. RXF6SIDL (6), Wake-up via WDT or Interrupt = -uuu uuuu\nLegend:",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.",
    "5.0 FLASH PROGRAM MEMORY\nThe Flash program memory is readable, writable and erasable during normal operation over the entire VDD range.\nA read from program memory is executed on one byte at a time. A write to program memory is executed on blocks  of  64  bytes  at  a  time.  Program  memory  is erased in blocks of 64 bytes at a time. A bulk erase operation may not be issued from user code.\nWriting or erasing program memory will cease instruction fetches until the operation is complete. The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming timer terminates program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing  a  program  memory location  that  forms  an  invalid  instruction  results  in  a NOP .",
    "5.1 Table Reads and Table Writes\nIn order to read and write program memory, there are two operations that allow the processor to move bytes between the program memory space and the data RAM:\n\u00b7 Table Read ( TBLRD )\n\u00b7 Table Write ( TBLWT )\nThe program memory space is 16 bits wide, while the data RAM space is 8 bits wide. Table reads and table writes move data between these two memory spaces through an 8-bit register (TABLAT).\nTable  read  operations  retrieve  data  from  program memory  and  place  it  into  the data RAM  space. Figure 5-1  shows  the  operation  of  a  table  read  with program memory and data RAM.\nTable write operations store data from the data memory space  into  holding  registers  in  program  memory.  The procedure to write the contents of the holding registers into program memory is detailed in Section 5.5 'Writing to  Flash  Program  Memory' . Figure 5-2  shows  the operation of a table write with program memory and data RAM.",
    "5.1 Table Reads and Table Writes\nTable operations work with byte entities. A table block containing data, rather than program instructions, is not required to be word aligned. Therefore, a table block can start and end at any byte address. If a table write is being used  to  write  executable  code  into  program  memory, program instructions will need to be word aligned.",
    "5.2 Control Registers\nSeveral control registers are used in conjunction with the TBLRD and TBLWT instructions. These include the:\nThe FREE bit, when set, will allow a program memory erase operation. When FREE is set, the erase operation is initiated on the next WR command. When FREE is clear, only writes are enabled.\n\u00b7 EECON1 register\n\u00b7 EECON2 register\n\u00b7 TABLAT register\n\u00b7 TBLPTR registers",
    "5.2.1 EECON1 AND EECON2 REGISTERS\nThe  EECON1  register  (Register 5-1)  is  the  control register for memory accesses. The EECON2 register is not  a  physical  register;  it  is  used  exclusively  in  the memory write and erase sequences. Reading EECON2 will read all ' 0 's.\nThe EEPGD control bit determines if the access will be a  program or  data  EEPROM memory access. When clear,  any  subsequent  operations will  operate on  the data  EEPROM  memory.  When  set,  any  subsequent operations will operate on the program memory.\nThe CFGS control bit determines if the access will be to the Configuration/Calibration registers or to program memory/data EEPROM memory. When set, subsequent  operations  will  operate  on  Configuration registers  regardless  of  EEPGD  (see Section 24.0 'Special Features of the CPU' ). When clear, memory selection access is determined by EEPGD.\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear. The WRERR bit is set in hardware when the WREN bit is set and cleared when the internal programming timer expires and the write operation is complete.",
    "Note:\nDuring normal operation, the WRERR is read as ' 1 '. This can indicate that a write operation was prematurely terminated by a Reset, or a write operation was attempted improperly.\nThe WR control bit initiates write operations. The bit cannot be cleared, only set, in software; it is cleared in hardware at the completion of the write operation.\nThe  EEIF  Interrupt  flag  bit  (PIR2<4>)  is set when the write is complete. It must be cleared in software.\nREGISTER 5-1:",
    "EECON1: DATA EEPROM CONTROL REGISTER 1\nR/W-x, 1 = R/W-x. R/W-x, 2 = U-0. R/W-x, 3 = R/W-0. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-0. R/W-x, 6 = R/S-0. R/W-x, 7 = R/S-0. EEPGD, 1 = CFGS. EEPGD, 2 = -. EEPGD, 3 = FREE. EEPGD, 4 = WRERR. EEPGD, 5 = WREN. EEPGD, 6 = WR. EEPGD, 7 = RD\nbit 7\nbit 0",
    "bit 7 EEPGD: Flash Program or Data EEPROM Memory Select bit\n1 = Access Flash program memory\n0 = Access data EEPROM memory\nCFGS: Flash Program/Data EEPROM or Configuration Select bit\n1 = Access Configuration registers\n0 = Access Flash program or data EEPROM memory",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nFREE:\nFlash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation)\n0 = Perform write only",
    "bit 3 WRERR: Flash Program/Data EEPROM Error Flag bit\n1 = A write operation is prematurely terminated (any Reset during self-timed programming in normal operation or an improper write attempt)\n0 = The write operation completed\nNote:\nWhen a WRERR occurs, the EEPGD and CFGS bits are not cleared. This allows tracing of the error condition.",
    "bit 2 WREN: Flash Program/Data EEPROM Write Enable bit\n1 = Allows write cycles to Flash program/data EEPROM\n0 = Inhibits write cycles to Flash program/data EEPROM",
    "bit 1 WR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle to the EEPROM is complete",
    "bit 0 RD: Read Control bit\n1 = Initiates an EEPROM read (Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1 or CFGS = 1 .)\n0 = Does not initiate an EEPROM read",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "5.2.2 TABLAT - TABLE LATCH REGISTER\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch register is used to hold 8-bit data during data transfers between program memory and data RAM.",
    "5.2.3 TBLPTR - TABLE POINTER REGISTER\nThe Table Pointer (TBLPTR) register addresses a byte within the program memory. The TBLPTR is comprised of three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL).  These  three  registers  join  to  form  a  22-bit  wide  pointer.  The  low-order 21 bits allow the device to address up to 2 Mbytes of program memory space. The 22nd bit allows access to the device ID, the user ID and the Configuration bits.\nThe Table Pointer, TBLPTR, is used by the TBLRD and TBLWT instructions. These instructions can update the TBLPTR in one of four ways based on the table operation. These operations are shown in Table 5-1. These operations  on  the  TBLPTR  only  affect  the  low-order 21 bits.",
    "5.2.4 TABLE POINTER BOUNDARIES\nWhen a TBLRD is executed, all 22 bits of the TBLPTR determine  which  byte  is  read  from  program  memory into TABLAT.\nWhen a TBLWT is executed, the six LSbs of the Table Pointer  register  (TBLPTR<5:0>)  determine  which  of the 64 program memory holding registers is written to. When the timed write to program memory begins (via the WR bit), the 16 MSbs of the TBLPTR (TBLPTR<21:6>)  determine  which  program  memory block  of  64  bytes  is  written  to.  For  more  detail,  see Section 5.5 'Writing to Flash Program Memory' .\nWhen an erase of program memory is executed, the 16 MSbs of the Table Pointer register (TBLPTR<21:6>) point to the 64-byte block that will be erased. The Least Significant bits (TBLPTR<5:0>) are ignored.\nFigure 5-3 describes the relevant boundaries of TBLPTR based on Flash program memory operations.\nTABLE 5-1: TABLE POINTER OPERATIONS WITH TBLRD AND TBLWT INSTRUCTIONS\nTBLPTR  is  used  in  reads,  writes  and  erases  of  the Flash program memory.",
    "5.2.4 TABLE POINTER BOUNDARIES\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "5.3 Reading the Flash Program Memory\nThe TBLRD instruction  is  used  to  retrieve  data  from program memory and places it into data RAM. Table reads from program memory are performed one byte at a time.\nTBLPTR points to a byte address in program space. Executing TBLRD places  the  byte  pointed  to  into TABLAT. In addition, TBLPTR can be modified automatically for the next table read operation.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. Figure 5-4 shows  the  interface  between  the  internal  program memory and the TABLAT.",
    "EXAMPLE 5-1: READING A FLASH PROGRAM MEMORY WORD\n, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. , 2 = CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL. , 3 = ; Load TBLPTR with the base ; address of the word. READ_WORD, 1 = . READ_WORD, 2 = . READ_WORD, 3 = . , 1 = TBLRD*+ MOVF MOVWF TBLRD*+ MOVF MOVF. , 2 = TABLAT, W WORD_EVEN. , 3 = ; read into TABLAT and increment ; get data. , 1 = . , 2 = TABLAT, W WORD_ODD. , 3 = ; read into TABLAT and increment ; get data",
    "5.4 Erasing Flash Program Memory\nThe minimum erase block is 32 words or 64 bytes. Only through the use of an external programmer, or through ICSP control, can larger blocks of program memory be bulk  erased.  Word  erase  in  the  Flash  array  is  not supported.\nWhen  initiating  an  erase  sequence  from  the  microcontroller itself, a block of 64 bytes of program memory is erased. The Most Significant 16 bits of the TBLPTR<21:6>  point  to  the block being erased. TBLPTR<5:0> are ignored.\nThe EECON1 register commands the erase operation. The  EEPGD  bit  must  be  set  to  point  to  the  Flash program memory. The WREN bit must be set to enable write operations. The FREE bit is set to select an erase operation.\nFor protection, the write initiate sequence for EECON2 must be used.",
    "5.4.1 FLASH PROGRAM MEMORY ERASE SEQUENCE\nThe sequence of events for erasing a block of internal program memory location is:\n1. Load Table Pointer register with address of row being erased.\n2. Set the EECON1 register for the erase operation:\n\u00b7 set EEPGD bit to point to program memory;\n\u00b7 clear the CFGS bit to access program memory;\n\u00b7 set WREN bit to enable writes;\n\u00b7 set FREE bit to enable the erase.\n3. Disable interrupts.\n4. Write 55h to EECON2.\n5. Write 0AAh to EECON2.\n6. Set  the  WR  bit.  This  will  begin  the  row  erase cycle.\nA long write is necessary for erasing the internal Flash. Instruction  execution  is  halted  while  in  a  long  write cycle. The long write will be terminated by the internal programming timer.\n7. The  CPU  will  stall  for  duration  of  the  erase (about 2 ms using internal timer).\n8. Re-enable interrupts.",
    "EXAMPLE 5-2: ERASING A FLASH PROGRAM MEMORY ROW\nERASE_ROW, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF BSF. ERASE_ROW, 2 = CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL. ERASE_ROW, 3 = . ERASE_ROW, 4 = ; load TBLPTR with the base ; address of the memory block. Required Sequence, 1 = BCF MOVLW MOVWF MOVLW MOVWF. Required Sequence, 2 = INTCON, 55h EECON2 0AAh EECON2. Required Sequence, 3 = GIE. Required Sequence, 4 = ; ; write 55h. , 1 = BSF. , 2 = EECON1,. , 3 = WR. , 4 = ; write 0AAh ; start erase (CPU stall). , 1 = . , 2 = . , 3 = . , 4 = ; re-enable interrupts. , 1 = BSF. , 2 = INTCON,. , 3 = GIE. , 4 = ",
    "5.5 Writing to Flash Program Memory\nThe  minimum  programming  block  is  32  words  or 64 bytes. Word or byte programming is not supported.\nTable  writes  are  used  internally  to  load  the  holding registers needed to program the Flash memory. There are  64  holding  registers  used  by  the  table  writes  for programming.\nThe  long  write  is  necessary  for  programming  the internal Flash. Instruction execution is halted while in a long write cycle. The long write will be terminated by the internal programming timer.\nThe  EEPROM  on-chip  timer  controls  the  write  time. The write/erase voltages are generated by an on-chip charge pump, rated to operate over the voltage range of the device.\nSince the Table Latch (TABLAT) is only a single byte, the TBLWT instruction  may  need  to  be  executed  64 times for each programming operation. All of the table write operations will essentially be short writes because only  the  holding  registers  are  written.  At  the  end  of updating the 64 holding registers, the EECON1 register must be written to in order  to start  the  programming operation with a long write.",
    "Note:\nThe default value of the holding registers on device Resets and after write operations is FFh.  A  write  of  FFh  to  a  holding  register does not modify that byte. This means that individual  bytes  of  program  memory  may be modified, provided that the change does not attempt to change any bit from a ' 0 ' to a ' 1 '.  When  modifying  individual  bytes,  it  is not necessary to load all 64 holding registers before executing a write operation.",
    "5.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThe sequence of events for programming an internal program memory location should be:\n1. Read 64 bytes into RAM.\n2. Update data values in RAM as necessary.\n3. Load Table Pointer register with address being erased.\n4. Execute the row erase procedure.\n5. Load Table Pointer register with address of first byte being written.\n6. Write the 64 bytes into the holding registers with auto-increment.\n7. Set the EECON1 register for the write operation:\n\u00b7 set EEPGD bit to point to program memory;\n\u00b7 clear the CFGS bit to access program memory;\n\u00b7 set WREN to enable byte writes.\n8. Disable interrupts.\n9. Write 55h to EECON2.\n10. Write 0AAh to EECON2.\n11. Set the WR bit. This will begin the write cycle.\n12. The CPU will stall for duration of the write (about 2 ms using internal timer).\n13. Re-enable interrupts.\n14. Verify the memory (table read).\nThis procedure will require about 18 ms to update one row of 64 bytes of memory. An example of the required code is given in Example 5-3.",
    "Note:\nBefore  setting the WR  bit,  the  Table Pointer  address  needs  to  be  within  the intended address range of the 64 bytes in the holding register.",
    "WRITING TO FLASH PROGRAM MEMORY\nMOVLWD'64 MOVWFCOUNTER MOVLWBUFFER_ADDR_HIGH MOVWFFSR0H MOVLWBUFFER_ADDR_LOW MOVWFFSR0L MOVLWCODE_ADDR_UPPER MOVWFTBLPTRU MOVLWCODE_ADDR_HIGH MOVWFTBLPTRH MOVLWCODE_ADDR_LOW, 1 = ; number of bytes in erase block ; point to buffer ; Load TBLPTR with the base. MOVWFTBLPTRL, 1 = . TBLRD*+ MOVFTABLAT, W MOVWFPOSTINC0 DECFSZCOUNTER BRA READ_BLOCK, 1 = ; read into TABLAT, and inc ; get data ; store data ; done? ; repeat. MOVLWDATA_ADDR_HIGH MOVWFFSR0H MOVLWDATA_ADDR_LOW MOVWFFSR0L MOVLWNEW_DATA_LOW MOVWFPOSTINC0 MOVLWNEW_DATA_HIGH, 1 = ; point to buffer.",
    "WRITING TO FLASH PROGRAM MEMORY\nMOVWFINDF0, 1 = . MOVLWCODE_ADDR_UPPER MOVWFTBLPTRU MOVLWCODE_ADDR_HIGH MOVWFTBLPTRH MOVLWCODE_ADDR_LOW MOVWFTBLPTRL, 1 = ; load TBLPTR with the base ; address of the memory block. BSF EECON1, EEPGD BCF EECON1, CFGS BSF EECON1, WREN BSF EECON1, FREE BCF INTCON, GIE, 1 = ; point to Flash program memory ; access Flash program memory. , 1 = enable write to memory enable Row Erase operation disable interrupts. , 1 = ;. , 1 = ;. MOVLW55h MOVWFEECON2 MOVLW0AAh, 1 = ;. TBLRD*-, 1 = ; write 55h ; write 0AAh ; start erase (CPU stall). , 1 = ; point to buffer. , 1 = ; dummy read. , 1 = decrement. , 1 = ; re-enable interrupts.",
    "WRITING TO FLASH PROGRAM MEMORY\nMOVLWBUFFER_ADDR_HIGH, 1 = . MOVWFFSR0H, 1 = . MOVLWBUFFER_ADDR_LOW, 1 = . MOVWFFSR0L, 1 = . WRITE_BUFFER_BACK, 1 = . MOVLWD'64, 1 = . , 1 = ; number of bytes in holding. MOVWFCOUNTER, 1 = register. , 1 = ; get low byte of buffer data. , 1 = ; present data to table latch. WRITE_BYTE_TO_HREGS, 1 = . , 1 = ; write data, perform a short. MOVFPOSTINC0, W, 1 = . , 1 = write. , 1 = ; to internal TBLWT holding. MOVWFTABLAT, 1 = . , 1 = register.. TBLWT+*, 1 = . , 1 = until buffers are full. DECFSZCOUNTER, 1 = . BRA WRITE_BYTE_TO_HREGS, 1 = . ;, 1 = . loop, 1 = ",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\nPROGRAM_MEMORY, 1 = PROGRAM_MEMORY. Required Sequence, 1 = ; write 55h ; write 0AAh ; start program (CPU ; re-enable interrupts WREN ; disable write to memory",
    "5.5.2 WRITE VERIFY\nDepending  on  the  application,  good  programming practice  may  dictate  that  the  value  written  to  the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "5.5.3 UNEXPECTED TERMINATION OF WRITE OPERATION\nIf a write is terminated by an unplanned event, such as loss  of  power  or  an  unexpected  Reset,  the  memory location just programmed should be verified and reprogrammed if needed. If the write operation is interrupted by  a  MCLR  Reset  or  a  WDT  Time-out  Reset  during normal operation, the user can check the WRERR bit and rewrite the location(s) as needed.",
    "5.5.4 PROTECTION AGAINST SPURIOUS WRITES\nTo  protect  against  spurious  writes  to  Flash  program memory,  the  write  initiate  sequence  must  also  be followed. See Section 24.0 'Special Features of the CPU' for more detail.",
    "5.6 Flash Program Operation During Code Protection\nSee Section 24.5 'Program Verification and Code Protection' for  details  on  code  protection  of  Flash program memory.",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH\nMEMORY\nTBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit21. TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Reset Valueson page = 46. TBPLTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>).",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH\nTBPLTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Reset Valueson page = 46. TBLPTRL, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH\nMemory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Reset Valueson page = 46. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Reset Valueson page = 46. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 =",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH\nINT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Valueson page = 46. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Reset Valueson page = 48. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS.",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH\nEECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Reset Valueson page = 48. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP (1). IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (1). IPR2, Reset Valueson page = 48. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF (1). PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 =",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH\nTMR3IF. PIR2, Bit 0 = ECCP1IF (1). PIR2, Reset Valueson page = 48. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE (1). PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (1). PIE2, Reset Valueson page = 49\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used during Flash/EEPROM access.\n- Note 1: These bits are available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.",
    "6.0 MEMORY ORGANIZATION\nThere are three types of memory in PIC18 Enhanced microcontroller devices:\n\u00b7 Program Memory\n\u00b7 Data RAM\n\u00b7 Data EEPROM\nAs Harvard architecture devices, the data and program memories  use  separate  busses;  this  allows  for  concurrent access of the two memory spaces. The data EEPROM, for practical purposes, can be regarded as a peripheral device, since it is addressed and accessed through a set of control registers.",
    "6.1 Program Memory Organization\nPIC18  microcontrollers  implement  a  21-bit  program counter,  which  is  capable  of  addressing  a  2-Mbyte program memory space. Accessing a location between the  upper  boundary  of  the  physically  implemented memory and the 2-Mbyte address will return all ' 0 's (a NOP instruction).\nThe PIC18F2585 and PIC18F4585 each have 48 Kbytes of Flash memory and can store up to 24,576 single-word instructions. The PIC18F2680 and PIC18F4680  each  have  64 Kbytes  of  Flash  memory and can store up to 32,768 single-word instructions.\nAdditional detailed information on the operation of the Flash  program  memory  is  provided  in Section 5.0 'Flash Program Memory' . Data EEPROM is discussed separately in Section 7.0 'Data EEPROM Memory' .\nPIC18 devices have two interrupt vectors. The Reset vector  address  is  at  0000h  and  the  interrupt  vector addresses are at 0008h and 0018h.\nThe  program  memory  maps  for  PIC18FX585  and PIC18FX680 devices are shown in Figure 6-1.",
    "6.1.1 PROGRAM COUNTER\nThe Program Counter (PC) specifies the address of the instruction to fetch for execution. The PC is 21 bits wide and is contained in three separate 8-bit registers. The low byte, known as the PCL register, is both readable and writable. The high byte, or PCH register, contains the PC<15:8> bits; it is not directly readable or writable. Updates to the PCH register are performed through the PCLATH register. The upper byte is called PCU. This register  contains  the  PC<20:16>  bits;  it  is  also  not directly  readable  or  writable.  Updates  to  the  PCU register are performed through the PCLATU register.\nThe contents of PCLATH and PCLATU are transferred to  the  program  counter  by  any  operation  that  writes PCL.  Similarly,  the  upper  two  bytes  of  the  program counter are transferred to PCLATH and PCLATU by an operation that reads PCL. This is useful for computed offsets  to  the  PC  (see Section 6.1.4.1  'Computed GOTO' ).",
    "6.1.1 PROGRAM COUNTER\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the Least Significant bit of PCL is fixed to a  value  of  ' 0 '.  The  PC  increments  by  2  to  address sequential instructions in the program memory.\nThe CALL , RCALL and GOTO program branch instructions write to the program counter directly. For these instructions, the contents of PCLATH  and PCLATU are not transferred to the program counter.",
    "6.1.2 RETURN ADDRESS STACK\nThe return address stack allows any combination of up to 31 program calls and interrupts to occur. The PC is pushed onto the stack when a CALL or RCALL instruction is executed or an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN, RETLW or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit  Stack  Pointer,  STKPTR. The stack space is not part of either program or data space. The Stack Pointer is readable and writable and the address on the top of the stack is readable and writable through the top-of-stack Special File Registers. Data can also be pushed  to,  or  popped  from  the  stack,  using  these registers.",
    "6.1.2 RETURN ADDRESS STACK\nA CALL type instruction causes a push onto the stack; the Stack Pointer is first incremented and the location pointed  to  by  the  Stack  Pointer  is  written  with  the contents of the PC (already pointing to the instruction following the CALL ). A RETURN type instruction causes a  pop  from  the  stack;  the  contents  of  the  location pointed to by the STKPTR are transferred to the PC and then the Stack Pointer is decremented.\nThe  Stack  Pointer  is  initialized  to  ' 00000 ' after  all Resets. There is no RAM associated with the location corresponding to a Stack Pointer value of ' 00000 '; this is only a Reset value. Status bits indicate if the stack is full or has overflowed or has underflowed.",
    "6.1.2.1 Top-of-Stack Access\nOnly  the  top  of  the  return  address  stack  (TOS)  is readable and writable. A set of three registers, TOSU:TOSH:TOSL, hold the contents of the stack location pointed to by the STKPTR register (Figure 6-2). This allows users to implement a software stack if necessary. After a CALL RCALL , or interrupt, the software can read the  pushed  value  by  reading  the  TOSU:TOSH:TOSL registers. These values can be placed on a user defined software stack. At return time, the software can return these values to TOSU:TOSH:TOSL and do a return.\nThe user must disable the global interrupt enable bits while accessing the stack to prevent inadvertent stack corruption.",
    "6.1.2.2 Return Stack Pointer (STKPTR)\nThe STKPTR register (Register 6-1) contains the Stack Pointer value, the STKFUL (Stack Full) status bit and the STKUNF (Stack Underflow) status bits. The value of the Stack Pointer can be 0 through 31. The Stack Pointer increments before values are pushed onto the stack and decrements after values are popped off the stack. On Reset, the Stack Pointer value will be zero. The user may read and write the Stack Pointer value. This  feature  can  be  used  by  a  Real-Time  Operating System (RTOS) for return stack maintenance.\nAfter the PC is pushed onto the stack 31 times (without popping any values off the stack), the STKFUL bit is set.  The  STKFUL  bit  is  cleared  by  software  or  by  a POR.",
    "6.1.2.2 Return Stack Pointer (STKPTR)\nThe action that takes place when the stack becomes full depends on the state of the STVREN (Stack Overflow Reset Enable) Configuration bit. (Refer to Section 24.1 'Configuration Bits' for a description of the device  Configuration  bits.) If STVREN  is  set (default),  the  31st  push  will  push  the  (PC  +  2)  value onto  the  stack,  set  the  STKFUL  bit  and  reset  the device. The STKFUL bit will remain set and the Stack Pointer will be set to zero.\nWhen  the  stack  has  been  popped  enough  times  to unload the stack, the next pop will return a value of zero to  the  PC  and  sets  the  STKUNF bit, while the Stack Pointer remains at zero. The STKUNF bit will remain set until cleared by software or until a POR occurs.\nNote:\nReturning a value of zero to the PC on an underflow has the effect of vectoring the program  to  the  Reset  vector,  where  the stack conditions can be verified and appropriate actions can be taken. This is not the same as a Reset, as the contents of the SFRs are not affected.",
    "6.1.2.3 PUSH and POP Instructions\nSince  the  Top-of-Stack  is  readable  and  writable,  the ability to push values onto the stack and pull values off the stack without disturbing normal program execution is a desirable  feature. The  PIC18  instruction  set includes  two  instructions, PUSH and POP ,  that  permit the  TOS  to  be  manipulated  under  software  control. TOSU, TOSH and TOSL can be modified to place data or a return address on the stack.\nIf STVREN is cleared, the STKFUL bit will be set on the 31st push and the Stack Pointer will increment to 31. Any additional pushes will not overwrite the 31st push and STKPTR will remain at 31.\nThe PUSH instruction places the current PC value onto the stack. This increments the Stack Pointer and loads the current PC value onto the stack.\nThe POP instruction discards the current TOS by decrementing the Stack Pointer. The previous value pushed onto the stack then becomes the TOS value.",
    "REGISTER 6-1: STKPTR: STACK POINTER REGISTER\nR/C-0, 1 = R/C-0. R/C-0, 2 = U-0. R/C-0, 3 = R/W-0. R/C-0, 4 = R/W-0. R/C-0, 5 = R/W-0. R/C-0, 6 = R/W-0. R/C-0, 7 = R/W-0. STKFUL (1), 1 = STKUNF (1). STKFUL (1), 2 = -. STKFUL (1), 3 = SP4. STKFUL (1), 4 = SP3. STKFUL (1), 5 = SP2. STKFUL (1), 6 = SP1. STKFUL (1), 7 = SP0\nbit 7\nbit 0\nSTKFUL: Stack Full Flag bit (1)\nbit 7\n1 = Stack became full or overflowed\n0 = Stack has not become full or overflowed\nbit 6\nSTKUNF: Stack Underflow Flag bit\n(1)\n1 = Stack underflow occurred",
    "REGISTER 6-1: STKPTR: STACK POINTER REGISTER\n0 = Stack underflow did not occur\nbit 5\nUnimplemented: Read as ' 0 '\nbit 4-0 SP4:SP0:\nStack Pointer Location bits\nNote 1: Bit 7 and bit 6 are cleared by user software or by a POR.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented\nC = Clearable only bit\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "6.1.2.4 Stack Full and Underflow Resets\nDevice Resets on stack overflow and stack underflow conditions are enabled by setting the STVREN bit in Configuration Register 4L. When STVREN is set, a full or underflow  will set the appropriate  STKFUL  or STKUNF bit  and  then  cause  a  device  Reset.  When STVREN is cleared, a full or underflow condition will set the appropriate STKFUL or STKUNF bit, but not cause a  device  Reset.  The  STKFUL  or  STKUNF  bits  are cleared by the user software or a Power-on Reset.",
    "6.1.3 FAST REGISTER STACK\nA  fast  register  stack  is  provided  for  the  STATUS, WREG and BSR registers, to provide a 'fast  return' option for interrupts. Each stack is only one level deep and is neither readable nor writable. It is loaded with the current value of the corresponding register when the processor vectors for an interrupt. All interrupt sources will push values into the stack registers. The values in the registers are then loaded back into their associated registers, if the RETFIE, FAST instruction is used to return from the interrupt.\nIf both low and high priority interrupts are enabled, the stack registers cannot be used reliably to return from low priority interrupts. If a high priority interrupt occurs while servicing a low priority interrupt, the stack register values  stored  by  the  low  priority  interrupt  will  be overwritten. In these cases, users must save the key registers in software during a low priority interrupt.",
    "6.1.3 FAST REGISTER STACK\nIf interrupt priority is not used, all interrupts may use the fast register stack for returns from interrupt. If no interrupts are used, the fast register stack can be used to restore the STATUS, WREG and BSR registers at the end of a subroutine call. To use the fast register stack for a subroutine call, a CALL label, FAST instruction must  be  executed  to  save  the  STATUS,  WREG  and BSR registers to the fast register stack. A RETURN, FAST instruction is then executed to restore these registers from the fast register stack.\nExample 6-1 shows a source code example that uses the  fast  register  stack  during  a  subroutine  call  and return.",
    "EXAMPLE 6-1: FAST REGISTER STACK CODE EXAMPLE\nCALL, 1 = SUB1, FAST ;STATUS, WREG, BSR ;SAVED IN FAST REGISTER ;STACK \uf0b7. SUB1, 1 = \uf0b7 \uf0b7 RETURN, FAST;RESTORE VALUES SAVED ;IN FAST REGISTER STACK",
    "6.1.4 LOOK-UP TABLES IN PROGRAM MEMORY\nThere may be programming situations that require the creation of data structures, or look-up tables, in program memory. For PIC18 devices, look-up tables can be implemented in two ways:\n\u00b7 Computed GOTO\n\u00b7 Table Reads",
    "6.1.4.1 Computed GOTO\nA computed GOTO is accomplished by adding an offset to  the  program  counter.  An  example  is  shown  in Example 6-2.\nA look-up  table  can  be  formed  with  an ADDWF  PCL instruction and a group of RETLW nn instructions. The W register is loaded with an offset into the table before executing a CALL to that table. The first instruction of the called routine is the ADDWF  PCL instruction. The next instruction executed will be one of the RETLW nn instructions,  that  returns  the  value  ' nn '  to  the  calling function.\nThe offset  value  (in  WREG)  specifies  the  number  of bytes  that  the  program  counter  should  advance  and should be multiples of 2 (LSb = 0 ).\nIn  this  method,  only  one  data  byte  may  be  stored  in each  instruction  location  and  room  on  the  return address stack is required.",
    "EXAMPLE 6-2: COMPUTED GOTO USING AN OFFSET VALUE\n, 1 = MOVF CALL. , 2 = OFFSET, W TABLE. ORG, 1 = nn00h. ORG, 2 = . TABLE, 1 = ADDWF. TABLE, 2 = PCL. , 1 = RETLW. , 2 = nnh. , 1 = RETLW. , 2 = nnh. , 1 = RETLW. , 2 = nnh. , 1 = .. , 2 = . , 1 = .. , 2 = . , 1 = .. , 2 = ",
    "6.1.4.2 Table Reads and Table Writes\nA  better  method  of  storing  data  in  program  memory allows two bytes of data to be stored in each instruction location.\nLook-up  table  data  may  be  stored  two  bytes  per program  word  by  using  table  reads  and  writes.  The Table  Pointer  (TBLPTR)  register  specifies  the  byte address and the Table Latch (TABLAT) register contains the data that is read from or written to program memory.  Data  is  transferred  to or from  program memory one byte at a time.\nTable  read  and  table  write  operations  are  discussed further in Section 5.1 'Table Reads  and  Table Writes' .",
    "6.2.1 CLOCKING SCHEME\nThe microcontroller clock input, whether from an internal or external source, is internally divided by four to generate four non-overlapping quadrature clocks (Q1, Q2, Q3 and Q4). Internally, the Program Counter (PC) is incremented on every Q1; the instruction is fetched from the program memory and latched into the Instruction Register (IR) during Q4. The instruction is decoded and executed during the following Q1 through Q4. The clocks  and  instruction  execution  flow  are  shown  in Figure 6-3.",
    "6.2.2 INSTRUCTION FLOW/PIPELINING\nAn  'Instruction  Cycle'  consists  of  four  Q  cycles:  Q1 through Q4. The instruction fetch and execute are pipelined in such a manner that a fetch takes one instruction cycle,  while  the  decode  and  execute  take  another instruction cycle. However, due to the pipelining, each instruction  effectively  executes  in  one  cycle.  If  an instruction causes the program counter to change (e.g., GOTO ),  then  two  cycles  are  required  to  complete  the instruction (Example 6-3).\nA fetch cycle begins with the program counter incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched into  the  Instruction  Register  (IR)  in  cycle  Q1.  This instruction  is  then  decoded  and  executed  during  the Q2, Q3 and Q4 cycles. Data memory is read during Q2 (operand  read)  and  written  during  Q4  (destination write).",
    "EXAMPLE 6-3: INSTRUCTION PIPELINE FLOW\nNote:\nAll instructions are single cycle, except for any program branches. These take two cycles since the fetch  instruction  is  'flushed'  from  the  pipeline  while  the  new  instruction  is  being  fetched  and  then executed.",
    "MEMORY\nThe program memory is addressed in bytes. Instructions are stored as two bytes or four bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSB = 0 ). To maintain alignment with instruction boundaries, the PC increments in steps of 2 and the LSB will always read ' 0 ' (see Section 6.1.1 'Program Counter' ).\nFigure 6-4 shows an example of how instruction words are stored in the program memory.\nThe CALL and GOTO instructions  have  the  absolute program memory address embedded into the instruction. Since  instructions  are  always  stored  on  word boundaries,  the  data  contained  in  the  instruction  is  a word address. The word address is written to PC<20:1>, which  accesses  the  desired  byte  address  in  program memory.  Instruction  #2  in  Figure 6-4  shows  how  the instruction GOTO  0006h is  encoded  in  the  program memory. Program branch instructions, which encode a relative address offset, operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions that the PC will be offset  by. Section 25.0  'Instruction  Set  Summary' provides further details of the instruction set.",
    "FIGURE 6-4: INSTRUCTIONS IN PROGRAM MEMORY\nProgram Memory\nByte Locations\n\uf0ae\uf020\nInstruction 1:\nInstruction 2:\nMOVLW\n055h\nGOTO\n0006h\nInstruction 3:\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address \uf0af. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. EFh, 1 = 03h. EFh, 2 = 00000Ah. F0h, 1 = 00h. F0h, 2 = 00000Ch. C1h, 1 = 23h. C1h, 2 = 00000Eh. F4h, 1 = 56h. F4h, 2 = 000010h. , 1 = . , 2 = 000012h. , 1 = . , 2 = 000014h\nMOVFF\n123h, 456h",
    "6.2.4 TWO-WORD INSTRUCTIONS\nThe standard PIC18 instruction set has four two-word instructions: CALL , MOVFF , GOTO and LSFR . In  all cases, the second word of the instructions always has ' 1111 ' as its four Most Significant bits; the other 12 bits are literal data, usually a data memory address.\nThe  use  of  ' 1111 '  in  the  4  MSbs  of  an  instruction specifies  a  special  form  of NOP .  If  the  instruction  is executed in proper sequence - immediately after the first  word - the data in the second word is accessed and used by the instruction sequence. If the first word is  skipped  for  some  reason  and  the  second  word  is executed by itself, a NOP is executed instead. This is necessary for cases when the two-word instruction is preceded by a conditional instruction that changes the PC. Example 6-4 shows how this works.",
    "Note:\nSee Section 6.5 'Program Memory and the Extended Instruction Set' for information on two-word instructions in the extended instruction set.",
    "EXAMPLE 6-4: TWO-WORD INSTRUCTIONS\n0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ; is RAM location. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:.Source Code = ; No, skip this word. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE",
    "EXAMPLE 6-4: TWO-WORD INSTRUCTIONS\n1:.Source Code = . 1111, CASE 1:.Source Code = ; Execute this word as a NOP. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ; continue code. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Object Code = Object",
    "EXAMPLE 6-4: TWO-WORD INSTRUCTIONS\nCode. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. 0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ; is RAM location. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:.Source Code = ; Yes, execute this",
    "EXAMPLE 6-4: TWO-WORD INSTRUCTIONS\nword. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; 2nd word of instruction. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ; continue code",
    "6.3.1 BANK SELECT REGISTER (BSR)\nNote:\nThe  operation  of  some  aspects  of  data memory  are  changed  when  the  PIC18 extended instruction  set  is  enabled.  See Section 6.6 'Data Memory  and the Extended Instruction Set' for more information.\nThe data memory in PIC18 devices is implemented as static  RAM. Each register in the data memory has a 12-bit  address,  allowing  up  to  4096  bytes  of  data memory. The memory space is divided into as many as 16 banks that contain 256 bytes each; PIC18F2585/2680/4585/4680  devices  implement  all 16 banks. Figure 6-5 shows the data memory organization for the PIC18F2585/2680/4585/4680 devices.\nThe data memory contains Special Function Registers (SFRs) and General Purpose Registers (GPRs). The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratchpad operations in the user's application. Any read of an unimplemented location will read as ' 0 's.",
    "6.3.1 BANK SELECT REGISTER (BSR)\nThe instruction  set  and  architecture  allow  operations across  all  banks.  The  entire  data  memory  may  be accessed  by  Direct,  Indirect  or  Indexed  Addressing modes. Addressing modes are discussed later in this subsection.\nTo  ensure  that  commonly  used  registers  (SFRs  and select GPRs) can be accessed in a single cycle, PIC18 devices implement an Access Bank. This is a 256-byte memory space that provides fast access to SFRs and the  lower  portion  of  GPR  Bank  0  without  using  the BSR. Section 6.3.2 'Access Bank' provides a detailed description of the Access RAM.\nLarge  areas  of  data  memory  require  an  efficient addressing  scheme  to  make  rapid  access  to  any address  possible.  Ideally,  this  means  that  an  entire address does not need to be provided for each read or write  operation.  For  PIC18  devices,  this  is  accomplished with a RAM banking scheme. This divides the memory space into 16 contiguous banks of 256 bytes. Depending  on  the  instruction,  each  location  can  be addressed directly by its full 12-bit address, or an 8-bit low-order address and a 4-bit bank pointer.",
    "6.3.1 BANK SELECT REGISTER (BSR)\nMost instructions in the PIC18 instruction set make use of the bank pointer, known as the Bank Select Register (BSR). This SFR holds the 4 Most Significant bits of a location's  address;  the  instruction  itself  includes  the 8 Least Significant bits. Only the four lower bits of the BSR are implemented (BSR3:BSR0). The upper four bits are unused; they will always read ' 0 ' and cannot be written to. The BSR can be loaded directly by using the MOVLB instruction.\nThe value of the BSR indicates the bank in data memory; the 8 bits in the instruction show the location in the bank and can be thought of as an offset from the bank's lower boundary. The relationship between the BSR's value and the bank division in data memory is shown in Figure 6-6.",
    "6.3.1 BANK SELECT REGISTER (BSR)\nSince up to 16 registers may share the same low-order address, the user must always be careful to ensure that the proper bank is selected before performing a data read  or  write.  For  example,  writing  what  should  be program data to an 8-bit address of F9h while the BSR is 0Fh, will end up resetting the program counter.\nWhile any bank can be selected, only those banks that are  actually  implemented  can  be  read  or  written  to. Writes  to  unimplemented  banks  are  ignored,  while reads from unimplemented banks will return ' 0 's. Even so, the STATUS register will still be affected as if the operation  was  successful.  The  data  memory  map  in Figure 6-5 indicates which banks are implemented.\nIn  the  core  PIC18  instruction  set,  only  the MOVFF instruction  fully  specifies  the  12-bit  address  of  the source and target registers. This instruction ignores the BSR completely when it executes. All other instructions include only the low-order address as an operand and must use either the BSR or the Access Bank to locate their target registers.\nFIGURE 6-5:",
    "DATA MEMORY MAP FOR PIC18F2585/2680/4585/4680 DEVICES\nBSR<3:0> = 0000,  = . BSR<3:0> = 0000,  = 00h. BSR<3:0> = 0000, Data Memory Map = Access RAM. BSR<3:0> = 0000,  = The BSR is ignored and the Access Bank is used.. BSR<3:0> = 0000, When a = 0 : = 000h. = 0001,  = Bank 0. = 0001,  = FFh 00h. = 0001, Data Memory Map = GPR. = 0001,  = 060h 05Fh 100h 0FFh. = 0001, When a = 0 : = The first 128 bytes are general purpose RAM (from Bank 0).. = 0010,  = Bank 1. = 0010,  = FFh 00h. = 0010, Data Memory Map = GPR. = 0010,  = 1FFh 200h. = 0010, When a = 0 : = The second 128 bytes are Special Function Registers (from Bank 15).. = 0011,",
    "DATA MEMORY MAP FOR PIC18F2585/2680/4585/4680 DEVICES\n= Bank 2 Bank. = 0011,  = FFh 00h. = 0011, Data Memory Map = GPR GPR. = 0011,  = used 2FFh 300h. = 0011, When a = 0 : = When a = 1 : The BSR specifies the Bank by the instruction. 3. = 0100,  = Bank 4. = 0100,  = FFh 00h. = 0100, Data Memory Map = GPR. = 0100,  = 3FFh 400h. = 0100, When a = 0 : = . =,  = Bank. =,  = FFh 00h. =, Data Memory Map = . =,  = 4FFh 500h. =, When a = 0 : = 5 0101. = 0110,  = . = 0110,  = FFh 00h. = 0110, Data Memory Map = GPR GPR. = 0110,  = 5FFh 600h. = 0110, When a = 0 : = Access Bank. = 0111,  = Bank 6 Bank. = 0111,",
    "DATA MEMORY MAP FOR PIC18F2585/2680/4585/4680 DEVICES\n= FFh 00h. = 0111, Data Memory Map = GPR. = 0111,  = 700h. = 0111, When a = 0 : = 00h 5Fh Access RAM Low 6FFh 7. = 1000,  = Bank 8. = 1000,  = FFh 00h. = 1000, Data Memory Map = GPR. = 1000,  = 7FFh 800h. = 1000, When a = 0 : = 60h FFh Access RAM High (SFRs). = 1001,  = Bank 9. = 1001,  = FFh 00h. = 1001, Data Memory Map = GPR. = 1001,  = 8FFh 900h. = 1001, When a = 0 : = . = 1010,  = . = 1010,  = FFh. = 1010, Data Memory Map = . = 1010,  = 9FFh A00h. = 1010, When a = 0 : = . ,  = Bank 10. ,  = 00h. , Data Memory Map = GPR. ,  = . , When a = 0 : = . = 1011,",
    "DATA MEMORY MAP FOR PIC18F2585/2680/4585/4680 DEVICES\n= Bank 11. = 1011,  = FFh 00h. = 1011, Data Memory Map = GPR. = 1011,  = AFFh B00h. = 1011, When a = 0 : = . = 1100,  = Bank 12. = 1100,  = FFh 00h. = 1100, Data Memory Map = GPR. = 1100,  = BFFh C00h. = 1100, When a = 0 : = . = 1101,  = . = 1101,  = FFh. = 1101, Data Memory Map = CAN SFRs. = 1101,  = CFFh D00h. = 1101, When a = 0 : = . = 1110,  = Bank 13. = 1110,  = 00h. = 1110, Data Memory Map = . = 1110,  = DFFh E00h. = 1110, When a = 0 : = . = 1111,  = Bank 14 Bank. = 1111,  = 00h FFh FFh 00h. = 1111, Data Memory Map = CAN SFRs CAN SFRs. = 1111,",
    "DATA MEMORY MAP FOR PIC18F2585/2680/4585/4680 DEVICES\n= F5Fh F00h EFFh. = 1111, When a = 0 : = 15 F60h",
    "FIGURE 6-6: USE OF THE BANK SELECT REGISTER (DIRECT ADDRESSING)\nNote 1: The Access RAM bit of the instruction can be used to force an override of the selected bank (BSR<3:0>) to the registers of the Access Bank.\n2: The MOVFF instruction embeds the entire 12-bit address in the instruction.",
    "6.3.2 ACCESS BANK\nWhile  the  use  of  the  BSR  with  an  embedded  8-bit address  allows  users  to  address  the  entire  range  of data memory, it also means that the user must always ensure  that  the  correct  bank  is  selected.  Otherwise, data may be read from or written to the wrong location. This can be disastrous if a GPR is the intended target of  an  operation,  but  an  SFR  is  written  to  instead. Verifying  and/or  changing  the  BSR  for  each  read  or write to data memory can become very inefficient.\nhowever,  the  instruction  is  forced  to  use  the  Access Bank  address  map;  the  current  value  of  the  BSR  is ignored entirely.",
    "6.3.2 ACCESS BANK\nTo streamline access for the most commonly used data memory locations, the data memory is configured with an  Access  Bank,  which  allows  users  to  access  a mapped block of  memory  without  specifying  a  BSR. The  Access  Bank  consists  of  the  first  128  bytes  of memory (00h-7Fh) in Bank 0 and the last 128 bytes of memory (80h-FFh) in Block 15. The lower half is known as the 'Access RAM' and is composed of GPRs. The upper  half is also where  the  device's  SFRs  are mapped. These two areas are mapped contiguously in the  Access  Bank  and  can  be  addressed  in  a  linear fashion by an 8-bit address (Figure 6-5).\nThe Access Bank is used by core PIC18 instructions that include the Access RAM bit (the 'a' parameter in the instruction). When 'a' is equal to ' 1 ', the instruction uses  the  BSR  and  the  8-bit  address  included  in  the opcode for the data memory address. When 'a' is ' 0 '",
    "6.3.2 ACCESS BANK\nUsing this 'forced' addressing allows the instruction to operate on a data address in a single cycle, without updating the BSR first. For 8-bit addresses of 80h and above, this means that users can evaluate and operate on SFRs more efficiently. The Access RAM below 80h is a good place for data values that the user might need to  access  rapidly,  such  as  immediate  computational results  or  common  program  variables.  Access  RAM also allows for faster and more code efficient context saving and switching of variables.\nThe mapping of the Access Bank is slightly different when the extended instruction set is enabled (XINST Configuration bit = 1 ). This is discussed in more detail in Section 6.6.3  'Mapping  the  Access  Bank  in Indexed Literal Offset Mode' .",
    "6.3.3 GENERAL PURPOSE REGISTER FILE\nPIC18 devices may have banked memory in the GPR area. This is data RAM, which is available for use by all instructions.  GPRs  start  at  the  bottom  of  Bank  0 (address 000h) and grow upwards towards the bottom of the SFR  area.  GPRs  are  not  initialized  by  a Power-on  Reset  and  are  unchanged  on  all  other Resets.",
    "6.3.4 SPECIAL FUNCTION REGISTERS\nThe Special  Function  Registers  (SFRs)  are  registers used by the CPU and peripheral modules for controlling the desired operation of the device. These registers are implemented as static RAM. SFRs start at the top of data memory (FFFh) and extend downward to occupy the top half of Bank 15 (F80h to FFFh). A list of these registers is given in Table 6-1 and Table 6-2.\nperipheral functions. The reset and interrupt registers are  described  in  their  respective  chapters,  while  the ALU's  STATUS  register  is  described  later  in  this section. Registers related to the operation of a peripheral feature are described in the chapter for that peripheral.\nThe  SFRs  can  be  classified  into  two  sets:  those associated  with  the  'core'  device  functionality  (ALU, Resets and interrupts) and those related to the\nThe SFRs are typically distributed among the peripherals whose functions they control. Unused SFR locations are unimplemented and read as ' 0 's.\n\nTABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES",
    "6.3.4 SPECIAL FUNCTION REGISTERS\nFFFh, Name = TOSU. FFFh, Address = FDFh. FFFh, Name = INDF2 (3). FFEh, Name = TOSH. FFEh, Address = FDEh. FFEh, Name = POSTINC2 (3). FFDh, Name = TOSL. FFDh, Address = FDDh. FFDh, Name = POSTDEC2 (3). FFCh, Name = STKPTR. FFCh, Address = FDCh. FFCh, Name = PREINC2 (3). FFBh, Name = PCLATU. FFBh, Address = FDBh. FFBh, Name = PLUSW2 (3). FFAh, Name = PCLATH. FFAh, Address = FDAh. FFAh, Name = FSR2H. FF9h, Name = PCL. FF9h, Address = FD9h. FF9h, Name = FSR2L. FF8h, Name = TBLPTRU. FF8h, Address = FD8h. FF8h, Name = STATUS. FF7h, Name =",
    "6.3.4 SPECIAL FUNCTION REGISTERS\nTBLPTRH. FF7h, Address = FD7h. FF7h, Name = TMR0H. FF6h, Name = TBLPTRL. FF6h, Address = FD6h. FF6h, Name = TMR0L. FF5h, Name = TABLAT. FF5h, Address = FD5h. FF5h, Name = T0CON. FF4h, Name = PRODH. FF4h, Address = FD4h. FF4h, Name = -. FF3h, Name = PRODL. FF3h, Address = FD3h. FF3h, Name = OSCCON. FF2h, Name = INTCON. FF2h, Address = FD2h. FF2h, Name = HLVDCON. FF1h, Name = INTCON2. FF1h, Address = FD1h. FF1h, Name = WDTCON. FF0h, Name = INTCON3. FF0h, Address = FD0h. FF0h, Name = RCON. FEFh, Name =",
    "6.3.4 SPECIAL FUNCTION REGISTERS\nINDF0 (3). FEFh, Address = FCFh. FEFh, Name = TMR1H. FEEh, Name = POSTINC0 (3). FEEh, Address = FCEh. FEEh, Name = TMR1L. FEDh, Name = POSTDEC0 (3). FEDh, Address = FCDh. FEDh, Name = T1CON. FECh, Name = PREINC0 (3). FECh, Address = FCCh. FECh, Name = TMR2. FEBh, Name = PLUSW0 (3). FEBh, Address = FCBh. FEBh, Name = PR2. FEAh, Name = FSR0H. FEAh, Address = FCAh. FEAh, Name = T2CON. FE9h, Name = FSR0L. FE9h, Address = FC9h. FE9h, Name = SSPBUF. FE8h, Name = WREG. FE8h, Address = FC8h. FE8h, Name = SSPADD. FE7h, Name = INDF1",
    "6.3.4 SPECIAL FUNCTION REGISTERS\n(3). FE7h, Address = FC7h. FE7h, Name = SSPSTAT. FE6h, Name = POSTINC1 (3). FE6h, Address = FC6h. FE6h, Name = SSPCON1. FE5h, Name = POSTDEC1 (3). FE5h, Address = FC5h. FE5h, Name = SSPCON2. FE4h, Name = PREINC1 (3). FE4h, Address = FC4h. FE4h, Name = ADRESH. FE3h, Name = PLUSW1 (3). FE3h, Address = FC3h. FE3h, Name = ADRESL. FE2h, Name = FSR1H. FE2h, Address = FC2h. FE2h, Name = ADCON0. FE1h, Name = FSR1L. FE1h, Address = FC1h. FE1h, Name = ADCON1. FE0h, Name = BSR. FE0h, Address = FC0h. FE0h, Name =",
    "6.3.4 SPECIAL FUNCTION REGISTERS\nADCON2\nAddress\nName",
    "6.3.4 SPECIAL FUNCTION REGISTERS\nFBFh, 1 = CCPR1H. FBEh, 1 = CCPR1L. FBDh, 1 = CCP1CON. FBCh, 1 = ECCPR1H (1). FBBh, 1 = ECCPR1L (1). FBAh, 1 = ECCP1CON (1). FB9h, 1 = -. FB8h, 1 = BAUDCON. FB7h, 1 = ECCP1DEL. FB6h, 1 = ECCP1AS (1). FB5h, 1 = CVRCON (1). FB4h, 1 = CMCON. FB3h, 1 = TMR3H. FB2h, 1 = TMR3L. FB1h, 1 = T3CON. FB0h, 1 = SPBRGH. FAFh, 1 = SPBRG. FAEh, 1 = RCREG. FADh, 1 = TXREG. FACh, 1 = TXSTA. FABh, 1 = RCSTA. FAAh, 1 = EEADRH.",
    "6.3.4 SPECIAL FUNCTION REGISTERS\nFA9h, 1 = EEADR. FA8h, 1 = EEDATA. FA7h, 1 = EECON2 (3). FA6h, 1 = EECON1. FA5h, 1 = IPR3. FA4h, 1 = PIR3. FA3h, 1 = PIE3. FA2h, 1 = IPR2. FA1h, 1 = PIR2. FA0h, 1 = PIE2\nNote",
    "6.3.4 SPECIAL FUNCTION REGISTERS\nF9Fh, Name = IPR1. F9Eh, Name = PIR1. F9Dh, Name = PIE1. F9Ch, Name = -. F9Bh, Name = OSCTUNE. F9Ah, Name = -. F99h, Name = -. F98h, Name = -. F97h, Name = -. F96h, Name = TRISE (1). F95h, Name = TRISD (1). F94h, Name = TRISC. F93h, Name = TRISB. F92h, Name = TRISA. F91h, Name = -. F90h, Name = -. F8Fh, Name = -. F8Eh, Name = -. F8Dh, Name = LATE (1). F8Ch, Name = LATD (1). F8Bh, Name = LATC. F8Ah, Name = LATB. F89h, Name = LATA. F88h, Name = -. F87h, Name = -. F86h,",
    "6.3.4 SPECIAL FUNCTION REGISTERS\nName = -. F85h, Name = -. F84h, Name = PORTE (1). F83h, Name = PORTD (1). F82h, Name = PORTC. F81h, Name = PORTB. F80h, Name = PORTA\n1: Registers available only on PIC18F4X8X devices; otherwise, the registers read as ' 0 '.\n2: When any TX_ENn bit in RX_TX_SELn is set, then the corresponding bit in this register has transmit properties.\n3: This is not a physical register.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nF7Fh, Name = -. F7Fh, Address = F5Fh. F7Fh, Name = CANCON_RO0. F7Fh, Address = F3Fh. F7Fh, Name = CANCON_RO2. F7Fh, Address = F1Fh. F7Fh, Name = RXM1EIDL. F7Eh, Name = -. F7Eh, Address = F5Eh. F7Eh, Name = CANSTAT_RO0. F7Eh, Address = F3Eh. F7Eh, Name = CANSTAT_RO2. F7Eh, Address = F1Eh. F7Eh, Name = RXM1EIDH. F7Dh, Name = -. F7Dh, Address = F5Dh. F7Dh, Name = RXB1D7. F7Dh, Address = F3Dh. F7Dh, Name = TXB1D7. F7Dh, Address = F1Dh. F7Dh, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nRXM1SIDL. F7Ch, Name = -. F7Ch, Address = F5Ch. F7Ch, Name = RXB1D6. F7Ch, Address = F3Ch. F7Ch, Name = TXB1D6. F7Ch, Address = F1Ch. F7Ch, Name = RXM1SIDH. F7Bh, Name = -. F7Bh, Address = F5Bh. F7Bh, Name = RXB1D5. F7Bh, Address = F3Bh. F7Bh, Name = TXB1D5. F7Bh, Address = F1Bh. F7Bh, Name = RXM0EIDL. F7Ah, Name = -. F7Ah, Address = F5Ah. F7Ah, Name = RXB1D4. F7Ah, Address = F3Ah. F7Ah, Name = TXB1D4. F7Ah, Address = F1Ah. F7Ah, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nRXM0EIDH. F79h, Name = -. F79h, Address = F59h. F79h, Name = RXB1D3. F79h, Address = F39h. F79h, Name = TXB1D3. F79h, Address = F19h. F79h, Name = RXM0SIDL. F78h, Name = -. F78h, Address = F58h. F78h, Name = RXB1D2. F78h, Address = F38h. F78h, Name = TXB1D2. F78h, Address = F18h. F78h, Name = RXM0SIDH. F77h, Name = ECANCON. F77h, Address = F57h. F77h, Name = RXB1D1. F77h, Address = F37h. F77h, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nTXB1D1. F77h, Address = F17h. F77h, Name = RXF5EIDL. F76h, Name = TXERRCNT. F76h, Address = F56h. F76h, Name = RXB1D0. F76h, Address = F36h. F76h, Name = TXB1D0. F76h, Address = F16h. F76h, Name = RXF5EIDH. F75h, Name = RXERRCNT. F75h, Address = F55h. F75h, Name = RXB1DLC. F75h, Address = F35h. F75h, Name = TXB1DLC. F75h, Address = F15h. F75h, Name = RXF5SIDL. F74h, Name = COMSTAT. F74h, Address = F54h. F74h, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nRXB1EIDL. F74h, Address = F34h. F74h, Name = TXB1EIDL. F74h, Address = F14h. F74h, Name = RXF5SIDH. F73h, Name = CIOCON. F73h, Address = F53h. F73h, Name = RXB1EIDH. F73h, Address = F33h. F73h, Name = TXB1EIDH. F73h, Address = F13h. F73h, Name = RXF4EIDL. F72h, Name = BRGCON3. F72h, Address = F52h. F72h, Name = RXB1SIDL. F72h, Address = F32h. F72h, Name = TXB1SIDL. F72h, Address = F12h. F72h, Name = RXF4EIDH.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nF71h, Name = BRGCON2. F71h, Address = F51h. F71h, Name = RXB1SIDH. F71h, Address = F31h. F71h, Name = TXB1SIDH. F71h, Address = F11h. F71h, Name = RXF4SIDL. F70h, Name = BRGCON1. F70h, Address = F50h. F70h, Name = RXB1CON. F70h, Address = F30h. F70h, Name = TXB1CON. F70h, Address = F10h. F70h, Name = RXF4SIDH. F6Fh, Name = CANCON. F6Fh, Address = F4Fh. F6Fh, Name = CANCON_RO1. F6Fh, Address = F2Fh. F6Fh, Name = CANCON_RO3. F6Fh,",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nAddress = F0Fh. F6Fh, Name = RXF3EIDL. F6Eh, Name = CANSTAT. F6Eh, Address = F4Eh. F6Eh, Name = CANSTAT_RO1. F6Eh, Address = F2Eh. F6Eh, Name = CANSTAT_RO3. F6Eh, Address = F0Eh. F6Eh, Name = RXF3EIDH. F6Dh, Name = RXB0D7. F6Dh, Address = F4DH. F6Dh, Name = TXB0D7. F6Dh, Address = F2Dh. F6Dh, Name = TXB2D7. F6Dh, Address = F0Dh. F6Dh, Name = RXF3SIDL. F6Ch, Name = RXB0D6. F6Ch, Address = F4Ch. F6Ch, Name = TXB0D6. F6Ch, Address = F2Ch. F6Ch, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nTXB2D6. F6Ch, Address = F0Ch. F6Ch, Name = RXF3SIDH. F6Bh, Name = RXB0D5. F6Bh, Address = F4Bh. F6Bh, Name = TXB0D5. F6Bh, Address = F2Bh. F6Bh, Name = TXB2D5. F6Bh, Address = F0Bh. F6Bh, Name = RXF2EIDL. F6Ah, Name = RXB0D4. F6Ah, Address = F4Ah. F6Ah, Name = TXB0D4. F6Ah, Address = F2Ah. F6Ah, Name = TXB2D4. F6Ah, Address = F0Ah. F6Ah, Name = RXF2EIDH. F69h, Name = RXB0D3. F69h, Address = F49h. F69h, Name = TXB0D3.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nF69h, Address = F29h. F69h, Name = TXB2D3. F69h, Address = F09h. F69h, Name = RXF2SIDL. F68h, Name = RXB0D2. F68h, Address = F48h. F68h, Name = TXB0D2. F68h, Address = F28h. F68h, Name = TXB2D2. F68h, Address = F08h. F68h, Name = RXF2SIDH. F67h, Name = RXB0D1. F67h, Address = F47h. F67h, Name = TXB0D1. F67h, Address = F27h. F67h, Name = TXB2D1. F67h, Address = F07h. F67h, Name = RXF1EIDL.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nF66h, Name = RXB0D0. F66h, Address = F46h. F66h, Name = TXB0D0. F66h, Address = F26h. F66h, Name = TXB2D0. F66h, Address = F06h. F66h, Name = RXF1EIDH. F65h, Name = RXB0DLC. F65h, Address = F45h. F65h, Name = TXB0DLC. F65h, Address = F25h. F65h, Name = TXB2DLC. F65h, Address = F05h. F65h, Name = RXF1SIDL. F64h, Name = RXB0EIDL. F64h, Address = F44h. F64h, Name = TXB0EIDL. F64h, Address = F24h. F64h, Name = TXB2EIDL. F64h, Address =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nF04h. F64h, Name = RXF1SIDH. F63h, Name = RXB0EIDH. F63h, Address = F43h. F63h, Name = TXB0EIDH. F63h, Address = F23h. F63h, Name = TXB2EIDH. F63h, Address = F03h. F63h, Name = RXF0EIDL. F62h, Name = RXB0SIDL. F62h, Address = F42h. F62h, Name = TXB0SIDL. F62h, Address = F22h. F62h, Name = TXB2SIDL. F62h, Address = F02h. F62h, Name = RXF0EIDH. F61h, Name = RXB0SIDH. F61h, Address = F41h. F61h, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nTXB0SIDH. F61h, Address = F21h. F61h, Name = TXB2SIDH. F61h, Address = F01h. F61h, Name = RXF0SIDL. F60h, Name = RXB0CON. F60h, Address = F40h. F60h, Name = TXB0CON. F60h, Address = F20h. F60h, Name = TXB2CON. F60h, Address = F00h. F60h, Name = RXF0SIDH\nNote\n1: Registers available only on PIC18F4X8X devices; otherwise, the registers read as ' 0 '.\n2: When any TX_ENn bit in RX_TX_SELn is set, then the corresponding bit in this register has transmit properties.\n3: This is not a physical register.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nEFFh, Name = -. EFFh, Address = EDFh. EFFh, Name = -. EFFh, Address = EBFh. EFFh, Name = -. EFFh, Address = E9Fh. EFFh, Name = -. EFEh, Name = -. EFEh, Address = EDEh. EFEh, Name = -. EFEh, Address = EBEh. EFEh, Name = -. EFEh, Address = E9Eh. EFEh, Name = -. EFDh, Name = -. EFDh, Address = EDDh. EFDh, Name = -. EFDh, Address = EBDh. EFDh, Name = -. EFDh, Address = E9Dh. EFDh, Name = -. EFCh, Name = -. EFCh, Address = EDCh. EFCh, Name = -. EFCh, Address = EBCh. EFCh, Name = -.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nEFCh, Address = E9Ch. EFCh, Name = -. EFBh, Name = -. EFBh, Address = EDBh. EFBh, Name = -. EFBh, Address = EBBh. EFBh, Name = -. EFBh, Address = E9Bh. EFBh, Name = -. EFAh, Name = -. EFAh, Address = EDAh. EFAh, Name = -. EFAh, Address = EBAh. EFAh, Name = -. EFAh, Address = E9Ah. EFAh, Name = -. EF9h, Name = -. EF9h, Address = ED9h. EF9h, Name = -. EF9h, Address = EB9h. EF9h, Name = -. EF9h, Address = E99h. EF9h, Name = -. EF8h, Name = -. EF8h, Address =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nED8h. EF8h, Name = -. EF8h, Address = EB8h. EF8h, Name = -. EF8h, Address = E98h. EF8h, Name = -. EF7h, Name = -. EF7h, Address = ED7h. EF7h, Name = -. EF7h, Address = EB7h. EF7h, Name = -. EF7h, Address = E97h. EF7h, Name = -. EF6h, Name = -. EF6h, Address = ED6h. EF6h, Name = -. EF6h, Address = EB6h. EF6h, Name = -. EF6h, Address = E96h. EF6h, Name = -. EF5h, Name = -. EF5h, Address = ED5h. EF5h, Name = -.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nEF5h, Address = EB5h. EF5h, Name = -. EF5h, Address = E95h. EF5h, Name = -. EF4h, Name = -. EF4h, Address = ED4h. EF4h, Name = -. EF4h, Address = EB4h. EF4h, Name = -. EF4h, Address = E94h. EF4h, Name = -. EF3h, Name = -. EF3h, Address = ED3h. EF3h, Name = -. EF3h, Address = EB3h. EF3h, Name = -. EF3h, Address = E93h. EF3h, Name = -. EF2h, Name = -. EF2h, Address = ED2h. EF2h, Name = -. EF2h, Address = EB2h.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nEF2h, Name = -. EF2h, Address = E92h. EF2h, Name = -. EF1h, Name = -. EF1h, Address = ED1h. EF1h, Name = -. EF1h, Address = EB1h. EF1h, Name = -. EF1h, Address = E91h. EF1h, Name = -. EF0h, Name = -. EF0h, Address = ED0h. EF0h, Name = -. EF0h, Address = EB0h. EF0h, Name = -. EF0h, Address = E90h. EF0h, Name = -. EEFh, Name = -. EEFh, Address = ECFh. EEFh, Name = -. EEFh, Address = EAFh. EEFh, Name = -. EEFh, Address = E8Fh.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nEEFh, Name = -. EEEh, Name = -. EEEh, Address = ECEh. EEEh, Name = -. EEEh, Address = EAEh. EEEh, Name = -. EEEh, Address = E8Eh. EEEh, Name = -. EEDh, Name = -. EEDh, Address = ECDh. EEDh, Name = -. EEDh, Address = EADh. EEDh, Name = -. EEDh, Address = E8Dh. EEDh, Name = -. EECh, Name = -. EECh, Address = ECCh. EECh, Name = -. EECh, Address = EACh. EECh, Name = -. EECh, Address = E8Ch. EECh, Name = -. EEBh, Name = -. EEBh, Address = ECBh. EEBh, Name = -. EEBh, Address = EABh. EEBh, Name = -. EEBh, Address = E8Bh. EEBh, Name = -. EEAh, Name = -.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nEEAh, Address = ECAh. EEAh, Name = -. EEAh, Address = EAAh. EEAh, Name = -. EEAh, Address = E8Ah. EEAh, Name = -. EE9h, Name = -. EE9h, Address = EC9h. EE9h, Name = -. EE9h, Address = EA9h. EE9h, Name = -. EE9h, Address = E89h. EE9h, Name = -. EE8h, Name = -. EE8h, Address = EC8h. EE8h, Name = -. EE8h, Address = EA8h. EE8h, Name = -. EE8h, Address = E88h. EE8h, Name = -. EE7h, Name = -. EE7h, Address = EC7h. EE7h, Name = -. EE7h, Address = EA7h. EE7h, Name = -. EE7h, Address = E87h.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nEE7h, Name = -. EE6h, Name = -. EE6h, Address = EC6h. EE6h, Name = -. EE6h, Address = EA6h. EE6h, Name = -. EE6h, Address = E86h. EE6h, Name = -. EE5h, Name = -. EE5h, Address = EC5h. EE5h, Name = -. EE5h, Address = EA5h. EE5h, Name = -. EE5h, Address = E85h. EE5h, Name = -. EE4h, Name = -. EE4h, Address = EC4h. EE4h, Name = -. EE4h, Address = EA4h. EE4h, Name = -. EE4h, Address = E84h. EE4h, Name = -. EE3h, Name = -. EE3h, Address = EC3h. EE3h, Name = -. EE3h, Address =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nEA3h. EE3h, Name = -. EE3h, Address = E83h. EE3h, Name = -. EE2h, Name = -. EE2h, Address = EC2h. EE2h, Name = -. EE2h, Address = EA2h. EE2h, Name = -. EE2h, Address = E82h. EE2h, Name = -. EE1h, Name = -. EE1h, Address = EC1h. EE1h, Name = -. EE1h, Address = EA1h. EE1h, Name = -. EE1h, Address = E81h. EE1h, Name = -. EE0h, Name = -. EE0h, Address = EC0h. EE0h, Name = -. EE0h, Address = EA0h. EE0h, Name = -. EE0h, Address = E80h. EE0h, Name = -",
    "Note\n1: Registers available only on PIC18F4X8X devices; otherwise, the registers read as ' 0 '.\n2: When any TX_ENn bit in RX_TX_SELn is set, then the corresponding bit in this register has transmit properties.\n3: This is not a physical register.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nE7Fh, Name = CANCON_RO4. E7Fh, Address = E6Fh. E7Fh, Name = CANCON_RO5. E7Fh, Address = E5Fh. E7Fh, Name = CANCON_RO6. E7Fh, Address = E4Fh. E7Fh, Name = CANCON_RO7. E7Eh, Name = CANSTAT_RO4. E7Eh, Address = E6Eh. E7Eh, Name = CANSTAT_RO5. E7Eh, Address = E5Eh. E7Eh, Name = CANSTAT_RO6. E7Eh, Address = E4Eh. E7Eh, Name = CANSTAT_RO7. E7Dh, Name = B5D7 (2). E7Dh, Address = E6Dh. E7Dh, Name = B4D7 (2). E7Dh, Address = E5Dh. E7Dh, Name = B3D7 (2).",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nE7Dh, Address = E4Dh. E7Dh, Name = B2D7 (2). E7Ch, Name = B5D6 (2). E7Ch, Address = E6Ch. E7Ch, Name = B4D6 (2). E7Ch, Address = E5Ch. E7Ch, Name = B3D6 (2). E7Ch, Address = E4Ch. E7Ch, Name = B2D6 (2). E7Bh, Name = B5D5 (2). E7Bh, Address = E6Bh. E7Bh, Name = B4D5 (2). E7Bh, Address = E5Bh. E7Bh, Name = B3D5 (2). E7Bh, Address = E4Bh. E7Bh, Name = B2D5 (2). E7Ah, Name = B5D4 (2). E7Ah, Address = E6Ah. E7Ah, Name = B4D4",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\n(2). E7Ah, Address = E5Ah. E7Ah, Name = B3D4 (2). E7Ah, Address = E4Ah. E7Ah, Name = B2D4 (2). E79h, Name = B5D3 (2). E79h, Address = E69h. E79h, Name = B4D3 (2). E79h, Address = E59h. E79h, Name = B3D3 (2). E79h, Address = E49h. E79h, Name = B2D3 (2). E78h, Name = B5D2 (2). E78h, Address = E68h. E78h, Name = B4D2 (2). E78h, Address = E58h. E78h, Name = B3D2 (2). E78h, Address = E48h. E78h, Name",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\n= B2D2 (2). E77h, Name = B5D1 (2). E77h, Address = E67h. E77h, Name = B4D1 (2). E77h, Address = E57h. E77h, Name = B3D1 (2). E77h, Address = E47h. E77h, Name = B2D1 (2). E76h, Name = B5D0 (2). E76h, Address = E66h. E76h, Name = B4D0 (2). E76h, Address = E56h. E76h, Name = B3D0 (2). E76h, Address = E46h. E76h, Name = B2D0 (2). E75h, Name = B5DLC (2). E75h, Address = E65h. E75h, Name = B4DLC",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\n(2). E75h, Address = E55h. E75h, Name = B3DLC (2). E75h, Address = E45h. E75h, Name = B2DLC (2). E74h, Name = B5EIDL (2). E74h, Address = E64h. E74h, Name = B4EIDL (2). E74h, Address = E54h. E74h, Name = B3EIDL (2). E74h, Address = E44h. E74h, Name = B2EIDL (2). E73h, Name = B5EIDH (2). E73h, Address = E63h. E73h, Name = B4EIDH (2). E73h, Address = E53h. E73h, Name = B3EIDH (2). E73h, Address = E43h. E73h,",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nName = B2EIDH (2). E72h, Name = B5SIDL (2). E72h, Address = E62h. E72h, Name = B4SIDL (2). E72h, Address = E52h. E72h, Name = B3SIDL (2). E72h, Address = E42h. E72h, Name = B2SIDL (2). E71h, Name = B5SIDH (2). E71h, Address = E61h. E71h, Name = B4SIDH (2). E71h, Address = E51h. E71h, Name = B3SIDH (2). E71h, Address = E41h. E71h, Name = B2SIDH (2). E70h, Name = B5CON (2). E70h, Address = E60h. E70h, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nB4CON (2). E70h, Address = E50h. E70h, Name = B3CON (2). E70h, Address = E40h. E70h, Name = B2CON (2). E3Fh, Name = CANCON_RO8. E3Fh, Address = E2Fh. E3Fh, Name = CANCON_RO9. E3Fh, Address = E1Fh. E3Fh, Name = -. E3Fh, Address = E0Fh. E3Fh, Name = -. E3Eh, Name = CANSTAT_RO8. E3Eh, Address = E2Eh. E3Eh, Name = CANSTAT_RO9. E3Eh, Address = E1Eh. E3Eh, Name = -. E3Eh, Address = E0Eh. E3Eh, Name = -. E3Dh, Name = B1D7 (2). E3Dh, Address = E2Dh.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nE3Dh, Name = B0D7 (2). E3Dh, Address = E1Dh. E3Dh, Name = -. E3Dh, Address = E0Dh. E3Dh, Name = -. E3Ch, Name = B1D6 (2). E3Ch, Address = E2Ch. E3Ch, Name = B0D6 (2). E3Ch, Address = E1Ch. E3Ch, Name = -. E3Ch, Address = E0Ch. E3Ch, Name = -. E3Bh, Name = B1D5 (2). E3Bh, Address = E2Bh. E3Bh, Name = B0D5 (2). E3Bh, Address = E1Bh. E3Bh, Name = -. E3Bh, Address = E0Bh. E3Bh, Name = -. E3Ah, Name = B1D4 (2). E3Ah, Address = E2Ah. E3Ah, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nB0D4 (2). E3Ah, Address = E1Ah. E3Ah, Name = -. E3Ah, Address = E0Ah. E3Ah, Name = -. E39h, Name = B1D3 (2). E39h, Address = E29h. E39h, Name = B0D3 (2). E39h, Address = E19h. E39h, Name = -. E39h, Address = E09h. E39h, Name = -. E38h, Name = B1D2 (2). E38h, Address = E28h. E38h, Name = B0D2 (2). E38h, Address = E18h. E38h, Name = -. E38h, Address = E08h. E38h, Name = -. E37h, Name = B1D1 (2). E37h, Address = E27h. E37h, Name = B0D1",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\n(2). E37h, Address = E17h. E37h, Name = -. E37h, Address = E07h. E37h, Name = -. E36h, Name = B1D0 (2). E36h, Address = E26h. E36h, Name = B0D0 (2). E36h, Address = E16h. E36h, Name = -. E36h, Address = E06h. E36h, Name = -. E35h, Name = B1DLC (2). E35h, Address = E25h. E35h, Name = B0DLC (2). E35h, Address = E15h. E35h, Name = -. E35h, Address = E05h. E35h, Name = -. E34h, Name = B1EIDL (2). E34h, Address = E24h. E34h, Name = B0EIDL (2).",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nE34h, Address = E14h. E34h, Name = -. E34h, Address = E04h. E34h, Name = -. E33h, Name = B1EIDH (2). E33h, Address = E23h. E33h, Name = B0EIDH (2). E33h, Address = E13h. E33h, Name = -. E33h, Address = E03h. E33h, Name = -. E32h, Name = B1SIDL (2). E32h, Address = E22h. E32h, Name = B0SIDL (2). E32h, Address = E12h. E32h, Name = -. E32h, Address = E02h. E32h, Name = -. E31h, Name = B1SIDH (2). E31h, Address = E21h. E31h, Name = B0SIDH (2). E31h, Address =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nE11h. E31h, Name = -. E31h, Address = E01h. E31h, Name = -. E30h, Name = B1CON (2). E30h, Address = E20h. E30h, Name = B0CON (2). E30h, Address = E10h. E30h, Name = -. E30h, Address = E00h. E30h, Name = -\nNote\n1: Registers available only on PIC18F4X8X devices; otherwise, the registers read as ' 0 '.\n2: When any TX_ENn bit in RX_TX_SELn is set, then the corresponding bit in this register has transmit properties.\n3: This is not a physical register.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nDFFh, Name = -. DFFh, Address = DDFh. DFFh, Name = -. DFFh, Address = DBFh. DFFh, Name = -. DFFh, Address = D9Fh. DFFh, Name = -. DFEh, Name = -. DFEh, Address = DDEh. DFEh, Name = -. DFEh, Address = DBEh. DFEh, Name = -. DFEh, Address = D9Eh. DFEh, Name = -. DFDh, Name = -. DFDh, Address = DDDh. DFDh, Name = -. DFDh, Address = DBDh. DFDh, Name = -. DFDh, Address = D9Dh. DFDh, Name = -. DFCh, Name = TXBIE. DFCh, Address = DDCh. DFCh, Name = -. DFCh, Address = DBCh. DFCh, Name = -.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nDFCh, Address = D9Ch. DFCh, Name = -. DFBh, Name = -. DFBh, Address = DDBh. DFBh, Name = -. DFBh, Address = DBBh. DFBh, Name = -. DFBh, Address = D9Bh. DFBh, Name = -. DFAh, Name = BIE0. DFAh, Address = DDAh. DFAh, Name = -. DFAh, Address = DBAh. DFAh, Name = -. DFAh, Address = D9Ah. DFAh, Name = -. DF9h, Name = -. DF9h, Address = DD9h. DF9h, Name = -. DF9h, Address = DB9h. DF9h, Name = -. DF9h, Address = D99h. DF9h, Name = -. DF8h, Name = BSEL0. DF8h, Address = DD8h.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nDF8h, Name = SDFLC. DF8h, Address = DB8h. DF8h, Name = -. DF8h, Address = D98h. DF8h, Name = -. DF7h, Name = -. DF7h, Address = DD7h. DF7h, Name = -. DF7h, Address = DB7h. DF7h, Name = -. DF7h, Address = D97h. DF7h, Name = -. DF6h, Name = -. DF6h, Address = DD6h. DF6h, Name = -. DF6h, Address = DB6h. DF6h, Name = -. DF6h, Address = D96h. DF6h, Name = -. DF5h, Name = -. DF5h, Address = DD5h. DF5h, Name = RXFCON1.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nDF5h, Address = DB5h. DF5h, Name = -. DF5h, Address = D95h. DF5h, Name = -. DF4h, Name = -. DF4h, Address = DD4h. DF4h, Name = RXFCON0. DF4h, Address = DB4h. DF4h, Name = -. DF4h, Address = D94h. DF4h, Name = -. DF3h, Name = MSEL3. DF3h, Address = DD3h. DF3h, Name = -. DF3h, Address = DB3h. DF3h, Name = -. DF3h, Address = D93h. DF3h, Name = RXF15EIDL. DF2h, Name = MSEL2. DF2h, Address = DD2h. DF2h, Name = -. DF2h,",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nAddress = DB2h. DF2h, Name = -. DF2h, Address = D92h. DF2h, Name = RXF15EIDH. DF1h, Name = MSEL1. DF1h, Address = DD1h. DF1h, Name = -. DF1h, Address = DB1h. DF1h, Name = -. DF1h, Address = D91h. DF1h, Name = RXF15SIDL. DF0h, Name = MSEL0. DF0h, Address = DD0h. DF0h, Name = -. DF0h, Address = DB0h. DF0h, Name = -. DF0h, Address = D90h. DF0h, Name = RXF15SIDH. DEFh, Name = -. DEFh, Address = DCFh. DEFh, Name = -. DEFh, Address = DAFh.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nDEFh, Name = -. DEFh, Address = D8Fh. DEFh, Name = -. DEEh, Name = -. DEEh, Address = DCEh. DEEh, Name = -. DEEh, Address = DAEh. DEEh, Name = -. DEEh, Address = D8Eh. DEEh, Name = -. DEDh, Name = -. DEDh, Address = DCDh. DEDh, Name = -. DEDh, Address = DADh. DEDh, Name = -. DEDh, Address = D8Dh. DEDh, Name = -. DECh, Name = -. DECh, Address = DCCh. DECh, Name = -. DECh, Address = DACh. DECh, Name = -. DECh, Address = D8Ch. DECh, Name = -. DEBh, Name = -. DEBh, Address = DCBh. DEBh, Name = -. DEBh, Address = DABh. DEBh, Name = -. DEBh, Address =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nD8Bh. DEBh, Name = RXF14EIDL. DEAh, Name = -. DEAh, Address = DCAh. DEAh, Name = -. DEAh, Address = DAAh. DEAh, Name = -. DEAh, Address = D8Ah. DEAh, Name = RXF14EIDH. DE9h, Name = -. DE9h, Address = DC9h. DE9h, Name = -. DE9h, Address = DA9h. DE9h, Name = -. DE9h, Address = D89h. DE9h, Name = RXF14SIDL. DE8h, Name = -. DE8h, Address = DC8h. DE8h, Name = -. DE8h, Address = DA8h. DE8h, Name = -. DE8h, Address = D88h. DE8h, Name = RXF14SIDH. DE7h, Name = RXFBCON7. DE7h, Address =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nDC7h. DE7h, Name = -. DE7h, Address = DA7h. DE7h, Name = -. DE7h, Address = D87h. DE7h, Name = RXF13EIDL. DE6h, Name = RXFBCON6. DE6h, Address = DC6h. DE6h, Name = -. DE6h, Address = DA6h. DE6h, Name = -. DE6h, Address = D86h. DE6h, Name = RXF13EIDH. DE5h, Name = RXFBCON5. DE5h, Address = DC5h. DE5h, Name = -. DE5h, Address = DA5h. DE5h, Name = -. DE5h, Address = D85h. DE5h, Name = RXF13SIDL. DE4h, Name = RXFBCON4. DE4h, Address = DC4h. DE4h, Name = -.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nDE4h, Address = DA4h. DE4h, Name = -. DE4h, Address = D84h. DE4h, Name = RXF13SIDH. DE3h, Name = RXFBCON3. DE3h, Address = DC3h. DE3h, Name = -. DE3h, Address = DA3h. DE3h, Name = -. DE3h, Address = D83h. DE3h, Name = RXF12EIDL. DE2h, Name = RXFBCON2. DE2h, Address = DC2h. DE2h, Name = -. DE2h, Address = DA2h. DE2h, Name = -. DE2h, Address = D82h. DE2h, Name = RXF12EIDH. DE1h, Name = RXFBCON1. DE1h, Address = DC1h. DE1h, Name = -. DE1h, Address = DA1h.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nDE1h, Name = -. DE1h, Address = D81h. DE1h, Name = RXF12SIDL. DE0h, Name = RXFBCON0. DE0h, Address = DC0h. DE0h, Name = -. DE0h, Address = DA0h. DE0h, Name = -. DE0h, Address = D80h. DE0h, Name = RXF12SIDH\nNote\n1: Registers available only on PIC18F4X8X devices; otherwise, the registers read as ' 0 '.\n2: When any TX_ENn bit in RX_TX_SELn is set, then the corresponding bit in this register has transmit properties.\n3: This is not a physical register.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\nD7Fh, Name = -. D7Eh, Name = -. D7Dh, Name = -. D7Ch, Name = -. D7Bh, Name = RXF11EIDL. D7Ah, Name = RXF11EIDH. D79h, Name = RXF11SIDL. D78h, Name = RXF11SIDH. D77h, Name = RXF10EIDL. D76h, Name = RXF10EIDH. D75h, Name = RXF10SIDL. D74h, Name = RXF10SIDH. D73h, Name = RXF9EIDL. D72h, Name = RXF9EIDH. D71h, Name = RXF9SIDL. D70h, Name = RXF9SIDH. D6Fh, Name = -. D6Eh, Name = -. D6Dh, Name = -. D6Ch, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2585/2680/4585/4680 DEVICES (CONTINUED)\n-. D6Bh, Name = RXF8EIDL. D6Ah, Name = RXF8EIDH. D69h, Name = RXF8SIDL. D68h, Name = RXF8SIDH. D67h, Name = RXF7EIDL. D66h, Name = RXF7EIDH. D65h, Name = RXF7SIDL. D64h, Name = RXF7SIDH. D63h, Name = RXF6EIDL. D62h, Name = RXF6EIDH. D61h, Name = RXF6SIDL. D60h, Name = RXF6SIDH",
    "Note\n1: Registers available only on PIC18F4X8X devices; otherwise, the registers read as ' 0 '.\n2: When any TX_ENn bit in RX_TX_SELn is set, then the corresponding bit in this register has transmit properties.\n3: This is not a physical register.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nTOSU, Bit 7 = -. TOSU, Bit 6 = -. TOSU, Bit 5 = -. TOSU, Bit 4 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 3 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 2 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 1 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 0 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Value on POR, BOR = ---0 0000. TOSU, Details on page: = 46, 68. TOSH, Bit 7 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 6 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 5 = Top-of-Stack High Byte",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\n(TOS<15:8>). TOSH, Bit 4 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 3 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 2 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 1 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 0 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Value on POR, BOR = 0000 0000. TOSH, Details on page: = 46, 68. TOSL, Bit 7 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 6 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 5 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 4 = Top-of-Stack",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nLow Byte (TOS<7:0>). TOSL, Bit 3 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 2 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 1 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 0 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Value on POR, BOR = 0000 0000. TOSL, Details on page: = 46, 68. STKPTR, Bit 7 = STKFUL. STKPTR, Bit 6 = STKUNF. STKPTR, Bit 5 = -. STKPTR, Bit 4 = Return Stack Pointer. STKPTR, Bit 3 = Return Stack Pointer. STKPTR, Bit 2 = Return Stack Pointer. STKPTR, Bit 1 = Return Stack Pointer. STKPTR, Bit 0 = Return Stack Pointer. STKPTR, Value",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\non POR, BOR = 00-0 0000. STKPTR, Details on page: = 46, 69. PCLATU, Bit 7 = -. PCLATU, Bit 6 = -. PCLATU, Bit 5 = bit 21 (1). PCLATU, Bit 4 = Holding Register for PC<20:16>. PCLATU, Bit 3 = Holding Register for PC<20:16>. PCLATU, Bit 2 = Holding Register for PC<20:16>. PCLATU, Bit 1 = Holding Register for PC<20:16>. PCLATU, Bit 0 = Holding Register for PC<20:16>. PCLATU, Value on POR, BOR = ---0 0000. PCLATU, Details on page: = 46, 68. PCLATH, Bit 7 = Holding Register for PC<15:8>. PCLATH, Bit 6 = Holding Register for PC<15:8>. PCLATH, Bit 5 = Holding Register for PC<15:8>. PCLATH, Bit 4 = Holding",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nRegister for PC<15:8>. PCLATH, Bit 3 = Holding Register for PC<15:8>. PCLATH, Bit 2 = Holding Register for PC<15:8>. PCLATH, Bit 1 = Holding Register for PC<15:8>. PCLATH, Bit 0 = Holding Register for PC<15:8>. PCLATH, Value on POR, BOR = 0000 0000. PCLATH, Details on page: = 46, 68. PCL, Bit 7 = PC Low Byte (PC<7:0>). PCL, Bit 6 = PC Low Byte (PC<7:0>). PCL, Bit 5 = PC Low Byte (PC<7:0>). PCL, Bit 4 = PC Low Byte (PC<7:0>). PCL, Bit 3 = PC Low Byte (PC<7:0>). PCL, Bit 2 = PC Low Byte (PC<7:0>). PCL, Bit 1 = PC Low Byte (PC<7:0>).",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nPCL, Bit 0 = PC Low Byte (PC<7:0>). PCL, Value on POR, BOR = 0000 0000. PCL, Details on page: = 46, 68. TBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit 21. TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on POR, BOR = --00 0000. TBLPTRU, Details on page: = 46,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\n61. TBLPTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Value on POR, BOR = 0000 0000. TBLPTRH, Details on page: = 46,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\n61. TBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Value on POR, BOR = 0000 0000. TBLPTRL, Details on page: = 46,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\n61. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on POR, BOR = 0000 0000. TABLAT, Details on page: = 46, 61. PRODH, Bit 7 = Product Register High Byte. PRODH, Bit 6 = Product Register High Byte. PRODH, Bit 5 = Product Register High Byte. PRODH, Bit 4 = Product Register High Byte. PRODH, Bit 3 = Product Register High Byte. PRODH, Bit 2 = Product Register High Byte. PRODH, Bit 1 = Product Register High Byte. PRODH, Bit 0 = Product Register High Byte. PRODH, Value on POR, BOR = xxxx xxxx. PRODH, Details on page: = 46, 105.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nPRODL, Bit 7 = Product Register Low Byte. PRODL, Bit 6 = Product Register Low Byte. PRODL, Bit 5 = Product Register Low Byte. PRODL, Bit 4 = Product Register Low Byte. PRODL, Bit 3 = Product Register Low Byte. PRODL, Bit 2 = Product Register Low Byte. PRODL, Bit 1 = Product Register Low Byte. PRODL, Bit 0 = Product Register Low Byte. PRODL, Value on POR, BOR = xxxx xxxx. PRODL, Details on page: = 46, 105. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Details on page: = 46, 109. INTCON2,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nBit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111 -1-1. INTCON2, Details on page: = 46, 110. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 11-0 0-00. INTCON3, Details on page: = 46, 111.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nINDF0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 0 = Uses",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\ncontents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Value on POR, BOR = N/A. INDF0, Details on page: = 46, 95. POSTINC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register).",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nPOSTINC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Value on POR, BOR = N/A. POSTINC0, Details on page: = 46, 96. POSTDEC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 5 = Uses contents of FSR0 to address data memory - value of",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nFSR0 post-decremented (not a physical register). POSTDEC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Value on POR, BOR = N/A. POSTDEC0, Details on page: = 46, 96. PREINC0, Bit 7",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\n= Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nFSR0 pre-incremented (not a physical register). PREINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Value on POR, BOR = N/A. PREINC0, Details on page: = 46, 96. PLUSW0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Bit 6 = offset by W. PLUSW0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Bit 3 = Uses contents of FSR0 to address data memory",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\n- value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Value on POR, BOR = N/A. PLUSW0, Details on page: = 46, 96. FSR0H, Bit 7 = -. FSR0H, Bit 6 = -. FSR0H, Bit 5 = -. FSR0H, Bit 4 = -. FSR0H, Bit 3 = Indirect Data Memory Address Pointer 0 High.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nFSR0H, Bit 2 = Indirect Data Memory Address Pointer 0 High. FSR0H, Bit 1 = Indirect Data Memory Address Pointer 0 High. FSR0H, Bit 0 = Indirect Data Memory Address Pointer 0 High. FSR0H, Value on POR, BOR = ---- xxxx. FSR0H, Details on page: = 46, 95. FSR0L, Bit 7 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 6 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 5 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 4 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 3 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 2 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 1 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 0 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Value on POR, BOR = xxxx",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nxxxx. FSR0L, Details on page: = 46, 95. WREG, Bit 7 = Working Register. WREG, Bit 6 = Working Register. WREG, Bit 5 = Working Register. WREG, Bit 4 = Working Register. WREG, Bit 3 = Working Register. WREG, Bit 2 = Working Register. WREG, Bit 1 = Working Register. WREG, Bit 0 = Working Register. WREG, Value on POR, BOR = xxxx xxxx. WREG, Details on page: = 46. INDF1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 4 = Uses contents of FSR1 to address data memory - value of",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nFSR1 not changed (not a physical register). INDF1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Value on POR, BOR = N/A. INDF1, Details on page: = 46, 95. POSTINC1, Bit 7 = Uses contents data. POSTINC1, Bit 6 = of FSR1 to. POSTINC1, Bit 5 = address. POSTINC1, Bit 4 = memory - value. POSTINC1, Bit 3 = of FSR1.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nPOSTINC1, Bit 2 = post-incremented. POSTINC1, Bit 1 = (not a physical. POSTINC1, Bit 0 = register). POSTINC1, Value on POR, BOR = N/A. POSTINC1, Details on page: = 46, 96. POSTDEC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 3 = Uses contents of FSR1 to address data memory - value",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nof FSR1 post-decremented (not a physical register). POSTDEC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Value on POR, BOR = N/A. POSTDEC1, Details on page: = 46, 96. PREINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\n5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Value on POR, BOR = N/A. PREINC1, Details",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\non page: = 46, 96. PLUSW1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nBit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Value on POR, BOR = N/A. PLUSW1, Details on page: = 46, 96. FSR1H, Bit 7 = -. FSR1H, Bit 6 = -. FSR1H, Bit 5 = -. FSR1H, Bit 4 = -. FSR1H, Bit 3 = Indirect Data Memory Address Pointer 1 High. FSR1H, Bit 2 = Indirect Data Memory Address Pointer 1 High.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nFSR1H, Bit 1 = Indirect Data Memory Address Pointer 1 High. FSR1H, Bit 0 = Indirect Data Memory Address Pointer 1 High. FSR1H, Value on POR, BOR = ---- xxxx. FSR1H, Details on page: = 46, 95. FSR1L, Bit 7 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 6 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 5 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 4 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 3 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 2 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 1 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 0 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Value on POR, BOR = xxxx xxxx. FSR1L, Details on page: = 46, 95.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nBSR, Bit 7 = -. BSR, Bit 6 = -. BSR, Bit 5 = -. BSR, Bit 4 = -. BSR, Bit 3 = Bank Select Register. BSR, Bit 2 = Bank Select Register. BSR, Bit 1 = Bank Select Register. BSR, Bit 0 = Bank Select Register. BSR, Value on POR, BOR = ---- 0000. BSR, Details on page: = 47, 73. INDF2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register).",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nINDF2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Value on POR, BOR = N/A N/A. INDF2, Details on page: = 47, 95 47, 96. POSTINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nregister). POSTINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Value on POR, BOR = .",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nPOSTINC2, Details on page: = . POSTDEC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nBit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Value on POR, BOR = N/A. POSTDEC2, Details on page: = 47, 96. PREINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\npre-incremented (not a physical register). PREINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Value on POR, BOR = N/A. PREINC2, Details on page: = 47, 96. PLUSW2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register), value of FSR2 offset by W.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nPLUSW2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register), value of FSR2 offset by W. PLUSW2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register), value of FSR2 offset by W. PLUSW2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register), value of FSR2 offset by W. PLUSW2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register), value of FSR2 offset by W. PLUSW2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register), value of FSR2 offset by W. PLUSW2, Bit 1 = Uses contents of",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\nFSR2 to address data memory - value of FSR2 pre-incremented (not a physical register), value of FSR2 offset by W. PLUSW2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register), value of FSR2 offset by W. PLUSW2, Value on POR, BOR = N/A. PLUSW2, Details on page: = 47, 96. , Bit 7 = Indirect Data Memory Address Pointer 2 Low Byte. , Bit 6 = Indirect Data Memory Address Pointer 2 Low Byte. , Bit 5 = Indirect Data Memory Address Pointer 2 Low Byte. , Bit 4 = Indirect Data Memory Address Pointer 2 Low Byte. , Bit 3 = Indirect Data Memory Address Pointer 2 Low Byte. , Bit 2 = Indirect Data Memory Address Pointer 2 Low Byte. , Bit 1 = Indirect Data Memory Address Pointer 2 Low Byte. , Bit 0 = Indirect Data Memory Address Pointer 2 Low Byte. , Value on POR, BOR = xxxx xxxx. , Details on page: = 47,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\n95. FSR2L, Bit 7 = . FSR2L, Bit 6 = . FSR2L, Bit 5 = . FSR2L, Bit 4 = . FSR2L, Bit 3 = Indirect Data Memory Address Pointer 2 High ----. FSR2L, Bit 2 = Indirect Data Memory Address Pointer 2 High ----. FSR2L, Bit 1 = Indirect Data Memory Address Pointer 2 High ----. FSR2L, Bit 0 = Indirect Data Memory Address Pointer 2 High ----. FSR2L, Value on POR, BOR = . FSR2L, Details on page: = \nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '. See Section 4.4 'Brown-out Reset (BOR)' .\n3: These registers and/or bits are not implemented on PIC18F2X8X devices and are read as ' 0 '. Reset values are shown for PIC18F4X8X devices; individual unimplemented bits should be interpreted as '-'.\n4: The PLLEN bit is only available in specific oscillator configuration; otherwise, it is disabled and reads as ' 0 '. See Section 2.6.4 'PLL in INTOSC Modes' .\n5: The RE3 bit is only available when Master Clear Reset is disabled (CONFIG3H<7> = 0 ); otherwise, RE3 reads as ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680)\n6: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as '0'.\n7: CAN bits have multiple functions depending on the selected mode of the CAN module.\n8: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.\n9: These registers are available on PIC18F4X8X devices only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nSTATUS, Bit 7 = -. STATUS, Bit 6 = -. STATUS, Bit 5 = -. STATUS, Bit 4 = N. STATUS, Bit 3 = OV. STATUS, Bit 2 = Z. STATUS, Bit 1 = DC. STATUS, Bit 0 = C. STATUS, Value on POR, BOR = ---x xxxx. STATUS, Details on page: = 47, 93. TMR0H, Bit 7 = Timer0 Register High Byte. TMR0H, Bit 6 = Timer0 Register High Byte. TMR0H, Bit 5 = Timer0 Register High Byte. TMR0H, Bit 4 = Timer0 Register High Byte. TMR0H, Bit 3 = Timer0 Register High Byte. TMR0H, Bit 2 = Timer0 Register High Byte. TMR0H, Bit 1 = Timer0 Register High Byte. TMR0H, Bit 0 = Timer0 Register High Byte. TMR0H, Value on POR, BOR = 0000 0000. TMR0H, Details",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\non page: = 47, 142. TMR0L, Bit 7 = Timer0 Register Low Byte. TMR0L, Bit 6 = Timer0 Register Low Byte. TMR0L, Bit 5 = Timer0 Register Low Byte. TMR0L, Bit 4 = Timer0 Register Low Byte. TMR0L, Bit 3 = Timer0 Register Low Byte. TMR0L, Bit 2 = Timer0 Register Low Byte. TMR0L, Bit 1 = Timer0 Register Low Byte. TMR0L, Bit 0 = Timer0 Register Low Byte. TMR0L, Value on POR, BOR = xxxx xxxx. TMR0L, Details on page: = 47, 142. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nT0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111 1111. T0CON, Details on page: = 47, 142. OSCCON, Bit 7 = IDLEN. OSCCON, Bit 6 = IRCF2. OSCCON, Bit 5 = IRCF1. OSCCON, Bit 4 = IRCF0. OSCCON, Bit 3 = OSTS. OSCCON, Bit 2 = IOFS. OSCCON, Bit 1 = SCS1. OSCCON, Bit 0 = SCS0. OSCCON, Value on POR, BOR = 0000 q000. OSCCON, Details on page: = 47, 47. HLVDCON, Bit 7 = VDIRMAG. HLVDCON, Bit 6 = -. HLVDCON, Bit 5 = IRVST. HLVDCON, Bit 4 = HLVDEN. HLVDCON,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 3 = HLVDL3. HLVDCON, Bit 2 = HLVDL2. HLVDCON, Bit 1 = HLVDL1. HLVDCON, Bit 0 = HLVDL0. HLVDCON, Value on POR, BOR = 0-00 0101. HLVDCON, Details on page: = 47, 256. WDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN. WDTCON, Value on POR, BOR = --- ---0. WDTCON, Details on page: = 47, 340. RCON, Bit 7 = IPEN. RCON, Bit 6 = SBOREN (2). RCON, Bit 5 = -. RCON, Bit 4 = RI.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0q-1 11q0. RCON, Details on page: = 47, 121. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Value on POR, BOR = xxxx xxxx. TMR1H, Details on page: = 47, 147. TMR1L, Bit 7 = Timer1 Register Low",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nByte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Value on POR, BOR = 0000 0000. TMR1L, Details on page: = 47, 147. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n0 = TMR1ON. T1CON, Value on POR, BOR = 0000 0000. T1CON, Details on page: = 47, 143. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Value on POR, BOR = 1111 1111. TMR2, Details on page: = 47, 150. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRegister. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = -000 0000. PR2, Details on page: = 47, 147. T2CON, Bit 7 = -. T2CON, Bit 6 = T2OUTPS3 T2OUTPS2 T2OUTPS1 T2OUTPS0. T2CON, Bit 5 = T2OUTPS3 T2OUTPS2 T2OUTPS1 T2OUTPS0. T2CON, Bit 4 = T2OUTPS3 T2OUTPS2 T2OUTPS1 T2OUTPS0. T2CON, Bit 3 = T2OUTPS3 T2OUTPS2 T2OUTPS1 T2OUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000 0000.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nT2CON, Details on page: = 47, 149. SSPBUF, Bit 7 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 0 = SSP Receive Buffer/Transmit Register. SSPBUF, Value on POR, BOR = xxxx xxxx. SSPBUF, Details on page: = 47, 185. SSPADD, Bit 7 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 6 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nReload Register in I 2 C Master mode.. SSPADD, Bit 5 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 4 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 3 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 2 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 1 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 0 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Value on POR, BOR = 0000",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n0000. SSPADD, Details on page: = 47, 185. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR, BOR = 0000 0000. SSPSTAT, Details on page: = 47, 187. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 = SSPM1. SSPCON1, Bit 0 = SSPM0. SSPCON1, Value on POR, BOR =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n0000 0000. SSPCON1, Details on page: = 47, 188. SSPCON2, Bit 7 = GCEN. SSPCON2, Bit 6 = ACKSTAT. SSPCON2, Bit 5 = ACKDT. SSPCON2, Bit 4 = ACKEN. SSPCON2, Bit 3 = RCEN. SSPCON2, Bit 2 = PEN. SSPCON2, Bit 1 = RSEN. SSPCON2, Bit 0 = SEN. SSPCON2, Value on POR, BOR = 0000 0000. SSPCON2, Details on page: = 47, 189. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nA/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Value on POR, BOR = xxxx xxxx. ADRESH, Details on page: = 47, 247. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Value on POR, BOR = xxxx xxxx. ADRESL, Details on page: = 47, 247. ADCON0, Bit 7 = -. ADCON0, Bit 6 = -. ADCON0, Bit 5 = CHS3.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nADCON0, Bit 4 = CHS2. ADCON0, Bit 3 = CHS1. ADCON0, Bit 2 = CHS0. ADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = --00 0000. ADCON0, Details on page: = 47, 238. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = --00 0qqq. ADCON1, Details on page: = 47, 239. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = -. ADCON2,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 5 = ACQT2. ADCON2, Bit 4 = ACQT1. ADCON2, Bit 3 = ACQT0. ADCON2, Bit 2 = ADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Value on POR, BOR = 0-00 0000. ADCON2, Details on page: = 47, 240. CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nCapture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Value on POR, BOR = xxxx xxxx. CCPR1H, Details on page: = 48, 159. CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Value",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\non POR, BOR = xxxx xxxx. CCPR1L, Details on page: = 48, 159. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = --xx xxxx. CCP1CON, Details on page: = 48, 154. ECCPR1H (9), Bit 7 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (9), Bit 6 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (9), Bit 5 = Enhanced Capture/Compare/PWM",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRegister 1 High Byte. ECCPR1H (9), Bit 4 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (9), Bit 3 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (9), Bit 2 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (9), Bit 1 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (9), Bit 0 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (9), Value on POR, BOR = xxxx xxxx. ECCPR1H (9), Details on page: = 48, 158. ECCPR1L (9), Bit 7 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (9), Bit 6 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (9), Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n5 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (9), Bit 4 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (9), Bit 3 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (9), Bit 2 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (9), Bit 1 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (9), Bit 0 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (9), Value on POR, BOR = xxxx xxxx. ECCPR1L (9), Details on page: = 48, 158. ECCP1CON (9), Bit 7 = EPWM1M1. ECCP1CON (9), Bit 6 = EPWM1M0. ECCP1CON (9), Bit 5 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEDC1B1. ECCP1CON (9), Bit 4 = EDC1B0. ECCP1CON (9), Bit 3 = ECCP1M3. ECCP1CON (9), Bit 2 = ECCP1M2. ECCP1CON (9), Bit 1 = ECCP1M1. ECCP1CON (9), Bit 0 = ECCP1M0. ECCP1CON (9), Value on POR, BOR = 0000 0000. ECCP1CON (9), Details on page: = 48, 159. BAUDCON, Bit 7 = ABDOVF. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Value on POR, BOR = 01-0 0000.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBAUDCON, Details on page: = 48, 219. ECCP1DEL (9), Bit 7 = PRSEN. ECCP1DEL (9), Bit 6 = PDC6 (3). ECCP1DEL (9), Bit 5 = PDC5 (3). ECCP1DEL (9), Bit 4 = PDC4 (3). ECCP1DEL (9), Bit 3 = PDC3 (3). ECCP1DEL (9), Bit 2 = PDC2 (3). ECCP1DEL (9), Bit 1 = PDC1 (3). ECCP1DEL (9), Bit 0 = PDC0 (3). ECCP1DEL (9), Value on POR, BOR = 0000 0000. ECCP1DEL (9), Details on page: = 48, 173. ECCP1AS (9), Bit 7 = ECCPASE. ECCP1AS (9), Bit 6 = ECCPAS2. ECCP1AS (9),",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 5 = ECCPAS1. ECCP1AS (9), Bit 4 = ECCPAS0. ECCP1AS (9), Bit 3 = PSSAC1. ECCP1AS (9), Bit 2 = PSSAC0. ECCP1AS (9), Bit 1 = PSSBD1 (3). ECCP1AS (9), Bit 0 = PSSBD0 (3). ECCP1AS (9), Value on POR, BOR = 0000. ECCP1AS (9), Details on page: = 48, 173. CVRCON (9), Bit 7 = CVREN. CVRCON (9), Bit 6 = CVROE. CVRCON (9), Bit 5 = CVRR. CVRCON (9), Bit 4 = CVRSS. CVRCON (9), Bit 3 = CVR3. CVRCON (9), Bit 2 = CVR2. CVRCON (9), Bit 1 = CVR1. CVRCON",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(9), Bit 0 = CVR0. CVRCON (9), Value on POR, BOR = 0000. CVRCON (9), Details on page: = 48, 253. CMCON (9), Bit 7 = C2OUT. CMCON (9), Bit 6 = C1OUT. CMCON (9), Bit 5 = C2INV. CMCON (9), Bit 4 = C1INV. CMCON (9), Bit 3 = CIS. CMCON (9), Bit 2 = CM2. CMCON (9), Bit 1 = CM1. CMCON (9), Bit 0 = CM0. CMCON (9), Value on POR, BOR = 0000 0000 0000 0000. CMCON (9), Details on page: = 48, 248 153. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = Timer3 Register High Byte. TMR3H, Value on POR, BOR = xxxx xxxx. TMR3H, Details on page: = 48,. TMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = Timer3 Register Low Byte.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTMR3L, Value on POR, BOR = xxxx xxxx. TMR3L, Details on page: = 48, 153. T3CON, Bit 7 = RD16 T3ECCP1 (9) T3CKPS1 T3CKPS0 T3CCP1 (9) T3SYNC TMR3CS TMR3ON. T3CON, Bit 6 = RD16 T3ECCP1 (9) T3CKPS1 T3CKPS0 T3CCP1 (9) T3SYNC TMR3CS TMR3ON. T3CON, Bit 5 = RD16 T3ECCP1 (9) T3CKPS1 T3CKPS0 T3CCP1 (9) T3SYNC TMR3CS TMR3ON. T3CON, Bit 4 = RD16 T3ECCP1 (9) T3CKPS1 T3CKPS0 T3CCP1 (9) T3SYNC TMR3CS",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTMR3ON. T3CON, Bit 3 = RD16 T3ECCP1 (9) T3CKPS1 T3CKPS0 T3CCP1 (9) T3SYNC TMR3CS TMR3ON. T3CON, Bit 2 = RD16 T3ECCP1 (9) T3CKPS1 T3CKPS0 T3CCP1 (9) T3SYNC TMR3CS TMR3ON. T3CON, Bit 1 = RD16 T3ECCP1 (9) T3CKPS1 T3CKPS0 T3CCP1 (9) T3SYNC TMR3CS TMR3ON. T3CON, Bit 0 = RD16 T3ECCP1 (9) T3CKPS1 T3CKPS0 T3CCP1 (9) T3SYNC TMR3CS TMR3ON. T3CON, Value on POR, BOR = 0000 0000. T3CON, Details on",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\npage: = 48, 153\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '. See Section 4.4 'Brown-out Reset (BOR)' .\n3: These registers and/or bits are not implemented on PIC18F2X8X devices and are read as ' 0 '. Reset values are shown for PIC18F4X8X devices; individual unimplemented bits should be interpreted as '-'.\n4: The PLLEN bit is only available in specific oscillator configuration; otherwise, it is disabled and reads as ' 0 '. See Section 2.6.4 'PLL in INTOSC Modes' .\n5: The RE3 bit is only available when Master Clear Reset is disabled (CONFIG3H<7> = 0 ); otherwise, RE3 reads as ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n6: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as '0'.\n7: CAN bits have multiple functions depending on the selected mode of the CAN module.\n8: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.\n9: These registers are available on PIC18F4X8X devices only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nSPBRGH, Bit 7 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, on = 0000. SPBRGH, Details page: = 48, 220. SPBRG, Bit 7 = EUSART Baud Rate Generator. SPBRG, Bit 6 = EUSART Baud Rate Generator. SPBRG, Bit 5 = EUSART Baud Rate Generator. SPBRG, Bit 4 = EUSART Baud Rate",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nGenerator. SPBRG, Bit 3 = EUSART Baud Rate Generator. SPBRG, Bit 2 = EUSART Baud Rate Generator. SPBRG, Bit 1 = EUSART Baud Rate Generator. SPBRG, Bit 0 = EUSART Baud Rate Generator. SPBRG, Value on POR, BOR = 0000. SPBRG, on = 0000. SPBRG, Details page: = 48, 220. RCREG, Bit 7 = EUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4 = EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, on = 0000. RCREG, Details",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\npage: = 48, 228. TXREG, Bit 7 = EUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit Register. TXREG, Bit 5 = EUSART Transmit Register. TXREG, Bit 4 = EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register. TXREG, Bit 0 = EUSART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, on = 0000. TXREG, Details page: = 48, 226. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n0000. TXSTA, on = 0010. TXSTA, Details page: = 48, 227. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, on = 000x. RCSTA, Details page: = 48, 227. EEADRH, Bit 7 = -. EEADRH, Bit 6 = -. EEADRH, Bit 5 = -. EEADRH, Bit 4 = -. EEADRH, Bit 3 = -. EEADRH, Bit 2 = -. EEADRH, Bit 1 = EEPROM Addr Register High. EEADRH, Bit 0 = EEPROM Addr Register High. EEADRH, Value on POR, BOR =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n----. EEADRH, on = --00. EEADRH, Details page: = 48, 103. EEADR, Bit 7 = EEPROM Address Register. EEADR, Bit 6 = EEPROM Address Register. EEADR, Bit 5 = EEPROM Address Register. EEADR, Bit 4 = EEPROM Address Register. EEADR, Bit 3 = EEPROM Address Register. EEADR, Bit 2 = EEPROM Address Register. EEADR, Bit 1 = EEPROM Address Register. EEADR, Bit 0 = EEPROM Address Register. EEADR, Value on POR, BOR = 0000. EEADR, on = 0000. EEADR, Details page: = 48, 100. EEDATA, Bit 7 = EEPROM Data Register. EEDATA, Bit 6 = EEPROM Data Register. EEDATA, Bit 5 = EEPROM Data Register. EEDATA, Bit 4 = EEPROM Data Register. EEDATA, Bit 3 = EEPROM Data",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRegister. EEDATA, Bit 2 = EEPROM Data Register. EEDATA, Bit 1 = EEPROM Data Register. EEDATA, Bit 0 = EEPROM Data Register. EEDATA, Value on POR, BOR = 0000. EEDATA, on = 0000. EEDATA, Details page: = 48, 100. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(not a physical register). EECON2, Value on POR, BOR = 0000. EECON2, on = 0000. EECON2, Details page: = 48, 100. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on POR, BOR = xx-0. EECON1, on = x000. EECON1, Details page: = 48, 100. IPR3 Mode 0, Bit 7 = IRXIP. IPR3 Mode 0, Bit 6 = WAKIP. IPR3 Mode 0, Bit 5 = ERRIP. IPR3 Mode 0, Bit 4 = TXB2IP. IPR3 Mode 0, Bit 3 = TXB1IP. IPR3 Mode 0, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n2 = TXB0IP. IPR3 Mode 0, Bit 1 = RXB1IP. IPR3 Mode 0, Bit 0 = RXB0IP. IPR3 Mode 0, Value on POR, BOR = 1111. IPR3 Mode 0, on = 1111. IPR3 Mode 0, Details page: = 48, 120. IPR3 Mode 1, 2, Bit 7 = IRXIP. IPR3 Mode 1, 2, Bit 6 = WAKIP. IPR3 Mode 1, 2, Bit 5 = ERRIP. IPR3 Mode 1, 2, Bit 4 = TXBnIP. IPR3 Mode 1, 2, Bit 3 = TXB1IP (8). IPR3 Mode 1, 2, Bit 2 = TXB0IP (8). IPR3 Mode 1, 2, Bit 1 = RXBnIP. IPR3 Mode 1, 2, Bit 0 = FIFOWMIP. IPR3 Mode 1, 2, Value on POR, BOR = 1111. IPR3",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nMode 1, 2, on = 1111. IPR3 Mode 1, 2, Details page: = 48, 120. PIR3 Mode 0, Bit 7 = IRXIF. PIR3 Mode 0, Bit 6 = WAKIF. PIR3 Mode 0, Bit 5 = ERRIF. PIR3 Mode 0, Bit 4 = TXB2IF. PIR3 Mode 0, Bit 3 = TXB1IF. PIR3 Mode 0, Bit 2 = TXB0IF. PIR3 Mode 0, Bit 1 = RXB1IF. PIR3 Mode 0, Bit 0 = RXB0IF. PIR3 Mode 0, Value on POR, BOR = 0000. PIR3 Mode 0, on = 0000. PIR3 Mode 0, Details page: = 48, 114. PIR3 Mode 1, 2, Bit 7 = IRXIF. PIR3 Mode 1, 2, Bit 6 = WAKIF. PIR3 Mode 1, 2, Bit 5 = ERRIF. PIR3 Mode 1,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n2, Bit 4 = TXBnIF. PIR3 Mode 1, 2, Bit 3 = TXB1IF (8). PIR3 Mode 1, 2, Bit 2 = TXB0IF (8). PIR3 Mode 1, 2, Bit 1 = RXBnIF. PIR3 Mode 1, 2, Bit 0 = FIFOWMIF. PIR3 Mode 1, 2, Value on POR, BOR = 0000. PIR3 Mode 1, 2, on = 0000. PIR3 Mode 1, 2, Details page: = 48, 114. PIE3 Mode 0, Bit 7 = IRXIE. PIE3 Mode 0, Bit 6 = WAKIE. PIE3 Mode 0, Bit 5 = ERRIE. PIE3 Mode 0, Bit 4 = TXB2IE. PIE3 Mode 0, Bit 3 = TXB1IE. PIE3 Mode 0, Bit 2 = TXB0IE. PIE3 Mode 0, Bit 1 = RXB1IE. PIE3 Mode 0, Bit 0 = RXB0IE. PIE3",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nMode 0, Value on POR, BOR = 0000. PIE3 Mode 0, on = 0000. PIE3 Mode 0, Details page: = 48, 117. PIE3 Mode 1, 2, Bit 7 = IRXIE. PIE3 Mode 1, 2, Bit 6 = WAKIE. PIE3 Mode 1, 2, Bit 5 = ERRIE. PIE3 Mode 1, 2, Bit 4 = TXBnIE. PIE3 Mode 1, 2, Bit 3 = TXB1IE (8). PIE3 Mode 1, 2, Bit 2 = TXB0IE (8). PIE3 Mode 1, 2, Bit 1 = RXBnIE. PIE3 Mode 1, 2, Bit 0 = FIFOMWIE. PIE3 Mode 1, 2, Value on POR, BOR = 0000. PIE3 Mode 1, 2, on = 0000. PIE3 Mode 1, 2, Details page: = 48, 117. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP (9). IPR2,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (9). IPR2, Value on POR, BOR = 11-1. IPR2, on = 1111. IPR2, Details page: = 48, 119. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF (9). PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (9). PIR2, Value on POR, BOR = 00-0. PIR2, on = 0000. PIR2, Details page: =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n48, 113. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE (9). PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (9). PIE2, Value on POR, BOR = 00-0. PIE2, on = 0000. PIE2, Details page: = 49, 116. IPR1, Bit 7 = PSPIP (3). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n1111. IPR1, on = 1111 49,. IPR1, Details page: = 118. PIR1, Bit 7 = PSPIF (3). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, on = 0000. PIR1, Details page: = 49, 112. PIE1, Bit 7 = PSPIE (3). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, on = 0000. PIE1, Details page: = 49, 115. OSCTUNE, Bit 7 = INTSRC. OSCTUNE, Bit 6 = PLLEN (4). OSCTUNE, Bit 5 = -. OSCTUNE, Bit 4 = TUN4. OSCTUNE, Bit 3 = TUN3. OSCTUNE, Bit 2 = TUN2. OSCTUNE, Bit 1 = TUN1. OSCTUNE, Bit 0 = TUN0. OSCTUNE, Value on POR, BOR = 0q-0. OSCTUNE, on = 0000. OSCTUNE, Details page: = 49, 49. TRISE (3), Bit 7 = IBF. TRISE (3), Bit 6 = OBF. TRISE (3), Bit 5 = IBOV. TRISE (3), Bit 4 = PSPMODE. TRISE (3), Bit 3 = -. TRISE (3), Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTRISE2. TRISE (3), Bit 1 = TRISE1. TRISE (3), Bit 0 = TRISE0. TRISE (3), Value on POR, BOR = 0000. TRISE (3), on = -111. TRISE (3), Details page: = 49, 135. TRISD (3), Bit 7 = Data Direction Control Register for PORTD. TRISD (3), Bit 6 = Data Direction Control Register for PORTD. TRISD (3), Bit 5 = Data Direction Control Register for PORTD. TRISD (3), Bit 4 = Data Direction Control Register for PORTD. TRISD (3), Bit 3 = Data Direction Control Register for PORTD. TRISD (3), Bit 2 = Data Direction Control Register for PORTD. TRISD (3), Bit 1 = Data Direction Control Register for PORTD. TRISD (3), Bit 0 = Data Direction Control Register for PORTD. TRISD (3), Value on POR, BOR = 1111 1111. TRISD",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(3), on = 49,. TRISD (3), Details page: = 132. TRISC, Bit 7 = Data Direction Control Register for PORTC. TRISC, Bit 6 = Data Direction Control Register for PORTC. TRISC, Bit 5 = Data Direction Control Register for PORTC. TRISC, Bit 4 = Data Direction Control Register for PORTC. TRISC, Bit 3 = Data Direction Control Register for PORTC. TRISC, Bit 2 = Data Direction Control Register for PORTC. TRISC, Bit 1 = Data Direction Control Register for PORTC. TRISC, Bit 0 = Data Direction Control Register for PORTC. TRISC, Value on POR, BOR = 1111. TRISC, on = 1111. TRISC, Details page: = 49, 129. TRISB, Bit 7 = Data Direction Control Register for PORTB. TRISB, Bit 6 = Data Direction Control Register for PORTB. TRISB, Bit 5 = Data Direction Control Register for PORTB. TRISB, Bit 4 = Data Direction Control Register for PORTB. TRISB, Bit 3 = Data Direction",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nControl Register for PORTB. TRISB, Bit 2 = Data Direction Control Register for PORTB. TRISB, Bit 1 = Data Direction Control Register for PORTB. TRISB, Bit 0 = Data Direction Control Register for PORTB. TRISB, Value on POR, BOR = 1111 1111. TRISB, on = 49,. TRISB, Details page: = 126. TRISA, Bit 7 = TRISA7 (6). TRISA, Bit 6 = TRISA6 (6). TRISA, Bit 5 = Data Direction Control Register for PORTA. TRISA, Bit 4 = Data Direction Control Register for PORTA. TRISA, Bit 3 = Data Direction Control Register for PORTA. TRISA, Bit 2 = Data Direction Control Register for PORTA. TRISA, Bit 1 = Data Direction Control Register for PORTA. TRISA, Bit 0 = Data Direction Control Register for PORTA. TRISA, Value on POR, BOR = 1111. TRISA, on = 1111 49,. TRISA, Details page: = 123. LATE (3), Bit 7",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n= -. LATE (3), Bit 6 = -. LATE (3), Bit 5 = -. LATE (3), Bit 4 = -. LATE (3), Bit 3 = -. LATE (3), Bit 2 = LATE2. LATE (3), Bit 1 = LATE1. LATE (3), Bit 0 = LATE0. LATE (3), Value on POR, BOR = ----. LATE (3), on = -xxx. LATE (3), Details page: = 49, 135. LATD (3), Bit 7 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 6 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 5 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 4 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 3 = Read PORTD Data Latch, Write PORTD Data Latch.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nLATD (3), Bit 2 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 1 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 0 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Value on POR, BOR = xxxx. LATD (3), on = xxxx. LATD (3), Details page: = 49, 132. LATC, Bit 7 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 6 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 5 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 4 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 3 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 2 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 1 = Read PORTC Data",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nLatch, Write PORTC Data Latch. LATC, Bit 0 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Value on POR, BOR = xxxx. LATC, on = xxxx. LATC, Details page: = 49, 129. LATB, Bit 7 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 6 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 5 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 4 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 3 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 2 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 1 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 0 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Value on POR, BOR = xxxx. LATB, on",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n= xxxx. LATB, Details page: = 49, 126. LATA, Bit 7 = LATA7 (6) LATA6 (6) Read PORTA Data Latch, Write PORTA Data Latch. LATA, Bit 6 = LATA7 (6) LATA6 (6) Read PORTA Data Latch, Write PORTA Data Latch. LATA, Bit 5 = LATA7 (6) LATA6 (6) Read PORTA Data Latch, Write PORTA Data Latch. LATA, Bit 4 = LATA7 (6) LATA6 (6) Read PORTA Data Latch, Write PORTA Data Latch. LATA, Bit 3 = LATA7 (6) LATA6 (6) Read PORTA Data Latch, Write PORTA Data Latch. LATA, Bit 2 = LATA7 (6) LATA6 (6) Read PORTA Data Latch, Write PORTA Data Latch. LATA, Bit 1 = LATA7 (6) LATA6 (6) Read PORTA Data Latch, Write PORTA Data Latch. LATA,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 0 = LATA7 (6) LATA6 (6) Read PORTA Data Latch, Write PORTA Data Latch. LATA, Value on POR, BOR = xxxx. LATA, on = xxxx. LATA, Details page: = 49, 123\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '. See Section 4.4 'Brown-out Reset (BOR)' .\n3: These registers and/or bits are not implemented on PIC18F2X8X devices and are read as ' 0 '. Reset values are shown for PIC18F4X8X devices; individual unimplemented bits should be interpreted as '-'.\n4: The PLLEN bit is only available in specific oscillator configuration; otherwise, it is disabled and reads as ' 0 '. See Section 2.6.4 'PLL in INTOSC Modes' .\n5: The RE3 bit is only available when Master Clear Reset is disabled (CONFIG3H<7> = 0 ); otherwise, RE3 reads as ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n6: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as '0'.\n7: CAN bits have multiple functions depending on the selected mode of the CAN module.\n8: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.\n9: These registers are available on PIC18F4X8X devices only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nPORTE (3), Bit 7 = -. PORTE (3), Bit 6 = -. PORTE (3), Bit 5 = -. PORTE (3), Bit 4 = -. PORTE (3), Bit 3 = RE3 (5). PORTE (3), Bit 2 = RE2 (3). PORTE (3), Bit 1 = RE1 (3). PORTE (3), Bit 0 = RE0 (3). PORTE (3), Value on POR, BOR = ---- xxxx. PORTE (3), Details on page: = 49, 139. PORTD (3), Bit 7 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 6 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 5 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 4 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 3 = Read PORTD pins, Write PORTD Data Latch.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nPORTD (3), Bit 2 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 1 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 0 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Value on POR, BOR = xxxx xxxx. PORTD (3), Details on page: = 49, 132. PORTC, Bit 7 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 6 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 5 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 4 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 3 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 2 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 1 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 0 = Read PORTC pins, Write PORTC Data Latch.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nPORTC, Value on POR, BOR = xxxx xxxx. PORTC, Details on page: = 49, 129. PORTB, Bit 7 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 6 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 5 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 4 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 3 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 2 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 1 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 0 = Read PORTB pins, Write PORTB Data Latch. PORTB, Value on POR, BOR = xxxx xxxx. PORTB, Details on page: = 49, 126. PORTA, Bit 7 = RA7 (6). PORTA, Bit 6 = RA6 (6). PORTA, Bit 5 = Read PORTA pins, Write PORTA Data",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nLatch. PORTA, Bit 4 = Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 3 = Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 2 = Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 1 = Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 0 = Read PORTA pins, Write PORTA Data Latch. PORTA, Value on POR, BOR = xx00 0000. PORTA, Details on page: = 49, 123. ECANCON, Bit 7 = MDSEL1. ECANCON, Bit 6 = MDSEL0. ECANCON, Bit 5 = FIFOWM. ECANCON, Bit 4 = EWIN4. ECANCON, Bit 3 = EWIN3. ECANCON, Bit 2 = EWIN2. ECANCON, Bit 1 = EWIN1. ECANCON, Bit 0 = EWIN0. ECANCON, Value on POR, BOR = 0001 000. ECANCON, Details on page: = 49,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n268. TXERRCNT, Bit 7 = TEC7. TXERRCNT, Bit 6 = TEC6. TXERRCNT, Bit 5 = TEC5. TXERRCNT, Bit 4 = TEC4. TXERRCNT, Bit 3 = TEC3. TXERRCNT, Bit 2 = TEC2. TXERRCNT, Bit 1 = TEC1. TXERRCNT, Bit 0 = TEC0. TXERRCNT, Value on POR, BOR = 0000 0000. TXERRCNT, Details on page: = 49, 273. RXERRCNT, Bit 7 = REC7. RXERRCNT, Bit 6 = REC6. RXERRCNT, Bit 5 = REC5. RXERRCNT, Bit 4 = REC4. RXERRCNT, Bit 3 = REC3. RXERRCNT, Bit 2 = REC2. RXERRCNT, Bit 1 = REC1. RXERRCNT, Bit 0 = REC0.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXERRCNT, Value on POR, BOR = 0000 0000. RXERRCNT, Details on page: = 49, 281. COMSTAT Mode 0, Bit 7 = RXB0OVFL. COMSTAT Mode 0, Bit 6 = RXB1OVFL. COMSTAT Mode 0, Bit 5 = TXBO. COMSTAT Mode 0, Bit 4 = TXBP. COMSTAT Mode 0, Bit 3 = RXBP. COMSTAT Mode 0, Bit 2 = TXWARN. COMSTAT Mode 0, Bit 1 = RXWARN. COMSTAT Mode 0, Bit 0 = EWARN. COMSTAT Mode 0, Value on POR, BOR = 0000 0000. COMSTAT Mode 0, Details on page: = 49, 269. COMSTAT Mode 1, Bit 7 = -. COMSTAT Mode 1, Bit 6 = RXBnOVFL. COMSTAT Mode 1, Bit 5 = TXBO. COMSTAT Mode 1, Bit 4 = TXBP.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nCOMSTAT Mode 1, Bit 3 = RXBP. COMSTAT Mode 1, Bit 2 = TXWARN. COMSTAT Mode 1, Bit 1 = RXWARN. COMSTAT Mode 1, Bit 0 = EWARN. COMSTAT Mode 1, Value on POR, BOR = -000 0000. COMSTAT Mode 1, Details on page: = 49, 269. COMSTAT Mode 2, Bit 7 = FIFOEMPTY. COMSTAT Mode 2, Bit 6 = RXBnOVFL. COMSTAT Mode 2, Bit 5 = TXBO. COMSTAT Mode 2, Bit 4 = TXBP. COMSTAT Mode 2, Bit 3 = RXBP. COMSTAT Mode 2, Bit 2 = TXWARN. COMSTAT Mode 2, Bit 1 = RXWARN. COMSTAT Mode 2, Bit 0 = EWARN. COMSTAT Mode 2, Value on POR, BOR = 0000 0000. COMSTAT Mode 2, Details on page: = 49, 269.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nCIOCON, Bit 7 = -. CIOCON, Bit 6 = -. CIOCON, Bit 5 = ENDRHI. CIOCON, Bit 4 = CANCAP. CIOCON, Bit 3 = -. CIOCON, Bit 2 = -. CIOCON, Bit 1 = -. CIOCON, Bit 0 = -. CIOCON, Value on POR, BOR = --00 ----. CIOCON, Details on page: = 49, 302. BRGCON3, Bit 7 = WAKDIS. BRGCON3, Bit 6 = WAKFIL. BRGCON3, Bit 5 = -. BRGCON3, Bit 4 = -. BRGCON3, Bit 3 = -. BRGCON3, Bit 2 = SEG2PH2. BRGCON3, Bit 1 = SEG2PH1. BRGCON3, Bit 0 = SEG2PH0. BRGCON3, Value on POR, BOR = 00-- -000. BRGCON3, Details on",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\npage: = 49, 301. BRGCON2, Bit 7 = SEG2PHTS. BRGCON2, Bit 6 = SAM. BRGCON2, Bit 5 = SEG1PH2. BRGCON2, Bit 4 = SEG1PH1. BRGCON2, Bit 3 = SEG1PH0. BRGCON2, Bit 2 = PRSEG2. BRGCON2, Bit 1 = PRSEG1. BRGCON2, Bit 0 = PRSEG0. BRGCON2, Value on POR, BOR = 0000 0000. BRGCON2, Details on page: = 49, 300. BRGCON1, Bit 7 = SJW1. BRGCON1, Bit 6 = SJW0. BRGCON1, Bit 5 = BRP5. BRGCON1, Bit 4 = BRP4. BRGCON1, Bit 3 = BRP3. BRGCON1, Bit 2 = BRP2. BRGCON1, Bit 1 = BRP1.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBRGCON1, Bit 0 = BRP0. BRGCON1, Value on POR, BOR = 0000 0000. BRGCON1, Details on page: = 49, 299. CANCON Mode 0, Bit 7 = REQOP2. CANCON Mode 0, Bit 6 = REQOP1. CANCON Mode 0, Bit 5 = REQOP0. CANCON Mode 0, Bit 4 = ABAT. CANCON Mode 0, Bit 3 = WIN2 (7). CANCON Mode 0, Bit 2 = WIN1 (7). CANCON Mode 0, Bit 1 = WIN0 (7). CANCON Mode 0, Bit 0 = - (7). CANCON Mode 0, Value on POR, BOR = 1000 000-. CANCON Mode 0, Details on page: = 50, 264. CANCON Mode 1, Bit 7 = REQOP2. CANCON Mode 1, Bit 6 = REQOP1. CANCON Mode 1, Bit 5 = REQOP0. CANCON Mode 1, Bit 4 = ABAT.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nCANCON Mode 1, Bit 3 = - (7). CANCON Mode 1, Bit 2 = - (7). CANCON Mode 1, Bit 1 = - (7). CANCON Mode 1, Bit 0 = - (7). CANCON Mode 1, Value on POR, BOR = 1000 ----. CANCON Mode 1, Details on page: = 50, 264. CANCON Mode 2, Bit 7 = REQOP2. CANCON Mode 2, Bit 6 = REQOP1. CANCON Mode 2, Bit 5 = REQOP0. CANCON Mode 2, Bit 4 = ABAT. CANCON Mode 2, Bit 3 = FP3 (7). CANCON Mode 2, Bit 2 = FP2 (7). CANCON Mode 2, Bit 1 = FP1 (7). CANCON Mode 2, Bit 0 = FP0 (7). CANCON Mode 2, Value on POR, BOR = 1000 0000. CANCON Mode 2, Details on page: = 50, 264. CANSTAT Mode 0,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 7 = OPMODE2. CANSTAT Mode 0, Bit 6 = OPMODE1. CANSTAT Mode 0, Bit 5 = OPMODE0. CANSTAT Mode 0, Bit 4 = - (7). CANSTAT Mode 0, Bit 3 = ICODE3 (7). CANSTAT Mode 0, Bit 2 = ICODE2 (7). CANSTAT Mode 0, Bit 1 = ICODE1 (7). CANSTAT Mode 0, Bit 0 = - (7). CANSTAT Mode 0, Value on POR, BOR = 000- 0000. CANSTAT Mode 0, Details on page: = 50, 265. CANSTAT Modes 1, 2, Bit 7 = OPMODE2. CANSTAT Modes 1, 2, Bit 6 = OPMODE1. CANSTAT Modes 1, 2, Bit 5 = OPMODE0. CANSTAT Modes 1, 2, Bit 4 = EICODE4 (7). CANSTAT Modes 1, 2, Bit 3 = EICODE3 (7). CANSTAT Modes 1, 2, Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEICODE2 (7). CANSTAT Modes 1, 2, Bit 1 = EICODE1 (7). CANSTAT Modes 1, 2, Bit 0 = EICODE0 (7). CANSTAT Modes 1, 2, Value on POR, BOR = 0000 0000. CANSTAT Modes 1, 2, Details on page: = 50, 265. RXB0D7, Bit 7 = RXB0D77. RXB0D7, Bit 6 = RXB0D76. RXB0D7, Bit 5 = RXB0D75. RXB0D7, Bit 4 = RXB0D74. RXB0D7, Bit 3 = RXB0D73. RXB0D7, Bit 2 = RXB0D72. RXB0D7, Bit 1 = RXB0D71. RXB0D7, Bit 0 = RXB0D70. RXB0D7, Value",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\non POR, BOR = xxxx xxxx. RXB0D7, Details on page: = 50, 280. RXB0D6, Bit 7 = RXB0D67. RXB0D6, Bit 6 = RXB0D66. RXB0D6, Bit 5 = RXB0D65. RXB0D6, Bit 4 = RXB0D64. RXB0D6, Bit 3 = RXB0D63. RXB0D6, Bit 2 = RXB0D62. RXB0D6, Bit 1 = RXB0D61. RXB0D6, Bit 0 = RXB0D60. RXB0D6, Value on POR, BOR = xxxx xxxx. RXB0D6, Details on page: = 50, 280. RXB0D5, Bit 7 = RXB0D57. RXB0D5, Bit 6 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB0D56. RXB0D5, Bit 5 = RXB0D55. RXB0D5, Bit 4 = RXB0D54. RXB0D5, Bit 3 = RXB0D53. RXB0D5, Bit 2 = RXB0D52. RXB0D5, Bit 1 = RXB0D51. RXB0D5, Bit 0 = RXB0D50. RXB0D5, Value on POR, BOR = xxxx xxxx. RXB0D5, Details on page: = 50, 280. RXB0D4, Bit 7 = RXB0D47. RXB0D4, Bit 6 = RXB0D46. RXB0D4, Bit 5 = RXB0D45. RXB0D4, Bit 4 = RXB0D44. RXB0D4, Bit 3 = RXB0D43.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB0D4, Bit 2 = RXB0D42. RXB0D4, Bit 1 = RXB0D41. RXB0D4, Bit 0 = RXB0D40. RXB0D4, Value on POR, BOR = xxxx xxxx. RXB0D4, Details on page: = 50, 280. RXB0D3, Bit 7 = RXB0D37. RXB0D3, Bit 6 = RXB0D36. RXB0D3, Bit 5 = RXB0D35. RXB0D3, Bit 4 = RXB0D34. RXB0D3, Bit 3 = RXB0D33. RXB0D3, Bit 2 = RXB0D32. RXB0D3, Bit 1 = RXB0D31. RXB0D3, Bit 0 = RXB0D30. RXB0D3,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nValue on POR, BOR = xxxx xxxx. RXB0D3, Details on page: = 50, 280. RXB0D2, Bit 7 = RXB0D27. RXB0D2, Bit 6 = RXB0D26. RXB0D2, Bit 5 = RXB0D25. RXB0D2, Bit 4 = RXB0D24. RXB0D2, Bit 3 = RXB0D23. RXB0D2, Bit 2 = RXB0D22. RXB0D2, Bit 1 = RXB0D21. RXB0D2, Bit 0 = RXB0D20. RXB0D2, Value on POR, BOR = xxxx xxxx. RXB0D2, Details on page: = 50, 280. RXB0D1, Bit 7 = RXB0D17. RXB0D1, Bit 6 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB0D16. RXB0D1, Bit 5 = RXB0D15. RXB0D1, Bit 4 = RXB0D14. RXB0D1, Bit 3 = RXB0D13. RXB0D1, Bit 2 = RXB0D12. RXB0D1, Bit 1 = RXB0D11. RXB0D1, Bit 0 = RXB0D10. RXB0D1, Value on POR, BOR = xxxx xxxx. RXB0D1, Details on page: = 50, 280. RXB0D0, Bit 7 = RXB0D07. RXB0D0, Bit 6 = RXB0D06. RXB0D0, Bit 5 = RXB0D05. RXB0D0, Bit 4 = RXB0D04. RXB0D0, Bit 3 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB0D03. RXB0D0, Bit 2 = RXB0D02. RXB0D0, Bit 1 = RXB0D01. RXB0D0, Bit 0 = RXB0D00. RXB0D0, Value on POR, BOR = xxxx xxxx. RXB0D0, Details on page: = 50, 280. RXB0DLC, Bit 7 = -. RXB0DLC, Bit 6 = RXRTR. RXB0DLC, Bit 5 = RB1. RXB0DLC, Bit 4 = RB0. RXB0DLC, Bit 3 = DLC3. RXB0DLC, Bit 2 = DLC2. RXB0DLC, Bit 1 = DLC1. RXB0DLC, Bit 0 = DLC0. RXB0DLC, Value on POR, BOR = -xxx xxxx.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB0DLC, Details on page: = 50, 280. RXB0EIDL, Bit 7 = EID7. RXB0EIDL, Bit 6 = EID6. RXB0EIDL, Bit 5 = EID5. RXB0EIDL, Bit 4 = EID4. RXB0EIDL, Bit 3 = EID3. RXB0EIDL, Bit 2 = EID2. RXB0EIDL, Bit 1 = EID1. RXB0EIDL, Bit 0 = EID0. RXB0EIDL, Value on POR, BOR = xxxx xxxx. RXB0EIDL, Details on page: = 50, 279. RXB0EIDH, Bit 7 = EID15. RXB0EIDH, Bit 6 = EID14. RXB0EIDH, Bit 5 = EID13. RXB0EIDH, Bit 4 = EID12. RXB0EIDH, Bit 3 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEID11. RXB0EIDH, Bit 2 = EID10. RXB0EIDH, Bit 1 = EID9. RXB0EIDH, Bit 0 = EID8. RXB0EIDH, Value on POR, BOR = xxxx xxxx. RXB0EIDH, Details on page: = 50, 279. RXB0SIDL, Bit 7 = SID2. RXB0SIDL, Bit 6 = SID1. RXB0SIDL, Bit 5 = SID0. RXB0SIDL, Bit 4 = SRR. RXB0SIDL, Bit 3 = EXID. RXB0SIDL, Bit 2 = -. RXB0SIDL, Bit 1 = EID17. RXB0SIDL, Bit 0 = EID16. RXB0SIDL, Value on POR, BOR = xxxx x-xx. RXB0SIDL, Details on page: = 50, 279. RXB0SIDH,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 7 = SID10. RXB0SIDH, Bit 6 = SID9. RXB0SIDH, Bit 5 = SID8. RXB0SIDH, Bit 4 = SID7. RXB0SIDH, Bit 3 = SID6. RXB0SIDH, Bit 2 = SID5. RXB0SIDH, Bit 1 = SID4. RXB0SIDH, Bit 0 = SID3. RXB0SIDH, Value on POR, BOR = xxxx xxxx. RXB0SIDH, Details on page: = 50, 278. RXB0CON Mode 0, Bit 7 = RXFUL. RXB0CON Mode 0, Bit 6 = RXM1. RXB0CON Mode 0, Bit 5 = RXM0 (7). RXB0CON Mode 0, Bit 4 = - (7). RXB0CON Mode 0, Bit 3 = . RXB0CON Mode 0, Bit 2 = . RXB0CON Mode",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n0, Bit 1 = . RXB0CON Mode 0, Bit 0 = (7). RXB0CON Mode 0, Value on POR, BOR = . RXB0CON Mode 0, Details on page: = 50, 275. RXB0CON Mode 1, 2, Bit 7 = RXFUL. RXB0CON Mode 1, 2, Bit 6 = RXM1. RXB0CON Mode 1, 2, Bit 5 = RTRRO. RXB0CON Mode 1, 2, Bit 4 = FILHIT4. RXB0CON Mode 1, 2, Bit 3 = RXRTRRO (7) RXBODBEN (7) FILHIT3. RXB0CON Mode 1, 2, Bit 2 = FILHIT2. RXB0CON Mode 1, 2, Bit 1 = JTOFF (7) FILHIT1. RXB0CON Mode 1, 2, Bit 0 = FILHIT0 FILHIT0. RXB0CON Mode 1,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n2, Value on POR, BOR = 000- 0000 0000 0000. RXB0CON Mode 1, 2, Details on page: = 50, 275\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '. See Section 4.4 'Brown-out Reset (BOR)' .\n3: These registers and/or bits are not implemented on PIC18F2X8X devices and are read as ' 0 '. Reset values are shown for PIC18F4X8X devices; individual unimplemented bits should be interpreted as '-'.\n4: The PLLEN bit is only available in specific oscillator configuration; otherwise, it is disabled and reads as ' 0 '. See Section 2.6.4 'PLL in INTOSC Modes' .\n5: The RE3 bit is only available when Master Clear Reset is disabled (CONFIG3H<7> = 0 ); otherwise, RE3 reads as ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n6: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as '0'.\n7: CAN bits have multiple functions depending on the selected mode of the CAN module.\n8: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.\n9: These registers are available on PIC18F4X8X devices only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB1D7, Bit 7 = RXB1D77. RXB1D7, Bit 6 = RXB1D76. RXB1D7, Bit 5 = RXB1D75. RXB1D7, Bit 4 = RXB1D74. RXB1D7, Bit 3 = RXB1D73. RXB1D7, Bit 2 = RXB1D72. RXB1D7, Bit 1 = RXB1D71. RXB1D7, Bit 0 = RXB1D70. RXB1D7, Value on POR, BOR = xxxx xxxx. RXB1D7, Details on page: = 50, 280. RXB1D6, Bit 7 = RXB1D67. RXB1D6, Bit 6 = RXB1D66. RXB1D6, Bit 5 = RXB1D65.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB1D6, Bit 4 = RXB1D64. RXB1D6, Bit 3 = RXB1D63. RXB1D6, Bit 2 = RXB1D62. RXB1D6, Bit 1 = RXB1D61. RXB1D6, Bit 0 = RXB1D60. RXB1D6, Value on POR, BOR = xxxx xxxx. RXB1D6, Details on page: = 50, 280. RXB1D5, Bit 7 = RXB1D57. RXB1D5, Bit 6 = RXB1D56. RXB1D5, Bit 5 = RXB1D55. RXB1D5, Bit 4 = RXB1D54. RXB1D5, Bit 3 = RXB1D53. RXB1D5, Bit 2 = RXB1D52.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB1D5, Bit 1 = RXB1D51. RXB1D5, Bit 0 = RXB1D50. RXB1D5, Value on POR, BOR = xxxx xxxx. RXB1D5, Details on page: = 50, 280. RXB1D4, Bit 7 = RXB1D47. RXB1D4, Bit 6 = RXB1D46. RXB1D4, Bit 5 = RXB1D45. RXB1D4, Bit 4 = RXB1D44. RXB1D4, Bit 3 = RXB1D43. RXB1D4, Bit 2 = RXB1D42. RXB1D4, Bit 1 = RXB1D41. RXB1D4, Bit 0 = RXB1D40. RXB1D4, Value on POR, BOR = xxxx xxxx.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB1D4, Details on page: = 50, 280. RXB1D3, Bit 7 = RXB1D37. RXB1D3, Bit 6 = RXB1D36. RXB1D3, Bit 5 = RXB1D35. RXB1D3, Bit 4 = RXB1D34. RXB1D3, Bit 3 = RXB1D33. RXB1D3, Bit 2 = RXB1D32. RXB1D3, Bit 1 = RXB1D31. RXB1D3, Bit 0 = RXB1D30. RXB1D3, Value on POR, BOR = xxxx xxxx. RXB1D3, Details on page: = 50, 280. RXB1D2, Bit 7 = RXB1D27. RXB1D2, Bit 6 = RXB1D26. RXB1D2, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n5 = RXB1D25. RXB1D2, Bit 4 = RXB1D24. RXB1D2, Bit 3 = RXB1D23. RXB1D2, Bit 2 = RXB1D22. RXB1D2, Bit 1 = RXB1D21. RXB1D2, Bit 0 = RXB1D20. RXB1D2, Value on POR, BOR = xxxx xxxx. RXB1D2, Details on page: = 50, 280. RXB1D1, Bit 7 = RXB1D17. RXB1D1, Bit 6 = RXB1D16. RXB1D1, Bit 5 = RXB1D15. RXB1D1, Bit 4 = RXB1D14. RXB1D1, Bit 3 = RXB1D13. RXB1D1, Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB1D12. RXB1D1, Bit 1 = RXB1D11. RXB1D1, Bit 0 = RXB1D10. RXB1D1, Value on POR, BOR = xxxx xxxx. RXB1D1, Details on page: = 50, 280. RXB1D0, Bit 7 = RXB1D07. RXB1D0, Bit 6 = RXB1D06. RXB1D0, Bit 5 = RXB1D05. RXB1D0, Bit 4 = RXB1D04. RXB1D0, Bit 3 = RXB1D03. RXB1D0, Bit 2 = RXB1D02. RXB1D0, Bit 1 = RXB1D01. RXB1D0, Bit 0 = RXB1D00. RXB1D0, Value on POR,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBOR = xxxx xxxx. RXB1D0, Details on page: = 50, 280. RXB1DLC, Bit 7 = -. RXB1DLC, Bit 6 = RXRTR. RXB1DLC, Bit 5 = RB1. RXB1DLC, Bit 4 = RB0. RXB1DLC, Bit 3 = DLC3. RXB1DLC, Bit 2 = DLC2. RXB1DLC, Bit 1 = DLC1. RXB1DLC, Bit 0 = DLC0. RXB1DLC, Value on POR, BOR = -xxx xxxx. RXB1DLC, Details on page: = 50, 280. RXB1EIDL, Bit 7 = EID7. RXB1EIDL, Bit 6 = EID6. RXB1EIDL, Bit 5 = EID5. RXB1EIDL, Bit 4 = EID4.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB1EIDL, Bit 3 = EID3. RXB1EIDL, Bit 2 = EID2. RXB1EIDL, Bit 1 = EID1. RXB1EIDL, Bit 0 = EID0. RXB1EIDL, Value on POR, BOR = xxxx xxxx. RXB1EIDL, Details on page: = 50, 279. RXB1EIDH, Bit 7 = EID15. RXB1EIDH, Bit 6 = EID14. RXB1EIDH, Bit 5 = EID13. RXB1EIDH, Bit 4 = EID12. RXB1EIDH, Bit 3 = EID11. RXB1EIDH, Bit 2 = EID10. RXB1EIDH, Bit 1 = EID9. RXB1EIDH, Bit 0 = EID8. RXB1EIDH, Value on POR, BOR = xxxx xxxx. RXB1EIDH,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nDetails on page: = 50, 279. RXB1SIDL, Bit 7 = SID2. RXB1SIDL, Bit 6 = SID1. RXB1SIDL, Bit 5 = SID0. RXB1SIDL, Bit 4 = SRR. RXB1SIDL, Bit 3 = EXID. RXB1SIDL, Bit 2 = -. RXB1SIDL, Bit 1 = EID17. RXB1SIDL, Bit 0 = EID16. RXB1SIDL, Value on POR, BOR = xxxx xxxx. RXB1SIDL, Details on page: = 50, 279. RXB1SIDH, Bit 7 = SID10. RXB1SIDH, Bit 6 = SID9. RXB1SIDH, Bit 5 = SID8. RXB1SIDH, Bit 4 = SID7. RXB1SIDH, Bit 3 = SID6. RXB1SIDH, Bit 2 = SID5.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXB1SIDH, Bit 1 = SID4. RXB1SIDH, Bit 0 = SID3. RXB1SIDH, Value on POR, BOR = xxxx xxxx. RXB1SIDH, Details on page: = 50, 278. RXB1CON Mode 0, Bit 7 = RXFUL. RXB1CON Mode 0, Bit 6 = RXM1. RXB1CON Mode 0, Bit 5 = RXM0 (7). RXB1CON Mode 0, Bit 4 = - (7). RXB1CON Mode 0, Bit 3 = RXRTRRO (7). RXB1CON Mode 0, Bit 2 = FILHIT2 (7). RXB1CON Mode 0, Bit 1 = FILHIT1 (7). RXB1CON Mode 0, Bit 0 = FILHIT0 (7). RXB1CON Mode 0, Value on POR, BOR = 000- 0000. RXB1CON Mode",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n0, Details on page: = 50, 275. RXB1CON Mode 1, 2, Bit 7 = RXFUL. RXB1CON Mode 1, 2, Bit 6 = RXM1. RXB1CON Mode 1, 2, Bit 5 = RTRRO. RXB1CON Mode 1, 2, Bit 4 = FILHIT4. RXB1CON Mode 1, 2, Bit 3 = FILHIT3. RXB1CON Mode 1, 2, Bit 2 = FILHIT2. RXB1CON Mode 1, 2, Bit 1 = FILHIT1. RXB1CON Mode 1, 2, Bit 0 = FILHIT0. RXB1CON Mode 1, 2, Value on POR, BOR = 0000 0000. RXB1CON Mode 1, 2, Details on page: = 50, 275. TXB0D7, Bit 7 = TXB0D77. TXB0D7, Bit 6 = TXB0D76.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB0D7, Bit 5 = TXB0D75. TXB0D7, Bit 4 = TXB0D74. TXB0D7, Bit 3 = TXB0D73. TXB0D7, Bit 2 = TXB0D72. TXB0D7, Bit 1 = TXB0D71. TXB0D7, Bit 0 = TXB0D70. TXB0D7, Value on POR, BOR = xxxx xxxx. TXB0D7, Details on page: = 50, 272. TXB0D6, Bit 7 = TXB0D67. TXB0D6, Bit 6 = TXB0D66. TXB0D6, Bit 5 = TXB0D65. TXB0D6, Bit 4 = TXB0D64. TXB0D6, Bit 3 = TXB0D63. TXB0D6, Bit 2 = TXB0D62. TXB0D6, Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB0D61. TXB0D6, Bit 0 = TXB0D60. TXB0D6, Value on POR, BOR = xxxx xxxx. TXB0D6, Details on page: = 50, 272. TXB0D5, Bit 7 = TXB0D57. TXB0D5, Bit 6 = TXB0D56. TXB0D5, Bit 5 = TXB0D55. TXB0D5, Bit 4 = TXB0D54. TXB0D5, Bit 3 = TXB0D53. TXB0D5, Bit 2 = TXB0D52. TXB0D5, Bit 1 = TXB0D51. TXB0D5, Bit 0 = TXB0D50. TXB0D5, Value on POR, BOR = xxxx xxxx. TXB0D5, Details on page: = 51, 272. TXB0D4, Bit 7 = TXB0D47. TXB0D4,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 6 = TXB0D46. TXB0D4, Bit 5 = TXB0D45. TXB0D4, Bit 4 = TXB0D44. TXB0D4, Bit 3 = TXB0D43. TXB0D4, Bit 2 = TXB0D42. TXB0D4, Bit 1 = TXB0D41. TXB0D4, Bit 0 = TXB0D40. TXB0D4, Value on POR, BOR = xxxx xxxx. TXB0D4, Details on page: = 51, 272. TXB0D3, Bit 7 = TXB0D37. TXB0D3, Bit 6 = TXB0D36. TXB0D3, Bit 5 = TXB0D35. TXB0D3, Bit 4 = TXB0D34. TXB0D3, Bit 3 = TXB0D33. TXB0D3, Bit 2 = TXB0D32. TXB0D3, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n1 = TXB0D31. TXB0D3, Bit 0 = TXB0D30. TXB0D3, Value on POR, BOR = xxxx xxxx. TXB0D3, Details on page: = 51, 272. TXB0D2, Bit 7 = TXB0D27. TXB0D2, Bit 6 = TXB0D26. TXB0D2, Bit 5 = TXB0D25. TXB0D2, Bit 4 = TXB0D24. TXB0D2, Bit 3 = TXB0D23. TXB0D2, Bit 2 = TXB0D22. TXB0D2, Bit 1 = TXB0D21. TXB0D2, Bit 0 = TXB0D20. TXB0D2, Value on POR, BOR = xxxx xxxx. TXB0D2, Details on page: = 51, 272. TXB0D1, Bit 7 = TXB0D17.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB0D1, Bit 6 = TXB0D16. TXB0D1, Bit 5 = TXB0D15. TXB0D1, Bit 4 = TXB0D14. TXB0D1, Bit 3 = TXB0D13. TXB0D1, Bit 2 = TXB0D12. TXB0D1, Bit 1 = TXB0D11. TXB0D1, Bit 0 = TXB0D10. TXB0D1, Value on POR, BOR = xxxx xxxx. TXB0D1, Details on page: = 51, 272. TXB0D0, Bit 7 = TXB0D07. TXB0D0, Bit 6 = TXB0D06. TXB0D0, Bit 5 = TXB0D05. TXB0D0, Bit 4 = TXB0D04. TXB0D0, Bit 3 = TXB0D03. TXB0D0, Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB0D02. TXB0D0, Bit 1 = TXB0D01. TXB0D0, Bit 0 = TXB0D00. TXB0D0, Value on POR, BOR = xxxx xxxx. TXB0D0, Details on page: = 51, 272. TXB0DLC, Bit 7 = -. TXB0DLC, Bit 6 = TXRTR. TXB0DLC, Bit 5 = -. TXB0DLC, Bit 4 = -. TXB0DLC, Bit 3 = DLC3. TXB0DLC, Bit 2 = DLC2. TXB0DLC, Bit 1 = DLC1. TXB0DLC, Bit 0 = DLC0. TXB0DLC, Value on POR, BOR = -x-- xxxx. TXB0DLC, Details on page: = 51, 273. TXB0EIDL, Bit 7 = EID7. TXB0EIDL, Bit 6 = EID6.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB0EIDL, Bit 5 = EID5. TXB0EIDL, Bit 4 = EID4. TXB0EIDL, Bit 3 = EID3. TXB0EIDL, Bit 2 = EID2. TXB0EIDL, Bit 1 = EID1. TXB0EIDL, Bit 0 = EID0. TXB0EIDL, Value on POR, BOR = xxxx xxxx. TXB0EIDL, Details on page: = 51, 272. TXB0EIDH, Bit 7 = EID15. TXB0EIDH, Bit 6 = EID14. TXB0EIDH, Bit 5 = EID13. TXB0EIDH, Bit 4 = EID12. TXB0EIDH, Bit 3 = EID11. TXB0EIDH, Bit 2 = EID10. TXB0EIDH, Bit 1 = EID9. TXB0EIDH, Bit 0 = EID8. TXB0EIDH, Value on POR, BOR =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nxxxx xxxx. TXB0EIDH, Details on page: = 51, 271. TXB0SIDL, Bit 7 = SID2. TXB0SIDL, Bit 6 = SID1. TXB0SIDL, Bit 5 = SID0. TXB0SIDL, Bit 4 = -. TXB0SIDL, Bit 3 = EXIDE. TXB0SIDL, Bit 2 = -. TXB0SIDL, Bit 1 = EID17. TXB0SIDL, Bit 0 = EID16. TXB0SIDL, Value on POR, BOR = xxx- x-xx. TXB0SIDL, Details on page: = 51, 271. TXB0SIDH, Bit 7 = SID10. TXB0SIDH, Bit 6 = SID9. TXB0SIDH, Bit 5 = SID8. TXB0SIDH, Bit 4 = SID7. TXB0SIDH, Bit 3 = SID6. TXB0SIDH, Bit 2 = SID5. TXB0SIDH,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 1 = SID4. TXB0SIDH, Bit 0 = SID3. TXB0SIDH, Value on POR, BOR = xxxx xxxx. TXB0SIDH, Details on page: = 51, 271. TXB0CON, Bit 7 = TXBIF. TXB0CON, Bit 6 = TXABT. TXB0CON, Bit 5 = TXLARB. TXB0CON, Bit 4 = TXERR. TXB0CON, Bit 3 = TXREQ. TXB0CON, Bit 2 = -. TXB0CON, Bit 1 = TXPRI1. TXB0CON, Bit 0 = TXPRI0. TXB0CON, Value on POR, BOR = 0000 0-00. TXB0CON, Details on page: = 51, 270. TXB1D7, Bit 7 = TXB1D77. TXB1D7, Bit 6 = TXB1D76. TXB1D7, Bit 5 = TXB1D75.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB1D7, Bit 4 = TXB1D74. TXB1D7, Bit 3 = TXB1D73. TXB1D7, Bit 2 = TXB1D72. TXB1D7, Bit 1 = TXB1D71. TXB1D7, Bit 0 = TXB1D70. TXB1D7, Value on POR, BOR = xxxx xxxx. TXB1D7, Details on page: = 51, 272. TXB1D6, Bit 7 = TXB1D67. TXB1D6, Bit 6 = TXB1D66. TXB1D6, Bit 5 = TXB1D65. TXB1D6, Bit 4 = TXB1D64. TXB1D6, Bit 3 = TXB1D63. TXB1D6, Bit 2 = TXB1D62. TXB1D6, Bit 1 = TXB1D61. TXB1D6, Bit 0",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n= TXB1D60. TXB1D6, Value on POR, BOR = xxxx xxxx. TXB1D6, Details on page: = 51, 272. TXB1D5, Bit 7 = TXB1D57. TXB1D5, Bit 6 = TXB1D56. TXB1D5, Bit 5 = TXB1D55. TXB1D5, Bit 4 = TXB1D54. TXB1D5, Bit 3 = TXB1D53. TXB1D5, Bit 2 = TXB1D52. TXB1D5, Bit 1 = TXB1D51. TXB1D5, Bit 0 = TXB1D50. TXB1D5, Value on POR, BOR = xxxx xxxx. TXB1D5, Details on page: = 51, 272. TXB1D4, Bit 7 = TXB1D47. TXB1D4, Bit 6 = TXB1D46. TXB1D4,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 5 = TXB1D45. TXB1D4, Bit 4 = TXB1D44. TXB1D4, Bit 3 = TXB1D43. TXB1D4, Bit 2 = TXB1D42. TXB1D4, Bit 1 = TXB1D41. TXB1D4, Bit 0 = TXB1D40. TXB1D4, Value on POR, BOR = xxxx xxxx. TXB1D4, Details on page: = 51, 272. TXB1D3, Bit 7 = TXB1D37. TXB1D3, Bit 6 = TXB1D36. TXB1D3, Bit 5 = TXB1D35. TXB1D3, Bit 4 = TXB1D34. TXB1D3, Bit 3 = TXB1D33. TXB1D3, Bit 2 = TXB1D32. TXB1D3, Bit 1 = TXB1D31. TXB1D3, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n0 = TXB1D30. TXB1D3, Value on POR, BOR = xxxx xxxx. TXB1D3, Details on page: = 51, 272. TXB1D2, Bit 7 = TXB1D27. TXB1D2, Bit 6 = TXB1D26. TXB1D2, Bit 5 = TXB1D25. TXB1D2, Bit 4 = TXB1D24. TXB1D2, Bit 3 = TXB1D23. TXB1D2, Bit 2 = TXB1D22. TXB1D2, Bit 1 = TXB1D21. TXB1D2, Bit 0 = TXB1D20. TXB1D2, Value on POR, BOR = xxxx xxxx. TXB1D2, Details on page: = 51, 272. TXB1D1, Bit 7 = TXB1D17. TXB1D1, Bit 6 = TXB1D16.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB1D1, Bit 5 = TXB1D15. TXB1D1, Bit 4 = TXB1D14. TXB1D1, Bit 3 = TXB1D13. TXB1D1, Bit 2 = TXB1D12. TXB1D1, Bit 1 = TXB1D11. TXB1D1, Bit 0 = TXB1D10. TXB1D1, Value on POR, BOR = xxxx xxxx. TXB1D1, Details on page: = 51, 272. TXB1D0, Bit 7 = TXB1D07. TXB1D0, Bit 6 = TXB1D06. TXB1D0, Bit 5 = TXB1D05. TXB1D0, Bit 4 = TXB1D04. TXB1D0, Bit 3 = TXB1D03. TXB1D0, Bit 2 = TXB1D02. TXB1D0, Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB1D01. TXB1D0, Bit 0 = TXB1D00. TXB1D0, Value on POR, BOR = xxxx. TXB1D0, Details on page: = 51, 272. TXB1DLC, Bit 7 = -. TXB1DLC, Bit 6 = . TXB1DLC, Bit 5 = -. TXB1DLC, Bit 4 = . TXB1DLC, Bit 3 = . TXB1DLC, Bit 2 = . TXB1DLC, Bit 1 = . TXB1DLC, Bit 0 = . TXB1DLC, Value on POR, BOR = xxxx. TXB1DLC, Details on page: = 51, 273. TXB1EIDL, Bit 7 = EID7. TXB1EIDL, Bit 6 = TXRTR EID6. TXB1EIDL, Bit 5 = EID5. TXB1EIDL, Bit 4 = - EID4. TXB1EIDL, Bit 3",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n= DLC3 EID3. TXB1EIDL, Bit 2 = DLC2 EID2. TXB1EIDL, Bit 1 = DLC1 EID1. TXB1EIDL, Bit 0 = DLC0 EID0. TXB1EIDL, Value on POR, BOR = -x-- xxxx xxxx xxxx. TXB1EIDL, Details on page: = 51, 272. TXB1EIDH, Bit 7 = EID15. TXB1EIDH, Bit 6 = EID14. TXB1EIDH, Bit 5 = EID13. TXB1EIDH, Bit 4 = EID12. TXB1EIDH, Bit 3 = EID11. TXB1EIDH, Bit 2 = EID10. TXB1EIDH, Bit 1 = EID9. TXB1EIDH, Bit 0 = EID8. TXB1EIDH, Value on POR, BOR = xxxx xxxx. TXB1EIDH, Details on page: =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n51, 271\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '. See Section 4.4 'Brown-out Reset (BOR)' .\n3: These registers and/or bits are not implemented on PIC18F2X8X devices and are read as ' 0 '. Reset values are shown for PIC18F4X8X devices; individual unimplemented bits should be interpreted as '-'.\n4: The PLLEN bit is only available in specific oscillator configuration; otherwise, it is disabled and reads as ' 0 '. See Section 2.6.4 'PLL in INTOSC Modes' .\n5: The RE3 bit is only available when Master Clear Reset is disabled (CONFIG3H<7> = 0 ); otherwise, RE3 reads as ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n6: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as '0'.\n7: CAN bits have multiple functions depending on the selected mode of the CAN module.\n8: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.\n9: These registers are available on PIC18F4X8X devices only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB1SIDL, Bit 7 = SID2. TXB1SIDL, Bit 6 = SID1. TXB1SIDL, Bit 5 = SID0. TXB1SIDL, Bit 4 = -. TXB1SIDL, Bit 3 = EXIDE. TXB1SIDL, Bit 2 = -. TXB1SIDL, Bit 1 = EID17. TXB1SIDL, Bit 0 = EID16. TXB1SIDL, Value on POR, BOR = xxx- x-xx. TXB1SIDL, Details on page: = 51, 271. TXB1SIDH, Bit 7 = SID10. TXB1SIDH, Bit 6 = SID9. TXB1SIDH, Bit 5 = SID8. TXB1SIDH, Bit 4 = SID7. TXB1SIDH, Bit 3 = SID6. TXB1SIDH, Bit 2 = SID5. TXB1SIDH, Bit 1 = SID4. TXB1SIDH, Bit 0 = SID3.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB1SIDH, Value on POR, BOR = xxxx xxxx. TXB1SIDH, Details on page: = 51, 271. TXB1CON, Bit 7 = TXBIF. TXB1CON, Bit 6 = TXABT. TXB1CON, Bit 5 = TXLARB. TXB1CON, Bit 4 = TXERR. TXB1CON, Bit 3 = TXREQ. TXB1CON, Bit 2 = -. TXB1CON, Bit 1 = TXPRI1. TXB1CON, Bit 0 = TXPRI0. TXB1CON, Value on POR, BOR = 0000 0-00. TXB1CON, Details on page: = 51, 270. TXB2D7, Bit 7 = TXB2D77. TXB2D7, Bit 6 = TXB2D76. TXB2D7, Bit 5 = TXB2D75. TXB2D7, Bit 4 = TXB2D74.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB2D7, Bit 3 = TXB2D73. TXB2D7, Bit 2 = TXB2D72. TXB2D7, Bit 1 = TXB2D71. TXB2D7, Bit 0 = TXB2D70. TXB2D7, Value on POR, BOR = xxxx xxxx. TXB2D7, Details on page: = 51, 272. TXB2D6, Bit 7 = TXB2D67. TXB2D6, Bit 6 = TXB2D66. TXB2D6, Bit 5 = TXB2D65. TXB2D6, Bit 4 = TXB2D64. TXB2D6, Bit 3 = TXB2D63. TXB2D6, Bit 2 = TXB2D62. TXB2D6, Bit 1 = TXB2D61. TXB2D6, Bit 0 = TXB2D60. TXB2D6, Value on",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nPOR, BOR = xxxx xxxx. TXB2D6, Details on page: = 51, 272. TXB2D5, Bit 7 = TXB2D57. TXB2D5, Bit 6 = TXB2D56. TXB2D5, Bit 5 = TXB2D55. TXB2D5, Bit 4 = TXB2D54. TXB2D5, Bit 3 = TXB2D53. TXB2D5, Bit 2 = TXB2D52. TXB2D5, Bit 1 = TXB2D51. TXB2D5, Bit 0 = TXB2D50. TXB2D5, Value on POR, BOR = xxxx xxxx. TXB2D5, Details on page: = 51, 272. TXB2D4, Bit 7 = TXB2D47. TXB2D4, Bit 6 = TXB2D46. TXB2D4, Bit 5 = TXB2D45. TXB2D4,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 4 = TXB2D44. TXB2D4, Bit 3 = TXB2D43. TXB2D4, Bit 2 = TXB2D42. TXB2D4, Bit 1 = TXB2D41. TXB2D4, Bit 0 = TXB2D40. TXB2D4, Value on POR, BOR = xxxx xxxx. TXB2D4, Details on page: = 51, 272. TXB2D3, Bit 7 = TXB2D37. TXB2D3, Bit 6 = TXB2D36. TXB2D3, Bit 5 = TXB2D35. TXB2D3, Bit 4 = TXB2D34. TXB2D3, Bit 3 = TXB2D33. TXB2D3, Bit 2 = TXB2D32. TXB2D3, Bit 1 = TXB2D31. TXB2D3, Bit 0 = TXB2D30. TXB2D3, Value",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\non POR, BOR = xxxx xxxx. TXB2D3, Details on page: = 51, 272. TXB2D2, Bit 7 = TXB2D27. TXB2D2, Bit 6 = TXB2D26. TXB2D2, Bit 5 = TXB2D25. TXB2D2, Bit 4 = TXB2D24. TXB2D2, Bit 3 = TXB2D23. TXB2D2, Bit 2 = TXB2D22. TXB2D2, Bit 1 = TXB2D21. TXB2D2, Bit 0 = TXB2D20. TXB2D2, Value on POR, BOR = xxxx xxxx. TXB2D2, Details on page: = 51, 272. TXB2D1, Bit 7 = TXB2D17. TXB2D1, Bit 6 = TXB2D16. TXB2D1, Bit 5 = TXB2D15.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB2D1, Bit 4 = TXB2D14. TXB2D1, Bit 3 = TXB2D13. TXB2D1, Bit 2 = TXB2D12. TXB2D1, Bit 1 = TXB2D11. TXB2D1, Bit 0 = TXB2D10. TXB2D1, Value on POR, BOR = xxxx xxxx. TXB2D1, Details on page: = 52, 272. TXB2D0, Bit 7 = TXB2D07. TXB2D0, Bit 6 = TXB2D06. TXB2D0, Bit 5 = TXB2D05. TXB2D0, Bit 4 = TXB2D04. TXB2D0, Bit 3 = TXB2D03. TXB2D0, Bit 2 = TXB2D02. TXB2D0, Bit 1 = TXB2D01. TXB2D0, Bit 0 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB2D00. TXB2D0, Value on POR, BOR = xxxx xxxx. TXB2D0, Details on page: = 52, 272. TXB2DLC, Bit 7 = -. TXB2DLC, Bit 6 = TXRTR. TXB2DLC, Bit 5 = -. TXB2DLC, Bit 4 = -. TXB2DLC, Bit 3 = DLC3. TXB2DLC, Bit 2 = DLC2. TXB2DLC, Bit 1 = DLC1. TXB2DLC, Bit 0 = DLC0. TXB2DLC, Value on POR, BOR = -x-- xxxx. TXB2DLC, Details on page: = 52, 273. TXB2EIDL, Bit 7 = EID7. TXB2EIDL, Bit 6 = EID6. TXB2EIDL, Bit 5 = EID5. TXB2EIDL, Bit 4 = EID4.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTXB2EIDL, Bit 3 = EID3. TXB2EIDL, Bit 2 = EID2. TXB2EIDL, Bit 1 = EID1. TXB2EIDL, Bit 0 = EID0. TXB2EIDL, Value on POR, BOR = xxxx xxxx. TXB2EIDL, Details on page: = 52, 272. TXB2EIDH, Bit 7 = EID15. TXB2EIDH, Bit 6 = EID14. TXB2EIDH, Bit 5 = EID13. TXB2EIDH, Bit 4 = EID12. TXB2EIDH, Bit 3 = EID11. TXB2EIDH, Bit 2 = EID10. TXB2EIDH, Bit 1 = EID9. TXB2EIDH, Bit 0 = EID8. TXB2EIDH, Value on POR, BOR = xxxx xxxx. TXB2EIDH, Details on page: = 52, 271. TXB2SIDL, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n7 = SID2. TXB2SIDL, Bit 6 = SID1. TXB2SIDL, Bit 5 = SID0. TXB2SIDL, Bit 4 = -. TXB2SIDL, Bit 3 = EXIDE. TXB2SIDL, Bit 2 = -. TXB2SIDL, Bit 1 = EID17. TXB2SIDL, Bit 0 = EID16. TXB2SIDL, Value on POR, BOR = xxxx x-xx. TXB2SIDL, Details on page: = 52, 271. TXB2SIDH, Bit 7 = SID10. TXB2SIDH, Bit 6 = SID9. TXB2SIDH, Bit 5 = SID8. TXB2SIDH, Bit 4 = SID7. TXB2SIDH, Bit 3 = SID6. TXB2SIDH, Bit 2 = SID5. TXB2SIDH, Bit 1 = SID4. TXB2SIDH, Bit 0 = SID3. TXB2SIDH, Value on POR,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBOR = xxx- x-xx. TXB2SIDH, Details on page: = 52, 271. TXB2CON, Bit 7 = TXBIF. TXB2CON, Bit 6 = TXABT. TXB2CON, Bit 5 = TXLARB. TXB2CON, Bit 4 = TXERR. TXB2CON, Bit 3 = TXREQ. TXB2CON, Bit 2 = -. TXB2CON, Bit 1 = TXPRI1. TXB2CON, Bit 0 = TXPRI0. TXB2CON, Value on POR, BOR = 0000 0-00. TXB2CON, Details on page: = 52, 270. RXM1EIDL, Bit 7 = EID7. RXM1EIDL, Bit 6 = EID6. RXM1EIDL, Bit 5 = EID5. RXM1EIDL, Bit 4 = EID4. RXM1EIDL, Bit 3 = EID3.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXM1EIDL, Bit 2 = EID2. RXM1EIDL, Bit 1 = EID1. RXM1EIDL, Bit 0 = EID0. RXM1EIDL, Value on POR, BOR = xxxx xxxx. RXM1EIDL, Details on page: = 52, 292. RXM1EIDH, Bit 7 = EID15. RXM1EIDH, Bit 6 = EID14. RXM1EIDH, Bit 5 = EID13. RXM1EIDH, Bit 4 = EID12. RXM1EIDH, Bit 3 = EID11. RXM1EIDH, Bit 2 = EID10. RXM1EIDH, Bit 1 = EID9. RXM1EIDH, Bit 0 = EID8. RXM1EIDH, Value on POR, BOR = xxxx xxxx. RXM1EIDH, Details on page: = 52, 292.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXM1SIDL, Bit 7 = SID2. RXM1SIDL, Bit 6 = SID1. RXM1SIDL, Bit 5 = SID0. RXM1SIDL, Bit 4 = -. RXM1SIDL, Bit 3 = EXIDEN. RXM1SIDL, Bit 2 = -. RXM1SIDL, Bit 1 = EID17. RXM1SIDL, Bit 0 = EID16. RXM1SIDL, Value on POR, BOR = xxx- x-xx. RXM1SIDL, Details on page: = 52, 292. RXM1SIDH, Bit 7 = SID10. RXM1SIDH, Bit 6 = SID9. RXM1SIDH, Bit 5 = SID8. RXM1SIDH, Bit 4 = SID7. RXM1SIDH, Bit 3 = SID6. RXM1SIDH, Bit 2 = SID5. RXM1SIDH, Bit 1",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n= SID4. RXM1SIDH, Bit 0 = SID3. RXM1SIDH, Value on POR, BOR = xxxx xxxx. RXM1SIDH, Details on page: = 52, 292. RXM0EIDL, Bit 7 = EID7. RXM0EIDL, Bit 6 = EID6. RXM0EIDL, Bit 5 = EID5. RXM0EIDL, Bit 4 = EID4. RXM0EIDL, Bit 3 = EID3. RXM0EIDL, Bit 2 = EID2. RXM0EIDL, Bit 1 = EID1. RXM0EIDL, Bit 0 = EID0. RXM0EIDL, Value on POR, BOR = xxxx xxxx. RXM0EIDL, Details on page: = 52, 292. RXM0EIDH, Bit 7 = EID15. RXM0EIDH, Bit 6 = EID14.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXM0EIDH, Bit 5 = EID13. RXM0EIDH, Bit 4 = EID12. RXM0EIDH, Bit 3 = EID11. RXM0EIDH, Bit 2 = EID10. RXM0EIDH, Bit 1 = EID9. RXM0EIDH, Bit 0 = EID8. RXM0EIDH, Value on POR, BOR = xxxx xxxx. RXM0EIDH, Details on page: = 52, 292. RXM0SIDL, Bit 7 = SID2. RXM0SIDL, Bit 6 = SID1. RXM0SIDL, Bit 5 = SID0. RXM0SIDL, Bit 4 = -. RXM0SIDL, Bit 3 = EXIDEN. RXM0SIDL, Bit 2 = -. RXM0SIDL, Bit 1 = EID17. RXM0SIDL, Bit 0 = EID16.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXM0SIDL, Value on POR, BOR = xxx- x-xx. RXM0SIDL, Details on page: = 52, 292. RXM0SIDH, Bit 7 = SID10. RXM0SIDH, Bit 6 = SID9. RXM0SIDH, Bit 5 = SID8. RXM0SIDH, Bit 4 = SID7. RXM0SIDH, Bit 3 = SID6. RXM0SIDH, Bit 2 = SID5. RXM0SIDH, Bit 1 = SID4. RXM0SIDH, Bit 0 = SID3. RXM0SIDH, Value on POR, BOR = xxxx xxxx. RXM0SIDH, Details on page: = 52, 291. RXF5EIDL, Bit 7 = EID7. RXF5EIDL, Bit 6 = EID6. RXF5EIDL, Bit 5 = EID5. RXF5EIDL, Bit 4 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEID4. RXF5EIDL, Bit 3 = EID3. RXF5EIDL, Bit 2 = EID2. RXF5EIDL, Bit 1 = EID1. RXF5EIDL, Bit 0 = EID0. RXF5EIDL, Value on POR, BOR = xxxx xxxx. RXF5EIDL, Details on page: = 52, 291. RXF5EIDH, Bit 7 = EID15. RXF5EIDH, Bit 6 = EID14. RXF5EIDH, Bit 5 = EID13. RXF5EIDH, Bit 4 = EID12. RXF5EIDH, Bit 3 = EID11. RXF5EIDH, Bit 2 = EID10. RXF5EIDH, Bit 1 = EID9. RXF5EIDH, Bit 0 = EID8. RXF5EIDH, Value on POR, BOR = xxxx xxxx.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF5EIDH, Details on page: = 52, 291. RXF5SIDL, Bit 7 = SID2. RXF5SIDL, Bit 6 = SID1. RXF5SIDL, Bit 5 = SID0. RXF5SIDL, Bit 4 = -. RXF5SIDL, Bit 3 = EXIDEN. RXF5SIDL, Bit 2 = -. RXF5SIDL, Bit 1 = EID17. RXF5SIDL, Bit 0 = EID16. RXF5SIDL, Value on POR, BOR = xxx- x-xx. RXF5SIDL, Details on page: = 52, 290. RXF5SIDH, Bit 7 = SID10. RXF5SIDH, Bit 6 = SID9. RXF5SIDH, Bit 5 = SID8. RXF5SIDH, Bit 4 = SID7. RXF5SIDH, Bit 3 = SID6.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF5SIDH, Bit 2 = SID5. RXF5SIDH, Bit 1 = SID4. RXF5SIDH, Bit 0 = SID3. RXF5SIDH, Value on POR, BOR = xxxx xxxx. RXF5SIDH, Details on page: = 52, 290. RXF4EIDL, Bit 7 = EID7. RXF4EIDL, Bit 6 = EID6. RXF4EIDL, Bit 5 = EID5. RXF4EIDL, Bit 4 = EID4. RXF4EIDL, Bit 3 = EID3. RXF4EIDL, Bit 2 = EID2. RXF4EIDL, Bit 1 = EID1. RXF4EIDL, Bit 0 = EID0. RXF4EIDL, Value on POR, BOR = xxxx xxxx. RXF4EIDL, Details on page: = 52, 291. RXF4EIDH, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n7 = EID15. RXF4EIDH, Bit 6 = EID14. RXF4EIDH, Bit 5 = EID13. RXF4EIDH, Bit 4 = EID12. RXF4EIDH, Bit 3 = EID11. RXF4EIDH, Bit 2 = EID10. RXF4EIDH, Bit 1 = EID9. RXF4EIDH, Bit 0 = EID8. RXF4EIDH, Value on POR, BOR = xxxx xxxx. RXF4EIDH, Details on page: = 52, 291. RXF4SIDL, Bit 7 = SID2. RXF4SIDL, Bit 6 = SID1. RXF4SIDL, Bit 5 = SID0. RXF4SIDL, Bit 4 = -. RXF4SIDL, Bit 3 = EXIDEN. RXF4SIDL, Bit 2 = -. RXF4SIDL, Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEID17. RXF4SIDL, Bit 0 = EID16. RXF4SIDL, Value on POR, BOR = xxx- x-xx. RXF4SIDL, Details on page: = 52, 290. RXF4SIDH, Bit 7 = SID10. RXF4SIDH, Bit 6 = SID9. RXF4SIDH, Bit 5 = SID8. RXF4SIDH, Bit 4 = SID7. RXF4SIDH, Bit 3 = SID6. RXF4SIDH, Bit 2 = SID5. RXF4SIDH, Bit 1 = SID4. RXF4SIDH, Bit 0 = SID3. RXF4SIDH, Value on POR, BOR = xxxx xxxx. RXF4SIDH, Details on page: = 52, 290. RXF3EIDL, Bit 7 = EID7. RXF3EIDL, Bit 6 = EID6. RXF3EIDL,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 5 = EID5. RXF3EIDL, Bit 4 = EID4. RXF3EIDL, Bit 3 = EID3. RXF3EIDL, Bit 2 = EID2. RXF3EIDL, Bit 1 = EID1. RXF3EIDL, Bit 0 = EID0. RXF3EIDL, Value on POR, BOR = xxxx xxxx. RXF3EIDL, Details on page: = 52, 291. RXF3EIDH, Bit 7 = EID15. RXF3EIDH, Bit 6 = EID14. RXF3EIDH, Bit 5 = EID13. RXF3EIDH, Bit 4 = EID12. RXF3EIDH, Bit 3 = EID11. RXF3EIDH, Bit 2 = EID10. RXF3EIDH, Bit 1 = EID9. RXF3EIDH, Bit 0 = EID8.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF3EIDH, Value on POR, BOR = xxxx xxxx. RXF3EIDH, Details on page: = 52, 291. RXF3SIDL, Bit 7 = SID2. RXF3SIDL, Bit 6 = SID1. RXF3SIDL, Bit 5 = SID0. RXF3SIDL, Bit 4 = -. RXF3SIDL, Bit 3 = EXIDEN. RXF3SIDL, Bit 2 = -. RXF3SIDL, Bit 1 = EID17. RXF3SIDL, Bit 0 = EID16. RXF3SIDL, Value on POR, BOR = xxx- x-xx. RXF3SIDL, Details on page: = 52, 290. RXF3SIDH, Bit 7 = SID10. RXF3SIDH, Bit 6 = SID9. RXF3SIDH, Bit 5 = SID8. RXF3SIDH, Bit 4 = SID7.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF3SIDH, Bit 3 = SID6. RXF3SIDH, Bit 2 = SID5. RXF3SIDH, Bit 1 = SID4. RXF3SIDH, Bit 0 = SID3. RXF3SIDH, Value on POR, BOR = xxxx xxxx. RXF3SIDH, Details on page: = 52, 290. RXF2EIDL, Bit 7 = EID7. RXF2EIDL, Bit 6 = EID6. RXF2EIDL, Bit 5 = EID5. RXF2EIDL, Bit 4 = EID4. RXF2EIDL, Bit 3 = EID3. RXF2EIDL, Bit 2 = EID2. RXF2EIDL, Bit 1 = EID1. RXF2EIDL, Bit 0 = EID0. RXF2EIDL, Value on POR, BOR = xxxx xxxx. RXF2EIDL, Details on page:",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n= 52, 291. RXF2EIDH, Bit 7 = EID15. RXF2EIDH, Bit 6 = EID14. RXF2EIDH, Bit 5 = EID13. RXF2EIDH, Bit 4 = EID12. RXF2EIDH, Bit 3 = EID11. RXF2EIDH, Bit 2 = EID10. RXF2EIDH, Bit 1 = EID9. RXF2EIDH, Bit 0 = EID8. RXF2EIDH, Value on POR, BOR = xxxx xxxx. RXF2EIDH, Details on page: = 52, 291. RXF2SIDL, Bit 7 = SID2. RXF2SIDL, Bit 6 = SID1. RXF2SIDL, Bit 5 = SID0. RXF2SIDL, Bit 4 = -. RXF2SIDL, Bit 3 = EXIDEN. RXF2SIDL, Bit 2 = -.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF2SIDL, Bit 1 = EID17. RXF2SIDL, Bit 0 = EID16. RXF2SIDL, Value on POR, BOR = xxx- x-xx. RXF2SIDL, Details on page: = 52, 290. RXF2SIDH, Bit 7 = SID10. RXF2SIDH, Bit 6 = SID9. RXF2SIDH, Bit 5 = SID8. RXF2SIDH, Bit 4 = SID7. RXF2SIDH, Bit 3 = SID6. RXF2SIDH, Bit 2 = SID5. RXF2SIDH, Bit 1 = SID4. RXF2SIDH, Bit 0 = SID3. RXF2SIDH, Value on POR, BOR = xxxx xxxx. RXF2SIDH, Details on page: = 52, 290\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '. See Section 4.4 'Brown-out Reset (BOR)' .\n3: These registers and/or bits are not implemented on PIC18F2X8X devices and are read as ' 0 '. Reset values are shown for PIC18F4X8X devices; individual unimplemented bits should be interpreted as '-'.\n4: The PLLEN bit is only available in specific oscillator configuration; otherwise, it is disabled and reads as ' 0 '. See Section 2.6.4 'PLL in INTOSC Modes' .\n5: The RE3 bit is only available when Master Clear Reset is disabled (CONFIG3H<7> = 0 ); otherwise, RE3 reads as ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n6: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as '0'.\n7: CAN bits have multiple functions depending on the selected mode of the CAN module.\n8: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.\n9: These registers are available on PIC18F4X8X devices only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF1EIDL, Bit 7 = EID7. RXF1EIDL, Bit 6 = EID6. RXF1EIDL, Bit 5 = EID5. RXF1EIDL, Bit 4 = EID4. RXF1EIDL, Bit 3 = EID3. RXF1EIDL, Bit 2 = EID2. RXF1EIDL, Bit 1 = EID1. RXF1EIDL, Bit 0 = EID0. RXF1EIDL, Value on POR, BOR = xxxx xxxx. RXF1EIDL, Details on page: = 53, 291. RXF1EIDH, Bit 7 = EID15. RXF1EIDH, Bit 6 = EID14. RXF1EIDH, Bit 5 = EID13. RXF1EIDH, Bit 4 = EID12. RXF1EIDH, Bit 3 = EID11. RXF1EIDH, Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEID10. RXF1EIDH, Bit 1 = EID9. RXF1EIDH, Bit 0 = EID8. RXF1EIDH, Value on POR, BOR = xxxx xxxx. RXF1EIDH, Details on page: = 53, 291. RXF1SIDL, Bit 7 = SID2. RXF1SIDL, Bit 6 = SID1. RXF1SIDL, Bit 5 = SID0. RXF1SIDL, Bit 4 = -. RXF1SIDL, Bit 3 = EXIDEN. RXF1SIDL, Bit 2 = -. RXF1SIDL, Bit 1 = EID17. RXF1SIDL, Bit 0 = EID16. RXF1SIDL, Value on POR, BOR = xxx- x-xx. RXF1SIDL, Details on page: = 53, 290. RXF1SIDH, Bit 7 = SID10. RXF1SIDH,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 6 = SID9. RXF1SIDH, Bit 5 = SID8. RXF1SIDH, Bit 4 = SID7. RXF1SIDH, Bit 3 = SID6. RXF1SIDH, Bit 2 = SID5. RXF1SIDH, Bit 1 = SID4. RXF1SIDH, Bit 0 = SID3. RXF1SIDH, Value on POR, BOR = xxxx xxxx. RXF1SIDH, Details on page: = 53, 290. RXF0EIDL, Bit 7 = EID7. RXF0EIDL, Bit 6 = EID6. RXF0EIDL, Bit 5 = EID5. RXF0EIDL, Bit 4 = EID4. RXF0EIDL, Bit 3 = EID3. RXF0EIDL, Bit 2 = EID2. RXF0EIDL, Bit 1 = EID1. RXF0EIDL, Bit 0 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEID0. RXF0EIDL, Value on POR, BOR = xxxx xxxx. RXF0EIDL, Details on page: = 53, 291. RXF0EIDH, Bit 7 = EID15. RXF0EIDH, Bit 6 = EID14. RXF0EIDH, Bit 5 = EID13. RXF0EIDH, Bit 4 = EID12. RXF0EIDH, Bit 3 = EID11. RXF0EIDH, Bit 2 = EID10. RXF0EIDH, Bit 1 = EID9. RXF0EIDH, Bit 0 = EID8. RXF0EIDH, Value on POR, BOR = xxxx xxxx. RXF0EIDH, Details on page: = 53, 291. RXF0SIDL, Bit 7 = SID2. RXF0SIDL, Bit 6 = SID1. RXF0SIDL, Bit 5 = SID0.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF0SIDL, Bit 4 = -. RXF0SIDL, Bit 3 = EXIDEN. RXF0SIDL, Bit 2 = -. RXF0SIDL, Bit 1 = EID17. RXF0SIDL, Bit 0 = EID16. RXF0SIDL, Value on POR, BOR = xxx- x-xx. RXF0SIDL, Details on page: = 53, 290. RXF0SIDH, Bit 7 = SID10. RXF0SIDH, Bit 6 = SID9. RXF0SIDH, Bit 5 = SID8. RXF0SIDH, Bit 4 = SID7. RXF0SIDH, Bit 3 = SID6. RXF0SIDH, Bit 2 = SID5. RXF0SIDH, Bit 1 = SID4. RXF0SIDH, Bit 0 = SID3. RXF0SIDH, Value on POR, BOR = xxxx xxxx.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF0SIDH, Details on page: = 53, 290. B5D7 (8), Bit 7 = B5D77. B5D7 (8), Bit 6 = B5D76. B5D7 (8), Bit 5 = B5D75. B5D7 (8), Bit 4 = B5D74. B5D7 (8), Bit 3 = B5D73. B5D7 (8), Bit 2 = B5D72. B5D7 (8), Bit 1 = B5D71. B5D7 (8), Bit 0 = B5D70. B5D7 (8), Value on POR, BOR = xxxx xxxx. B5D7 (8), Details on page: = 53, 287. B5D6 (8), Bit 7 = B5D67. B5D6 (8), Bit 6 = B5D66. B5D6 (8), Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n5 = B5D65. B5D6 (8), Bit 4 = B5D64. B5D6 (8), Bit 3 = B5D63. B5D6 (8), Bit 2 = B5D62. B5D6 (8), Bit 1 = B5D61. B5D6 (8), Bit 0 = B5D60. B5D6 (8), Value on POR, BOR = xxxx xxxx. B5D6 (8), Details on page: = 53, 287. B5D5 (8), Bit 7 = B5D57. B5D5 (8), Bit 6 = B5D56. B5D5 (8), Bit 5 = B5D55. B5D5 (8), Bit 4 = B5D54. B5D5 (8), Bit 3 = B5D53. B5D5 (8), Bit 2 = B5D52. B5D5",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Bit 1 = B5D51. B5D5 (8), Bit 0 = B5D50. B5D5 (8), Value on POR, BOR = xxxx xxxx. B5D5 (8), Details on page: = 53, 287. B5D4 (8), Bit 7 = B5D47. B5D4 (8), Bit 6 = B5D46. B5D4 (8), Bit 5 = B5D45. B5D4 (8), Bit 4 = B5D44. B5D4 (8), Bit 3 = B5D43. B5D4 (8), Bit 2 = B5D42. B5D4 (8), Bit 1 = B5D41. B5D4 (8), Bit 0 = B5D40. B5D4 (8), Value on POR, BOR = xxxx xxxx. B5D4 (8), Details on page: = 53,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n287. B5D3 (8), Bit 7 = B5D37. B5D3 (8), Bit 6 = B5D36. B5D3 (8), Bit 5 = B5D35. B5D3 (8), Bit 4 = B5D34. B5D3 (8), Bit 3 = B5D33. B5D3 (8), Bit 2 = B5D32. B5D3 (8), Bit 1 = B5D31. B5D3 (8), Bit 0 = B5D30. B5D3 (8), Value on POR, BOR = xxxx xxxx. B5D3 (8), Details on page: = 53, 287. B5D2 (8), Bit 7 = B5D27. B5D2 (8), Bit 6 = B5D26. B5D2 (8), Bit 5 = B5D25. B5D2 (8), Bit 4 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB5D24. B5D2 (8), Bit 3 = B5D23. B5D2 (8), Bit 2 = B5D22. B5D2 (8), Bit 1 = B5D21. B5D2 (8), Bit 0 = B5D20. B5D2 (8), Value on POR, BOR = xxxx xxxx. B5D2 (8), Details on page: = 53, 287. B5D1 (8), Bit 7 = B5D17. B5D1 (8), Bit 6 = B5D16. B5D1 (8), Bit 5 = B5D15. B5D1 (8), Bit 4 = B5D14. B5D1 (8), Bit 3 = B5D13. B5D1 (8), Bit 2 = B5D12. B5D1 (8), Bit 1 = B5D11. B5D1 (8), Bit 0 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB5D10. B5D1 (8), Value on POR, BOR = xxxx xxxx. B5D1 (8), Details on page: = 53, 287. B5D0 (8), Bit 7 = B5D07. B5D0 (8), Bit 6 = B5D06. B5D0 (8), Bit 5 = B5D05. B5D0 (8), Bit 4 = B5D04. B5D0 (8), Bit 3 = B5D03. B5D0 (8), Bit 2 = B5D02. B5D0 (8), Bit 1 = B5D01. B5D0 (8), Bit 0 = B5D00. B5D0 (8), Value on POR, BOR = xxxx xxxx. B5D0 (8), Details on page: = 53, 287. B5DLC (8) Receive mode, Bit 7 = -.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB5DLC (8) Receive mode, Bit 6 = RXRTR. B5DLC (8) Receive mode, Bit 5 = RB1. B5DLC (8) Receive mode, Bit 4 = RB0. B5DLC (8) Receive mode, Bit 3 = DLC3. B5DLC (8) Receive mode, Bit 2 = DLC2. B5DLC (8) Receive mode, Bit 1 = DLC1. B5DLC (8) Receive mode, Bit 0 = DLC0. B5DLC (8) Receive mode, Value on POR, BOR = -xxx xxxx. B5DLC (8) Receive mode, Details on page: = 53, 288. B5DLC (8) Transmit mode, Bit 7 = -. B5DLC (8) Transmit mode, Bit 6 = TXRTR. B5DLC (8) Transmit mode, Bit 5 = -. B5DLC (8) Transmit mode, Bit 4 = -. B5DLC (8)",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTransmit mode, Bit 3 = DLC3. B5DLC (8) Transmit mode, Bit 2 = DLC2. B5DLC (8) Transmit mode, Bit 1 = DLC1. B5DLC (8) Transmit mode, Bit 0 = DLC0. B5DLC (8) Transmit mode, Value on POR, BOR = -x-- xxxx. B5DLC (8) Transmit mode, Details on page: = 53, 289. B5EIDL (8), Bit 7 = EID7. B5EIDL (8), Bit 6 = EID6. B5EIDL (8), Bit 5 = EID5. B5EIDL (8), Bit 4 = EID4. B5EIDL (8), Bit 3 = EID3. B5EIDL (8), Bit 2 = EID2. B5EIDL (8), Bit 1 = EID1. B5EIDL (8), Bit 0 = EID0. B5EIDL",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Value on POR, BOR = xxxx xxxx. B5EIDL (8), Details on page: = 53, 287. B5EIDH (8), Bit 7 = EID15. B5EIDH (8), Bit 6 = EID14. B5EIDH (8), Bit 5 = EID13. B5EIDH (8), Bit 4 = EID12. B5EIDH (8), Bit 3 = EID11. B5EIDH (8), Bit 2 = EID10. B5EIDH (8), Bit 1 = EID9. B5EIDH (8), Bit 0 = EID8. B5EIDH (8), Value on POR, BOR = xxxx xxxx. B5EIDH (8), Details on page: = 53, 286. B5SIDL (8) Receive mode, Bit 7 = SID2. B5SIDL (8) Receive mode, Bit 6 = SID1. B5SIDL (8)",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nReceive mode, Bit 5 = SID0. B5SIDL (8) Receive mode, Bit 4 = SRR. B5SIDL (8) Receive mode, Bit 3 = EXID. B5SIDL (8) Receive mode, Bit 2 = -. B5SIDL (8) Receive mode, Bit 1 = EID17. B5SIDL (8) Receive mode, Bit 0 = EID16. B5SIDL (8) Receive mode, Value on POR, BOR = xxxx x-xx. B5SIDL (8) Receive mode, Details on page: = 53, 285. B5SIDL (8) Transmit mode, Bit 7 = SID2. B5SIDL (8) Transmit mode, Bit 6 = SID1. B5SIDL (8) Transmit mode, Bit 5 = SID0. B5SIDL (8) Transmit mode, Bit 4 = -. B5SIDL (8) Transmit mode, Bit 3 = EXIDE. B5SIDL (8) Transmit mode, Bit 2 = -.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB5SIDL (8) Transmit mode, Bit 1 = EID17. B5SIDL (8) Transmit mode, Bit 0 = EID16. B5SIDL (8) Transmit mode, Value on POR, BOR = xxx- x-xx. B5SIDL (8) Transmit mode, Details on page: = 53, 285. B5SIDH (8), Bit 7 = SID10. B5SIDH (8), Bit 6 = SID9. B5SIDH (8), Bit 5 = SID8. B5SIDH (8), Bit 4 = SID7. B5SIDH (8), Bit 3 = SID6. B5SIDH (8), Bit 2 = SID5. B5SIDH (8), Bit 1 = SID4. B5SIDH (8), Bit 0 = SID3. B5SIDH (8), Value on POR, BOR = xxxx x-xx. B5SIDH (8), Details on page: = 53, 284.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB5CON (8) Receive mode, Bit 7 = RXFUL. B5CON (8) Receive mode, Bit 6 = RXM1. B5CON (8) Receive mode, Bit 5 = RXRTRRO. B5CON (8) Receive mode, Bit 4 = FILHIT4. B5CON (8) Receive mode, Bit 3 = FILHIT3. B5CON (8) Receive mode, Bit 2 = FILHIT2. B5CON (8) Receive mode, Bit 1 = FILHIT1. B5CON (8) Receive mode, Bit 0 = FILHIT0. B5CON (8) Receive mode, Value on POR, BOR = 0000 0000. B5CON (8) Receive mode, Details on page: = 53, 282. B5CON (8) Transmit mode, Bit 7 = TXBIF. B5CON (8) Transmit mode, Bit 6 = TXABT. B5CON (8) Transmit mode, Bit 5 = TXLARB. B5CON (8) Transmit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nmode, Bit 4 = TXERR. B5CON (8) Transmit mode, Bit 3 = TXREQ. B5CON (8) Transmit mode, Bit 2 = RTREN. B5CON (8) Transmit mode, Bit 1 = TXPRI1. B5CON (8) Transmit mode, Bit 0 = TXPRI0. B5CON (8) Transmit mode, Value on POR, BOR = 0000 0000. B5CON (8) Transmit mode, Details on page: = 53, 283. B4D7 (8), Bit 7 = B4D77. B4D7 (8), Bit 6 = B4D76. B4D7 (8), Bit 5 = B4D75. B4D7 (8), Bit 4 = B4D74. B4D7 (8), Bit 3 = B4D73. B4D7 (8), Bit 2 = B4D72. B4D7 (8), Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB4D71. B4D7 (8), Bit 0 = B4D70. B4D7 (8), Value on POR, BOR = xxxx xxxx. B4D7 (8), Details on page: = 53, 287. B4D6 (8), Bit 7 = B4D67. B4D6 (8), Bit 6 = B4D66. B4D6 (8), Bit 5 = B4D65. B4D6 (8), Bit 4 = B4D64. B4D6 (8), Bit 3 = B4D63. B4D6 (8), Bit 2 = B4D62. B4D6 (8), Bit 1 = B4D61. B4D6 (8), Bit 0 = B4D60. B4D6 (8), Value on POR, BOR = xxxx xxxx. B4D6 (8), Details on page: = 53, 287.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB4D5 (8), Bit 7 = B4D57. B4D5 (8), Bit 6 = B4D56. B4D5 (8), Bit 5 = B4D55. B4D5 (8), Bit 4 = B4D54. B4D5 (8), Bit 3 = B4D53. B4D5 (8), Bit 2 = B4D52. B4D5 (8), Bit 1 = B4D51. B4D5 (8), Bit 0 = B4D50. B4D5 (8), Value on POR, BOR = xxxx xxxx. B4D5 (8), Details on page: = 53, 287. B4D4 (8), Bit 7 = B4D47. B4D4 (8), Bit 6 = B4D46. B4D4 (8), Bit 5 = B4D45. B4D4 (8), Bit 4 = B4D44.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB4D4 (8), Bit 3 = B4D43. B4D4 (8), Bit 2 = B4D42. B4D4 (8), Bit 1 = B4D41. B4D4 (8), Bit 0 = B4D40. B4D4 (8), Value on POR, BOR = xxxx xxxx. B4D4 (8), Details on page: = 53, 287. B4D3 (8), Bit 7 = B4D37. B4D3 (8), Bit 6 = B4D36. B4D3 (8), Bit 5 = B4D35. B4D3 (8), Bit 4 = B4D34. B4D3 (8), Bit 3 = B4D33. B4D3 (8), Bit 2 = B4D32. B4D3 (8), Bit 1 = B4D31. B4D3 (8), Bit 0 = B4D30.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB4D3 (8), Value on POR, BOR = xxxx xxxx. B4D3 (8), Details on page: = 53, 287. B4D2 (8), Bit 7 = B4D27. B4D2 (8), Bit 6 = B4D26. B4D2 (8), Bit 5 = B4D25. B4D2 (8), Bit 4 = B4D24. B4D2 (8), Bit 3 = B4D23. B4D2 (8), Bit 2 = B4D22. B4D2 (8), Bit 1 = B4D21. B4D2 (8), Bit 0 = B4D20. B4D2 (8), Value on POR, BOR = xxxx xxxx. B4D2 (8), Details on page: = 53, 287. B4D1 (8), Bit 7 = B4D17. B4D1 (8), Bit 6 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB4D16. B4D1 (8), Bit 5 = B4D15. B4D1 (8), Bit 4 = B4D14. B4D1 (8), Bit 3 = B4D13. B4D1 (8), Bit 2 = B4D12. B4D1 (8), Bit 1 = B4D11. B4D1 (8), Bit 0 = B4D10. B4D1 (8), Value on POR, BOR = xxxx xxxx. B4D1 (8), Details on page: = 53, 287. B4D0 (8), Bit 7 = B4D07. B4D0 (8), Bit 6 = B4D06. B4D0 (8), Bit 5 = B4D05. B4D0 (8), Bit 4 = B4D04. B4D0 (8), Bit 3 = B4D03. B4D0",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Bit 2 = B4D02. B4D0 (8), Bit 1 = B4D01. B4D0 (8), Bit 0 = B4D00. B4D0 (8), Value on POR, BOR = xxxx xxxx. B4D0 (8), Details on page: = 53, 287. B4DLC (8) Receive mode, Bit 7 = -. B4DLC (8) Receive mode, Bit 6 = RXRTR. B4DLC (8) Receive mode, Bit 5 = RB1. B4DLC (8) Receive mode, Bit 4 = RB0. B4DLC (8) Receive mode, Bit 3 = DLC3. B4DLC (8) Receive mode, Bit 2 = DLC2. B4DLC (8) Receive mode, Bit 1 = DLC1. B4DLC (8) Receive mode, Bit 0 = DLC0. B4DLC (8) Receive mode, Value on POR,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBOR = -xxx xxxx. B4DLC (8) Receive mode, Details on page: = 53, 288. B4DLC (8) Transmit mode, Bit 7 = -. B4DLC (8) Transmit mode, Bit 6 = TXRTR. B4DLC (8) Transmit mode, Bit 5 = -. B4DLC (8) Transmit mode, Bit 4 = -. B4DLC (8) Transmit mode, Bit 3 = DLC3. B4DLC (8) Transmit mode, Bit 2 = DLC2. B4DLC (8) Transmit mode, Bit 1 = DLC1. B4DLC (8) Transmit mode, Bit 0 = DLC0. B4DLC (8) Transmit mode, Value on POR, BOR = -x-- xxxx. B4DLC (8) Transmit mode, Details on page: = 53, 289\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '. See Section 4.4 'Brown-out Reset (BOR)' .\n3: These registers and/or bits are not implemented on PIC18F2X8X devices and are read as ' 0 '. Reset values are shown for PIC18F4X8X devices; individual unimplemented bits should be interpreted as '-'.\n4: The PLLEN bit is only available in specific oscillator configuration; otherwise, it is disabled and reads as ' 0 '. See Section 2.6.4 'PLL in INTOSC Modes' .\n5: The RE3 bit is only available when Master Clear Reset is disabled (CONFIG3H<7> = 0 ); otherwise, RE3 reads as ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n6: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as '0'.\n7: CAN bits have multiple functions depending on the selected mode of the CAN module.\n8: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.\n9: These registers are available on PIC18F4X8X devices only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB4EIDL (8), Bit 7 = EID7. B4EIDL (8), Bit 6 = EID6. B4EIDL (8), Bit 5 = EID5. B4EIDL (8), Bit 4 = EID4. B4EIDL (8), Bit 3 = EID3. B4EIDL (8), Bit 2 = EID2. B4EIDL (8), Bit 1 = EID1. B4EIDL (8), Bit 0 = EID0. B4EIDL (8), Value on POR, BOR = xxxx xxxx. B4EIDL (8), Details on page: = 53, 287. B4EIDH (8), Bit 7 = EID15. B4EIDH (8), Bit 6 = EID14. B4EIDH (8), Bit 5 = EID13. B4EIDH (8), Bit 4 = EID12. B4EIDH (8), Bit 3 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEID11. B4EIDH (8), Bit 2 = EID10. B4EIDH (8), Bit 1 = EID9. B4EIDH (8), Bit 0 = EID8. B4EIDH (8), Value on POR, BOR = xxxx xxxx. B4EIDH (8), Details on page: = 54, 286. B4SIDL (8) Receive mode, Bit 7 = SID2. B4SIDL (8) Receive mode, Bit 6 = SID1. B4SIDL (8) Receive mode, Bit 5 = SID0. B4SIDL (8) Receive mode, Bit 4 = SRR. B4SIDL (8) Receive mode, Bit 3 = EXID. B4SIDL (8) Receive mode, Bit 2 = -. B4SIDL (8) Receive mode, Bit 1 = EID17. B4SIDL (8) Receive mode, Bit 0 = EID16. B4SIDL (8) Receive mode, Value on POR,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBOR = xxxx x-xx. B4SIDL (8) Receive mode, Details on page: = 53, 285. B4SIDL (8) Transmit mode, Bit 7 = SID2. B4SIDL (8) Transmit mode, Bit 6 = SID1. B4SIDL (8) Transmit mode, Bit 5 = SID0. B4SIDL (8) Transmit mode, Bit 4 = -. B4SIDL (8) Transmit mode, Bit 3 = EXIDE. B4SIDL (8) Transmit mode, Bit 2 = -. B4SIDL (8) Transmit mode, Bit 1 = EID17. B4SIDL (8) Transmit mode, Bit 0 = EID16. B4SIDL (8) Transmit mode, Value on POR, BOR = xxx- x-xx. B4SIDL (8) Transmit mode, Details on page: = 53, 285. B4SIDH (8), Bit 7 = SID10. B4SIDH (8), Bit 6 = SID9.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB4SIDH (8), Bit 5 = SID8. B4SIDH (8), Bit 4 = SID7. B4SIDH (8), Bit 3 = SID6. B4SIDH (8), Bit 2 = SID5. B4SIDH (8), Bit 1 = SID4. B4SIDH (8), Bit 0 = SID3. B4SIDH (8), Value on POR, BOR = xxxx xxxx. B4SIDH (8), Details on page: = 54, 284. B4CON (8) Receive mode, Bit 7 = RXFUL. B4CON (8) Receive mode, Bit 6 = RXM1. B4CON (8) Receive mode, Bit 5 = RXRTRRO. B4CON (8) Receive mode, Bit 4 = FILHIT4. B4CON (8) Receive mode, Bit 3 = FILHIT3. B4CON (8) Receive mode, Bit 2 = FILHIT2. B4CON (8) Receive",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nmode, Bit 1 = FILHIT1. B4CON (8) Receive mode, Bit 0 = FILHIT0. B4CON (8) Receive mode, Value on POR, BOR = 0000 0000. B4CON (8) Receive mode, Details on page: = 54, 282. B4CON (8) Transmit mode, Bit 7 = TXBIF. B4CON (8) Transmit mode, Bit 6 = TXABT. B4CON (8) Transmit mode, Bit 5 = TXLARB. B4CON (8) Transmit mode, Bit 4 = TXERR. B4CON (8) Transmit mode, Bit 3 = TXREQ. B4CON (8) Transmit mode, Bit 2 = RTREN. B4CON (8) Transmit mode, Bit 1 = TXPRI1. B4CON (8) Transmit mode, Bit 0 = TXPRI0. B4CON (8) Transmit mode, Value on POR, BOR = 0000 0000. B4CON (8) Transmit mode, Details on page:",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n= 54, 283. B3D7 (8), Bit 7 = B3D77. B3D7 (8), Bit 6 = B3D76. B3D7 (8), Bit 5 = B3D75. B3D7 (8), Bit 4 = B3D74. B3D7 (8), Bit 3 = B3D73. B3D7 (8), Bit 2 = B3D72. B3D7 (8), Bit 1 = B3D71. B3D7 (8), Bit 0 = B3D70. B3D7 (8), Value on POR, BOR = xxxx xxxx. B3D7 (8), Details on page: = 54, 287. B3D6 (8), Bit 7 = B3D67. B3D6 (8), Bit 6 = B3D66. B3D6 (8), Bit 5 = B3D65. B3D6 (8), Bit 4 = B3D64. B3D6 (8), Bit 3 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB3D63. B3D6 (8), Bit 2 = B3D62. B3D6 (8), Bit 1 = B3D61. B3D6 (8), Bit 0 = B3D60. B3D6 (8), Value on POR, BOR = xxxx xxxx. B3D6 (8), Details on page: = 54, 287. B3D5 (8), Bit 7 = B3D57. B3D5 (8), Bit 6 = B3D56. B3D5 (8), Bit 5 = B3D55. B3D5 (8), Bit 4 = B3D54. B3D5 (8), Bit 3 = B3D53. B3D5 (8), Bit 2 = B3D52. B3D5 (8), Bit 1 = B3D51. B3D5 (8), Bit 0 = B3D50. B3D5 (8), Value on POR, BOR = xxxx xxxx. B3D5 (8), Details on page: = 54,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n287. B3D4 (8), Bit 7 = B3D47. B3D4 (8), Bit 6 = B3D46. B3D4 (8), Bit 5 = B3D45. B3D4 (8), Bit 4 = B3D44. B3D4 (8), Bit 3 = B3D43. B3D4 (8), Bit 2 = B3D42. B3D4 (8), Bit 1 = B3D41. B3D4 (8), Bit 0 = B3D40. B3D4 (8), Value on POR, BOR = xxxx xxxx. B3D4 (8), Details on page: = 54, 287. B3D3 (8), Bit 7 = B3D37. B3D3 (8), Bit 6 = B3D36. B3D3 (8), Bit 5 = B3D35. B3D3 (8), Bit 4 = B3D34. B3D3 (8), Bit 3 = B3D33. B3D3 (8), Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB3D32. B3D3 (8), Bit 1 = B3D31. B3D3 (8), Bit 0 = B3D30. B3D3 (8), Value on POR, BOR = xxxx xxxx. B3D3 (8), Details on page: = 54, 287. B3D2 (8), Bit 7 = B3D27. B3D2 (8), Bit 6 = B3D26. B3D2 (8), Bit 5 = B3D25. B3D2 (8), Bit 4 = B3D24. B3D2 (8), Bit 3 = B3D23. B3D2 (8), Bit 2 = B3D22. B3D2 (8), Bit 1 = B3D21. B3D2 (8), Bit 0 = B3D20. B3D2 (8), Value on POR, BOR = xxxx xxxx. B3D2 (8), Details on page: = 54, 287. B3D1 (8), Bit 7 = B3D17.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB3D1 (8), Bit 6 = B3D16. B3D1 (8), Bit 5 = B3D15. B3D1 (8), Bit 4 = B3D14. B3D1 (8), Bit 3 = B3D13. B3D1 (8), Bit 2 = B3D12. B3D1 (8), Bit 1 = B3D11. B3D1 (8), Bit 0 = B3D10. B3D1 (8), Value on POR, BOR = xxxx xxxx. B3D1 (8), Details on page: = 54, 287. B3D0 (8), Bit 7 = B3D07. B3D0 (8), Bit 6 = B3D06. B3D0 (8), Bit 5 = B3D05. B3D0 (8), Bit 4 = B3D04. B3D0 (8), Bit 3 = B3D03. B3D0 (8), Bit 2 = B3D02. B3D0",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Bit 1 = B3D01. B3D0 (8), Bit 0 = B3D00. B3D0 (8), Value on POR, BOR = xxxx xxxx. B3D0 (8), Details on page: = 54, 287. B3DLC (8) Receive mode, Bit 7 = -. B3DLC (8) Receive mode, Bit 6 = RXRTR. B3DLC (8) Receive mode, Bit 5 = RB1. B3DLC (8) Receive mode, Bit 4 = RB0. B3DLC (8) Receive mode, Bit 3 = DLC3. B3DLC (8) Receive mode, Bit 2 = DLC2. B3DLC (8) Receive mode, Bit 1 = DLC1. B3DLC (8) Receive mode, Bit 0 = DLC0. B3DLC (8) Receive mode, Value on POR, BOR = -xxx xxxx. B3DLC (8) Receive mode, Details on page: = 53, 288. B3DLC",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8) Transmit mode, Bit 7 = -. B3DLC (8) Transmit mode, Bit 6 = TXRTR. B3DLC (8) Transmit mode, Bit 5 = -. B3DLC (8) Transmit mode, Bit 4 = -. B3DLC (8) Transmit mode, Bit 3 = DLC3. B3DLC (8) Transmit mode, Bit 2 = DLC2. B3DLC (8) Transmit mode, Bit 1 = DLC1. B3DLC (8) Transmit mode, Bit 0 = DLC0. B3DLC (8) Transmit mode, Value on POR, BOR = -x-- xxxx. B3DLC (8) Transmit mode, Details on page: = 53, 289. B3EIDL (8), Bit 7 = EID7. B3EIDL (8), Bit 6 = EID6. B3EIDL (8), Bit 5 = EID5. B3EIDL (8), Bit 4 = EID4. B3EIDL (8), Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n3 = EID3. B3EIDL (8), Bit 2 = EID2. B3EIDL (8), Bit 1 = EID1. B3EIDL (8), Bit 0 = EID0. B3EIDL (8), Value on POR, BOR = xxxx xxxx. B3EIDL (8), Details on page: = 54, 287. B3EIDH (8), Bit 7 = EID15. B3EIDH (8), Bit 6 = EID14. B3EIDH (8), Bit 5 = EID13. B3EIDH (8), Bit 4 = EID12. B3EIDH (8), Bit 3 = EID11. B3EIDH (8), Bit 2 = EID10. B3EIDH (8), Bit 1 = EID9. B3EIDH (8), Bit 0 = EID8. B3EIDH (8), Value on POR, BOR = xxxx xxxx.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB3EIDH (8), Details on page: = 54, 286. B3SIDL (8) Receive mode, Bit 7 = SID2. B3SIDL (8) Receive mode, Bit 6 = SID1. B3SIDL (8) Receive mode, Bit 5 = SID0. B3SIDL (8) Receive mode, Bit 4 = SRR. B3SIDL (8) Receive mode, Bit 3 = EXID. B3SIDL (8) Receive mode, Bit 2 = -. B3SIDL (8) Receive mode, Bit 1 = EID17. B3SIDL (8) Receive mode, Bit 0 = EID16. B3SIDL (8) Receive mode, Value on POR, BOR = xxxx x-xx. B3SIDL (8) Receive mode, Details on page: = 53, 285. B3SIDL (8) Transmit mode, Bit 7 = SID2. B3SIDL (8) Transmit mode, Bit 6 = SID1. B3SIDL (8) Transmit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nmode, Bit 5 = SID0. B3SIDL (8) Transmit mode, Bit 4 = -. B3SIDL (8) Transmit mode, Bit 3 = EXIDE. B3SIDL (8) Transmit mode, Bit 2 = -. B3SIDL (8) Transmit mode, Bit 1 = EID17. B3SIDL (8) Transmit mode, Bit 0 = EID16. B3SIDL (8) Transmit mode, Value on POR, BOR = xxx- x-xx. B3SIDL (8) Transmit mode, Details on page: = 53, 285. B3SIDH (8), Bit 7 = SID10. B3SIDH (8), Bit 6 = SID9. B3SIDH (8), Bit 5 = SID8. B3SIDH (8), Bit 4 = SID7. B3SIDH (8), Bit 3 = SID6. B3SIDH (8), Bit 2 = SID5. B3SIDH (8), Bit 1 = SID4.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB3SIDH (8), Bit 0 = SID3. B3SIDH (8), Value on POR, BOR = xxxx xxxx. B3SIDH (8), Details on page: = 54, 284. B3CON (8) Receive mode, Bit 7 = RXFUL. B3CON (8) Receive mode, Bit 6 = RXM1. B3CON (8) Receive mode, Bit 5 = RXRTRRO. B3CON (8) Receive mode, Bit 4 = FILHIT4. B3CON (8) Receive mode, Bit 3 = FILHIT3. B3CON (8) Receive mode, Bit 2 = FILHIT2. B3CON (8) Receive mode, Bit 1 = FILHIT1. B3CON (8) Receive mode, Bit 0 = FILHIT0. B3CON (8) Receive mode, Value on POR, BOR = 0000 0000. B3CON (8) Receive mode, Details on page: = 54, 282. B3CON",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8) Transmit mode, Bit 7 = TXBIF. B3CON (8) Transmit mode, Bit 6 = TXABT. B3CON (8) Transmit mode, Bit 5 = TXLARB. B3CON (8) Transmit mode, Bit 4 = TXERR. B3CON (8) Transmit mode, Bit 3 = TXREQ. B3CON (8) Transmit mode, Bit 2 = RTREN. B3CON (8) Transmit mode, Bit 1 = TXPRI1. B3CON (8) Transmit mode, Bit 0 = TXPRI0. B3CON (8) Transmit mode, Value on POR, BOR = 0000 0000. B3CON (8) Transmit mode, Details on page: = 54, 283. B2D7 (8), Bit 7 = B2D77. B2D7 (8), Bit 6 = B2D76. B2D7 (8), Bit 5 = B2D75. B2D7 (8), Bit 4 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB2D74. B2D7 (8), Bit 3 = B2D73. B2D7 (8), Bit 2 = B2D72. B2D7 (8), Bit 1 = B2D71. B2D7 (8), Bit 0 = B2D70. B2D7 (8), Value on POR, BOR = xxxx xxxx. B2D7 (8), Details on page: = 54, 287. B2D6 (8), Bit 7 = B2D67. B2D6 (8), Bit 6 = B2D66. B2D6 (8), Bit 5 = B2D65. B2D6 (8), Bit 4 = B2D64. B2D6 (8), Bit 3 = B2D63. B2D6 (8), Bit 2 = B2D62. B2D6 (8), Bit 1 = B2D61.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB2D6 (8), Bit 0 = B2D60. B2D6 (8), Value on POR, BOR = xxxx xxxx. B2D6 (8), Details on page: = 54, 287. B2D5 (8), Bit 7 = B2D57. B2D5 (8), Bit 6 = B2D56. B2D5 (8), Bit 5 = B2D55. B2D5 (8), Bit 4 = B2D54. B2D5 (8), Bit 3 = B2D53. B2D5 (8), Bit 2 = B2D52. B2D5 (8), Bit 1 = B2D51. B2D5 (8), Bit 0 = B2D50. B2D5 (8), Value on POR, BOR = xxxx xxxx. B2D5 (8), Details on page: = 54, 287. B2D4 (8), Bit 7 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB2D47. B2D4 (8), Bit 6 = B2D46. B2D4 (8), Bit 5 = B2D45. B2D4 (8), Bit 4 = B2D44. B2D4 (8), Bit 3 = B2D43. B2D4 (8), Bit 2 = B2D42. B2D4 (8), Bit 1 = B2D41. B2D4 (8), Bit 0 = B2D40. B2D4 (8), Value on POR, BOR = xxxx xxxx. B2D4 (8), Details on page: = 54, 287. B2D3 (8), Bit 7 = B2D37. B2D3 (8), Bit 6 = B2D36. B2D3 (8), Bit 5 = B2D35. B2D3 (8), Bit 4 = B2D34. B2D3 (8), Bit 3 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB2D33. B2D3 (8), Bit 2 = B2D32. B2D3 (8), Bit 1 = B2D31. B2D3 (8), Bit 0 = B2D30. B2D3 (8), Value on POR, BOR = xxxx xxxx. B2D3 (8), Details on page: = 54, 287. B2D2 (8), Bit 7 = B2D27. B2D2 (8), Bit 6 = B2D26. B2D2 (8), Bit 5 = B2D25. B2D2 (8), Bit 4 = B2D24. B2D2 (8), Bit 3 = B2D23. B2D2 (8), Bit 2 = B2D22. B2D2 (8), Bit 1 = B2D21. B2D2 (8), Bit 0 = B2D20. B2D2 (8), Value on",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nPOR, BOR = xxxx xxxx. B2D2 (8), Details on page: = 54, 287. B2D1 (8), Bit 7 = B2D17. B2D1 (8), Bit 6 = B2D16. B2D1 (8), Bit 5 = B2D15. B2D1 (8), Bit 4 = B2D14. B2D1 (8), Bit 3 = B2D13. B2D1 (8), Bit 2 = B2D12. B2D1 (8), Bit 1 = B2D11. B2D1 (8), Bit 0 = B2D10. B2D1 (8), Value on POR, BOR = xxxx xxxx. B2D1 (8), Details on page: = 54, 287. B2D0 (8), Bit 7 = B2D07. B2D0 (8), Bit 6 = B2D06.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB2D0 (8), Bit 5 = B2D05. B2D0 (8), Bit 4 = B2D04. B2D0 (8), Bit 3 = B2D03. B2D0 (8), Bit 2 = B2D02. B2D0 (8), Bit 1 = B2D01. B2D0 (8), Bit 0 = B2D00. B2D0 (8), Value on POR, BOR = xxxx xxxx. B2D0 (8), Details on page: = 54, 287\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '. See Section 4.4 'Brown-out Reset (BOR)' .\n3: These registers and/or bits are not implemented on PIC18F2X8X devices and are read as ' 0 '. Reset values are shown for PIC18F4X8X devices; individual unimplemented bits should be interpreted as '-'.\n4: The PLLEN bit is only available in specific oscillator configuration; otherwise, it is disabled and reads as ' 0 '. See Section 2.6.4 'PLL in INTOSC Modes' .\n5: The RE3 bit is only available when Master Clear Reset is disabled (CONFIG3H<7> = 0 ); otherwise, RE3 reads as ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n6: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as '0'.\n7: CAN bits have multiple functions depending on the selected mode of the CAN module.\n8: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.\n9: These registers are available on PIC18F4X8X devices only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB2DLC (8) Receive mode, Bit 7 = -. B2DLC (8) Receive mode, Bit 6 = RXRTR. B2DLC (8) Receive mode, Bit 5 = RB1. B2DLC (8) Receive mode, Bit 4 = RB0. B2DLC (8) Receive mode, Bit 3 = DLC3. B2DLC (8) Receive mode, Bit 2 = DLC2. B2DLC (8) Receive mode, Bit 1 = DLC1. B2DLC (8) Receive mode, Bit 0 = DLC0. B2DLC (8) Receive mode, Value on POR, BOR = -xxx xxxx. B2DLC (8) Receive mode, Details on page: = 53, 288. B2DLC (8) Transmit mode, Bit 7 = -. B2DLC (8) Transmit mode, Bit 6 = TXRTR. B2DLC (8) Transmit mode, Bit 5 = -. B2DLC (8)",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTransmit mode, Bit 4 = -. B2DLC (8) Transmit mode, Bit 3 = DLC3. B2DLC (8) Transmit mode, Bit 2 = DLC2. B2DLC (8) Transmit mode, Bit 1 = DLC1. B2DLC (8) Transmit mode, Bit 0 = DLC0. B2DLC (8) Transmit mode, Value on POR, BOR = -x-- xxxx. B2DLC (8) Transmit mode, Details on page: = 53, 289. B2EIDL (8), Bit 7 = EID7. B2EIDL (8), Bit 6 = EID6. B2EIDL (8), Bit 5 = EID5. B2EIDL (8), Bit 4 = EID4. B2EIDL (8), Bit 3 = EID3. B2EIDL (8), Bit 2 = EID2. B2EIDL (8), Bit 1 = EID1. B2EIDL",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Bit 0 = EID0. B2EIDL (8), Value on POR, BOR = xxxx xxxx. B2EIDL (8), Details on page: = 54, 287. B2EIDH (8), Bit 7 = EID15. B2EIDH (8), Bit 6 = EID14. B2EIDH (8), Bit 5 = EID13. B2EIDH (8), Bit 4 = EID12. B2EIDH (8), Bit 3 = EID11. B2EIDH (8), Bit 2 = EID10. B2EIDH (8), Bit 1 = EID9. B2EIDH (8), Bit 0 = EID8. B2EIDH (8), Value on POR, BOR = xxxx xxxx. B2EIDH (8), Details on page: = 54, 286. B2SIDL (8) Receive mode, Bit 7 = SID2. B2SIDL (8) Receive",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nmode, Bit 6 = SID1. B2SIDL (8) Receive mode, Bit 5 = SID0. B2SIDL (8) Receive mode, Bit 4 = SRR. B2SIDL (8) Receive mode, Bit 3 = EXID. B2SIDL (8) Receive mode, Bit 2 = -. B2SIDL (8) Receive mode, Bit 1 = EID17. B2SIDL (8) Receive mode, Bit 0 = EID16. B2SIDL (8) Receive mode, Value on POR, BOR = xxxx x-xx. B2SIDL (8) Receive mode, Details on page: = 53, 285. B2SIDL (8) Transmit mode, Bit 7 = SID2. B2SIDL (8) Transmit mode, Bit 6 = SID1. B2SIDL (8) Transmit mode, Bit 5 = SID0. B2SIDL (8) Transmit mode, Bit 4 = -. B2SIDL (8) Transmit mode, Bit 3 = EXIDE.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB2SIDL (8) Transmit mode, Bit 2 = -. B2SIDL (8) Transmit mode, Bit 1 = EID17. B2SIDL (8) Transmit mode, Bit 0 = EID16. B2SIDL (8) Transmit mode, Value on POR, BOR = xxx- x-xx. B2SIDL (8) Transmit mode, Details on page: = 53, 285. B2SIDH (8), Bit 7 = SID10. B2SIDH (8), Bit 6 = SID9. B2SIDH (8), Bit 5 = SID8. B2SIDH (8), Bit 4 = SID7. B2SIDH (8), Bit 3 = SID6. B2SIDH (8), Bit 2 = SID5. B2SIDH (8), Bit 1 = SID4. B2SIDH (8), Bit 0 = SID3. B2SIDH (8), Value on POR, BOR = xxxx xxxx. B2SIDH",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Details on page: = 54, 284. B2CON (8) Receive mode, Bit 7 = RXFUL. B2CON (8) Receive mode, Bit 6 = RXM1. B2CON (8) Receive mode, Bit 5 = RXRTRRO. B2CON (8) Receive mode, Bit 4 = FILHIT4. B2CON (8) Receive mode, Bit 3 = FILHIT3. B2CON (8) Receive mode, Bit 2 = FILHIT2. B2CON (8) Receive mode, Bit 1 = FILHIT1. B2CON (8) Receive mode, Bit 0 = FILHIT0. B2CON (8) Receive mode, Value on POR, BOR = 0000 0000. B2CON (8) Receive mode, Details on page: = 55, 282. B2CON (8) Transmit mode, Bit 7 = TXBIF. B2CON (8) Transmit mode, Bit 6 = RXM1. B2CON (8) Transmit mode,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 5 = TXLARB. B2CON (8) Transmit mode, Bit 4 = TXERR. B2CON (8) Transmit mode, Bit 3 = TXREQ. B2CON (8) Transmit mode, Bit 2 = RTREN. B2CON (8) Transmit mode, Bit 1 = TXPRI1. B2CON (8) Transmit mode, Bit 0 = TXPRI0. B2CON (8) Transmit mode, Value on POR, BOR = 0000 0000. B2CON (8) Transmit mode, Details on page: = 55, 283. B1D7 (8), Bit 7 = B1D77. B1D7 (8), Bit 6 = B1D76. B1D7 (8), Bit 5 = B1D75. B1D7 (8), Bit 4 = B1D74. B1D7 (8), Bit 3 = B1D73. B1D7 (8), Bit 2 = B1D72. B1D7 (8), Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB1D71. B1D7 (8), Bit 0 = B1D70. B1D7 (8), Value on POR, BOR = xxxx xxxx. B1D7 (8), Details on page: = 55, 287. B1D6 (8), Bit 7 = B1D67. B1D6 (8), Bit 6 = B1D66. B1D6 (8), Bit 5 = B1D65. B1D6 (8), Bit 4 = B1D64. B1D6 (8), Bit 3 = B1D63. B1D6 (8), Bit 2 = B1D62. B1D6 (8), Bit 1 = B1D61. B1D6 (8), Bit 0 = B1D60. B1D6 (8), Value on POR, BOR = xxxx xxxx. B1D6 (8), Details on page: = 55, 287. B1D5 (8), Bit 7 = B1D57. B1D5 (8), Bit 6 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB1D56. B1D5 (8), Bit 5 = B1D55. B1D5 (8), Bit 4 = B1D54. B1D5 (8), Bit 3 = B1D53. B1D5 (8), Bit 2 = B1D52. B1D5 (8), Bit 1 = B1D51. B1D5 (8), Bit 0 = B1D50. B1D5 (8), Value on POR, BOR = xxxx xxxx. B1D5 (8), Details on page: = 55, 287. B1D4 (8), Bit 7 = B1D47. B1D4 (8), Bit 6 = B1D46. B1D4 (8), Bit 5 = B1D45. B1D4 (8), Bit 4 = B1D44. B1D4 (8), Bit 3 = B1D43. B1D4 (8), Bit 2 = B1D42. B1D4 (8), Bit 1 = B1D41. B1D4 (8), Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n0 = B1D40. B1D4 (8), Value on POR, BOR = xxxx xxxx. B1D4 (8), Details on page: = 55, 287. B1D3 (8), Bit 7 = B1D37. B1D3 (8), Bit 6 = B1D36. B1D3 (8), Bit 5 = B1D35. B1D3 (8), Bit 4 = B1D34. B1D3 (8), Bit 3 = B1D33. B1D3 (8), Bit 2 = B1D32. B1D3 (8), Bit 1 = B1D31. B1D3 (8), Bit 0 = B1D30. B1D3 (8), Value on POR, BOR = xxxx xxxx. B1D3 (8), Details on page: = 55, 287. B1D2 (8), Bit 7 = B1D27. B1D2 (8), Bit 6 = B1D26. B1D2 (8), Bit 5 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB1D25. B1D2 (8), Bit 4 = B1D24. B1D2 (8), Bit 3 = B1D23. B1D2 (8), Bit 2 = B1D22. B1D2 (8), Bit 1 = B1D21. B1D2 (8), Bit 0 = B1D20. B1D2 (8), Value on POR, BOR = xxxx xxxx. B1D2 (8), Details on page: = 55, 287. B1D1 (8), Bit 7 = B1D17. B1D1 (8), Bit 6 = B1D16. B1D1 (8), Bit 5 = B1D15. B1D1 (8), Bit 4 = B1D14. B1D1 (8), Bit 3 = B1D13. B1D1 (8), Bit 2 = B1D12. B1D1 (8), Bit 1 = B1D11. B1D1 (8), Bit 0 = B1D10. B1D1 (8), Value",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\non POR, BOR = xxxx xxxx. B1D1 (8), Details on page: = 55, 287. B1D0 (8), Bit 7 = B1D07. B1D0 (8), Bit 6 = B1D06. B1D0 (8), Bit 5 = B1D05. B1D0 (8), Bit 4 = B1D04. B1D0 (8), Bit 3 = B1D03. B1D0 (8), Bit 2 = B1D02. B1D0 (8), Bit 1 = B1D01. B1D0 (8), Bit 0 = B1D00. B1D0 (8), Value on POR, BOR = xxxx xxxx. B1D0 (8), Details on page: = 55, 287. B1DLC (8) Receive mode, Bit 7 = -. B1DLC (8) Receive mode, Bit 6 = RXRTR. B1DLC (8) Receive mode, Bit 5 = RB1. B1DLC",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8) Receive mode, Bit 4 = RB0. B1DLC (8) Receive mode, Bit 3 = DLC3. B1DLC (8) Receive mode, Bit 2 = DLC2. B1DLC (8) Receive mode, Bit 1 = DLC1. B1DLC (8) Receive mode, Bit 0 = DLC0. B1DLC (8) Receive mode, Value on POR, BOR = -xxx xxxx. B1DLC (8) Receive mode, Details on page: = 53, 288. B1DLC (8) Transmit mode, Bit 7 = -. B1DLC (8) Transmit mode, Bit 6 = TXRTR. B1DLC (8) Transmit mode, Bit 5 = -. B1DLC (8) Transmit mode, Bit 4 = -. B1DLC (8) Transmit mode, Bit 3 = DLC3. B1DLC (8) Transmit mode, Bit 2 = DLC2. B1DLC (8) Transmit mode, Bit 1 = DLC1. B1DLC (8) Transmit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nmode, Bit 0 = DLC0. B1DLC (8) Transmit mode, Value on POR, BOR = -x-- xxxx. B1DLC (8) Transmit mode, Details on page: = 53, 289. B1EIDL (8), Bit 7 = EID7. B1EIDL (8), Bit 6 = EID6. B1EIDL (8), Bit 5 = EID5. B1EIDL (8), Bit 4 = EID4. B1EIDL (8), Bit 3 = EID3. B1EIDL (8), Bit 2 = EID2. B1EIDL (8), Bit 1 = EID1. B1EIDL (8), Bit 0 = EID0. B1EIDL (8), Value on POR, BOR = xxxx xxxx. B1EIDL (8), Details on page: = 55, 287. B1EIDH (8), Bit 7 = EID15. B1EIDH (8), Bit 6 = EID14. B1EIDH",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Bit 5 = EID13. B1EIDH (8), Bit 4 = EID12. B1EIDH (8), Bit 3 = EID11. B1EIDH (8), Bit 2 = EID10. B1EIDH (8), Bit 1 = EID9. B1EIDH (8), Bit 0 = EID8. B1EIDH (8), Value on POR, BOR = xxxx xxxx. B1EIDH (8), Details on page: = 55, 286. B1SIDL (8) Receive mode, Bit 7 = SID2. B1SIDL (8) Receive mode, Bit 6 = SID1. B1SIDL (8) Receive mode, Bit 5 = SID0. B1SIDL (8) Receive mode, Bit 4 = SRR. B1SIDL (8) Receive mode, Bit 3 = EXID. B1SIDL (8) Receive mode, Bit 2 = -. B1SIDL (8) Receive mode, Bit 1 = EID17. B1SIDL (8) Receive",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nmode, Bit 0 = EID16. B1SIDL (8) Receive mode, Value on POR, BOR = xxxx x-xx. B1SIDL (8) Receive mode, Details on page: = 53, 285. B1SIDL (8) Transmit mode, Bit 7 = SID2. B1SIDL (8) Transmit mode, Bit 6 = SID1. B1SIDL (8) Transmit mode, Bit 5 = SID0. B1SIDL (8) Transmit mode, Bit 4 = -. B1SIDL (8) Transmit mode, Bit 3 = EXIDE. B1SIDL (8) Transmit mode, Bit 2 = -. B1SIDL (8) Transmit mode, Bit 1 = EID17. B1SIDL (8) Transmit mode, Bit 0 = EID16. B1SIDL (8) Transmit mode, Value on POR, BOR = xxx- x-xx. B1SIDL (8) Transmit mode, Details on page: = 53, 285. B1SIDH (8), Bit 7 = SID10. B1SIDH",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Bit 6 = SID9. B1SIDH (8), Bit 5 = SID8. B1SIDH (8), Bit 4 = SID7. B1SIDH (8), Bit 3 = SID6. B1SIDH (8), Bit 2 = SID5. B1SIDH (8), Bit 1 = SID4. B1SIDH (8), Bit 0 = SID3. B1SIDH (8), Value on POR, BOR = xxxx xxxx. B1SIDH (8), Details on page: = 55, 284. B1CON (8) Receive mode, Bit 7 = RXFUL. B1CON (8) Receive mode, Bit 6 = RXM1. B1CON (8) Receive mode, Bit 5 = RXRTRRO. B1CON (8) Receive mode, Bit 4 = FILHIT4. B1CON (8) Receive mode, Bit 3 = FILHIT3. B1CON (8) Receive mode, Bit 2 = FILHIT2. B1CON (8) Receive mode, Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nFILHIT1. B1CON (8) Receive mode, Bit 0 = FILHIT0. B1CON (8) Receive mode, Value on POR, BOR = 0000 0000. B1CON (8) Receive mode, Details on page: = 55, 283. B1CON (8) Transmit mode, Bit 7 = TXBIF. B1CON (8) Transmit mode, Bit 6 = TXABT. B1CON (8) Transmit mode, Bit 5 = TXLARB. B1CON (8) Transmit mode, Bit 4 = TXERR. B1CON (8) Transmit mode, Bit 3 = TXREQ. B1CON (8) Transmit mode, Bit 2 = RTREN. B1CON (8) Transmit mode, Bit 1 = TXPRI1. B1CON (8) Transmit mode, Bit 0 = TXPRI0. B1CON (8) Transmit mode, Value on POR, BOR = 0000 0000. B1CON (8) Transmit mode, Details on page: = 55, 283. B0D7 (8), Bit 7 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB0D77. B0D7 (8), Bit 6 = B0D76. B0D7 (8), Bit 5 = B0D75. B0D7 (8), Bit 4 = B0D74. B0D7 (8), Bit 3 = B0D73. B0D7 (8), Bit 2 = B0D72. B0D7 (8), Bit 1 = B0D71. B0D7 (8), Bit 0 = B0D70. B0D7 (8), Value on POR, BOR = xxxx xxxx. B0D7 (8), Details on page: = 55, 287. B0D6 (8), Bit 7 = B0D67. B0D6 (8), Bit 6 = B0D66. B0D6 (8), Bit 5 = B0D65. B0D6 (8), Bit 4 = B0D64. B0D6",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Bit 3 = B0D63. B0D6 (8), Bit 2 = B0D62. B0D6 (8), Bit 1 = B0D61. B0D6 (8), Bit 0 = B0D60. B0D6 (8), Value on POR, BOR = xxxx xxxx. B0D6 (8), Details on page: = 55, 287. B0D5 (8), Bit 7 = B0D57. B0D5 (8), Bit 6 = B0D56. B0D5 (8), Bit 5 = B0D55. B0D5 (8), Bit 4 = B0D54. B0D5 (8), Bit 3 = B0D53. B0D5 (8), Bit 2 = B0D52. B0D5 (8), Bit 1 = B0D51. B0D5 (8), Bit 0 = B0D50.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB0D5 (8), Value on POR, BOR = xxxx xxxx. B0D5 (8), Details on page: = 55, 287. B0D4 (8), Bit 7 = B0D47. B0D4 (8), Bit 6 = B0D46. B0D4 (8), Bit 5 = B0D45. B0D4 (8), Bit 4 = B0D44. B0D4 (8), Bit 3 = B0D43. B0D4 (8), Bit 2 = B0D42. B0D4 (8), Bit 1 = B0D41. B0D4 (8), Bit 0 = B0D40. B0D4 (8), Value on POR, BOR = xxxx xxxx. B0D4 (8), Details on page: = 55, 287. B0D3 (8), Bit 7 = B0D37. B0D3 (8), Bit 6 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB0D36. B0D3 (8), Bit 5 = B0D35. B0D3 (8), Bit 4 = B0D34. B0D3 (8), Bit 3 = B0D33. B0D3 (8), Bit 2 = B0D32. B0D3 (8), Bit 1 = B0D31. B0D3 (8), Bit 0 = B0D30. B0D3 (8), Value on POR, BOR = xxxx xxxx. B0D3 (8), Details on page: = 55, 287. B0D2 (8), Bit 7 = B0D27. B0D2 (8), Bit 6 = B0D26. B0D2 (8), Bit 5 = B0D25. B0D2 (8), Bit 4 = B0D24. B0D2 (8), Bit 3 = B0D23. B0D2 (8), Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB0D22. B0D2 (8), Bit 1 = B0D21. B0D2 (8), Bit 0 = B0D20. B0D2 (8), Value on POR, BOR = xxxx xxxx. B0D2 (8), Details on page: = 55, 287. B0D1 (8), Bit 7 = B0D17. B0D1 (8), Bit 6 = B0D16. B0D1 (8), Bit 5 = B0D15. B0D1 (8), Bit 4 = B0D14. B0D1 (8), Bit 3 = B0D13. B0D1 (8), Bit 2 = B0D12. B0D1 (8), Bit 1 = B0D11. B0D1 (8), Bit 0 = B0D10. B0D1 (8), Value on POR, BOR = xxxx xxxx. B0D1",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Details on page: = 55, 287. B0D0 (8), Bit 7 = B0D07. B0D0 (8), Bit 6 = B0D06. B0D0 (8), Bit 5 = B0D05. B0D0 (8), Bit 4 = B0D04. B0D0 (8), Bit 3 = B0D03. B0D0 (8), Bit 2 = B0D02. B0D0 (8), Bit 1 = B0D01. B0D0 (8), Bit 0 = B0D00. B0D0 (8), Value on POR, BOR = xxxx xxxx. B0D0 (8), Details on page: = 55, 287\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '. See Section 4.4 'Brown-out Reset (BOR)' .\n3: These registers and/or bits are not implemented on PIC18F2X8X devices and are read as ' 0 '. Reset values are shown for PIC18F4X8X devices; individual unimplemented bits should be interpreted as '-'.\n4: The PLLEN bit is only available in specific oscillator configuration; otherwise, it is disabled and reads as ' 0 '. See Section 2.6.4 'PLL in INTOSC Modes' .\n5: The RE3 bit is only available when Master Clear Reset is disabled (CONFIG3H<7> = 0 ); otherwise, RE3 reads as ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n6: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as '0'.\n7: CAN bits have multiple functions depending on the selected mode of the CAN module.\n8: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.\n9: These registers are available on PIC18F4X8X devices only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB0DLC (8) Receive mode, Bit 7 = -. B0DLC (8) Receive mode, Bit 6 = RXRTR. B0DLC (8) Receive mode, Bit 5 = RB1. B0DLC (8) Receive mode, Bit 4 = RB0. B0DLC (8) Receive mode, Bit 3 = DLC3. B0DLC (8) Receive mode, Bit 2 = DLC2. B0DLC (8) Receive mode, Bit 1 = DLC1. B0DLC (8) Receive mode, Bit 0 = DLC0. B0DLC (8) Receive mode, Value on POR, BOR = -xxx xxxx. B0DLC (8) Receive mode, Details on page: = 53, 288. B0DLC (8) Transmit mode, Bit 7 = -. B0DLC (8) Transmit mode, Bit 6 = TXRTR. B0DLC (8) Transmit mode, Bit 5 = -. B0DLC (8)",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nTransmit mode, Bit 4 = -. B0DLC (8) Transmit mode, Bit 3 = DLC3. B0DLC (8) Transmit mode, Bit 2 = DLC2. B0DLC (8) Transmit mode, Bit 1 = DLC1. B0DLC (8) Transmit mode, Bit 0 = DLC0. B0DLC (8) Transmit mode, Value on POR, BOR = -x-- xxxx. B0DLC (8) Transmit mode, Details on page: = 53, 289. B0EIDL (8), Bit 7 = EID7. B0EIDL (8), Bit 6 = EID6. B0EIDL (8), Bit 5 = EID5. B0EIDL (8), Bit 4 = EID4. B0EIDL (8), Bit 3 = EID3. B0EIDL (8), Bit 2 = EID2. B0EIDL (8), Bit 1 = EID1. B0EIDL",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Bit 0 = EID0. B0EIDL (8), Value on POR, BOR = xxxx xxxx. B0EIDL (8), Details on page: = 55, 287. B0EIDH (8), Bit 7 = EID15. B0EIDH (8), Bit 6 = EID14. B0EIDH (8), Bit 5 = EID13. B0EIDH (8), Bit 4 = EID12. B0EIDH (8), Bit 3 = EID11. B0EIDH (8), Bit 2 = EID10. B0EIDH (8), Bit 1 = EID9. B0EIDH (8), Bit 0 = EID8. B0EIDH (8), Value on POR, BOR = xxxx xxxx. B0EIDH (8), Details on page: = 55, 286. B0SIDL (8) Receive mode, Bit 7 = SID2. B0SIDL (8) Receive",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nmode, Bit 6 = SID1. B0SIDL (8) Receive mode, Bit 5 = SID0. B0SIDL (8) Receive mode, Bit 4 = SRR. B0SIDL (8) Receive mode, Bit 3 = EXID. B0SIDL (8) Receive mode, Bit 2 = -. B0SIDL (8) Receive mode, Bit 1 = EID17. B0SIDL (8) Receive mode, Bit 0 = EID16. B0SIDL (8) Receive mode, Value on POR, BOR = xxxx x-xx. B0SIDL (8) Receive mode, Details on page: = 53, 285. B0SIDL (8) Transmit mode, Bit 7 = SID2. B0SIDL (8) Transmit mode, Bit 6 = SID1. B0SIDL (8) Transmit mode, Bit 5 = SID0. B0SIDL (8) Transmit mode, Bit 4 = -. B0SIDL (8) Transmit mode, Bit 3 = EXIDE.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nB0SIDL (8) Transmit mode, Bit 2 = -. B0SIDL (8) Transmit mode, Bit 1 = EID17. B0SIDL (8) Transmit mode, Bit 0 = EID16. B0SIDL (8) Transmit mode, Value on POR, BOR = xxx- x-xx. B0SIDL (8) Transmit mode, Details on page: = 53, 285. B0SIDH (8), Bit 7 = SID10. B0SIDH (8), Bit 6 = SID9. B0SIDH (8), Bit 5 = SID8. B0SIDH (8), Bit 4 = SID7. B0SIDH (8), Bit 3 = SID6. B0SIDH (8), Bit 2 = SID5. B0SIDH (8), Bit 1 = SID4. B0SIDH (8), Bit 0 = SID3. B0SIDH (8), Value on POR, BOR = xxxx xxxx. B0SIDH",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n(8), Details on page: = 55, 284. B0CON (8) Receive mode, Bit 7 = RXFUL. B0CON (8) Receive mode, Bit 6 = RXM1. B0CON (8) Receive mode, Bit 5 = RXRTRRO. B0CON (8) Receive mode, Bit 4 = FILHIT4. B0CON (8) Receive mode, Bit 3 = FILHIT3. B0CON (8) Receive mode, Bit 2 = FILHIT2. B0CON (8) Receive mode, Bit 1 = FILHIT1. B0CON (8) Receive mode, Bit 0 = FILHIT0. B0CON (8) Receive mode, Value on POR, BOR = 0000 0000. B0CON (8) Receive mode, Details on page: = 55, 283. B0CON (8) Transmit mode, Bit 7 = TXBIF. B0CON (8) Transmit mode, Bit 6 = TXABT. B0CON (8) Transmit mode, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n5 = TXLARB. B0CON (8) Transmit mode, Bit 4 = TXERR. B0CON (8) Transmit mode, Bit 3 = TXREQ. B0CON (8) Transmit mode, Bit 2 = RTREN. B0CON (8) Transmit mode, Bit 1 = TXPRI1. B0CON (8) Transmit mode, Bit 0 = TXPRI0. B0CON (8) Transmit mode, Value on POR, BOR = 0000 0000. B0CON (8) Transmit mode, Details on page: = 55, 283. TXBIE, Bit 7 = -. TXBIE, Bit 6 = -. TXBIE, Bit 5 = -. TXBIE, Bit 4 = TXB2IE. TXBIE, Bit 3 = TXB1IE. TXBIE, Bit 2 = TXB0IE. TXBIE, Bit 1 = -. TXBIE, Bit 0 = -. TXBIE, Value on POR, BOR = ---0 00--. TXBIE, Details on page: = 55, 306.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBIE0, Bit 7 = B5IE. BIE0, Bit 6 = B4IE. BIE0, Bit 5 = B3IE. BIE0, Bit 4 = B2IE. BIE0, Bit 3 = B1IE. BIE0, Bit 2 = B0IE. BIE0, Bit 1 = RXB1IE. BIE0, Bit 0 = RXB0IE. BIE0, Value on POR, BOR = 0000 0000. BIE0, Details on page: = 55, 306. BSEL0, Bit 7 = B5TXEN. BSEL0, Bit 6 = B4TXEN. BSEL0, Bit 5 = B3TXEN. BSEL0, Bit 4 = B2TXEN. BSEL0, Bit 3 = B1TXEN. BSEL0, Bit 2 = B0TXEN. BSEL0, Bit 1 = -. BSEL0, Bit 0 = -. BSEL0, Value on POR, BOR = 0000",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n00--. BSEL0, Details on page: = 56, 289. MSEL3, Bit 7 = FIL15_1. MSEL3, Bit 6 = FIL15_0. MSEL3, Bit 5 = FIL14_1. MSEL3, Bit 4 = FIL14_0. MSEL3, Bit 3 = FIL13_1. MSEL3, Bit 2 = FIL13_0. MSEL3, Bit 1 = FIL12_1. MSEL3, Bit 0 = FIL12_0. MSEL3, Value on POR, BOR = 0000 0000. MSEL3, Details on page: = 56, 298. MSEL2, Bit 7 = FIL11_1. MSEL2, Bit 6 = FIL11_0. MSEL2, Bit 5 = FIL10_1. MSEL2, Bit 4 = FIL10_0. MSEL2, Bit 3 = FIL9_1. MSEL2, Bit 2 = FIL9_0.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nMSEL2, Bit 1 = FIL8_1. MSEL2, Bit 0 = FIL8_0. MSEL2, Value on POR, BOR = 0000 0000. MSEL2, Details on page: = 56, 297. MSEL1, Bit 7 = FIL7_1. MSEL1, Bit 6 = FIL7_0. MSEL1, Bit 5 = FIL6_1. MSEL1, Bit 4 = FIL6_0. MSEL1, Bit 3 = FIL5_1. MSEL1, Bit 2 = FIL5_0. MSEL1, Bit 1 = FIL4_1. MSEL1, Bit 0 = FIL4_0. MSEL1, Value on POR, BOR = 0000 0101. MSEL1, Details on page: = 56, 296. MSEL0, Bit 7 = FIL3_1. MSEL0, Bit 6 = FIL3_0. MSEL0, Bit 5 = FIL2_1.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nMSEL0, Bit 4 = FIL2_0. MSEL0, Bit 3 = FIL1_1. MSEL0, Bit 2 = FIL1_0. MSEL0, Bit 1 = FIL0_1. MSEL0, Bit 0 = FIL0_0. MSEL0, Value on POR, BOR = 0101 0000. MSEL0, Details on page: = 56, 295. RXFBCON7, Bit 7 = F15BP_3. RXFBCON7, Bit 6 = F15BP_2. RXFBCON7, Bit 5 = F15BP_1. RXFBCON7, Bit 4 = F15BP_0. RXFBCON7, Bit 3 = F14BP_3. RXFBCON7, Bit 2 = F14BP_2. RXFBCON7, Bit 1 = F14BP_1. RXFBCON7, Bit 0 = F14BP_0. RXFBCON7, Value",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\non POR, BOR = 0000 0000. RXFBCON7, Details on page: = 56, 293. RXFBCON6, Bit 7 = F13BP_3. RXFBCON6, Bit 6 = F13BP_2. RXFBCON6, Bit 5 = F13BP_1. RXFBCON6, Bit 4 = F13BP_0. RXFBCON6, Bit 3 = F12BP_3. RXFBCON6, Bit 2 = F12BP_2. RXFBCON6, Bit 1 = F12BP_1. RXFBCON6, Bit 0 = F12BP_0. RXFBCON6, Value on POR, BOR = 0000 0000. RXFBCON6, Details on page: = 56, 293. RXFBCON5, Bit 7 = F11BP_3. RXFBCON5, Bit 6 = F11BP_2. RXFBCON5, Bit 5 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nF11BP_1. RXFBCON5, Bit 4 = F11BP_0. RXFBCON5, Bit 3 = F10BP_3. RXFBCON5, Bit 2 = F10BP_2. RXFBCON5, Bit 1 = F10BP_1. RXFBCON5, Bit 0 = F10BP_0. RXFBCON5, Value on POR, BOR = 0000 0000. RXFBCON5, Details on page: = 56, 293. RXFBCON4, Bit 7 = F9BP_3. RXFBCON4, Bit 6 = F9BP_2. RXFBCON4, Bit 5 = F9BP_1. RXFBCON4, Bit 4 = F9BP_0. RXFBCON4, Bit 3 = F8BP_3. RXFBCON4, Bit 2 = F8BP_2. RXFBCON4, Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nF8BP_1. RXFBCON4, Bit 0 = F8BP_0. RXFBCON4, Value on POR, BOR = 0000 0000. RXFBCON4, Details on page: = 56, 293. RXFBCON3, Bit 7 = F7BP_3. RXFBCON3, Bit 6 = F7BP_2. RXFBCON3, Bit 5 = F7BP_1. RXFBCON3, Bit 4 = F7BP_0. RXFBCON3, Bit 3 = F6BP_3. RXFBCON3, Bit 2 = F6BP_2. RXFBCON3, Bit 1 = F6BP_1. RXFBCON3, Bit 0 = F6BP_0. RXFBCON3, Value on POR, BOR = 0000 0000. RXFBCON3, Details on page: = 56, 293. RXFBCON2, Bit 7 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nF5BP_3. RXFBCON2, Bit 6 = F5BP_2. RXFBCON2, Bit 5 = F5BP_1. RXFBCON2, Bit 4 = F5BP_0. RXFBCON2, Bit 3 = F4BP_3. RXFBCON2, Bit 2 = F4BP_2. RXFBCON2, Bit 1 = F4BP_1. RXFBCON2, Bit 0 = F4BP_0. RXFBCON2, Value on POR, BOR = 0001 0001. RXFBCON2, Details on page: = 56, 293. RXFBCON1, Bit 7 = F3BP_3. RXFBCON1, Bit 6 = F3BP_2. RXFBCON1, Bit 5 = F3BP_1. RXFBCON1, Bit 4 = F3BP_0. RXFBCON1, Bit 3 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nF2BP_3. RXFBCON1, Bit 2 = F2BP_2. RXFBCON1, Bit 1 = F2BP_1. RXFBCON1, Bit 0 = F2BP_0. RXFBCON1, Value on POR, BOR = 0001 0001. RXFBCON1, Details on page: = 56, 293. RXFBCON0, Bit 7 = F1BP_3. RXFBCON0, Bit 6 = F1BP_2. RXFBCON0, Bit 5 = F1BP_1. RXFBCON0, Bit 4 = F1BP_0. RXFBCON0, Bit 3 = F0BP_3. RXFBCON0, Bit 2 = F0BP_2. RXFBCON0, Bit 1 = F0BP_1. RXFBCON0, Bit 0 = F0BP_0. RXFBCON0, Value on POR, BOR = 0000",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n0000. RXFBCON0, Details on page: = 56, 293. SDFLC, Bit 7 = -. SDFLC, Bit 6 = -. SDFLC, Bit 5 = -. SDFLC, Bit 4 = FLC4. SDFLC, Bit 3 = FLC3. SDFLC, Bit 2 = FLC2. SDFLC, Bit 1 = FLC1. SDFLC, Bit 0 = FLC0. SDFLC, Value on POR, BOR = ---0 0000. SDFLC, Details on page: = 56, 293. RXFCON1, Bit 7 = RXF15EN. RXFCON1, Bit 6 = RXF14EN. RXFCON1, Bit 5 = RXF13EN. RXFCON1, Bit 4 = RXF12EN. RXFCON1, Bit 3 = RXF11EN. RXFCON1, Bit 2 = RXF10EN. RXFCON1, Bit 1",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n= RXF9EN. RXFCON1, Bit 0 = RXF8EN. RXFCON1, Value on POR, BOR = 0000 0000. RXFCON1, Details on page: = 56, 294. RXFCON0, Bit 7 = RXF7EN. RXFCON0, Bit 6 = RXF6EN. RXFCON0, Bit 5 = RXF5EN. RXFCON0, Bit 4 = RXF4EN. RXFCON0, Bit 3 = RXF3EN. RXFCON0, Bit 2 = RXF2EN. RXFCON0, Bit 1 = RXF1EN. RXFCON0, Bit 0 = RXF0EN. RXFCON0, Value on POR, BOR = 0000 0000. RXFCON0, Details on page: = 56, 293. RXF15EIDL, Bit 7 = EID7. RXF15EIDL,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 6 = EID6. RXF15EIDL, Bit 5 = EID5. RXF15EIDL, Bit 4 = EID4. RXF15EIDL, Bit 3 = EID3. RXF15EIDL, Bit 2 = EID2. RXF15EIDL, Bit 1 = EID1. RXF15EIDL, Bit 0 = EID0. RXF15EIDL, Value on POR, BOR = xxxx xxxx. RXF15EIDL, Details on page: = 56, 291. RXF15EIDH, Bit 7 = EID15. RXF15EIDH, Bit 6 = EID14. RXF15EIDH, Bit 5 = EID13. RXF15EIDH, Bit 4 = EID12. RXF15EIDH, Bit 3 = EID11. RXF15EIDH, Bit 2 = EID10. RXF15EIDH, Bit 1 = EID9.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF15EIDH, Bit 0 = EID8. RXF15EIDH, Value on POR, BOR = xxxx xxxx. RXF15EIDH, Details on page: = 56, 291. RXF15SIDL, Bit 7 = SID2. RXF15SIDL, Bit 6 = SID1. RXF15SIDL, Bit 5 = SID0. RXF15SIDL, Bit 4 = -. RXF15SIDL, Bit 3 = EXIDEN. RXF15SIDL, Bit 2 = -. RXF15SIDL, Bit 1 = EID17. RXF15SIDL, Bit 0 = EID16. RXF15SIDL, Value on POR, BOR = xxx- x-xx. RXF15SIDL, Details on page: = 56, 292. RXF15SIDH, Bit 7 = SID10. RXF15SIDH, Bit 6 = SID9. RXF15SIDH, Bit 5 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nSID8. RXF15SIDH, Bit 4 = SID7. RXF15SIDH, Bit 3 = SID6. RXF15SIDH, Bit 2 = SID5. RXF15SIDH, Bit 1 = SID4. RXF15SIDH, Bit 0 = SID3. RXF15SIDH, Value on POR, BOR = xxxx xxxx. RXF15SIDH, Details on page: = 56, 291. RXF14EIDL, Bit 7 = EID7. RXF14EIDL, Bit 6 = EID6. RXF14EIDL, Bit 5 = EID5. RXF14EIDL, Bit 4 = EID4. RXF14EIDL, Bit 3 = EID3. RXF14EIDL, Bit 2 = EID2. RXF14EIDL, Bit 1 = EID1. RXF14EIDL, Bit 0 = EID0. RXF14EIDL, Value on POR, BOR =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nxxxx xxxx. RXF14EIDL, Details on page: = 56, 291. RXF14EIDH, Bit 7 = EID15. RXF14EIDH, Bit 6 = EID14. RXF14EIDH, Bit 5 = EID13. RXF14EIDH, Bit 4 = EID12. RXF14EIDH, Bit 3 = EID11. RXF14EIDH, Bit 2 = EID10. RXF14EIDH, Bit 1 = EID9. RXF14EIDH, Bit 0 = EID8. RXF14EIDH, Value on POR, BOR = xxxx xxxx. RXF14EIDH, Details on page: = 56, 291. RXF14SIDL, Bit 7 = SID2. RXF14SIDL, Bit 6 = SID1. RXF14SIDL, Bit 5 = SID0. RXF14SIDL, Bit 4 = -. RXF14SIDL, Bit 3 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEXIDEN. RXF14SIDL, Bit 2 = -. RXF14SIDL, Bit 1 = EID17. RXF14SIDL, Bit 0 = EID16. RXF14SIDL, Value on POR, BOR = xxx- x-xx. RXF14SIDL, Details on page: = 56, 292. RXF14SIDH, Bit 7 = SID10. RXF14SIDH, Bit 6 = SID9. RXF14SIDH, Bit 5 = SID8. RXF14SIDH, Bit 4 = SID7. RXF14SIDH, Bit 3 = SID6. RXF14SIDH, Bit 2 = SID5. RXF14SIDH, Bit 1 = SID4. RXF14SIDH, Bit 0 = SID3. RXF14SIDH, Value on POR, BOR = xxxx xxxx. RXF14SIDH, Details on page: = 56, 291. RXF13EIDL, Bit 7",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n= EID7. RXF13EIDL, Bit 6 = EID6. RXF13EIDL, Bit 5 = EID5. RXF13EIDL, Bit 4 = EID4 EID12. RXF13EIDL, Bit 3 = EID3. RXF13EIDL, Bit 2 = EID2. RXF13EIDL, Bit 1 = EID1. RXF13EIDL, Bit 0 = EID0. RXF13EIDL, Value on POR, BOR = xxxx xxxx. RXF13EIDL, Details on page: = 56, 291. RXF13EIDH, Bit 7 = EID15. RXF13EIDH, Bit 6 = EID14. RXF13EIDH, Bit 5 = EID13. RXF13EIDH, Bit 4 = . RXF13EIDH, Bit 3 = EID11. RXF13EIDH, Bit 2 = EID10. RXF13EIDH,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 1 = EID9. RXF13EIDH, Bit 0 = EID8. RXF13EIDH, Value on POR, BOR = xxxx xxxx. RXF13EIDH, Details on page: = 56, 291\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '. See Section 4.4 'Brown-out Reset (BOR)' .\n3: These registers and/or bits are not implemented on PIC18F2X8X devices and are read as ' 0 '. Reset values are shown for PIC18F4X8X devices; individual unimplemented bits should be interpreted as '-'.\n4: The PLLEN bit is only available in specific oscillator configuration; otherwise, it is disabled and reads as ' 0 '. See Section 2.6.4 'PLL in INTOSC Modes' .\n5: The RE3 bit is only available when Master Clear Reset is disabled (CONFIG3H<7> = 0 ); otherwise, RE3 reads as ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n6: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as '0'.\n7: CAN bits have multiple functions depending on the selected mode of the CAN module.\n8: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.\n9: These registers are available on PIC18F4X8X devices only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF13SIDL, Bit 7 = SID2. RXF13SIDL, Bit 6 = SID1. RXF13SIDL, Bit 5 = SID0. RXF13SIDL, Bit 4 = -. RXF13SIDL, Bit 3 = EXIDEN. RXF13SIDL, Bit 2 = -. RXF13SIDL, Bit 1 = EID17. RXF13SIDL, Bit 0 = EID16. RXF13SIDL, Value on POR, BOR = xxx- x-xx. RXF13SIDL, Details on page: = 56, 292. RXF13SIDH, Bit 7 = SID10. RXF13SIDH, Bit 6 = SID9. RXF13SIDH, Bit 5 = SID8. RXF13SIDH, Bit 4 = SID7. RXF13SIDH, Bit 3 = SID6. RXF13SIDH, Bit 2 = SID5. RXF13SIDH, Bit 1",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n= SID4. RXF13SIDH, Bit 0 = SID3. RXF13SIDH, Value on POR, BOR = xxxx xxxx. RXF13SIDH, Details on page: = 56, 291. RXF12EIDL, Bit 7 = EID7. RXF12EIDL, Bit 6 = EID6. RXF12EIDL, Bit 5 = EID5. RXF12EIDL, Bit 4 = EID4. RXF12EIDL, Bit 3 = EID3. RXF12EIDL, Bit 2 = EID2. RXF12EIDL, Bit 1 = EID1. RXF12EIDL, Bit 0 = EID0. RXF12EIDL, Value on POR, BOR = xxxx xxxx. RXF12EIDL, Details on page: = 56, 291. RXF12EIDH, Bit 7 = EID15. RXF12EIDH, Bit 6 = EID14.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF12EIDH, Bit 5 = EID13. RXF12EIDH, Bit 4 = EID12. RXF12EIDH, Bit 3 = EID11. RXF12EIDH, Bit 2 = EID10. RXF12EIDH, Bit 1 = EID9. RXF12EIDH, Bit 0 = EID8. RXF12EIDH, Value on POR, BOR = xxxx xxxx. RXF12EIDH, Details on page: = 56, 291. RXF12SIDL, Bit 7 = SID2. RXF12SIDL, Bit 6 = SID1. RXF12SIDL, Bit 5 = SID0. RXF12SIDL, Bit 4 = -. RXF12SIDL, Bit 3 = EXIDEN. RXF12SIDL, Bit 2 = -. RXF12SIDL, Bit 1 = EID17. RXF12SIDL, Bit 0 = EID16.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF12SIDL, Value on POR, BOR = xxx- x-xx. RXF12SIDL, Details on page: = 56, 292. RXF12SIDH, Bit 7 = SID10. RXF12SIDH, Bit 6 = SID9. RXF12SIDH, Bit 5 = SID8. RXF12SIDH, Bit 4 = SID7. RXF12SIDH, Bit 3 = SID6. RXF12SIDH, Bit 2 = SID5. RXF12SIDH, Bit 1 = SID4. RXF12SIDH, Bit 0 = SID3. RXF12SIDH, Value on POR, BOR = xxxx xxxx. RXF12SIDH, Details on page: = 57, 291. RXF11EIDL, Bit 7 = EID7. RXF11EIDL, Bit 6 = EID6. RXF11EIDL, Bit 5 = EID5. RXF11EIDL, Bit 4 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEID4. RXF11EIDL, Bit 3 = EID3. RXF11EIDL, Bit 2 = EID2. RXF11EIDL, Bit 1 = EID1. RXF11EIDL, Bit 0 = EID0. RXF11EIDL, Value on POR, BOR = xxxx xxxx. RXF11EIDL, Details on page: = 57, 291. RXF11EIDH, Bit 7 = EID15. RXF11EIDH, Bit 6 = EID14. RXF11EIDH, Bit 5 = EID13. RXF11EIDH, Bit 4 = EID12. RXF11EIDH, Bit 3 = EID11. RXF11EIDH, Bit 2 = EID10. RXF11EIDH, Bit 1 = EID9. RXF11EIDH, Bit 0 = EID8. RXF11EIDH, Value on POR, BOR = xxxx xxxx.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF11EIDH, Details on page: = 57, 291. RXF11SIDL, Bit 7 = SID2. RXF11SIDL, Bit 6 = SID1. RXF11SIDL, Bit 5 = SID0. RXF11SIDL, Bit 4 = -. RXF11SIDL, Bit 3 = EXIDEN. RXF11SIDL, Bit 2 = -. RXF11SIDL, Bit 1 = EID17. RXF11SIDL, Bit 0 = EID16. RXF11SIDL, Value on POR, BOR = xxx- x-xx. RXF11SIDL, Details on page: = 57, 292. RXF11SIDH, Bit 7 = SID10. RXF11SIDH, Bit 6 = SID9. RXF11SIDH, Bit 5 = SID8. RXF11SIDH, Bit 4 = SID7. RXF11SIDH, Bit 3 = SID6.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF11SIDH, Bit 2 = SID5. RXF11SIDH, Bit 1 = SID4. RXF11SIDH, Bit 0 = SID3. RXF11SIDH, Value on POR, BOR = xxxx xxxx. RXF11SIDH, Details on page: = 57, 291. RXF10EIDL, Bit 7 = EID7. RXF10EIDL, Bit 6 = EID6. RXF10EIDL, Bit 5 = EID5. RXF10EIDL, Bit 4 = EID4. RXF10EIDL, Bit 3 = EID3. RXF10EIDL, Bit 2 = EID2. RXF10EIDL, Bit 1 = EID1. RXF10EIDL, Bit 0 = EID0. RXF10EIDL, Value on POR, BOR = xxxx xxxx. RXF10EIDL, Details on page: = 57, 291. RXF10EIDH, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n7 = EID15. RXF10EIDH, Bit 6 = EID14. RXF10EIDH, Bit 5 = EID13. RXF10EIDH, Bit 4 = EID12. RXF10EIDH, Bit 3 = EID11. RXF10EIDH, Bit 2 = EID10. RXF10EIDH, Bit 1 = EID9. RXF10EIDH, Bit 0 = EID8. RXF10EIDH, Value on POR, BOR = xxxx xxxx. RXF10EIDH, Details on page: = 57, 291. RXF10SIDL, Bit 7 = SID2. RXF10SIDL, Bit 6 = SID1. RXF10SIDL, Bit 5 = SID0. RXF10SIDL, Bit 4 = -. RXF10SIDL, Bit 3 = EXIDEN. RXF10SIDL, Bit 2 = -. RXF10SIDL, Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEID17. RXF10SIDL, Bit 0 = EID16. RXF10SIDL, Value on POR, BOR = xxx- x-xx. RXF10SIDL, Details on page: = 57, 292. RXF10SIDH, Bit 7 = SID10. RXF10SIDH, Bit 6 = SID9. RXF10SIDH, Bit 5 = SID8. RXF10SIDH, Bit 4 = SID7. RXF10SIDH, Bit 3 = SID6. RXF10SIDH, Bit 2 = SID5. RXF10SIDH, Bit 1 = SID4. RXF10SIDH, Bit 0 = SID3. RXF10SIDH, Value on POR, BOR = xxxx xxxx. RXF10SIDH, Details on page: = 57, 291. RXF9EIDL, Bit 7 = EID7. RXF9EIDL, Bit 6 = EID6. RXF9EIDL,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 5 = EID5. RXF9EIDL, Bit 4 = EID4. RXF9EIDL, Bit 3 = EID3. RXF9EIDL, Bit 2 = EID2. RXF9EIDL, Bit 1 = EID1. RXF9EIDL, Bit 0 = EID0. RXF9EIDL, Value on POR, BOR = xxxx xxxx. RXF9EIDL, Details on page: = 57, 291. RXF9EIDH, Bit 7 = EID15. RXF9EIDH, Bit 6 = EID14. RXF9EIDH, Bit 5 = EID13. RXF9EIDH, Bit 4 = EID12. RXF9EIDH, Bit 3 = EID11. RXF9EIDH, Bit 2 = EID10. RXF9EIDH, Bit 1 = EID9. RXF9EIDH, Bit 0 = EID8.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF9EIDH, Value on POR, BOR = xxxx xxxx. RXF9EIDH, Details on page: = 57, 291. RXF9SIDL, Bit 7 = SID2. RXF9SIDL, Bit 6 = SID1. RXF9SIDL, Bit 5 = SID0. RXF9SIDL, Bit 4 = -. RXF9SIDL, Bit 3 = EXIDEN. RXF9SIDL, Bit 2 = -. RXF9SIDL, Bit 1 = EID17. RXF9SIDL, Bit 0 = EID16. RXF9SIDL, Value on POR, BOR = xxx- x-xx. RXF9SIDL, Details on page: = 57, 292. RXF9SIDH, Bit 7 = SID10. RXF9SIDH, Bit 6 = SID9. RXF9SIDH, Bit 5 = SID8. RXF9SIDH, Bit 4 = SID7.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF9SIDH, Bit 3 = SID6. RXF9SIDH, Bit 2 = SID5. RXF9SIDH, Bit 1 = SID4. RXF9SIDH, Bit 0 = SID3. RXF9SIDH, Value on POR, BOR = xxxx xxxx. RXF9SIDH, Details on page: = 57, 291. RXF8EIDL, Bit 7 = EID7. RXF8EIDL, Bit 6 = EID6. RXF8EIDL, Bit 5 = EID5. RXF8EIDL, Bit 4 = EID4. RXF8EIDL, Bit 3 = EID3. RXF8EIDL, Bit 2 = EID2. RXF8EIDL, Bit 1 = EID1. RXF8EIDL, Bit 0 = EID0. RXF8EIDL, Value on POR, BOR = xxxx xxxx. RXF8EIDL, Details on page:",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n= 57, 291. RXF8EIDH, Bit 7 = EID15. RXF8EIDH, Bit 6 = EID14. RXF8EIDH, Bit 5 = EID13. RXF8EIDH, Bit 4 = EID12. RXF8EIDH, Bit 3 = EID11. RXF8EIDH, Bit 2 = EID10. RXF8EIDH, Bit 1 = EID9. RXF8EIDH, Bit 0 = EID8. RXF8EIDH, Value on POR, BOR = xxxx xxxx. RXF8EIDH, Details on page: = 57, 291. RXF8SIDL, Bit 7 = SID2. RXF8SIDL, Bit 6 = SID1. RXF8SIDL, Bit 5 = SID0. RXF8SIDL, Bit 4 = -. RXF8SIDL, Bit 3 = EXIDEN. RXF8SIDL, Bit 2 = -.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF8SIDL, Bit 1 = EID17. RXF8SIDL, Bit 0 = EID16. RXF8SIDL, Value on POR, BOR = xxx- x-xx. RXF8SIDL, Details on page: = 57, 292. RXF8SIDH, Bit 7 = SID10. RXF8SIDH, Bit 6 = SID9. RXF8SIDH, Bit 5 = SID8. RXF8SIDH, Bit 4 = SID7. RXF8SIDH, Bit 3 = SID6. RXF8SIDH, Bit 2 = SID5. RXF8SIDH, Bit 1 = SID4. RXF8SIDH, Bit 0 = SID3. RXF8SIDH, Value on POR, BOR = xxxx xxxx. RXF8SIDH, Details on page: = 57, 291. RXF7EIDL, Bit 7 = EID7. RXF7EIDL, Bit 6 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nEID6. RXF7EIDL, Bit 5 = EID5. RXF7EIDL, Bit 4 = EID4. RXF7EIDL, Bit 3 = EID3. RXF7EIDL, Bit 2 = EID2. RXF7EIDL, Bit 1 = EID1. RXF7EIDL, Bit 0 = EID0. RXF7EIDL, Value on POR, BOR = xxxx xxxx. RXF7EIDL, Details on page: = 57, 291. RXF7EIDH, Bit 7 = EID15. RXF7EIDH, Bit 6 = EID14. RXF7EIDH, Bit 5 = EID13. RXF7EIDH, Bit 4 = EID12. RXF7EIDH, Bit 3 = EID11. RXF7EIDH, Bit 2 = EID10. RXF7EIDH, Bit 1 = EID9. RXF7EIDH, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n0 = EID8. RXF7EIDH, Value on POR, BOR = xxxx xxxx. RXF7EIDH, Details on page: = 57, 291. RXF7SIDL, Bit 7 = SID2. RXF7SIDL, Bit 6 = SID1. RXF7SIDL, Bit 5 = SID0. RXF7SIDL, Bit 4 = -. RXF7SIDL, Bit 3 = EXIDEN. RXF7SIDL, Bit 2 = -. RXF7SIDL, Bit 1 = EID17. RXF7SIDL, Bit 0 = EID16. RXF7SIDL, Value on POR, BOR = xxx- x-xx. RXF7SIDL, Details on page: = 57, 292. RXF7SIDH, Bit 7 = SID10. RXF7SIDH, Bit 6 = SID9. RXF7SIDH, Bit 5 = SID8. RXF7SIDH,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nBit 4 = SID7. RXF7SIDH, Bit 3 = SID6. RXF7SIDH, Bit 2 = SID5. RXF7SIDH, Bit 1 = SID4. RXF7SIDH, Bit 0 = SID3. RXF7SIDH, Value on POR, BOR = xxxx xxxx. RXF7SIDH, Details on page: = 57, 291. RXF6EIDL, Bit 7 = EID7. RXF6EIDL, Bit 6 = EID6. RXF6EIDL, Bit 5 = EID5. RXF6EIDL, Bit 4 = EID4. RXF6EIDL, Bit 3 = EID3. RXF6EIDL, Bit 2 = EID2. RXF6EIDL, Bit 1 = EID1. RXF6EIDL, Bit 0 = EID0. RXF6EIDL, Value on POR, BOR = xxxx xxxx.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF6EIDL, Details on page: = 57, 291. RXF6EIDH, Bit 7 = EID15. RXF6EIDH, Bit 6 = EID14. RXF6EIDH, Bit 5 = EID13. RXF6EIDH, Bit 4 = EID12. RXF6EIDH, Bit 3 = EID11. RXF6EIDH, Bit 2 = EID10. RXF6EIDH, Bit 1 = EID9. RXF6EIDH, Bit 0 = EID8. RXF6EIDH, Value on POR, BOR = xxxx xxxx. RXF6EIDH, Details on page: = 57, 291. RXF6SIDL, Bit 7 = SID2. RXF6SIDL, Bit 6 = SID1. RXF6SIDL, Bit 5 = SID0. RXF6SIDL, Bit 4 = -. RXF6SIDL, Bit 3 = EXIDEN.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nRXF6SIDL, Bit 2 = -. RXF6SIDL, Bit 1 = EID17. RXF6SIDL, Bit 0 = EID16. RXF6SIDL, Value on POR, BOR = xxx- x-xx. RXF6SIDL, Details on page: = 57, 292. RXF6SIDH, Bit 7 = SID10. RXF6SIDH, Bit 6 = SID9. RXF6SIDH, Bit 5 = SID8. RXF6SIDH, Bit 4 = SID7. RXF6SIDH, Bit 3 = SID6. RXF6SIDH, Bit 2 = SID5. RXF6SIDH, Bit 1 = SID4. RXF6SIDH, Bit 0 = SID3. RXF6SIDH, Value on POR, BOR = xxxx xxxx. RXF6SIDH, Details on page: = 57, 291",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '. See Section 4.4 'Brown-out Reset (BOR)' .\n3: These registers and/or bits are not implemented on PIC18F2X8X devices and are read as ' 0 '. Reset values are shown for PIC18F4X8X devices; individual unimplemented bits should be interpreted as '-'.\n4: The PLLEN bit is only available in specific oscillator configuration; otherwise, it is disabled and reads as ' 0 '. See Section 2.6.4 'PLL in INTOSC Modes' .\n5: The RE3 bit is only available when Master Clear Reset is disabled (CONFIG3H<7> = 0 ); otherwise, RE3 reads as ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2585/2680/4585/4680) (CONTINUED)\n6: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as '0'.\n7: CAN bits have multiple functions depending on the selected mode of the CAN module.\n8: This register reads all ' 0 's until the ECAN\u2122 technology is set up in Mode 1 or Mode 2.\n9: These registers are available on PIC18F4X8X devices only.",
    "6.3.5 STATUS REGISTER\nThe STATUS register, shown in Register 6-2, contains the arithmetic status of the ALU. As with any other SFR, it can be the operand for any instruction.\nIt is recommended that only BCF BSF SWAPF MOVFF , , , and MOVWF instructions are used to alter the STATUS register, because these instructions do not affect the Z, C, DC, OV or N bits in the STATUS register.\nIf the STATUS register is the destination for an instruction that affects the Z, DC, C, OV or N bits, the results of the instruction are not written; instead, the status is updated according to the instruction performed. Therefore,  the  result  of  an  instruction  with  the  STATUS register as its destination may  be  different than intended. As an example, CLRF STATUS will set the Z bit  and  leave  the  remaining  Status  bits  unchanged (' 000u u1uu ').\nFor other instructions that do not affect Status bits, see the instruction set summaries  in Table 25-2 and Table 25-3.\nNote:\nThe C and DC bits operate as the borrow and digit borrow bits respectively in subtraction.",
    "REGISTER 6-2: STATUS REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-x. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = -. -, 2 = -. -, 3 = N. -, 4 = OV. -, 5 = Z. -, 6 = DC. -, 7 = C\nbit 7\nbit 0",
    "bit 4 N: Negative bit\nThis bit is used for signed arithmetic (2's complement). It indicates whether the result was negative (ALU MSB = 1 ).\n1 = Result was negative\n0 = Result was positive",
    "bit 3 OV: Overflow bit\nThis bit is used for signed arithmetic (2's complement). It indicates an overflow of the 7-bit magnitude which causes the sign bit (bit 7) to change state.\n1 = Overflow occurred for signed arithmetic (in this arithmetic operation)\n0 = No overflow occurred\nZ: Zero bit\n1 = The result of an arithmetic or logic operation is zero\n0 = The result of an arithmetic or logic operation is not zero",
    "bit 1 DC: Digit carry/borrow bit\nFor ADDWF , ADDLW, SUBLW and SUBWF instructions:\n1 = A carry-out from the 4th low-order bit of the result occurred\n0 = No carry-out from the 4th low-order bit of the result\nNote:\nFor borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand. For rotate ( RRF RLF , ) instructions, this bit is loaded with either the bit 4 or bit 3 of the source register.\nC: Carry/borrow bit\nFor ADDWF , ADDLW, SUBLW and SUBWF instructions:\n1 = A carry-out from the Most Significant bit of the result occurred\n0 = No carry-out from the Most Significant bit of the result occurred\nNote:\nFor borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand. For rotate ( RRF RLF , ) instructions, this bit is loaded with either the high or low-order bit of the source register.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "6.4 Data Addressing Modes\nNote:\nThe execution of some instructions in the core  PIC18  instruction  set  are  changed when the PIC18 extended instruction set is enabled.  See Section 6.6  'Data Memory and the Extended Instruction Set' for more information.\nWhile the program memory can be addressed in only one way - through the program counter - information in the data memory space can be addressed in several ways. For most instructions, the addressing mode is fixed. Other instructions may use up to three modes, depending on which operands are used and whether or not the extended instruction set is enabled.\nThe addressing modes are:\n\u00b7 Inherent\n\u00b7 Literal\n\u00b7 Direct\n\u00b7 Indirect\nAn additional addressing mode, Indexed Literal Offset, is available  when  the  extended  instruction  set  is enabled (XINST Configuration bit = 1 ). Its operation is discussed in greater detail in Section 6.6.1 'Indexed Addressing with Literal Offset' .",
    "6.4.1 INHERENT AND LITERAL ADDRESSING\nMany  PIC18  control  instructions  do  not  need  any argument at all; they either perform an operation that globally affects the device or they operate implicitly on one  register. This  addressing  mode  is  known  as Inherent Addressing. Examples include SLEEP RESET , and DAW .\nOther instructions work in a similar way but require an additional  explicit  argument  in  the  opcode.  This  is known  as  Literal  Addressing  mode  because  they require some literal value as an argument. Examples include ADDLW and MOVLW which, respectively, add or move a literal value to the W register. Other examples include CALL and GOTO , which include a 20-bit program memory address.",
    "6.4.2 DIRECT ADDRESSING\nDirect  addressing  specifies  all  or  part  of  the  source and/or destination address of the operation within the opcode itself. The options are specified by the arguments accompanying the instruction.\nIn  the  core  PIC18  instruction  set,  bit-oriented  and byte-oriented  instructions  use  some  version  of  direct addressing by default. All of these instructions include some  8-bit  literal  address  as  their  Least  Significant Byte. This address specifies either a register address in one of the banks of data RAM ( Section 6.3.3 'General\nPurpose Register File' )  or  a  location  in  the  Access Bank  ( Section 6.3.2  'Access  Bank' ) as  the  data source for the instruction.\nThe Access RAM bit 'a' determines how the address is interpreted.  When  'a'  is  ' 1 ',  the  contents  of  the  BSR ( Section 6.3.1  'Bank  Select  Register  (BSR)' )  are used with the address to determine the complete 12-bit address of the register. When 'a' is ' 0 ', the address is interpreted  as  being  a  register  in  the  Access  Bank. Addressing that uses the Access RAM is sometimes also known as Direct Forced Addressing mode.",
    "6.4.2 DIRECT ADDRESSING\nA few instructions, such as MOVFF ,  include the entire 12-bit  address  (either  source  or  destination)  in  their opcodes. In those cases, the BSR is ignored entirely.\nThe destination of the operation's results is determined by the destination bit 'd'. When 'd' is ' 1 ', the results are stored back in the source register, overwriting its original contents. When 'd' is ' 0 ',  the results are stored in the  W  register.  Instructions  without  the  'd'  argument have a destination that is implicit in the instruction; their destination is either the target register being operated on or the W register.",
    "6.4.3 INDIRECT ADDRESSING\nIndirect addressing allows the user to access a location in data memory without giving a fixed address in the instruction. This is done by using File Select Registers (FSRs) as pointers to the locations to be read or written to. Since the FSRs are themselves located in RAM as Special File Registers, they can also be directly manipulated under program control. This makes FSRs very useful in implementing data structures, such as tables and arrays in data memory.\nThe  registers  for  indirect  addressing  are  also  implemented with Indirect File Operands (INDFs) that permit automatic manipulation of the pointer value with auto-incrementing, auto-decrementing or offsetting with another value. This allows for efficient code, using loops, such as the example of clearing an entire RAM bank in Example 6-5.",
    "EXAMPLE 6-5:\nHOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nNEXT, 1 = LFSR CLRF. NEXT, 2 = FSR0, 100h; POSTINC0; Clear INDF ; register then ; inc pointer. BRA, 1 = BTFSS FSR0H,. BRA, 2 = 1; All done with ; Bank1?. CONTINUE, 1 = NEXT. CONTINUE, 2 = ; NO, clear next ; YES, continue",
    "6.4.3.1 FSR Registers and the INDF Operand\nAt  the  core  of  indirect  addressing  are  three  sets  of registers: FSR0, FSR1 and FSR2. Each represents a pair  of  8-bit  registers,  FSRnH  and  FSRnL.  The  four upper bits of the FSRnH register are not used, so each FSR pair holds a 12-bit value. This represents a value that can address the entire range of the data memory in a linear fashion. The FSR register pairs, then, serve as pointers to data memory locations.",
    "6.4.3.1 FSR Registers and the INDF Operand\nIndirect  addressing  is  accomplished  with  a  set  of Indirect File Operands, INDF0 through INDF2. These can  be  thought  of  as  'virtual'  registers:  they  are mapped  in  the  SFR  space,  but  are  not  physically implemented. Reading or writing to a particular INDF register actually accesses  its corresponding FSR register  pair.  A  read  from  INDF1, for example, reads the  data  at  the  address  indicated  by  FSR1H:FSR1L. Instructions that use the INDF registers as operands actually use the contents of their corresponding FSR as a pointer to the instruction's target. The INDF operand is just a convenient way of using the pointer.\nBecause indirect addressing uses a full 12-bit address, data RAM banking is not necessary. Thus, the current contents of the BSR and the Access RAM bit have no effect on determining the target address.",
    "6.4.3.3 Operations by FSRs on FSRs\nIn addition to the INDF operand, each FSR register pair also has four additional indirect operands. Like INDF, these  are  'virtual'  registers  that  cannot  be  indirectly read or written to. Accessing these registers actually accesses  the  associated  FSR  register  pair,  but  also performs a specific action on its stored value. They are:\n\u00b7 POSTDEC: accesses the FSR value, then automatically decrements it by 1 afterwards\n\u00b7 POSTINC: accesses the FSR value, then automatically increments it by 1 afterwards\n\u00b7 PREINC: increments the FSR value by 1, then uses it in the operation\n\u00b7 PLUSW: adds the signed value of the W register (range of -127 to 128) to that of the FSR and uses the new value in the operation.\nIn  this  context,  accessing  an  INDF  register  uses  the value  in  the  FSR  registers  without  changing  them. Similarly, accessing a PLUSW register gives the FSR value offset by that in the W register; neither value is actually changed in the operation. Accessing the other virtual registers changes the value of the FSR registers.",
    "6.4.3.3 Operations by FSRs on FSRs\nOperations  on  the  FSRs  with  POSTDEC,  POSTINC and  PREINC  affect  the  entire  register  pair;  that  is, rollovers of the FSRnL register from FFh to 00h carry over to the FSRnH register. On the other hand, results of  these  operations  do  not  change  the  value  of  any flags in the STATUS register (e.g., Z, N, OV, etc.).\nThe PLUSW register can be used to implement a form of indexed addressing in the data memory space. By manipulating  the  value  in  the  W  register,  users  can reach  addresses  that  are  fixed  offsets  from  pointer addresses. In some applications, this can be used to implement  some  powerful  program  control  structure, such as software stacks, inside of data memory.",
    "6.4.3.3 Operations by FSRs on FSRs\nIndirect addressing operations that target other FSRs or virtual registers represent special cases. For example, using an FSR to point to one of the virtual registers will  not  result  in  successful  operations.  As  a  specific case, assume that FSR0H:FSR0L contains FE7h, the address of INDF1. Attempts to read the value of the INDF1  using  INDF0  as  an  operand  will  return  00h. Attempts to write to INDF1 using INDF0 as the operand will result in a NOP .\nOn the other hand, using the virtual registers to write to an FSR pair may not occur as planned. In these cases, the value will be written to the FSR pair but without any incrementing or decrementing. Thus, writing to INDF2 or POSTDEC2  will  write  the  same  value  to  the FSR2H:FSR2L.\nSince the FSRs are physical registers mapped in the SFR space, they can be manipulated through all direct operations.  Users  should  proceed  cautiously  when working  on  these  registers,  particularly  if  their  code uses indirect addressing.",
    "6.4.3.3 Operations by FSRs on FSRs\nSimilarly, operations by indirect addressing are generally permitted on all other SFRs. Users should exercise the appropriate caution that they do not inadvertently change settings that might affect the operation of the device.",
    "6.5 Program Memory and the Extended Instruction Set\nThe operation of program memory is unaffected by the use of the extended instruction set.\nEnabling  the extended  instruction set adds  eight additional two-word commands to the existing PIC18 instruction set: ADDFSR , ADDULNK , CALLW , MOVSF MOVSS PUSHL SUBFSR , , , and SUBULNK. These instructions are executed as described in Section 6.2.4 'Two-Word Instructions' .",
    "6.6 Data Memory and the Extended Instruction Set\nEnabling  the  PIC18  extended  instruction  set  (XINST Configuration  bit  = 1 ) significantly  changes  certain aspects  of  data  memory  and  its  addressing.  Specifically, the use of the Access Bank for many of the core PIC18 instructions is different; this is due to the introduction of a new addressing mode for the data memory space. This mode also alters the behavior of indirect addressing using FSR2 and its associated operands.\nWhat does not change is just as important. The size of the data memory space is unchanged, as well as its linear  addressing.  The  SFR  map  remains  the  same. Core PIC18 instructions can still operate in both Direct and  Indirect  Addressing  mode;  inherent  and  literal instructions  do  not  change  at  all.  Indirect  addressing with FSR0 and FSR1 also remains unchanged.",
    "6.6.1 INDEXED ADDRESSING WITH LITERAL OFFSET\nEnabling the PIC18 extended instruction set changes the  behavior  of  indirect  addressing  using  the  FSR2 register pair and its associated file operands. Under the proper  conditions,  instructions  that  use  the  Access Bank - that is, most bit-oriented and byte-oriented instructions - can invoke a form of indexed addressing using an offset specified in the instruction. This special addressing mode is known as Indexed Addressing with Literal Offset or Indexed Literal Offset mode.\nWhen using the extended instruction set, this addressing mode requires the following:\n\u00b7 The use of the Access Bank is forced ('a' = 0 ); and\n\u00b7 The file address argument is less than or equal to 5Fh.\nUnder these conditions, the file address of the instruction is not interpreted as the lower byte of an address (used with the BSR in direct addressing), or as an 8-bit address  in  the  Access  Bank.  Instead,  the  value  is interpreted  as  an  offset  value  to  an  address  pointer, specified  by  FSR2.  The  offset  and  the  contents  of FSR2 are added to obtain the  target  address  of  the operation.",
    "6.6.2 INSTRUCTIONS AFFECTED BY INDEXED LITERAL OFFSET MODE\nAny of the core PIC18 instructions that can use direct addressing  are  potentially  affected  by  the  Indexed Literal Offset Addressing  mode.  This  includes  all byte-oriented  and  bit-oriented  instructions,  or  almost one-half of the standard PIC18 instruction set. Instructions  that  only  use  Inherent  or  Literal  Addressing modes are unaffected.\nAdditionally, byte-oriented and bit-oriented instructions are not affected if they use the Access Bank (Access RAM bit is ' 1 '), or include a file address of 60h or above. Instructions  meeting  these  criteria  will  continue  to execute as before. A comparison of the different possible addressing modes when the extended instruction set is enabled in shown in Figure 6-8.\nThose who desire to use byte-oriented or bit-oriented instructions in the Indexed Literal Offset mode should note the changes to assembler syntax for this mode. This  is  described  in  more  detail  in Section 25.2.1 'Extended Instruction Syntax' .\nFIGURE 6-8:",
    "COMPARING ADDRESSING OPTIONS FOR BIT-ORIENTED AND BYTE-ORIENTED INSTRUCTIONS (EXTENDED INSTRUCTION SET ENABLED)\nEXAMPLE INSTRUCTION: ADDWF, f, d, a (Opcode: 0010 01da ffff ffff )",
    "When a = 0 and f \uf0b3 60h:\nThe  instruction executes  in Direct Forced mode. 'f' is interpreted as a location in the Access  RAM  between  060h and 0FFh. This is the same as the SFRs, or locations F60h to 0FFh (Bank 15) of data memory.\nLocations  below  60h  are  not available in this addressing mode.",
    "When a = 0 and f \uf020\uf0a3\uf020 5Fh:\nThe instruction executes in Indexed Literal Offset mode. 'f' is interpreted as an offset to the address  value  in  FSR2.  The two are added together to obtain the address of the target register for the instruction. The address  can  be  anywhere  in the data memory space.\nNote  that  in  this mode,  the correct syntax is now: ADDWF [k], d where 'k' is the same as 'f'.",
    "When a = 1 (all values of f):\nThe  instruction executes  in Direct  mode  (also  known  as Direct Long mode). 'f' is interpreted  as  a  location  in one of the 16 banks of the data memory  space.  The  bank  is designated by the Bank Select Register  (BSR).  The  address can  be  in  any  implemented bank in the data memory space.",
    "6.6.3 MAPPING THE ACCESS BANK IN INDEXED LITERAL OFFSET MODE\nThe  use  of  Indexed  Literal  Offset  Addressing  mode effectively changes how the lower half of Access RAM (00h to 7Fh) is mapped. Rather than containing just the contents of the bottom half of Bank 0, this mode maps the contents from Bank 0 and a user defined 'window' that  can  be  located  anywhere  in  the  data  memory space. The value of FSR2 establishes the lower boundary of the addresses mapped into the window, while the upper  boundary  is  defined  by  FSR2  plus  95  (5Fh). Addresses in the Access RAM above 5Fh are mapped as previously described (see Section 6.3.2 'Access Bank' ). An example of Access Bank remapping in this addressing mode is shown in Figure 6-9.",
    "6.6.3 MAPPING THE ACCESS BANK IN INDEXED LITERAL OFFSET MODE\nRemapping of the Access Bank applies only to operations using the Indexed Literal Offset mode. Operations that use the BSR (Access RAM bit is ' 1 ') will continue to  use  direct  addressing  as  before.  Any  indirect  or indexed operation that explicitly uses any of the indirect file operands (including FSR2) will continue to operate as  standard  indirect  addressing.  Any  instruction  that uses the Access Bank, but includes a register address of greater than 05Fh, will use direct addressing and the normal Access Bank map.",
    "6.6.4 BSR IN INDEXED LITERAL OFFSET MODE\nAlthough  the  Access  Bank  is  remapped  when  the extended instruction set is enabled, the operation of the BSR remains unchanged. Direct addressing using the BSR to select the data memory bank operates in the same manner as previously described.",
    "7.0 DATA EEPROM MEMORY\nThe  data  EEPROM  is  a  nonvolatile  memory  array, separate from the data RAM and program memory, that is used for long-term storage of program data. It is not directly  mapped in either  the register  file  or  program memory space but is indirectly addressed through the Special Function Registers (SFRs). The EEPROM is readable and writable during normal operation over the entire VDD range.\nFive  SFRs  are  used  to  read  and  write  to  the  data EEPROM as well as the program memory. They are:\n\u00b7 EECON1\n\u00b7 EECON2\n\u00b7 EEDATA\n\u00b7 EEADR\n\u00b7 EEADRH\nThe data EEPROM allows byte read and write. When interfacing to the data memory block, EEDATA holds the 8-bit data for read/write and the EEADRH:EEADR register pair holds the address of the EEPROM location being accessed.",
    "7.0 DATA EEPROM MEMORY\nThe EEPROM data memory is rated for high erase/write cycle endurance. A byte write automatically erases the location  and  writes  the  new  data  (erase-before-write). The write time is controlled by an on-chip timer; it will vary with voltage and temperature, as well as from chip to chip. Please refer to parameter D122 (Table 27-1 in Section 27.0  'Electrical  Characteristics' )  for  exact limits.",
    "7.1 EEADR and EEADRH Registers\nThe EEADRH:EEADR register pair is used to address the  data  EEPROM  for  read  and  write  operations. EEADRH  holds  the  two  MSbits  of  the  address;  the upper 6 bits are ignored. The 10-bit range of the pair can address a memory range of 1024 bytes (00h to 3FFh).",
    "7.2 EECON1 and EECON2 Registers\nAccess  to  the  data  EEPROM  is  controlled  by  two registers: EECON1 and EECON2. These are the same registers which control access to the program memory and  are used  in a similar manner  for  the data EEPROM.\nThe  EECON1  register  (Register 7-1)  is  the  control register for data and program memory access. Control bit EEPGD determines if the access will be to program or data EEPROM memory. When clear, operations will access the data EEPROM memory. When set, program memory is accessed.\nControl bit CFGS determines if the access will be to the Configuration  registers  or  to  program  memory/data EEPROM memory. When set, subsequent operations access Configuration registers. When CFGS is clear, the  EEPGD bit selects  either  program  Flash  or  data EEPROM memory.\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear. The WRERR bit is set in hardware when the WREN bit is set and cleared when the internal programming timer expires and the write operation is complete.\nNote:",
    "7.2 EECON1 and EECON2 Registers\nDuring normal operation, the WRERR is read as ' 1 '. This can indicate that a write operation was prematurely terminated by a Reset, or a write operation was attempted improperly.\nThe WR control bit initiates write operations. The bit cannot be cleared, only set, in software; it is cleared in hardware at the completion of the write operation.\nNote:\nThe  EEIF  interrupt  flag  bit  (PIR2<4>)  is set when the write is complete. It must be cleared in software.\nControl  bits,  RD  and  WR,  start  read  and  erase/write operations, respectively. These bits are set by firmware and  cleared  by  hardware  at  the  completion  of  the operation.\nThe  RD  bit  cannot  be  set  when  accessing  program memory (EEPGD = 1 ). Program memory is read using table read instructions. See Section 5.1 'Table Reads and Table Writes' regarding table reads.\nThe EECON2 register is not a physical register. It is used  exclusively  in the memory  write  and  erase sequences. Reading EECON2 will read all ' 0 's.",
    "EECON1: DATA EEPROM CONTROL REGISTER 1\nR/W-x, 1 = R/W-x. R/W-x, 2 = U-0. R/W-x, 3 = R/W-0. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-0. R/W-x, 6 = R/S-0. R/W-x, 7 = R/S-0. EEPGD, 1 = CFGS. EEPGD, 2 = -. EEPGD, 3 = FREE. EEPGD, 4 = WRERR. EEPGD, 5 = WREN. EEPGD, 6 = WR. EEPGD, 7 = RD\nbit 7\nbit 0",
    "bit 7 EEPGD: Flash Program or Data EEPROM Memory Select bit\n1 = Access Flash program memory\n0 = Access data EEPROM memory\nCFGS: Flash Program/Data EEPROM or Configuration Select bit\n1 = Access Configuration registers\n0 = Access Flash program or data EEPROM memory",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nFREE:\nFlash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation)\n0 = Perform write only",
    "bit 3 WRERR: Flash Program/Data EEPROM Error Flag bit\n1 = A write operation is prematurely terminated (any Reset during self-timed programming in normal operation, or an improper write attempt)\n0 = The write operation completed\nNote:\nWhen a WRERR occurs, the EEPGD and CFGS bits are not cleared. This allows tracing of the error condition.",
    "bit 2 WREN: Flash Program/Data EEPROM Write Enable bit\n1 = Allows write cycles to Flash program/data EEPROM\n0 = Inhibits write cycles to Flash program/data EEPROM",
    "bit 1 WR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle to the EEPROM is complete",
    "bit 0 RD: Read Control bit\n1 = Initiates an EEPROM read (Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1 or CFGS = 1 .)\n0 = Does not initiate an EEPROM read\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "7.3 Reading the Data EEPROM Memory\nTo read a data memory location, the user must write the address to the EEADRH:EEADR register pair, clear the EEPGD control bit (EECON1<7>) and then set control bit,  RD  (EECON1<0>).  The  data  is  available  on  the very  next  instruction  cycle;  therefore,  the  EEDATA register can be read by the next instruction. EEDATA will hold this value until another read operation, or until it is written to by the user (during a write operation).\nThe basic process is shown in Example 7-1.",
    "7.4 Writing to the Data EEPROM Memory\nTo write an EEPROM data location, the address must first  be  written  to  the  EEADRH:EEADR  register  pair and  the  data  written  to  the  EEDATA  register.  The sequence in Example 7-2 must be followed to initiate the write cycle.\nThe write will not begin if this sequence is not exactly followed (write 55h to EECON2,  write 0AAh  to EECON2, then set WR bit) for each byte. It is strongly recommended that interrupts  be  disabled  during  this code segment.\nAdditionally, the WREN bit in EECON1 must be set to enable  writes.  This  mechanism  prevents  accidental writes  to  data  EEPROM  due  to  unexpected  code execution  (i.e.,  runaway  programs).  The  WREN  bit should be kept clear at all times, except when updating the EEPROM. The WREN bit is not cleared by hardware.\nAfter  a  write  sequence  has  been  initiated,  EECON1, EEADRH:EEADR  and  EEDATA  cannot  be  modified. The WR bit will be inhibited from being set unless the WREN bit  is  set.  The  WREN  bit  must  be  set  on  a previous instruction. Both WR and WREN cannot be set with the same instruction.",
    "7.4 Writing to the Data EEPROM Memory\nAt  the  completion  of  the  write  cycle,  the  WR  bit  is cleared in hardware and the EEPROM Interrupt Flag bit (EEIF) is set. The user may either enable this interrupt, or poll this bit. EEIF must be cleared by software.",
    "7.5 Write Verify\nDepending  on  the  application,  good  programming practice  may  dictate  that  the  value  written  to  the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "EXAMPLE 7-1: DATA EEPROM READ\nMOVLW, 1 = DATA_EE_ADDRH. MOVLW, 2 = ;. MOVWF, 1 = EEADRH. MOVWF, 2 = ; Upper bits of Data Memory Address to read. MOVLW, 1 = DATA_EE_ADDR. MOVLW, 2 = ;. MOVWF, 1 = EEADR. MOVWF, 2 = ; Lower bits of Data Memory Address to read. BCF, 1 = EECON1, EEPGD. BCF, 2 = ; Point to DATA memory. BCF, 1 = EECON1, CFGS. BCF, 2 = ; Access EEPROM. BSF, 1 = EECON1, RD. BSF, 2 = ; EEPROM Read. MOVF, 1 = EEDATA, W. MOVF, 2 = ; W = EEDATA",
    "EXAMPLE 7-2: DATA EEPROM WRITE\n, 1 = MOVLW MOVWF MOVLW MOVWF BCF BCF. , 2 = DATA_EE_ADDRH EEADRH DATA_EE_ADDR EEADR DATA_EE_DATA EEDATA EECON1, EPGD EECON1, CFGS EECON1, WREN. , 3 = ; ; ; ;. , 4 = Upper bits of Data Memory Address to write Lower bits of Data Memory Address to write Data Memory Value to write Point to DATA memory Access EEPROM. , 1 = MOVLW. , 2 = . , 3 = ;. , 4 = . , 1 = . , 2 = . , 3 = ;. , 4 = . , 1 = MOVLW. , 2 = . , 3 = ;. , 4 = . , 1 = MOVWF. , 2 = . , 3 = ;. , 4 = . , 1 = . , 2 = . , 3 = ;. , 4 = . , 1 = BSF. , 2 = . , 3 = ;. , 4 = Enable writes. , 1 = BCF. , 2 = INTCON, GIE.",
    "EXAMPLE 7-2: DATA EEPROM WRITE\n, 3 = ;. , 4 = Disable Interrupts. , 1 = . , 2 = 55h. , 3 = . , 4 = . Required Sequence, 1 = MOVWF. Required Sequence, 2 = EECON2. Required Sequence, 3 = . Required Sequence, 4 = ; Write 55h. Required Sequence, 1 = MOVLW. Required Sequence, 2 = 0AAh. Required Sequence, 3 = ;. Required Sequence, 4 = . Required Sequence, 1 = MOVWF. Required Sequence, 2 = EECON2. Required Sequence, 3 = . Required Sequence, 4 = ; Write 0AAh. Required Sequence, 1 = BSF. Required Sequence, 2 = EECON1, WR. Required Sequence, 3 = ;. Required Sequence, 4 = Set WR bit to begin write. Required Sequence, 1 = BSF. Required Sequence, 2 = INTCON, GIE. Required Sequence, 3 = . Required Sequence, 4 = ; Enable Interrupts. Required Sequence, 1 = . Required Sequence, 2 = . Required Sequence, 3 = ;. Required Sequence, 4 = User code execution. Required Sequence, 1 = BCF. Required Sequence,",
    "EXAMPLE 7-2: DATA EEPROM WRITE\n2 = EECON1, WREN. Required Sequence, 3 = ;. Required Sequence, 4 = Disable writes on write complete (EEIF set)",
    "7.6 Operation During Code-Protect\nData EEPROM memory has its own code-protect bits in Configuration Words. External read and write operations are disabled if code protection is enabled.\nThe microcontroller itself can both read and write to the internal Data EEPROM, regardless of the state of the code-protect Configuration bit. Refer to Section 24.0 'Special Features of the CPU' for additional information.",
    "7.7 Protection Against Spurious Write\nThere are conditions when the device may not want to write to the data EEPROM memory. To protect against spurious EEPROM writes, various mechanisms have been  implemented.  On  power-up,  the  WREN  bit  is cleared. In addition, writes to the EEPROM are blocked during the Power-up Timer period (TPWRT, parameter 33).",
    "7.8 Using the Data EEPROM\nThe data EEPROM is a high endurance, byte addressable array that has been optimized for the storage of frequently changing information (e.g., program variables or other data that are updated often). Frequently  changing  values  will  typically  be  updated more often than specification  D124. If  this  is  not  the case,  an  array  refresh  must  be  performed.  For  this reason,  variables  that  change  infrequently  (such  as constants,  IDs,  calibration,  etc.)  should  be  stored  in Flash program memory.\nA  simple  data  EEPROM  refresh  routine  is  shown  in Example 7-3.",
    "Note:\nIf  data  EEPROM  is  only  used  to  store constants and/or data that changes rarely, an array refresh is likely not required. See specification D124.\nThe write initiate sequence and the WREN bit together help  prevent  an  accidental  write  during  brown-out, power glitch or software malfunction.",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\n, 1 = CLRF. , 2 = EEADR. , 3 = ; Start at address. Loop, 1 = . Loop, 2 = . Loop, 3 = ; ; Set for memory ; Set for Data EEPROM ; Loop. , 1 = BCF. , 2 = EECON1, CFGS. , 3 = . , 1 = BCF BCF. , 2 = EECON1, EEPGD INTCON, GIE. , 3 = ; Disable interrupts. , 1 = BSF. , 2 = EECON1, WREN. , 3 = ; Enable writes. , 1 = BSF MOVLW. , 2 = EECON1, RD. , 3 = ; Read current address ;. , 1 = . , 2 = . , 3 = ; 55h. , 1 = MOVWF. , 2 = EECON2. , 3 = Write. , 1 = MOVLW. , 2 = 0AAh. , 3 = ; ; Write 0AAh. , 1 = MOVWF. , 2 = EECON2. , 3 = . , 1 = BSF. , 2 =",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\nEECON1, WR. , 3 = ; Set WR bit to begin write. , 1 = BTFSC BRA. , 2 = EECON1, WR. , 3 = ; Wait for write to complete. , 1 = INCFSZ. , 2 = EEADR, F. , 3 = ; Increment address. , 1 = BRA. , 2 = LOOP. , 3 = ; Not zero, do it again. , 1 = INCFSZ. , 2 = EEADRH, F. , 3 = ; Increment the high address. , 1 = BRA. , 2 = LOOP. , 3 = ; Not zero, do it again. , 1 = BCF. , 2 = EECON1, WREN. , 3 = ; Disable writes. , 1 = BSF. , 2 = INTCON, GIE. , 3 = ; Enable interrupts",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. EEADRH, Bit 7 = -. EEADRH, Bit 6 = -. EEADRH, Bit 5 = -. EEADRH, Bit 4 = -. EEADRH, Bit 3 = -. EEADRH, Bit 2 = -. EEADRH, Bit 1 = EEPROM Address Register High Byte. EEADRH, Bit 0 = EEPROM Address Register High Byte. EEADRH, Reset Values on page = 48. EEADR, Bit 7 = EEPROM Address Register. EEADR, Bit 6 = EEPROM Address Register. EEADR, Bit 5 = EEPROM Address Register. EEADR, Bit 4 = EEPROM Address Register.",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nEEADR, Bit 3 = EEPROM Address Register. EEADR, Bit 2 = EEPROM Address Register. EEADR, Bit 1 = EEPROM Address Register. EEADR, Bit 0 = EEPROM Address Register. EEADR, Reset Values on page = 48. EEDATA, Bit 7 = EEPROM Data Register. EEDATA, Bit 6 = EEPROM Data Register. EEDATA, Bit 5 = EEPROM Data Register. EEDATA, Bit 4 = EEPROM Data Register. EEDATA, Bit 3 = EEPROM Data Register. EEDATA, Bit 2 = EEPROM Data Register. EEDATA, Bit 1 = EEPROM Data Register. EEDATA, Bit 0 = EEPROM Data Register. EEDATA, Reset Values on page = 48. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\n4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Reset Values on page = 48. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Reset Values on page = 48. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP (1). IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\n3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (1). IPR2, Reset Values on page = 48. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF (1). PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (1). PIR2, Reset Values on page = 48. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE (1). PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 =",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nECCP1IE (1). PIE2, Reset Values on page = 49\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used during Flash/EEPROM access.\nNote 1:\n- These bits are available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.",
    "EXAMPLE 8-1:\n8 x 8 UNSIGNED MULTIPLY ROUTINE\nAll PIC18 devices include an 8 x 8 hardware multiplier as part of the ALU. The multiplier performs an unsigned operation and yields a 16-bit result that is stored in the product register pair, PRODH:PRODL. The multiplier's operation  does  not  affect  any  flags  in  the  STATUS register.\nMaking multiplication a hardware operation allows it to be completed in a single instruction cycle. This has the advantages  of  higher  computational  throughput  and reduced  code  size  for  multiplication  algorithms  and allows the PIC18 devices to be used in many applications previously reserved for digital signal processors. A comparison  of various hardware  and  software multiply operations, along with the savings in memory and execution time, is shown in Table 8-1.",
    "8.2 Operation\nExample 8-1  shows  the  instruction  sequence  for  an 8 x 8  unsigned  multiplication.  Only  one  instruction  is required when one of the arguments is already loaded in the WREG register.\nExample 8-2 shows the sequence to do an 8 x 8 signed multiplication.  To  account  for  the  signed  bits  of  the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "TABLE 8-1: PERFORMANCE COMPARISON FOR VARIOUS MULTIPLY OPERATIONS\n8 x 8 unsigned, Multiply Method = Without hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 13. 8 x 8 unsigned, Cycles (Max). = 69. 8 x 8 unsigned, Time.@40 MHz = 6.9 \uf06d s. 8 x 8 unsigned, Time.@10 MHz = 27.6 \uf06d s. 8 x 8 unsigned, Time.@4MHz = 69 \uf06d s. 8 x 8 unsigned, Multiply Method = Hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 1. 8 x 8 unsigned, Cycles (Max). = 1. 8 x 8 unsigned, Time.@40 MHz = 100 ns. 8 x 8 unsigned, Time.@10 MHz = 400 ns. 8 x 8 unsigned, Time.@4MHz = 1 \uf06d s. 8 x 8 signed, Multiply Method = Without hardware multiply. 8 x 8 signed, Program Memory (Words). = 33. 8 x 8 signed, Cycles (Max). = 91. 8 x 8 signed, Time.@40 MHz = 9.1 \uf06d s. 8 x 8 signed, Time.@10 MHz = 36.4 \uf06d",
    "TABLE 8-1: PERFORMANCE COMPARISON FOR VARIOUS MULTIPLY OPERATIONS\ns. 8 x 8 signed, Time.@4MHz = 91 \uf06d s. 8 x 8 signed, Multiply Method = Hardware multiply. 8 x 8 signed, Program Memory (Words). = 6. 8 x 8 signed, Cycles (Max). = 6. 8 x 8 signed, Time.@40 MHz = 600 ns. 8 x 8 signed, Time.@10 MHz = 2.4 \uf06d s. 8 x 8 signed, Time.@4MHz = 6 \uf06d s. 16 x 16 unsigned, Multiply Method = Without hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 21. 16 x 16 unsigned, Cycles (Max). = 242. 16 x 16 unsigned, Time.@40 MHz = 24.2 \uf06d s. 16 x 16 unsigned, Time.@10 MHz = 96.8 \uf06d s. 16 x 16 unsigned, Time.@4MHz = 242 \uf06d s. 16 x 16 unsigned, Multiply Method = Hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 28. 16 x 16 unsigned, Cycles (Max). = 28. 16 x 16 unsigned, Time.@40 MHz =",
    "TABLE 8-1: PERFORMANCE COMPARISON FOR VARIOUS MULTIPLY OPERATIONS\n2.8 \uf06d s. 16 x 16 unsigned, Time.@10 MHz = 11.2 \uf06d s. 16 x 16 unsigned, Time.@4MHz = 28 \uf06d s. 16 x 16 signed, Multiply Method = Without hardware multiply. 16 x 16 signed, Program Memory (Words). = 52. 16 x 16 signed, Cycles (Max). = 254. 16 x 16 signed, Time.@40 MHz = 25.4 \uf06d s. 16 x 16 signed, Time.@10 MHz = 102.6 \uf06d s. 16 x 16 signed, Time.@4MHz = 254 \uf06d s. 16 x 16 signed, Multiply Method = Hardware multiply. 16 x 16 signed, Program Memory (Words). = 35. 16 x 16 signed, Cycles (Max). = 40. 16 x 16 signed, Time.@40 MHz = 4.0 \uf06d s. 16 x 16 signed, Time.@10 MHz = 16.0 \uf06d s. 16 x 16 signed, Time.@4MHz = 40 \uf06d s\nMOVF\nARG1, W\n;\nMULWF\nARG2\n; ARG1 * ARG2 ->",
    "TABLE 8-1: PERFORMANCE COMPARISON FOR VARIOUS MULTIPLY OPERATIONS\n; PRODH:PRODL",
    "EXAMPLE 8-2: 8 x 8 SIGNED MULTIPLY\nROUTINE\nMOVF MULWF, 1 = ARG1, W ARG2. MOVF MULWF, 2 = ; ARG1 * ARG2 ->. BTFSC SUBWF MOVF, 1 = ARG2, SB PRODH, F. BTFSC SUBWF MOVF, 2 = ; Test Sign Bit ; PRODH = PRODH. BTFSC SUBWF, 1 = ARG2, W SB. BTFSC SUBWF, 2 = ; - ARG1 ; Test Sign Bit. , 1 = ARG1, PRODH, F. , 2 = ; PRODH = PRODH ; - ARG2",
    "PIC18F2585/2680/4585/4680\nExample 8-3  shows  the  sequence  to  do  a  16  x  16 unsigned multiplication. Equation 8-1 shows the algorithm that is used. The 32-bit result is stored in four registers (RES3:RES0).",
    "EQUATION 8-2:\n16 x 16 SIGNED MULTIPLICATION ALGORITHM",
    "16 x 16 UNSIGNED MULTIPLICATION ALGORITHM\nRES3:RES0, 1 = =. RES3:RES0, 2 = ARG1H:ARG1L \uf0b7 ARG2H:ARG2L (ARG1H \uf0b7 ARG2H \uf0b7 2 16 ) + (ARG1H \uf0b7 ARG2L \uf0b7 2 8 ) + (ARG1L \uf0b7 ARG2H \uf0b7 2 8 ) + (ARG1L \uf0b7 ARG2L)",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF MULWF, 1 = ARG1L, ARG2L. MOVF MULWF, 2 = W. MOVF MULWF, 3 = ; ARG1L * ARG2L-> ; PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES1 ;. MOVFF, 3 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES0 ;. MOVFF, 3 = . MOVF MULWF, 1 = ARG1H, ARG2H. MOVF MULWF, 2 = W ;. MOVF MULWF, 3 = ARG1H * ARG2H-> ; PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES3. MOVFF, 3 = ;. MOVFF, 1 = PRODL,. MOVFF, 2 = RES2 ;. MOVFF, 3 = . MOVF MULWF, 1 =",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nARG1L, ARG2H. MOVF MULWF, 2 = W ;. MOVF MULWF, 3 = ARG1L * ARG2H-> ; PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W ;. MOVF, 3 = . ADDWF, 1 = RES1, F. ADDWF, 2 = ;. ADDWF, 3 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W ;. MOVF, 3 = products. ADDWFC CLRF, 1 = RES2, F. ADDWFC CLRF, 2 = ;. ADDWFC CLRF, 3 = . ADDWFC, 1 = RES3, F. ADDWFC, 2 = . ADDWFC, 3 = ;. MOVF MULWF, 1 = ARG1H, ARG2L. MOVF MULWF, 2 = W ; ;. MOVF MULWF, 3 = ARG1H *",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nARG2L->. MOVF, 1 = PRODL,. MOVF, 2 = ; W ;. MOVF, 3 = PRODH:PRODL. ADDWF, 1 = RES1,. ADDWF, 2 = ;. ADDWF, 3 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W ;. MOVF, 3 = products. ADDWFC, 1 = RES2,. ADDWFC, 2 = ;. ADDWFC, 3 = . CLRF, 1 = WREG. CLRF, 2 = ;. CLRF, 3 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = . ADDWFC, 3 = ;\nExample 8-4  shows  the  sequence  to  do  a  16  x  16 signed  multiply. Equation 8-2  shows  the  algorithm used.  The  32-bit  result  is  stored  in  four  registers (RES3:RES0).  To  account  for  the  signed  bits  of  the arguments, the MSb for each argument pair is tested and the appropriate subtractions are done.",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nRES3:RES0=ARG1H:ARG1L   ARG2H:ARG2L \uf0b7\n= (ARG1H   ARG2H   2 16 ) + \uf0b7 \uf0b7\n(ARG1H   ARG2L   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2H   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2L) + \uf0b7\n(-1 \uf0b7 ARG2H<7>   ARG1H:ARG1L   2 16 ) + \uf0b7 \uf0b7\n(-1 \uf0b7 ARG1H<7>   ARG2H:ARG2L   2 16 ) \uf0b7 \uf0b7",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nMOVFF, ARG1L, = PRODH,. MOVFF, W = RES1. MOVFF, ; = ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES0. MOVFF, ; = ;. MOVFF,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF, ; = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF, ; = ; ;. MULWF,  = ARG1H * ARG2H -> PRODH:PRODL. MOVFF MOVFF MOVF, ARG1L, = PRODH, PRODL,. MOVFF MOVFF MOVF, W = RES3 RES2. MOVFF MOVFF MOVF, ; = ; ;. MOVFF MOVFF MOVF,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . MULWF, ARG1L, = ARG1L,W ARG2H. MULWF, W = . MULWF, ; = ; ;. MULWF,  = ARG1L * ARG2H -> PRODH:PRODL. MOVF ADDWF MOVF ADDWFC, ARG1L, = PRODL, RES1, PRODH,. MOVF ADDWF MOVF ADDWFC, W = W F W. MOVF ADDWF MOVF ADDWFC, ; = ; ;. MOVF ADDWF MOVF ADDWFC,  = Add cross. CLRF ADDWFC, ARG1L, = RES2, WREG. CLRF ADDWFC, W = F F. CLRF ADDWFC, ; = ;. CLRF ADDWFC,  = products. , ARG1L, = . , W = . , ; = ;. ,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ARG1H * ARG2L. ; MOVF, ARG1L, = RES3,. ; MOVF, W = . ; MOVF, ; = ; ;. ; MOVF,  = . MULWF, ARG1L, = ARG1H, ARG2L. MULWF, W = W. MULWF, ; = ;. MULWF,  = . , ARG1L, = . , W = . , ; = ; ;. ,  = -> PRODH:PRODL. MOVF ADDWFC CLRF ADDWFC, ARG1L, = PRODH, RES2, F WREG. MOVF ADDWFC CLRF ADDWFC, W = W. MOVF ADDWFC CLRF ADDWFC, ; = ; ; ;. MOVF ADDWFC CLRF ADDWFC,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= Add cross products. ; BTFSS BRA, ARG1L, = RES3, F ARG2H,. ; BTFSS BRA, W = 7. ; BTFSS BRA, ; = ; ;. ; BTFSS BRA,  = ARG2H:ARG2L neg? no, check ARG1. ; SIGN_ARG1 BTFSS, ARG1L, = ARG1L, RES2. ; SIGN_ARG1 BTFSS, W = W. ; SIGN_ARG1 BTFSS, ; = ; ; ; ;. ; SIGN_ARG1 BTFSS,  = . MOVF MOVF, ARG1L, = . MOVF MOVF, W = SIGN_ARG1 W. MOVF MOVF, ; = . MOVF MOVF,  = . SUBWF, ARG1L, = ARG1H,. SUBWF, W = . SUBWF, ; = . SUBWF,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . SUBWFB, ARG1L, = RES3. SUBWFB, W = . SUBWFB, ; = . SUBWFB,  = . , ARG1L, = . , W = . , ; = . ,  = ARG1H:ARG1L neg?. , ARG1L, = . , W = CONT_CODE W. , ; = ; ;. ,  = no, done. BRA MOVF SUBWF, ARG1L, = ARG2L, RES2. BRA MOVF SUBWF, W = . BRA MOVF SUBWF, ; = . BRA MOVF SUBWF,  = . MOVF, ARG1L, = ARG2H,. MOVF, W = W. MOVF, ; = ;. MOVF,  = . , ARG1L, = . , W = . , ; = ;. ,  = . SUBWFB, ARG1L, = RES3. SUBWFB, W = . SUBWFB, ; = . SUBWFB,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . ;, ARG1L, = . ;, W = . ;, ; = . ;,  = . CONT_CODE, ARG1L, = . CONT_CODE, W = . CONT_CODE, ; = . CONT_CODE,  = . , ARG1L, = :. , W = . , ; = . ,  = . , ARG1L, = . , W = ARG1H, 7. , ; = ;. ,  = ",
    "9.0 INTERRUPTS\nThe PIC18F2585/2680/4585/4680 devices have multiple  interrupt  sources  and  an  interrupt  priority  feature that allows each interrupt source to be assigned a high priority  level  or  a  low  priority  level.  The  high  priority interrupt  vector  is  at  000008h  and  the  low  priority interrupt  vector  is  at  000018h.  High  priority  interrupt events will interrupt any low priority interrupts that may be in progress.\nWhen the IPEN bit is cleared (default state), the interrupt priority feature is disabled and interrupts are compatible with PIC \u00ae  mid-range devices. In Compatibility mode, the interrupt priority bits for each source have no effect.  INTCON<6>  is  the  PEIE  bit,  which  enables/ disables all peripheral interrupt sources. INTCON<7> is  the  GIE  bit,  which  enables/disables  all  interrupt sources. All interrupts branch to address 000008h in Compatibility mode.\nThere  are  ten  registers  which  are  used  to  control interrupt operation. These registers are:\n\u00b7 RCON\n\u00b7 INTCON\n\u00b7 INTCON2\n\u00b7 INTCON3\n\u00b7 PIR1, PIR2, PIR3\n\u00b7 PIE1, PIE2, PIE3\n\u00b7 IPR1, IPR2, IPR3",
    "9.0 INTERRUPTS\nIt is  recommended  that  the  Microchip  header  files supplied with MPLAB \u00ae  IDE be used for the symbolic bit names in these registers. This allows the assembler/ compiler to automatically take care of the placement of these bits within the specified register.\nEach  interrupt  source  has  three  bits  to  control  its operation. The functions of these bits are:\n\u00b7 Flag bit to indicate that an interrupt event occurred\n\u00b7 Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\n\u00b7 Priority bit to select high priority or low priority\nThe interrupt priority feature is enabled by setting the IPEN bit (RCON<7>). When  interrupt priority is enabled,  there  are  two  bits  which  enable  interrupts globally. Setting the GIEH bit (INTCON<7>) enables all interrupts  that  have  the  priority  bit  set  (high  priority). Setting the GIEL bit (INTCON<6>) enables all interrupts that have the priority bit cleared (low priority). When  the  interrupt  flag,  enable  bit  and  appropriate global  interrupt  enable  bit  are  set,  the  interrupt  will vector  immediately  to  address  000008h  or  000018h, depending on the  priority  bit  setting.  Individual  interrupts  can  be  disabled  through  their  corresponding enable bits.",
    "9.0 INTERRUPTS\nWhen an interrupt is responded to, the global interrupt enable bit is cleared to disable further interrupts. If the IPEN bit is cleared, this is the GIE bit. If interrupt priority levels are used, this will be either the GIEH or GIEL bit. High  priority  interrupt  sources  can  interrupt  a  low priority interrupt. Low priority interrupts are not processed while high priority interrupts are in progress.\nThe return address is pushed onto the stack and the PC  is loaded with the interrupt vector address (000008h or 000018h). Once in the Interrupt Service Routine,  the  source(s)  of  the  interrupt  can  be  determined by polling  the  interrupt  flag  bits.  The  interrupt flag bits must be cleared in software before re-enabling interrupts to avoid recursive interrupts.\nThe 'return  from  interrupt'  instruction, RETFIE ,  exits the interrupt routine and sets the GIE bit (GIEH or GIEL if priority levels are used), which re-enables interrupts.",
    "9.0 INTERRUPTS\nFor external interrupt events, such as the INT pins or the PORTB input change interrupt, the interrupt latency will be  three  to  four  instruction  cycles.  The  exact latency is the same for one or two-cycle instructions. Individual interrupt flag bits are set, regardless of the status of their corresponding enable bit or the GIE bit.\nNote:\nDo not use the MOVFF instruction to modify  any  of  the  interrupt  control  registers while any interrupt  is  enabled.  Doing  so may cause erratic microcontroller behavior.\nFIGURE 9-1:",
    "PIC18F2585/2680/4585/4680\nINTERRUPT LOGIC",
    "9.1 INTCON Registers\nThe  INTCON  registers  are  readable  and  writable registers,  which  contain  various  enable,  priority  and flag bits.\nNote:\nInterrupt flag bits are set when an interrupt condition occurs regardless of the state of its corresponding enable bit or the global interrupt enable bit. User software should ensure the appropriate interrupt flag  bits are  clear  prior  to  enabling  an  interrupt. This feature allows for software polling.",
    "INTCON: INTERRUPT CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-x. GIE/GIEH, 1 = PEIE/GIEL. GIE/GIEH, 2 = TMR0IE. GIE/GIEH, 3 = INT0IE. GIE/GIEH, 4 = RBIE. GIE/GIEH, 5 = TMR0IF. GIE/GIEH, 6 = INT0IF. GIE/GIEH, 7 = RBIF\nbit 7\nbit 0",
    "bit 7 GIE/GIEH: Global Interrupt Enable bit\nWhen IPEN = 0 :\n1 = Enables all unmasked interrupts\n0 = Disables all interrupts\nWhen IPEN = 1 :\n1 = Enables all high priority interrupts\n0 = Disables all high priority interrupts",
    "bit 6 PEIE/GIEL: Peripheral Interrupt Enable bit\nWhen IPEN = 0 :\n1 = Enables all unmasked peripheral interrupts\n0 = Disables all peripheral interrupts",
    "When IPEN = 1 :\n1 = Enables all low priority peripheral interrupts\n0 = Disables all low priority peripheral interrupts",
    "bit 5 TMR0IE: TMR0 Overflow Interrupt Enable bit\n1 = Enables the TMR0 overflow interrupt\n0 = Disables the TMR0 overflow interrupt\nbit 4 INT0IE: INT0 External Interrupt Enable bit\n1 = Enables the INT0 external interrupt\n0 = Disables the INT0 external interrupt\nbit 3 RBIE: RB Port Change Interrupt Enable bit\n1 = Enables the RB port change interrupt\n0 = Disables the RB port change interrupt",
    "bit 2 TMR0IF: TMR0 Overflow Interrupt Flag bit\n1 = TMR0 register has overflowed (must be cleared in software)\n0 = TMR0 register did not overflow",
    "bit 1 INT0IF: INT0 External Interrupt Flag bit\n1 = The INT0 external interrupt occurred (must be cleared in software)\n0 = The INT0 external interrupt did not occur",
    "bit 0 RBIF: RB Port Change Interrupt Flag bit\n1 = At least one of the RB7:RB4 pins changed state (must be cleared in software)\n0 = None of the RB7:RB4 pins have changed state\nNote:\nA mismatch condition will continue to set this bit. Reading PORTB will end the mismatch condition and allow the bit to be cleared.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nREGISTER 9-2:",
    "INTCON2: INTERRUPT CONTROL REGISTER 2\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = R/W-1. R/W-1, 4 = U-0. R/W-1, 5 = R/W-1. R/W-1, 6 = U-0. R/W-1, 7 = R/W-1. RBPU, 1 = INTEDG0. RBPU, 2 = INTEDG1. RBPU, 3 = INTEDG2. RBPU, 4 = -. RBPU, 5 = TMR0IP. RBPU, 6 = -. RBPU, 7 = RBIP\nbit 7\nbit 0",
    "bit 7 RBPU: PORTB Pull-up Enable bit\n1 = All PORTB pull-ups are disabled\n0 = PORTB pull-ups are enabled by individual port latch values\nbit 6 INTEDG0: External Interrupt 0 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 5\nINTEDG1:\nExternal Interrupt 1 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 4 INTEDG2: External Interrupt 2 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 3 Unimplemented: Read as ' 0 '\nbit 2 TMR0IP: TMR0 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1 Unimplemented: Read as ' 0 '",
    "bit 0 RBIP: RB Port Change Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "Note:\nInterrupt flag bits are set when an interrupt condition occurs regardless of the state of  its  corresponding  enable  bit  or  the  global  interrupt  enable  bit.  User  software should  ensure  the  appropriate  interrupt  flag  bits  are  clear  prior  to  enabling  an interrupt. This feature allows for software polling.",
    "INTCON3: INTERRUPT CONTROL REGISTER 3\nR/W-1, 1 = R/W-1. R/W-1, 2 = U-0. R/W-1, 3 = R/W-0. R/W-1, 4 = R/W-0. R/W-1, 5 = U-0. R/W-1, 6 = R/W-0. R/W-1, 7 = R/W-0. INT2IP, 1 = INT1IP. INT2IP, 2 = -. INT2IP, 3 = INT2IE. INT2IP, 4 = INT1IE. INT2IP, 5 = -. INT2IP, 6 = INT2IF. INT2IP, 7 = INT1IF\nbit 7\nbit 0\nbit 7 INT2IP: INT2 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nINT1IP:\nINT1 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5 Unimplemented: Read as ' 0 '\nbit 4 INT2IE: INT2 External Interrupt Enable bit\n1 = Enables the INT2 external interrupt\n0 = Disables the INT2 external interrupt",
    "bit 3 INT1IE: INT1 External Interrupt Enable bit\n1 = Enables the INT1 external interrupt\n0 = Disables the INT1 external interrupt\nbit 2 Unimplemented: Read as ' 0 '",
    "bit 1 INT2IF: INT2 External Interrupt Flag bit\n1 = The INT2 external interrupt occurred (must be cleared in software)\n0 = The INT2 external interrupt did not occur",
    "bit 0 INT1IF: INT1 External Interrupt Flag bit\n1 = The INT1 external interrupt occurred (must be cleared in software)\n0 = The INT1 external interrupt did not occur",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "Note:\nInterrupt flag bits are set when an interrupt condition occurs regardless of the state of  its  corresponding  enable  bit  or  the  global  interrupt  enable  bit.  User  software should  ensure  the  appropriate  interrupt  flag  bits  are  clear  prior  to  enabling  an interrupt. This feature allows for software polling.\nbit 1",
    "9.2 PIR Registers\nThe PIR registers contain the individual flag bits for the peripheral interrupts. Due to the number of peripheral interrupt  sources,  there  are  two  Peripheral  Interrupt Request (Flag) registers (PIR1, PIR2).\nNote 1: Interrupt flag bits are set when an interrupt  condition  occurs  regardless  of  the state of its corresponding enable bit or the global interrupt enable  bit, GIE  (INTCON<7>).\n2: User software should ensure the appropriate interrupt flag bits are cleared prior to enabling an interrupt and after servicing that interrupt.",
    "REGISTER 9-4: PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIF (1), 1 = ADIF. PSPIF (1), 2 = RCIF. PSPIF (1), 3 = TXIF. PSPIF (1), 4 = SSPIF. PSPIF (1), 5 = CCP1IF. PSPIF (1), 6 = TMR2IF. PSPIF (1), 7 = TMR1IF\nbit 7\nbit 0\nbit 7 PSPIF: Parallel Slave Port Read/Write Interrupt Flag bit (1)\n1 = A read or a write operation has taken place (must be cleared in software)\n0 = No read or write has occurred",
    "REGISTER 9-4: PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nNote 1: This bit is reserved on PIC18F2X8X devices; always maintain this bit clear.\nbit 6 ADIF: A/D Converter Interrupt Flag bit\n1 = An A/D conversion completed (must be cleared in software)\n0 = The A/D conversion is not complete\nbit 5 RCIF: EUSART Receive Interrupt Flag bit\n1 = The EUSART receive buffer, RCREG, is full (cleared when RCREG is read)\n0 = The EUSART receive buffer is empty\nbit 4 TXIF: EUSART Transmit Interrupt Flag bit\n1 = The EUSART transmit buffer, TXREG, is empty (cleared when TXREG is written)\n0 = The EUSART transmit buffer is full\nbit 3 SSPIF: Master Synchronous Serial Port Interrupt Flag bit\n1 = The transmission/reception is complete (must be cleared in software)\n0 = Waiting to transmit/receive",
    "Capture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n0 = No TMR1 register capture occurred",
    "Compare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n0 = No TMR1 register compare match occurred",
    "PWM mode:\nUnused in this mode.\nTMR2IF: TMR2 to PR2 Match Interrupt Flag bit\n1 = TMR2 to PR2 match occurred (must be cleared in software)\n0 = No TMR2 to PR2 match occurred\nbit 0 TMR1IF: TMR1 Overflow Interrupt Flag bit\n1 = TMR1 register overflowed (must be cleared in software)\n0 = MR1 register did not overflow",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 2",
    "REGISTER 9-5: PIR2: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 2\nR/W-0, 1 = R/W-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. OSCFIF, 1 = CMIF (1). OSCFIF, 2 = -. OSCFIF, 3 = EEIF. OSCFIF, 4 = BCLIF. OSCFIF, 5 = HLVDIF. OSCFIF, 6 = TMR3IF. OSCFIF, 7 = ECCP1IF (1)\nbit 7\nbit 0",
    "bit 7 OSCFIF: Oscillator Fail Interrupt Flag bit\n1 = System oscillator failed, clock input has changed to INTOSC (must be cleared in software)\n0 = System clock operating\nbit 6 CMIF: Comparator Interrupt Flag bit (1)\n1 = Comparator input has changed (must be cleared in software)\n0 = Comparator input has not changed",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4 EEIF: Data EEPROM/Flash Write Operation Interrupt Flag bit\n1 = The write operation is complete (must be cleared in software)\n0 = The write operation is not complete, or has not been started\nbit 3 BCLIF: Bus Collision Interrupt Flag bit\n1 = A bus collision occurred (must be cleared in software)\n0 = No bus collision occurred\nHLVDIF:\nHigh/Low-Voltage Detect Interrupt Flag bit\n1 = A low-voltage condition occurred (must be cleared in software)\n0 = The device voltage is above the High/Low-Voltage Detect trip point\nbit 1 TMR3IF: TMR3 Overflow Interrupt Flag bit\n1 = TMR3 register overflowed (must be cleared in software)\n0 = TMR3 register did not overflow",
    "Capture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n0 = No TMR1 register capture occurred",
    "Compare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n0 = No TMR1 register compare match occurred",
    "PWM mode:\n- Unused in this mode.\nNote 1: These bits are available in PIC18F4X8X and reserved in PIC18F2X8X devices.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\nMode 0, R/W-0 = IRXIF. Mode 0, R/W-0 = WAKIF. Mode 0, R/W-0 = ERRIF. Mode 0, R/W-0 = TXB2IF. Mode 0, R/W-0 = TXB1IF (1). Mode 0, R/W-0 = TXB0IF (1). Mode 0, R/W-0 = RXB1IF. Mode 0, R/W-0 = RXB0IF. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = IRXIF. , R/W-0 = WAKIF. ,",
    "PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\nR/W-0 = ERRIF. , R/W-0 = TXBnIF. , R/W-0 = TXB1IF (1). , R/W-0 = TXB0IF (1). , R/W-0 = RXBnIF. , R/W-0 = FIFOWMIF\nbit 7\nbit 0\n- bit 7\nIRXIF: CAN Invalid Received Message Interrupt Flag bit\n- 1 = An invalid message has occurred on the CAN bus\n0 = No invalid message on CAN bus\nWAKIF: CAN bus Activity Wake-up Interrupt Flag bit\n1 = Activity on CAN bus has occurred\n0 = No activity on CAN bus",
    "bit 5 ERRIF:\nCAN bus Error Interrupt Flag bit\n1 = An error has occurred in the CAN module (multiple sources)\n0 = No CAN module errors",
    "bit 4 When CAN is in Mode 0:\nTXB2IF: CAN Transmit Buffer 2 Interrupt Flag bit\n1 = Transmit Buffer 2 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 2 has not completed transmission of a message\nWhen CAN is in Mode 1 or 2:\nTXBnIF: Any Transmit Buffer Interrupt Flag bit\n1 = One or more transmit buffers have completed transmission of a message and may be reloaded\n0 = No transmit buffer is ready for reload\nbit 3 TXB1IF: CAN Transmit Buffer 1 Interrupt Flag bit (1)\n1 = Transmit Buffer 1 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 1 has not completed transmission of a message",
    "bit 2 TXB0IF: CAN Transmit Buffer 0 Interrupt Flag bit (1)\n1 = Transmit Buffer 0 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 0 has not completed transmission of a message",
    "bit 1 When CAN is in Mode 0:\nRXB1IF: CAN Receive Buffer 1 Interrupt Flag bit\n1 = Receive Buffer 1 has received a new message\n0 = Receive Buffer 1 has not received a new message",
    "When CAN is in Mode 1 or 2:\nRXBnIF: Any Receive Buffer Interrupt Flag bit\n1 = One or more receive buffers has received a new message\n0 = No receive buffer has received a new message",
    "bit 0 When CAN is in Mode 0:\nRXB0IF: CAN Receive Buffer 0 Interrupt Flag bit\n1 = Receive Buffer 0 has received a new message\n0 = Receive Buffer 0 has not received a new message\nWhen CAN is in Mode 1:\nUnimplemented: Read as ' 0 '",
    "When CAN is in Mode 2:\nFIFOWMIF:\nFIFO Watermark Interrupt Flag bit\n1 = FIFO high watermark is reached\n0 = FIFO high watermark is not reached\nNote 1:\nIn CAN Mode 1 and 2, this bit is forced to ' 0 '.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "9.3 PIE Registers\nThe PIE registers contain the individual enable bits for the peripheral interrupts. Due to the number of peripheral  interrupt  sources,  there  are  two  Peripheral Interrupt Enable registers (PIE1, PIE2). When IPEN = 0 , the  PEIE  bit  must  be  set  to  enable  any  of  these peripheral interrupts.",
    "PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIE (1), 1 = ADIE. PSPIE (1), 2 = RCIE. PSPIE (1), 3 = TXIE. PSPIE (1), 4 = SSPIE. PSPIE (1), 5 = CCP1IE. PSPIE (1), 6 = TMR2IE. PSPIE (1), 7 = TMR1IE\nbit 7\nbit 0\nPSPIE: Parallel Slave Port Read/Write Interrupt Enable bit (1)\nbit 7\n1 = Enables the PSP read/write interrupt\n0 = Disables the PSP read/write interrupt\nNote 1: This bit is reserved on PIC18F2X8X devices; always maintain this bit clear.",
    "PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nbit 6\nADIE: A/D Converter Interrupt Enable bit\n1 = Enables the A/D interrupt\n0 = Disables the A/D interrupt",
    "bit 5\nRCIE: EUSART Receive Interrupt Enable bit\n1 = Enables the EUSART receive interrupt\n0 = Disables the EUSART receive interrupt",
    "bit 4\nTXIE: EUSART Transmit Interrupt Enable bit\n1 = Enables the EUSART transmit interrupt\n0 = Disables the EUSART transmit interrupt",
    "bit 3 SSPIE: Master Synchronous Serial Port Interrupt Enable bit\n1 = Enables the MSSP interrupt\n0\n= Disables the MSSP interrupt",
    "bit 2\nCCP1IE: CCP1 Interrupt Enable bit\n1 = Enables the CCP1 interrupt\n0 = Disables the CCP1 interrupt\nbit 1\nTMR2IE: TMR2 to PR2 Match Interrupt Enable bit\n1 = Enables the TMR2 to PR2 match interrupt\n0 = Disables the TMR2 to PR2 match interrupt\nbit 0\nTMR1IE:\nTMR1 Overflow Interrupt Enable bit\n1 = Enables the TMR1 overflow interrupt\n0 = Disables the TMR1 overflow interrupt",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\n, R/W-0.OSCFIE = bit 7. , R/W-0.CMIE (1) = . , U-0.- = . , R/W-0.EEIE = . , R/W-0.BCLIE = . , R/W-0.HLVDIE = . , R/W-0.TMR3IE = . , R/W-0.ECCP1IE (2) = bit 0. bit 7, R/W-0.OSCFIE = OSCFIE: Oscillator Fail Interrupt Enable bit. bit 7, R/W-0.CMIE (1) = OSCFIE: Oscillator Fail Interrupt Enable bit. bit 7, U-0.- = OSCFIE: Oscillator Fail Interrupt Enable bit. bit 7, R/W-0.EEIE = OSCFIE: Oscillator Fail Interrupt Enable bit. bit 7, R/W-0.BCLIE = OSCFIE: Oscillator Fail Interrupt Enable bit. bit 7,",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nR/W-0.HLVDIE = OSCFIE: Oscillator Fail Interrupt Enable bit. bit 7, R/W-0.TMR3IE = OSCFIE: Oscillator Fail Interrupt Enable bit. bit 7, R/W-0.ECCP1IE (2) = OSCFIE: Oscillator Fail Interrupt Enable bit. , R/W-0.OSCFIE = 1 = Enabled 0 = Disabled. , R/W-0.CMIE (1) = 1 = Enabled 0 = Disabled. , U-0.- = 1 = Enabled 0 = Disabled. , R/W-0.EEIE = 1 = Enabled 0 = Disabled. , R/W-0.BCLIE = 1 = Enabled 0 = Disabled. , R/W-0.HLVDIE = 1 = Enabled 0 = Disabled. , R/W-0.TMR3IE = 1 = Enabled 0 = Disabled. , R/W-0.ECCP1IE (2) = 1 = Enabled 0 = Disabled. bit 6, R/W-0.OSCFIE =",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nCMIE: Comparator Interrupt Enable bit (1) 1 = Enabled. bit 6, R/W-0.CMIE (1) = CMIE: Comparator Interrupt Enable bit (1) 1 = Enabled. bit 6, U-0.- = CMIE: Comparator Interrupt Enable bit (1) 1 = Enabled. bit 6, R/W-0.EEIE = CMIE: Comparator Interrupt Enable bit (1) 1 = Enabled. bit 6, R/W-0.BCLIE = CMIE: Comparator Interrupt Enable bit (1) 1 = Enabled. bit 6, R/W-0.HLVDIE = CMIE: Comparator Interrupt Enable bit (1) 1 = Enabled. bit 6, R/W-0.TMR3IE = CMIE: Comparator Interrupt Enable bit (1) 1 = Enabled. bit 6, R/W-0.ECCP1IE (2) = CMIE: Comparator Interrupt Enable bit (1) 1 = Enabled. , R/W-0.OSCFIE = 0 = Disabled. , R/W-0.CMIE",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\n(1) = 0 = Disabled. , U-0.- = 0 = Disabled. , R/W-0.EEIE = 0 = Disabled. , R/W-0.BCLIE = 0 = Disabled. , R/W-0.HLVDIE = 0 = Disabled. , R/W-0.TMR3IE = 0 = Disabled. , R/W-0.ECCP1IE (2) = 0 = Disabled. bit 5, R/W-0.OSCFIE = Unimplemented: Read as ' 0 '. bit 5, R/W-0.CMIE (1) = Unimplemented: Read as ' 0 '. bit 5, U-0.- = Unimplemented: Read as ' 0 '. bit 5, R/W-0.EEIE = Unimplemented: Read as ' 0 '. bit 5, R/W-0.BCLIE = Unimplemented: Read as ' 0 '. bit 5, R/W-0.HLVDIE = Unimplemented: Read as ' 0 '. bit",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\n5, R/W-0.TMR3IE = Unimplemented: Read as ' 0 '. bit 5, R/W-0.ECCP1IE (2) = Unimplemented: Read as ' 0 '. bit 4, R/W-0.OSCFIE = EEIE: Data EEPROM/Flash Write Operation Interrupt Enable bit. bit 4, R/W-0.CMIE (1) = EEIE: Data EEPROM/Flash Write Operation Interrupt Enable bit. bit 4, U-0.- = EEIE: Data EEPROM/Flash Write Operation Interrupt Enable bit. bit 4, R/W-0.EEIE = EEIE: Data EEPROM/Flash Write Operation Interrupt Enable bit. bit 4, R/W-0.BCLIE = EEIE: Data EEPROM/Flash Write Operation Interrupt Enable bit. bit 4, R/W-0.HLVDIE = EEIE: Data EEPROM/Flash Write Operation Interrupt Enable bit. bit 4, R/W-0.TMR3IE = EEIE: Data EEPROM/Flash Write Operation Interrupt",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nEnable bit. bit 4, R/W-0.ECCP1IE (2) = EEIE: Data EEPROM/Flash Write Operation Interrupt Enable bit. , R/W-0.OSCFIE = 1 = Enabled = Disabled. , R/W-0.CMIE (1) = 1 = Enabled = Disabled. , U-0.- = 1 = Enabled = Disabled. , R/W-0.EEIE = 1 = Enabled = Disabled. , R/W-0.BCLIE = 1 = Enabled = Disabled. , R/W-0.HLVDIE = 1 = Enabled = Disabled. , R/W-0.TMR3IE = 1 = Enabled = Disabled. , R/W-0.ECCP1IE (2) = 1 = Enabled = Disabled. bit 3, R/W-0.OSCFIE = BCLIE: Bus Collision Interrupt Enable bit. bit 3, R/W-0.CMIE (1) = BCLIE: Bus Collision Interrupt Enable bit. bit 3, U-0.- = BCLIE: Bus Collision Interrupt Enable bit. bit 3,",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nR/W-0.EEIE = BCLIE: Bus Collision Interrupt Enable bit. bit 3, R/W-0.BCLIE = BCLIE: Bus Collision Interrupt Enable bit. bit 3, R/W-0.HLVDIE = BCLIE: Bus Collision Interrupt Enable bit. bit 3, R/W-0.TMR3IE = BCLIE: Bus Collision Interrupt Enable bit. bit 3, R/W-0.ECCP1IE (2) = BCLIE: Bus Collision Interrupt Enable bit. , R/W-0.OSCFIE = 1 = Enabled. , R/W-0.CMIE (1) = 1 = Enabled. , U-0.- = 1 = Enabled. , R/W-0.EEIE = 1 = Enabled. , R/W-0.BCLIE = 1 = Enabled. , R/W-0.HLVDIE = 1 = Enabled. , R/W-0.TMR3IE = 1 = Enabled. , R/W-0.ECCP1IE (2) = 1 = Enabled. , R/W-0.OSCFIE =",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\n0 = Disabled. , R/W-0.CMIE (1) = 0 = Disabled. , U-0.- = 0 = Disabled. , R/W-0.EEIE = 0 = Disabled. , R/W-0.BCLIE = 0 = Disabled. , R/W-0.HLVDIE = 0 = Disabled. , R/W-0.TMR3IE = 0 = Disabled. , R/W-0.ECCP1IE (2) = 0 = Disabled. bit 2, R/W-0.OSCFIE = HLVDIE: High/Low-Voltage Detect Interrupt Enable bit. bit 2, R/W-0.CMIE (1) = HLVDIE: High/Low-Voltage Detect Interrupt Enable bit. bit 2, U-0.- = HLVDIE: High/Low-Voltage Detect Interrupt Enable bit. bit 2, R/W-0.EEIE = HLVDIE: High/Low-Voltage Detect Interrupt Enable bit. bit 2, R/W-0.BCLIE = HLVDIE: High/Low-Voltage Detect Interrupt Enable",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nbit. bit 2, R/W-0.HLVDIE = HLVDIE: High/Low-Voltage Detect Interrupt Enable bit. bit 2, R/W-0.TMR3IE = HLVDIE: High/Low-Voltage Detect Interrupt Enable bit. bit 2, R/W-0.ECCP1IE (2) = HLVDIE: High/Low-Voltage Detect Interrupt Enable bit. , R/W-0.OSCFIE = 1 = Enabled. , R/W-0.CMIE (1) = 1 = Enabled. , U-0.- = 1 = Enabled. , R/W-0.EEIE = 1 = Enabled. , R/W-0.BCLIE = 1 = Enabled. , R/W-0.HLVDIE = 1 = Enabled. , R/W-0.TMR3IE = 1 = Enabled. , R/W-0.ECCP1IE (2) = 1 = Enabled. , R/W-0.OSCFIE = 0 = Disabled. , R/W-0.CMIE (1) = 0 =",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nDisabled. , U-0.- = 0 = Disabled. , R/W-0.EEIE = 0 = Disabled. , R/W-0.BCLIE = 0 = Disabled. , R/W-0.HLVDIE = 0 = Disabled. , R/W-0.TMR3IE = 0 = Disabled. , R/W-0.ECCP1IE (2) = 0 = Disabled. bit 1, R/W-0.OSCFIE = TMR3IE: TMR3 Overflow Interrupt Enable bit. bit 1, R/W-0.CMIE (1) = TMR3IE: TMR3 Overflow Interrupt Enable bit. bit 1, U-0.- = TMR3IE: TMR3 Overflow Interrupt Enable bit. bit 1, R/W-0.EEIE = TMR3IE: TMR3 Overflow Interrupt Enable bit. bit 1, R/W-0.BCLIE = TMR3IE: TMR3 Overflow Interrupt Enable bit. bit 1, R/W-0.HLVDIE",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\n= TMR3IE: TMR3 Overflow Interrupt Enable bit. bit 1, R/W-0.TMR3IE = TMR3IE: TMR3 Overflow Interrupt Enable bit. bit 1, R/W-0.ECCP1IE (2) = TMR3IE: TMR3 Overflow Interrupt Enable bit. , R/W-0.OSCFIE = 1 = Enabled = Disabled. , R/W-0.CMIE (1) = 1 = Enabled = Disabled. , U-0.- = 1 = Enabled = Disabled. , R/W-0.EEIE = 1 = Enabled = Disabled. , R/W-0.BCLIE = 1 = Enabled = Disabled. , R/W-0.HLVDIE = 1 = Enabled = Disabled. , R/W-0.TMR3IE = 1 = Enabled = Disabled. , R/W-0.ECCP1IE (2) = 1 = Enabled = Disabled. bit 0, R/W-0.OSCFIE = ECCP1IE: ECCP1 Interrupt Enable bit",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\n(2). bit 0, R/W-0.CMIE (1) = ECCP1IE: ECCP1 Interrupt Enable bit (2). bit 0, U-0.- = ECCP1IE: ECCP1 Interrupt Enable bit (2). bit 0, R/W-0.EEIE = ECCP1IE: ECCP1 Interrupt Enable bit (2). bit 0, R/W-0.BCLIE = ECCP1IE: ECCP1 Interrupt Enable bit (2). bit 0, R/W-0.HLVDIE = ECCP1IE: ECCP1 Interrupt Enable bit (2). bit 0, R/W-0.TMR3IE = ECCP1IE: ECCP1 Interrupt Enable bit (2). bit 0, R/W-0.ECCP1IE (2) = ECCP1IE: ECCP1 Interrupt Enable bit (2). , R/W-0.OSCFIE = 0 = Disabled. , R/W-0.CMIE (1) = 0 = Disabled. , U-0.- = 0 = Disabled. ,",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nR/W-0.EEIE = 0 = Disabled. , R/W-0.BCLIE = 0 = Disabled. , R/W-0.HLVDIE = 0 = Disabled. , R/W-0.TMR3IE = 0 = Disabled. , R/W-0.ECCP1IE (2) = 0 = Disabled. , R/W-0.OSCFIE = Note 1: This bit is available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.. , R/W-0.CMIE (1) = Note 1: This bit is available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.. , U-0.- = Note 1: This bit is available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.. , R/W-0.EEIE = Note 1: This bit is available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.. , R/W-0.BCLIE = Note",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\n1: This bit is available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.. , R/W-0.HLVDIE = Note 1: This bit is available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.. , R/W-0.TMR3IE = Note 1: This bit is available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.. , R/W-0.ECCP1IE (2) = Note 1: This bit is available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.. , R/W-0.OSCFIE = 2: This bit is available in PIC18F4X8X devices only.. , R/W-0.CMIE (1) = 2: This bit is available in PIC18F4X8X devices only.. , U-0.- = 2: This bit is available in PIC18F4X8X devices only.. ,",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nR/W-0.EEIE = 2: This bit is available in PIC18F4X8X devices only.. , R/W-0.BCLIE = 2: This bit is available in PIC18F4X8X devices only.. , R/W-0.HLVDIE = 2: This bit is available in PIC18F4X8X devices only.. , R/W-0.TMR3IE = 2: This bit is available in PIC18F4X8X devices only.. , R/W-0.ECCP1IE (2) = 2: This bit is available in PIC18F4X8X devices only.. , R/W-0.OSCFIE = Legend: R = Readable bit. , R/W-0.CMIE (1) = Legend: R = Readable bit. , U-0.- = . , R/W-0.EEIE = . , R/W-0.BCLIE = U = Unimplemented bit, read as '0'. , R/W-0.HLVDIE = U =",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nUnimplemented bit, read as '0'. , R/W-0.TMR3IE = U = Unimplemented bit, read as '0'. , R/W-0.ECCP1IE (2) = U = Unimplemented bit, read as '0'",
    "REGISTER 9-9: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\nMode 0\nMode 1",
    "bit 5\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nIRXIE\nWAKIE\nERRIE\nTXB2IE\nTXB1IE\n(1)\nTXB0IE\n(1)\nRXB1IE\nRXB0IE\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IRXIE, 1 = WAKIE. IRXIE, 2 = ERRIE. IRXIE, 3 = TXBnIE. IRXIE, 4 = TXB1IE (1). IRXIE, 5 = TXB0IE (1). IRXIE, 6 = RXBnIE. IRXIE, 7 = FIFOWMIE\nbit 7\nbit 0",
    "bit 5\nIRXIE: CAN Invalid Received Message Interrupt Enable bit\n1 = Enable invalid message received interrupt\n0 = Disable invalid message received interrupt\nWAKIE: CAN bus Activity Wake-up Interrupt Enable bit\n1 = Enable bus activity wake-up interrupt\n0 = Disable bus activity wake-up interrupt\nERRIE: CAN bus Error Interrupt Enable bit\n1 = Enable CAN bus error interrupt\n0 = Disable CAN bus error interrupt",
    "bit 4 When CAN is in Mode 0:\nTXB2IE: CAN Transmit Buffer 2 Interrupt Enable bit\n- 1 = Enable Transmit Buffer 2 interrupt\n0 = Disable Transmit Buffer 2 interrupt\nWhen CAN is in Mode 1 or 2:\nTXBnIE: CAN Transmit Buffer Interrupts Enable bit\n1 = Enable transmit buffer interrupt; individual interrupt is enabled by TXBIE and BIE0\n0 = Disable all transmit buffer interrupts",
    "bit 3 TXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1)\n- 1 = Enable Transmit Buffer 1 interrupt\n0 = Disable Transmit Buffer 1 interrupt",
    "bit 2 TXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1)\n1 = Enable Transmit Buffer 0 interrupt\n0 = Disable Transmit Buffer 0 interrupt",
    "bit 1 When CAN is in Mode 0:\nRXB1IE: CAN Receive Buffer 1 Interrupt Enable bit\n- 1 = Enable Receive Buffer 1 interrupt\n0 = Disable Receive Buffer 1 interrupt\nWhen CAN is in Mode 1 or 2:\nRXBnIE: CAN Receive Buffer Interrupts Enable bit\n1 = Enable receive buffer interrupt; individual interrupt is enabled by BIE0\n0 = Disable all receive buffer interrupts",
    "bit 0 When CAN is in Mode 0:\nRXB0IE: CAN Receive Buffer 0 Interrupt Enable bit\n1 = Enable Receive Buffer 0 interrupt\n0 = Disable Receive Buffer 0 interrupt\nWhen CAN is in Mode 1:\nUnimplemented: Read as ' 0 '",
    "When CAN is in Mode 2:\nFIFOWMIE:\nFIFO Watermark Interrupt Enable bit\n1 = Enable FIFO watermark interrupt\n0 = Disable FIFO watermark interrupt\nNote 1:\nIn CAN Mode 1 and 2, this bit is forced to ' 0 '.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "9.4 IPR Registers\nThe IPR registers contain the individual priority bits for the peripheral interrupts. Due  to the number  of peripheral interrupt sources, there are two Peripheral Interrupt  Priority  registers  (IPR1,  IPR2).  Using  the priority  bits  requires  that  the  Interrupt  Priority  Enable (IPEN) bit be set.",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = R/W-1. R/W-1, 4 = R/W-1. R/W-1, 5 = R/W-1. R/W-1, 6 = R/W-1. R/W-1, 7 = R/W-1. PSPIP (1), 1 = ADIP. PSPIP (1), 2 = RCIP. PSPIP (1), 3 = TXIP. PSPIP (1), 4 = SSPIP. PSPIP (1), 5 = CCP1IP. PSPIP (1), 6 = TMR2IP. PSPIP (1), 7 = TMR1IP\nbit 7\nbit 0\nPSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1)\nbit 7\n1 = High priority\n0 = Low priority\nNote 1: This bit is reserved on PIC18F2X8X devices; always maintain this bit set.\nbit 6",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nADIP: A/D Converter Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nRCIP: EUSART Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4\nTXIP: EUSART Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nSSPIP: Master Synchronous Serial Port Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nCCP1IP: CCP1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR2IP: TMR2 to PR2 Match Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nTMR1IP: TMR1 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nR/W-1, 1 = R/W-1. R/W-1, 2 = U-0. R/W-1, 3 = R/W-1. R/W-1, 4 = R/W-1. R/W-1, 5 = R/W-1. R/W-1, 6 = R/W-1. R/W-1, 7 = R/W-1. OSCFIP, 1 = CMIP (1). OSCFIP, 2 = -. OSCFIP, 3 = EEIP. OSCFIP, 4 = BCLIP. OSCFIP, 5 = HLVDIP. OSCFIP, 6 = TMR3IP. OSCFIP, 7 = ECCP1IP (2)\nbit 7\nbit 0\nbit 7\nOSCFIP: Oscillator Fail Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nCMIP: Comparator Interrupt Priority bit (1)\n1 = High priority\n0 = Low priority\nbit 5 Unimplemented: Read as ' 0 '",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nbit 4 EEIP: Data EEPROM/Flash Write Operation Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nBCLIP: Bus Collision Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nHLVDIP: High/Low-Voltage Detect Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR3IP: TMR3 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nECCP1IP: ECCP1 Interrupt Priority bit (2)\n1 = High priority\n0 = Low priority\nNote 1: This bit is available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.\n2: This bit is available in PIC18F4X8X devices only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nMode 1, 2, R/W-1.IRXIP = R/W-1. Mode 1, 2, R/W-1.WAKIP = R/W-1. Mode 1, 2, R/W-1.ERRIP = R/W-1. Mode 1, 2, R/W-1.TXB2IP = R/W-1. Mode 1, 2, R/W-1.TXB1IP (1) = R/W-1. Mode 1, 2, R/W-1.TXB0IP (1) = R/W-1. Mode 1, 2, R/W-1.RXB1IP = R/W-1. Mode 1, 2, R/W-1.RXB0IP = R/W-1. Mode 1, 2, R/W-1.IRXIP = IRXIP. Mode 1, 2, R/W-1.WAKIP = WAKIP. Mode 1, 2, R/W-1.ERRIP = ERRIP. Mode 1, 2,",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nR/W-1.TXB2IP = TXBnIP. Mode 1, 2, R/W-1.TXB1IP (1) = TXB1IP (1). Mode 1, 2, R/W-1.TXB0IP (1) = TXB0IP (1). Mode 1, 2, R/W-1.RXB1IP = RXBnIP. Mode 1, 2, R/W-1.RXB0IP = FIFOWMIP. Mode 1, 2, R/W-1.IRXIP = bit 7. Mode 1, 2, R/W-1.WAKIP = . Mode 1, 2, R/W-1.ERRIP = . Mode 1, 2, R/W-1.TXB2IP = . Mode 1, 2, R/W-1.TXB1IP (1) = . Mode 1, 2, R/W-1.TXB0IP (1) = . Mode 1, 2, R/W-1.RXB1IP = . Mode 1, 2,",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nR/W-1.RXB0IP = bit 0. bit 7, R/W-1.IRXIP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.WAKIP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.ERRIP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.TXB2IP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.TXB1IP (1) = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.TXB0IP (1) = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.RXB1IP = IRXIP: CAN Invalid Received Message Interrupt Priority bit",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\n1 = High priority 0 = Low priority. bit 7, R/W-1.RXB0IP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.IRXIP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.WAKIP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.ERRIP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.TXB2IP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.TXB1IP (1) = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.TXB0IP (1) = WAKIP: CAN bus Activity",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nWake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.RXB1IP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.RXB0IP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.IRXIP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.WAKIP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.ERRIP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.TXB2IP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.TXB1IP (1) = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\npriority. bit 5, R/W-1.TXB0IP (1) = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.RXB1IP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.RXB0IP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1.IRXIP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1.WAKIP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit 1 = High priority = Low priority. bit 4,",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nR/W-1.ERRIP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1.TXB2IP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1.TXB1IP (1) = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1.TXB0IP (1) = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nCAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1.RXB1IP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1.RXB0IP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit 1 = High priority = Low priority. bit 3, R/W-1.IRXIP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.WAKIP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.ERRIP = TXB1IP:",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nCAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.TXB2IP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.TXB1IP (1) = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.TXB0IP (1) = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.RXB1IP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.RXB0IP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.IRXIP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.WAKIP = TXB0IP: CAN Transmit Buffer",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\n0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.ERRIP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.TXB2IP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.TXB1IP (1) = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.TXB0IP (1) = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.RXB1IP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.RXB0IP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 1, R/W-1.IRXIP = = Low priority When CAN is in Mode 0:",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nRXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.WAKIP = = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.ERRIP = = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.TXB2IP = = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nBuffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.TXB1IP (1) = = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.TXB0IP (1) = = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.RXB1IP = = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.RXB0IP = = Low",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\npriority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 0, R/W-1.IRXIP = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.WAKIP = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.ERRIP = 0 = Low priority When CAN is in Mode 0:",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nRXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.TXB2IP = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.TXB1IP (1) = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.TXB0IP",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\n(1) = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.RXB1IP = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.RXB0IP = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit.",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\n, R/W-1.IRXIP = Legend: R = Readable -n = Value. , R/W-1.WAKIP = bit at POR. , R/W-1.ERRIP = W=Writable '1' = Bit. , R/W-1.TXB2IP = bit set. , R/W-1.TXB1IP (1) = U = '0' = Bit. , R/W-1.TXB0IP (1) = Unimplemented is cleared. , R/W-1.RXB1IP = bit, read x = Bit. , R/W-1.RXB0IP = '0' unknown",
    "9.5 RCON Register\nThe RCON register contains flag bits which are used to determine the cause of the last Reset or wake-up from Idle or Sleep modes. RCON also contains the IPEN bit which enables interrupt priorities.",
    "REGISTER 9-13: RCON: RESET CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R-1. R/W-0, 5 = R-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = SBOREN. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0\nbit 7\nIPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16CXXX Compatibility mode)\nbit 6\nSBOREN: BOR Software Enable bit\nFor details of bit operation, see Register 4-1.\nbit 5 Unimplemented: Read as ' 0 '\nbit 4 RI:\nRESET Instruction Flag bit\nFor details of bit operation, see Register 4-1.\nbit 3",
    "REGISTER 9-13: RCON: RESET CONTROL REGISTER\nTO: Watchdog Time-out Flag bit\nFor details of bit operation, see Register 4-1.\nbit 2\nPD: Power-down Detection Flag bit\nFor details of bit operation, see Register 4-1.\nbit 1\nPOR: Power-on Reset Status bit\nFor details of bit operation, see Register 4-1.\nbit 0\nBOR: Brown-out Reset Status bit\nFor details of bit operation, see Register 4-1.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "9.6 INTn Pin Interrupts\nExternal  interrupts  on  the  RB0/INT0,  RB1/INT1  and RB2/INT2 pins are edge-triggered. If the corresponding INTEDGx bit in the INTCON2 register is set (= 1 ), the interrupt is triggered by a rising edge; if the bit is clear, the trigger is on the falling edge. When a valid edge appears on the RBx/INTx pin, the corresponding flag bit INTxF is set. This interrupt can be disabled by clearing the corresponding enable bit INTxE. Flag bit INTxF must  be  cleared  in  software  in  the  Interrupt  Service Routine before re-enabling the interrupt.\nAll external  interrupts  (INT0,  INT1  and  INT2)  can wake-up  the  processor  from  the  power  managed modes, if bit INTxE was set prior to going into power managed  modes.  If  the  Global  Interrupt  Enable  bit, GIE, is set, the processor will branch to the interrupt vector following wake-up.",
    "9.6 INTn Pin Interrupts\nInterrupt priority for INT1 and INT2 is determined by the value  contained  in  the  interrupt  priority  bits,  INT1IP (INTCON3<6>) and INT2IP (INTCON3<7>). There is no priority bit associated with INT0. It is always a high priority interrupt source.",
    "9.7 TMR0 Interrupt\nIn 8-bit mode (which is the default), an overflow in the TMR0 register (FFh \uf0ae 00h) will set flag bit TMR0IF. In 16-bit mode, an overflow in the TMR0H:TMR0L register pair (FFFFh \uf0ae\uf020 0000h) will set TMR0IF. The interrupt can be enabled/disabled by setting/clearing enable bit TMR0IE (INTCON<5>). Interrupt priority for Timer0 is determined  by  the  value  contained  in  the  interrupt priority bit, TMR0IP (INTCON2<2>). See Section 11.0 'Timer0  Module' for  further  details  on  the  Timer0 module.",
    "9.8 PORTB Interrupt-on-Change\nAn input change on PORTB<7:4> sets flag bit, RBIF (INTCON<0>). The interrupt can be enabled/disabled by  setting/clearing  enable  bit,  RBIE  (INTCON<3>). Interrupt  priority  for  PORTB  interrupt-on-change  is determined  by  the  value  contained  in  the  interrupt priority bit, RBIP (INTCON2<0>).",
    "9.9 Context Saving During Interrupts\nDuring interrupts, the return PC address is saved on the stack. Additionally, the WREG, STATUS and BSR registers are saved on the fast return stack. If a fast return  from  interrupt  is  not  used  (See Section 6.3 'Data Memory Organization' ), the user may need to save the WREG, STATUS and BSR registers on entry to  the  Interrupt  Service  Routine.  Depending  on  the user's application, other registers may also need to be saved.  Example 9-1  saves  and  restores  the  WREG, STATUS and BSR registers during an Interrupt Service Routine.",
    "SAVING STATUS, WREG AND BSR REGISTERS IN RAM\nMOVWF MOVFF MOVFF ; ;, 1 = W_TEMP STATUS, STATUS_TEMP BSR, BSR_TEMP. MOVWF MOVFF MOVFF ; ;, 2 = ; W_TEMP is in virtual bank ; STATUS_TEMP located anywhere ; BSR_TMEP located anywhere. USER ;, 1 = ISR CODE. USER ;, 2 = . MOVFF, 1 = BSR_TEMP, BSR. MOVFF, 2 = ; Restore BSR. MOVF, 1 = W_TEMP, W. MOVF, 2 = ; Restore WREG. MOVFF, 1 = STATUS_TEMP, STATUS. MOVFF, 2 = ; Restore STATUS",
    "10.0 I/O PORTS\nDepending on the device selected and features enabled, there are up to five ports available. Some pins of  the  I/O  ports  are  multiplexed  with  an  alternate function from the peripheral features on the device. In general, when a peripheral is enabled, that pin may not be used as a general purpose I/O pin.\nEach port has three registers for its operation. These registers are:\n\u00b7 TRIS register (data direction register)\n\u00b7 PORT register (reads the levels on the pins of the device)\n\u00b7 LAT register (output latch)\nThe Data Latch register (LAT) is useful for read-modifywrite  operations  on  the  value  that  the  I/O  pins  are driving.\nA simplified  model  of  a  generic  I/O  port,  without  the interfaces to other peripherals, is shown in Figure 10-1.",
    "10.1 PORTA, TRISA and LATA Registers\nPORTA  is  an 8-bit wide, bidirectional port. The corresponding data direction register is TRISA. Setting a TRISA bit (= 1 ) will make the corresponding PORTA pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISA bit (= 0 ) will make the corresponding PORTA pin an output (i.e., put the contents of the output latch on the selected pin).\nReading the PORTA register reads the status of the pins, whereas writing to it, will write to the port latch.\nThe  Data  Latch register (LATA)  is also memory mapped.  Read-modify-write  operations  on  the  LATA register  read  and  write  the  latched  output  value  for PORTA.",
    "10.1 PORTA, TRISA and LATA Registers\nThe  RA4  pin  is  multiplexed  with  the  Timer0  module clock input to become the RA4/T0CKI pin. Pins RA6 and RA7 are multiplexed with the main oscillator pins; they are enabled as oscillator or I/O pins by the selection of the main oscillator in Configuration Register 1H (see Section 24.1  'Configuration  Bits' for  details). When they are not used as port pins, RA6 and RA7 and their associated TRIS and LAT bits are read as ' 0 '.\nThe  other  PORTA  pins  are  multiplexed  with  analog inputs,  the  analog  VREF+  and  VREF-  inputs  and  the comparator voltage reference output. The operation of pins  RA3:RA0  and  RA5  as  A/D  converter  inputs  is selected  by  clearing/setting  the  control  bits  in  the ADCON1 register (A/D Control Register 1).\nNote:, 1 = On a Power-on Reset, RA5 and RA3:RA0 are configured as analog inputs and read as ' 0 '. RA4 is configured as a digital input.",
    "10.1 PORTA, TRISA and LATA Registers\nAll  other  PORTA  pins  have  TTL  input  levels  and  full CMOS output drivers.\nThe  TRISA  register  controls  the  direction  of  the  RA pins, even when they are being used as analog inputs. The user must ensure the bits in the TRISA register are maintained set when using them as analog inputs.",
    "EXAMPLE 10-1: INITIALIZING PORTA\nCLRF, 1 = PORTA. CLRF, 2 = ; Initialize PORTA by ; clearing output ; data latches. CLRF, 1 = LATA. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF MOVWF MOVWF MOVLW, 1 = 0Fh ADCON1 07h CMCON 0CFh. MOVLW MOVWF MOVWF MOVWF MOVLW, 2 = ; Configure A/D ; for digital inputs ; Configure comparators ; for digital input ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISA. MOVWF, 2 = ; Set RA<3:0> as inputs ; RA<5:4> as outputs",
    "TABLE 10-1: PORTA I/O SUMMARY\nRA0/AN0/CVREF, Function = RA0. RA0/AN0/CVREF, I/O = OUT. RA0/AN0/CVREF, TRIS = 0. RA0/AN0/CVREF, Buffer = DIG. RA0/AN0/CVREF, Description = LATA<0> data output.. RA0/AN0/CVREF, Function = RA0. RA0/AN0/CVREF, I/O = IN. RA0/AN0/CVREF, TRIS = 1. RA0/AN0/CVREF, Buffer = TTL. RA0/AN0/CVREF, Description = PORTA<0> data input.. RA0/AN0/CVREF, Function = AN0. RA0/AN0/CVREF, I/O = IN. RA0/AN0/CVREF, TRIS = 1. RA0/AN0/CVREF, Buffer = ANA. RA0/AN0/CVREF, Description = A/D input channel 0. Enabled on",
    "TABLE 10-1: PORTA I/O SUMMARY\nPOR, this analog input overrides the digital input (read as clear - low level).. RA0/AN0/CVREF, Function = CVREF. RA0/AN0/CVREF, I/O = OUT. RA0/AN0/CVREF, TRIS = x. RA0/AN0/CVREF, Buffer = ANA. RA0/AN0/CVREF, Description = Comparator voltage reference analog output. Enabling this analog output overrides the digital I/O (read as clear - low level).. RA1/AN1, Function = RA1. RA1/AN1, I/O = OUT. RA1/AN1, TRIS = 0. RA1/AN1, Buffer = DIG. RA1/AN1, Description = LATA<1> data output.. RA1/AN1, Function = RA1. RA1/AN1, I/O = IN. RA1/AN1, TRIS = 1. RA1/AN1, Buffer = TTL. RA1/AN1, Description = PORTA<1> data",
    "TABLE 10-1: PORTA I/O SUMMARY\ninput.. RA1/AN1, Function = AN1. RA1/AN1, I/O = IN. RA1/AN1, TRIS = 1. RA1/AN1, Buffer = ANA. RA1/AN1, Description = A/D input channel 1. Enabled on POR, this analog input overrides the digital input (read as clear - low level).. RA2/AN2/VREF-, Function = RA2. RA2/AN2/VREF-, I/O = OUT. RA2/AN2/VREF-, TRIS = 0. RA2/AN2/VREF-, Buffer = DIG. RA2/AN2/VREF-, Description = LATA<2> data output.. RA2/AN2/VREF-, Function = RA2. RA2/AN2/VREF-, I/O = IN. RA2/AN2/VREF-, TRIS = 1. RA2/AN2/VREF-, Buffer = TTL. RA2/AN2/VREF-, Description = PORTA<2> data",
    "TABLE 10-1: PORTA I/O SUMMARY\ninput.. RA2/AN2/VREF-, Function = AN2. RA2/AN2/VREF-, I/O = IN. RA2/AN2/VREF-, TRIS = 1. RA2/AN2/VREF-, Buffer = ANA. RA2/AN2/VREF-, Description = A/D input channel 2. Enabled on POR, this analog input overrides the digital input (read as clear - low level).. RA2/AN2/VREF-, Function = VREF-. RA2/AN2/VREF-, I/O = IN. RA2/AN2/VREF-, TRIS = 1. RA2/AN2/VREF-, Buffer = ANA. RA2/AN2/VREF-, Description = A/D and comparator negative voltage analog input.. RA3/AN3/VREF+, Function = RA3. RA3/AN3/VREF+, I/O = OUT. RA3/AN3/VREF+, TRIS = 0.",
    "TABLE 10-1: PORTA I/O SUMMARY\nRA3/AN3/VREF+, Buffer = DIG. RA3/AN3/VREF+, Description = LATA<3> data output.. RA3/AN3/VREF+, Function = RA3. RA3/AN3/VREF+, I/O = IN. RA3/AN3/VREF+, TRIS = 1. RA3/AN3/VREF+, Buffer = TTL. RA3/AN3/VREF+, Description = PORTA<3> data input.. RA3/AN3/VREF+, Function = AN3. RA3/AN3/VREF+, I/O = IN. RA3/AN3/VREF+, TRIS = 1. RA3/AN3/VREF+, Buffer = ANA. RA3/AN3/VREF+, Description = A/D input channel 3. Enabled on POR, this analog input overrides the digital input (read as clear - low level).. RA3/AN3/VREF+, Function = VREF+. RA3/AN3/VREF+,",
    "TABLE 10-1: PORTA I/O SUMMARY\nI/O = IN. RA3/AN3/VREF+, TRIS = 1. RA3/AN3/VREF+, Buffer = ANA. RA3/AN3/VREF+, Description = A/D and comparator positive voltage analog input.. RA4/T0CKI, Function = RA4. RA4/T0CKI, I/O = OUT. RA4/T0CKI, TRIS = 0. RA4/T0CKI, Buffer = DIG. RA4/T0CKI, Description = LATA<4> data output.. RA4/T0CKI, Function = RA4. RA4/T0CKI, I/O = IN. RA4/T0CKI, TRIS = 1. RA4/T0CKI, Buffer = TTL. RA4/T0CKI, Description = PORTA<4> data input.. RA4/T0CKI, Function = T0CKI. RA4/T0CKI, I/O = IN. RA4/T0CKI, TRIS = 1. RA4/T0CKI, Buffer = ST.",
    "TABLE 10-1: PORTA I/O SUMMARY\nRA4/T0CKI, Description = Timer0 clock input.. RA5/AN4/SS/HLVDIN, Function = RA5. RA5/AN4/SS/HLVDIN, I/O = OUT. RA5/AN4/SS/HLVDIN, TRIS = 0. RA5/AN4/SS/HLVDIN, Buffer = DIG. RA5/AN4/SS/HLVDIN, Description = LATA<5> data output.. RA5/AN4/SS/HLVDIN, Function = RA5. RA5/AN4/SS/HLVDIN, I/O = IN. RA5/AN4/SS/HLVDIN, TRIS = 1. RA5/AN4/SS/HLVDIN, Buffer = TTL. RA5/AN4/SS/HLVDIN, Description = PORTA<5> data input.. RA5/AN4/SS/HLVDIN, Function = AN4. RA5/AN4/SS/HLVDIN, I/O = IN.",
    "TABLE 10-1: PORTA I/O SUMMARY\nRA5/AN4/SS/HLVDIN, TRIS = 1. RA5/AN4/SS/HLVDIN, Buffer = ANA. RA5/AN4/SS/HLVDIN, Description = A/D input channel 4. Enabled on POR, this analog input overrides the digital input (read as clear - low level).. RA5/AN4/SS/HLVDIN, Function = SS. RA5/AN4/SS/HLVDIN, I/O = IN. RA5/AN4/SS/HLVDIN, TRIS = 1. RA5/AN4/SS/HLVDIN, Buffer = TTL. RA5/AN4/SS/HLVDIN, Description = Slave select input for MSSP.. RA5/AN4/SS/HLVDIN, Function = HLVDIN. RA5/AN4/SS/HLVDIN, I/O = IN. RA5/AN4/SS/HLVDIN, TRIS = 1. RA5/AN4/SS/HLVDIN,",
    "TABLE 10-1: PORTA I/O SUMMARY\nBuffer = ANA. RA5/AN4/SS/HLVDIN, Description = High/Low-Voltage Detect external trip point input.. OSC2/CLKO/RA6, Function = OSC2. OSC2/CLKO/RA6, I/O = OUT. OSC2/CLKO/RA6, TRIS = x. OSC2/CLKO/RA6, Buffer = ANA. OSC2/CLKO/RA6, Description = Output connection, selected by FOSC3:FOSC0 Configuration bits. Enabling OSC2 overrides digital I/O.. OSC2/CLKO/RA6, Function = CLKO. OSC2/CLKO/RA6, I/O = OUT. OSC2/CLKO/RA6, TRIS = x. OSC2/CLKO/RA6, Buffer = DIG. OSC2/CLKO/RA6, Description = Output connection, selected by FOSC3:FOSC0 Configuration bits. Enabling CLKO overrides digital I/O (F OSC/4)..",
    "TABLE 10-1: PORTA I/O SUMMARY\nOSC2/CLKO/RA6, Function = RA6. OSC2/CLKO/RA6, I/O = OUT. OSC2/CLKO/RA6, TRIS = 0. OSC2/CLKO/RA6, Buffer = DIG. OSC2/CLKO/RA6, Description = LATA<6> data output.. OSC2/CLKO/RA6, Function = RA6. OSC2/CLKO/RA6, I/O = IN. OSC2/CLKO/RA6, TRIS = 1. OSC2/CLKO/RA6, Buffer = TTL. OSC2/CLKO/RA6, Description = PORTA<6> data input.. OSC1/CLKI/RA7, Function = OSC1. OSC1/CLKI/RA7, I/O = IN. OSC1/CLKI/RA7, TRIS = x. OSC1/CLKI/RA7, Buffer = ANA. OSC1/CLKI/RA7, Description = Main oscillator input connection, determined",
    "TABLE 10-1: PORTA I/O SUMMARY\nby FOSC3:FOSC0 Configuration bits. Enabling OSC1 overrides digital I/O.. OSC1/CLKI/RA7, Function = CLKI. OSC1/CLKI/RA7, I/O = IN. OSC1/CLKI/RA7, TRIS = x. OSC1/CLKI/RA7, Buffer = ANA. OSC1/CLKI/RA7, Description = Main clock input connection, determined by FOSC3:FOSC0 Configuration bits. Enabling CLKI overrides digital I/O.. OSC1/CLKI/RA7, Function = RA7. OSC1/CLKI/RA7, I/O = OUT. OSC1/CLKI/RA7, TRIS = 0. OSC1/CLKI/RA7, Buffer = DIG. OSC1/CLKI/RA7, Description = LATA<7> data output.. OSC1/CLKI/RA7, Function = RA7. OSC1/CLKI/RA7, I/O = IN.",
    "TABLE 10-1: PORTA I/O SUMMARY\nOSC1/CLKI/RA7, TRIS = 1. OSC1/CLKI/RA7, Buffer = TTL. OSC1/CLKI/RA7, Description = PORTA<7> data input.\nLegend:\nPWR = Power Supply; OUT = Output; IN = Input; ANA = Analog Signal; DIG = Digital Output; ST = Schmitt Buffer Input; TTL = TTL Buffer Input",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nPORTA, Bit 7 = RA7 (1). PORTA, Bit 6 = RA6 (1). PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Reset Values on page = 49. LATA, Bit 7 = LATA7 (1). LATA, Bit 6 = LATA6 (1). LATA, Bit 5 = LATA Data Output Register. LATA, Bit 4 = LATA Data Output Register. LATA, Bit 3 = LATA Data Output Register. LATA, Bit 2 = LATA Data Output Register. LATA, Bit 1 = LATA Data Output Register. LATA, Bit 0 = LATA Data Output Register. LATA, Reset Values on page = 49. TRISA, Bit 7 = TRISA7 (1). TRISA, Bit 6 = TRISA6 (1). TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nRegister. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Reset Values on page = 49. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Reset Values on page = 47. CMCON (2), Bit 7 = C2OUT. CMCON (2), Bit 6 = C1OUT. CMCON (2), Bit 5 = C2INV. CMCON (2), Bit 4 = C1INV. CMCON (2), Bit 3 = CIS. CMCON (2), Bit 2 = CM2. CMCON (2), Bit 1 =",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nCM1. CMCON (2), Bit 0 = CM0. CMCON (2), Reset Values on page = 48. CVRCON (2), Bit 7 = CVREN. CVRCON (2), Bit 6 = CVROE. CVRCON (2), Bit 5 = CVRR. CVRCON (2), Bit 4 = CVRSS. CVRCON (2), Bit 3 = CVR3. CVRCON (2), Bit 2 = CVR2. CVRCON (2), Bit 1 = CVR1. CVRCON (2), Bit 0 = CVR0. CVRCON (2), Reset Values on page = 48\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by PORTA.\nNote 1: RA7:RA6 and their associated latch and data direction bits are enabled as I/O pins based on oscillator configuration; otherwise, they are read as ' 0 '.\n2: These registers are unimplemented on PIC18F2X8X devices.",
    "10.2 PORTB, TRISB and LATB Registers\nPORTB  is  an  8-bit wide, bidirectional port. The corresponding data direction register is TRISB. Setting a TRISB bit (= 1 ) will make the corresponding PORTB pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISB bit (= 0 ) will make the corresponding PORTB pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATB)  is also memory mapped.  Read-modify-write  operations  on  the  LATB register  read  and  write  the  latched  output  value  for PORTB.\nPins RB2 through RB3 are multiplexed with the ECAN peripheral. Refer to Section 23.0 'ECAN\u2122 Technology' for proper  settings  of  TRISB  when  CAN  is enabled.",
    "EXAMPLE 10-2: INITIALIZING PORTB\nCLRF, 1 = PORTB. CLRF, 2 = ; Initialize PORTB by ; clearing output ; data latches. CLRF, 1 = LATB. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0Eh. MOVLW, 2 = ; Set RB<4:0> as. MOVLW, 1 = 0CFh. MOVLW, 2 = ; PBADEN is set) ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISB. MOVWF, 2 = ; Set RB<3:0> as inputs ; RB<5:4> as outputs ; RB<7:6> as inputs\nEach of the PORTB pins has a weak internal pull-up. A single control bit  can  turn  on  all  the  pull-ups.  This  is performed by clearing bit RBPU (INTCON2<7>). The weak pull-up is automatically turned off when the port pin  is configured  as  an  output.  The  pull-ups  are disabled on all device Resets.\nNote:",
    "EXAMPLE 10-2: INITIALIZING PORTB\nOn  a  Power-on  Reset,  RB4:RB0  are configured as analog inputs by default and read  as  ' 0 ';  RB7:RB5  are  configured  as digital inputs.\nBy  programming  the  Configuration  bit, PBADEN (CONFIG3H<1>), RB4:RB0 will alternatively be configured as digital inputs on POR.\nFour of the PORTB pins (RB7:RB4) have an interrupton-change feature. Only pins configured as inputs can cause  this  interrupt  to  occur  (i.e.,  any  RB7:RB4  pin configured as an output is excluded from the interrupton-change comparison). The input pins (of RB7:RB4) are  compared  with  the  old  value  latched  on  the  last read of PORTB. The 'mismatch' outputs of RB7:RB4 are  ORed together to generate the RB Port Change Interrupt with Flag bit, RBIF (INTCON<0>).\nThis  interrupt  can  wake  the  device  from  Sleep.  The user,  in  the  Interrupt  Service  Routine,  can  clear  the interrupt in the following manner:",
    "EXAMPLE 10-2: INITIALIZING PORTB\na) Any  read  or  write  of  PORTB  (except  with  the MOVFF  (ANY), PORTB instruction).  This  will end the mismatch condition.\nb) Clear flag bit RBIF.\nA mismatch condition will continue to set flag bit RBIF. Reading PORTB will end the mismatch condition and allow flag bit RBIF to be cleared.\nThe interrupt-on-change  feature  is  recommended  for wake-up on key depression operation and operations where PORTB is only used for the interrupt-on-change feature. Polling of PORTB is not recommended while using the interrupt-on-change feature.",
    "TABLE 10-3: PORTB I/O SUMMARY\nRB0/INT0/FLT0/AN10, Function = RB0. RB0/INT0/FLT0/AN10, I/O = OUT. RB0/INT0/FLT0/AN10, TRIS = 0. RB0/INT0/FLT0/AN10, Buffer = DIG. RB0/INT0/FLT0/AN10, Description = LATB<0> data output.. RB0/INT0/FLT0/AN10, Function = RB0. RB0/INT0/FLT0/AN10, I/O = IN. RB0/INT0/FLT0/AN10, TRIS = 1. RB0/INT0/FLT0/AN10, Buffer = TTL. RB0/INT0/FLT0/AN10, Description = PORTB<0> data input. Weak pull-up available only in this mode.. RB0/INT0/FLT0/AN10, Function = INT0. RB0/INT0/FLT0/AN10, I/O = IN.",
    "TABLE 10-3: PORTB I/O SUMMARY\nRB0/INT0/FLT0/AN10, TRIS = 1. RB0/INT0/FLT0/AN10, Buffer = ST. RB0/INT0/FLT0/AN10, Description = External interrupt 0 input.. RB0/INT0/FLT0/AN10, Function = FLT0. RB0/INT0/FLT0/AN10, I/O = IN. RB0/INT0/FLT0/AN10, TRIS = 1. RB0/INT0/FLT0/AN10, Buffer = ST. RB0/INT0/FLT0/AN10, Description = Enhanced PWM Fault input.. RB0/INT0/FLT0/AN10, Function = AN10. RB0/INT0/FLT0/AN10, I/O = IN. RB0/INT0/FLT0/AN10, TRIS = 1. RB0/INT0/FLT0/AN10, Buffer = ANA. RB0/INT0/FLT0/AN10, Description = A/D input channel",
    "TABLE 10-3: PORTB I/O SUMMARY\n10. Enabled on POR, this analog input overrides the digital input (read as clear - low level).. RB1/INT1/AN8, Function = RB1. RB1/INT1/AN8, I/O = OUT. RB1/INT1/AN8, TRIS = 0. RB1/INT1/AN8, Buffer = DIG. RB1/INT1/AN8, Description = LATB<1> data output.. RB1/INT1/AN8, Function = RB1. RB1/INT1/AN8, I/O = IN. RB1/INT1/AN8, TRIS = 1. RB1/INT1/AN8, Buffer = TTL. RB1/INT1/AN8, Description = PORTB<1> data input. Weak pull-up available only in this mode.. RB1/INT1/AN8, Function = INT1. RB1/INT1/AN8, I/O = IN. RB1/INT1/AN8, TRIS = 1. RB1/INT1/AN8, Buffer = ST.",
    "TABLE 10-3: PORTB I/O SUMMARY\nRB1/INT1/AN8, Description = External interrupt 1 input.. RB1/INT1/AN8, Function = AN8. RB1/INT1/AN8, I/O = IN. RB1/INT1/AN8, TRIS = 1. RB1/INT1/AN8, Buffer = ANA. RB1/INT1/AN8, Description = A/D input channel 8. Enabled on POR, this analog input overrides the digital input (read as clear - low level).. RB2/INT2/CANTX, Function = RB2. RB2/INT2/CANTX, I/O = OUT. RB2/INT2/CANTX, TRIS = x. RB2/INT2/CANTX, Buffer = DIG. RB2/INT2/CANTX, Description = LATB<2> data output.. RB2/INT2/CANTX, Function = RB2. RB2/INT2/CANTX, I/O = IN. RB2/INT2/CANTX, TRIS = 1.",
    "TABLE 10-3: PORTB I/O SUMMARY\nRB2/INT2/CANTX, Buffer = TTL. RB2/INT2/CANTX, Description = PORTB<2> data input. Weak pull-up available only in this mode.. RB2/INT2/CANTX, Function = INT2. RB2/INT2/CANTX, I/O = IN. RB2/INT2/CANTX, TRIS = 1. RB2/INT2/CANTX, Buffer = ST. RB2/INT2/CANTX, Description = External interrupt 2 input.. RB2/INT2/CANTX, Function = CANTX. RB2/INT2/CANTX, I/O = OUT. RB2/INT2/CANTX, TRIS = 1. RB2/INT2/CANTX, Buffer = DIG. RB2/INT2/CANTX, Description = CAN transmit signal output. The CAN interface overrides the TRIS<2> control when enabled.. RB3/CANRX, Function = RB3. RB3/CANRX, I/O = OUT.",
    "TABLE 10-3: PORTB I/O SUMMARY\nRB3/CANRX, TRIS = 0. RB3/CANRX, Buffer = DIG. RB3/CANRX, Description = LATB<3> data output.. RB3/CANRX, Function = RB3. RB3/CANRX, I/O = IN. RB3/CANRX, TRIS = 1. RB3/CANRX, Buffer = TTL. RB3/CANRX, Description = PORTB<3> data input. Weak pull-up available only in this mode.. RB3/CANRX, Function = CANRX. RB3/CANRX, I/O = IN. RB3/CANRX, TRIS = 1. RB3/CANRX, Buffer = ST. RB3/CANRX, Description = CAN receive signal input. Pin must be configured as a digital input by setting TRISB<3>.. RB4/KBI0/AN9, Function = RB4. RB4/KBI0/AN9, I/O = OUT. RB4/KBI0/AN9, TRIS = 0.",
    "TABLE 10-3: PORTB I/O SUMMARY\nRB4/KBI0/AN9, Buffer = DIG. RB4/KBI0/AN9, Description = LATB<4> data output.. RB4/KBI0/AN9, Function = RB4. RB4/KBI0/AN9, I/O = IN. RB4/KBI0/AN9, TRIS = 1. RB4/KBI0/AN9, Buffer = TTL. RB4/KBI0/AN9, Description = PORTB<4> data input. Weak pull-up available only in this mode.. RB4/KBI0/AN9, Function = KBI0. RB4/KBI0/AN9, I/O = IN. RB4/KBI0/AN9, TRIS = 1. RB4/KBI0/AN9, Buffer = TTL. RB4/KBI0/AN9, Description = Interrupt-on-pin change.. RB4/KBI0/AN9, Function = AN9. RB4/KBI0/AN9, I/O = IN.",
    "TABLE 10-3: PORTB I/O SUMMARY\nRB4/KBI0/AN9, TRIS = 1. RB4/KBI0/AN9, Buffer = ANA. RB4/KBI0/AN9, Description = A/D input channel 9. Enabled on POR, this analog input overrides the digital input (read as clear - low level).. RB5/KBI1/PGM, Function = RB5. RB5/KBI1/PGM, I/O = OUT. RB5/KBI1/PGM, TRIS = 0. RB5/KBI1/PGM, Buffer = DIG. RB5/KBI1/PGM, Description = LATB<5> data output.. RB5/KBI1/PGM, Function = RB5. RB5/KBI1/PGM, I/O = IN. RB5/KBI1/PGM, TRIS = 1. RB5/KBI1/PGM, Buffer = TTL. RB5/KBI1/PGM, Description = PORTB<5> data input. Weak pull-up available only in this mode..",
    "TABLE 10-3: PORTB I/O SUMMARY\nRB5/KBI1/PGM, Function = KBI1. RB5/KBI1/PGM, I/O = IN. RB5/KBI1/PGM, TRIS = 1. RB5/KBI1/PGM, Buffer = TTL. RB5/KBI1/PGM, Description = Interrupt-on-pin change.. RB5/KBI1/PGM, Function = PGM. RB5/KBI1/PGM, I/O = IN. RB5/KBI1/PGM, TRIS = x. RB5/KBI1/PGM, Buffer = ST. RB5/KBI1/PGM, Description = Low-Voltage Programming mode entry (ICSP\u2122). Enabling this function overrides digital output.. RB6/KBI2/PGC, Function = RB6. RB6/KBI2/PGC, I/O = OUT. RB6/KBI2/PGC, TRIS = 0. RB6/KBI2/PGC, Buffer = DIG.",
    "TABLE 10-3: PORTB I/O SUMMARY\nRB6/KBI2/PGC, Description = LATB<6> data output.. RB6/KBI2/PGC, Function = RB6. RB6/KBI2/PGC, I/O = IN. RB6/KBI2/PGC, TRIS = 1. RB6/KBI2/PGC, Buffer = TTL. RB6/KBI2/PGC, Description = PORTB<6> data input. Weak pull-up available only in this mode.. RB6/KBI2/PGC, Function = KBI2. RB6/KBI2/PGC, I/O = IN. RB6/KBI2/PGC, TRIS = 1. RB6/KBI2/PGC, Buffer = TTL. RB6/KBI2/PGC, Description = Interrupt-on-pin change.. RB6/KBI2/PGC, Function = PGC. RB6/KBI2/PGC, I/O = IN. RB6/KBI2/PGC, TRIS = x.",
    "TABLE 10-3: PORTB I/O SUMMARY\nRB6/KBI2/PGC, Buffer = ST. RB6/KBI2/PGC, Description = Low-Voltage Programming mode entry (ICSP) clock input.. RB7/KBI3/PGD, Function = RB7. RB7/KBI3/PGD, I/O = OUT. RB7/KBI3/PGD, TRIS = 0. RB7/KBI3/PGD, Buffer = DIG. RB7/KBI3/PGD, Description = LATB<7> data output.. RB7/KBI3/PGD, Function = RB7. RB7/KBI3/PGD, I/O = IN. RB7/KBI3/PGD, TRIS = 1. RB7/KBI3/PGD, Buffer = TTL. RB7/KBI3/PGD, Description = PORTB<7> data input. Weak pull-up available only in this mode.. RB7/KBI3/PGD, Function = KBI3. RB7/KBI3/PGD, I/O =",
    "TABLE 10-3: PORTB I/O SUMMARY\nIN. RB7/KBI3/PGD, TRIS = 1. RB7/KBI3/PGD, Buffer = TTL. RB7/KBI3/PGD, Description = Interrupt-on-pin change.. RB7/KBI3/PGD, Function = PGD. RB7/KBI3/PGD, I/O = OUT. RB7/KBI3/PGD, TRIS = x. RB7/KBI3/PGD, Buffer = DIG. RB7/KBI3/PGD, Description = Low-Voltage Programming mode entry (ICSP) clock output.. RB7/KBI3/PGD, Function = PGD. RB7/KBI3/PGD, I/O = IN. RB7/KBI3/PGD, TRIS = x. RB7/KBI3/PGD, Buffer = ST. RB7/KBI3/PGD, Description = Low-Voltage Programming mode entry (ICSP) clock input.\nLegend:",
    "TABLE 10-3: PORTB I/O SUMMARY\nPWR = Power Supply; OUT = Output; IN = Input; ANA = Analog Signal; DIG = Digital Output; ST = Schmitt Buffer Input; TTL - TTL Buffer Input",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nPORTB, Bit 7 = RB7. PORTB, Bit 6 = RB6. PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 = RB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTB, Reset Values on page = 49. LATB, Bit 7 = LATB Data Output Register (Read and Write to Data Latch). LATB, Bit 6 = LATB Data Output Register (Read and Write to Data Latch). LATB, Bit 5 = LATB Data Output Register (Read and Write to Data Latch). LATB, Bit 4 = LATB Data Output Register (Read and Write to Data Latch). LATB, Bit 3 = LATB Data Output Register (Read and Write to Data Latch). LATB, Bit 2 = LATB Data Output Register (Read and Write to Data Latch). LATB, Bit 1 = LATB Data Output Register (Read and Write to Data Latch). LATB, Bit 0 =",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nLATB Data Output Register (Read and Write to Data Latch). LATB, Reset Values on page = 49. TRISB, Bit 7 = PORTB Data Direction Control Register. TRISB, Bit 6 = PORTB Data Direction Control Register. TRISB, Bit 5 = PORTB Data Direction Control Register. TRISB, Bit 4 = PORTB Data Direction Control Register. TRISB, Bit 3 = PORTB Data Direction Control Register. TRISB, Bit 2 = PORTB Data Direction Control Register. TRISB, Bit 1 = PORTB Data Direction Control Register. TRISB, Bit 0 = PORTB Data Direction Control Register. TRISB, Reset Values on page = 49. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. INTCON2, Bit 7 =",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nRBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Reset Values on page = 46. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Reset Values on page = 46. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1,",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nBit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Reset Values on page = 47\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used by PORTB.",
    "10.3 PORTC, TRISC and LATC Registers\nPORTC  is  an  8-bit wide, bidirectional port. The corresponding data direction register is TRISC. Setting a TRISC bit (= 1 ) will make the corresponding PORTC pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISC bit (= 0 ) will make the corresponding PORTC pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATC)  is also memory mapped.  Read-modify-write  operations  on  the  LATC register  read  and  write  the  latched  output  value  for PORTC.\nPORTC is multiplexed with several peripheral functions (Table 10-5).  The  pins  have  Schmitt  Trigger  input buffers.\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTC pin. Some peripherals override the TRIS bit to make a pin an output, while other peripherals override the TRIS bit to make a pin an input. The user should refer to the corresponding peripheral section for the correct TRIS bit settings.\nNote:",
    "10.3 PORTC, TRISC and LATC Registers\nOn  a  Power-on  Reset,  these  pins  are configured as digital inputs.\nThe  contents  of  the  TRISC  register  are  affected  by peripheral  overrides.  Reading  TRISC  always  returns the current contents, even though a peripheral device may be overriding one or more of the pins.",
    "EXAMPLE 10-3: INITIALIZING PORTC\nCLRF, 1 = PORTC. CLRF, 2 = ; Initialize PORTC by ; clearing output ; data latches. CLRF, 1 = LATC. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISC. MOVWF, 2 = ; Set RC<3:0> as inputs ; RC<5:4> as outputs ; RC<7:6> as inputs",
    "TABLE 10-5: PORTC I/O SUMMARY\nRC0/T1OSO/ T13CKI, Function = RC0. RC0/T1OSO/ T13CKI, I/O = OUT. RC0/T1OSO/ T13CKI, TRIS = 0. RC0/T1OSO/ T13CKI, Buffer = DIG. RC0/T1OSO/ T13CKI, Description = LATC<0> data output.. RC0/T1OSO/ T13CKI, Function = RC0. RC0/T1OSO/ T13CKI, I/O = IN. RC0/T1OSO/ T13CKI, TRIS = 1. RC0/T1OSO/ T13CKI, Buffer = ST. RC0/T1OSO/ T13CKI, Description = PORTC<0> data input.. RC0/T1OSO/ T13CKI, Function = T1OSO. RC0/T1OSO/ T13CKI, I/O = OUT. RC0/T1OSO/ T13CKI, TRIS = x. RC0/T1OSO/ T13CKI, Buffer = ANA. RC0/T1OSO/",
    "TABLE 10-5: PORTC I/O SUMMARY\nT13CKI, Description = Timer1 oscillator output - overrides the TRIS<0> control when enabled.. RC0/T1OSO/ T13CKI, Function = T13CKI. RC0/T1OSO/ T13CKI, I/O = IN. RC0/T1OSO/ T13CKI, TRIS = 1. RC0/T1OSO/ T13CKI, Buffer = ST. RC0/T1OSO/ T13CKI, Description = Timer1/Timer3 clock input.. RC1/T1OSI, Function = RC1. RC1/T1OSI, I/O = OUT. RC1/T1OSI, TRIS = 0. RC1/T1OSI, Buffer = DIG. RC1/T1OSI, Description = LATC<1> data output.. RC1/T1OSI, Function = RC1. RC1/T1OSI, I/O = IN. RC1/T1OSI, TRIS = 1. RC1/T1OSI, Buffer = ST. RC1/T1OSI, Description = PORTC<1> data",
    "TABLE 10-5: PORTC I/O SUMMARY\ninput.. RC1/T1OSI, Function = T1OSI. RC1/T1OSI, I/O = IN. RC1/T1OSI, TRIS = x. RC1/T1OSI, Buffer = ANA. RC1/T1OSI, Description = Timer1 oscillator input - overrides the TRIS<1> control when enabled.. RC2/CCP1, Function = RC2. RC2/CCP1, I/O = OUT. RC2/CCP1, TRIS = 0. RC2/CCP1, Buffer = DIG. RC2/CCP1, Description = LATC<2> data output.. RC2/CCP1, Function = RC2. RC2/CCP1, I/O = IN. RC2/CCP1, TRIS = 1. RC2/CCP1, Buffer = ST. RC2/CCP1, Description = PORTC<2> data input.. RC2/CCP1, Function = CCP1. RC2/CCP1, I/O = OUT.",
    "TABLE 10-5: PORTC I/O SUMMARY\nRC2/CCP1, TRIS = 0. RC2/CCP1, Buffer = DIG. RC2/CCP1, Description = CCP1 compare output.. RC2/CCP1, Function = CCP1. RC2/CCP1, I/O = IN. RC2/CCP1, TRIS = 1. RC2/CCP1, Buffer = ST. RC2/CCP1, Description = CCP1 capture input.. RC3/SCK/SCL, Function = RC3. RC3/SCK/SCL, I/O = OUT. RC3/SCK/SCL, TRIS = 0. RC3/SCK/SCL, Buffer = DIG. RC3/SCK/SCL, Description = LATC<3> data output.. RC3/SCK/SCL, Function = RC3. RC3/SCK/SCL, I/O = IN. RC3/SCK/SCL, TRIS = 1. RC3/SCK/SCL, Buffer = ST. RC3/SCK/SCL,",
    "TABLE 10-5: PORTC I/O SUMMARY\nDescription = PORTC<3> data input.. RC3/SCK/SCL, Function = SCK. RC3/SCK/SCL, I/O = OUT. RC3/SCK/SCL, TRIS = 0. RC3/SCK/SCL, Buffer = DIG. RC3/SCK/SCL, Description = SPI clock output (MSSP module) - must have TRIS set to ' 1 ' to allow the MSSP module to control the bidirectional communication.. RC3/SCK/SCL, Function = SCK. RC3/SCK/SCL, I/O = IN. RC3/SCK/SCL, TRIS = 1. RC3/SCK/SCL, Buffer = ST. RC3/SCK/SCL, Description = SPI clock input (MSSP module).. RC3/SCK/SCL, Function = SCL. RC3/SCK/SCL, I/O = OUT. RC3/SCK/SCL, TRIS = 0. RC3/SCK/SCL, Buffer =",
    "TABLE 10-5: PORTC I/O SUMMARY\nDIG. RC3/SCK/SCL, Description = I 2 C\u2122/SM bus clock output (MSSP module) - must have TRIS set to ' 1 ' to allow the MSSP module to control the bidirectional communication.. RC3/SCK/SCL, Function = SCL. RC3/SCK/SCL, I/O = IN. RC3/SCK/SCL, TRIS = 1. RC3/SCK/SCL, Buffer = I 2 C/SMB. RC3/SCK/SCL, Description = I 2 C/SM bus clock input.. RC4/SDI/SDA, Function = RC4. RC4/SDI/SDA, I/O = OUT. RC4/SDI/SDA, TRIS = 0. RC4/SDI/SDA, Buffer = DIG. RC4/SDI/SDA, Description = LATC<4> data output.. RC4/SDI/SDA, Function = RC4. RC4/SDI/SDA, I/O = IN.",
    "TABLE 10-5: PORTC I/O SUMMARY\nRC4/SDI/SDA, TRIS = 1. RC4/SDI/SDA, Buffer = ST. RC4/SDI/SDA, Description = PORTC<4> data input.. RC4/SDI/SDA, Function = SDI. RC4/SDI/SDA, I/O = IN. RC4/SDI/SDA, TRIS = 1. RC4/SDI/SDA, Buffer = ST. RC4/SDI/SDA, Description = SPI data input (MSSP module).. RC4/SDI/SDA, Function = SDA. RC4/SDI/SDA, I/O = OUT. RC4/SDI/SDA, TRIS = 1. RC4/SDI/SDA, Buffer = DIG. RC4/SDI/SDA, Description = I 2 C/SM bus data output (MSSP module) - must have TRIS set to ' 1 ' to allow the MSSP module to control the bidirectional communication.. RC4/SDI/SDA, Function = SDA.",
    "TABLE 10-5: PORTC I/O SUMMARY\nRC4/SDI/SDA, I/O = IN. RC4/SDI/SDA, TRIS = 1. RC4/SDI/SDA, Buffer = I 2 C/SMB. RC4/SDI/SDA, Description = I 2 C/SM bus data input (MSSP module) - must have TRIS set to ' 1 ' to allow the MSSP module to control the bidirectional communication.. RC5/SDO, Function = RC5. RC5/SDO, I/O = OUT. RC5/SDO, TRIS = 0. RC5/SDO, Buffer = DIG. RC5/SDO, Description = LATC<5> data output.. RC5/SDO, Function = RC5. RC5/SDO, I/O = IN. RC5/SDO, TRIS = 1. RC5/SDO, Buffer = ST. RC5/SDO, Description = PORTC<5> data input.. RC5/SDO, Function = SDO. RC5/SDO, I/O = OUT.",
    "TABLE 10-5: PORTC I/O SUMMARY\nRC5/SDO, TRIS = 0. RC5/SDO, Buffer = DIG. RC5/SDO, Description = SPI data output (MSSP module).. RC6/TX/CK, Function = RC6. RC6/TX/CK, I/O = OUT. RC6/TX/CK, TRIS = 0. RC6/TX/CK, Buffer = DIG. RC6/TX/CK, Description = LATC<6> data output.. RC6/TX/CK, Function = RC6. RC6/TX/CK, I/O = IN. RC6/TX/CK, TRIS = 1. RC6/TX/CK, Buffer = ST. RC6/TX/CK, Description = PORTC<6> data input.. RC6/TX/CK, Function = TX. RC6/TX/CK, I/O = OUT. RC6/TX/CK, TRIS = 0. RC6/TX/CK, Buffer = DIG. RC6/TX/CK, Description = EUSART data output.. RC6/TX/CK, Function =",
    "TABLE 10-5: PORTC I/O SUMMARY\nCK. RC6/TX/CK, I/O = OUT. RC6/TX/CK, TRIS = 1. RC6/TX/CK, Buffer = DIG. RC6/TX/CK, Description = EUSART synchronous clock output - must have TRIS set to ' 1 ' to enable EUSART to control the bidirectional communication.. RC6/TX/CK, Function = CK. RC6/TX/CK, I/O = IN. RC6/TX/CK, TRIS = 1. RC6/TX/CK, Buffer = ST. RC6/TX/CK, Description = EUSART synchronous clock input.. RC7/RX/DT, Function = RC7. RC7/RX/DT, I/O = OUT. RC7/RX/DT, TRIS = 0. RC7/RX/DT, Buffer = DIG. RC7/RX/DT, Description = LATC<7> data output.. RC7/RX/DT, Function = RC7. RC7/RX/DT, I/O =",
    "TABLE 10-5: PORTC I/O SUMMARY\nIN. RC7/RX/DT, TRIS = 1. RC7/RX/DT, Buffer = ST. RC7/RX/DT, Description = PORTC<7> data input.. RC7/RX/DT, Function = RX. RC7/RX/DT, I/O = IN. RC7/RX/DT, TRIS = 1. RC7/RX/DT, Buffer = ST. RC7/RX/DT, Description = EUSART asynchronous data input.. RC7/RX/DT, Function = DT. RC7/RX/DT, I/O = OUT. RC7/RX/DT, TRIS = 1. RC7/RX/DT, Buffer = DIG. RC7/RX/DT, Description = EUSART synchronous data output - must have TRIS set to ' 1 ' to enable EUSART to control the bidirectional communication.. RC7/RX/DT, Function = DT. RC7/RX/DT, I/O = IN.",
    "TABLE 10-5: PORTC I/O SUMMARY\nRC7/RX/DT, TRIS = 1. RC7/RX/DT, Buffer = ST. RC7/RX/DT, Description = EUSART synchronous data input.\nLegend: PWR = Power Supply; OUT = Output; IN = Input; ANA = Analog Signal; DIG = Digital Output; ST = Schmitt Buffer Input; TTL = TTL Buffer Input",
    "TABLE 10-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nPORTC, Bit 7 = RC7. PORTC, Bit 6 = RC6. PORTC, Bit 5 = RC5. PORTC, Bit 4 = RC4. PORTC, Bit 3 = RC3. PORTC, Bit 2 = RC2. PORTC, Bit 1 = RC1. PORTC, Bit 0 = RC0. PORTC, Reset Values on page = 49. LATC, Bit 7 = PORTC Data Output Register. LATC, Bit 6 = PORTC Data Output Register. LATC, Bit 5 = PORTC Data Output Register. LATC, Bit 4 = PORTC Data Output Register. LATC, Bit 3 = PORTC Data Output Register. LATC, Bit 2 = PORTC Data Output Register. LATC, Bit 1 = PORTC Data Output Register. LATC, Bit 0 = PORTC Data Output Register. LATC, Reset Values on page = 49. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC",
    "TABLE 10-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nData Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Reset Values on page = 49",
    "10.4 PORTD, TRISD and LATD Registers\nNote:\nPORTD is only available on PIC18F4X8X devices.\nPORTD is an 8-bit wide, bidirectional port. The corresponding Data Direction register is TRISD. Setting a TRISD bit (= 1 )  will  make the corresponding PORTD pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISD bit (= 0 ) will make the corresponding PORTD pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATD)  is also memory mapped.  Read-modify-write  operations  on  the  LATD register  read  and  write  the  latched  output  value  for PORTD.\nAll pins on PORTD are implemented with Schmitt Trigger input buffers. Each pin is individually configurable as an input or output.",
    "10.4 PORTD, TRISD and LATD Registers\nThree of the PORTD pins are multiplexed with outputs P1A,  P1B,  P1C  and  P1D  of  the  Enhanced  CCP1 (ECCP1)  module.  The  operation  of  these  additional PWM  output  pins  is  covered  in  greater  detail  in Section 16.0 'Enhanced Capture/Compare/PWM (ECCP1) Module' .\nNote:\nOn  a  Power-on  Reset,  these  pins  are configured as digital inputs.\nPORTD can also be configured as an 8-bit wide microprocessor port (Parallel Slave Port) by setting control bit,  PSPMODE  (TRISE<4>).  In  this  mode,  the  input buffers  are  TTL.  See Section 10.6  'Parallel  Slave Port' for  additional  information on the Parallel Slave Port (PSP).\nNote:\nWhen the Enhanced PWM mode is used with either dual or quad outputs, the PSP functions  of PORTD  are  automatically disabled.",
    "EXAMPLE 10-4: INITIALIZING PORTD\nCLRF, 1 = PORTD. CLRF, 2 = ; Initialize PORTD by ; clearing output ; data latches. CLRF, 1 = LATD. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISD. MOVWF, 2 = ; Set RD<3:0> as inputs ; RD<5:4> as outputs ; RD<7:6> as inputs",
    "TABLE 10-7: PORTD I/O SUMMARY\nRD0/PSP0/ C1IN+, Function = RD0. RD0/PSP0/ C1IN+, I/O = OUT. RD0/PSP0/ C1IN+, TRIS = 0. RD0/PSP0/ C1IN+, Buffer = DIG. RD0/PSP0/ C1IN+, Description = LATD<0> data output.. RD0/PSP0/ C1IN+, Function = . RD0/PSP0/ C1IN+, I/O = IN. RD0/PSP0/ C1IN+, TRIS = 1. RD0/PSP0/ C1IN+, Buffer = ST. RD0/PSP0/ C1IN+, Description = PORTD<0> data input.. RD0/PSP0/ C1IN+, Function = PSP0. RD0/PSP0/ C1IN+, I/O = OUT. RD0/PSP0/ C1IN+, TRIS = x. RD0/PSP0/ C1IN+, Buffer = DIG. RD0/PSP0/",
    "TABLE 10-7: PORTD I/O SUMMARY\nC1IN+, Description = Parallel Slave Port (PSP) data output (overrides the TRIS<0> control when enabled).. RD0/PSP0/ C1IN+, Function = . RD0/PSP0/ C1IN+, I/O = IN. RD0/PSP0/ C1IN+, TRIS = x. RD0/PSP0/ C1IN+, Buffer = TTL. RD0/PSP0/ C1IN+, Description = Parallel Slave Port (PSP) data input (overrides the TRIS<0> control when enabled).. RD0/PSP0/ C1IN+, Function = C1IN+. RD0/PSP0/ C1IN+, I/O = IN. RD0/PSP0/ C1IN+, TRIS = 1. RD0/PSP0/ C1IN+, Buffer = ANA. RD0/PSP0/ C1IN+, Description = Comparator 1 positive input B. Default on POR. This analog input overrides the digital input (read as clear - low level)..",
    "TABLE 10-7: PORTD I/O SUMMARY\nRD1/PSP1/ C1IN-, Function = RD1. RD1/PSP1/ C1IN-, I/O = OUT. RD1/PSP1/ C1IN-, TRIS = 0. RD1/PSP1/ C1IN-, Buffer = DIG. RD1/PSP1/ C1IN-, Description = LATD<1> data output.. RD1/PSP1/ C1IN-, Function = . RD1/PSP1/ C1IN-, I/O = IN. RD1/PSP1/ C1IN-, TRIS = 1. RD1/PSP1/ C1IN-, Buffer = ST. RD1/PSP1/ C1IN-, Description = PORTD<1> data input.. RD1/PSP1/ C1IN-, Function = PSP1. RD1/PSP1/ C1IN-, I/O = OUT. RD1/PSP1/ C1IN-, TRIS = x. RD1/PSP1/ C1IN-, Buffer = DIG. RD1/PSP1/",
    "TABLE 10-7: PORTD I/O SUMMARY\nC1IN-, Description = Parallel Slave Port (PSP) data output (overrides the TRIS<1> control when enabled).. RD1/PSP1/ C1IN-, Function = . RD1/PSP1/ C1IN-, I/O = IN. RD1/PSP1/ C1IN-, TRIS = x. RD1/PSP1/ C1IN-, Buffer = TTL. RD1/PSP1/ C1IN-, Description = Parallel Slave Port (PSP) data input (overrides the TRIS<1> control when enabled).. RD1/PSP1/ C1IN-, Function = C1IN-. RD1/PSP1/ C1IN-, I/O = IN. RD1/PSP1/ C1IN-, TRIS = 1. RD1/PSP1/ C1IN-, Buffer = ANA. RD1/PSP1/ C1IN-, Description = Comparator 1 negative input. Default on POR. This analog input overrides the digital input (read as clear - low level)..",
    "TABLE 10-7: PORTD I/O SUMMARY\nRD2/PSP2/ C2IN+, Function = RD2. RD2/PSP2/ C2IN+, I/O = OUT. RD2/PSP2/ C2IN+, TRIS = 0. RD2/PSP2/ C2IN+, Buffer = DIG. RD2/PSP2/ C2IN+, Description = LATD<2> data output.. RD2/PSP2/ C2IN+, Function = . RD2/PSP2/ C2IN+, I/O = IN. RD2/PSP2/ C2IN+, TRIS = 1. RD2/PSP2/ C2IN+, Buffer = ST. RD2/PSP2/ C2IN+, Description = PORTD<2> data input.. RD2/PSP2/ C2IN+, Function = PSP2. RD2/PSP2/ C2IN+, I/O = OUT. RD2/PSP2/ C2IN+, TRIS = x. RD2/PSP2/ C2IN+, Buffer = DIG. RD2/PSP2/",
    "TABLE 10-7: PORTD I/O SUMMARY\nC2IN+, Description = Parallel Slave Port (PSP) data output (overrides the TRIS<2> control when enabled).. RD2/PSP2/ C2IN+, Function = . RD2/PSP2/ C2IN+, I/O = IN. RD2/PSP2/ C2IN+, TRIS = x. RD2/PSP2/ C2IN+, Buffer = TTL. RD2/PSP2/ C2IN+, Description = Parallel Slave Port (PSP) data input (overrides the TRIS<2> control when enabled).. RD2/PSP2/ C2IN+, Function = C2IN+. RD2/PSP2/ C2IN+, I/O = IN. RD2/PSP2/ C2IN+, TRIS = 1. RD2/PSP2/ C2IN+, Buffer = ANA. RD2/PSP2/ C2IN+, Description = Comparator 2 positive input. Default on POR. This analog input overrides the digital input (read as clear - low level)..",
    "TABLE 10-7: PORTD I/O SUMMARY\nRD3/PSP3/ C2IN-, Function = RD3. RD3/PSP3/ C2IN-, I/O = OUT. RD3/PSP3/ C2IN-, TRIS = 0. RD3/PSP3/ C2IN-, Buffer = DIG. RD3/PSP3/ C2IN-, Description = LATD<3> data output.. RD3/PSP3/ C2IN-, Function = . RD3/PSP3/ C2IN-, I/O = IN. RD3/PSP3/ C2IN-, TRIS = 1. RD3/PSP3/ C2IN-, Buffer = ST. RD3/PSP3/ C2IN-, Description = PORTD<3> data input.. RD3/PSP3/ C2IN-, Function = PSP3. RD3/PSP3/ C2IN-, I/O = OUT. RD3/PSP3/ C2IN-, TRIS = x. RD3/PSP3/ C2IN-, Buffer = DIG. RD3/PSP3/",
    "TABLE 10-7: PORTD I/O SUMMARY\nC2IN-, Description = Parallel Slave Port (PSP) data output (overrides the TRIS<3> control when enabled).. RD3/PSP3/ C2IN-, Function = . RD3/PSP3/ C2IN-, I/O = IN. RD3/PSP3/ C2IN-, TRIS = x. RD3/PSP3/ C2IN-, Buffer = TTL. RD3/PSP3/ C2IN-, Description = Parallel Slave Port (PSP) data input (overrides the TRIS<3> control when enabled).. RD3/PSP3/ C2IN-, Function = C2IN-. RD3/PSP3/ C2IN-, I/O = IN. RD3/PSP3/ C2IN-, TRIS = 1. RD3/PSP3/ C2IN-, Buffer = ANA. RD3/PSP3/ C2IN-, Description = Comparator 2 negative input. Default input on POR. This analog input overrides the digital input (read as clear - low level)..",
    "TABLE 10-7: PORTD I/O SUMMARY\nRD4/PSP4/ ECCP1/P1A, Function = RD4. RD4/PSP4/ ECCP1/P1A, I/O = OUT. RD4/PSP4/ ECCP1/P1A, TRIS = 0. RD4/PSP4/ ECCP1/P1A, Buffer = DIG. RD4/PSP4/ ECCP1/P1A, Description = LATD<4> data output.. RD4/PSP4/ ECCP1/P1A, Function = . RD4/PSP4/ ECCP1/P1A, I/O = IN. RD4/PSP4/ ECCP1/P1A, TRIS = 1. RD4/PSP4/ ECCP1/P1A, Buffer = ST. RD4/PSP4/ ECCP1/P1A, Description = PORTD<4> data input.. RD4/PSP4/ ECCP1/P1A, Function = PSP4. RD4/PSP4/",
    "TABLE 10-7: PORTD I/O SUMMARY\nECCP1/P1A, I/O = OUT. RD4/PSP4/ ECCP1/P1A, TRIS = x. RD4/PSP4/ ECCP1/P1A, Buffer = DIG. RD4/PSP4/ ECCP1/P1A, Description = Parallel Slave Port (PSP) data output (overrides the TRIS<4> control when enabled).. RD4/PSP4/ ECCP1/P1A, Function = . RD4/PSP4/ ECCP1/P1A, I/O = IN. RD4/PSP4/ ECCP1/P1A, TRIS = x. RD4/PSP4/ ECCP1/P1A, Buffer = TTL. RD4/PSP4/ ECCP1/P1A, Description = Parallel Slave Port (PSP) data input (overrides the TRIS<4> control when enabled).. RD4/PSP4/ ECCP1/P1A, Function = ECCP1. RD4/PSP4/",
    "TABLE 10-7: PORTD I/O SUMMARY\nECCP1/P1A, I/O = OUT. RD4/PSP4/ ECCP1/P1A, TRIS = 0. RD4/PSP4/ ECCP1/P1A, Buffer = DIG. RD4/PSP4/ ECCP1/P1A, Description = ECCP1 compare output.. RD4/PSP4/ ECCP1/P1A, Function = . RD4/PSP4/ ECCP1/P1A, I/O = IN. RD4/PSP4/ ECCP1/P1A, TRIS = 1. RD4/PSP4/ ECCP1/P1A, Buffer = ST. RD4/PSP4/ ECCP1/P1A, Description = ECCP1 capture input.. RD4/PSP4/ ECCP1/P1A, Function = P1A. RD4/PSP4/ ECCP1/P1A, I/O = OUT. RD4/PSP4/ ECCP1/P1A, TRIS = 0.",
    "TABLE 10-7: PORTD I/O SUMMARY\nRD4/PSP4/ ECCP1/P1A, Buffer = DIG. RD4/PSP4/ ECCP1/P1A, Description = ECCP1 Enhanced PWMoutput, channel A.. RD5/PSP5/ P1B, Function = RD5. RD5/PSP5/ P1B, I/O = OUT. RD5/PSP5/ P1B, TRIS = 0. RD5/PSP5/ P1B, Buffer = DIG. RD5/PSP5/ P1B, Description = LATD<5> data output.. RD5/PSP5/ P1B, Function = . RD5/PSP5/ P1B, I/O = IN. RD5/PSP5/ P1B, TRIS = 1. RD5/PSP5/ P1B, Buffer = ST. RD5/PSP5/ P1B, Description = PORTD<5> data input.. RD5/PSP5/ P1B, Function = PSP5. RD5/PSP5/",
    "TABLE 10-7: PORTD I/O SUMMARY\nP1B, I/O = OUT. RD5/PSP5/ P1B, TRIS = X. RD5/PSP5/ P1B, Buffer = DIG. RD5/PSP5/ P1B, Description = Parallel Slave Port (PSP) data output (overrides the TRIS<5> control when enabled).. RD5/PSP5/ P1B, Function = . RD5/PSP5/ P1B, I/O = IN. RD5/PSP5/ P1B, TRIS = x. RD5/PSP5/ P1B, Buffer = TTL. RD5/PSP5/ P1B, Description = Parallel Slave Port (PSP) data input (overrides the TRIS<5> control when enabled).. RD5/PSP5/ P1B, Function = P1B. RD5/PSP5/ P1B, I/O = OUT. RD5/PSP5/ P1B, TRIS = 0. RD5/PSP5/ P1B, Buffer = DIG.",
    "TABLE 10-7: PORTD I/O SUMMARY\nRD5/PSP5/ P1B, Description = ECCP1 Enhanced PWMoutput, channel B.. RD6/PSP6/ P1C, Function = RD6. RD6/PSP6/ P1C, I/O = OUT. RD6/PSP6/ P1C, TRIS = 0. RD6/PSP6/ P1C, Buffer = DIG. RD6/PSP6/ P1C, Description = LATD<6> data output.. RD6/PSP6/ P1C, Function = . RD6/PSP6/ P1C, I/O = IN. RD6/PSP6/ P1C, TRIS = 1. RD6/PSP6/ P1C, Buffer = ST. RD6/PSP6/ P1C, Description = PORTD<6> data input.. RD6/PSP6/ P1C, Function = PSP6. RD6/PSP6/ P1C, I/O = OUT. RD6/PSP6/ P1C, TRIS",
    "TABLE 10-7: PORTD I/O SUMMARY\n= x. RD6/PSP6/ P1C, Buffer = DIG. RD6/PSP6/ P1C, Description = Parallel Slave Port (PSP) data output (overrides the TRIS<6> control when enabled).. RD6/PSP6/ P1C, Function = . RD6/PSP6/ P1C, I/O = IN. RD6/PSP6/ P1C, TRIS = x. RD6/PSP6/ P1C, Buffer = TTL. RD6/PSP6/ P1C, Description = Parallel Slave Port (PSP) data input (overrides the TRIS<6> control when enabled).. RD6/PSP6/ P1C, Function = P1C. RD6/PSP6/ P1C, I/O = OUT. RD6/PSP6/ P1C, TRIS = 0. RD6/PSP6/ P1C, Buffer = DIG. RD6/PSP6/ P1C, Description = ECCP1 Enhanced PWMoutput,",
    "TABLE 10-7: PORTD I/O SUMMARY\nchannel C.. RD7/PSP7/ P1D, Function = RD7. RD7/PSP7/ P1D, I/O = OUT. RD7/PSP7/ P1D, TRIS = 0. RD7/PSP7/ P1D, Buffer = DIG. RD7/PSP7/ P1D, Description = LATD<7> data output.. RD7/PSP7/ P1D, Function = . RD7/PSP7/ P1D, I/O = IN. RD7/PSP7/ P1D, TRIS = 1. RD7/PSP7/ P1D, Buffer = ST. RD7/PSP7/ P1D, Description = PORTD<7> data input.. RD7/PSP7/ P1D, Function = PSP7. RD7/PSP7/ P1D, I/O = OUT. RD7/PSP7/ P1D, TRIS = x. RD7/PSP7/ P1D, Buffer = DIG.",
    "TABLE 10-7: PORTD I/O SUMMARY\nRD7/PSP7/ P1D, Description = Parallel Slave Port (PSP) data output (overrides the TRIS<7> control when enabled).. RD7/PSP7/ P1D, Function = . RD7/PSP7/ P1D, I/O = IN. RD7/PSP7/ P1D, TRIS = x. RD7/PSP7/ P1D, Buffer = TTL. RD7/PSP7/ P1D, Description = Parallel Slave Port (PSP) data input (overrides the TRIS<7> control when enabled).. RD7/PSP7/ P1D, Function = P1D. RD7/PSP7/ P1D, I/O = OUT. RD7/PSP7/ P1D, TRIS = 0. RD7/PSP7/ P1D, Buffer = DIG. RD7/PSP7/ P1D, Description = ECCP1 Enhanced PWMoutput, channel D.",
    "TABLE 10-7: PORTD I/O SUMMARY\nLegend: PWR = Power Supply; OUT = Output; IN = Input; ANA = Analog Signal; DIG = Digital Output; ST = Schmitt Buffer Input; TTL = TTL Buffer Input",
    "TABLE 10-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nPORTD (1), Bit 7 = RD7. PORTD (1), Bit 6 = RD6. PORTD (1), Bit 5 = RD5. PORTD (1), Bit 4 = RD4. PORTD (1), Bit 3 = RD3. PORTD (1), Bit 2 = RD2. PORTD (1), Bit 1 = RD1. PORTD (1), Bit 0 = RD0. PORTD (1), Reset Values on page = 49. LATD (1), Bit 7 = LATD Data Output Register. LATD (1), Bit 6 = LATD Data Output Register. LATD (1), Bit 5 = LATD Data Output Register. LATD (1), Bit 4 = LATD Data Output Register. LATD (1), Bit 3 = LATD Data Output Register. LATD (1), Bit 2 = LATD Data Output Register. LATD (1), Bit 1 = LATD Data Output Register. LATD (1), Bit 0 = LATD Data Output",
    "TABLE 10-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nRegister. LATD (1), Reset Values on page = 49. TRISD (1), Bit 7 = PORTD Data Direction Register. TRISD (1), Bit 6 = PORTD Data Direction Register. TRISD (1), Bit 5 = PORTD Data Direction Register. TRISD (1), Bit 4 = PORTD Data Direction Register. TRISD (1), Bit 3 = PORTD Data Direction Register. TRISD (1), Bit 2 = PORTD Data Direction Register. TRISD (1), Bit 1 = PORTD Data Direction Register. TRISD (1), Bit 0 = PORTD Data Direction Register. TRISD (1), Reset Values on page = 49. TRISE (1), Bit 7 = IBF. TRISE (1), Bit 6 = OBF. TRISE (1), Bit 5 = IBOV. TRISE (1), Bit 4 = PSPMODE. TRISE (1), Bit 3 = -. TRISE (1), Bit 2 = PORTE Data Direction bits. TRISE (1), Bit 1 = PORTE Data Direction bits. TRISE (1), Bit",
    "TABLE 10-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\n0 = PORTE Data Direction bits. TRISE (1), Reset Values on page = 49. ECCP1CON (1), Bit 7 = EPWM1M1. ECCP1CON (1), Bit 6 = EPWM1M0. ECCP1CON (1), Bit 5 = EDC1B1. ECCP1CON (1), Bit 4 = EDC1B0. ECCP1CON (1), Bit 3 = ECCP1M3. ECCP1CON (1), Bit 2 = ECCP1M2. ECCP1CON (1), Bit 1 = ECCP1M1. ECCP1CON (1), Bit 0 = ECCP1M0. ECCP1CON (1), Reset Values on page = 48\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used by PORTD.\nNote 1:\nThese registers are available on PIC18F4X8X devices only.",
    "10.5 PORTE, TRISE and LATE Registers\nDepending on the particular PIC18F2585/2680/4585/ 4680 device selected, PORTE is implemented in two different ways.\nFor PIC18F4X8X devices, PORTE is a 4-bit wide port. Three pins (RE0/RD/AN5, RE1/WR/AN6/C1OUT and RE2/CS/AN7/C2OUT) are individually configurable as inputs  or  outputs.  These  pins  have  Schmitt  Trigger input buffers. When selected as an analog input, these pins will read as ' 0 's.\nThe  corresponding  data  direction  register  is  TRISE. Setting a TRISE bit (= 1 ) will make the corresponding PORTE pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISE bit (= 0 ) will make the corresponding PORTE pin an output (i.e., put the contents of the output latch on the selected pin).\nTRISE controls the direction of the RE pins, even when they are being used as analog inputs. The user must make sure to keep the pins configured as inputs when using them as analog inputs.\nNote:",
    "10.5 PORTE, TRISE and LATE Registers\nOn  a  Power-on  Reset,  RE2:RE0  are configured as analog inputs.\nThe upper four bits of the TRISE register also control the operation of the Parallel Slave Port. Their operation is explained in Register 10-1.\nThe  Data  Latch  register (LATE)  is also memory mapped.  Read-modify-write  operations  on  the  LATE register,  read  and  write  the  latched  output  value  for PORTE.\nThe fourth pin of PORTE (MCLR/VPP/RE3) is an input only  pin.  Its  operation  is  controlled  by  the  MCLRE Configuration bit. When  selected as a port pin (MCLRE = 0 ), it functions as a digital input only pin. As such, it does not have TRIS or LAT bits associated with its  operation.  Otherwise,  it  functions  as  the  device's Master Clear input.  In  either  configuration,  RE3  also functions  as  the  programming  voltage  input  during programming.\nNote:, 1 = On a Power-on Reset, RE3 is enabled as a digital input only if Master Clear functionality is disabled.",
    "EXAMPLE 10-5: INITIALIZING PORTE\nCLRF, 1 = PORTE. CLRF, 2 = ; Initialize PORTE by ; clearing output ; data latches. CLRF, 1 = LATE. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF MOVLW, 1 = 0Ah ADCON1 03h. MOVLW MOVWF MOVLW, 2 = ; Configure A/D ; for digital inputs ; Value used to. MOVLW MOVWF MOVWF, 1 = 07h CMCON TRISC. MOVLW MOVWF MOVWF, 2 = ; direction ; Turn off ; comparators ; Set RE<0> as inputs ; RE<1> as outputs ; RE<2> as inputs",
    "10.5.1 PORTE IN 28-PIN DEVICES\nFor  PIC18F2X8X  devices,  PORTE  is  only  available when Master Clear functionality is disabled (MCLRE = 0 ).  In  these cases, PORTE is a single bit, input only port comprised of RE3 only. The pin operates as previously described.",
    "TRISE REGISTER (PIC18F4X8X DEVICES ONLY)\nR-0, 1 = R-0. R-0, 2 = R/W-0. R-0, 3 = R/W-0. R-0, 4 = U-0. R-0, 5 = R/W-1. R-0, 6 = R/W-1. R-0, 7 = R/W-1. IBF, 1 = OBF. IBF, 2 = IBOV. IBF, 3 = PSPMODE. IBF, 4 = -. IBF, 5 = TRISE2. IBF, 6 = TRISE1. IBF, 7 = TRISE0\nbit 7\nbit 0",
    "bit 7\nIBF: Input Buffer Full Status bit\n1 = A word has been received and waiting to be read by the CPU\n0 = No word has been received",
    "bit 6 OBF: Output Buffer Full Status bit\n1 = The output buffer still holds a previously written word\n0 = The output buffer has been read\nbit 5\nIBOV: Input Buffer Overflow Detect bit (in Microprocessor mode)\n1 = A write occurred when a previously input word has not been read (must be cleared in software)\n0 = No overflow occurred\nbit 4 PSPMODE: Parallel Slave Port Mode Select bit\n1 = Parallel Slave Port mode\n0 = General Purpose I/O mode",
    "bit 3 Unimplemented: Read as ' 0 '\nbit 2\nTRISE2:\nRE2 Direction Control bit\n1 = Input\n0 = Output\nbit 1\nTRISE1: RE1 Direction Control bit\n1 = Input\n0 = Output",
    "bit 0\nTRISE0: RE0 Direction Control bit\n1 = Input\n0 = Output",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "TABLE 10-9: PORTE I/O SUMMARY\nRE0/RD/AN5, Function = RE0. RE0/RD/AN5, I/O = OUT. RE0/RD/AN5, TRIS = 0. RE0/RD/AN5, Buffer = DIG. RE0/RD/AN5, Description = LATE<0> data output.. RE0/RD/AN5, Function = RE0. RE0/RD/AN5, I/O = IN. RE0/RD/AN5, TRIS = 1. RE0/RD/AN5, Buffer = ST. RE0/RD/AN5, Description = PORTE<0> data input.. RE0/RD/AN5, Function = RD. RE0/RD/AN5, I/O = IN. RE0/RD/AN5, TRIS = 1. RE0/RD/AN5, Buffer = TTL. RE0/RD/AN5, Description = PSP read enable input.. RE0/RD/AN5, Function = AN5. RE0/RD/AN5, I/O = IN. RE0/RD/AN5, TRIS",
    "TABLE 10-9: PORTE I/O SUMMARY\n= 1. RE0/RD/AN5, Buffer = ANA. RE0/RD/AN5, Description = A/D input channel 5. Enabled on POR, this analog input overrides the digital input (read as clear - low level).. RE1/WR/AN6/C1OUT, Function = RE1. RE1/WR/AN6/C1OUT, I/O = OUT. RE1/WR/AN6/C1OUT, TRIS = 0. RE1/WR/AN6/C1OUT, Buffer = DIG. RE1/WR/AN6/C1OUT, Description = LATE<1> data output.. RE1/WR/AN6/C1OUT, Function = RE1. RE1/WR/AN6/C1OUT, I/O = IN. RE1/WR/AN6/C1OUT, TRIS = 1. RE1/WR/AN6/C1OUT, Buffer = ST. RE1/WR/AN6/C1OUT, Description = PORTE<1> data input.. RE1/WR/AN6/C1OUT, Function = WR.",
    "TABLE 10-9: PORTE I/O SUMMARY\nRE1/WR/AN6/C1OUT, I/O = IN. RE1/WR/AN6/C1OUT, TRIS = 1. RE1/WR/AN6/C1OUT, Buffer = TTL. RE1/WR/AN6/C1OUT, Description = PSP write enable input.. RE1/WR/AN6/C1OUT, Function = AN6. RE1/WR/AN6/C1OUT, I/O = IN. RE1/WR/AN6/C1OUT, TRIS = 1. RE1/WR/AN6/C1OUT, Buffer = ANA. RE1/WR/AN6/C1OUT, Description = A/D input channel 6. Enabled on POR, this analog input overrides the digital input (read as clear - low level).. RE1/WR/AN6/C1OUT, Function = C1OUT. RE1/WR/AN6/C1OUT, I/O = OUT. RE1/WR/AN6/C1OUT, TRIS = 0. RE1/WR/AN6/C1OUT, Buffer = DIG.",
    "TABLE 10-9: PORTE I/O SUMMARY\nRE1/WR/AN6/C1OUT, Description = Comparator 1 output.. RE2/CS/AN7/C2OUT, Function = RE2. RE2/CS/AN7/C2OUT, I/O = OUT. RE2/CS/AN7/C2OUT, TRIS = 0. RE2/CS/AN7/C2OUT, Buffer = DIG. RE2/CS/AN7/C2OUT, Description = LATE<2> data output.. RE2/CS/AN7/C2OUT, Function = RE2. RE2/CS/AN7/C2OUT, I/O = IN. RE2/CS/AN7/C2OUT, TRIS = 1. RE2/CS/AN7/C2OUT, Buffer = ST. RE2/CS/AN7/C2OUT, Description = PORTE<2> data input.. RE2/CS/AN7/C2OUT, Function = CS. RE2/CS/AN7/C2OUT, I/O = IN. RE2/CS/AN7/C2OUT, TRIS = 1.",
    "TABLE 10-9: PORTE I/O SUMMARY\nRE2/CS/AN7/C2OUT, Buffer = TTL. RE2/CS/AN7/C2OUT, Description = PSP chip select input.. RE2/CS/AN7/C2OUT, Function = AN7. RE2/CS/AN7/C2OUT, I/O = IN. RE2/CS/AN7/C2OUT, TRIS = 1. RE2/CS/AN7/C2OUT, Buffer = ANA. RE2/CS/AN7/C2OUT, Description = A/D input channel 7. Enabled on POR, this analog input overrides the digital input (read as clear - low level).. RE2/CS/AN7/C2OUT, Function = C2OUT. RE2/CS/AN7/C2OUT, I/O = OUT. RE2/CS/AN7/C2OUT, TRIS = 0. RE2/CS/AN7/C2OUT, Buffer = DIG. RE2/CS/AN7/C2OUT, Description = Comparator 2 output.. MCLR/VPP/RE3, Function = MCLR.",
    "TABLE 10-9: PORTE I/O SUMMARY\nMCLR/VPP/RE3, I/O = IN. MCLR/VPP/RE3, TRIS = x. MCLR/VPP/RE3, Buffer = ST. MCLR/VPP/RE3, Description = External Reset input. Disabled when MCLRE Configuration bit is ' 1 '.. MCLR/VPP/RE3, Function = VPP. MCLR/VPP/RE3, I/O = IN. MCLR/VPP/RE3, TRIS = x. MCLR/VPP/RE3, Buffer = ANA. MCLR/VPP/RE3, Description = High-voltage detection; used by ICSP\u2122 operation.. MCLR/VPP/RE3, Function = RE3. MCLR/VPP/RE3, I/O = IN. MCLR/VPP/RE3, TRIS = 1. MCLR/VPP/RE3, Buffer = ST. MCLR/VPP/RE3, Description = PORTE<3> data input. Disabled when MCLRE Configuration bit is ' 0 '.\nLegend:",
    "TABLE 10-9: PORTE I/O SUMMARY\nPWR = Power Supply; OUT = Output; IN = Input; ANA = Analog Signal; DIG = Digital Output; ST = Schmitt Buffer Input; TTL = TTL Buffer Input",
    "TABLE 10-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nPORTE (3), Bit 7 = -. PORTE (3), Bit 6 = -. PORTE (3), Bit 5 = -. PORTE (3), Bit 4 = -. PORTE (3), Bit 3 = RE3 (1,2). PORTE (3), Bit 2 = RE2. PORTE (3), Bit 1 = RE1. PORTE (3), Bit 0 = RE0. PORTE (3), Reset Values on page = 49. LATE (2), Bit 7 = -. LATE (2), Bit 6 = -. LATE (2), Bit 5 = -. LATE (2), Bit 4 = -. LATE (2), Bit 3 = -. LATE (2), Bit 2 = LATE Data Output Register. LATE (2), Bit 1 = LATE Data Output Register. LATE (2), Bit 0 = LATE Data Output Register. LATE (2), Reset Values on page = 49. TRISE (3), Bit 7 = IBF. TRISE (3), Bit 6 = OBF. TRISE (3), Bit 5 = IBOV. TRISE (3), Bit",
    "TABLE 10-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\n4 = PSPMODE. TRISE (3), Bit 3 = -. TRISE (3), Bit 2 = TRISE2. TRISE (3), Bit 1 = TRISE1. TRISE (3), Bit 0 = TRISE0. TRISE (3), Reset Values on page = 49. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Reset Values on page = 47. CMCON (3), Bit 7 = C2OUT. CMCON (3), Bit 6 = C1OUT. CMCON (3), Bit 5 = C2INV. CMCON (3), Bit 4 = C1INV. CMCON (3), Bit 3 = CIS. CMCON (3), Bit 2 = CM2. CMCON",
    "TABLE 10-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\n(3), Bit 1 = CM1. CMCON (3), Bit 0 = CM0. CMCON (3), Reset Values on page = 48\n- = unimplemented, read as ' '. Shaded cells are not used by PORTE.\nLegend: 0\nNote 1:\nImplemented only when Master Clear functionality is disabled (MCLRE Configuration bit = 0 ).\n2: RE3 is the only PORTE bit implemented on both PIC18F2X8X and PIC18F4X8X devices. All other bits are implemented only when PORTE is implemented (i.e., PIC18F4X8X devices).\n3: These registers are unimplemented on PIC18F2X8X devices.",
    "10.6 Parallel Slave Port\nNote:\nThe Parallel Slave Port is only available on PIC18F4X8X devices.\nIn addition to its function as a general I/O port, PORTD can also operate as an 8-bit wide Parallel Slave Port (PSP) or microprocessor port. PSP  operation is controlled  by  the  4  upper  bits  of  the  TRISE  register (Register 10-1). Setting control bit, PSPMODE (TRISE<4>), enables  PSP  operation,  as  long  as  the Enhanced CCP1 (ECCP1) module is not operating in dual output or quad output PWM mode. In Slave mode, the port is asynchronously readable and writable by the external world.",
    "10.6 Parallel Slave Port\nThe  PSP  can  directly  interface  to  an  8-bit  microprocessor data bus. The external microprocessor can read or write the PORTD latch as an 8-bit latch. Setting the control bit PSPMODE enables the PORTE I/O pins to become control inputs for the microprocessor port. When set, port pin RE0 is the RD input, RE1 is the WR input and RE2 is the CS (Chip Select) input. For this functionality,  the  corresponding  data  direction  bits  of the TRISE register (TRISE<2:0>) must be configured as inputs (set). The  A/D  port configuration bits, PFCG3:PFCG0 (ADCON1<3:0>), must also be set to ' 1010 '.\nA write to the PSP occurs when both the CS and WR lines are first detected low and ends when either are detected high. The PSPIF and IBF flag bits are both set when the write ends.",
    "10.6 Parallel Slave Port\nA read from the PSP occurs when both the CS and RD lines are first detected low. The data in PORTD is read out and the OBF bit is set. If the user writes new data to PORTD to set OBF, the data is immediately read out; however, the OBF bit is not set.\nWhen either the CS or RD lines are detected high, the PORTD pins return to the input state and the PSPIF bit is set. User applications should wait for PSPIF to be set before servicing the PSP; when this happens, the IBF and OBF bits can be polled and the appropriate action taken.\nThe timing for the  control  signals  in  Write  and  Read modes  is  shown  in  Figure 10-3 and  Figure 10-4, respectively.",
    "TABLE 10-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nPORTD (1), Bit 7 = RD7. PORTD (1), Bit 6 = RD6. PORTD (1), Bit 5 = RD5. PORTD (1), Bit 4 = RD4. PORTD (1), Bit 3 = RD3. PORTD (1), Bit 2 = RD2. PORTD (1), Bit 1 = RD1. PORTD (1), Bit 0 = RD0. PORTD (1), Reset Values on page = 49. LATD (1), Bit 7 = PORTD Data Latch Register (Read and Write to Data Latch). LATD (1), Bit 6 = PORTD Data Latch Register (Read and Write to Data Latch). LATD (1), Bit 5 = PORTD Data Latch Register (Read and Write to Data Latch). LATD (1), Bit 4 = PORTD Data Latch Register (Read and Write to Data Latch). LATD (1), Bit 3 = PORTD Data Latch Register (Read and Write to Data Latch). LATD (1), Bit 2 = PORTD Data Latch Register",
    "TABLE 10-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n(Read and Write to Data Latch). LATD (1), Bit 1 = PORTD Data Latch Register (Read and Write to Data Latch). LATD (1), Bit 0 = PORTD Data Latch Register (Read and Write to Data Latch). LATD (1), Reset Values on page = 49. TRISD (1), Bit 7 = PORTD Data Direction Control Register. TRISD (1), Bit 6 = PORTD Data Direction Control Register. TRISD (1), Bit 5 = PORTD Data Direction Control Register. TRISD (1), Bit 4 = PORTD Data Direction Control Register. TRISD (1), Bit 3 = PORTD Data Direction Control Register. TRISD (1), Bit 2 = PORTD Data Direction Control Register. TRISD (1), Bit 1 = PORTD Data Direction Control Register. TRISD (1), Bit 0 = PORTD Data Direction Control Register. TRISD (1), Reset Values on page = 49. PORTE (1), Bit 7 = -. PORTE (1), Bit 6 = -. PORTE (1), Bit 5 = -. PORTE",
    "TABLE 10-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n(1), Bit 4 = -. PORTE (1), Bit 3 = RE3. PORTE (1), Bit 2 = RE2. PORTE (1), Bit 1 = RE1. PORTE (1), Bit 0 = RE0. PORTE (1), Reset Values on page = 49. LATE (1), Bit 7 = -. LATE (1), Bit 6 = -. LATE (1), Bit 5 = -. LATE (1), Bit 4 = -. LATE (1), Bit 3 = -. LATE (1), Bit 2 = LATE Data Output bits. LATE (1), Bit 1 = LATE Data Output bits. LATE (1), Bit 0 = LATE Data Output bits. LATE (1), Reset Values on page = 49. TRISE (1), Bit 7 = IBF. TRISE (1), Bit 6 = OBF. TRISE (1), Bit 5 = IBOV. TRISE (1), Bit 4 = PSPMODE. TRISE (1), Bit 3 = -. TRISE (1), Bit 2 = TRISE2. TRISE (1),",
    "TABLE 10-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nBit 1 = TRISE1. TRISE (1), Bit 0 = TRISE0. TRISE (1), Reset Values on page = 49. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. PIR1, Bit 7 = PSPIF (2). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE (2).",
    "TABLE 10-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nPIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR1, Bit 7 = PSPIP (2). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2",
    "TABLE 10-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Reset Values on page = 47. CMCON (1), Bit 7 = C2OUT. CMCON (1), Bit 6 = C1OUT. CMCON (1), Bit 5 = C2INV. CMCON (1), Bit 4 = C1INV. CMCON (1), Bit 3 = CIS. CMCON (1), Bit 2 = CM2. CMCON (1), Bit 1 = CM1. CMCON (1), Bit 0 = CM0. CMCON (1), Reset Values on page = 48\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by the Parallel Slave Port.\nNote\n1: These registers are available on PIC18F4X8X devices only.\n2: These registers are unimplemented on PIC18F2X8X devices and read as ' 0 '.",
    "11.0 TIMER0 MODULE\nThe Timer0 module incorporates the following features:\nThe T0CON register (Register 11-1) controls all aspects of the module's operation, including the prescale selection. It is both readable and writable.\n\u00b7 Software selectable operation as a timer or counter in both 8-bit or 16-bit modes\n\u00b7 Readable and writable registers\n\u00b7 Dedicated 8-bit, software programmable prescaler\n\u00b7 Selectable clock source (internal or external)\n\u00b7 Edge select for external clock\n\u00b7 Interrupt-on-overflow",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\n, R/W-1 = TMR0ON. , R/W-1 = T08BIT. , R/W-1 = T0CS. , R/W-1 = T0SE. , R/W-1 = PSA. , R/W-1 = T0PS2. , R/W-1 = T0PS1. , R/W-1 = T0PS0. , R/W-1 = bit 7. , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = bit 0. bit 7, R/W-1 = TMR0ON: Timer0 On/Off Control bit = Enables Timer0. bit 7, R/W-1 = TMR0ON: Timer0 On/Off Control bit = Enables Timer0. bit 7, R/W-1 = TMR0ON: Timer0 On/Off Control bit = Enables Timer0. bit",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\n7, R/W-1 = TMR0ON: Timer0 On/Off Control bit = Enables Timer0. bit 7, R/W-1 = TMR0ON: Timer0 On/Off Control bit = Enables Timer0. bit 7, R/W-1 = TMR0ON: Timer0 On/Off Control bit = Enables Timer0. bit 7, R/W-1 = TMR0ON: Timer0 On/Off Control bit = Enables Timer0. bit 7, R/W-1 = TMR0ON: Timer0 On/Off Control bit = Enables Timer0. bit 6, R/W-1 = T08BIT : Timer0 8-bit/16-bit Control bit 1 = Timer0 is configured as an 8-bit timer/counter 0 = Timer0 is configured as a 16-bit timer/counter. bit 6, R/W-1 = T08BIT : Timer0 8-bit/16-bit Control bit 1 = Timer0 is configured as an 8-bit timer/counter 0 = Timer0 is configured as a 16-bit timer/counter. bit",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\n6, R/W-1 = T08BIT : Timer0 8-bit/16-bit Control bit 1 = Timer0 is configured as an 8-bit timer/counter 0 = Timer0 is configured as a 16-bit timer/counter. bit 6, R/W-1 = T08BIT : Timer0 8-bit/16-bit Control bit 1 = Timer0 is configured as an 8-bit timer/counter 0 = Timer0 is configured as a 16-bit timer/counter. bit 6, R/W-1 = T08BIT : Timer0 8-bit/16-bit Control bit 1 = Timer0 is configured as an 8-bit timer/counter 0 = Timer0 is configured as a 16-bit timer/counter. bit 6, R/W-1 = T08BIT : Timer0 8-bit/16-bit Control bit 1 = Timer0 is configured as an 8-bit timer/counter 0 = Timer0 is configured as a 16-bit timer/counter. bit 6, R/W-1 = T08BIT : Timer0 8-bit/16-bit Control bit 1 =",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nTimer0 is configured as an 8-bit timer/counter 0 = Timer0 is configured as a 16-bit timer/counter. bit 6, R/W-1 = T08BIT : Timer0 8-bit/16-bit Control bit 1 = Timer0 is configured as an 8-bit timer/counter 0 = Timer0 is configured as a 16-bit timer/counter. bit 5, R/W-1 = T0CS : Timer0 Clock Source Select bit 1 = Transition on T0CKI pin 0 = Internal instruction cycle clock (CLKO). bit 5, R/W-1 = T0CS : Timer0 Clock Source Select bit 1 = Transition on T0CKI pin 0 = Internal instruction cycle clock (CLKO). bit 5, R/W-1 = T0CS : Timer0 Clock Source Select bit 1 = Transition on T0CKI pin 0 = Internal instruction cycle clock (CLKO). bit 5, R/W-1 = T0CS : Timer0 Clock Source Select bit 1 = Transition on T0CKI pin 0 = Internal instruction cycle clock (CLKO). bit 5, R/W-1 =",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nT0CS : Timer0 Clock Source Select bit 1 = Transition on T0CKI pin 0 = Internal instruction cycle clock (CLKO). bit 5, R/W-1 = T0CS : Timer0 Clock Source Select bit 1 = Transition on T0CKI pin 0 = Internal instruction cycle clock (CLKO). bit 5, R/W-1 = T0CS : Timer0 Clock Source Select bit 1 = Transition on T0CKI pin 0 = Internal instruction cycle clock (CLKO). bit 5, R/W-1 = T0CS : Timer0 Clock Source Select bit 1 = Transition on T0CKI pin 0 = Internal instruction cycle clock (CLKO). bit 4, R/W-1 = T0SE : Timer0 Source Edge Select bit 1 = Increment on high-to-low transition on T0CKI pin 0 = Increment on low-to-high transition on T0CKI pin. bit 4, R/W-1 = T0SE : Timer0 Source Edge Select bit 1 = Increment on high-to-low transition on T0CKI pin 0 = Increment on",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nlow-to-high transition on T0CKI pin. bit 4, R/W-1 = T0SE : Timer0 Source Edge Select bit 1 = Increment on high-to-low transition on T0CKI pin 0 = Increment on low-to-high transition on T0CKI pin. bit 4, R/W-1 = T0SE : Timer0 Source Edge Select bit 1 = Increment on high-to-low transition on T0CKI pin 0 = Increment on low-to-high transition on T0CKI pin. bit 4, R/W-1 = T0SE : Timer0 Source Edge Select bit 1 = Increment on high-to-low transition on T0CKI pin 0 = Increment on low-to-high transition on T0CKI pin. bit 4, R/W-1 = T0SE : Timer0 Source Edge Select bit 1 = Increment on high-to-low transition on T0CKI pin 0 = Increment on low-to-high transition on T0CKI pin. bit 4, R/W-1 = T0SE : Timer0",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nSource Edge Select bit 1 = Increment on high-to-low transition on T0CKI pin 0 = Increment on low-to-high transition on T0CKI pin. bit 4, R/W-1 = T0SE : Timer0 Source Edge Select bit 1 = Increment on high-to-low transition on T0CKI pin 0 = Increment on low-to-high transition on T0CKI pin. bit, R/W-1 = PSA : Timer0 Prescaler Assignment bit. bit, R/W-1 = PSA : Timer0 Prescaler Assignment bit. bit, R/W-1 = PSA : Timer0 Prescaler Assignment bit. bit, R/W-1 = PSA : Timer0 Prescaler Assignment bit. bit, R/W-1 = PSA : Timer0 Prescaler Assignment bit. bit, R/W-1 = PSA : Timer0 Prescaler Assignment bit. bit, R/W-1 = PSA : Timer0 Prescaler Assignment bit. bit, R/W-1 = PSA : Timer0 Prescaler Assignment",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nbit. 3, R/W-1 = 1 = TImer0 prescaler is NOT assigned. Timer0 clock input bypasses prescaler. 0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.. 3, R/W-1 = 1 = TImer0 prescaler is NOT assigned. Timer0 clock input bypasses prescaler. 0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.. 3, R/W-1 = 1 = TImer0 prescaler is NOT assigned. Timer0 clock input bypasses prescaler. 0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.. 3, R/W-1 = 1 = TImer0 prescaler is NOT assigned. Timer0 clock input bypasses prescaler. 0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.. 3, R/W-1 = 1 = TImer0 prescaler is NOT assigned. Timer0 clock input bypasses prescaler. 0 = Timer0 prescaler is",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nassigned. Timer0 clock input comes from prescaler output.. 3, R/W-1 = 1 = TImer0 prescaler is NOT assigned. Timer0 clock input bypasses prescaler. 0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.. 3, R/W-1 = 1 = TImer0 prescaler is NOT assigned. Timer0 clock input bypasses prescaler. 0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.. 3, R/W-1 = 1 = TImer0 prescaler is NOT assigned. Timer0 clock input bypasses prescaler. 0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.. bit 2-0, R/W-1 = T0PS2:T0PS0 : Timer0 Prescaler Select bits 111 = 1:256 Prescale value 110 = 1:128 Prescale value 101 = 1:64 Prescale value = 1:32 Prescale value. bit 2-0, R/W-1 =",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nT0PS2:T0PS0 : Timer0 Prescaler Select bits 111 = 1:256 Prescale value 110 = 1:128 Prescale value 101 = 1:64 Prescale value = 1:32 Prescale value. bit 2-0, R/W-1 = T0PS2:T0PS0 : Timer0 Prescaler Select bits 111 = 1:256 Prescale value 110 = 1:128 Prescale value 101 = 1:64 Prescale value = 1:32 Prescale value. bit 2-0, R/W-1 = T0PS2:T0PS0 : Timer0 Prescaler Select bits 111 = 1:256 Prescale value 110 = 1:128 Prescale value 101 = 1:64 Prescale value = 1:32 Prescale value. bit 2-0, R/W-1 = T0PS2:T0PS0 : Timer0 Prescaler Select bits 111 = 1:256 Prescale value 110 = 1:128 Prescale value 101 = 1:64 Prescale value = 1:32 Prescale",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nvalue. bit 2-0, R/W-1 = T0PS2:T0PS0 : Timer0 Prescaler Select bits 111 = 1:256 Prescale value 110 = 1:128 Prescale value 101 = 1:64 Prescale value = 1:32 Prescale value. bit 2-0, R/W-1 = T0PS2:T0PS0 : Timer0 Prescaler Select bits 111 = 1:256 Prescale value 110 = 1:128 Prescale value 101 = 1:64 Prescale value = 1:32 Prescale value. bit 2-0, R/W-1 = T0PS2:T0PS0 : Timer0 Prescaler Select bits 111 = 1:256 Prescale value 110 = 1:128 Prescale value 101 = 1:64 Prescale value = 1:32 Prescale value. , R/W-1 = Legend: R = Readable bit W=Writable bit. , R/W-1 = Legend: R = Readable bit W=Writable bit. , R/W-1 = Legend:",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nR = Readable bit W=Writable bit. , R/W-1 = Legend: R = Readable bit W=Writable bit. , R/W-1 = Legend: R = Readable bit W=Writable bit. , R/W-1 = Legend: R = Readable bit W=Writable bit. , R/W-1 = Legend: R = Readable bit W=Writable bit. , R/W-1 = Legend: R = Readable bit W=Writable bit. , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = U = Unimplemented bit, read as '0'. , R/W-1 = U = Unimplemented bit, read as '0'. , R/W-1 = U = Unimplemented bit, read as '0'. , R/W-1 = U = Unimplemented bit, read as '0'",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nA simplified block diagram of the Timer0 module in 8-bit mode  is  shown  in  Figure 11-1.  Figure 11-2  shows  a simplified block diagram of the Timer0 module in 16-bit mode.",
    "11.1 Timer0 Operation\nTimer0 can operate as either a timer or a counter; the mode is selected by clearing the T0CS bit (T0CON<5>). In Timer mode, the module increments on every clock by default unless a different prescaler value  is  selected  (see Section 11.3  'Prescaler' ).  If the TMR0 register is written to, the increment is inhibited for the following two instruction cycles. The user can work around this by writing an adjusted value to the TMR0 register.\nThe Counter mode is selected by setting the T0CS bit (= 1 ).  In  Counter mode, Timer0 increments either on every  rising  or  falling  edge  of  pin  RA4/T0CKI.  The incrementing edge is determined by the Timer0 Source Edge Select bit, T0SE (T0CON<4>). Clearing this bit selects  the  rising  edge.  Restrictions  on  the  external clock input are discussed below.\ninternal phase clock (TOSC). There is a delay between synchronization  and  the  onset  of  incrementing  the timer/counter.",
    "11.2 Timer0 Reads and Writes in 16-Bit Mode\nTMR0H is not the actual high byte of Timer0 in 16-bit mode; it is actually a buffered version of the real high byte of Timer0, which is not directly readable nor writable (refer to Figure 11-2). TMR0H is updated with the contents of the high byte of Timer0 during a read of TMR0L. This provides the ability to read all 16 bits of Timer0 without having to verify that the read of the high and  low  byte  were  valid,  due  to  a  rollover  between successive reads of the high and low byte.\nAn external clock source can be used to drive Timer0; however, it must meet certain requirements to ensure that  the  external  clock  can  be  synchronized  with  the\nSimilarly, a write to the high byte of Timer0 must also take place through the TMR0H Buffer register. The high byte is updated with the contents of TMR0H when a write occurs to TMR0L. This allows all 16 bits of Timer0 to be updated at once.",
    "11.3 Prescaler\nAn 8-bit counter is available as a prescaler for the Timer0 module. The prescaler is not directly readable or writable; its  value  is  set  by  the  PSA  and  T0PS2:T0PS0  bits (T0CON<3:0>) which determine the prescaler assignment and prescale ratio.\nClearing the PSA bit assigns the prescaler to the Timer0 module. When it is assigned, prescale values from 1:2 through 1:256 in power-of-2 increments are selectable.\nWhen assigned to the Timer0 module, all instructions writing to the TMR0 register (e.g., CLRF TMR0 MOVWF , TMR0 BSF TMR0 , , etc.) clear the prescaler count.\nNote:\nWriting  to  TMR0  when  the  prescaler  is assigned to Timer0 will clear the prescaler count  but  will  not  change  the  prescaler assignment.",
    "11.3.1 SWITCHING PRESCALER ASSIGNMENT\nThe  prescaler  assignment  is  fully under  software control and can be changed 'on-the-fly' during program execution.",
    "11.4 Timer0 Interrupt\nThe  TMR0  interrupt  is  generated  when  the  TMR0 register  overflows  from  FFh  to  00h  in  8-bit  mode,  or from FFFFh to 0000h in 16-bit mode. This overflow sets the TMR0IF flag bit. The interrupt can be masked by clearing  the  TMR0IE  bit  (INTCON<5>).  Before  reenabling the interrupt, the TMR0IF bit must be cleared in software by the Interrupt Service Routine.\nSince Timer0 is shut down in Sleep mode, the TMR0 interrupt cannot awaken the processor from Sleep.",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0L, Bit 7 = Timer0 Module Low Byte Register. TMR0L, Bit 6 = Timer0 Module Low Byte Register. TMR0L, Bit 5 = Timer0 Module Low Byte Register. TMR0L, Bit 4 = Timer0 Module Low Byte Register. TMR0L, Bit 3 = Timer0 Module Low Byte Register. TMR0L, Bit 2 = Timer0 Module Low Byte Register. TMR0L, Bit 1 = Timer0 Module Low Byte Register. TMR0L, Bit 0 = Timer0 Module Low Byte Register. TMR0L, Reset Values on page = 47. TMR0H, Bit 7 = Timer0 Module High Byte Register. TMR0H, Bit 6 = Timer0 Module High Byte Register. TMR0H, Bit 5 = Timer0 Module High Byte Register. TMR0H, Bit 4 = Timer0 Module High Byte Register. TMR0H, Bit 3 = Timer0 Module High Byte Register. TMR0H, Bit 2 = Timer0 Module High Byte Register. TMR0H, Bit 1 =",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nTimer0 Module High Byte Register. TMR0H, Bit 0 = Timer0 Module High Byte Register. TMR0H, Reset Values on page = 47. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Reset Values on page = 47. TRISA, Bit 7 = -.",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nTRISA, Bit 6 = PORTA Data Direction Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Reset Values on page = 49\nLegend:\nx = unknown, u = unchanged, - = unimplemented locations, read as ' 0 '.\nShaded cells are not used by Timer0.",
    "12.0 TIMER1 MODULE\nThe Timer1 timer/counter  module  incorporates  these features:\nA  simplified  block  diagram  of  the  Timer1  module  is shown in Figure 12-1. A block diagram of the module's operation in Read/Write mode is shown in Figure 12-2.\n\u00b7 Software selectable operation as a 16-bit timer or counter\n\u00b7 Readable and writable 8-bit registers (TMR3H and TMR3L)\n\u00b7 Selectable clock source (internal or external) with device clock or Timer1 oscillator internal options\n\u00b7 Interrupt-on-overflow\n\u00b7 Module Reset on CCP1 special event trigger\n\u00b7 Device clock status flag (T1RUN)\nThe module incorporates its own low-power oscillator to  provide  an  additional  clocking  option.  The  Timer1 oscillator can also be used as a low-power clock source for the microcontroller in power managed operation.\nTimer1 can also be used to provide Real-Time Clock (RTC) functionality to applications with only a minimal addition of external components and code overhead.",
    "12.0 TIMER1 MODULE\nTimer1  is controlled through the T1CON  Control register  (Register 12-1).  It  also  contains  the  Timer1 Oscillator Enable  bit  (T1OSCEN).  Timer1  can  be enabled or disabled by setting or clearing control bit, TMR1ON (T1CON<0>).",
    "REGISTER 12-1: T1CON: TIMER1 CONTROL REGISTER\nR/W-0, 1 = R-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. RD16, 1 = T1RUN. RD16, 2 = T1CKPS1. RD16, 3 = T1CKPS0. RD16, 4 = T1OSCEN. RD16, 5 = T1SYNC. RD16, 6 = TMR1CS. RD16, 7 = TMR1ON\nbit 7\nbit 0",
    "bit 7 RD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register read/write of TImer1 in one 16-bit operation\n0 = Enables register read/write of Timer1 in two 8-bit operations\nbit 6 T1RUN: Timer1 System Clock Status bit\n1 = Device clock is derived from Timer1 oscillator\n0 = Device clock is derived from another source",
    "bit 5-4 T1CKPS1:T1CKPS0: Timer1 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value",
    "bit 3 T1OSCEN:\nTimer1 Oscillator Enable bit\n1 = Timer1 oscillator is enabled\n0 = Timer1 oscillator is shut off\nThe oscillator inverter and feedback resistor are turned off to eliminate power drain.",
    "bit 2 T1SYNC: Timer1 External Clock Input Synchronization Select bit\nWhen TMR1CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR1CS = 0 :\nThis bit is ignored. Timer1 uses the internal clock when TMR1CS = 0 .",
    "bit 1 TMR1CS: Timer1 Clock Source Select bit\n1 = External clock from pin RC0/T1OSO/T13CKI (on the rising edge)\n0 = Internal clock (FOSC/4)",
    "bit 0 TMR1ON: Timer1 On bit\n1 = Enables Timer1\n0 = Stops Timer1",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "12.1 Timer1 Operation\nTimer1 can operate in one of these modes:\n\u00b7 Timer\n\u00b7 Synchronous Counter\n\u00b7 Asynchronous Counter\nThe operating mode is determined by the clock select bit, TMR3CS (T3CON<1>). When TMR3CS is cleared (= 0 ), Timer3 increments on every internal instruction",
    "PIC18F2585/2680/4585/4680\ncycle (Fosc/4). When the bit is set, Timer3 increments on every rising edge of the Timer1 external clock input or the Timer1 oscillator, if enabled.\nWhen  Timer1  is  enabled,  the  RC1/T1OSI  and  RC0/ T1OSO/T13CKI pins become inputs. This means the values  of  TRISC<1:0>  are  ignored  and  the  pins  are read as ' 0 '.",
    "FIGURE 12-2: TIMER1 BLOCK DIAGRAM (16-BIT READ/WRITE MODE)\nNote 1: When enable bit T1OSCEN is cleared, the inverter and feedback resistor are turned off to eliminate power drain.",
    "12.2 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured for 16-bit reads and writes (see Figure 12-2). When the RD16 control bit (T1CON<7>) is set, the address for TMR1H is mapped to a buffer register for the high byte of Timer1. A read from TMR1L will load the contents of the high byte of Timer1 into the Timer1 High Byte Buffer register. This provides the user with the ability to accurately read all 16 bits of Timer1 without having to determine whether a read of the high byte, followed by a read of the low byte,  has  become  invalid  due  to  a  rollover  between reads.\nA write to the high byte of Timer1 must also take place through the TMR1H Buffer register. The Timer1 high byte is updated with the contents of TMR1H when a write occurs to TMR1L. This allows a user to write all 16 bits to both the high and low bytes of Timer1 at once.",
    "12.2 Timer1 16-Bit Read/Write Mode\nThe  high  byte  of  Timer1  is  not  directly  readable  or writable in this mode. All reads and writes must take place  through  the  Timer1  High  Byte  Buffer  register. Writes  to  TMR1H  do  not  clear  the  Timer1  prescaler. The prescaler is only cleared on writes to TMR1L.",
    "12.3 Timer1 Oscillator\nAn  on-chip  crystal  oscillator  circuit  is  incorporated between  pins  T1OSI  (input)  and  T1OSO  (amplifier output). It is enabled by setting the Timer1 Oscillator Enable bit, T1OSCEN (T1CON<3>). The oscillator is a low-power  circuit rated for 32 kHz  crystals. It will continue to run during all power managed modes. The circuit for a typical LP oscillator is shown in Figure 12-3. Table 12-1 shows the capacitor selection for the Timer1 oscillator.\nThe user must provide a software time delay to ensure proper start-up of the Timer1 oscillator.",
    "CAPACITOR SELECTION FOR THE TIMER OSCILLATOR (1,2,3,4)\nOsc Type, 1 = Freq. Osc Type, 2 = C1. Osc Type, 3 = C2. LP, 1 = 32 kHz. LP, 2 = 27 pF. LP, 3 = 27 pF\nNote 1: Microchip  suggests  these  values  as  a starting  point  in  validating  the  oscillator circuit.\n2: Higher capacitance increases the stability of the oscillator but also increases the start-up time.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer  for appropriate values of external components.\n4: Capacitor values are for design guidance only.",
    "12.3.1 USING TIMER1 AS A CLOCK SOURCE\nThe Timer1 oscillator is also available as a clock source in power managed modes. By setting the clock select bits, SCS1:SCS0 (OSCCON<1:0>), to ' 01 ', the device switches  to  SEC_RUN  mode;  both  the  CPU  and peripherals are clocked from the Timer1 oscillator. If the IDLEN  bit  (OSCCON<7>)  is  cleared  and  a SLEEP instruction  is  executed,  the  device  enters  SEC_IDLE mode. Additional details are  available in Section 3.0 'Power Managed Modes' .\nWhenever the Timer1 oscillator is providing the clock source,  the  Timer1  system  clock  status  flag,  T1RUN (T1CON<6>), is set. This can be used to determine the controller's current clocking mode. It can also indicate the clock source being currently used by the Fail-Safe Clock Monitor. If the Clock Monitor is enabled and the Timer1 oscillator fails while providing the clock, polling the T1RUN bit will indicate whether the clock is being provided by the Timer1 oscillator or another source.",
    "12.3.2 LOW-POWER TIMER1 OPTION\nThe Timer1 oscillator can operate at two distinct levels of power consumption based on device configuration. When the LPT1OSC Configuration bit is set, the Timer1 oscillator operates in a low-power mode. When LPT1OSC is not set, Timer1 operates at a higher power level. Power consumption for a particular mode is relatively  constant,  regardless  of  the  device's  operating mode. The default Timer1 configuration is the higher power mode.\nAs  the  low-power  Timer1  mode  tends  to  be  more sensitive to interference, high noise environments may cause some oscillator instability. The low-power option is, therefore, best suited for low noise applications where power conservation is an important design consideration.",
    "12.3.3 TIMER1 OSCILLATOR LAYOUT CONSIDERATIONS\nThe  Timer1  oscillator  circuit  draws  very  little  power during operation. Due to the low-power nature of the oscillator, it may also be sensitive to rapidly changing signals in close proximity.\nThe oscillator circuit, shown in Figure 12-3, should be located  as  close  as  possible  to  the  microcontroller. There should be no circuits passing within the oscillator circuit boundaries other than VSS or VDD.\nIf a high-speed circuit must be located near the oscillator (such as the CCP1 pin in Output Compare or PWM mode, or the primary oscillator using the OSC2 pin), a grounded  guard  ring  around  the  oscillator  circuit,  as shown in Figure 12-4, may be helpful when used on a single-sided PCB or in addition to a ground plane.",
    "12.4 Timer1 Interrupt\nThe TMR1 register pair (TMR1H:TMR1L) increments from 0000h to FFFFh and rolls over to 0000h. The Timer1  interrupt,  if  enabled,  is  generated  on  overflow, which is latched in interrupt flag bit, TMR1IF (PIR1<0>). This interrupt can be enabled or disabled by setting or clearing the Timer1 Interrupt Enable bit, TMR1IE (PIE1<0>).",
    "12.5 Resetting Timer1 Using the CCP1 Special Event Trigger\nIf either of the CCP1 modules is configured in Compare mode to generate a special event trigger (CCP1M3:CCP1M0 or CCP2M3:CCP2M0 = 1011 ), this signal will reset Timer1. The trigger from ECCP1 will also start an A/D conversion if the A/D module is enabled (see Section 15.3.4 'Special Event Trigger' for more information.).\nThe module must be configured as either a timer or a synchronous counter to take advantage of this feature. When used this way, the  CCPR1H:CCPR1L register pair effectively becomes a period register for Timer1.\nIf  Timer1  is  running  in  Asynchronous  Counter mode, this Reset operation may not work.\nIn  the  event  that  a  write  to  Timer1  coincides  with  a special  event  trigger,  the  write  operation  will  take precedence.\nNote:, 1 = The special event triggers from the ECCP1 module will not set the TMR1IF interrupt flag bit (PIR1<0>).",
    "12.6 Using Timer1 as a Real-Time Clock\nAdding an external LP oscillator to Timer1 (such as the one  described  in Section 12.3  'Timer1  Oscillator' above) gives users the option to include RTC functionality to their applications. This is accomplished with an inexpensive watch crystal to provide an accurate time base and several lines of application code to calculate the time. When operating in Sleep mode and using a battery  or  supercapacitor  as  a  power  source,  it  can completely  eliminate  the  need  for  a  separate  RTC device and battery backup.\nThe  application code  routine, RTCisr , shown  in Example 12-1, demonstrates a simple method  to increment a counter at one-second intervals using an Interrupt  Service  Routine.  Incrementing  the  TMR1 register pair to overflow triggers the interrupt and calls the routine, which increments the seconds counter by one;  additional  counters  for  minutes  and  hours  are incremented as the previous counter overflow.",
    "12.6 Using Timer1 as a Real-Time Clock\nSince the register pair is 16 bits wide, counting up to overflow the register directly from a 32.768 kHz clock would  take  2  seconds.  To  force  the  overflow  at  the required one-second intervals, it is necessary to preload  it.  The  simplest  method  is  to  set  the  MSb  of TMR1H with a BSF instruction. Note that the TMR1L register  is  never  preloaded  or  altered;  doing  so  may introduce cumulative error over many cycles.\nFor this method to be accurate, Timer1 must operate in Asynchronous mode and the Timer1 overflow interrupt must be enabled (PIE1<0> = 1 ) as shown in the routine, RTCinit . The Timer1 oscillator must also be enabled and running at all times.",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nRTCinit, 1 = MOVLW MOVWF CLRF MOVLW MOVWF CLRF CLRF MOVLW MOVWF BSF RETURN. RTCinit, 2 = 80h TMR1H TMR1L b'00001111' T1OSC secs mins .12 hours PIE1, TMR1IE. RTCinit, 3 = ; ; ;. RTCinit, 4 = Preload TMR1 register pair for 1 second overflow Configure for external clock, Asynchronous operation, external oscillator Initialize timekeeping registers. RTCisr, 1 = BSF BCF. RTCisr, 2 = TMR1H, 7 PIR1, TMR1IF secs, F .59 secs. RTCisr, 3 = ; ;. RTCisr, 4 = Preload for 1 sec overflow Clear interrupt flag Increment seconds 60 seconds elapsed? No, done\nTABLE 12-2:\nREGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/ COUNTER",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE.",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nPIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. TMR1L, Bit 7 = Timer1 Register, Low Byte. TMR1L, Bit 6 = Timer1 Register, Low Byte. TMR1L, Bit 5 = Timer1 Register, Low Byte. TMR1L, Bit 4 = Timer1 Register, Low Byte. TMR1L, Bit 3 = Timer1 Register, Low Byte.",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nTMR1L, Bit 2 = Timer1 Register, Low Byte. TMR1L, Bit 1 = Timer1 Register, Low Byte. TMR1L, Bit 0 = Timer1 Register, Low Byte. TMR1L, Reset Values on page = 47. TMR1H, Bit 7 = TImer1 Register, High Byte. TMR1H, Bit 6 = TImer1 Register, High Byte. TMR1H, Bit 5 = TImer1 Register, High Byte. TMR1H, Bit 4 = TImer1 Register, High Byte. TMR1H, Bit 3 = TImer1 Register, High Byte. TMR1H, Bit 2 = TImer1 Register, High Byte. TMR1H, Bit 1 = TImer1 Register, High Byte. TMR1H, Bit 0 = TImer1 Register, High Byte. TMR1H, Reset Values on page = 47. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1.",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nT1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Reset Values on page = 47\nLegend:\n- x = unknown, u = unchanged, - = unimplemented, read as ' 0 '.\nShaded cells are not used by the Timer1 module.\nNote 1: These bits are unimplemented on PIC18F2X8X devices; always maintain these bits clear.\nNOTES:",
    "13.1 Timer2 Operation\nThe  Timer2  module  timer  incorporates  the  following features:\n\u00b7 8-bit timer and period registers (TMR2 and PR2, respectively)\n\u00b7 Readable and writable (both registers)\n\u00b7 Software programmable prescaler (1:1, 1:4 and 1:16)\n\u00b7 Software programmable postscaler (1:1 through 1:16)\n\u00b7 Interrupt on TMR2-to-PR2 match\n\u00b7 Optional use as the shift clock for the MSSP module\nThe module is controlled through the T2CON register (Register 13-1),  which  enables  or  disables  the  timer and  configures  the  prescaler  and  postscaler.  Timer2 can  be  shut  off  by  clearing  control  bit,  TMR2ON (T2CON<2>), to minimize power consumption.\nA simplified block diagram of the module is shown in Figure 13-1.",
    "13.1 Timer2 Operation\nIn normal operation, TMR2 is incremented from 00h on each  clock  (FOSC/4).  A  2-bit  counter/prescaler  on  the clock input gives direct input, divide-by-4 and divide-by16 prescale options; these are selected by the prescaler control  bits,  T2CKPS1:T2CKPS0  (T2CON<1:0>).  The value of TMR2 is compared to that of the period register, PR2, on each clock cycle. When the two values match, the comparator generates a match signal as the timer output. This signal also resets the value of TMR2 to 00h on the next cycle and drives the output counter/postscaler (see Section 13.2 'Timer2 Interrupt' ).\nThe TMR2 and PR2 registers are both directly readable and  writable.  The  TMR2  register  is  cleared  on  any device Reset, while the PR2 register initializes at FFh. Both the prescaler and postscaler counters are cleared on the following events:",
    "13.1 Timer2 Operation\n\u00b7 a write to the TMR2 register\n\u00b7 a write to the T2CON register\n\u00b7 any device Reset (Power-on Reset, MCLR Reset, Watchdog Timer Reset or Brown-out Reset)\nTMR2 is not cleared when T2CON is written.",
    "REGISTER 13-1: T2CON: TIMER2 CONTROL REGISTER\nU-0, 1 = R/W-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = T2OUTPS3. -, 2 = T2OUTPS2. -, 3 = T2OUTPS1. -, 4 = T2OUTPS0. -, 5 = TMR2ON. -, 6 = T2CKPS1. -, 7 = T2CKPS0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6-3 T2OUTPS3:T2OUTPS0 : Timer2 Output Postscale Select bits\n0000 = 1:1 Postscale",
    "REGISTER 13-1: T2CON: TIMER2 CONTROL REGISTER\n0001 = 1:2 Postscale\n\u2022\n\u2022\n\u2022\n1111 = 1:16 Postscale",
    "bit 2 TMR2ON : Timer2 On bit\n1 = Timer2 is on\n0 = Timer2 is off",
    "bit 1-0 T2CKPS1:T2CKPS0 : Timer2 Clock Prescale Select bits\n00 = Prescaler is 1\n01 = Prescaler is 4\n1x = Prescaler is 16",
    "Legend:\nR = Readable bit\n-n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "13.2 Timer2 Interrupt\nTimer2 also can generate an optional device interrupt. The Timer2 output signal (TMR2-to-PR2 match) provides  the  input  for  the  4-bit  output  counter/postscaler. This counter generates the TMR2 match interrupt flag which is latched in TMR2IF (PIR1<1>). The interrupt  is  enabled  by  setting  the  TMR2  Match  Interrupt Enable bit, TMR2IE (PIE1<1>).\nA range of 16 postscale options (from 1:1 through 1:16 inclusive) can be selected with the postscaler control bits, T2OUTPS3:T2OUTPS0 (T2CON<6:3>).",
    "FIGURE 13-1: TIMER2 BLOCK DIAGRAM\nTABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/",
    "COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 =",
    "COUNTER\nCCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Reset Values on page = 47. T2CON,",
    "COUNTER\nBit 7 = -. T2CON, Bit 6 = T2OUTPS3. T2CON, Bit 5 = T2OUTPS2. T2CON, Bit 4 = T2OUTPS1. T2CON, Bit 3 = T2OUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Reset Values on page = 47. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Reset Values on page = 47\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer2 module.",
    "COUNTER\nNote 1: These bits are unimplemented on PIC18F2X8X devices; always maintain these bits clear.",
    "13.3 TMR2 Output\nThe unscaled output of TMR2 is available primarily to the CCP1 modules, where it is used as a time base for operations in PWM mode.\nTimer2 can be optionally used as the shift clock source for the MSSP  module operating in SPI mode. Additional  information  is provided  in Section 17.0 'Master Synchronous Serial Port (MSSP) Module' .",
    "14.0 TIMER3 MODULE\nThe Timer3 module timer/counter incorporates  these features:\nA  simplified  block  diagram  of  the  Timer3  module  is shown in Figure 14-1. A block diagram of the module's operation in Read/Write mode is shown in Figure 14-2.\n\u00b7 Software selectable operation as a 16-bit timer or counter\n\u00b7 Readable and writable 8-bit registers (TMR3H and TMR3L)\n\u00b7 Selectable clock source (internal or external) with device clock or Timer1 oscillator internal options\n\u00b7 Interrupt-on-overflow\n\u00b7 Module Reset on CCP1 special event trigger",
    "REGISTER 14-1: T3CON: TIMER3 CONTROL REGISTER\nRD16, R/W-0 = T3ECCP1 (1). RD16, R/W-0 = T3CKPS1. RD16, R/W-0 = T3CKPS0. RD16, R/W-0 = T3CCP1 (1). RD16, R/W-0 = T3SYNC. RD16, R/W-0 = TMR3CS. RD16, R/W-0 = TMR3ON\nbit 7\nbit 0\nbit 7 RD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register read/write of Timer3 in one 16-bit operation\n0 = Enables register read/write of Timer3 in two 8-bit operations bit 6,3 T3ECCP1:T3CCP1: Timer3 and Timer1 to ECCP1/CCP1 Enable bits\n(1)\n1x =Timer3 is the capture/compare clock source for both CCP1 and ECCP1 modules\n01 =Timer3 is the capture/compare clock source for ECCP1;",
    "REGISTER 14-1: T3CON: TIMER3 CONTROL REGISTER\nTimer1 is the capture/compare clock source for CCP1\n00 =Timer1 is the capture/compare clock source for both CCP1 and ECCP1 modules\nNote 1: These bits are available on PIC18F4X8X devices only.",
    "bit 5-4 T3CKPS1:T3CKPS0 : Timer3 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value bit 2 T3SYNC: Timer3 External Clock Input Synchronization Control bit\n(Not usable if the device clock comes from Timer1/Timer3.)",
    "When TMR3CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR3CS = 0 :\nThis bit is ignored. Timer3 uses the internal clock when TMR3CS = 0 .",
    "bit 1 TMR3CS: Timer3 Clock Source Select bit\n- 1 = External clock input from Timer1 oscillator or T13CKI (on the rising edge after the first falling edge)\n0 = Internal clock (FOSC/4)",
    "bit 0 TMR3ON: Timer3 On bit\n1 = Enables Timer3\n- 0 = Stops Timer3",
    "Legend:\nR = Readable bit\n-n = Value at POR\nThe Timer3 module is controlled through the T3CON register (Register 14-1). It also selects the clock source options  for  the  CCP1  modules  (see Section 15.1.1 'CCP1  Modules  and  Timer  Resources' for  more information).\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "14.1 Timer3 Operation\nTimer3 can operate in one of three modes:\n\u00b7 Timer\n\u00b7 Synchronous Counter\n\u00b7 Asynchronous Counter\nThe operating mode is determined by the clock select bit, TMR3CS (T3CON<1>). When TMR3CS is cleared (= 0 ), Timer3 increments on every internal instruction",
    "PIC18F2585/2680/4585/4680\ncycle (FOSC/4). When the bit is set, Timer3 increments on every rising edge of the Timer1 external clock input or the Timer1 oscillator if enabled.\nAs  with  Timer1,  the  RC1/T1OSI  and  RC0/T1OSO/ T13CKI pins become inputs when the Timer1 oscillator is enabled. This means the values of TRISC<1:0> are ignored and the pins are read as ' 0 '.",
    "14.2 Timer3 16-Bit Read/Write Mode\nTimer3 can be configured for 16-bit reads and writes (see Figure 14-2). When the RD16 control bit (T3CON<7>) is set, the address for TMR3H is mapped to a buffer register for the high byte of Timer3. A read from TMR3L will load the contents of the high byte of Timer3 into the Timer3 High Byte Buffer register. This provides the user with the ability to accurately read all 16 bits of Timer1 without having to determine whether a read of the high byte, followed by a read of the low byte,  has  become  invalid  due  to  a  rollover  between reads.\nA write to the high byte of Timer3 must also take place through the TMR3H Buffer register. The Timer3 high byte is updated with the contents of TMR3H when a write occurs to TMR3L. This allows a user to write all 16 bits to both the high and low bytes of Timer3 at once.\nThe  high  byte  of  Timer3  is  not  directly  readable  or writable in this mode. All reads and writes must take place through the Timer3 High Byte Buffer register.",
    "14.2 Timer3 16-Bit Read/Write Mode\nWrites  to  TMR3H  do  not  clear  the  Timer3  prescaler. The prescaler is only cleared on writes to TMR3L.",
    "14.3 Using the Timer1 Oscillator as the Timer3 Clock Source\nThe Timer1 internal oscillator may be used as the clock source for Timer3. The Timer1 oscillator is enabled by setting the T1OSCEN (T1CON<3>) bit. To use it as the Timer3 clock source, the TMR3CS bit must also be set. As  previously  noted,  this  also  configures  Timer3  to increment on every rising edge of the oscillator source.\nThe  Timer1  oscillator  is  described  in Section 12.0 'Timer1 Module' .\nTABLE 14-1:\nREGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/ COUNTER",
    "14.3 Using the Timer1 Oscillator as the Timer3 Clock Source\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF (2). PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (2). PIR2, Reset Values on page = 48. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE (2). PIE2, Bit 5 = -. PIE2, Bit 4 =",
    "14.3 Using the Timer1 Oscillator as the Timer3 Clock Source\nEEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (2). PIE2, Reset Values on page = 49. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP (2). IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (2). IPR2, Reset Values on page = 48. TMR3L, Bit 7 = Timer3 Register, Low Byte. TMR3L, Bit 6 = Timer3 Register, Low Byte. TMR3L, Bit 5 = Timer3 Register, Low Byte. TMR3L, Bit 4 = Timer3 Register, Low Byte. TMR3L, Bit 3 = Timer3",
    "14.3 Using the Timer1 Oscillator as the Timer3 Clock Source\nRegister, Low Byte. TMR3L, Bit 2 = Timer3 Register, Low Byte. TMR3L, Bit 1 = Timer3 Register, Low Byte. TMR3L, Bit 0 = Timer3 Register, Low Byte. TMR3L, Reset Values on page = 48. TMR3H, Bit 7 = Timer3 Register, High Byte. TMR3H, Bit 6 = Timer3 Register, High Byte. TMR3H, Bit 5 = Timer3 Register, High Byte. TMR3H, Bit 4 = Timer3 Register, High Byte. TMR3H, Bit 3 = Timer3 Register, High Byte. TMR3H, Bit 2 = Timer3 Register, High Byte. TMR3H, Bit 1 = Timer3 Register, High Byte. TMR3H, Bit 0 = Timer3 Register, High Byte. TMR3H, Reset Values on page = 48. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 =",
    "14.3 Using the Timer1 Oscillator as the Timer3 Clock Source\nT1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Reset Values on page = 47. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3ECCP1 (1). T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1 (1). T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Reset Values on page = 48\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer3 module.",
    "14.3 Using the Timer1 Oscillator as the Timer3 Clock Source\nNote\n1: These bits are available in PIC18F4X8X devices only.\n2: These bits are available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.",
    "14.4 Timer3 Interrupt\nThe TMR3 register pair (TMR3H:TMR3L) increments from 0000h to FFFFh and overflows to 0000h. The Timer3 interrupt, if enabled, is generated on overflow and is latched in the interrupt flag bit, TMR3IF (PIR2<1>). This interrupt can be enabled or disabled by setting or clearing the Timer3  Interrupt  Enable  bit, TMR3IE (PIE2<1>).",
    "14.5 Resetting Timer3 Using the ECCP1 Special Event Trigger\nIf the  ECCP1  module  is  configured  to  generate  a special event trigger in Compare mode (ECCP1M3:ECCP1M0 = 1011 ),  this  signal  will  reset Timer3. It will also start an A/D conversion if the A/D module  is enabled (see Section 15.3.4 'Special Event Trigger' for more information.).\nThe module must be configured as either a timer or synchronous counter to take advantage of this feature. When used this way, the ECCPR1H:ECCPR1L register pair effectively becomes a period register for Timer3.\nIf  Timer3  is  running  in  Asynchronous  Counter mode, the Reset operation may not work.\nIn  the  event  that  a  write  to  Timer3  coincides  with  a special event trigger from a CCP1 module, the write will take precedence.\nNote:\nThe special event triggers from the ECCP1 module will not set  the  TMR3IF interrupt flag bit (PIR1<0>).",
    "15.0 CAPTURE/COMPARE/PWM (CCP1) MODULES\nPIC18F2585/2680  devices  have  one  CCP1  module. PIC18F4585/4680 devices have two CCP1 (Capture/Compare/PWM) modules. CCP1, discussed in this  chapter,  implements  standard  Capture,  Compare and Pulse-Width Modulation (PWM) modes.\nThe CCP1 module contains a 16-bit register which can operate as a 16-bit Capture register, a 16-bit Compare register  or  a  PWM Master/Slave Duty Cycle register. For the sake of clarity, all CCP1 module operation in the following sections is described with respect to CCP1, but is equally applicable to ECCP1.\nECCP1  implements  an  Enhanced  PWM  mode.  The\nECCP1 implementation is discussed in Section 16.0 'Enhanced Capture/Compare/PWM (ECCP1)\nCapture  and  Compare  operations  described  in  this chapter  apply  to  all  standard  and  Enhanced  CCP1 modules. The operations of PWM mode, described in Section 15.4 'PWM Mode' , apply to ECCP1 only.\nModule' .",
    "REGISTER 15-1: CCP1CON: CAPTURE/COMPARE/PWM CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = DC1B1. -, 3 = DC1B0. -, 4 = CCP1M3. -, 5 = CCP1M2. -, 6 = CCP1M1. -, 7 = CCP1M0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-4 DC1B1:DC1B0 : PWM Duty Cycle bit 1 and bit 0 for CCP1 Module\nCapture mode:\nUnused.\nCompare mode:\nUnused.\nPWM mode:",
    "REGISTER 15-1: CCP1CON: CAPTURE/COMPARE/PWM CONTROL REGISTER\nThese bits are the two LSbs (bit 1 and bit 0) of the 10-bit PWM duty cycle. The eight MSbs (DC19:DC12) of the duty cycle are found in ECCPR1L.",
    "bit 3-0 CCP1M3:CCP1M0 : CCP1 Module Mode Select bits\n0000 =Capture/Compare/PWM disabled (resets CCP1 module)\n0001 =Reserved\n0010 =Compare mode, toggle output on match (CCP1IF bit is set)\n0011 =Reserved\n0100 =Capture mode, every falling edge or CAN message received (time-stamp) (1)\n0101 =Capture mode, every rising edge or CAN message received (time-stamp) (1)\n0110 =Capture mode, every 4th rising edge or every 4th CAN  message  received (time-stamp) (1)\n0111 =Capture  mode,  every  16th  rising  edge  or  every  16th  CAN  message  received (time-stamp) (1)\n1000 =Compare mode: initialize CCP1 pin low; on compare match, force CCP1 pin high (CCPIF bit is set)\n1001 =Compare mode: initialize CCP pin high; on compare match, force CCP1 pin low (CCPIF bit is set)\n1010 =Compare mode: generate software interrupt on compare match (CCPIF bit is set, CCP1 pin reflects I/O state)",
    "bit 3-0 CCP1M3:CCP1M0 : CCP1 Module Mode Select bits\n1011 =Compare mode: trigger special event, reset timer (TMR1 or TMR3, CCP1IF bit is set) 11xx =PWM mode\nNote 1: Selected by CANCAP (CIOCON<4>) bit; overrides the CCP1 input pin source.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "15.1 CCP1 Module Configuration\nEach  Capture/Compare/PWM  module  is  associated with a control register (CCP1CON or ECCP1CON) and a data register (CCPR1 or ECCPR1). The data register, in turn, is comprised of two 8-bit registers: CCPR1L or ECCPR1L (low byte) and CCPR1H or ECCPR1H (high byte). All registers are both readable and writable.",
    "15.1.1 CCP1 MODULES AND TIMER RESOURCES\nThe CCP1 modules utilize Timers 1, 2 or 3, depending on the mode selected. Timer1 and Timer3 are available to modules in Capture or Compare modes, while Timer2 is available for modules in PWM mode.\nTABLE 15-1: CCP1 MODE - TIMER RESOURCE\n\nCapture Compare PWM, Timer Resource = Timer1 or Timer3 Timer1 or Timer3 Timer2\nThe  assignment  of  a  particular  timer  to  a  module  is determined by the Timer-to-CCP1/ECCP1 enable bits in the T3CON register (Register 14-1). Both modules may be active at any given time and may share the same timer resource if they are configured to operate in the same mode (Capture/Compare or PWM) at the same time. The interactions between the two modules are summarized in Figure 15-1 and Figure 15-2.",
    "TABLE 15-2: INTERACTIONS BETWEEN CCP1 AND ECCP1 FOR TIMER RESOURCES\nCapture, ECCP1 Mode = Capture. Capture, Interaction = Each module can use TMR1 or TMR3 as the time base. Time base can be different for each CCP1.. Capture, ECCP1 Mode = Compare. Capture, Interaction = CCP1 can be configured for the special event trigger to reset TMR1 or TMR3 (depending upon which time base is used). Automatic A/D conversions on trigger event can also be done. Operation of CCP1 could be affected if it is using the same timer as a time base.. Compare, ECCP1 Mode = Capture. Compare, Interaction = CCP1 can be configured for the special event trigger to reset TMR1 or TMR3 (depending upon which time base is used). Operation of CCP1 could be affected if it is using the same timer as a time base.. Compare, ECCP1 Mode = Compare. Compare, Interaction = Either module can be configured for the special event trigger to reset the time base. Automatic A/D conversions on ECCP1 trigger event can be done. Conflicts may occur if both modules are",
    "TABLE 15-2: INTERACTIONS BETWEEN CCP1 AND ECCP1 FOR TIMER RESOURCES\nusing the same time base.. Capture, ECCP1 Mode = PWM*. Capture, Interaction = None. Compare, ECCP1 Mode = PWM*. Compare, Interaction = None. PWM*, ECCP1 Mode = Capture. PWM*, Interaction = None. PWM*, ECCP1 Mode = Compare. PWM*, Interaction = None. PWM*, ECCP1 Mode = PWM. PWM*, Interaction = Both PWMs will have the same frequency and update rate (TMR2 interrupt).\n- * Includes standard and Enhanced PWM operation.",
    "15.2.4 CCP1 PRESCALER\nIn  Capture  mode,  the  ECCPR1H:ECCPR1L  register pair  captures the 16-bit value of the TMR1 or TMR3 registers when an event occurs on the CCP1 pin (RB3 or RC1, depending on device configuration). An event is defined as one of the following:\n\u00b7 every falling edge\n\u00b7 every rising edge\n\u00b7 every 4th rising edge\n\u00b7 every 16th rising edge\nThe  event is selected by the mode  select bits, CCP1M3:CCP1M0 (CCP1CON<3:0>). When a capture is made, the interrupt request flag bit, CCP1IF (PIR2<1>),  is  set;  it  must  be  cleared  in  software.  If another  capture  occurs  before  the  value  in  register CCPR1 is read, the old captured value is overwritten by the new captured value.",
    "15.2.1 CCP1 PIN CONFIGURATION\nIn Capture mode, the appropriate CCP1 pin should be configured  as  an  input  by  setting  the  corresponding TRIS direction bit.",
    "Note:\nIf  RC2/CCP1  or  RD4/PSP4/ECCP1/P1A is configured as an output, a write to the port can cause a capture condition.",
    "15.2.2 TIMER1/TIMER3 MODE SELECTION\nThe timers that are to be used with the capture feature (Timer1 and/or Timer3) must be running in Timer mode or Synchronized  Counter  mode.  In  Asynchronous Counter  mode,  the  capture  operation  may  not  work. The  timer  to  be  used  with  each  CCP1  module  is selected  in  the  T3CON  register  (see Section 15.1.1 'CCP1 Modules and Timer Resources' ).",
    "15.2.3 SOFTWARE INTERRUPT\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep the CCP1IE or ECCP1IE interrupt enable bit clear to avoid false  interrupts. The  interrupt  flag  bit,  CCP1IF  or ECCP1IF, should also be cleared following any such change in operating mode.\nThere are four prescaler settings in Capture mode; they are specified as part of the operating mode selected by the  mode select bits (CCP1M3:CCP1M0). Whenever the CCP1 module is turned off or the CCP1 module is not in Capture mode, the prescaler counter is cleared. This  means  that  any  Reset  will  clear  the  prescaler counter.\nSwitching from one capture prescaler to another may generate an interrupt. Also, the prescaler counter will not be cleared; therefore, the first capture may be from a non-zero prescaler. Example 15-1 shows the recommended method for switching between capture prescalers.  This  example  also  clears  the  prescaler counter and will not generate the 'false' interrupt.",
    "15.2.5 CAN MESSAGE TIME-STAMP\nThe  CAN  capture  event  occurs  when  a  message  is received  in  any  of  the  receive  buffers.  When  configured, the CAN module provides the trigger to the CCP1 module  to  cause  a  capture  event.  This  feature  is provided to 'time-stamp' the received CAN messages.\nThis feature is enabled by setting the CANCAP bit of the CAN  I/O  Control  register  (CIOCON<4>).  The message  receive  signal  from  the  CAN  module  then takes the place of the events on RC2/CCP1.\nIf  this  feature  is  selected,  then  four  different  capture options for CCP1M<3:0> are available:\n\u00b7 0100 - every time a CAN message is received\n\u00b7 0101 - every time a CAN message is received\n\u00b7 0110 - every 4th time a CAN message is received\n\u00b7 0111 - Capture mode, every 16th time a CAN message is received",
    "EXAMPLE 15-1: CHANGING BETWEEN CAPTURE PRESCALERS\nCLRF\nCCP1CON\n; Turn CCP1 module off\nMOVLW\nNEW_CAPT_PS; Load WREG with the\n; new prescaler mode\n; value and CCP1 ON\nMOVWF CCP1CON\n; Load CCP1CON with\n; this value",
    "15.3 Compare Mode\nIn Compare mode, the 16-bit CCPR1 register value is constantly compared against either the TMR1 or TMR3 register pair value. When a match occurs, the CCP1 pin can be:\n\u00b7 driven high\n\u00b7 driven low\n\u00b7 toggled (high-to-low or low-to-high)\n\u00b7 remain unchanged (that is, reflects the state of the I/O latch)\nThe action on the pin is based on the value of the mode select bits (ECCP1M3:ECCP1M0). At the same time, the interrupt flag bit ECCP1IF is set.",
    "15.3.1 CCP1 PIN CONFIGURATION\nThe user must configure the CCP1 (ECCP1) pin as an output by clearing the appropriate TRIS bit.\nNote:, 1 = Clearing the CCP1CON register will force the RC2 compare output latch (depending on device configuration) to the default low level. This is not the PORTC I/O data latch.",
    "15.3.2 TIMER1/TIMER3 MODE SELECTION\nTimer1 and/or Timer3 must be running in Timer mode or Synchronized Counter mode if the CCP1 module is using the compare feature. In Asynchronous Counter mode, the compare operation may not work.",
    "15.3.3 SOFTWARE INTERRUPT MODE\nWhen the Generate Software Interrupt mode is chosen (CCP1M3:CCP1M0  = 1010 ), the  CCP1  pin  is  not affected. Only a CCP1 interrupt is generated, if enabled and the CCP1IE bit is set.",
    "15.3.4 SPECIAL EVENT TRIGGER\nBoth CCP1 modules are equipped with a special event trigger. This is an internal hardware signal generated in Compare mode to trigger  actions  by  other  modules. The  special  event  trigger  is  enabled  by  selecting the Compare Special Event Trigger mode (CCP1M3:CCP1M0 = 1011 ).\nFor  either  CCP1  module,  the  special  event  trigger resets  the  timer  register  pair  for whichever  timer resource  is  currently  assigned  as  the  module's  time base. This allows the CCPR1 (ECCPR1) registers to serve  as  a  programmable  period  register  for  either timer.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. RCON, Bit 7 = IPEN. RCON, Bit 6 = SBOREN (3). RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Reset Values on page = 47. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR2, Bit 7",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= OSCFIP. IPR2, Bit 6 = CMIP (2). IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (2). IPR2, Reset Values on page = 48. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF (2). PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (2). PIR2, Reset Values on page = 49. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE (2). PIE2, Bit 5 = -. PIE2,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nBit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (2). PIE2, Reset Values on page = 48. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Reset Values on page = 49. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nRegister. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Reset Values on page = 49. TMR1L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nSignificant Byte of the 16-bit TMR1 Register. TMR1L, Reset Values on page = 47. TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR1 Register. TMR1H, Reset Values on page = 47. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Reset Values on page = 47. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n0 = Timer3 Register High Byte. TMR3H, Reset Values on page = 48. TMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = Timer3 Register Low Byte. TMR3L, Reset Values on page = 48. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3ECCP1 (1). T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 =",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Reset Values on page = 48. CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Reset Values on page = 48. CCPR1H, Bit 7 = Capture/Compare/PWM Register 1",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n(MSB). CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Reset Values on page = 48. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 =",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Reset Values on page = 48. ECCPR1L (1), Bit 7 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 6 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 5 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 4 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 3 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 2 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 1 = Enhanced Capture/Compare/PWM Register 1 (LSB).",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nECCPR1L (1), Bit 0 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Reset Values on page = 48. ECCPR1H (1), Bit 7 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 6 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 5 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 4 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 3 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 2 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 1 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n(1), Bit 0 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Reset Values on page = 48. ECCP1CON (1), Bit 7 = EPWM1M1. ECCP1CON (1), Bit 6 = EPWM1M0. ECCP1CON (1), Bit 5 = EDC1B1. ECCP1CON (1), Bit 4 = EDC1B0. ECCP1CON (1), Bit 3 = ECCP1M3. ECCP1CON (1), Bit 2 = ECCP1M2. ECCP1CON (1), Bit 1 = ECCP1M1. ECCP1CON (1), Bit 0 = ECCP1M0. ECCP1CON (1), Reset Values on page = 48\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used by Capture and Compare, Timer1 or Timer3.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nNote\n1: These bits or registers are available on PIC18F4X8X devices only.\n2: These bits are available on PIC18F4X8X devices and reserved on PIC18F2X8X devices.\n3: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '.",
    "15.4 PWM Mode\nIn Pulse-Width Modulation (PWM) mode, the CCP1 pin produces up to a 10-bit resolution PWM output. Since the CCP1 pin is multiplexed with a PORTB or PORTC data latch, the appropriate TRIS bit must be cleared to make the CCP1 pin an output.\nNote:, 1 = Clearing the CCP1CON register will force the RC2 output latch (depending on device configuration) to the default low level. This is not the PORTC I/O data latch.\nFigure 15-3  shows  a  simplified  block  diagram  of  the CCP1 module in PWM mode.\nFor  a  step-by-step  procedure  on  how  to  set  up  the CCP1 module for PWM operation, see Section 15.4.4 'Setup for PWM Operation' .",
    "FIGURE 15-3: SIMPLIFIED PWM BLOCK DIAGRAM\nA PWM output (Figure 15-4) has a time base (period) and a time that the output stays high (duty cycle). The frequency  of  the  PWM  is  the  inverse  of  the  period (1/period).",
    "15.4.1 PWM PERIOD\nThe  PWM  period  is  specified  by  writing  to  the  PR2 (PR4)  register.  The  PWM  period  can  be  calculated using the following formula.",
    "EQUATION 15-1:\nPWM Period   = (PR2) + 1] \u00b7 4 \u00b7 TOSC \u00b7 (TMR2 Prescale Value)\nPWM frequency is defined as 1/[PWM period].\nWhen  TMR1  (TMR3)  is  equal  to  PR2  (PR2),  the following  three  events  occur  on  the  next  increment cycle:\n\u00b7 TMR2 is cleared\n\u00b7 The CCP1 pin is set (exception: if PWM duty cycle = 0%, the CCP1 pin will not be set)\n\u00b7 The PWM duty cycle is latched from ECCPR1L into ECCPR1H\nNote:\nThe Timer2 postscalers (see Section 13.0 'Timer2  Module' )  are  not  used  in  the determination of the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "15.4.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the ECCPR1L register and to the CCP1CON<5:4> bits. Up to 10-bit resolution is available. The ECCPR1L contains the eight MSbs and the CCP1CON<5:4> contains the two LSbs. This 10-bit value is represented by ECCPR1L:ECCP1CON<5:4>. The following equation is used to calculate the PWM duty cycle in time.",
    "EQUATION 15-2:\nPWM Duty Cycle  = (ECCPR1L:ECCP1CON<5:4>) \u00b7 TOSC \u00b7 (TMR2 Prescale Value)\nECCPR1L and ECCP1CON<5:4> can be written to at any time, but the duty cycle value is not latched into ECCPR1H until after a match between PR2 and TMR2 occurs  (i.e.,  the  period  is  complete).  In  PWM  mode, ECCPR1H is a read-only register.",
    "PIC18F2585/2680/4585/4680\nThe ECCPR1H register and a 2-bit internal latch are used  to  double-buffer  the  PWM  duty  cycle.  This double-buffering is essential for glitchless PWM operation.",
    "EQUATION 15-3:\nWhen  the  ECCPR1H  and  2-bit  latch  match  TMR2, concatenated with an internal 2-bit Q clock or 2 bits of the TMR2 prescaler, the CCP1 pin is cleared.\n<!-- formula-not-decoded -->\nThe maximum PWM resolution (bits) for a given PWM frequency is given by the equation.\nNote:\nIf the PWM duty cycle value is longer than the PWM period, the ECCP1 pin will not be cleared.",
    "TABLE 15-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.77 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.25 kHz = 1. Timer Prescaler (1, 4, 16), 312.50 kHz = 1. Timer Prescaler (1, 4, 16), 416.67 kHz = 1. PR2 Value, 2.44 kHz = FFh. PR2 Value, 9.77 kHz = FFh. PR2 Value, 39.06 kHz = FFh. PR2 Value, 156.25 kHz = 3Fh. PR2 Value, 312.50 kHz = 1Fh. PR2 Value, 416.67 kHz = 17h. Maximum Resolution (bits), 2.44 kHz = 14. Maximum Resolution (bits), 9.77 kHz = 12. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits), 156.25 kHz =",
    "TABLE 15-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\n8. Maximum Resolution (bits), 312.50 kHz = 7. Maximum Resolution (bits), 416.67 kHz = 6.58",
    "15.4.4 SETUP FOR PWM OPERATION\nThe  PWM  auto-shutdown  features  of  the  Enhanced CCP1 module are available to ECCP1 in PIC18F4585/4680 (40/44-pin) devices. The operation of this feature is discussed in detail in Section 16.4.7 'Enhanced PWM Auto-Shutdown' .\nAuto-shutdown features are not available for CCP1.\nThe following steps should be taken when configuring the CCP1 module for PWM operation:\n1. Set  the  PWM  period  by  writing  to  the  PR2 register.\n2. Set  the  PWM  duty  cycle  by  writing  to  the CCPR1L register and CCP1CON<5:4> bits.\n3. Make the CCP1 pin an output by clearing the appropriate TRIS bit.\n4. Set the TMR2 prescale value, then enable Timer2 by writing to T2CON.\n5. Configure the CCP1 module for PWM operation.",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. RCON, Bit 7 = IPEN. RCON, Bit 6 = SBOREN (2). RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Reset Values on page = 47. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF.",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nPIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. TRISB, Bit 7 = PORTB Data Direction Register.",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nTRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Reset Values on page = 49. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Reset Values on page = 49. TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register.",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nTMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Reset Values on page = 47. PR2, Bit 7 = Timer2 Module Period Register. PR2, Bit 6 = Timer2 Module Period Register. PR2, Bit 5 = Timer2 Module Period Register. PR2, Bit 4 = Timer2 Module Period Register. PR2, Bit 3 = Timer2 Module Period Register. PR2, Bit 2 = Timer2 Module Period Register. PR2, Bit 1 = Timer2 Module Period Register. PR2, Bit 0 = Timer2 Module Period Register. PR2, Reset Values on page = 47. T2CON, Bit 7 = -. T2CON, Bit 6 = T2OUTPS3. T2CON, Bit 5 = T2OUTPS2. T2CON, Bit 4 = T2OUTPS1. T2CON, Bit 3 =",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nT2OUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Reset Values on page = 47. CCPR1L (1), Bit 7 = Capture/Compare/PWM Register 1 (LSB). CCPR1L (1), Bit 6 = Capture/Compare/PWM Register 1 (LSB). CCPR1L (1), Bit 5 = Capture/Compare/PWM Register 1 (LSB). CCPR1L (1), Bit 4 = Capture/Compare/PWM Register 1 (LSB). CCPR1L (1), Bit 3 = Capture/Compare/PWM Register 1 (LSB). CCPR1L (1), Bit 2 = Capture/Compare/PWM Register 1 (LSB). CCPR1L (1), Bit 1 = Capture/Compare/PWM Register 1 (LSB). CCPR1L (1), Bit 0 =",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCapture/Compare/PWM Register 1 (LSB). CCPR1L (1), Reset Values on page = 48. CCPR1H (1), Bit 7 = Capture/Compare/PWM Register 1 (MSB). CCPR1H (1), Bit 6 = Capture/Compare/PWM Register 1 (MSB). CCPR1H (1), Bit 5 = Capture/Compare/PWM Register 1 (MSB). CCPR1H (1), Bit 4 = Capture/Compare/PWM Register 1 (MSB). CCPR1H (1), Bit 3 = Capture/Compare/PWM Register 1 (MSB). CCPR1H (1), Bit 2 = Capture/Compare/PWM Register 1 (MSB). CCPR1H (1), Bit 1 = Capture/Compare/PWM Register 1 (MSB). CCPR1H (1), Bit 0 = Capture/Compare/PWM Register 1 (MSB). CCPR1H (1), Reset Values on page =",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n48. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Reset Values on page = 48. ECCPR1L (1), Bit 7 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 6 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 5 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 4 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 3 = Enhanced",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCapture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 2 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 1 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Bit 0 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (1), Reset Values on page = 48. ECCPR1H (1), Bit 7 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 6 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 5 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 4 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 3 = Enhanced Capture/Compare/PWM Register 1",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n(MSB). ECCPR1H (1), Bit 2 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 1 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Bit 0 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (1), Reset Values on page = 48. ECCP1CON (1), Bit 7 = EPWM1M1. ECCP1CON (1), Bit 6 = EPWM1M0. ECCP1CON (1), Bit 5 = EDC1B1. ECCP1CON (1), Bit 4 = EDC1B0. ECCP1CON (1), Bit 3 = ECCP1M3. ECCP1CON (1), Bit 2 = ECCP1M2. ECCP1CON (1), Bit 1 = ECCP1M1. ECCP1CON (1), Bit 0 = ECCP1M0.",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nECCP1CON (1), Reset Values on page = 48\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used by PWM or Timer2.\nNote\n1: These registers are unimplemented on PIC18F2X8X devices.\n2: The SBOREN bit is only available when CONFIG2L<1:0> = 01 ; otherwise, it is disabled and reads as ' 0 '.",
    "16.0 ENHANCED CAPTURE/COMPARE/PWM (ECCP1) MODULE\nenhanced features are discussed in detail in\nNote:\nThe ECCP1 module is implemented only in PIC18F4X8X (40/44-pin) devices.\nSection 16.4 'Enhanced  PWM  Mode' . Capture, Compare  and  single  output  PWM  functions  of  the ECCP1  module  are  the  same  as  described  for  the standard CCP1 module.\nIn PIC18F4585/4680 devices, ECCP1 is implemented as  a  standard  CCP1  module  with  Enhanced  PWM capabilities.  These  include  the  provision  for  2  or  4 output  channels,  user  selectable  polarity,  dead-band control and  automatic  shutdown  and  restart.  The\nThe control register for the Enhanced CCP1 module is shown in Register 16-1. It differs from the CCP1CON register  in  the  PIC18F2585/2680  devices  in  that  the two  Most  Significant  bits  are  implemented  to  control PWM functionality.",
    "REGISTER 16-1: ECCP1CON REGISTER (ECCP1 MODULE, PIC18F4585/4680 DEVICES)\nEPWM1M1, R/W-0 = EPWM1M0. EPWM1M1, R/W-0 = EDC1B1. EPWM1M1, R/W-0 = EDC1B0. EPWM1M1, R/W-0 = ECCP1M3. EPWM1M1, R/W-0 = ECCP1M2. EPWM1M1, R/W-0 = ECCP1M1. EPWM1M1, R/W-0 = ECCP1M0. bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = bit 0\nbit 7-6\nEPWM1M1:EPWM1M0:\nEnhanced PWM Output Configuration bits",
    "REGISTER 16-1: ECCP1CON REGISTER (ECCP1 MODULE, PIC18F4585/4680 DEVICES)\nIf ECCP1M3:ECCP1M2 = 00 01 10 , , :\nxx =P1A assigned as Capture/Compare input/output; P1B, P1C, P1D assigned as port pins\nIf ECCP1M3:ECCP1M2 = 11 :\n00 =Single output: P1A modulated; P1B, P1C, P1D assigned as port pins\n10 =Half-bridge output: P1A, P1B modulated with dead-band control; P1C, P1D assigned as port pins\n01 =Full-bridge output forward: P1D modulated; P1A active; P1B, P1C inactive\n11 =Full-bridge output reverse: P1B modulated; P1C active; P1A, P1D inactive",
    "bit 5-4 EDC1B1:EDC1B0 : PWM Duty Cycle bit 1 and bit 0\nCapture mode:\nUnused.\nCompare mode:\nUnused.\nPWM mode:\nThese bits are the two LSbs of the 10-bit PWM duty cycle. The eight MSbs of the duty cycle are found in CCPR1L/ECCPR1L.",
    "bit 3-0 ECCP1M3:ECCP1M0 : Enhanced CCP1 Mode Select bits\n0000 =Capture/Compare/PWM off (resets ECCP1 module)\n0010 =Compare mode, toggle output on match\n0001 =Reserved\n0011 =Reserved\n0101 =Capture mode, every rising edge\n- 0100 =Capture mode, every falling edge\n0110 =Capture mode, every 4th rising edge\n1000 =Compare mode, initialize ECCP1 pin low, set output on compare match (set ECCP1IF)\n0111 =Capture mode, every 16th rising edge\n1001 =Compare mode, initialize ECCP1 pin high, clear output on compare match (set ECCP1IF)\n- 1011 =Compare mode, trigger special event (ECCP1 resets TMR1 or TMR3, sets ECCP1IF bit and starts the A/D conversion on ECCP1 match)\n1010 =Compare mode, generate software interrupt only, ECCP1 pin reverts to I/O state\n1100 =PWM mode; P1A, P1C active-high; P1B, P1D active-high",
    "bit 3-0 ECCP1M3:ECCP1M0 : Enhanced CCP1 Mode Select bits\n1110 =PWM mode; P1A, P1C active-low; P1B, P1D active-high\n1101 =PWM mode; P1A, P1C active-high; P1B, P1D active-low\n1111 =PWM mode; P1A, P1C active-low; P1B, P1D active-low",
    "Legend:\nR = Readable bit\n-n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown\nIn addition to the expanded range of modes available through  the  CCP1CON  register,  the  ECCP1  module has two additional registers associated with Enhanced PWM operation and auto-shutdown features. They are:\n\u00b7 ECCP1DEL (Dead-band delay)\n\u00b7 ECCP1AS (Auto-shutdown configuration)",
    "16.1 ECCP1 Outputs and Configuration\nThe  Enhanced  CCP1  module  may  have  up  to  four PWM outputs,  depending  on  the  selected  operating mode. These outputs, designated P1A through P1D, are multiplexed with I/O pins on PORTC and PORTD. The  outputs  that  are  active  depend  on  the  CCP1 operating  mode  selected.  The  pin  assignments  are summarized in Table 16-1.\nTo configure the I/O pins as PWM outputs, the proper PWM  mode must be selected by setting the EPWM1M1:EPWM1M0  and  CCP1M3:CCP1M0  bits. The appropriate TRISC and TRISD direction bits for the port pins must also be set as outputs.",
    "16.2 Capture and Compare Modes\nExcept  for  the  operation  of  the  special  event  trigger discussed below, the Capture and Compare modes of the ECCP1 module are identical in operation to that of CCP1. These are discussed in  detail  in Section 15.2 'Capture Mode' and Section 15.3 'Compare Mode' .",
    "16.2.1 SPECIAL EVENT TRIGGER\nThe special event trigger output of ECCP1 resets the TMR1 or TMR3 register pair, depending on which timer resource is currently selected. This allows the ECCP1 register to effectively be a 16-bit programmable period register for Timer1 or Timer3. The special event trigger for ECCP1 can also start an A/D conversion. In order to start the conversion, the A/D  converter  must  be previously enabled.",
    "16.3 Standard PWM Mode\nWhen configured in Single Output mode, the ECCP1 module  functions  identically  to  the  standard  CCP1 module in PWM mode, as described in Section 15.4 'PWM Mode' .  This is also sometimes referred to as 'Compatible CCP1' mode, as in Table 16-1.\nLike the standard CCP1 modules, the ECCP1 module can utilize Timers 1, 2 or 3, depending on the mode selected. Timer1 and Timer3 are available for modules in Capture or Compare  modes,  while  Timer2  is available  for  modules  in  PWM  mode.  Interactions between the standard and Enhanced CCP1 modules are  identical  to  those  described  for  standard  CCP1 modules.  Additional  details  on  timer  resources  are provided in Section 15.1.1 'CCP1  Modules  and Timer Resources' .\nNote:\nWhen setting up single output PWM operations, users are free to use either of the processes described in Section 15.4.4 'Setup for PWM Operation' or Section 16.4.9 'Setup for PWM Operation' . The  latter  is  more  generic  but  will  work  for either single or multi-output PWM.",
    "TABLE 16-1: PIN ASSIGNMENTS FOR VARIOUS ECCP1 MODES\nAll PIC18F4585/4680 devices:, CCP1CON Configuration = All PIC18F4585/4680 devices:. All PIC18F4585/4680 devices:, RD4 = All PIC18F4585/4680 devices:. All PIC18F4585/4680 devices:, RD5 = All PIC18F4585/4680 devices:. All PIC18F4585/4680 devices:, RD6 = All PIC18F4585/4680 devices:. All PIC18F4585/4680 devices:, RD7 = All PIC18F4585/4680 devices:. Compatible CCP1, CCP1CON Configuration = 00xx 11xx. Compatible CCP1, RD4 = CCP1. Compatible CCP1, RD5 = RD5/PSP5. Compatible CCP1, RD6 = RD6/PSP6. Compatible CCP1, RD7 = RD7/PSP7. Dual PWM, CCP1CON Configuration = 10xx 11xx. Dual PWM, RD4 = P1A. Dual",
    "TABLE 16-1: PIN ASSIGNMENTS FOR VARIOUS ECCP1 MODES\nPWM, RD5 = P1B. Dual PWM, RD6 = RD6/PSP6. Dual PWM, RD7 = RD7/PSP7. Quad PWM, CCP1CON Configuration = x1xx 11xx. Quad PWM, RD4 = P1A. Quad PWM, RD5 = P1B. Quad PWM, RD6 = P1C. Quad PWM, RD7 = P1D\nLegend: x = Don't care. Shaded cells indicate pin assignments not used by ECCP1 in a given mode.",
    "16.4 Enhanced PWM Mode\nThe Enhanced PWM mode provides additional PWM output options for a broader range of control applications. The module is a backward compatible version of the standard CCP1 module and offers up to four outputs, designated P1A through P1D. Users are also able to select the polarity of the signal (either active-high or active-low). The module's output mode and polarity are configured by setting the EPWM1M1:EPWM1M0 and CCP1M3:CCP1M0 bits of the ECCP1CON register.",
    "16.4 Enhanced PWM Mode\nFigure 16-1 shows a simplified block diagram of PWM operation. All control registers are double-buffered and are loaded at the beginning of a new PWM cycle (the period  boundary  when  Timer2  resets)  in  order  to prevent glitches on any of the outputs. The exception is the PWM Delay register, ECCP1DEL, which is loaded at  either  the  duty  cycle  boundary  or  the  boundary period (whichever comes first). Because of the buffering,  the  module  waits  until  the  assigned  timer  resets instead of starting immediately. This means  that Enhanced PWM waveforms do not exactly match the standard  PWM  waveforms  but  are  instead  offset  by one full instruction cycle (4 TOSC).",
    "16.4.1 PWM PERIOD\nThe  PWM  period  is  specified  by  writing  to  the  PR2 register. The PWM period can be calculated using the following equation.",
    "EQUATION 16-1:\nPWM Period   = [(PR2) + 1] \u00b7 4 \u00b7 TOSC \u00b7\n(TMR2 Prescale Value)\nPWM frequency is defined as 1/[PWM period]. When TMR2 is equal to PR2, the following three events occur on the next increment cycle:\n\u00b7 TMR2 is cleared\n\u00b7 The ECCP1 pin is set (if PWM duty cycle = 0%, the ECCP1 pin will not be set)\n\u00b7 The PWM duty cycle is copied from ECCPR1L into ECCPR1H\nNote:\nAs  before,  the  user  must  manually  configure  the appropriate TRIS bits for output.\nThe Timer2 postscaler (see Section 13.0 'Timer2  Module' ) is not  used  in  the determination of the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "16.4.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the ECCPR1L register and to the ECCP1CON<5:4> bits. Up  to  10-bit  resolution  is  available.  The  ECCPR1L contains  the  eight  MSbs  and  the  ECCP1CON<5:4> contains the two LSbs. This 10-bit value is represented by ECCPR1L:ECCP1CON<5:4>. The PWM duty cycle is calculated by the following equation.",
    "EQUATION 16-2:\nPWM Duty Cycle   = (ECCPR1L:ECCP1CON<5:4> \u00b7 TOSC \u00b7 (TMR2 Prescale Value)\nECCPR1L and ECCP1CON<5:4> can be written to at any time,  but  the  duty  cycle  value  is  not  copied  into ECCPR1H  until  a  match  between  PR2  and  TMR2 occurs  (i.e.,  the  period  is  complete).  In  PWM  mode, ECCPR1H is a read-only register.",
    "EQUATION 16-3:\n<!-- formula-not-decoded -->\nNote:\nIf the PWM duty cycle value is longer than the PWM period, the CCP1 pin will not be cleared.",
    "16.4.3 PWM OUTPUT CONFIGURATIONS\nThe  EPWM1M1:EPWM1M0  bits  in  the  ECCP1CON register allow one of four configurations:\n\u00b7 Single Output\n\u00b7 Half-Bridge Output\n\u00b7 Full-Bridge Output, Forward mode\nThe ECCPR1H register and a 2-bit internal latch are used  to  double-buffer  the  PWM  duty  cycle.  This double-buffering is essential for glitchless PWM operation. When the ECCPR1H and 2-bit latch match TMR2, concatenated with an internal 2-bit Q clock or two bits of the TMR2 prescaler, the ECCP1 pin is cleared. The maximum  PWM  resolution  (bits)  for  a  given  PWM frequency is given by the following equation.\n- \u00b7 Full-Bridge Output, Reverse mode\nThe Single Output mode is the standard PWM mode discussed in Section 16.4 'Enhanced PWM Mode' . The  Half-Bridge  and  Full-Bridge  Output  modes  are covered in detail in the sections that follow.\nThe general relationship of the outputs in all configurations is summarized in Figure 16-2.\n",
    "16.4.3 PWM OUTPUT CONFIGURATIONS\nTABLE 16-2: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz",
    "16.4.3 PWM OUTPUT CONFIGURATIONS\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.77 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.25 kHz = 1. Timer Prescaler (1, 4, 16), 312.50 kHz = 1. Timer Prescaler (1, 4, 16), 416.67 kHz = 1. PR2 Value, 2.44 kHz = FFh. PR2 Value, 9.77 kHz = FFh. PR2 Value, 39.06 kHz = FFh. PR2 Value, 156.25 kHz = 3Fh. PR2 Value, 312.50 kHz = 1Fh. PR2 Value, 416.67 kHz = 17h. Maximum Resolution (bits), 2.44 kHz = 10. Maximum Resolution (bits), 9.77 kHz = 10. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits), 156.25 kHz = 8. Maximum Resolution",
    "16.4.3 PWM OUTPUT CONFIGURATIONS\n(bits), 312.50 kHz = 7. Maximum Resolution (bits), 416.67 kHz = 6.58",
    "PWM OUTPUT RELATIONSHIPS (ACTIVE-HIGH STATE)\n00, ECCP1CON <7:6>. = (Single Output). 00, SIGNAL. = P1A Modulated. 00, 0.Duty Cycle = Delay (1). 00,  = (1). 00, PR2 + 1. = . 10, ECCP1CON <7:6>. = (Half-Bridge). 10, SIGNAL. = P1A Modulated. 10, 0.Duty Cycle = . 10,  = Delay. 10, PR2 + 1. = . , ECCP1CON <7:6>. = . , SIGNAL. = P1B Modulated. , 0.Duty Cycle = . ,  = . , PR2 + 1. = . 01, ECCP1CON <7:6>. = (Full-Bridge, Forward). 01, SIGNAL. = P1A Active. 01, 0.Duty Cycle = . 01,  = . 01, PR2 + 1. = . , ECCP1CON <7:6>. = . , SIGNAL. = P1B Inactive. , 0.Duty Cycle = . ,",
    "PWM OUTPUT RELATIONSHIPS (ACTIVE-HIGH STATE)\n= . , PR2 + 1. = . 11, ECCP1CON <7:6>. = . 11, SIGNAL. = P1C Inactive P1D Modulated. 11, 0.Duty Cycle = . 11,  = . 11, PR2 + 1. = . , ECCP1CON <7:6>. = (Full-Bridge, Reverse). , SIGNAL. = P1A Inactive P1B Modulated P1C Active. , 0.Duty Cycle = . ,  = . , PR2 + 1. = ",
    "FIGURE 16-3: PWM OUTPUT RELATIONSHIPS (ACTIVE-LOW STATE)\n00, ECCP1CON = (Single Output). 00, SIGNAL = P1A Modulated. 00, 0. = . 00,  = . 10, ECCP1CON = (Half-Bridge). 10, SIGNAL = P1B Modulated. 10, 0. = Delay (1). 10,  = Delay (1). 01, ECCP1CON = (Full-Bridge,. 01, SIGNAL = P1A Active. 01, 0. = . 01,  = . , ECCP1CON = Forward). , SIGNAL = P1B Inactive. , 0. = . ,  = . , ECCP1CON = . , SIGNAL = P1D Modulated. , 0. = . ,  = . 11, ECCP1CON = P1B Modulated (Full-Bridge,. 11, SIGNAL = P1A Inactive. 11, 0. = . 11,  = . , ECCP1CON = P1C Reverse). , SIGNAL = Active. , 0. = . ,  = . , ECCP1CON = P1D Inactive. , SIGNAL = . , 0. = . ,  = ",
    "Relationships:\n\u00b7 Period = 4 * TOSC * (PR2 + 1) * (TMR2 Prescale Value)\n\u00b7 Duty Cycle = TOSC * (ECCPR1L<7:0>:ECCP1CON<5:4>) * (TMR2 Prescale Value)\n\u00b7 Delay = 4 * TOSC * (ECCP1DEL<6:0>)\nNote1: Dead-band delay is programmed using the ECCP1DEL register ( Section 16.4.6 'Programmable Dead-Band Delay' ).",
    "16.4.4 HALF-BRIDGE MODE\nIn the Half-Bridge Output mode, two pins are used as outputs  to  drive  push-pull  loads.  The  PWM  output signal is output on the P1A pin, while the complementary  PWM  output  signal  is  output  on  the  P1B  pin (Figure 16-4). This mode can be used for half-bridge applications, as shown in Figure 16-5, or for full-bridge applications  where  four  power  switches  are  being modulated with two PWM signals.\nIn Half-Bridge Output mode, the programmable dead-band delay can be used to prevent shoot-through current in half-bridge power devices. The value of bits, PDC6:PDC0,  sets  the  number  of  instruction  cycles before the output is driven active. If the value is greater than the duty cycle, the corresponding output remains inactive  during  the  entire  cycle.  See Section 16.4.6 'Programmable Dead-Band Delay' for more details of the dead-band delay operations.",
    "HALF-BRIDGE PWM OUTPUT\nSince the P1A and P1B outputs are multiplexed with the  PORTD<4>  and  PORTD<5>  data  latches,  the TRISD<4>  and  TRISD<5>  bits  must  be  cleared  to configure P1A and P1B as outputs.",
    "16.4.5 FULL-BRIDGE MODE\nIn  Full-Bridge  Output  mode,  four  pins  are  used  as outputs; however, only two outputs are active at a time. In  the  Forward mode, pin P1A is continuously active and pin P1D is modulated. In the Reverse mode, pin P1C is continuously active and pin P1B is modulated. These are illustrated in Figure 16-6.\nP1A, P1B, P1C and P1D outputs are multiplexed with the PORTD<4>, PORTD<5>, PORTD<6> and PORTD<7> data latches. The TRISD<4>, TRISD<5>, TRISD<6>  and  TRISD<7>  bits  must  be  cleared  to make the P1A, P1B, P1C and P1D pins outputs.\nFIGURE 16-6: FULL-BRIDGE PWM OUTPUT",
    "16.4.5 FULL-BRIDGE MODE\n, Forward Mode = . , Forward Mode = Period. , Forward Mode = . , Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . , Forward Mode = Duty Cycle. , Forward Mode = . , Forward Mode = . , Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . P1D (2), Forward Mode = . P1D (2), Forward Mode = . P1D (2), Forward Mode = . P1D (2), Forward Mode = . , Forward Mode = . , Forward Mode = . , Forward Mode = (1). , Forward Mode = . , Forward Mode =",
    "16.4.5 FULL-BRIDGE MODE\n(1). , Forward Mode = . , Forward Mode = . , Forward Mode = . Reverse Mode, Forward Mode = Reverse Mode. Reverse Mode, Forward Mode = Reverse Mode. Reverse Mode, Forward Mode = Reverse Mode. Reverse Mode, Forward Mode = Reverse Mode. , Forward Mode = . , Forward Mode = Period. , Forward Mode = . , Forward Mode = . , Forward Mode = Duty Cycle. , Forward Mode = . , Forward Mode = . , Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . (2), Forward Mode = . (2), Forward Mode = .",
    "16.4.5 FULL-BRIDGE MODE\n(2), Forward Mode = . (2), Forward Mode = . P1D, Forward Mode = . P1D, Forward Mode = . P1D, Forward Mode = . P1D, Forward Mode = . , Forward Mode = (1). , Forward Mode = . , Forward Mode = (1). , Forward Mode = . Note 1: At this time, the TMR2 register is equal to the PR2 register., Forward Mode = Note 1: At this time, the TMR2 register is equal to the PR2 register.. Note 1: At this time, the TMR2 register is equal to the PR2 register., Forward Mode = Note 1: At this time, the TMR2 register is equal to the PR2 register.. Note 1: At this time, the TMR2 register is equal to the PR2 register., Forward Mode = Note 1: At this time, the TMR2 register is equal to the PR2 register.. Note 1: At this time, the TMR2 register is equal to the PR2 register., Forward Mode = Note 1: At this time,",
    "16.4.5 FULL-BRIDGE MODE\nthe TMR2 register is equal to the PR2 register.",
    "16.4.5.1 Direction Change in Full-Bridge Mode\nIn the Full-Bridge Output mode, the EPWM1M1 bit in the CCP1CON register allows the user to control the forward/reverse direction. When the application firmware changes this direction control bit, the module will assume the new direction on the next PWM cycle.\nJust  before  the  end  of  the  current  PWM  period,  the modulated outputs (P1B and P1D) are placed in their inactive state, while the unmodulated outputs (P1A and P1C) are switched to drive in the opposite direction. This  occurs  in  a  time  interval  of  (4  TOSC  *  (Timer2 Prescale Value)) before the next PWM period begins. The Timer2 prescaler will be either 1, 4 or 16, depending  on  the  value  of  the  T2CKPS  bit  (T2CON<1:0>). During the interval from the switch of the unmodulated outputs  to  the beginning  of  the  next  period,  the modulated  outputs  (P1B  and  P1D)  remain  inactive. This relationship is shown in Figure 16-8.",
    "16.4.5.1 Direction Change in Full-Bridge Mode\nNote that  in  the  Full-Bridge  Output  mode,  the  CCP1 module  does  not  provide  any  dead-band  delay.  In general, since only one output is modulated at all times, dead-band delay is not required. However, there is a situation where a dead-band delay might be required. This situation occurs  when  both  of  the  following conditions are true:\n1. The direction of the PWM output changes when the duty cycle of the output is at or near 100%.\n2. The turn-off time of the power switch, including the  power  device  and  driver  circuit,  is  greater than the turn-on time.",
    "16.4.5.1 Direction Change in Full-Bridge Mode\nFigure 16-9 shows an example where the PWM direction changes from forward to reverse at a near 100% duty  cycle.  At  time  t1,  the  outputs  P1A  and  P1D become inactive, while output P1C becomes active. In this  example,  since  the  turn-off  time  of  the  power devices is longer than the turn-on time, a shoot-through current may flow through power devices, QC and QD (see  Figure 16-7),  for  the  duration  of  't'.  The  same phenomenon will occur to power devices, QA and QB, for PWM direction change from reverse to forward.\nIf changing PWM direction at high duty cycle is required for  an  application,  one  of  the  following  requirements must be met:\n1. Reduce PWM  for a PWM  period before changing directions.\n2. Use switch drivers that can drive the switches off faster than they can drive them on.\nOther  options  to  prevent  shoot-through  current  may exist.",
    "FIGURE 16-9: PWM DIRECTION CHANGE AT NEAR 100% DUTY CYCLE\n16.4.6\nPROGRAMMABLE DEAD-BAND DELAY\nNote:\nProgrammable  dead-band  delay  is  not implemented in PIC18F2X8X devices with standard CCP1 modules.\nIn half-bridge applications where all power switches are modulated at the PWM frequency at all times, the power switches normally require more time to turn off than to turn on. If both the upper and lower power switches are switched at the same time (one turned on and the other turned off), both switches may be on for a short period of time  until  one  switch  completely  turns  off.  During  this brief interval, a very high current ( shoot-through current ) may  flow  through  both  power  switches,  shorting  the bridge supply. To  avoid this potentially destructive shoot-through  current  from  flowing  during  switching, turning  on  either  of  the  power  switches  is  normally delayed to allow the other switch to completely turn off.",
    "FIGURE 16-9: PWM DIRECTION CHANGE AT NEAR 100% DUTY CYCLE\nIn  the  Half-Bridge  Output  mode,  a  digitally  programmable dead-band delay is available to avoid shoot-through current from destroying the bridge power switches. The delay occurs at the signal transition  from  the non-active state to the active state. See Figure 16-4  for  illustration.  Bits  PDC6:PDC0  of  the ECCP1DEL  register  (Register 16-2)  set  the  delay period  in  terms  of  microcontroller  instruction  cycles (TCY  or  4  TOSC).  These  bits  are  not  available  on PIC18F2X8X devices, as the standard CCP1 module does not support half-bridge operation.\nNote:\nIf the dead-band delay value is increased after the dead-band time has elapsed, that new value takes effect immediately. This happens  even  if  the  PWM  pulse  is  high and can appear to be a glitch. Dead-band values must be changed during the dead-band  time  or  before  the  ECCP1 module is active.",
    "16.4.7 ENHANCED PWM AUTO-SHUTDOWN\nWhen the CCP1 is programmed for any of the Enhanced PWM modes, the active output pins may be configured for  auto-shutdown. Auto-shutdown immediately places the Enhanced PWM output pins into a defined shutdown state when a shutdown event occurs.\nA  shutdown  event  can  be  caused  by  either  of  the comparator modules, a low level on the RB0/INT0/FLT0/AN10 pin, or any combination of these three sources. The comparators may be used to monitor a voltage input proportional to a current being monitored in the bridge circuit. If the voltage exceeds a threshold, the comparator switches state and triggers a shutdown. Alternatively,  a digital signal on the INT0 pin can also trigger a shutdown. The auto-shutdown feature can be disabled by not selecting any auto-shutdown sources. The  auto-shutdown  sources  to  be  used  are  selected using  the  ECCPAS2:ECCPAS0  bits  (bits<6:4>  of  the ECCP1AS register).",
    "16.4.7 ENHANCED PWM AUTO-SHUTDOWN\nWhen a shutdown occurs, the output pins are asynchronously placed in their shutdown states, specified by  the  PSSAC1:PSSAC0  and  PSS1BD1:PSS1BD0 bits  (ECCPAS3:ECCPAS0).  Each  pin  pair  (P1A/P1C and P1B/P1D) may be set to drive high, drive low or be tri-stated (not driving). The ECCPASE bit (ECCP1AS<7>) is also set to hold the Enhanced PWM outputs in their shutdown states.\nThe ECCPASE bit is set by hardware when a shutdown event occurs. If automatic restarts are not enabled, the ECCPASE bit is cleared by firmware when the cause of the shutdown clears. If automatic restarts are enabled, the  ECCPASE  bit  is  automatically  cleared  when  the cause of the auto-shutdown has cleared.",
    "16.4.7 ENHANCED PWM AUTO-SHUTDOWN\nIf the ECCPASE bit is set when a PWM period begins, the PWM outputs remain in their shutdown state for that entire PWM period. When the ECCPASE bit is cleared, the PWM outputs will return to normal operation at the beginning of the next PWM period.\nNote:\nWriting  to  the  ECCPASE  bit  is  disabled while a shutdown condition is active.",
    "ECCP1DEL: PWM CONFIGURATION REGISTER\nPRSEN, R/W-0 = PDC6 (1). PRSEN, R/W-0 = PDC5 (1). PRSEN, R/W-0 = PDC4 (1). PRSEN, R/W-0 = PDC3 (1). PRSEN, R/W-0 = PDC2 (1). PRSEN, R/W-0 = PDC1 (1). PRSEN, R/W-0 = PDC0 (1)\nbit 7\nbit 0",
    "bit 7 PRSEN: PWM Restart Enable bit\n1 = Upon auto-shutdown, the ECCPASE bit clears automatically once the shutdown event goes away; the PWM restarts automatically\n0 = Upon auto-shutdown, ECCPASE must be cleared in software to restart the PWM\nPDC6:PDC0: PWM Delay Count bits (1)\nDelay time, in number of FOSC/4 (4 * TOSC) cycles, between the scheduled and actual time for a PWM signal to transition to active.\nNote 1: Reserved on PIC18F2X8X devices; maintain these bits clear.",
    "bit 7 PRSEN: PWM Restart Enable bit\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "ECCP1AS: ENHANCED CAPTURE/COMPARE/PWM AUTO-SHUTDOWN CONTROL REGISTER\nECCPASE, R/W-0 = ECCPAS2. ECCPASE, R/W-0 = ECCPAS1. ECCPASE, R/W-0 = ECCPAS0. ECCPASE, R/W-0 = PSSAC1. ECCPASE, R/W-0 = PSSAC0. ECCPASE, R/W-0 = PSSBD1 (1). ECCPASE, R/W-0 = PSSBD0 (1). bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = bit 0\nECCPASE: ECCP1 Auto-Shutdown Event Status bit\n1 = A shutdown event has occurred; ECCP1 outputs are in shutdown state\n0 = ECCP1 outputs are operating",
    "bit 6-4 ECCPAS2:ECCPAS0: ECCP1 Auto-Shutdown Source Select bits\n111 = RB0 or Comparator 1 or Comparator 2\n110 = RB0 or Comparator 2\n101 = RB0 or Comparator 1\n100 = RB0\n011 = Either Comparator 1 or 2\n010 = Comparator 2 output\n001 = Comparator 1 output\n000 = Auto-shutdown is disabled",
    "bit 3-2 PSSAC1:PSSAC0: Pins A and C Shutdown State Control bits\n1x = Pins A and C tri-state (PIC18F4X8X devices);\n01 = Drive Pins A and C to ' 1 '\n00 = Drive Pins A and C to ' 0 '",
    "bit 1-0 PSSBD1:PSSBD0: Pins B and D Shutdown State Control bits (1)\n1x = Pins B and D tri-state\n01 = Drive Pins B and D to ' 1 '\n00 = Drive Pins B and D to ' 0 '\nNote 1: Reserved on PIC18F2X8X devices; maintain these bits clear.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 16-3:\nbit 7",
    "16.4.7.1 Auto-Shutdown and Auto-Restart\nThe auto-shutdown feature can be configured to allow automatic restarts of the module following a shutdown event. This is enabled by setting the PRSEN bit of the ECCP1DEL register (ECCP1DEL<7>).\nIn Shutdown mode with PRSEN = 1 (Figure 16-10), the ECCPASE bit will remain set for as long as the cause of the shutdown continues. When the shutdown condition clears, the ECCP1ASE bit is cleared. If PRSEN = 0 (Figure 16-11), once a shutdown condition occurs, the ECCPASE  bit  will  remain  set  until  it  is  cleared  by firmware.  Once  ECCPASE is  cleared,  the  Enhanced PWM will resume at the beginning of the next PWM period.\nNote:\nWriting  to  the  ECCPASE  bit  is  disabled while a shutdown condition is active.\nIndependent of the PRSEN bit setting, if the auto-shutdown source is one of the comparators, the shutdown  condition  is  a  level.  The  ECCPASE  bit cannot be cleared as long as the cause of the shutdown persists.",
    "16.4.8 START-UP CONSIDERATIONS\nWhen the ECCP1 module is used in the PWM mode, the application hardware must use the proper external pull-up and/or pull-down resistors on the PWM output pins. When the microcontroller is released from Reset, all of the I/O pins are in the high-impedance state. The external circuits must keep the power switch devices in the off state until the  microcontroller  drives  the  I/O  pins  with  the  proper signal levels, or activates the PWM output(s).\nThe  ECCP1M1:ECCP1M0  bits  (ECCP1CON<1:0>) allow the user to choose whether the PWM output signals are active-high or active-low for each pair of PWM output pins (P1A/P1C and P1B/P1D). The PWM output polarities must be selected before the PWM pins are configured as outputs. Changing the polarity configuration while the PWM pins are configured as outputs is not recommended, since it may result in damage to the application circuits.",
    "16.4.8 START-UP CONSIDERATIONS\nThe Auto-Shutdown mode can be forced by writing a ' 1 ' to the ECCPASE bit.\nThe P1A, P1B, P1C and P1D output latches may not be in the proper states when the PWM module is initialized. Enabling the PWM pins for output at the same time as the ECCP1 module may cause damage to the application circuit. The ECCP1 module must be enabled in the proper  output  mode  and  complete  a  full  PWM  cycle before configuring the PWM pins as outputs. The completion of a full PWM cycle is indicated by the TMR2IF bit being set as the second PWM period begins.",
    "FIGURE 16-10: PWM AUTO-SHUTDOWN (PRSEN =  , AUTO-RESTART ENABLED) 1\nFIGURE 16-11: PWM AUTO-SHUTDOWN (PRSEN =  , AUTO-RESTART DISABLED) 0",
    "16.4.10 EFFECTS OF A RESET\nThe following steps should be taken when configuring the ECCP1 module for PWM operation:",
    "16.4.10 EFFECTS OF A RESET\n1. Configure  the  PWM  pins  P1A  and  P1B  (and P1C and P1D, if used) as inputs by setting the corresponding TRIS bits.\n2. Set the PWM period by loading the PR2 register.\n3. Configure  the  ECCP1  module  for  the  desired PWM mode  and  configuration  by  loading  the ECCP1CON register with the appropriate values:\n\u00b7 Select one of the available output configurations and direction with the EPWM1M1:EPWM1M0 bits.\n\u00b7 Select the polarities of the PWM output signals with the ECCP1M3:ECCP1M0 bits.\n4. Set the PWM  duty cycle by loading the ECCPR1L register and ECCP1CON<5:4> bits.\n5. For Half-Bridge Output mode, set the dead-band delay by loading ECCP1DEL<6:0> with the appropriate value.\n6. If auto-shutdown operation is required, load the ECCP1AS register:\n\u00b7 Select the auto-shutdown sources using the ECCPAS2:ECCPAS0 bits.",
    "16.4.10 EFFECTS OF A RESET\n\u00b7 Select the shutdown states of the PWM output pins using PSSAC1:PSSAC0 and PSSBD1:PSSBD0 bits.\n\u00b7 Set the ECCPASE bit (ECCP1AS<7>).\n\u00b7 Configure the comparators using the CMCON register.\n\u00b7 Configure the comparator inputs as analog inputs.\n7. If auto-restart  operation  is  required,  set  the PRSEN bit (ECCP1DEL<7>).\n8. Configure and start TMR2:\n\u00b7 Clear the TMR2 interrupt flag bit by clearing the TMR2IF bit (PIR1<1>).\n\u00b7 Set the TMR2 prescale value by loading the T2CKPS bits (T2CON<1:0>).\n\u00b7 Enable Timer2 by setting the TMR2ON bit (T2CON<2>).\n9. Enable  PWM outputs  after  a  new  PWM  cycle has started:\n\u00b7 Wait until TMRn overflows (TMRnIF bit is set).",
    "16.4.10 EFFECTS OF A RESET\n\u00b7 Enable the ECCP1/P1A, P1B, P1C and/or P1D pin outputs by clearing the respective TRIS bits.\n\u00b7 Clear the ECCPASE bit (ECCP1AS<7>).\nBoth Power-on Reset and subsequent Resets will force all ports to Input mode and the CCP1 registers to their Reset states.\nThis forces the Enhanced CCP1 module to reset to a state compatible with the standard CCP1 module.",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. RCON, Bit 7 = IPEN. RCON, Bit 6 = SBOREN. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Reset Values on page = 47. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP.",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nIPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR2, Bit 7 =",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nOSCFIP. IPR2, Bit 6 = CMIP (3). IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (3). IPR2, Reset Values on page = 48. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF (3). PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (3). PIR2, Reset Values on page = 48. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE (3). PIE2, Bit 5 = -. PIE2,",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nBit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (3). PIE2, Reset Values on page = 49. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Reset Values on page = 49. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nRegister. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Reset Values on page = 49. TRISD (1), Bit 7 = PORTD Data Direction Register. TRISD (1), Bit 6 = PORTD Data Direction Register. TRISD (1), Bit 5 = PORTD Data Direction Register. TRISD (1), Bit 4 = PORTD Data Direction Register. TRISD (1), Bit 3 = PORTD Data Direction Register. TRISD (1), Bit 2 = PORTD Data Direction Register. TRISD (1), Bit 1 = PORTD Data Direction Register. TRISD (1), Bit 0 = PORTD Data Direction Register. TRISD (1), Reset Values on page = 49. TMR1L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nByte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Reset Values on page = 47. TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nTMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Reset Values on page = 47. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS.",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nT1CON, Bit 0 = TMR1ON. T1CON, Reset Values on page = 47. TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Reset Values on page = 47. T2CON, Bit 7 = -. T2CON, Bit 6 = T2OUTPS3. T2CON, Bit 5 = T2OUTPS2. T2CON, Bit 4 = T2OUTPS1. T2CON, Bit 3 = T2OUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 =",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nT2CKPS0. T2CON, Reset Values on page = 47. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Reset Values on page = 47. TMR3L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 3 = Holding Register for the Least Significant",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nByte of the 16-bit TMR3 Register. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Reset Values on page = 48. TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nTMR3 Register. TMR3H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Reset Values on page = 48. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3ECCP1 (1). T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1 (1). T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Reset Values on page = 48. ECCPR1L (2), Bit 7 = Enhanced Capture/Compare/PWM Register",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\n1 (LSB). ECCPR1L (2), Bit 6 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (2), Bit 5 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (2), Bit 4 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (2), Bit 3 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (2), Bit 2 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (2), Bit 1 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (2), Bit 0 = Enhanced Capture/Compare/PWM Register 1 (LSB). ECCPR1L (2), Reset Values on page = 48. ECCPR1H (2), Bit 7 = Enhanced Capture/Compare/PWM Register 1 (MSB).",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nECCPR1H (2), Bit 6 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (2), Bit 5 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (2), Bit 4 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (2), Bit 3 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (2), Bit 2 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (2), Bit 1 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (2), Bit 0 = Enhanced Capture/Compare/PWM Register 1 (MSB). ECCPR1H (2), Reset Values on page = 48. ECCP1CON (2), Bit 7 = EPWM1M1. ECCP1CON (2), Bit 6 =",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nEPWM1M0. ECCP1CON (2), Bit 5 = EDC1B1. ECCP1CON (2), Bit 4 = EDC1B0. ECCP1CON (2), Bit 3 = ECCP1M3. ECCP1CON (2), Bit 2 = ECCP1M2. ECCP1CON (2), Bit 1 = ECCP1M1. ECCP1CON (2), Bit 0 = ECCP1M0. ECCP1CON (2), Reset Values on page = 48. ECCP1AS (2), Bit 7 = ECCPASE. ECCP1AS (2), Bit 6 = ECCPAS2. ECCP1AS (2), Bit 5 = ECCPAS1. ECCP1AS (2), Bit 4 = ECCPAS0. ECCP1AS (2), Bit 3 = PSSAC1. ECCP1AS (2), Bit 2 = PSSAC0. ECCP1AS (2), Bit 1 = PSSBD1 (2).",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\nECCP1AS (2), Bit 0 = PSSBD0 (2). ECCP1AS (2), Reset Values on page = 48. ECCP1DEL (2), Bit 7 = PRSEN. ECCP1DEL (2), Bit 6 = PDC6 (2). ECCP1DEL (2), Bit 5 = PDC5 (2). ECCP1DEL (2), Bit 4 = PDC4 (2). ECCP1DEL (2), Bit 3 = PDC3 (2). ECCP1DEL (2), Bit 2 = PDC2 (2). ECCP1DEL (2), Bit 1 = PDC1 (2). ECCP1DEL (2), Bit 0 = PDC0 (2). ECCP1DEL (2), Reset Values on page = 48\nLegend:",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH ECCP1 MODULE AND TIMER1 TO TIMER3\n- = unimplemented, read as ' 0 '. Shaded cells are not used during ECCP1 operation.\nNote 1:\nThese bits are available on PIC18F4X8X devices only.\n2: These bits or registers are unimplemented in PIC18F2X8X devices; always maintain these bit clear.\n3: These bits are available on PIC18F4X8X and reserved on PIC18F2X8X devices.",
    "17.1 Master SSP (MSSP) Module Overview\nThe Master Synchronous Serial Port (MSSP) module is a serial interface, useful for communicating with other peripheral or microcontroller devices. These peripheral devices  may  be  serial  EEPROMs,  shift  registers, display drivers, A/D converters, etc. The MSSP module can operate in one of two modes:\n\u00b7 Serial Peripheral Interface (SPI)\n\u00b7 Inter-Integrated Circuit (I C) 2\n-Full Master mode\n-Slave mode (with general address call)\nThe  I 2 C  interface  supports  the  following  modes  in hardware:\n\u00b7 Master mode\n\u00b7 Multi-Master mode\n\u00b7 Slave mode",
    "17.2 Control Registers\nThe  MSSP  module  has  three  associated  registers. These  include  a  status  register  (SSPSTAT)  and  two control registers (SSPCON1 and SSPCON2). The use of these registers and their individual configuration bits differ  significantly  depending  on  whether  the  MSSP module is operated in SPI or I 2 C mode.\nAdditional  details  are  provided  under  the  individual sections.",
    "17.3 SPI Mode\nThe SPI mode allows 8 bits of data to be synchronously transmitted and received simultaneously. All four modes of SPI are supported. To accomplish communication, typically three pins are used:\n\u00b7 Serial Data Out (SDO) - RC5/SDO\n\u00b7 Serial Data In (SDI) - RC4/SDI/SDA\n\u00b7 Serial Clock (SCK) - RC3/SCK/SCL\nAdditionally, a fourth pin may be used when in a Slave mode of operation:\n- \u00b7 Slave Select (SS) - RA5/AN4/SS/HLVDIN\nFigure 17-1  shows  the  block  diagram  of  the  MSSP module when operating in SPI mode.",
    "17.3.1 REGISTERS\nThe  MSSP  module  has  four  registers  for  SPI  mode operation. These are:\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to or read from.\n\u00b7 MSSP Control Register 1 (SSPCON1)\n\u00b7 MSSP Status Register (SSPSTAT)\n\u00b7 Serial Receive/Transmit Buffer Register (SSPBUF)\n\u00b7 MSSP Shift Register (SSPSR) - Not directly accessible\nIn receive operations, SSPSR and SSPBUF together create a double-buffered receiver. When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.\nDuring  transmission, the SSPBUF  is  not  doublebuffered. A write to SSPBUF will write to both SSPBUF and SSPSR.\nSSPCON1 and SSPSTAT are the control and status registers in SPI  mode  operation.  The  SSPCON1 register is readable and writable. The lower 6 bits of the SSPSTAT are read-only. The upper two bits of the SSPSTAT are read/write.",
    "REGISTER 17-1: SSPSTAT: MSSP STATUS REGISTER (SPI MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "bit 7 SMP:\nSample bit\nSPI Master mode:\n1 = Input data sampled at end of data output time\n0 = Input data sampled at middle of data output time\nSPI Slave mode:\nSMP must be cleared when SPI is used in Slave mode.",
    "bit 6 CKE: SPI Clock Select bit\n1 = Transmit occurs on transition from active to Idle clock state 0 = Transmit occurs on transition from Idle to active clock state Polarity of clock state is set by the CKP bit (SSPCON1<4>).",
    "bit 5 D/A: Data/Address bit\nUsed in I 2 C mode only.",
    "bit 4 P: Stop bit\nUsed in I 2 C mode only. This bit is cleared when the MSSP module is disabled, SSPEN is cleared.",
    "bit 3 S:\nStart bit\nUsed in I 2 C mode only.",
    "bit 2 R/W: Read/Write bit Information\nUsed in I 2 C mode only.",
    "bit 1 UA: Update Address bit\nUsed in I 2 C mode only.",
    "bit 0 BF:\nBuffer Full Status bit (Receive mode only)\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 17-2: SSPCON1: MSSP CONTROL REGISTER 1 (SPI MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0\nbit 7 WCOL: Write Collision Detect bit (Transmit mode only)\n1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision\nSSPOV:\nReceive Overflow Indicator bit\nbit 6\nSPI Slave mode:",
    "REGISTER 17-2: SSPCON1: MSSP CONTROL REGISTER 1 (SPI MODE)\n1 = A new byte is received while the SSPBUF register is still holding the previous data. In case of overflow, the data in SSPSR is lost. Overflow can only occur in Slave mode. The user must read the SSPBUF, even if only transmitting data, to avoid setting overflow (must be cleared in software).\n0 = No overflow\nNote:\nIn  Master  mode,  the  overflow  bit  is  not  set  since  each  new  reception  (and transmission) is initiated by writing to the SSPBUF register.",
    "bit 5 SSPEN: Synchronous Serial Port Enable bit\n1 = Enables serial port and configures SCK, SDO, SDI and SS as serial port pins\n0 = Disables serial port and configures these pins as I/O port pins\nNote:\nWhen enabled, these pins must be properly configured as input or output.",
    "bit 4 CKP: Clock Polarity Select bit\n- 1 = Idle state for clock is a high level\n0 = Idle state for clock is a low level",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits\n0101 = SPI Slave mode, clock = SCK pin, SS pin control disabled, SS can be used as I/O pin\n0100 = SPI Slave mode, clock = SCK pin, SS pin control enabled\n0011 = SPI Master mode, clock = TMR2 output/2\n0010 = SPI Master mode, clock = FOSC/64\n0001 = SPI Master mode, clock = FOSC/16\n0000 = SPI Master mode, clock = FOSC/4\nNote:\nBit combinations not specifically listed here are either reserved or implemented in I 2 C mode only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "17.3.2 OPERATION\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control  bits  (SSPCON1<5:0>  and  SSPSTAT<7:6>). These control bits allow the following to be specified:\n\u00b7 Master mode (SCK is the clock output)\n\u00b7 Slave mode (SCK is the clock input)\n\u00b7 Clock Polarity (Idle state of SCK)\n\u00b7 Data Input Sample Phase (middle or end of data output time)\n\u00b7 Clock Edge (output data on rising/falling edge of SCK)\n\u00b7 Clock Rate (Master mode only)\n\u00b7 Slave Select mode (Slave mode only)",
    "17.3.2 OPERATION\nThe MSSP consists of a transmit/receive shift register (SSPSR) and a buffer register (SSPBUF). The SSPSR shifts the data in and out of the device, MSb first. The SSPBUF holds the data that was written to the SSPSR until the received data is ready. Once the 8 bits of data have been received, that byte is moved to the SSPBUF register. Then, the Buffer Full detect bit, BF (SSPSTAT<0>) and the interrupt  flag  bit,  SSPIF,  are set. This double-buffering of the received data (SSPBUF) allows the next byte to start reception before reading the data that was just received. Any write to the SSPBUF register during transmission/reception of data will be ignored and the write collision detect bit, WCOL (SSPCON1<7>), will be set. User software must clear the WCOL bit so that it can be determined if the following write(s) to the SSPBUF  register completed successfully.",
    "17.3.2 OPERATION\nWhen the application software is expecting to receive valid data, the SSPBUF should be read before the next byte of data to transfer is written to the SSPBUF. The Buffer  Full  bit,  BF  (SSPSTAT<0>),  indicates  when SSPBUF  has  been  loaded  with  the  received  data (transmission is complete). When the SSPBUF is read, the BF bit is cleared. This data may be irrelevant if the SPI is only a transmitter. Generally, the MSSP interrupt is used to determine when the transmission/reception has  completed.  The  SSPBUF  must  be  read  and/or written. If the interrupt method is not going to be used, then software polling can be done to ensure that a write collision  does  not  occur.  Example 17-1  shows  the loading of the SSPBUF (SSPSR) for data transmission.\nThe SSPSR is not directly readable or writable and can only be accessed by addressing the SSPBUF register. Additionally, the  MSSP  status  register  (SSPSTAT) indicates the various status conditions.",
    "EXAMPLE 17-1: LOADING THE SSPBUF (SSPSR) REGISTER\nLOOP, 1 = BTFSS. LOOP, 2 = SSPSTAT, BF. LOOP, 3 = ;Has data been received (transmit complete)?. , 1 = BRA. , 2 = LOOP. , 3 = ;No. , 1 = MOVF. , 2 = SSPBUF, W. , 3 = ;WREG reg = contents of SSPBUF. , 1 = MOVWF. , 2 = RXDATA. , 3 = ;Save in user RAM, if data is meaningful. , 1 = MOVF. , 2 = TXDATA, W. , 3 = ;W reg = contents of TXDATA. , 1 = MOVWF. , 2 = SSPBUF. , 3 = ;New data to xmit",
    "17.3.3 ENABLING SPI I/O\nTo enable the serial port, SSP Enable bit, SSPEN (SSPCON1<5>),  must  be  set.  To  reset  or  reconfigure  SPI mode, clear the SSPEN bit, reinitialize the SSPCON registers and then set the SSPEN bit. This configures the SDI, SDO, SCK and SS pins as serial port pins. For the pins to behave as the serial port function, some must have  their  data  direction  bits  (in  the  TRIS  register) appropriately programmed as follows:\n\u00b7 SDI is automatically controlled by the SPI module\n\u00b7 SDO must have TRISC<5> bit cleared\n\u00b7 SCK (Master mode) must have TRISC<3> bit cleared\n\u00b7 SCK (Slave mode) must have TRISC<3> bit set\n\u00b7 SS must have TRISF<7> bit set\nAny  serial  port  function  that  is  not  desired  may  be overridden  by  programming  the  corresponding  data direction (TRIS) register to the opposite value.",
    "Note:\nWhen the module is enabled and in Master mode  (CKE,  SSPSTAT<6> = 1 ),  a  small glitch of approximately half a TCY may be seen on the SCK pin. To resolve this, keep the  SCK  pin  as  an  input  while  setting SPEN. Then, configure the SCK pin as an output (TRISC<3> = 0 ).",
    "17.3.4 TYPICAL CONNECTION\nFigure 17-2 shows a typical connection between two microcontrollers. The master controller (Processor 1) initiates the data transfer by sending the SCK signal. Data  is  shifted  out  of  both  shift  registers  on  their programmed clock edge and latched on the opposite edge of the clock. Both processors should be programmed to the same Clock Polarity (CKP), then both  controllers  would  send  and  receive  data  at  the same time. Whether the data is meaningful (or dummy data) depends on the application software. This leads to three scenarios for data transmission:\n\u00b7 Master sends data - Slave sends dummy data \uf020 \uf020\n\u00b7 Master sends data - Slave sends data \uf020 \uf020\n\u00b7 Master sends dummy data - Slave sends data \uf020 \uf020",
    "17.3.5 MASTER MODE\nThe master can initiate the data transfer at any time because it controls the SCK. The master determines when  the  slave (Processor 2, Figure 17-2) is to broadcast data by the software protocol.\nIn  Master  mode,  the  data  is  transmitted/received  as soon as the SSPBUF register is written to. If the SPI is only  going  to  receive,  the SDO  output  could  be disabled (programmed as an input). The SSPSR register will continue to shift in the signal present on the SDI pin  at  the  programmed  clock  rate.  As  each  byte  is received, it will be loaded into the SSPBUF register as if  a  normal  received  byte  (interrupts  and  status  bits appropriately  set).  This  could  be  useful  in  receiver applications as a 'Line Activity Monitor' mode.\nThe clock polarity is selected by appropriately programming the CKP bit (SSPCON1<4>). This then, would  give  waveforms  for  SPI  communication  as shown  in  Figure 17-3,  Figure 17-5  and  Figure 17-6, where the MSB is transmitted first. In Master mode, the SPI clock rate (bit rate) is user-programmable to be one of the following:",
    "17.3.5 MASTER MODE\n\u00b7 FOSC/4 (or TCY)\n\u00b7 FOSC/16 (or 4 \u00b7 TCY)\n\u00b7 FOSC/64 (or 16 \u00b7 TCY)\n\u00b7 Timer2 output/2\nThis  allows  a  maximum  data  rate  (at  40  MHz)  of 10.00 Mbps.\nFigure 17-3  shows  the  waveforms  for  Master  mode. When the CKE bit is set, the SDO data is valid before there is a clock edge on SCK. The change of the input sample is shown based on the state of the SMP bit. The time  when  the  SSPBUF  is  loaded  with  the  received data is shown.\nFIGURE 17-3: SPI MODE WAVEFORM (MASTER MODE)",
    "17.3.6 SLAVE MODE\nIn Slave mode, the data is transmitted and received as the  external  clock  pulses  appear  on  SCK.  When  the last bit is latched, the SSPIF interrupt flag bit is set.\nBefore  enabling  the  module  in  SPI  Slave  mode,  the clock line must match the proper Idle state. The clock line can be observed by reading the SCK pin. The Idle state is determined by the CKP bit (SSPCON1<4>).\nWhile in Slave mode, the external clock is supplied by the external clock source on the SCK pin. This external clock must meet the minimum high and low times as specified in the electrical specifications.\nWhile  in  Sleep  mode,  the  slave  can  transmit/receive data. When a byte is received, the device will wake-up from Sleep.",
    "17.3.7 SLAVE SELECT SYNCHRONIZATION\nThe SS pin allows a Synchronous Slave mode. The SPI must be in Slave mode with SS pin control enabled (SSPCON1<3:0> = 04h). The pin must not be driven low for the SS pin to function as an input. The data latch must be high. When the SS pin is low, transmission and reception are enabled and the SDO pin is driven. When the SS pin goes high, the SDO pin is no longer driven, even if in the middle of a transmitted byte and becomes a  floating  output.  External  pull-up/pull-down  resistors may be desirable depending on the application.\nNote 1: When the SPI is in Slave mode with SS pin control enabled (SSPCON<3:0> = 0100 ), the SPI module will reset if the SS pin is set to VDD.\n2: If the SPI is used in Slave mode with CKE set,  then  the  SS  pin  control  must  be enabled.\nWhen the SPI module resets, the bit counter is forced to ' 0 '. This can be done by either forcing the SS pin to a high level or clearing the SSPEN bit.",
    "17.3.7 SLAVE SELECT SYNCHRONIZATION\nTo emulate two-wire communication, the SDO pin can be connected to the SDI pin. When the SPI needs to operate as a receiver, the SDO pin can be configured as an input. This disables transmissions from the SDO. The SDI can always be left as an input (SDI function) since it cannot create a bus conflict.\nFIGURE 17-4: SLAVE SYNCHRONIZATION WAVEFORM",
    "PIC18F2585/2680/4585/4680\nFIGURE 17-6: SPI MODE WAVEFORM (SLAVE MODE WITH CKE = 1\n)",
    "17.3.9 EFFECTS OF A RESET\nIn SPI Master mode, module clocks may be operating at a different speed than when in full power mode; in the case of the Sleep mode, all clocks are halted.\nIn most power managed modes, a clock is provided to the peripherals. That clock should be from the primary clock source, the secondary clock (Timer1 oscillator at 32.768 kHz) or the INTOSC source. See Section 2.7 'Clock Sources and Oscillator Switching' for additional information.\nIn most cases, the speed that the master clocks SPI data is not important; however, this should be evaluated for each system.\nIf  MSSP  interrupts  are  enabled,  they  can  wake  the controller from Sleep mode, or one of the Idle modes, when  the  master  completes  sending  data.  If  an  exit from Sleep  or Idle mode  is  not desired, MSSP interrupts should be disabled.\nIf  the  Sleep  mode  is  selected,  all  module  clocks  are halted  and  the  transmission/reception  will  remain  in that  state  until  the  devices  wakes.  After  the  device returns to Run mode, the module will resume transmitting and receiving data.\nA Reset disables the MSSP module and terminates the current transfer.",
    "17.3.10 BUS MODE COMPATIBILITY\nTable 17-1 shows the compatibility between the standard SPI modes and the states of the CKP and CKE control bits.",
    "TABLE 17-1: SPI BUS MODES\n0, 0, Control Bits State.CKP = 0. 0, 0, Control Bits State.CKE = 1. 0, 1, Control Bits State.CKP = 0. 0, 1, Control Bits State.CKE = 0. 1, 0, Control Bits State.CKP = 1. 1, 0, Control Bits State.CKE = 1. 1, 1, Control Bits State.CKP = 1. 1, 1, Control Bits State.CKE = 0\nThere is also a SMP bit which controls when the data is sampled.\nIn  SPI  Slave  mode,  the  SPI  Transmit/Receive  Shift register  operates  asynchronously  to  the  device.  This allows the device to be placed in any power managed mode  and  data  to  be  shifted  into  the  SPI  Transmit/ Receive  Shift  register.  When  all  8  bits  have  been received, the MSSP interrupt flag bit will be set and if enabled, will wake the device.",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 =",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nSSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. TRISA, Bit 7 = PORTA Data Direction Register. TRISA, Bit 6 = PORTA Data Direction Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nDirection Register. TRISA, Reset Values on page = 49. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Reset Values on page = 49. SSPBUF, Bit 7 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 6 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 5 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 4 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 3 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 2 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI OPERATION\n1 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 0 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Reset Values on page = 47. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 = SSPM1. SSPCON1, Bit 0 = SSPM0. SSPCON1, Reset Values on page = 47. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Reset Values on page = 47\nLegend:",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI OPERATION\n- = unimplemented, read as ' 0 '. Shaded cells are not used by the MSSP in SPI mode.\nNote 1: These bits are unimplemented in PIC18F2X8X devices; always maintain these bits clear.",
    "17.4.1 REGISTERS\nThe MSSP module in I 2 C  mode fully  implements  all master  and  slave  functions  (including  general  call support) and provides interrupts on Start and Stop bits in  hardware  to  determine  a  free  bus  (multi-master function). The MSSP module implements the standard mode  specifications, as well as 7-bit and  10-bit addressing.\nTwo pins are used for data transfer:\n\u00b7 Serial clock (SCL) - RC3/SCK/SCL\n\u00b7 Serial data (SDA) - RC4/SDI/SDA\nThe user must configure these pins as inputs or outputs through the TRISC<4:3> bits.",
    "(I C\u2122 MODE)\nThe MSSP module has six registers for I 2 C operation.\nThese are:\n\u00b7 MSSP Control Register 1 (SSPCON1)\n\u00b7 MSSP Control Register 2 (SSPCON2)\n\u00b7 MSSP Status Register (SSPSTAT)\n\u00b7 Serial Receive/Transmit Buffer Register (SSPBUF)\n\u00b7 MSSP Shift Register (SSPSR) - Not directly accessible\n\u00b7 MSSP Address Register (SSPADD)\nSSPCON1, SSPCON2 and SSPSTAT are the control and status registers in I 2 C mode operation. The     SSPCON1 and SSPCON2 registers are readable and writable. The lower 6 bits of the SSPSTAT are read-only. The upper two bits of the SSPSTAT are read/write.\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to or read from.\nSSPADD  register  holds  the  slave  device  address when the SSP is configured in I 2 C Slave mode. When the  SSP  is  configured  in  Master  mode,  the  lower seven bits of SSPADD  act as the Baud Rate Generator reload value.",
    "(I C\u2122 MODE)\nIn receive operations, SSPSR and SSPBUF together create a double-buffered receiver. When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.\nDuring  transmission, the SSPBUF  is  not  doublebuffered. A write to SSPBUF will write to both SSPBUF and SSPSR.",
    "REGISTER 17-3: SSPSTAT: MSSP STATUS REGISTER (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P (1). SMP, 4 = S (1). SMP, 5 = R/W (2,3). SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "bit 7 SMP: Slew Rate Control bit\nIn Master or Slave mode:\n1 = Slew rate control disabled for Standard Speed mode (100 kHz and 1 MHz)\n0 = Slew rate control enabled for High-Speed mode (400 kHz)",
    "In Master or Slave mode:\n1 = Enable SMBus specific inputs\n0 = Disable SMBus specific inputs",
    "In Master mode:\nReserved.",
    "In Slave mode:\n1 = Indicates that the last byte received or transmitted was data\n0 = Indicates that the last byte received or transmitted was address",
    "bit 4 P: Stop bit (1)\n1 = Indicates that a Stop bit has been detected last\n0 = Stop bit was not detected last\n(1)",
    "bit 3 S: Start bit\n1 = Indicates that a Start bit has been detected last\n0 = Start bit was not detected last",
    "In Slave mode:\n1 = Read\n0 = Write",
    "In Master mode:\n1 = Transmit is in progress\n0 = Transmit is not in progress\nbit 1 UA: Update Address bit (10-bit Slave mode only)\n1 = Indicates that the user needs to update the address in the SSPADD register\n0 = Address does not need to be updated",
    "In Receive mode:\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty",
    "In Transmit mode:\n1 = Data transmit in progress (does not include the ACK and Stop bits), SSPBUF is full\n0 = Data transmit complete (does not include the ACK and Stop bits), SSPBUF is empty\nNote 1: This bit is cleared on Reset and when SSPEN is cleared.\n2: This bit holds the R/W bit information following the last address match. This bit is only valid from the address match to the next Start bit, Stop bit or not ACK bit.\n3: ORing this bit with SEN, RSEN, PEN, RCEN or ACKEN will indicate if the MSSP is in Idle mode.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 17-4: SSPCON1: MSSP CONTROL REGISTER 1 (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0",
    "bit 7 WCOL: Write Collision Detect bit\nIn Master Transmit mode:\n1 = A write to the SSPBUF register was attempted while the I 2 C conditions were not valid for a transmission to be started (must be cleared in software)\n0 = No collision",
    "In Slave Transmit mode:\n1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision\nIn Receive mode (Master or Slave modes):\nThis is a 'don't care' bit.",
    "In Receive mode:\n1 = A byte is received while the SSPBUF register is still holding the previous byte (must be cleared in software)\n0 = No overflow",
    "In Transmit mode:\nThis is a 'don't care' bit in Transmit mode.",
    "bit 5 SSPEN:\nSynchronous Serial Port Enable bit\n1 = Enables the serial port and configures the SDA and SCL pins as the serial port pins\n0 = Disables serial port and configures these pins as I/O port pins\nNote:\nWhen enabled,  the  SDA  and  SCL  pins  must  be  properly  configured  as  input  or output.",
    "bit 4 CKP: SCK Release Control bit\nIn Slave mode:\n1 = Release clock\n- 0 = Holds clock low (clock stretch), used to ensure data setup time\nIn Master mode:\nUnused in this mode.",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits\n1111 = I 2 C Slave mode, 10-bit address with Start and Stop bit interrupts enabled\n1110 = I 2 C Slave mode, 7-bit address with Start and Stop bit interrupts enabled\n1011 = I 2 C Firmware Controlled Master mode (Slave Idle)\n1000 = I 2 C Master mode, clock = FOSC/(4 * (SSPADD + 1))\n0111 = I 2 C Slave mode, 10-bit address\n0110 = I 2 C Slave mode, 7-bit address\nNote:\nBit combinations not specifically listed here are either reserved or implemented in SPI mode only.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR,  = '0' = Bit is cleared. -n = Value at POR,  = x = Bit is unknown\nbit 3",
    "REGISTER 17-5: SSPCON2: MSSP CONTROL REGISTER 2 (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. GCEN, 1 = ACKSTAT. GCEN, 2 = ACKDT. GCEN, 3 = ACKEN (1). GCEN, 4 = RCEN (1). GCEN, 5 = PEN (1). GCEN, 6 = RSEN (1). GCEN, 7 = SEN (1)\nbit 7\nbit 0",
    "REGISTER 17-5: SSPCON2: MSSP CONTROL REGISTER 2 (I 2 C MODE)\nbit 7 GCEN: General Call Enable bit (Slave mode only)\n1 = Enable interrupt when a general call address (0000h) is received in the SSPSR\n0 = General call address disabled\nbit 6 ACKSTAT: Acknowledge Status bit (Master Transmit mode only)\n1 = Acknowledge was not received from slave\n0 = Acknowledge was received from slave\nbit 5 ACKDT: Acknowledge Data bit (Master Receive mode only)\n1 = Not Acknowledge\n0 = Acknowledge\nNote:\nValue that will be transmitted when the user initiates an Acknowledge sequence at the end of a receive.\nbit 4 ACKEN: Acknowledge Sequence Enable bit (Master Receive mode only) (1)\n1 = Initiate  Acknowledge  sequence  on  SDA  and  SCL  pins  and  transmit  ACKDT  data  bit. Automatically cleared by hardware.\n0 = Acknowledge sequence Idle\nRCEN:\nReceive Enable bit (Master mode only)\n1 = Enables Receive mode for I 2 C\n0 = Receive Idle",
    "bit 2 PEN: Stop Condition Enable bit (Master mode only) (1)\n1 = Initiate Stop condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Stop condition Idle\nbit 1 RSEN: Repeated Start Condition Enable bit (Master mode only) (1)\n1 = Initiate Repeated Start condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Repeated Start condition Idle\nbit 0 SEN: Start Condition Enable/Stretch Enable bit (1)",
    "In Master mode:\n1 = Initiate Start condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Start condition Idle",
    "In Slave mode:\n1 = Clock stretching is enabled for both slave transmit and slave receive (stretch enabled)\n0 = Clock stretching is disabled\nNote 1:\nFor bits ACKEN, RCEN, PEN, RSEN, SEN: If the I 2 C module is not in the Idle mode, these bits may not be set (no spooling) and the SSPBUF may not be written (or writes to the SSPBUF are disabled).",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared x = Bit is unknown\n(1)",
    "17.4.3.1 Addressing\nThe  MSSP  module  functions  are  enabled  by  setting MSSP Enable bit, SSPEN (SSPCON<5>).\nThe  SSPCON1  register  allows  control  of  the  I 2 C operation.  Four mode selection bits (SSPCON<3:0>) allow one of the following I 2 C modes to be selected:\n\u00b7 I 2 C Master mode, clock = (FOSC/4) x (SSPADD + 1)\n\u00b7 I 2 C Slave mode (7-bit address)\n\u00b7 I 2 C Slave mode (10-bit address)\n\u00b7 I 2 C Slave mode (7-bit address) with Start and Stop bit interrupts enabled\n\u00b7 I 2 C Slave mode (10-bit address) with Start and Stop bit interrupts enabled\n\u00b7 I 2 C Firmware Controlled Master mode, slave is Idle\nSelection  of  any  I 2 C  mode  with  the  SSPEN  bit  set, forces  the  SCL  and  SDA  pins  to  be  open-drain, provided  these  pins  are  programmed  to  inputs  by setting the appropriate TRISC bits. To ensure proper operation  of  the  module,  pull-up  resistors  must  be provided externally to the SCL and SDA pins.",
    "17.4.3 SLAVE MODE\nIn Slave mode, the SCL and SDA pins must be configured as inputs (TRISC<4:3> set). The MSSP module will override the input state with the output data when required (slave-transmitter).\nThe I 2 C Slave mode hardware will always generate an interrupt  on  an  address  match.  Through  the  mode select  bits,  the  user  can  also  choose  to  interrupt  on Start and Stop bits\nWhen an address is matched, or the data transfer after an address match is received, the hardware automatically will generate the Acknowledge (ACK) pulse and load  the  SSPBUF  register  with  the  received  value currently in the SSPSR register.\nAny combination of the following conditions will cause the MSSP module not to give this ACK pulse:\n\u00b7 The Buffer Full bit, BF (SSPSTAT<0>), was set before the transfer was received.\n\u00b7 The overflow bit, SSPOV (SSPCON<6>), was set before the transfer was received.",
    "17.4.3 SLAVE MODE\nIn this  case, the SSPSR register value is not loaded into the SSPBUF, but bit SSPIF (PIR1<3>) is set. The BF bit is cleared by reading the SSPBUF register, while bit SSPOV is cleared through software.\nThe SCL clock input must have a minimum high and low for proper operation. The high and low times of the I 2 C  specification,  as  well  as  the  requirement  of  the MSSP module, are shown in timing parameter 100 and parameter 101.\nOnce the MSSP module has been enabled, it waits for a Start condition to occur. Following the Start condition, the  8-bits  are  shifted  into  the  SSPSR  register.  All incoming bits are sampled with the rising edge of the clock (SCL) line. The value of register SSPSR<7:1> is compared to the value of the SSPADD register. The address is compared on the falling edge of the eighth clock (SCL) pulse. If the addresses match and the BF and SSPOV bits are clear, the following events occur:",
    "17.4.3 SLAVE MODE\n1. The  SSPSR  register  value  is  loaded  into  the SSPBUF register.\n2. The Buffer Full bit, BF, is set.\n3. An ACK pulse is generated.\n4. MSSP Interrupt  Flag  bit,  SSPIF  (PIR1<3>),  is set  (interrupt  is  generated,  if  enabled)  on  the falling edge of the ninth SCL pulse.\nIn 10-bit Address mode, two address bytes need to be received  by  the  slave.  The  five  Most  Significant  bits (MSbs) of the first address byte specify if this is a 10-bit address. Bit R/W (SSPSTAT<2>) must specify a write so the slave device will receive the second address byte. For a 10-bit address, the first byte would equal ' 11110 A9 A8 0 ', where ' A9 ' and ' A8 ' are the two MSbs of the address. The sequence of events for 10-bit address is as follows, with steps 7 through 9 for the slave-transmitter:",
    "17.4.3 SLAVE MODE\n1. Receive first (high) byte of address (bits SSPIF, BF and UA (SSPSTAT<1>) are set).\n2. Update the SSPADD register with second (low) byte of address (clears bit UA and releases the SCL line).\n3. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n4. Receive  second  (low)  byte  of  address  (bits SSPIF, BF and UA are set).\n5. Update the SSPADD register with the first (high) byte of address. If match releases SCL line, this will clear bit UA.\n6. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n7. Receive Repeated Start condition.\n8. Receive first (high) byte of address (bits SSPIF and BF are set).\n9. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.",
    "17.4.3.3 Transmission\nWhen the R/W bit of the address byte is clear and an address match occurs, the R/W bit  of  the  SSPSTAT register is cleared. The received address is loaded into the  SSPBUF  register  and  the  SDA  line  is  held  low (ACK).\nWhen the address byte overflow condition exists, then the no Acknowledge (ACK) pulse is given. An overflow condition is defined as either bit BF (SSPSTAT<0>) is set, or bit SSPOV (SSPCON1<6>) is set.\nAn MSSP interrupt is generated for each data transfer byte.  Flag  bit,  SSPIF  (PIR1<3>),  must  be  cleared  in software. The SSPSTAT register is used to determine the status of the byte.\nIf SEN is enabled (SSPCON2<0> = 1 ), RC3/SCK/SCL will  be  held  low  (clock  stretch)  following  each  data transfer.  The  clock  must  be  released  by  setting  bit CKP  (SSPCON<4>).  See Section 17.4.4 'Clock Stretching' for more detail.",
    "17.4.3.3 Transmission\nWhen the R/W bit of the incoming address byte is set and  an  address  match  occurs,  the  R/W  bit  of  the SSPSTAT  register  is  set.  The  received  address  is loaded into the SSPBUF register. The ACK pulse will be sent on the ninth bit and pin RC3/SCK/SCL is held low  regardless  of  SEN  (see Section 17.4.4  'Clock Stretching' for  more detail). By stretching the clock, the master will be unable to assert another clock pulse until the slave is done preparing the transmit data. The transmit data must be loaded into the SSPBUF register which also loads the SSPSR register. Then pin RC3/ SCK/SCL should be enabled by setting bit, CKP (SSPCON1<4>). The eight data bits are shifted out on the falling  edge  of  the  SCL  input.  This  ensures  that  the SDA  signal is valid during the SCL high time (Figure 17-9).",
    "17.4.3.3 Transmission\nThe ACK pulse from the master-receiver is latched on the rising edge of the ninth SCL input pulse. If the SDA line is high  (not  ACK),  then  the  data  transfer  is complete. In this case, when the ACK is latched by the slave, the slave logic is reset (resets SSPSTAT register) and the slave monitors for another occurrence of the Start bit. If the SDA line was low (ACK), the next transmit data must be loaded into the SSPBUF register. Again, pin RC3/SCK/SCL must be enabled by setting bit CKP.\nAn MSSP interrupt is generated for each data transfer byte. The SSPIF bit must be cleared in software and the SSPSTAT register is used to determine the status of the byte. The SSPIF bit is set on the falling edge of the ninth clock pulse.",
    "17.4.4 CLOCK STRETCHING\nBoth 7 and 10-bit Slave modes implement automatic clock stretching during a transmit sequence.",
    "17.4.4.3 Clock Stretching for 7-bit Slave Transmit Mode\nThe SEN bit (SSPCON2<0>) allows clock stretching to be  enabled  during  receives.  Setting  SEN  will  cause the  SCL  pin  to  be  held  low  at  the  end  of  each  data receive sequence.",
    "17.4.4.1 Clock Stretching for 7-bit Slave Receive Mode (SEN = 1 )\nIn 7-bit Slave Receive mode, on the falling edge of the ninth clock at the end of the ACK sequence if the BF bit  is  set,  the  CKP  bit  in  the  SSPCON1  register  is automatically  cleared,  forcing  the  SCL  output  to  be held low. The CKP being cleared to ' 0 ' will assert the SCL line low. The CKP bit must be set in the user's ISR before reception is allowed to continue. By holding the SCL line low, the user has time to service the ISR and  read  the  contents  of  the  SSPBUF  before  the master device can initiate another receive sequence. This will  prevent  buffer  overruns  from  occurring  (see Figure 17-13).",
    "17.4.4.1 Clock Stretching for 7-bit Slave Receive Mode (SEN = 1 )\nNote 1: If the  user  reads  the  contents  of  the SSPBUF  before  the  falling  edge  of  the ninth clock, thus clearing the BF bit, the CKP  bit  will  not  be  cleared  and  clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software regardless of the state of the BF bit. The user should be careful to clear the BF bit in the ISR before the next receive sequence in order to prevent an overflow condition.",
    "17.4.4.2 Clock Stretching for 10-bit Slave Receive Mode (SEN = 1 )\nIn  10-bit  Slave  Receive  mode  during  the  address sequence,  clock  stretching  automatically  takes  place but CKP is not cleared. During this time, if the UA bit is set  after  the  ninth  clock,  clock  stretching  is  initiated. The UA bit is set after receiving the upper byte of the 10-bit address and following the receive of the second byte of the 10-bit address with the R/W bit cleared to ' 0 '. The release of the clock line occurs upon updating SSPADD.  Clock  stretching  will  occur  on  each  data receive sequence as described in 7-bit mode.\nNote:\nIf the user polls the UA bit and clears it by updating the SSPADD register before the falling edge of the ninth clock occurs and if the user hasn't cleared the BF bit by reading the SSPBUF register before that time, then the CKP bit will still NOT be asserted low.  Clock  stretching  on  the  basis  of  the state  of  the  BF  bit  only  occurs  during  a data sequence, not an address sequence.",
    "17.4.4.2 Clock Stretching for 10-bit Slave Receive Mode (SEN = 1 )\n7-bit Slave Transmit mode implements clock stretching by  clearing  the  CKP  bit  after  the  falling  edge  of  the ninth clock if the BF bit is clear. This occurs regardless of the state of the SEN bit.\nThe user's ISR must set the CKP bit before transmission  is  allowed  to  continue.  By  holding  the  SCL  line low, the user has time to service the ISR and load the contents of the SSPBUF before the master device can initiate another transmit sequence (see Figure 17-9).\nNote 1: If the user loads the contents of SSPBUF, setting the BF bit before the falling edge of the  ninth  clock,  the  CKP  bit  will  not  be cleared and clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software regardless of the state of the BF bit.",
    "17.4.4.4 Clock Stretching for 10-bit Slave Transmit Mode\nIn  10-bit  Slave  Transmit  mode,  clock  stretching  is controlled  during  the  first  two  address  sequences  by the  state  of  the  UA  bit,  just  as  it  is  in  10-bit  Slave Receive mode. The first  two  addresses are  followed by a third address sequence which contains the highorder bits of the 10-bit address and the R/W bit set to ' 1 '. After the third address sequence is performed, the UA  bit  is  not  set,  the  module  is  now  configured  in Transmit  mode  and  clock  stretching  is  controlled  by the  BF  flag  as  in  7-bit  Slave  Transmit  mode  (see Figure 17-11).",
    "17.4.4.5 Clock Synchronization and the CKP bit\nWhen the CKP bit is cleared, the SCL output is forced to ' 0 '. However, setting the CKP bit will not assert the SCL  output  low  until the SCL  output  is already sampled low. Therefore, the CKP bit will not assert the SCL  line  until  an  external  I 2 C  master  device  has already  asserted  the  SCL  line.  The  SCL  output  will remain  low  until  the  CKP  bit  is  set  and  all  other devices  on  the  I 2 C  bus  have  deasserted  SCL.  This ensures that a write to the CKP bit will not violate the minimum high time requirement for SCL (see Figure 17-12).",
    "17.4.5 GENERAL CALL ADDRESS SUPPORT\nThe addressing procedure for the I 2 C bus is such that the first byte after the Start condition usually determines which device will be the slave addressed by the master. The exception is the general call address which can address all devices. When this address is used,  all  devices  should,  in  theory,  respond  with  an Acknowledge.\nThe  general  call  address  is  one  of  eight  addresses reserved for specific purposes by the I 2 C protocol. It consists of all ' 0 's with R/W = 0 .\nThe  general  call  address  is  recognized  when  the General  Call  Enable  bit,  GCEN,  is  enabled  (SSPCON2<7> set). Following a Start bit detect, 8 bits are shifted into the SSPSR and the address is compared against the SSPADD. It is also compared to the general call address and fixed in hardware.\nIf  the  general  call  address  matches,  the  SSPSR  is transferred to the SSPBUF, the BF flag bit is set (eighth bit) and on the falling edge of the ninth bit (ACK bit), the SSPIF interrupt flag bit is set.",
    "17.4.5 GENERAL CALL ADDRESS SUPPORT\nWhen  the  interrupt  is  serviced,  the  source  for  the interrupt can be checked by reading the contents of the SSPBUF. The value can be used to determine if the address was device specific or a general call address.\nIn 10-bit mode, the SSPADD is required to be updated for the second half of the address to match and the UA bit is set (SSPSTAT<1>). If the general call address is sampled when the GCEN bit is set, while the slave is configured  in  10-bit  Address  mode,  then  the  second half of the address is not necessary, the UA bit will not be set and the slave will begin receiving data after the Acknowledge (Figure 17-15).",
    "17.4.6 MASTER MODE\nMaster  mode  is  enabled  by  setting  and  clearing  the appropriate SSPM bits in SSPCON1 and by setting the SSPEN bit. In Master mode, the SCL and SDA lines are manipulated by the MSSP hardware.\nMaster  mode  of  operation  is  supported  by  interrupt generation  on  the  detection  of  the  Start  and  Stop conditions. The Stop (P) and Start (S) bits are cleared from a Reset or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set or the bus is Idle, with both the S and P bits clear.\nIn Firmware  Controlled Master mode,  user  code conducts  all  I 2 C  bus  operations  based  on  Start  and Stop bit conditions.\nOnce  Master  mode  is  enabled,  the  user  has  six options.\n1. Assert a Start condition on SDA and SCL.\n2. Assert a Repeated Start condition on SDA and SCL.\n3. Write to the SSPBUF register initiating transmission of data/address.\n4. Configure the I 2 C port to receive data.\n5. Generate an Acknowledge condition at the end of a received byte of data.\n6. Generate a Stop condition on SDA and SCL.",
    "Note:\nThe  MSSP  module,  when  configured  in I 2 C Master mode, does not allow queueing of  events.  For  instance,  the  user  is  not allowed  to  initiate  a  Start  condition  and immediately write the SSPBUF register to initiate transmission before the Start condition  is  complete.  In  this  case,  the SSPBUF  will  not  be  written  to  and  the WCOL bit will be set, indicating that a write to the SSPBUF did not occur.\nThe following events will cause the SSP Interrupt Flag bit, SSPIF, to be set (SSP interrupt, if enabled):\n\u00b7 Start condition\n\u00b7 Stop condition\n\u00b7 Data transfer byte transmitted/received\n\u00b7 Acknowledge transmit\n\u00b7 Repeated Start",
    "17.4.6.1 I 2 C Master Mode Operation\nA typical transmit sequence would go as follows:\nThe  master  device  generates  all  of  the  serial  clock pulses and the Start and Stop conditions.   A transfer is ended with a Stop condition or with a Repeated Start condition. Since the Repeated Start condition is also the beginning of the next serial transfer, the I 2 C bus will not be released.\nIn  Master  Transmitter  mode,  serial  data  is  output through SDA, while SCL outputs the serial clock. The first byte transmitted contains the slave address of the receiving device (7 bits) and the Read/Write (R/W) bit. In this case, the R/W bit will be logic ' 0 '. Serial data is transmitted 8 bits at a time. After each byte is transmitted,  an  Acknowledge  bit  is  received.  Start  and  Stop conditions are output to indicate the beginning and the end of a serial transfer.",
    "17.4.6.1 I 2 C Master Mode Operation\nIn  Master  Receive  mode,  the  first  byte  transmitted contains the slave address of the transmitting device (7 bits) and the R/W bit. In this case, the R/W bit will be logic ' 1 ' Thus, the first byte transmitted is a 7-bit slave address followed  by  a  ' 1 '  to  indicate  the  receive  bit. Serial data is received via SDA, while SCL outputs the serial clock. Serial data is received 8 bits at a time. After each byte is received, an Acknowledge bit is transmitted.  Start  and  Stop  conditions  indicate  the  beginning and end of transmission.\nThe  Baud  Rate  Generator  used  for  the  SPI  mode operation is used to set the SCL clock frequency for either 100 kHz, 400 kHz or 1 MHz I 2 C operation. See Section 17.4.7 'Baud Rate' for more detail.",
    "17.4.6.1 I 2 C Master Mode Operation\n1. The user generates a Start condition by setting the Start Enable bit, SEN (SSPCON2<0>).\n2. SSPIF is set. The MSSP module will wait the required  start  time  before  any  other  operation takes place.\n3. The  user  loads  the  SSPBUF  with  the  slave address to transmit.\n4. Address is shifted out the SDA pin until all 8 bits are transmitted.\n5. The MSSP Module shifts in the ACK bit from the slave device and writes its value into the SSPCON2 register (SSPCON2<6>).\n6. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.\n7. The user loads the SSPBUF with eight bits of data.\n8. Data is shifted out the SDA pin until all 8 bits are transmitted.\n9. The MSSP module shifts in the ACK bit from the slave device and writes its value into the SSPCON2 register (SSPCON2<6>).\n10. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.",
    "17.4.6.1 I 2 C Master Mode Operation\n11. The user generates a Stop condition by setting the Stop Enable bit, PEN (SSPCON2<2>).\n12. Interrupt is generated once the Stop condition is complete.",
    "17.4.7 BAUD RATE\nIn I 2 C Master mode, the Baud Rate Generator (BRG) reload  value  is  placed  in  the  lower  7  bits  of  the SSPADD register (Figure 17-17). When a write occurs to SSPBUF, the Baud Rate Generator will automatically begin counting. The BRG counts down to ' 0 ' and stops until another reload has taken place. The BRG count is decremented twice per instruction cycle (TCY) on the Q2 and Q4 clocks. In I 2 C Master mode, the BRG is reloaded automatically.\nOnce the given operation is complete (i.e., transmission of the last data bit is followed by ACK), the internal clock will automatically stop counting and the SCL pin will remain in its last state.\nTable 17-3 demonstrates clock rates based on instruction  cycles  and  the  BRG  value  loaded  into SSPADD.",
    "TABLE 17-3: I 2 C\u2122 CLOCK RATE W/BRG\n10 MHz, FCY*2 = 20 MHz. 10 MHz, BRG Value = 19h. 10 MHz, FSCL (2 Rollovers of BRG) = 400 kHz (1). 10 MHz, FCY*2 = 20 MHz. 10 MHz, BRG Value = 20h. 10 MHz, FSCL (2 Rollovers of BRG) = 312.5 kHz. 10 MHz, FCY*2 = 20 MHz. 10 MHz, BRG Value = 64h. 10 MHz, FSCL (2 Rollovers of BRG) = 100 kHz. 4 MHz, FCY*2 = 8 MHz. 4 MHz, BRG Value = 0Ah. 4 MHz, FSCL (2 Rollovers of BRG) = 400 kHz (1). 4 MHz, FCY*2 = 8 MHz. 4 MHz, BRG Value = 0Dh. 4 MHz, FSCL (2 Rollovers of BRG) = 308 kHz. 4 MHz, FCY*2 = 8 MHz. 4 MHz, BRG Value = 28h. 4 MHz, FSCL (2 Rollovers of BRG) = 100",
    "TABLE 17-3: I 2 C\u2122 CLOCK RATE W/BRG\nkHz. 1 MHz, FCY*2 = 2 MHz. 1 MHz, BRG Value = 03h. 1 MHz, FSCL (2 Rollovers of BRG) = 333 kHz (1). 1 MHz, FCY*2 = 2 MHz. 1 MHz, BRG Value = 0Ah. 1 MHz, FSCL (2 Rollovers of BRG) = 100 kHz. 1 MHz, FCY*2 = 2 MHz. 1 MHz, BRG Value = 00h. 1 MHz, FSCL (2 Rollovers of BRG) = 1 MHz (1)\nNote 1: The I 2 C\u2122 interface does not conform to the 400 kHz I 2 C specification (which applies to rates greater than 100 kHz) in all details, but may be used with care where higher rates are required by the application.",
    "17.4.7.1 Clock Arbitration\nClock arbitration occurs when the master, during any receive,  transmit  or  Repeated  Start/Stop  condition, deasserts  the  SCL  pin  (SCL  allowed  to  float  high). When the SCL pin is allowed to float high, the Baud Rate  Generator  (BRG)  is  suspended  from  counting until the SCL pin is actually sampled high. When the\nSCL pin is sampled high, the Baud Rate Generator is reloaded  with  the  contents  of  SSPADD<6:0>  and begins counting. This ensures that the SCL high time will always be at least one BRG rollover count in the event that the clock is held low by an external device (Figure 17-18).",
    "17.4.8 I 2 C MASTER MODE START CONDITION TIMING\nTo  initiate  a  Start  condition,  the  user  sets  the  Start Enable bit, SEN (SSPCON2<0>). If the SDA and SCL pins  are  sampled  high,  the  Baud  Rate  Generator  is reloaded with the contents of SSPADD<6:0> and starts its count. If SCL and SDA are both sampled high when the Baud Rate Generator times out (TBRG), the SDA pin is driven low. The action of the SDA being driven low while SCL is high is the Start condition and causes the S bit (SSPSTAT<3>) to be set. Following this, the Baud Rate Generator is reloaded with the contents of SSPADD<6:0> and resumes its count. When the Baud Rate Generator times out (TBRG), the SEN bit (SSPCON2<0>) will be automatically cleared by hardware, the  Baud  Rate  Generator  is  suspended,  leaving  the SDA line held low and the Start condition is complete.\nNote:",
    "17.4.8 I 2 C MASTER MODE START CONDITION TIMING\nIf  at  the  beginning  of  the  Start  condition, the SDA and SCL pins are already sampled low, or if during the Start condition, the SCL line is sampled low before the SDA line  is  driven  low,  a  bus  collision  occurs, the Bus Collision Interrupt Flag, BCLIF, is set, the Start condition is aborted and the I 2 C module is reset into its Idle state.",
    "17.4.8.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Start sequence is in progress, the WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).",
    "Note:\nBecause queueing of events is not allowed, writing to the lower 5 bits of SSP- CON2 is disabled until the Start condition is complete.",
    "17.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nA Repeated Start condition occurs when the RSEN bit (SSPCON2<1>) is programmed high and the I 2 C logic module is in the Idle state. When the RSEN bit is set, the  SCL  pin  is  asserted  low.  When  the  SCL  pin  is sampled low, the Baud Rate Generator is loaded with the  contents  of  SSPADD<5:0>  and  begins  counting. The SDA pin is released (brought high) for one Baud Rate  Generator  count  (TBRG).  When  the  Baud  Rate Generator times out, if SDA is sampled high, the SCL pin  will  be  deasserted  (brought  high).  When  SCL  is sampled  high,  the  Baud  Rate  Generator  is  reloaded with the contents of SSPADD<6:0> and begins counting. SDA and SCL must be sampled high for one TBRG. This action is then followed by assertion of the SDA pin (SDA = 0 ) for one TBRG while SCL is high. Following this, the RSEN bit (SSPCON2<1>) will be automatically cleared  and  the  Baud  Rate  Generator  will  not",
    "17.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nbe reloaded, leaving the SDA pin held low. As soon as a Start condition is detected on the SDA and SCL pins, the S bit (SSPSTAT<3>) will be set. The SSPIF bit will not be set until the Baud Rate Generator has timed out.\nNote 1: If  RSEN is programmed while any other event is in progress, it will not take effect.\n2: A bus collision during the Repeated Start condition occurs if:\n\u00b7SDA is sampled low when SCL goes from low-to-high.\n\u00b7SCL goes low before SDA is asserted low. This may indicate that another master is attempting to transmit a data ' 1 '.\nImmediately following the SSPIF bit getting set, the user may write the SSPBUF with the 7-bit address in 7-bit mode, or the default first address in 10-bit mode. After the  first eight  bits  are  transmitted  and  an  ACK  is received, the user may then transmit an additional eight bits of address (10-bit mode) or eight bits of data (7-bit mode).",
    "17.4.9.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Repeated Start sequence  is  in  progress,  the  WCOL  is  set  and  the contents of the buffer are unchanged (the write doesn't occur).",
    "Note:\nBecause queueing of events is not allowed, writing of the lower 5 bits of SSPCON2 is disabled until the Repeated Start condition is complete.",
    "17.4.10 I 2 C MASTER MODE TRANSMISSION\nTransmission  of  a  data  byte,  a  7-bit  address  or  the other half of a 10-bit address is accomplished by simply writing a value to the SSPBUF register. This action will set the Buffer Full flag bit, BF and allow the Baud Rate Generator to begin counting and start the next transmission. Each bit of address/data will be shifted out onto the SDA pin after the falling edge of SCL is asserted (see data hold time specification parameter 106).  SCL  is  held  low  for  one  Baud  Rate  Generator rollover count (TBRG). Data should be valid before SCL is  released  high  (see  data  setup  time  specification parameter 107). When the SCL pin is released high, it is  held  that  way  for  TBRG.  The  data  on  the  SDA  pin must  remain  stable  for  that  duration  and  some  hold time after the next falling edge of SCL. After the eighth bit is shifted out (the falling edge of the eighth clock), the BF flag is cleared and the master releases SDA. This  allows  the  slave  device  being  addressed  to respond with an ACK bit during the ninth bit time if an address  match  occurred,  or  if  data  was",
    "17.4.10 I 2 C MASTER MODE TRANSMISSION\nreceived properly. The status of ACK is written into the ACKDT bit on the falling edge of the ninth clock. If the master receives an Acknowledge, the Acknowledge status bit, ACKSTAT, is cleared. If not, the bit is set. After the ninth clock, the SSPIF bit is set and the master clock (Baud Rate Generator) is suspended until the next data byte is loaded into the SSPBUF, leaving SCL low and SDA unchanged (Figure 17-21).",
    "17.4.10 I 2 C MASTER MODE TRANSMISSION\nAfter the write to the SSPBUF, each bit of address will be shifted out on the falling edge of SCL until all seven address bits and the R/W bit are completed. On the falling edge of the eighth clock, the master will deassert the  SDA  pin,  allowing  the  slave  to  respond  with  an Acknowledge. On the falling edge of the ninth clock, the master will sample the SDA pin to see if the address was recognized by a slave. The status of the ACK bit is loaded into the ACKSTAT status bit (SSPCON2<6>). Following the falling edge of the ninth clock transmission of the address, the SSPIF is set, the BF flag is cleared and the Baud Rate Generator is turned off until another write to the SSPBUF takes place, holding SCL low and allowing SDA to float.",
    "17.4.10.1 BF Status Flag\nIn  Transmit  mode,  the  BF  bit  (SSPSTAT<0>)  is  set when the CPU writes to SSPBUF and is cleared when all 8 bits are shifted out.",
    "17.4.10.2 WCOL Status Flag\nIf  the  user  writes  the  SSPBUF  when  a  transmit  is already in progress (i.e., SSPSR is still shifting out a data byte), the WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).\nWCOL must be cleared in software.",
    "17.4.10.3 ACKSTAT Status Flag\nIn Transmit mode, the ACKSTAT bit (SSPCON2<6>) is cleared  when  the  slave  has  sent  an  Acknowledge (ACK = 0 ) and is set when the slave does not Acknowledge (ACK = 1 ). A slave sends an Acknowledge when it has recognized its address (including a general call), or when the slave has properly received its data.",
    "17.4.11 I 2 C MASTER MODE RECEPTION\nMaster mode reception is enabled by programming the Receive Enable bit, RCEN (SSPCON2<3>).\nNote:\nThe MSSP module must be in an Idle state before the RCEN bit is set or the RCEN bit will be disregarded.\nThe Baud Rate Generator begins counting and on each rollover, the state of the SCL pin changes (high-to-low/ low-to-high) and data is shifted into the SSPSR. After the falling edge of the eighth clock, the receive enable flag is automatically  cleared,  the  contents  of  the SSPSR are loaded into the SSPBUF, the BF flag bit is set,  the  SSPIF  flag  bit  is  set  and  the  Baud  Rate Generator  is  suspended  from  counting,  holding  SCL low. The MSSP is now in Idle state awaiting the next command. When the buffer is read by the CPU, the BF flag  bit  is  automatically  cleared.  The  user  can  then send an Acknowledge bit at the end of reception by setting the Acknowledge sequence enable bit, ACKEN (SSPCON2<4>).",
    "17.4.11.1 BF Status Flag\nIn receive operation, the BF bit is set when an address or data byte is loaded into SSPBUF from SSPSR. It is cleared when the SSPBUF register is read.",
    "17.4.11.2 SSPOV Status Flag\nIn receive operation, the SSPOV bit is set when 8 bits are  received  into  the  SSPSR  and  the  BF  flag  bit  is already set from a previous reception.",
    "17.4.11.3 WCOL Status Flag\nIf the  user  writes  the  SSPBUF  when  a  receive  is already in progress (i.e., SSPSR is still shifting in a data byte), the WCOL bit is set and the contents of the buffer are unchanged (the write doesn't occur).",
    "17.4.12 ACKNOWLEDGE SEQUENCE TIMING\nAn  Acknowledge  sequence  is  enabled  by  setting  the Acknowledge  sequence  enable  bit,  ACKEN  (SSPCON2<4>). When this bit is set, the SCL pin is pulled low and the contents of the Acknowledge data bit are presented on the SDA pin. If the user wishes to generate an Acknowledge, then the ACKDT bit should be cleared. If not, the user should set the ACKDT bit before starting an Acknowledge sequence. The Baud Rate Generator then counts for one rollover period (TBRG) and the SCL pin is deasserted (pulled high). When the SCL pin is sampled high (clock arbitration), the Baud Rate Generator counts for TBRG. The SCL pin is then pulled low. Following this, the ACKEN bit is automatically cleared, the Baud Rate Generator is turned off and the MSSP module then goes into Idle mode (Figure 17-23).",
    "17.4.12.1 WCOL Status Flag\nIf the user writes the SSPBUF when an Acknowledge sequence is  in  progress,  then  WCOL  is  set  and  the contents of the buffer are unchanged (the write doesn't occur).",
    "17.4.13 STOP CONDITION TIMING\nA Stop bit is asserted on the SDA pin at the end of a receive/transmit by setting the Stop Sequence Enable bit,  PEN  (SSPCON2<2>).  At  the  end  of  a  receive/ transmit, the SCL line is held low after the falling edge of the ninth clock. When the PEN bit is set, the master will  assert  the  SDA  line  low.  When  the  SDA  line  is sampled low, the Baud Rate Generator is reloaded and counts  down  to  ' 0 '.  When  the  Baud  Rate  Generator times out,  the  SCL pin  will  be  brought  high  and  one TBRG (Baud Rate Generator rollover count) later, the SDA  pin  will  be  deasserted.  When  the  SDA  pin  is sampled high while SCL is high, the P bit (SSPSTAT<4>)  is  set.  A  TBRG  later,  the  PEN  bit  is cleared and the SSPIF bit is set (Figure 17-24).",
    "17.4.13.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Stop sequence is  in  progress,  then  the  WCOL  bit  is  set  and  the contents of the buffer are unchanged (the write doesn't occur).",
    "17.4.14 SLEEP OPERATION\nWhile  in  Sleep  mode,  the  I 2 C  module  can  receive addresses  or  data  and  when  an  address  match  or complete  byte  transfer  occurs,  wake  the  processor from Sleep (if the MSSP interrupt is enabled).",
    "17.4.15 EFFECT OF A RESET\nA Reset disables the MSSP module and terminates the current transfer.",
    "17.4.16 MULTI-MASTER MODE\nIn Multi-Master mode, the interrupt generation on the detection of  the  Start  and  Stop  conditions  allows  the determination of when the bus is free. The Stop (P) and Start  (S)  bits  are  cleared  from  a  Reset  or  when  the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit (SSPSTAT<4>) is set, or the bus is Idle, with both the S and P bits clear. When the bus is busy, enabling the SSP interrupt will generate the interrupt when the Stop condition occurs.\nIn multi-master  operation,  the SDA  line  must  be monitored for arbitration to see if the signal level is the expected  output  level.  This  check  is  performed  in hardware with the result placed in the BCLIF bit.\nThe states where arbitration can be lost are:\n\u00b7 Address Transfer\n\u00b7 Data Transfer\n\u00b7 A Start Condition\n\u00b7 A Repeated Start Condition\n\u00b7 An Acknowledge Condition",
    "17.4.17 MULTI-MASTER COMMUNICATION, BUS COLLISION AND BUS ARBITRATION\nMulti-Master mode support is achieved by bus arbitration. When the master outputs address/data bits onto the SDA pin, arbitration takes place when the master outputs  a  ' 1 '  on  SDA,  by  letting  SDA  float  high  and another master asserts a ' 0 '. When the SCL pin floats high,  data  should  be  stable.  If  the  expected  data  on SDA is a ' 1 ' and the data sampled on the SDA pin = 0 , then a bus collision has taken place. The master will set the Bus Collision Interrupt Flag, BCLIF and reset the I 2 C port to its Idle state (Figure 17-25).\nIf  a  transmit  was  in  progress  when  the  bus  collision occurred,  the  transmission  is  halted,  the  BF  flag  is cleared, the SDA and SCL lines are deasserted and the SSPBUF can be written to. When the user services the bus collision  Interrupt  Service  Routine  and  if  the  I 2 C bus  is  free,  the  user  can  resume  communication  by asserting a Start condition.",
    "17.4.17 MULTI-MASTER COMMUNICATION, BUS COLLISION AND BUS ARBITRATION\nIf a Start, Repeated Start, Stop or Acknowledge condition was  in progress  when  the  bus  collision occurred,  the  condition  is  aborted,  the  SDA  and  SCL lines are deasserted and the respective control bits in the SSPCON2 register are cleared. When the user services the bus collision Interrupt Service Routine and if the I 2 C bus is free, the user can resume communication by asserting a Start condition.\nThe master will continue to monitor the SDA and SCL pins. If a Stop condition occurs, the SSPIF bit will be set.\nA write  to  the  SSPBUF  will  start  the  transmission  of data  at  the  first  data  bit  regardless  of  where  the transmitter left off when the bus collision occurred.\nIn  Multi-Master  mode,  the  interrupt  generation  on  the detection of Start and Stop conditions allows the determination of when the bus is free. Control of the I 2 C bus can be taken when the P bit is set in the SSPSTAT register, or the bus is Idle and the S and P bits are cleared.",
    "17.4.17.1 Bus Collision During a Start Condition\nDuring a Start condition, a bus collision occurs if:\na) SDA or SCL are sampled low at the beginning of the Start condition (Figure 17-26).\nb) SCL is sampled low before SDA is asserted low (Figure 17-27).\nIf  the  SDA  pin  is  sampled  low  during  this  count,  the BRG  is  reset  and  the  SDA  line  is  asserted  early (Figure 17-28). If, however, a ' 1 ' is sampled on the SDA pin, the SDA pin is asserted low at the end of the BRG count. The Baud Rate Generator is then reloaded and counts down to 0 and during this time, if the SCL pins are sampled as ' 0 ', a bus collision does not occur. At the end of the BRG count, the SCL pin is asserted low.\nDuring a Start condition, both  the SDA  and the  SCL pins are monitored.\nIf the SDA pin is already low, or the SCL pin is already low, then all of the following occur:",
    "17.4.17.1 Bus Collision During a Start Condition\n\u00b7 the Start condition is aborted,\n\u00b7 the BCLIF flag is set; and\n\u00b7 the MSSP module is reset to its Idle state (Figure 17-26).\nThe Start condition begins with the SDA and SCL pins deasserted. When the SDA pin is sampled high, the Baud  Rate  Generator  is  loaded  from  SSPADD<6:0> and counts down to 0. If the SCL pin is sampled low while SDA is high, a bus collision occurs because it is assumed that another master is attempting to drive a data ' 1 ' during the Start condition.\nThe reason that bus collision is not a factor during a Start condition is that no two bus masters can assert a Start condition at the exact  same  time.  Therefore,  one  master will  always  assert  SDA  before  the  other. This condition does  not cause  a bus collision because the two masters must be allowed to arbitrate the first address following the Start condition. If the address is the same, arbitration must be allowed to continue  into  the  data  portion,  Repeated Start or Stop conditions.",
    "17.4.17.2 Bus Collision During a Repeated Start Condition\nDuring  a  Repeated  Start  condition,  a  bus  collision occurs if:\n- a) A low level is sampled on SDA when SCL goes from low level to high level.\nIf SDA is low, a bus collision has occurred (i.e., another master is attempting to transmit a data ' 0 ', Figure 17-29). If SDA is sampled high, the BRG is reloaded and begins counting. If SDA goes from high to low before the BRG times  out,  no  bus  collision  occurs  because  no  two masters can assert SDA at exactly the same time.\n- b) SCL  goes  low  before  SDA  is  asserted  low, indicating that  another master is attempting to transmit a data ' 1 '.\nWhen the user deasserts SDA and the pin is allowed to float high, the BRG is loaded with SSPADD<6:0> and counts down to 0. The SCL pin is then deasserted and when sampled high, the SDA pin is sampled.",
    "17.4.17.2 Bus Collision During a Repeated Start Condition\nIf SCL goes from high to low before the BRG times out and SDA has not already been asserted, a bus collision occurs. In this case, another master is attempting to transmit a data ' 1 ' during the Repeated Start condition, see Figure 17-30.\nIf, at the end of the BRG time-out, both SCL and SDA are still high, the SDA pin is driven low and the BRG is reloaded and begins counting. At the end of the count, regardless of the status of the SCL pin, the SCL pin is driven low and the Repeated Start condition is complete.",
    "17.4.17.3 Bus Collision During a Stop Condition\nBus collision occurs during a Stop condition if:\na) After  the  SDA  pin  has  been  deasserted  and allowed to float high, SDA is sampled low after the BRG has timed out.\nb) After the SCL pin is deasserted, SCL is sampled low before SDA goes high.\nThe  Stop  condition  begins  with  SDA  asserted  low. When SDA is sampled low, the SCL pin is allowed to float. When the pin is sampled high (clock arbitration), the Baud Rate Generator is loaded with SSPADD<6:0> and counts down to 0. After the BRG times out, SDA is sampled. If  SDA is sampled low, a bus collision has occurred. This is due to another master attempting to drive  a  data  ' 0 ' (Figure 17-31).  If  the  SCL  pin  is sampled low before SDA is allowed to float high, a bus collision occurs. This is another case of another master attempting to drive a data ' 0 ' (Figure 17-32).",
    "FIGURE 17-31: BUS COLLISION DURING A STOP CONDITION (CASE 1)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nSDA asserted low\nSDA sampled low after TBRG, set BCLIF\n' 0 '\n'\n0\n'",
    "FIGURE 17-32: BUS COLLISION DURING A STOP CONDITION (CASE 2)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nAssert SDA\nSCL goes low before SDA goes high, set BCLIF\n' 0 '\n' 0 '",
    "18.0 ENHANCED UNIVERSAL SYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\nThe  Universal  Synchronous  Asynchronous  Receiver Transmitter (USART) module is one of the two serial I/O  modules.  (USART  is  also  known  as  a  Serial Communications Interface or SCI.) The USART can be configured as a full-duplex asynchronous system that can  communicate  with  peripheral  devices,  such  as CRT terminals and personal computers. It can also be configured as a half-duplex synchronous system that can communicate with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs and so on.\nThe EUSART module implements additional features, including  automatic  baud  rate  detection  and  calibration, automatic wake-up on Sync Break reception and 12-bit Break character transmit. These make it ideally suited for use in Local Interconnect Network bus (LIN bus) systems.\nThe  EUSART  can  be  configured  in  the  following modes:",
    "18.0 ENHANCED UNIVERSAL SYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\n\u00b7 Asynchronous (full-duplex) with:\n-Auto-Wake-up on character reception\n-Auto-Baud calibration\n-12-bit Break character transmission\n\u00b7 Synchronous - Master (half-duplex) with selectable clock polarity\n\u00b7 Synchronous - Slave (half-duplex) with selectable clock polarity\nThe pins of the Enhanced USART are multiplexed with PORTC. In order to configure RC6/TX/CK and RC7/RX/DT as a USART:\n\u00b7 bit SPEN (RCSTA<7>) must be set (= 1 )\n\u00b7 bit TRISC<7> must be set (= 1 )\n\u00b7 bit TRISC<6> must be cleared (= 0 ) for Asynchronous and Synchronous Master modes, or set (= 1 ) for Synchronous Slave mode\nNote:\nThe  EUSART  control  will  automatically reconfigure the pin from input to output as needed.\nThe  operation  of  the  Enhanced  USART  module  is controlled through three registers:",
    "18.0 ENHANCED UNIVERSAL SYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\n\u00b7 Transmit Status and Control (TXSTA)\n\u00b7 Receive Status and Control (RCSTA)\n\u00b7 Baud Rate Control (BAUDCON)\nThese are detailed on the following pages in Register 18-1, Register 18-2 and Register 18-3, respectively.",
    "REGISTER 18-1: TXSTA: TRANSMIT STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R-1. R/W-0, 7 = R/W-0. CSRC, 1 = TX9. CSRC, 2 = TXEN. CSRC, 3 = SYNC. CSRC, 4 = SENDB. CSRC, 5 = BRGH. CSRC, 6 = TRMT. CSRC, 7 = TX9D\nCSRC\nTX9\nTXEN\nSYNC\nSENDB\nBRGH\nTRMT\nTX9D\nbit 7\nbit 0",
    "bit 7 CSRC:\nClock Source Select bit\nAsynchronous mode:\nDon't care.\nSynchronous mode:\n1 = Master mode (clock generated internally from BRG)\n0 = Slave mode (clock from external source)",
    "bit 6 TX9: 9-bit Transmit Enable bit\n1 = Selects 9-bit transmission\n0 = Selects 8-bit transmission",
    "bit 5 TXEN: Transmit Enable bit\n1 = Transmit enabled\n0 = Transmit disabled\nNote:\nSREN/CREN overrides TXEN in Sync mode.",
    "bit 4 SYNC: EUSART Mode Select bit\n1 = Synchronous mode\n0 = Asynchronous mode",
    "bit 3 SENDB: Send Break Character bit\nAsynchronous mode:\n1 = Send Sync Break on next transmission (cleared by hardware upon completion)\n0 = Sync Break transmission completed\nSynchronous mode:\nDon't care.",
    "bit 2 BRGH: High Baud Rate Select bit\nAsynchronous mode:\n1 = High speed\n0 = Low speed\nSynchronous mode:\nUnused in this mode.",
    "bit 1 TRMT: Transmit Shift Register Status bit\n1 = TSR empty\n0 = TSR full",
    "bit 0 TX9D: 9th bit of Transmit Data\nCan be address/data bit or a parity bit.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 0",
    "REGISTER 18-2: RCSTA: RECEIVE STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-x. SPEN, 1 = RX9. SPEN, 2 = SREN. SPEN, 3 = CREN. SPEN, 4 = ADDEN. SPEN, 5 = FERR. SPEN, 6 = OERR. SPEN, 7 = RX9D\nbit 7\nbit 0",
    "bit 7 SPEN: Serial Port Enable bit\n1 = Serial port enabled (configures RX/DT and TX/CK pins as serial port pins)\n0 = Serial port disabled (held in Reset)",
    "bit 6 RX9: 9-bit Receive Enable bit\n1 = Selects 9-bit reception\n0 = Selects 8-bit reception",
    "Asynchronous mode:\nDon't care.",
    "Synchronous mode - Master:\n1 = Enables single receive\n0 = Disables single receive\nThis bit is cleared after reception is complete.\nSynchronous mode - Slave:\nDon't care.",
    "Asynchronous mode:\n1 = Enables receiver\n0 = Disables receiver",
    "Synchronous mode:\n1 = Enables continuous receive until enable bit CREN is cleared (CREN overrides SREN)\n0 = Disables continuous receive",
    "bit 3 ADDEN: Address Detect Enable bit\nAsynchronous mode 9-bit (RX9 = 1 ):\n1 = Enables address detection, enables interrupt and loads the receive buffer when RSR<8> is set\n= Disables address detection, all bytes are received and ninth bit can be used as parity bit\n0 Asynchronous mode 9-bit (RX9 = 0 ):\nDon't care.",
    "bit 2 FERR: Framing Error bit\n1 = Framing error (can be updated by reading RCREG register and receiving next valid byte)\n0 = No framing error",
    "bit 1 OERR: Overrun Error bit\n1 = Overrun error (can be cleared by clearing bit CREN)\n0 = No overrun error\nRX9D:\n9th bit of Received Data bit\nThis can be address/data bit or a parity bit and must be calculated by user firmware.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, read = '0' = Bit is cleared. -n = Value at POR, as '0' = x = Bit is unknown",
    "REGISTER 18-3: BAUDCON: BAUD RATE CONTROL REGISTER\nR/W-0, 1 = R-1. R/W-0, 2 = U-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = U-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. ABDOVF, 1 = RCIDL. ABDOVF, 2 = -. ABDOVF, 3 = SCKP. ABDOVF, 4 = BRG16. ABDOVF, 5 = -. ABDOVF, 6 = WUE. ABDOVF, 7 = ABDEN\nbit 7\nbit 0",
    "bit 7 ABDOVF: Auto-Baud Acquisition Rollover Status bit\n1 = A BRG rollover has occurred during Auto-Baud Rate Detect mode (must be cleared in software)\n0 = No BRG rollover has occurred",
    "bit 6 RCIDL: Receive Operation Idle Status bit\n1 = Receive operation is Idle\n0 = Receive operation is active",
    "bit 4 SCKP: Synchronous Clock Polarity Select bit\nAsynchronous mode:\nUnused in this mode.",
    "Synchronous mode:\n1 = Idle state for clock (CK) is a high level\n0 = Idle state for clock (CK) is a low level\nBRG16: 16-bit Baud Rate Register Enable bit\n1 = 16-bit Baud Rate Generator - SPBRGH and SPBRG\n0 = 8-bit Baud Rate Generator - SPBRG only (Compatible mode), SPBRGH value ignored",
    "Asynchronous mode:\n1 = EUSART will continue to sample the RX pin - interrupt generated on falling edge; bit cleared in hardware on following rising edge\n0 = RX pin not monitored or rising edge detected\nSynchronous mode:\nUnused in this mode.\n1 = Enable baud rate measurement on the next character. Requires reception of a Sync field (55h); cleared in hardware upon completion\n0 = Baud rate measurement disabled or completed\nSynchronous mode:\nUnused in this mode.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "18.1 Baud Rate Generator (BRG)\nThe BRG is a dedicated 8-bit or 16-bit generator that supports  both  the  Asynchronous  and  Synchronous modes of the EUSART. By default, the BRG operates in 8-bit mode; setting the BRG16 bit (BAUDCON<3>) selects 16-bit mode.\ngeous to use the high baud rate (BRGH = 1 )  or  the 16-bit BRG to reduce the baud rate error, or achieve a slow baud rate for a fast oscillator frequency.\nThe SPBRGH:SPBRG register pair controls the period of  a  free  running  timer.  In  Asynchronous  mode,  bits BRGH (TXSTA<2>) and BRG16 (BAUDCON<3>) also control the baud rate. In Synchronous mode, BRGH is ignored. Table 18-1 shows the formula for computation of  the  baud  rate  for  different  EUSART  modes  which only apply in Master mode (internally generated clock).",
    "18.1 Baud Rate Generator (BRG)\nGiven  the  desired  baud  rate  and  FOSC,  the  nearest integer value for the SPBRGH:SPBRG registers can be calculated using the formulas in Table 18-1. From this, the error in baud rate can be determined. An example calculation  is  shown  in  Example 18-1.  Typical  baud rates  and  error  values  for  the  various  Asynchronous modes are shown in Table 18-2.  It  may  be  advanta-\nWriting a new value to the SPBRGH:SPBRG registers causes the BRG timer to be reset (or cleared).  This ensures the  BRG does not wait for  a  timer  overflow before outputting the new baud rate.",
    "18.1.1 OPERATION IN POWER MANAGED MODES\nThe device clock is used to generate the desired baud rate.  When  one  of  the  power  managed  modes  is entered, the new clock source may be operating at a different frequency. This may require an adjustment to the value in the SPBRG register pair.",
    "18.1.2 SAMPLING\nThe data on the RX pin is sampled three times by a majority detect circuit to determine if a high or a low level is present at the RX pin.",
    "TABLE 18-1: BAUD RATE FORMULAS\n0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[64 (n + 1)]. 0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 1. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 1. 0,",
    "TABLE 18-1: BAUD RATE FORMULAS\nBRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 0. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 1. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]\nLegend: x = Don't care, n = value of SPBRGH:SPBRG register pair",
    "EXAMPLE 18-1: CALCULATING BAUD RATE ERROR\nFor a device with FOSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, 8-bit BRG:\nDesired Baud Rate\n= FOSC/(64 ([SPBRGH:SPBRG] + 1)\nSolving for SPBRGH:SPBRG:\nX\n= ((FOSC/Desired Baud Rate)/64) - 1\n= ((16000000/9600)/64) - 1\n= [25.042] = 25\nCalculated Baud Rate\n= 16000000/(64 (25 + 1))\n= 9615\nError\n= (Calculated Baud Rate - Desired Baud Rate)/Desired Baud Rate\n= (9615 - 9600)/9600 = 0.16%\nTABLE 18-2:\nREGISTERS ASSOCIATED WITH BAUD RATE GENERATOR",
    "PIC18F2585/2680/4585/4680\nTXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Reset Values on page = 48. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Reset Values on page = 48. BAUDCON, Bit 7 = ABDOVF. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE.",
    "PIC18F2585/2680/4585/4680\nBAUDCON, Bit 0 = ABDEN. BAUDCON, Reset Values on page = 48. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Reset Values on page = 48. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud",
    "PIC18F2585/2680/4585/4680\nRate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Reset Values on page = 48\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by the BRG.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 1.221. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 255. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n64. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 , BRG16",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 31. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 15. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K)",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 9615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 15. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 7. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n-. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 4. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 52.083. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -9.58. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 2. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 104.167. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -9.58. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 2. 115.2, SYNC = 0 , BRGH = 0",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 78.125. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -32.18. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 0.3, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 1201.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 12. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 2.4, SYNC",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 8.929. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -6.99. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 6. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.SPBRG value (decimal) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 20.833. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 2. 19.2, SYNC = 0 , BRGH",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -45.75. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.615.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = 21. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 55555. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 1",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.SPBRG value (decimal) = 12. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, 125.000.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, 8.51.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, 1.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 8332. 0.3, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 0.3, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n4165. 0.3, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02. 0.3, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 1.2,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n125.000.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 1.200. 1.2, 8.51.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 1.2, 1.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 2082. 1.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 1.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 1041.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200. 1.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -0.03. 1.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 520. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 415. 2.4, 125.000.SYNC",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 2.402. 2.4, 8.51.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.06. 2.4, 1.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 2.4, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.399. 2.4, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 2.4, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 2.4,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n-.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 2.4, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 259. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, 125.000.SYNC = 0 , BRGH",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, 8.51.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 9.6, 1.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 259. 9.6, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 9.615. 9.6, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 9.6, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, -.SYNC = 0 , BRGH",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, 125.000.SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, 8.51.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 19.2, 1.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 129. 19.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, -.SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 1.73. 19.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, 125.000.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n40.000 MHz.Actual Rate (K) = 58.140. 57.6, 8.51.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.94. 57.6, 1.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 56.818. 57.6, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -1.36. 57.6, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n10.000 MHz.Actual Rate (K) = 56.818. 57.6, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36. 57.6, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 55555. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, 125.000.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n(K) = 113.636. 115.2, 8.51.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -1.36. 115.2, 1.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -1.36. 115.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = 125.000. 115.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 8.51. 115.2, -.SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.04. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 415. 0.3, SYNC = 0 , BRGH = 0 , BRG16",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1.FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K)",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 9.6, SYNC",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n4.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 33332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.00.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 16665. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 8332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 300.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.01. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 6665. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 8332.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 4165. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 2.400.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 4165. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 2082.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.402. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.06. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 1040. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 832. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.606. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.06. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n9.596. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal)",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 259. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 19.193. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -0.03.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 520. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 259. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 19.231.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 103. 57.6,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 57.803. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.35. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 172. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 57.471. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.22. 57.6, SYNC",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 86. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 57142. 57.6, SYNC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 0.79. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 34. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 114.943. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -0.22. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 86. 115.2, SYNC = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 116.279. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.94. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 42. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 117647. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -2.12. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 16",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.01. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 3332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.04. 0.3,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 1665. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.04. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 832. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.04. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 415. 1.2, SYNC = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 1",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n, BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 415. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 207. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 103. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 9.6, SYNC = 0 , BRGH = 1 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 12. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n, BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 58.824. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 2.12. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 16. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 55555. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 8. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 111.111. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 4.000 MHz.% Error = -3.55. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "18.1.3 AUTO-BAUD RATE DETECT\nThe Enhanced USART module supports the automatic detection and calibration of baud rate. This feature is active only in Asynchronous mode and while the WUE bit is clear.\nThe  automatic  baud  rate  measurement  sequence (Figure 18-1) begins whenever a Start bit is received and the ABDEN  bit is set. The calculation is self-averaging.\nIn the Auto-Baud Rate Detect (ABD) mode, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RX signal, the RX signal is timing the BRG. In ABD mode, the internal Baud Rate Generator is used as a counter to time the bit period of the incoming serial byte stream.",
    "18.1.3 AUTO-BAUD RATE DETECT\nOnce the ABDEN bit is set, the state machine will clear the BRG and look for a Start bit. The Auto-Baud Rate Detection  must  receive  a  byte  with  the  value  55h (ASCII 'U', which is also the LIN bus Sync character) in order to calculate the proper bit rate. The measurement is taken over both a low and a high bit time in order to minimize any effects caused by asymmetry of the incoming signal. After a Start bit, the SPBRG begins counting up, using the preselected clock source on the first rising edge of RX. After eight bits on the RX pin or the fifth rising edge, an accumulated value totalling the proper BRG period is left in the SPBRGH:SPBRG register pair. Once the 5th edge is seen (this should correspond to the Stop bit), the ABDEN bit is automatically cleared.",
    "18.1.3 AUTO-BAUD RATE DETECT\nIf a rollover of the BRG occurs (an overflow from FFFFh to 0000h), the event is trapped by the ABDOVF status bit  (BAUDCON<7>).  It  is  set  in  hardware  by  BRG rollovers  and  can  be  set  or  cleared  by  the  user  in software.  ABD  mode  remains  active  after  rollover events and the ABDEN bit remains set (Figure 18-2).\nWhile  calibrating the baud  rate  period, the BRG registers are clocked at 1/8th the preconfigured clock rate. Note that the BRG clock will be configured by the BRG16 and BRGH bits. Independent of the BRG16 bit setting, both the SPBRG and SPBRGH will be used as a 16-bit counter. This allows the user to verify that no carry occurred for 8-bit modes by checking for 00h in the SPBRGH register. Refer to Table 18-4 for counter clock rates to the BRG.",
    "18.1.3 AUTO-BAUD RATE DETECT\nWhile  the  ABD  sequence  takes  place,  the  EUSART state machine is held in Idle. The RCIF interrupt is set once the fifth rising edge on RX is detected. The value in  the  RCREG  needs  to  be  read  to  clear  the  RCIF interrupt. The contents of RCREG should be discarded.\nNote 1: If the WUE bit is set with the ABDEN bit, Auto-Baud Rate Detection will  occur  on the byte following the Break character.\n2: It is up to the user to determine that the incoming character baud rate is within the range of the selected BRG clock source. Some combinations of oscillator frequency  and  EUSART baud rates are not possible due to bit error rates. Overall system timing and communication baud rates  must  be  taken  into  consideration when using the Auto-Baud Rate Detection feature.",
    "TABLE 18-4: BRG COUNTER CLOCK RATES\n0, BRGH = 0. 0, BRG Counter Clock = FOSC/512. 0, BRGH = 1. 0, BRG Counter Clock = FOSC/128. 1, BRGH = 0. 1, BRG Counter Clock = FOSC/128. 1, BRGH = 1. 1, BRG Counter Clock = FOSC/32\nNote: During the ABD sequence, SPBRG and SPBRGH are both used as a 16-bit counter, independent of the BRG16 setting.",
    "18.1.3.1 ABD and EUSART Transmission\nSince the BRG clock is reversed during ABD acquisition,  the  EUSART transmitter cannot be used during ABD. This means that whenever the ABDEN bit is set, TXREG cannot be written to. Users should also ensure that  ABDEN  does  not  become  set  during  a  transmit sequence. Failing to do this may result in unpredictable EUSART operation.",
    "FIGURE 18-2: BRG OVERFLOW SEQUENCE\nStart\nBit 0\nXXXXh\n0000h\n0000h\nFFFFh\nBRG Clock\nABDEN bit\nRX pin\nABDOVF bit\nBRG Value",
    "18.2 EUSART Asynchronous Mode\nThe Asynchronous mode of operation is selected by clearing the SYNC bit (TXSTA<4>). In this mode, the EUSART  uses  standard  Non-Return-to-Zero  (NRZ) format (one Start bit, eight or nine data bits and one Stop bit). The most common data format is 8 bits. An on-chip  dedicated  8-bit/16-bit  Baud  Rate  Generator can be used to derive standard baud rate frequencies from the oscillator.\nThe EUSART transmits and receives the LSb first. The EUSART's  transmitter  and  receiver  are  functionally independent  but  use  the  same  data  format  and  baud rate. The Baud Rate Generator produces a clock, either x16 or x64 of the bit shift rate depending on the BRGH and BRG16 bits (TXSTA<2> and BAUDCON<3>). Parity is not supported by the hardware, but can be implemented in software and stored as the 9th data bit.\nWhen operating in Asynchronous mode, the EUSART module consists of the following important elements:",
    "18.2 EUSART Asynchronous Mode\n\u00b7 Baud Rate Generator\n\u00b7 Sampling Circuit\n\u00b7 Asynchronous Transmitter\n\u00b7 Asynchronous Receiver\n\u00b7 Auto-Wake-up on Sync Break Character\n\u00b7 12-bit Break Character Transmit\n\u00b7 Auto-Baud Rate Detection",
    "18.2.1 EUSART ASYNCHRONOUS TRANSMITTER\nOnce the TXREG register transfers the data to the TSR register (occurs in one T CY), the TXREG register is empty and the TXIF flag bit (PIR1<4>) is set. This interrupt can be enabled or disabled by setting or clearing the interrupt enable bit, TXIE (PIE1<4>). TXIF will be set regardless of the state of TXIE; it cannot be cleared in software. TXIF is also not cleared immediately upon loading TXREG, but becomes valid in the second instruction cycle following the load instruction. Polling TXIF immediately following a load of TXREG will return invalid results.\nWhile TXIF indicates the status of the TXREG register, another bit,  TRMT  (TXSTA<1>), shows the status of the TSR register. TRMT is a read-only bit which is set when the TSR register is empty. No interrupt logic is tied to this bit so the user has to poll this bit in order to determine if the TSR register is empty.",
    "18.2.1 EUSART ASYNCHRONOUS TRANSMITTER\nNote 1: The TSR register is not mapped in data memory so it is not available to the user.\n2: Flag bit TXIF is set when enable bit TXEN is set.\nTo set up an Asynchronous Transmission:\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit TXIE.\nThe  EUSART transmitter  block  diagram  is  shown  in Figure 18-3. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The Shift register obtains its data from the Read/Write Transmit Buffer register, TXREG. The  TXREG register  is  loaded  with  data  in software. The TSR register is not loaded until the Stop bit  has  been  transmitted  from  the  previous  load.  As soon as the Stop bit is transmitted, the TSR is loaded with new data from the TXREG register (if available).",
    "18.2.1 EUSART ASYNCHRONOUS TRANSMITTER\n4. If  9-bit  transmission is desired, set transmit bit TX9. Can be used as address/data bit.\n5. Enable  the  transmission  by  setting  bit  TXEN which will also set bit TXIF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Load data to the TXREG  register (starts transmission).\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "FIGURE 18-5: ASYNCHRONOUS TRANSMISSION (BACK TO BACK)\nTABLE 18-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION",
    "FIGURE 18-5: ASYNCHRONOUS TRANSMISSION (BACK TO BACK)\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE.",
    "FIGURE 18-5: ASYNCHRONOUS TRANSMISSION (BACK TO BACK)\nPIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Reset Values on",
    "FIGURE 18-5: ASYNCHRONOUS TRANSMISSION (BACK TO BACK)\npage = 48. TXREG, Bit 7 = EUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit Register. TXREG, Bit 5 = EUSART Transmit Register. TXREG, Bit 4 = EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register. TXREG, Bit 0 = EUSART Transmit Register. TXREG, Reset Values on page = 48. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Reset Values on page = 48. BAUDCON, Bit 7 = ABDOVF. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 =",
    "FIGURE 18-5: ASYNCHRONOUS TRANSMISSION (BACK TO BACK)\nSCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Reset Values on page = 48. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Reset Values on page = 48. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud",
    "FIGURE 18-5: ASYNCHRONOUS TRANSMISSION (BACK TO BACK)\nRate Generator Register Low Byte. SPBRG, Bit 5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Reset Values on page = 48\nLegend: - = unimplemented locations read as ' 0 '. Shaded cells are not used for asynchronous transmission.\nNote 1: Reserved in PIC18F2X8X devices; always maintain these bits clear.",
    "18.2.2 EUSART ASYNCHRONOUS RECEIVER\nThe receiver  block  diagram  is  shown  in  Figure 18-6. The data is received on the RX pin and drives the data recovery block. The data recovery block is actually a high-speed shifter operating at x16 times the baud rate, whereas the main receive serial shifter operates at the bit rate or at FOSC. This mode would typically be used in RS-232 systems.\nTo set up an Asynchronous Reception:",
    "18.2.2 EUSART ASYNCHRONOUS RECEIVER\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit RCIE.\n4. If 9-bit reception is desired, set bit RX9.\n5. Enable the reception by setting bit CREN.\n6. Flag  bit  RCIF  will  be  set  when  reception  is complete and an interrupt  will  be  generated  if enable bit RCIE was set.\n7. Read the RCSTA register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n8. Read  the  8-bit  received  data  by  reading  the RCREG register.\n9. If any error occurred, clear the error by clearing enable bit CREN.",
    "18.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\nThis mode would typically be used in RS-485 systems. To  set  up  an  Asynchronous  Reception  with  Address Detect Enable:",
    "18.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n2. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n3. If interrupts are required, set the RCEN bit and select the desired priority level with the RCIP bit.\n4. Set the RX9 bit to enable 9-bit reception.\n5. Set the ADDEN bit to enable address detect.\n6. Enable reception by setting the CREN bit.\n7. The  RCIF  bit  will  be  set  when  reception  is complete. The interrupt will be Acknowledged if the RCIE and GIE bits are set.\n8. Read  the  RCSTA  register  to  determine  if  any error occurred during reception, as well as read bit 9 of data (if applicable).\n9. Read RCREG to determine if the device is being addressed.\n10. If any error occurred, clear the CREN bit.",
    "18.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n11. If  the  device  has  been  addressed,  clear  the ADDEN bit  to  allow  all  received  data  into  the receive buffer and interrupt the CPU.\n10. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1,",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nBit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Reset Values on page = 48.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nRCREG, Bit 7 = EUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4 = EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, Reset Values on page = 48. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Reset Values on page = 48. BAUDCON, Bit 7 = ABDOVF. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nBAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Reset Values on page = 48. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Reset Values on page = 48. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Register Low Byte.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nSPBRG, Bit 5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Reset Values on page = 48\nLegend: - = unimplemented locations read as ' 0 '. Shaded cells are not used for asynchronous reception.\nNote 1: Reserved in PIC18F2X8X devices; always maintain these bits clear.",
    "18.2.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nDuring  Sleep  mode,  all  clocks  to  the  EUSART  are suspended. Because of this, the Baud Rate Generator is  inactive  and  a  proper  byte  reception  cannot  be performed. The auto-wake-up feature allows the controller to wake-up due to activity on the RX/DT line while the EUSART is operating in Asynchronous mode.\nThe  auto-wake-up  feature  is  enabled  by  setting  the WUE bit (BAUDCON<1>). Once set, the typical receive sequence  on  RX/DT  is  disabled  and  the  EUSART remains in an Idle state, monitoring for a wake-up event independent  of  the  CPU  mode.  A  wake-up  event consists of a high-to-low transition on the RX/DT line. (This  coincides  with  the  start  of  a  Sync  Break  or  a Wake-up Signal character for the LIN protocol.)",
    "18.2.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nFollowing a wake-up event, the module generates an RCIF  interrupt.  The  interrupt  is  generated  synchronously  to  the  Q  clocks  in  normal  operating  modes (Figure 18-8)  and  asynchronously,  if  the  device  is  in Sleep  mode  (Figure 18-9).  The  interrupt  condition  is cleared by reading the RCREG register.\nThe WUE bit is automatically cleared once a low-to-high transition  is  observed  on  the  RX  line  following  the wake-up event. At this point, the EUSART module is in Idle mode and returns to normal operation. This signals to the user that the Sync Break event is over.",
    "18.2.4.1 Special Considerations Using Auto-Wake-up\nSince  auto-wake-up  functions  by  sensing  rising  edge transitions on RX/DT, information with any state changes  before the Stop bit may  signal a false end-of-character and cause data or framing errors. To work properly, therefore, the initial character in the transmission must be all ' 0 's. This can be 00h (8 bytes) for standard RS-232 devices or 000h (12 bits) for LIN bus.\nOscillator start-up time must  also  be  considered, especially in applications using oscillators with longer start-up  intervals  (i.e.,  XT  or  HS  mode).  The  Sync Break  (or  Wake-up  Signal)  character  must  be  of sufficient length and be followed by a sufficient interval to allow enough time for the selected oscillator to start and provide proper initialization of the EUSART.",
    "18.2.4.2 Special Considerations Using the WUE Bit\nThe timing of WUE and RCIF events may cause some confusion when it comes to determining the validity of received data. As noted, setting the WUE bit places the EUSART in an Idle mode. The wake-up event causes a receive interrupt by setting the RCIF bit. The WUE bit is  cleared  after  this  when  a  rising  edge  is  seen  on RX/DT.  The  interrupt  condition  is  then  cleared  by reading  the  RCREG  register.  Ordinarily,  the  data  in RCREG will be dummy data and should be discarded.\nThe fact that the WUE bit has been cleared (or is still set) and the RCIF flag is set should not be used as an indicator of the integrity of the data in RCREG. Users should  consider  implementing  a  parallel  method  in firmware to verify received data integrity.\nTo assure that no actual data is lost, check the RCIDL bit to verify that a receive operation is not in process. If a receive operation is not occurring, the WUE bit may then be set just prior to entering the Sleep mode.",
    "FIGURE 18-9: AUTO-WAKE-UP BIT (WUE) TIMINGS DURING SLEEP\nNote 1: If the wake-up event requires long oscillator warm-up time, the auto-clear of the WUE bit can occur while the stposc signal is still active. This sequence should not depend on the presence of Q clocks.\n- 2: The EUSART remains in Idle while the WUE bit is set.",
    "18.2.5 BREAK CHARACTER SEQUENCE\nThe Enhanced EUSART module has the capability of sending  the  special  Break  character  sequences  that are required by the LIN bus standard. The Break character transmit consists of a Start bit, followed by twelve ' 0 '  bits  and  a  Stop  bit.  The  frame  Break  character  is sent whenever the SENDB and TXEN bits (TXSTA<3> and  TXSTA<5>)  are  set  while  the  Transmit  Shift register is loaded with data. Note that the value of data written  to  TXREG  will  be  ignored  and  all  ' 0 's  will  be transmitted.\nThe SENDB bit is automatically reset by hardware after the corresponding Stop bit is sent. This allows the user to preload the transmit FIFO with the next transmit byte following the Break  character  (typically, the Sync character in the LIN specification).\nNote that the data value written to the TXREG for the Break character is ignored. The write simply serves the purpose of initiating the proper sequence.\nThe TRMT bit indicates when the transmit operation is active or Idle, just as it does during normal transmission.  See  Figure 18-10  for  the  timing  of  the  Break character sequence.",
    "18.2.5.1 Break and Sync Transmit Sequence\nThe  following  sequence  will  send  a  message  frame header made up of a Break, followed by an Auto-Baud Sync  byte.  This  sequence  is  typical  of  a  LIN  bus master.\n1. Configure the EUSART for the desired mode.\n2. Set  the  TXEN  and  SENDB  bits  to  set  up  the Break character.\n3. Load  the  TXREG  with  a  dummy  character  to initiate transmission (the value is ignored).\n4. Write '55h' to TXREG to load the Sync character into the transmit FIFO buffer.\n5. After the Break has been sent, the SENDB bit is reset  by  hardware.  The  Sync  character  now transmits in the preconfigured mode.\nWhen the TXREG becomes empty, as indicated by the TXIF, the next data byte can be written to TXREG.",
    "18.2.6 RECEIVING A BREAK CHARACTER\nThe  Enhanced  USART module  can  receive  a  Break character in two ways.\nThe first method forces configuration of the baud rate at a frequency of 9/13 the typical speed. This allows for the  Stop  bit  transition  to  be  at  the  correct  sampling location (13 bits for Break versus Start bit and 8 data bits for typical data).\nThe  second  method  uses  the  auto-wake-up  feature described in Section 18.2.4 'Auto-Wake-up on Sync Break  Character' . By  enabling this feature, the EUSART will sample the next two transitions on RX/DT, cause an RCIF interrupt and receive the next data byte followed by another interrupt.\nNote  that  following  a  Break  character,  the  user  will typically  want  to  enable  the  Auto-Baud  Rate  Detect feature. For both methods, the user can set the ABD bit once the TXIF interrupt is observed.",
    "18.3 EUSART Synchronous Master Mode\nThe Synchronous Master mode is entered by setting the CSRC bit (TXSTA<7>). In this mode, the data is transmitted in a half-duplex manner (i.e., transmission and reception do not occur at the same time). When transmitting  data,  the  reception  is  inhibited  and  vice versa.  Synchronous  mode  is  entered  by  setting  bit SYNC  (TXSTA<4>).  In  addition,  enable  bit  SPEN (RCSTA<7>) is set in order to configure the TX and RX pins to CK (clock) and DT (data) lines, respectively.\nThe Master mode indicates that the processor transmits the master clock on the CK line. Clock polarity is selected  with  the  SCKP  bit  (BAUDCON<4>);  setting SCKP sets the Idle state on CK as high, while clearing the bit sets the Idle state as low. This option is provided to support Microwire devices with this module.",
    "18.3.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\nThe  EUSART transmitter  block  diagram  is  shown  in Figure 18-3. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The Shift register obtains its data from the Read/Write Transmit Buffer register, TXREG. The  TXREG register  is  loaded  with  data  in software. The TSR register is not loaded until the last bit  has  been  transmitted  from  the  previous  load.  As soon as the last bit is transmitted, the TSR is loaded with new data from the TXREG (if available).\nOnce the TXREG register transfers the data to the TSR register (occurs in one TCYCLE), the TXREG is empty and the TXIF flag bit (PIR1<4>) is set. The interrupt can be enabled or disabled by setting or clearing the interrupt enable bit, TXIE (PIE1<4>). TXIF is set regardless of the state of enable bit TXIE; it cannot be cleared in software. It will reset only when new data is loaded into the TXREG register.",
    "18.3.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\nWhile flag bit TXIF indicates the status of the TXREG register,  another  bit,  TRMT  (TXSTA<1>),  shows  the status of the TSR register. TRMT is a read-only bit which is set when the TSR is empty. No interrupt logic is tied to this  bit  so  the  user  has  to  poll  this  bit  in  order  to determine if the TSR register is empty. The TSR is not mapped in data memory so it is not available to the user.\nTo set up a Synchronous Master Transmission:",
    "18.3.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRG16 bit,  as  required,  to  achieve  the  desired  baud rate.\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC SPEN and CSRC.\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable the transmission by setting bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREG register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "SYNCHRONOUS TRANSMISSION (THROUGH TXEN)\nTABLE 18-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION",
    "SYNCHRONOUS TRANSMISSION (THROUGH TXEN)\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 =",
    "SYNCHRONOUS TRANSMISSION (THROUGH TXEN)\nSSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Reset Values on page = 48. TXREG, Bit 7 =",
    "SYNCHRONOUS TRANSMISSION (THROUGH TXEN)\nEUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit Register. TXREG, Bit 5 = EUSART Transmit Register. TXREG, Bit 4 = EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register. TXREG, Bit 0 = EUSART Transmit Register. TXREG, Reset Values on page = 48. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Reset Values on page = 48. BAUDCON, Bit 7 = ABDOVF. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 = BRG16.",
    "SYNCHRONOUS TRANSMISSION (THROUGH TXEN)\nBAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Reset Values on page = 48. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Reset Values on page = 48. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 5 = EUSART Baud Rate Generator Register",
    "SYNCHRONOUS TRANSMISSION (THROUGH TXEN)\nLow Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Reset Values on page = 48\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master transmission.\nNote 1: Reserved in PIC18F2X8X devices; always maintain these bits clear.",
    "18.3.2 EUSART SYNCHRONOUS MASTER RECEPTION\nOnce  Synchronous  mode  is  selected,  reception  is enabled by setting either the Single Receive Enable bit, SREN  (RCSTA<5>), or the Continuous Receive Enable bit, CREN (RCSTA<4>). Data is sampled on the RX pin on the falling edge of the clock.\nIf enable bit SREN is set, only a single word is received. If enable bit CREN is set, the reception is continuous until CREN is cleared. If both bits are set, then CREN takes precedence.\nTo set up a Synchronous Master Reception:",
    "18.3.2 EUSART SYNCHRONOUS MASTER RECEPTION\n1. Initialize  the  SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRG16 bit, as required, to achieve the desired baud rate.\n3. Ensure bits CREN and SREN are clear.\n4. If interrupts are desired, set enable bit RCIE.\n5. If 9-bit reception is desired, set bit RX9.\n6. If  a  single reception is required, set bit SREN. For continuous reception, set bit CREN.\n7. Interrupt flag bit RCIF will be set when reception is complete and an interrupt will be generated if the enable bit RCIE was set.\n8. Read the RCSTA register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n9. Read  the  8-bit  received  data  by  reading  the RCREG register.\n10. If any error occurred, clear the error by clearing bit CREN.\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN and CSRC.",
    "18.3.2 EUSART SYNCHRONOUS MASTER RECEPTION\n11. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "FIGURE 18-13: SYNCHRONOUS RECEPTION (MASTER MODE, SREN)\nTABLE 18-8:\nREGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION",
    "PIC18F2585/2680/4585/4680\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1,",
    "PIC18F2585/2680/4585/4680\nBit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Reset Values on page = 48.",
    "PIC18F2585/2680/4585/4680\nRCREG, Bit 7 = EUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4 = EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, Reset Values on page = 48. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Reset Values on page = 48. BAUDCON, Bit 7 = ABDOVF. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP.",
    "PIC18F2585/2680/4585/4680\nBAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Reset Values on page = 48. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Reset Values on page = 48. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Register Low Byte.",
    "PIC18F2585/2680/4585/4680\nSPBRG, Bit 5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Reset Values on page = 48\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master reception.\nNote 1:\nReserved in PIC18F2X8X devices; always maintain these bits clear.",
    "18.4 EUSART Synchronous Slave Mode\nSynchronous  Slave  mode  is  entered  by  clearing  bit, CSRC  (TXSTA<7>).  This mode  differs from the Synchronous Master mode in that the shift clock is supplied externally at the CK pin (instead of being supplied internally  in  Master  mode).  This  allows  the  device  to transfer or receive data while in any low-power mode.",
    "18.4.1 EUSART SYNCHRONOUS SLAVE TRANSMIT\nThe operation of the Synchronous Master and Slave modes are identical, except in the case of the Sleep mode.\nIf  two  words  are  written  to  the  TXREG  and  then  the SLEEP instruction is executed, the following will occur:\na) The  first  word  will  immediately  transfer  to  the TSR register and transmit.\nb) The  second  word  will  remain  in  the  TXREG register.\nc) Flag bit TXIF will not be set.\nd) When the first word has been shifted out of TSR, the  TXREG  register  will  transfer  the  second word to the TSR and flag bit TXIF will now be set.\ne) If enable bit TXIE is set, the interrupt will wake the chip from Sleep. If the global interrupt is enabled, the program will branch to the interrupt vector.\nTABLE 18-9:\nREGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION",
    "18.4.1 EUSART SYNCHRONOUS SLAVE TRANSMIT\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1,",
    "18.4.1 EUSART SYNCHRONOUS SLAVE TRANSMIT\nBit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Reset Values on page = 48.",
    "18.4.1 EUSART SYNCHRONOUS SLAVE TRANSMIT\nTXREG, Bit 7 = EUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit Register. TXREG, Bit 5 = EUSART Transmit Register. TXREG, Bit 4 = EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register. TXREG, Bit 0 = EUSART Transmit Register. TXREG, Reset Values on page = 48. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Reset Values on page = 48. BAUDCON, Bit 7 = ABDOVF. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP.",
    "18.4.1 EUSART SYNCHRONOUS SLAVE TRANSMIT\nBAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Reset Values on page = 48. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Reset Values on page = 48. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Register Low Byte.",
    "18.4.1 EUSART SYNCHRONOUS SLAVE TRANSMIT\nSPBRG, Bit 5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Reset Values on page = 48\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave transmission.\nNote 1: Reserved in PIC18F2X8X devices; always maintain these bits clear.\nTo set up a Synchronous Slave Transmission:",
    "18.4.1 EUSART SYNCHRONOUS SLAVE TRANSMIT\n1. Enable  the  synchronous  slave  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. Clear bits CREN and SREN.\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable  the  transmission  by  setting  enable  bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREGx register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "18.4.2 EUSART SYNCHRONOUS SLAVE RECEPTION\nThe operation of the Synchronous Master and Slave modes is identical, except in the case of Sleep or any Idle  mode  and  bit  SREN,  which  is  a  'don't  care'  in Slave mode.\nIf  receive is enabled by setting the CREN bit prior to entering Sleep or any Idle mode, then a word may be received while in this low-power mode. Once the word is received, the RSR register will transfer the data to the RCREG register; if the RCIE enable bit is set, the interrupt generated will wake the chip from the low-power mode. If the global interrupt is enabled, the program will branch to the interrupt vector.\nTo set up a Synchronous Slave Reception:",
    "18.4.2 EUSART SYNCHRONOUS SLAVE RECEPTION\n1. Enable  the  synchronous  master  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. If interrupts are desired, set enable bit RCIE.\n3. If 9-bit reception is desired, set bit RX9.\n4. To enable reception, set enable bit CREN.\n5. Flag  bit  RCIF  will  be  set  when  reception  is complete.  An  interrupt  will be  generated  if enable bit RCIE was set.\n6. Read the RCSTA register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n7. Read  the  8-bit  received  data  by  reading  the RCREG register.\n8. If any error occurred, clear the error by clearing bit CREN.\n9. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1,",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nBit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Reset Values on page = 48.",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nRCREG, Bit 7 = EUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4 = EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, Reset Values on page = 48. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Reset Values on page = 48. BAUDCON, Bit 7 = ABDOVF. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP.",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nBAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Reset Values on page = 48. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Reset Values on page = 48. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Register Low Byte.",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nSPBRG, Bit 5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Reset Values on page = 48\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave reception.\nNote 1: Reserved in PIC18F2X8X devices; always maintain these bits clear.",
    "19.0 10-BIT ANALOG-TO-DIGITAL CONVERTER (A/D) MODULE\nThe module has five registers:\n- \u00b7 A/D Result High Register (ADRESH)\nThe  Analog-to-Digital  (A/D)  converter  module  has 8 inputs  for  the  PIC18F2X8X  devices  and  11  for  the PIC18F4X8X devices. This module allows conversion of  an  analog  input  signal  to  a  corresponding  10-bit digital number.\n\u00b7 A/D Result Low Register (ADRESL)\n\u00b7 A/D Control Register 0 (ADCON0)\n\u00b7 A/D Control Register 1 (ADCON1)\n\u00b7 A/D Control Register 2 (ADCON2)\nThe ADCON0 register, shown in Register 19-1, controls the operation of the A/D module. The ADCON1 register, shown in Register 19-2, configures the functions of the port pins. The ADCON2 register, shown in Register 19-3, configures the A/D clock source, programmed acquisition time and justification.",
    "REGISTER 19-1: ADCON0: A/D CONTROL REGISTER 0\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = CHS3. -, 3 = CHS2. -, 4 = CHS1. -, 5 = CHS0. -, 6 = GO/DONE. -, 7 = ADON\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-2 CHS3:CHS0: Analog Channel Select bits\n0000 = Channel 0 (AN0)\n0001 = Channel 1 (AN1)\n0010 = Channel 2 (AN2)\n0011 = Channel 3 (AN3)\n0100 = Channel 4 (AN4)\n0101 = Channel 5 (AN5) (1,2)",
    "REGISTER 19-1: ADCON0: A/D CONTROL REGISTER 0\n0110 = Channel 6 (AN6) (1,2)\n0111 = Channel 7 (AN7) (1,2)\n1000 = Channel 8 (AN8)\n1001 = Channel 9 (AN9)\n1010 = Channel 10 (AN10)\n1011 = Unused\n1100 = Unused\n1101 = Unused\n1110 = Unused\n1111 = Unused\nNote 1: These channels are not implemented on PIC18F2X8X devices.\n2: Performing a conversion on unimplemented channels will return full-scale measurements.\nbit 1\nGO/DONE:\nA/D Conversion Status bit\nWhen ADON = 1 :\n1 = A/D conversion in progress\n0 = A/D Idle",
    "bit 0 ADON: A/D On bit\n1 = A/D converter module is enabled\n0 = A/D converter module is disabled",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "ADCON1: A/D CONTROL REGISTER 1\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0 (1). U-0, 5 = R/W-q (1). U-0, 6 = R/W-q (1). U-0, 7 = R/W-q (1). -, 1 = -. -, 2 = VCFG1. -, 3 = VCFG0. -, 4 = PCFG3. -, 5 = PCFG2. -, 6 = PCFG1. -, 7 = PCFG0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5\nVCFG1: Voltage Reference Configuration bit (VREF- source)\n1 = VREF- (AN2)\n0 = AVSS\nbit 4\nVCFG0: Voltage Reference Configuration bit (VREF+ source)\n1 = VREF+ (AN3)\n0 = AVDD\nbit 3-0",
    "ADCON1: A/D CONTROL REGISTER 1\nPCFG3:PCFG0: A/D Port Configuration Control bits",
    "ADCON1: A/D CONTROL REGISTER 1\n0000 (1), AN10 = A. 0000 (1), AN9 = A. 0000 (1), AN8 = A. 0000 (1), AN7 (2) = A. 0000 (1), AN6 (2) = A. 0000 (1), AN5 (2) = A. 0000 (1), AN4 = A. 0000 (1), AN3 = A. 0000 (1), AN2 = A. 0000 (1), AN1 = A. 0000 (1), AN0 = A. 0001, AN10 = A. 0001, AN9 = A. 0001, AN8 = A. 0001, AN7 (2) = A. 0001, AN6 (2) = A. 0001, AN5 (2) = A. 0001, AN4 = A. 0001, AN3 = A. 0001, AN2 = A. 0001, AN1 = A. 0001, AN0 = A. 0010, AN10 = A. 0010, AN9 = A. 0010,",
    "ADCON1: A/D CONTROL REGISTER 1\nAN8 = A. 0010, AN7 (2) = A. 0010, AN6 (2) = A. 0010, AN5 (2) = A. 0010, AN4 = A. 0010, AN3 = A. 0010, AN2 = A. 0010, AN1 = A. 0010, AN0 = A. 0011, AN10 = A. 0011, AN9 = A. 0011, AN8 = A. 0011, AN7 (2) = A. 0011, AN6 (2) = A. 0011, AN5 (2) = A. 0011, AN4 = A. 0011, AN3 = A. 0011, AN2 = A. 0011, AN1 = A. 0011, AN0 = A. 0100, AN10 = A. 0100, AN9 = A. 0100, AN8 = A. 0100, AN7 (2) = A. 0100, AN6 (2) = A. 0100, AN5 (2) = A. 0100, AN4 = A. 0100, AN3 =",
    "ADCON1: A/D CONTROL REGISTER 1\nA. 0100, AN2 = A. 0100, AN1 = A. 0100, AN0 = A. 0101, AN10 = D. 0101, AN9 = A. 0101, AN8 = A. 0101, AN7 (2) = A. 0101, AN6 (2) = A. 0101, AN5 (2) = A. 0101, AN4 = A. 0101, AN3 = A. 0101, AN2 = A. 0101, AN1 = A. 0101, AN0 = A. 0110, AN10 = D. 0110, AN9 = D. 0110, AN8 = A. 0110, AN7 (2) = A. 0110, AN6 (2) = A. 0110, AN5 (2) = A. 0110, AN4 = A. 0110, AN3 = A. 0110, AN2 = A. 0110, AN1 = A. 0110, AN0 = A. 0111 (1), AN10 = D. 0111 (1), AN9 = D. 0111",
    "ADCON1: A/D CONTROL REGISTER 1\n(1), AN8 = D. 0111 (1), AN7 (2) = A. 0111 (1), AN6 (2) = A. 0111 (1), AN5 (2) = A. 0111 (1), AN4 = A. 0111 (1), AN3 = A. 0111 (1), AN2 = A. 0111 (1), AN1 = A. 0111 (1), AN0 = A. 1000, AN10 = D. 1000, AN9 = D. 1000, AN8 = D. 1000, AN7 (2) = D. 1000, AN6 (2) = A. 1000, AN5 (2) = A. 1000, AN4 = A. 1000, AN3 = A. 1000, AN2 = A. 1000, AN1 = A. 1000, AN0 = A. 1001, AN10 = D. 1001, AN9 = D. 1001, AN8 = D. 1001, AN7 (2) = D. 1001, AN6 (2) = D. 1001, AN5 (2)",
    "ADCON1: A/D CONTROL REGISTER 1\n= A. 1001, AN4 = A. 1001, AN3 = A. 1001, AN2 = A. 1001, AN1 = A. 1001, AN0 = A. 1010, AN10 = D. 1010, AN9 = D. 1010, AN8 = D. 1010, AN7 (2) = D. 1010, AN6 (2) = D. 1010, AN5 (2) = D. 1010, AN4 = A. 1010, AN3 = A. 1010, AN2 = A. 1010, AN1 = A. 1010, AN0 = A. 1011, AN10 = D. 1011, AN9 = D. 1011, AN8 = D. 1011, AN7 (2) = D. 1011, AN6 (2) = D. 1011, AN5 (2) = D. 1011, AN4 = D. 1011, AN3 = A. 1011, AN2 = A. 1011, AN1 = A. 1011, AN0 = A. 1100, AN10 = D. 1100,",
    "ADCON1: A/D CONTROL REGISTER 1\nAN9 = D. 1100, AN8 = D. 1100, AN7 (2) = D. 1100, AN6 (2) = D. 1100, AN5 (2) = D. 1100, AN4 = D. 1100, AN3 = D. 1100, AN2 = A. 1100, AN1 = A. 1100, AN0 = A. 1101, AN10 = D. 1101, AN9 = D. 1101, AN8 = D. 1101, AN7 (2) = D. 1101, AN6 (2) = D. 1101, AN5 (2) = D. 1101, AN4 = D. 1101, AN3 = D. 1101, AN2 = D. 1101, AN1 = A. 1101, AN0 = A. 1110, AN10 = D. 1110, AN9 = D. 1110, AN8 = D. 1110, AN7 (2) = D. 1110, AN6 (2) = D. 1110, AN5 (2) = D. 1110, AN4 = D. 1110, AN3 =",
    "ADCON1: A/D CONTROL REGISTER 1\nD. 1110, AN2 = D. 1110, AN1 = D. 1110, AN0 = A. 1111, AN10 = D. 1111, AN9 = D. 1111, AN8 = D. 1111, AN7 (2) = D. 1111, AN6 (2) = D. 1111, AN5 (2) = D. 1111, AN4 = D. 1111, AN3 = D. 1111, AN2 = D. 1111, AN1 = D. 1111, AN0 = D\nA = Analog input            D = Digital I/O\nNote 1: The POR value of the PCFG bits depends on the value of the PBADEN bit in Configuration Register 3H. When PBADEN = 1 , PCFG<3:0> = 0000 ; when PBADEN = 0 , PCFG<3:0> = 0111 .\n- 2: AN5 through AN7 are available only in PIC18F4X8X devices.",
    "ADCON1: A/D CONTROL REGISTER 1\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "ADCON2: A/D CONTROL REGISTER 2\nR/W-0, 1 = U-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. ADFM, 1 = -. ADFM, 2 = ACQT2. ADFM, 3 = ACQT1. ADFM, 4 = ACQT0. ADFM, 5 = ADCS2. ADFM, 6 = ADCS1. ADFM, 7 = ADCS0\nbit 7\nbit 0",
    "bit 7\nADFM: A/D Result Format Select bit\n1 = Right justified\n0 = Left justified\nbit 6 Unimplemented: Read as ' 0 '\nbit 5-3\nACQT2:ACQT0: A/D Acquisition Time Select bits\n111 = 20 TAD\n110 = 16 TAD\n101 = 12 TAD\n100 = 8 TAD\n011 = 6 TAD\n010 = 4 TAD\n001 = 2 TAD\n000 = 0 TAD (1)\nbit 2-0 ADCS2:ADCS0: A/D Conversion Clock Select bits\n111 = FRC (clock derived from A/D RC oscillator) (1)\n110 = FOSC/64\n101 = FOSC/16\n100 = FOSC/4\n011 = FRC (clock derived from A/D RC oscillator) (1)\n010 = FOSC/32\n001 = FOSC/8\n000 = FOSC/2\nNote 1: If the A/D FRC clock source is selected, a delay of one TCY (instruction cycle) is added before the A/D clock starts. This allows the SLEEP instruction to be executed before starting a conversion.",
    "bit 7\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "PIC18F2585/2680/4585/4680\nThe analog reference voltage is software selectable to either the device's positive and negative supply voltage (AVDD and AVSS), or the voltage level on the RA3/AN3/VREF+ and RA2/AN2/VREF-/CVREF pins.\nA device Reset forces all registers to their Reset state. This forces the A/D module to be turned off and any conversion in progress is aborted.\nThe A/D converter has a unique feature of being able to  operate  while  the  device  is  in  Sleep  mode.  To operate  in  Sleep,  the  A/D  conversion  clock  must  be derived from the A/D's internal RC oscillator.\nThe output of the sample and hold is the input into the converter,  which  generates  the  result  via  successive approximation.",
    "PIC18F2585/2680/4585/4680\nEach port pin associated with the A/D converter can be configured as an analog input, or as a digital I/O. The ADRESH and ADRESL registers contain the result of the A/D conversion. When the A/D conversion is complete, the result is loaded into the ADRESH/ADRESL registers,  the  GO/DONE  bit  (ADCON0  register)  is cleared  and  A/D  Interrupt  Flag  bit  ADIF  is  set.  The block diagram of the A/D module is shown in Figure 19-1.",
    "FIGURE 19-1: A/D BLOCK DIAGRAM\nNote 1: Channels AN5 through AN7 are not available on PIC18F2X8X devices.\n2: I/O pins have diode protection to VDD and VSS.",
    "PIC18F2585/2680/4585/4680\nThe  value  in  the  ADRESH/ADRESL  registers  is  not modified for a Power-on Reset. The ADRESH/ADRESL registers  will  contain  unknown  data  after  a  Power-on Reset.\nAfter the A/D module has been configured as desired, the selected channel must be acquired before the conversion  is  started.  The  analog  input  channels  must have  their  corresponding  TRIS  bits  selected  as  an input. To determine acquisition time, see Section 19.1 'A/D Acquisition Requirements' .  After this acquisition  time  has  elapsed,  the  A/D  conversion  can  be started.  An  acquisition  time  can  be  programmed  to occur between setting the GO/DONE bit and the actual start of the conversion.\nThe following steps should be followed to perform an A/D conversion:\n1. Configure the A/D module:\n\u00b7 Configure analog pins, voltage reference and digital I/O (ADCON1)\n\u00b7 Select A/D input channel (ADCON0)\n\u00b7 Select A/D acquisition time (ADCON2)\n\u00b7 Select A/D conversion clock (ADCON2)\n\u00b7 Turn on A/D module (ADCON0)",
    "FIGURE 19-2: ANALOG INPUT MODEL\n2. Configure A/D interrupt (if desired):\n\u00b7 Clear ADIF bit\n\u00b7 Set ADIE bit\n\u00b7 Set GIE bit\n3. Wait the required acquisition time (if required).\n4. Start conversion:\n\u00b7 Set GO/DONE bit (ADCON0 register)\n5. Wait for A/D conversion to complete, by either: \u00b7 Polling for the GO/DONE bit to be cleared OR\n\u00b7 Waiting for the A/D interrupt\n6. Read A/D Result registers (ADRESH:ADRESL); clear bit ADIF, if required.\n7. For next conversion, go to step 1 or step 2, as required.  The  A/D  conversion  time  per  bit  is defined  as  TAD.  A  minimum  wait  of  2  TAD  is required before next acquisition starts.",
    "19.1 A/D Acquisition Requirements\nFor the A/D converter to meet its specified accuracy, the charge holding capacitor (CHOLD) must be allowed to fully charge to the input channel voltage level. The analog  input  model  is  shown  in  Figure 19-2.  The source  impedance  (RS)  and  the  internal  sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (VDD). The source impedance affects the offset voltage at the analog input (due to pin leakage current). The maximum  recommended  impedance  for  analog sources is 2.5 k \uf057 .  After  the  analog input channel is selected (changed), the channel must be sampled for at least the minimum acquisition time before starting a conversion.\nNote:\nWhen  the conversion is started, the holding capacitor is disconnected from the input pin.\nEQUATION 19-1:",
    "ACQUISITION TIME\nTACQ, 1 = =. TACQ, 2 = Amplifier Settling Time + Holding Capacitor Charging Time + Temperature Coefficient. , 1 = =. , 2 = TAMP + TC + TCOFF",
    "EQUATION 19-2: A/D MINIMUM CHARGING TIME\nVHOLD  = (VREF - (VREF/2048)) \u2022 (1 - e (-Tc/CHOLD(RIC + RSS + RS)) )\nor\nTC = -(CHOLD)(RIC + RSS + RS) ln(1/2048)",
    "EQUATION 19-3: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\nTACQ = TAMP + TC + TCOFF\nTAMP = 5 \uf06d s\nTCOFF = (Temp - 25 C)(0.05 \uf0b0 \uf06d s/ \uf0b0 C)\n(50 C - 25 C)(0.05 \uf0b0 \uf0b0 \uf06d s/ \uf0b0 C)\n1.25 \uf06d s\nTemperature coefficient is only required for temperatures > 25 C. Below 25 C, TCOFF = 0 ms. \uf0b0 \uf0b0\nTC = -(CHOLD)(RIC + RSS + RS) ln(1/2047) \uf06d s -(120 pF) (1 k \uf057 + 7 k \uf057 + 2.5 k \uf057 ) ln(0.0004883) \uf06d s 9.61 \uf06d s\nTACQ =\n5\n\uf06d\ns + 1.25\n\uf06d\ns + 9.61\n\uf06d\ns\n12.86 \uf06d s\nTo calculate the minimum acquisition time, Equation 19-1  may  be  used.  This  equation  assumes that 1/2 LSb error is used (1024 steps for the A/D). The 1/2 LSb error is the maximum error allowed for the A/D to meet its specified resolution.\nExample 19-3 shows the calculation  of  the  minimum required  acquisition  time  TACQ.  This  calculation  is based on the following application system assumptions:\nCHOLD",
    "EQUATION 19-3: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\n= 120 pF\nRs\n= 2.5 k \uf057\uf020\nConversion Error\n\uf0a3 1/2 LSb\nVDD\n= 5V \uf0ae Rss = 7 k \uf057\nTemperature\n= 50 C (system max.) \uf0b0\nVHOLD\n= 0V @ time = 0",
    "19.2 Selecting and Configuring Automatic Acquisition Time\nThe  ADCON2  register  allows  the  user  to  select  an acquisition time that occurs each time the GO/DONE bit is set.\nWhen the GO/DONE bit is set, sampling is stopped and a conversion begins. The user is responsible for ensuring the required acquisition time has passed between selecting  the  desired  input  channel  and  setting  the GO/DONE bit. This occurs when the ACQT2:ACQT0 bits (ADCON2<5:3>) remain in their Reset state (' 000 ') and  is  compatible  with  devices  that  do  not  offer programmable acquisition times.\nIf desired,  the  ACQT  bits  can  be  set  to  select  a programmable  acquisition  time  for  the  A/D  module. When  the  GO/DONE  bit  is  set,  the  A/D  module continues to sample the input for the selected acquisition time, then automatically begins a conversion. Since the acquisition time is programmed, there may be no need to wait for an acquisition time between selecting a channel and setting the GO/DONE bit.",
    "19.3 Selecting the A/D Conversion Clock\nThe A/D conversion time per bit is defined as TAD. The A/D conversion requires 11 TAD per 10-bit conversion. The  source  of  the  A/D  conversion  clock  is  software selectable. There are seven possible options for TAD:\n\u00b7 2 TOSC\n\u00b7 4 TOSC\n\u00b7 8 TOSC\n\u00b7 16 TOSC\n\u00b7 32 TOSC\n\u00b7 64 TOSC\n\u00b7 Internal RC Oscillator\nFor correct A/D conversions, the A/D conversion clock (TAD) must be as short as possible, but greater than the minimum TAD (approximately 2 \uf06d s, see parameter 130 for more information).\nTable 19-1 shows the resultant TAD times derived from the  device  operating  frequencies  and  the  A/D  clock source selected.\nIn either case, when the conversion is completed, the GO/DONE bit is cleared, the ADIF flag is set and the A/D  begins  sampling  the  currently  selected  channel again.  If  an  acquisition  time  is  programmed,  there  is nothing to indicate if the acquisition time has ended or if the conversion has begun.",
    "TABLE 19-1: TAD vs. DEVICE OPERATING FREQUENCIES\n2 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 000. 2 T OSC, Maximum Device Frequency.PIC18FX585/X680 = 2.86 MHz. 2 T OSC, Maximum Device Frequency.PIC18LFX585/X680 (4) = 1.43 kHz. 4 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 100. 4 T OSC, Maximum Device Frequency.PIC18FX585/X680 = 5.71 MHz. 4 T OSC, Maximum Device Frequency.PIC18LFX585/X680 (4) = 2.86 MHz. 8 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 001. 8 T OSC, Maximum Device Frequency.PIC18FX585/X680 = 11.43 MHz. 8 T OSC, Maximum Device Frequency.PIC18LFX585/X680 (4) = 5.72 MHz. 16 T OSC, AD Clock Source (T",
    "TABLE 19-1: TAD vs. DEVICE OPERATING FREQUENCIES\nAD).ADCS2:ADCS0 = 101. 16 T OSC, Maximum Device Frequency.PIC18FX585/X680 = 22.86 MHz. 16 T OSC, Maximum Device Frequency.PIC18LFX585/X680 (4) = 11.43 MHz. 32 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 010. 32 T OSC, Maximum Device Frequency.PIC18FX585/X680 = 40.0 MHz. 32 T OSC, Maximum Device Frequency.PIC18LFX585/X680 (4) = 22.86 MHz. 64 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 110. 64 T OSC, Maximum Device Frequency.PIC18FX585/X680 = 40.0 MHz. 64 T OSC, Maximum Device Frequency.PIC18LFX585/X680 (4) = 22.86 MHz. RC (3), AD Clock Source (T AD).ADCS2:ADCS0 = x11. RC",
    "TABLE 19-1: TAD vs. DEVICE OPERATING FREQUENCIES\n(3), Maximum Device Frequency.PIC18FX585/X680 = 1.00 MHz (1). RC (3), Maximum Device Frequency.PIC18LFX585/X680 (4) = 1.00 MHz (2)\nNote\n1: The RC source has a typical TAD time of 4 ms.\n2: The RC source has a typical TAD time of 6 ms.\n3: For device frequencies above 1 MHz, the device must be in Sleep for the entire conversion or the A/D accuracy may be out of specification.\n4: Low-power (PIC18LFXXXX) devices only.",
    "19.4 Operation in Power Managed Modes\nThe selection of the automatic acquisition time and A/D conversion  clock  is  determined  in  part,  by  the  clock source and frequency while in a power managed mode.\nIf the A/D is expected to operate while the device is in a  power  managed  mode,  the  ACQT2:ACQT0  and ADCS2:ADCS0 bits in ADCON2 should be updated in accordance with the clock source to  be used in that mode. After entering the mode, an A/D acquisition or conversion may be started. Once started, the device should  continue  to  be  clocked  by  the  same  clock source until the conversion has been completed.\nIf desired, the device may be placed into the corresponding Idle mode during the conversion. If the device clock frequency is less than 1 MHz, the A/D RC clock source should be selected.",
    "19.4 Operation in Power Managed Modes\nOperation  in  the  Sleep  mode  requires  the  A/D  FRC clock to be selected. If bits ACQT2:ACQT0 are set to ' 000 ' and a conversion is started, the conversion will be delayed one instruction cycle to allow execution of the SLEEP instruction and entry to Sleep mode. The IDLEN bit  (OSCCON<7>)  must  have  already  been  cleared prior to starting the conversion.",
    "19.5 Configuring Analog Port Pins\nThe ADCON1, TRISA, TRISB and TRISE registers all configure the A/D port pins. The port pins needed as analog inputs must have their corresponding TRIS bits set (input). If the TRIS bit is cleared (output), the digital output level (VOH or VOL) will be converted.\nThe A/D operation is independent of the state of the CHS3:CHS0 bits and the TRIS bits.\nNote 1: When reading the Port register,  all  pins configured as analog input channels will read as cleared (a low level). Pins configured  as  digital  inputs  will convert  an analog input. Analog levels on a digitally configured input will be accurately converted.\n2: Analog  levels  on  any  pin  defined  as  a digital  input  may  cause  the  digital  input buffer  to  consume  current  out  of  the device's specification limits.\n3: The PBADEN bit in Configuration Register 3H  configures  PORTB  pins  to reset  as  analog  or  digital  pins  by  controlling how the PCFG0 bits in ADCON1 are reset.",
    "19.6 A/D Conversions\nFigure 19-3 shows the operation of the A/D converter after the GO bit has been set and the ACQT2:ACQT0 bits are cleared. A conversion is started after the following instruction to allow entry into Sleep mode before the conversion begins.\nFigure 19-4 shows the operation of the A/D converter after the GO bit has been set and the ACQT2:ACQT0 bits are set to ' 010 ' and selecting a 4 TAD acquisition time before the conversion starts.\nClearing  the  GO/DONE  bit  during  a  conversion  will abort the current conversion. The A/D Result register pair will NOT be updated with the partially completed A/D conversion sample. This means the ADRESH:ADRESL  registers  will  continue  to  contain the value of the last completed conversion (or the last value written to the ADRESH:ADRESL registers).\nAfter  the  A/D  conversion  is  completed  or  aborted,  a 2 TAD wait is required before the next acquisition can be started. After this wait, acquisition on the selected channel is automatically started.\nNote:\nThe GO/DONE bit should NOT be set in the same instruction that turns on the A/D.",
    "19.6 A/D Conversions\nFIGURE 19-3: A/D CONVERSION TAD CYCLES (ACQT<2:0> = 000 , TACQ = 0 )\nFIGURE 19-4: A/D CONVERSION TAD CYCLES   (ACQT<2:0> = 010 , TACQ = 4 TAD)",
    "19.7 Use of the CCP1 Trigger\nAn A/D conversion can be started by the 'special event trigger' of the ECCP1 module. This requires that the ECCP1M3:ECCP1M0 bits (ECCP1CON<3:0>) be programmed  as  ' 1011 '  and  that  the  A/D  module  is enabled (ADON bit is set). When the trigger occurs, the GO/DONE bit will be set, starting the A/D acquisition and conversion and the Timer1 (or Timer3) counter will be reset to zero. Timer1 (or Timer3) is reset to automatically  repeat  the  A/D  acquisition  period  with  minimal software overhead (moving ADRESH/ADRESL to the desired location). The appropriate analog input channel must be selected and the minimum acquisition period  is  either  timed  by  the  user,  or  an  appropriate TACQ time selected before the 'special event trigger' sets the GO/DONE bit (starts a conversion).\nIf the A/D module is not enabled (ADON is cleared), the 'special  event  trigger'  will  be  ignored  by  the  A/D module,  but  will  still  reset  the  Timer1  (or  Timer3) counter.",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 46. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on page = 49. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF.",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nPIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on page = 49. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on page = 49. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP (5). IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH A/D OPERATION\n(5). IPR2, Reset Values on page = 48. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF (5). PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (5). PIR2, Reset Values on page = 48. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE (5). PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (5). PIE2, Reset Values on page = 49. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nByte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Reset Values on page = 47. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Reset Values on page = 47. ADCON0, Bit 7 = -. ADCON0, Bit 6 =",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH A/D OPERATION\n-. ADCON0, Bit 5 = CHS3. ADCON0, Bit 4 = CHS2. ADCON0, Bit 3 = CHS1. ADCON0, Bit 2 = CHS0. ADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Reset Values on page = 47. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Reset Values on page = 47. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = -. ADCON2, Bit 5 = ACQT2. ADCON2, Bit 4 = ACQT1. ADCON2, Bit 3 = ACQT0. ADCON2, Bit 2 =",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Reset Values on page = 47. PORTA, Bit 7 = RA7 (2). PORTA, Bit 6 = RA6 (2). PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Reset Values on page = 49. TRISA, Bit 7 = TRISA7 (2) TRISA6 (2) PORTA Data Direction Register. TRISA, Bit 6 = TRISA7 (2) TRISA6 (2) PORTA Data Direction Register. TRISA, Bit 5 = TRISA7 (2) TRISA6 (2) PORTA Data Direction Register. TRISA, Bit 4 = TRISA7 (2) TRISA6 (2) PORTA Data Direction Register. TRISA, Bit 3 = TRISA7 (2) TRISA6 (2) PORTA Data Direction",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nRegister. TRISA, Bit 2 = TRISA7 (2) TRISA6 (2) PORTA Data Direction Register. TRISA, Bit 1 = TRISA7 (2) TRISA6 (2) PORTA Data Direction Register. TRISA, Bit 0 = TRISA7 (2) TRISA6 (2) PORTA Data Direction Register. TRISA, Reset Values on page = 49. PORTB, Bit 7 = Read PORTB pins, Write LATB Latch. PORTB, Bit 6 = Read PORTB pins, Write LATB Latch. PORTB, Bit 5 = Read PORTB pins, Write LATB Latch. PORTB, Bit 4 = Read PORTB pins, Write LATB Latch. PORTB, Bit 3 = Read PORTB pins, Write LATB Latch. PORTB, Bit 2 = Read PORTB pins, Write LATB Latch. PORTB, Bit 1 = Read PORTB pins, Write LATB Latch. PORTB, Bit 0 = Read PORTB pins, Write LATB Latch. PORTB, Reset Values on page = 49. TRISB, Bit 7 = PORTB Data Direction Register.",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nTRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Reset Values on page = 49. LATB, Bit 7 = PORTB Output Data Latch. LATB, Bit 6 = PORTB Output Data Latch. LATB, Bit 5 = PORTB Output Data Latch. LATB, Bit 4 = PORTB Output Data Latch. LATB, Bit 3 = PORTB Output Data Latch. LATB, Bit 2 = PORTB Output Data Latch. LATB, Bit 1 = PORTB Output Data Latch. LATB, Bit 0 = PORTB Output Data Latch. LATB, Reset Values on page = 49. PORTE (4), Bit 7 = -. PORTE (4), Bit 6 = -. PORTE (4), Bit 5 = -. PORTE (4),",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nBit 4 = -. PORTE (4), Bit 3 = RE3 (3). PORTE (4), Bit 2 = Read PORTE pins, Write LATE (1). PORTE (4), Bit 1 = Read PORTE pins, Write LATE (1). PORTE (4), Bit 0 = Read PORTE pins, Write LATE (1). PORTE (4), Reset Values on page = 49. TRISE (4), Bit 7 = IBF. TRISE (4), Bit 6 = OBF. TRISE (4), Bit 5 = IBOV. TRISE (4), Bit 4 = PSPMODE. TRISE (4), Bit 3 = -. TRISE (4), Bit 2 = PORTE Data Direction. TRISE (4), Bit 1 = PORTE Data Direction. TRISE (4), Bit 0 = PORTE Data Direction. TRISE (4), Reset Values on page = 49. LATE (4), Bit 7 = -. LATE (4), Bit 6 = -. LATE (4), Bit 5 = -. LATE (4), Bit 4 = -. LATE (4), Bit 3",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH A/D OPERATION\n= -. LATE (4), Bit 2 = LATE2. LATE (4), Bit 1 = LATE1. LATE (4), Bit 0 = LATE0. LATE (4), Reset Values on page = 49\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used for A/D conversion.\nNote 1:\nThese bits are unimplemented on PIC18F2X8X devices; always maintain these bits clear.\n2: These pins may be configured as port pins depending on the oscillator mode selected.\n3: RE3 port bit is available only as an input pin when the MCLRE Configuration bit is ' 0 '.\n4: These registers are not implemented on PIC18F2X8X devices.\n5: These bits are available on PIC18F4X8X and reserved on PIC18F2X8X devices.",
    "20.0 COMPARATOR MODULE\nThe analog comparator module contains two comparators  that  can  be  configured  in  a  variety  of  ways.  The inputs can be selected from the analog inputs multiplexed with pins RA0 through RA5, as well as the on-chip voltage reference (see Section 21.0 'Comparator Voltage Reference  Module' ).  The  digital  outputs  (normal  or inverted) are available at the pin level and can also be read through the control register.\nThe CMCON  register (Register 20-1) selects the comparator input and output configuration. Block diagrams of the various comparator configurations are shown in Figure 20-1.",
    "REGISTER 20-1: CMCON: COMPARATOR CONTROL REGISTER\nR-0, 1 = R-0. R-0, 2 = R/W-0. R-0, 3 = R/W-0. R-0, 4 = R/W-0. R-0, 5 = R/W-0. R-0, 6 = R/W-0. R-0, 7 = R/W-0. C2OUT, 1 = C1OUT. C2OUT, 2 = C2INV. C2OUT, 3 = C1INV. C2OUT, 4 = CIS. C2OUT, 5 = CM2. C2OUT, 6 = CM1. C2OUT, 7 = CM0\nbit 7\nbit 0",
    "bit 7 C2OUT : Comparator 2 Output bit\nWhen C2INV = 0 :\n1 = C2 VIN+ > C2 VIN-\n0 = C2 VIN+ < C2 VIN-\nWhen C2INV = 1 :\n1 = C2 VIN+ < C2 VIN-\n0 = C2 VIN+ > C2 VIN-",
    "bit 6 C1OUT : Comparator 1 Output bit\nWhen C1INV = 0 :\n1 = C1 VIN+ > C1 VIN-\n0 = C1 VIN+ < C1 VIN-\nWhen C1INV = 1 :\n1 = C1 VIN+ < C1 VIN-\n0 = C1 VIN+ > C1 VIN-",
    "bit 5 C2INV : Comparator 2 Output Inversion bit\n1 = C2 output inverted\n0 = C2 output not inverted",
    "bit 4 C1INV : Comparator 1 Output Inversion bit\n1 = C1 Output inverted\n0 = C1 Output not inverted",
    "When CM2:CM0 = 110 :\n- 1 = C1 VIN- connects to RD0/PSP0/C1IN+\nC2 VIN- connects to RD2/PSP2/C2IN+\n0 = C1 VIN- connects to RD1/PSP1/C1IN-\nC2 VIN- connects to RD3/PSP3/C2IN-\nCM2:CM0 : Comparator Mode bits\nFigure 20-1 shows the Comparator modes and the CM2:CM0 bit settings.",
    "Legend:\nR = Readable bit\n-n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "20.1 Comparator Configuration\nThere are eight modes of operation for the comparators, shown  in  Figure 20-1.  Bits  CM2:CM0  of  the CMCON register are used to select these modes. The TRISA register controls the data direction of the comparator pins for each mode. If the Comparator mode is changed, the comparator output level may not be valid for the specified mode  change delay shown in Section 27.0 'Electrical Characteristics' .\nNote:\nComparator interrupts should be disabled during a Comparator mode change; otherwise, a false interrupt may occur.",
    "20.2 Comparator Operation\nA single comparator is shown in Figure 20-2, along with the  relationship  between  the  analog  input  levels  and the digital output. When the analog input at VIN+ is less than the analog input VIN-, the output of the comparator is a digital low level. When the analog input at VIN+ is greater  than  the  analog  input  VIN-,  the  output  of  the comparator is a digital high level. The shaded areas of the output of the comparator in Figure 20-2 represent the uncertainty, due to input offsets and response time.",
    "20.3 Comparator Reference\nDepending on the comparator operating mode, either an external or internal voltage reference may be used. The analog signal present at VIN- is compared to the signal at VIN+ and the digital output of the comparator is adjusted accordingly (Figure 20-2).\nFIGURE 20-2: SINGLE COMPARATOR\n20.3.1 EXTERNAL REFERENCE SIGNAL\nWhen  external voltage references are used, the comparator module can be configured to have the comparators operate from the same or different reference sources. However, threshold detector applications may require the same reference. The reference signal must be between VSS and VDD and can be applied to either pin of the comparator(s).",
    "20.3.2 INTERNAL REFERENCE SIGNAL\nThe comparator module also allows the selection of an internally generated voltage reference from the comparator voltage reference module. This module is described in more detail in Section 21.0 'Comparator Voltage Reference Module' .\nThe  internal  reference  is  only  available  in  the  mode where four inputs are multiplexed to two comparators (CM2:CM0 = 110 ).  In  this  mode,  the  internal  voltage reference is applied to the VIN+ pin of both comparators.",
    "20.4 Comparator Response Time\nResponse time is the minimum time, after selecting a new  reference  voltage  or  input  source,  before  the comparator  output  has  a  valid  level.  If  the  internal reference  is  changed,  the  maximum  delay  of  the internal  voltage  reference  must  be  considered  when using the comparator outputs. Otherwise, the maximum  delay  of  the  comparators  should  be  used (see Section 27.0 'Electrical Characteristics' ).",
    "20.5 Comparator Outputs\nThe comparator outputs are read through the CMCON register.  These  bits  are  read-only.  The  comparator outputs may also be directly output to the RE1 and RE2 I/O pins. When enabled, multiplexors in the output path of the RE1 and RE2 pins will switch and the output of each  pin  will  be  the  unsynchronized  output  of  the comparator. The uncertainty of each of the comparators is related to the input offset voltage and the response time given in the specifications. Figure 20-3 shows the comparator output block diagram.\nThe TRISE bits will still function as an output enable/ disable for the RE1 and RE2 pins while in this mode.\nThe polarity of the comparator outputs can be changed using the C2INV and C1INV bits (CMCON<4:5>).\nNote 1: When reading the Port register, all pins configured as analog inputs will read as a ' 0 '.  Pins  configured  as digital  inputs  will convert an analog input according to the Schmitt Trigger input specification.\n2: Analog  levels  on  any  pin  defined  as  a digital input may cause the input buffer to consume more current than is specified.",
    "20.6 Comparator Interrupts\nThe comparator interrupt flag is set whenever there is a  change  in  the  output  value  of  either  comparator. Software  will  need  to  maintain  information  about  the status of the output bits, as read from CMCON<7:6>, to determine the actual change that occurred. The CMIF bit  (PIR2<6>)  is  the  Comparator  Interrupt  Flag.  The CMIF bit must be reset by clearing it. Since it is also possible  to  write  a  ' 1 ' to  this  register,  a  simulated interrupt may be initiated.",
    "20.7 Comparator Operation During Sleep\nBoth the CMIE  bit (PIE2<6>)  and  the PEIE  bit (INTCON<6>) must be set to enable the interrupt. In addition, the GIE bit (INTCON<7>) must also be set. If any of these bits are clear, the interrupt is not enabled, though  the  CMIF  bit  will  still  be  set  if  an  interrupt condition occurs.\nNote:\nIf a change in the CMCON  register (C1OUT or C2OUT) should occur when a read operation is being executed (start of the Q2 cycle), then the CMIF (PIR registers) interrupt flag may not get set.\nThe user, in the Interrupt Service Routine, can clear the interrupt in the following manner:\na) Any  read  or  write  of  CMCON  will  end  the mismatch condition.\nb) Clear flag bit CMIF.\nA mismatch condition will continue to set flag bit CMIF. Reading CMCON will end the mismatch condition and allow flag bit CMIF to be cleared.",
    "20.7 Comparator Operation During Sleep\nWhen a comparator is active and the device is placed in Sleep mode, the comparator remains active and the interrupt  is  functional  if  enabled.  This  interrupt  will wake-up the device from Sleep mode, when enabled. While  the  comparator  is  powered  up,  higher  Sleep currents than shown in the power-down current specification  will  occur.  Each  operational  comparator will consume  additional  current,  as  shown  in  the comparator specifications. To minimize power consumption while in Sleep mode, turn off the comparators (CM2:CM0 = 111 ) before entering Sleep. If the device wakes up from Sleep, the contents of the CMCON register are not affected.",
    "20.8 Effects of a Reset\nA device Reset forces the CMCON register to its Reset state, causing the comparator module to be in the Comparator Reset mode (CM2:CM0 = 000) . This ensures that  all potential  inputs  are  analog  inputs.  Device current is minimized when analog inputs are present at Reset time. The comparators are powered down during the Reset interval.",
    "20.9 Analog Input Connection Considerations\nA  simplified  circuit  for  an  analog  input  is  shown  in Figure 20-4. Since the analog pins are connected to a digital output, they have reverse biased diodes to VDD and VSS. The analog input, therefore, must be between VSS and VDD. If the  input  voltage  deviates  from  this range by more than 0.6V in either direction, one of the diodes is forward biased and a latch-up condition may occur.  A  maximum  source  impedance  of  10 k \uf057 is recommended  for  the  analog  sources.  Any  external component connected to an analog input pin, such as a  capacitor  or  a  Zener  diode,  should  have  very  little leakage current.",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nCMCON (3), Bit 7 = C2OUT. CMCON (3), Bit 6 = C1OUT. CMCON (3), Bit 5 = C2INV. CMCON (3), Bit 4 = C1INV. CMCON (3), Bit 3 = CIS. CMCON (3), Bit 2 = CM2. CMCON (3), Bit 1 = CM1. CMCON (3), Bit 0 = CM0. CMCON (3), Reset Values on page = 48. CVRCON (3), Bit 7 = CVREN. CVRCON (3), Bit 6 = CVROE. CVRCON (3), Bit 5 = CVRR. CVRCON (3), Bit 4 = CVRSS. CVRCON (3), Bit 3 = CVR3. CVRCON (3), Bit 2 = CVR2. CVRCON (3), Bit 1 = CVR1. CVRCON (3), Bit 0 = CVR0. CVRCON (3), Reset Values on page = 48. INTCON, Bit 7 =",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nGIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 49. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP (2). IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (2). IPR2, Reset Values on page = 48. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF (2). PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\n3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (2). PIR2, Reset Values on page = 48. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE (2). PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (2). PIE2, Reset Values on page = 49. PORTA, Bit 7 = RA7 (1). PORTA, Bit 6 = RA6 (1). PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Reset Values on page = 49. LATA,",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nBit 7 = LATA7 (1). LATA, Bit 6 = LATA6 (1). LATA, Bit 5 = LATA Data Output Register. LATA, Bit 4 = LATA Data Output Register. LATA, Bit 3 = LATA Data Output Register. LATA, Bit 2 = LATA Data Output Register. LATA, Bit 1 = LATA Data Output Register. LATA, Bit 0 = LATA Data Output Register. LATA, Reset Values on page = 49. TRISA, Bit 7 = TRISA7 (1). TRISA, Bit 6 = TRISA6 (1). TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Reset Values on page = 49\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are unused by the comparator module.\nNote",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\n1: PORTA pins are enabled based on oscillator configuration.\n2: These bits are available in PIC18F4X8X devices and reserved in PIC18F2X8X devices.\n3: These registers are unimplemented on PIC18F2X8X devices.",
    "21.0 COMPARATOR VOLTAGE REFERENCE MODULE\nThe comparator voltage reference is a 16-tap resistor ladder  network  that  provides  a  selectable  reference voltage. Although its primary purpose is to provide a reference for the analog comparators, it may also be used independently of them.\nA block diagram is of the module shown in Figure 21-1. The resistor ladder is segmented to provide two ranges of  CVREF  values  and  has  a  power-down  function  to conserve power when the reference is not being used. The module's supply reference can be provided from either device VDD/VSS or an external voltage reference.",
    "21.1 Configuring the Comparator Voltage Reference\nused is selected by the CVRR bit (CVRCON<5>). The primary difference between the ranges is the size of the steps selected by the CVREF Selection bits (CVR3:CVR0), with one range offering finer resolution. The  equations  used  to  calculate  the  output  of  the comparator voltage reference are as follows:\nIf CVRR = 1 : CVREF = ((CVR3:CVR0)/24) x CVRSRC If CVRR = 0 : CVREF = (CVDD x 1/4) + (((CVR3:CVR0)/32) x CVRSRC)\nThe  comparator  reference  supply  voltage  can  come from either VDD and VSS, or the external VREF+ and VREF-  that  are  multiplexed  with  RA2  and  RA3.  The voltage source is selected by the CVRSS bit (CVRCON<4>).\nThe voltage reference module is controlled through the CVRCON  register  (Register 21-1).  The  comparator voltage reference provides two ranges of output voltage, each with 16 distinct levels. The range to be",
    "21.1 Configuring the Comparator Voltage Reference\nThe settling time of the comparator voltage reference must be considered when changing the CVREF output\n(see Table 27-3 in Section 27.0 'Electrical Characteristics' ).",
    "REGISTER 21-1: CVRCON: COMPARATOR VOLTAGE REFERENCE CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. CVREN, 1 = CVROE (1). CVREN, 2 = CVRR. CVREN, 3 = CVRSS. CVREN, 4 = CVR3. CVREN, 5 = CVR2. CVREN, 6 = CVR1. CVREN, 7 = CVR0\nbit 7\nbit 0\nbit 7\nCVREN : Comparator Voltage Reference Enable bit\n1 = CVREF circuit powered on\n0 = CVREF circuit powered down\nbit 6\nCVROE : Comparator VREF Output Enable bit (1)\n1 = CVREF voltage level is also output on the RA0/AN0/CVREF pin",
    "REGISTER 21-1: CVRCON: COMPARATOR VOLTAGE REFERENCE CONTROL REGISTER\n0 = CVREF voltage is disconnected from the RA0/AN0/CVREF pin\nNote 1:\nCVROE overrides the TRISA<0> bit setting. If enabled for output, RA2 must also be configured as an input by setting TRISA<2> to ' 1 '.\nbit 5 CVRR : Comparator VREF Range Selection bit\n1\n= 0.00 CVRSRC to 0.75 CVRSRC, with CVRSRC/24 step size\n0 = 0.25 CVRSRC to 0.75 CVRSRC, with CVRSRC/32 step size\nbit 4\nCVRSS : Comparator VREF Source Selection bit\n1 = Comparator reference source, CVRSRC = (VREF+) - (VREF-)\n0 = Comparator reference source, CVRSRC = VDD - VSS\nbit 3-0\nCVR3:CVR0: Comparator VREF Value Selection bits (0 \uf0a3 (CVR3:CVR0) \uf0a3 15)\nWhen CVRR = 1 :\nCVREF = ((CVR3:CVR0)/24)   (CVRSRC) \uf0b7",
    "REGISTER 21-1: CVRCON: COMPARATOR VOLTAGE REFERENCE CONTROL REGISTER\nWhen CVRR = 0 :\nCVREF = (CVRSRC/4) + ((CVR3:CVR0)/32)   (CVRSRC) \uf0b7",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nFIGURE 21-1: COMPARATOR VOLTAGE REFERENCE BLOCK DIAGRAM",
    "21.4 Effects of a Reset\nThe full range of voltage reference cannot be realized due to the construction of the module. The transistors on the top and bottom of the resistor ladder network (Figure 21-1) keep CVREF from approaching the reference source rails. The voltage reference is derived from the reference source; therefore, the CVREF output changes  with  fluctuations  in  that  source.  The  tested absolute  accuracy  of  the  voltage  reference  can  be found in Section 27.0 'Electrical Characteristics' .",
    "21.3 Operation During Sleep\nWhen  the  device  wakes  up  from  Sleep  through  an interrupt or a Watchdog Timer time-out, the contents of the  CVRCON  register  are  not  affected.  To  minimize current consumption  in Sleep mode,  the voltage reference should be disabled.\nA  device  Reset  disables  the  voltage  reference  by clearing  bit  CVREN  (CVRCON<7>).  This  Reset  also disconnects the reference from the RA0 pin by clearing bit CVROE (CVRCON<6>) and selects the high-voltage range by clearing bit CVRR (CVRCON<5>). The CVR value select bits are also cleared.",
    "21.5 Connection Considerations\nThe voltage reference module operates independently of the comparator module. The output of the reference generator  may  be  connected  to  the  RA0  pin  if  the TRISA<0>  bit  and  the  CVROE  bit  are  both  set. Enabling  the  voltage  reference  output  onto  the  RA0 pin, with an input signal present, will increase current consumption. Connecting RA0 as a digital output with CVRSS enabled will also increase current consumption.\nThe RA0 pin can be used as a simple D/A output with limited drive capability. Due to the limited current drive capability, a  buffer  must  be  used  on  the  voltage reference  output  for  external  connections  to  VREF. Figure 21-2 shows an example buffering technique.",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR VOLTAGE REFERENCE\nCVRCON (2), Bit 7 = CVREN. CVRCON (2), Bit 6 = CVROE. CVRCON (2), Bit 5 = CVRR. CVRCON (2), Bit 4 = CVRSS. CVRCON (2), Bit 3 = CVR3. CVRCON (2), Bit 2 = CVR2. CVRCON (2), Bit 1 = CVR1. CVRCON (2), Bit 0 = CVR0. CVRCON (2), Reset Values on page = 48. CMCON (2), Bit 7 = C2OUT. CMCON (2), Bit 6 = C1OUT. CMCON (2), Bit 5 = C2INV. CMCON (2), Bit 4 = C1INV. CMCON (2), Bit 3 = CIS. CMCON (2), Bit 2 = CM2. CMCON (2), Bit 1 = CM1. CMCON (2), Bit 0 = CM0. CMCON (2), Reset Values on page = 48. TRISA, Bit 7 = TRISA7",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR VOLTAGE REFERENCE\n(1) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 6 = TRISA7 (1) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 5 = TRISA7 (1) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 4 = TRISA7 (1) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 3 = TRISA7 (1) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 2 = TRISA7 (1) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 1 = TRISA7 (1) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 0 = TRISA7 (1) TRISA6 (1) PORTA Data Direction Register. TRISA, Reset Values on page = 49\nLegend: Shaded cells are not used with the comparator voltage reference.\nNote 1: PORTA pins are enabled based on oscillator configuration.\n2: These registers are unimplemented on PIC18F2X8X devices.",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR VOLTAGE REFERENCE\nbit 3-0",
    "22.0 HIGH/LOW-VOLTAGE DETECT (HLVD)\nPIC18F2585/2680/4585/4680 devices have a High/Low-Voltage  Detect  module  (HLVD).  This  is  a programmable  circuit  that  allows  the  user  to  specify both  a  device  voltage  trip  point  and  the  direction  of change from that point. If the device experiences an excursion  past  the  trip  point  in  that  direction,  an interrupt  flag  is  set.  If  the  interrupt  is  enabled,  the program execution will branch to the interrupt  vector address  and  the  software  can  then  respond  to  the interrupt.\nThe High/Low-Voltage Detect Control register (Register 22-1) completely controls the operation of the HLVD module. This allows the circuitry to be 'turned off' by the user under software control, which minimizes the current consumption for the device.\nThe block diagram for the HLVD module is shown in Figure 22-1.",
    "REGISTER 22-1: HLVDCON: HIGH/LOW-VOLTAGE DETECT CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = R-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-1. VDIRMAG, 1 = -. VDIRMAG, 2 = IRVST. VDIRMAG, 3 = HLVDEN. VDIRMAG, 4 = HLVDL3 (1). VDIRMAG, 5 = HLVDL2 (1). VDIRMAG, 6 = HLVDL1 (1). VDIRMAG, 7 = HLVDL0 (1)\nbit 7\n- bit 7\nbit 0\nVDIRMAG: Voltage Direction Magnitude Select bit",
    "REGISTER 22-1: HLVDCON: HIGH/LOW-VOLTAGE DETECT CONTROL REGISTER\n1 = Event occurs when voltage equals or exceeds trip point (HLVDL3:HLDVL0)\n0 = Event occurs when voltage equals or falls below trip point (HLVDL3:HLVDL0)\nbit 6 Unimplemented: Read as ' 0 '\nbit 5\nIRVST: Internal Reference Voltage Stable Flag bit\n1 = Indicates that the voltage detect logic will generate the interrupt flag at the specified voltage range\n0 = Indicates that the voltage detect logic will not generate the interrupt flag at the specified voltage range and the HLVD interrupt should not be enabled",
    "bit 4 HLVDEN: High/Low-Voltage Detect Power Enable bit\n1 = HLVD enabled\n0 = HLVD disabled\nHLVDL3:HLVDL0: Voltage Detection Limit bits (1)\n1111 = External analog input is used (input comes from the HLVDIN pin)\n1110 = 4.48V-4.69V\n1101 = 4.23V-4.43V\n1100 = 4.01V-4.20V\n1011 = 3.81V-3.99V\n1010 = 3.63V-3.80V\n1001 = 3.46V-3.63V\n1000 = 3.31V-3.47V\n0111 = 3.05V-3.19V\n0110 = 2.82V-2.95V\n0101 = 2.72V-2.85V\n0100 = 2.54V-2.66V\n0011 = 2.38V-2.49V\n0010 = 2.31V-2.42V\n0001 = 2.18V-2.28V\n0000 = 2.12V-2.22V",
    "bit 4 HLVDEN: High/Low-Voltage Detect Power Enable bit\nNote 1: HLVDL3:HLVDL0 modes that result in a trip point below the valid operating voltage of the device are not tested.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "PIC18F2585/2680/4585/4680\nThe  module  is  enabled  by  setting  the  HLVDEN  bit. Each  time  that  the  HLVD  module  is  enabled,  the circuitry requires some time to stabilize. The IRVST bit is a read-only bit and is used to indicate when the circuit is  stable.  The module can only generate an interrupt after the circuit is stable and IRVST is set.\nevent, depending on the configuration of the module. When the supply voltage is equal to the trip point, the voltage tapped off of the resistor array is equal to the internal  reference  voltage  generated  by  the  voltage reference module. The comparator then generates an interrupt signal by setting the HLVDIF bit.\nThe VDIRMAG bit determines the overall operation of the module. When VDIRMAG is cleared, the module monitors for drops in VDD below a predetermined set point. When the bit is set, the module monitors for rises in VDD above the set point.",
    "22.1 Operation\nWhen the HLVD module is enabled, a comparator uses an  internally  generated  reference  voltage  as  the  set point.  The  set  point  is  compared  with  the  trip  point, where each node in the resistor divider represents a trip point voltage. The 'trip point' voltage is the voltage level at which the device detects a high or low-voltage\nThe trip point voltage is software programmable to any one  of  sixteen  values.  The  trip  point  is  selected by programming the HLVDL3:HLVDL0 bits (HLVDCON<3:0>).\nThe HLVD module has an additional feature that allows the user to supply the trip voltage to the module from an external  source.  This  mode  is  enabled  when  bits HLVDL3:HLVDL0 are set to ' 1111 '.  In  this  state,  the comparator input is multiplexed from the external input pin,  HLVDIN.  This  gives  users  flexibility  because  it allows them to configure the High/Low-Voltage Detect interrupt to occur at any voltage in the valid operating range.\nFIGURE 22-1: HLVD MODULE BLOCK DIAGRAM (WITH EXTERNAL INPUT)",
    "22.2 HLVD Setup\nThe following  steps  are  needed  to  set  up  the  HLVD module:\n1. Disable the module by clearing the HLVDEN bit (HLVDCON<4>).\n2. Write the value to the HLVDL3:HLVDL0 bits that select the desired HLVD trip point.\n3. Set  the  VDIRMAG  bit  to  detect  high  voltage (VDIRMAG = 1 ) or low voltage (VDIRMAG = 0 ).\n4. Enable the HLVD module by setting the HLVDEN bit.\n5. Clear the HLVD interrupt flag (PIR2<2>), which may have been set from a previous interrupt.\n6. Enable  the  HLVD  interrupt  if  interrupts  are desired  by  setting  the  HLVDIE  and  GIE  bits (PIE<2> and INTCON<7>). An interrupt will not be generated until the IRVST bit is set.",
    "22.3 Current Consumption\nWhen the  module  is  enabled,  the  HLVD  comparator and voltage divider are enabled and will consume static current. The total current consumption, when enabled, is specified in electrical specification parameter D022B.\nDepending on the application, the HLVD module does not need to be operating constantly. To decrease the current  requirements,  the  HLVD  circuitry  may  only need to be enabled for short periods where the voltage is  checked. After doing the check, the HLVD module may be disabled.",
    "22.4 HLVD Start-up Time\nThe  internal  reference  voltage  of  the  HLVD  module, specified  in  electrical  specification  parameter  D420, may be used by  other  internal  circuitry,  such  as  the Programmable Brown-out Reset. If the HLVD or other circuits  using  the  voltage  reference  are  disabled  to lower the device's current consumption, the reference voltage circuit will require time to become stable before a low or high-voltage condition can be reliably detected. This start-up time, TIRVST, is an interval that is independent of device clock speed. It is specified in electrical specification parameter 36.\nThe HLVD interrupt flag is not enabled until TIRVST has expired and a stable reference voltage is reached. For this reason, brief excursions beyond the set point may not be detected during this interval. Refer to Figure 22-2 or Figure 22-3.",
    "22.5 Applications\nIn many applications, the ability to detect a drop below, or  rise  above  a  particular  threshold  is  desirable.  For example,  the  HLVD  module  could  be  periodically enabled to detect Universal Serial Bus (USB) attach or detach. This assumes the device is powered by a lower voltage source than the USB when detached. An attach would indicate a high-voltage detect from, for example, 3.3V to 5V (the voltage on USB) and vice versa for a detach. This feature could save a design a few extra components and an attach signal (input pin).\nFIGURE 22-4: TYPICAL LOW-VOLTAGE DETECT APPLICATION\nFor general battery applications, Figure 22-4 shows a possible voltage curve. Over time, the device voltage decreases. When the device voltage reaches voltage VA, the HLVD logic generates an interrupt at time TA. The  interrupt  could  cause  the  execution  of  an  ISR, which would allow the application to perform 'housekeeping  tasks'  and  perform  a  controlled  shutdown before  the  device  voltage  exits  the  valid  operating range at TB. The HLVD, thus, would give the application a time window, represented by the difference between TA and TB, to safely exit.",
    "22.7 Effects of a Reset\nWhen enabled, the HLVD circuitry continues to operate during  Sleep.  If  the  device  voltage  crosses  the  trip point,  the  HLVDIF  bit  will  be  set  and  the  device  will wake-up  from  Sleep.  Device  execution  will  continue from  the  interrupt  vector  address  if  interrupts  have been globally enabled.\nA device Reset forces all registers to their Reset state. This forces the HLVD module to be turned off.",
    "TABLE 22-1: REGISTERS ASSOCIATED WITH HIGH/LOW-VOLTAGE DETECT MODULE\nHLVDCON, Bit 7 = VDIRMAG. HLVDCON, Bit 6 = -. HLVDCON, Bit 5 = IRVST. HLVDCON, Bit 4 = HLVDEN. HLVDCON, Bit 3 = HLVDL3. HLVDCON, Bit 2 = HLVDL2. HLVDCON, Bit 1 = HLVDL1. HLVDCON, Bit 0 = HLVDL0. HLVDCON, Reset Values on Page = 47. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 46. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF. PIR2, Bit 5 =",
    "TABLE 22-1: REGISTERS ASSOCIATED WITH HIGH/LOW-VOLTAGE DETECT MODULE\n-. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF. PIR2, Reset Values on Page = 48. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE. PIE2, Reset Values on Page = 49. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2,",
    "TABLE 22-1: REGISTERS ASSOCIATED WITH HIGH/LOW-VOLTAGE DETECT MODULE\nBit 0 = ECCP1IP. IPR2, Reset Values on Page = 48\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are unused by the HLVD module.",
    "23.1 Module Overview\nPIC18F2585/2680/4585/4680 devices contain an Enhanced  Controller  Area  Network  (ECAN)  module. The ECAN module is fully backward compatible with the CAN module available in PIC18CXX8 and PIC18FXX8 devices.\nThe Controller Area Network (CAN) module is a serial interface which is useful for communicating with other peripherals or microcontroller devices. This interface, or  protocol,  was  designed  to  allow  communications within noisy environments.\nThe ECAN module is a communication controller, implementing the CAN 2.0A or B protocol as defined in the BOSCH specification. The module will support CAN 1.2, CAN 2.0A,  CAN  2.0B  Passive  and  CAN  2.0B  Active versions of the protocol. The module implementation is a full CAN system; however, the CAN specification is not covered within this data sheet. Refer to the BOSCH CAN specification for further details.\nThe module features are as follows:",
    "23.1 Module Overview\n\u00b7 Implementation of the CAN protocol CAN 1.2, CAN 2.0A and CAN 2.0B\n\u00b7 DeviceNet TM  data bytes filter support\n\u00b7 Standard and extended data frames\n\u00b7 0-8 bytes data length\n\u00b7 Programmable bit rate up to 1 Mbit/sec\n\u00b7 Fully backward compatible with PIC18XXX8 CAN module\n\u00b7 Three modes of operation:\n-Mode 0 - Legacy mode\n-Mode 1 - Enhanced Legacy mode with DeviceNet support\n-Mode 2 - FIFO mode with DeviceNet support\n\u00b7 Support for remote frames with automated handling\n\u00b7 Double-buffered receiver with two prioritized received message storage buffers\n\u00b7 Six buffers programmable as RX and TX message buffers\n\u00b7 16 full (standard/extended identifier) acceptance filters that can be linked to one of four masks\n\u00b7 Two full acceptance filter masks that can be assigned to any filter\n\u00b7 One full acceptance filter that can be used as either an acceptance filter or acceptance filter mask\n\u00b7 Three dedicated transmit buffers with application specified prioritization and abort capability\n\u00b7 Programmable wake-up functionality with integrated low-pass filter\n\u00b7 Programmable Loopback mode supports self-test operation\n\u00b7 Signaling via interrupt capabilities for all CAN receiver and transmitter error states\n\u00b7 Programmable clock source",
    "23.1 Module Overview\n\u00b7 Programmable link to timer module for time-stamping and network synchronization\n\u00b7 Low-power Sleep mode\nThe CAN bus module consists of a protocol engine and message  buffering  and  control.  The  CAN  protocol engine automatically handles all functions for receiving and transmitting messages on the CAN bus. Messages are  transmitted  by  first  loading  the  appropriate  data registers. Status and errors can be checked by reading the  appropriate  registers.  Any  message  detected  on the CAN bus is checked for errors and then matched against filters to see if it should be received and stored in one of the two receive registers.\nThe CAN module supports the following frame types:\n\u00b7 Standard Data Frame\n\u00b7 Extended Data Frame\n\u00b7 Remote Frame\n\u00b7 Error Frame\n\u00b7 Overload Frame Reception\n\u00b7 Interframe Space Generation/Detection\nThe  CAN  module  uses  the  RB2/CANTX  and  RB3/ CANRX pins to interface with the CAN bus. In normal mode, the CAN module automatically overrides TRISB<2>. The user must ensure  that  TRISB<3>  is set.",
    "23.1.1 MODULE FUNCTIONALITY\nThe CAN bus module consists of a protocol engine, message buffering and control (see Figure 23-1). The protocol engine can best be understood by defining the types of data frames to be transmitted and received by the module.\nThe following sequence illustrates the necessary initialization steps before the ECAN module can be used to transmit or receive a message. Steps can be added or removed depending on the requirements of the application.\n1. Ensure that the ECAN module is in Configuration mode.\n2. Select ECAN Operational mode.\n3. Set up the baud rate registers.\n4. Set up the filter and mask registers.\n5. Set the ECAN module to normal mode or any other mode required by the application logic.",
    "23.2 CAN Module Registers\nNote:\nNot all CAN registers are available in the access bank.",
    "23.2.1 CAN CONTROL AND STATUS REGISTERS\nThere are many control and data registers associated with the CAN module. For convenience, their descriptions  have  been  grouped  into  the  following sections:\n\u00b7 Control and Status Registers\n\u00b7 Dedicated Transmit Buffer Registers\n\u00b7 Dedicated Receive Buffer Registers\n\u00b7 Programmable TX/RX and Auto RTR Buffers\n\u00b7 Baud Rate Control Registers\n\u00b7 I/O Control Register\n\u00b7 Interrupt Status and Control Registers\nDetailed descriptions of each register and their usage are described in the following sections.\nThe  registers  described  in  this  section  control  the overall  operation  of  the  CAN  module  and  show  its operational status.",
    "REGISTER 23-1: CANCON: CAN CONTROL REGISTER\nMode 0, R/W-1 = REQOP2. Mode 0, R/W-0 = REQOP1. Mode 0, R/W-0 = REQOP0. Mode 0, R/S-0 = ABAT. Mode 0, R/W-0 = WIN2. Mode 0, R/W-0 = WIN1. Mode 0, R/W-0 = WIN0. Mode 0, U-0 = -. , R/W-1 = R/W-1. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/S-0 = R/S-0. , R/W-0 = U-0. , R/W-0 = U-0. , R/W-0 = U-0. , U-0 = U-0. , R/W-1 = REQOP2. , R/W-0 = REQOP1. , R/W-0 = REQOP0. , R/S-0 = ABAT. , R/W-0",
    "REGISTER 23-1: CANCON: CAN CONTROL REGISTER\n= -. , R/W-0 = -. , R/W-0 = -. , U-0 = -. , R/W-1 = R/W-1. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/S-0 = R/S-0. , R/W-0 = R-0. , R/W-0 = R-0. , R/W-0 = R-0. , U-0 = R-0. , R/W-1 = REQOP2. , R/W-0 = REQOP1. , R/W-0 = REQOP0. , R/S-0 = ABAT. , R/W-0 = FP3. , R/W-0 = FP2. , R/W-0 = FP1. , U-0 = FP0\nbit 7\nbit 0\nbit 7-5 REQOP2:REQOP0: Request CAN Operation Mode bits\n1xx = Request Configuration mode\n011 = Request Listen Only mode",
    "REGISTER 23-1: CANCON: CAN CONTROL REGISTER\n010 = Request Loopback mode\n001 = Request Disable mode\n000 = Request Normal mode\nABAT: Abort All Pending Transmissions bit\n1 = Abort all pending transmissions (in all transmit buffers)\n0 = Transmissions proceeding as normal",
    "bit 3-1 Mode 0:\nWIN2:WIN0: Window Address bits\nThese bits select which of the CAN buffers to switch into the access bank area. This allows access to the buffer registers from any data memory bank. After a frame has caused an interrupt, the ICODE3:ICODE0 bits can be copied to the WIN3:WIN0 bits to select the correct buffer. See Example 23-2 for a code example.\n111 = Receive Buffer 0\n110 = Receive Buffer 0\n101 = Receive Buffer 1\n100 = Transmit Buffer 0\n011 = Transmit Buffer 1\n010 = Transmit Buffer 2\n001 = Receive Buffer 0\n000 = Receive Buffer 0",
    "bit 0 Unimplemented: Read as ' 0 '\nbit 4-0 Mode 1:\nUnimplemented: Read as ' 0 '",
    "Mode 2:\nFP3:FP0: FIFO Read Pointer bits\nThese bits point to the message buffer to be read.\n0111:0000 = Message buffer to be read\n1111:1000 = Reserved",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-2:\nCANSTAT: CAN STATUS REGISTER",
    "REGISTER 23-2:\nMode 1, 2, R-1.OPMODE2 (1) = R-1. Mode 1, 2, R-0.OPMODE1 (1) = R-0. Mode 1, 2, R-0.OPMODE0 (1) = R-0. Mode 1, 2, R-0.- = R-0. Mode 1, 2, R-0.ICODE3 = R-0. Mode 1, 2, R-0.ICODE2 = R-0. Mode 1, 2, R-0.ICODE1 = R-0. Mode 1, 2, U-0.- = R-0. Mode 1, 2, R-1.OPMODE2 (1) = OPMODE2 (1). Mode 1, 2, R-0.OPMODE1 (1) = OPMODE1 (1). Mode 1, 2, R-0.OPMODE0 (1) = OPMODE0 (1). Mode 1, 2, R-0.- = EICODE4. Mode 1, 2, R-0.ICODE3 =",
    "REGISTER 23-2:\nEICODE3. Mode 1, 2, R-0.ICODE2 = EICODE2. Mode 1, 2, R-0.ICODE1 = EICODE1. Mode 1, 2, U-0.- = EICODE0. , R-1.OPMODE2 (1) = bit 7. , R-0.OPMODE1 (1) = . , R-0.OPMODE0 (1) = . , R-0.- = . , R-0.ICODE3 = . , R-0.ICODE2 = . , R-0.ICODE1 = . , U-0.- = bit 0\nbit 7-5 OPMODE2:OPMODE0: Operation Mode Status bits (1)\n111 = Reserved\n110 = Reserved\n101 = Reserved\n100 = Configuration mode\n011 = Listen Only mode\n010 = Loopback mode\n001 = Disable/Sleep mode\n000 = Normal mode",
    "bit 4 Mode 0:\nUnimplemented: Read as ' 0 '",
    "bit  3-1 ICODE3:ICODE1:\nInterrupt Code bits\nWhen an interrupt occurs, a prioritized coded interrupt value will be present in these bits. This code indicates the source of the interrupt. By copying ICODE3:ICODE1 to WIN2:WIN0 (Mode 0) or EICODE4:EICODE0 to EWIN4:EWIN0 (Mode 1 and 2), it is possible to select the correct buffer to map into the Access Bank area. See Example 23-2 for a code example. To simplify the description, the following table lists all five bits.",
    "bit  3-1 ICODE3:ICODE1:\nNo interrupt, Mode 0 = 00000. No interrupt, Mode 1 = 00000. No interrupt, Mode 2 = 00000. Error interrupt, Mode 0 = 00010. Error interrupt, Mode 1 = 00010. Error interrupt, Mode 2 = 00010. TXB2 interrupt, Mode 0 = 00100. TXB2 interrupt, Mode 1 = 00100. TXB2 interrupt, Mode 2 = 00100. TXB1 interrupt, Mode 0 = 00110. TXB1 interrupt, Mode 1 = 00110. TXB1 interrupt, Mode 2 = 00110. TXB0 interrupt, Mode 0 = 01000. TXB0 interrupt, Mode 1 = 01000. TXB0 interrupt, Mode 2 = 01000. RXB1 interrupt, Mode 0 = 01010. RXB1 interrupt, Mode 1 = 10001. RXB1 interrupt, Mode 2 = -----. RXB0 interrupt, Mode 0 = 01100. RXB0 interrupt, Mode 1 = 10000. RXB0 interrupt, Mode 2 = 10000. Wake-up interrupt, Mode 0 = 00010.",
    "bit  3-1 ICODE3:ICODE1:\nWake-up interrupt, Mode 1 = 01110. Wake-up interrupt, Mode 2 = 01110. RXB0 interrupt, Mode 0 = -----. RXB0 interrupt, Mode 1 = 10000. RXB0 interrupt, Mode 2 = 10000. RXB1 interrupt, Mode 0 = -----. RXB1 interrupt, Mode 1 = 10001. RXB1 interrupt, Mode 2 = 10000. RX/TX B0 interrupt, Mode 0 = -----. RX/TX B0 interrupt, Mode 1 = 10010. RX/TX B0 interrupt, Mode 2 = 10010. RX/TX B1 interrupt, Mode 0 = -----. RX/TX B1 interrupt, Mode 1 = 10011. RX/TX B1 interrupt, Mode 2 = 10011 (2). RX/TX B2 interrupt, Mode 0 = -----. RX/TX B2 interrupt, Mode 1 = 10100. RX/TX B2 interrupt, Mode 2 = 10100 (2). RX/TX",
    "bit  3-1 ICODE3:ICODE1:\nB3 interrupt, Mode 0 = -----. RX/TX B3 interrupt, Mode 1 = 10101. RX/TX B3 interrupt, Mode 2 = 10101 (2). RX/TX B4 interrupt, Mode 0 = -----. RX/TX B4 interrupt, Mode 1 = 10110. RX/TX B4 interrupt, Mode 2 = 10110 (2). RX/TX B5 interrupt, Mode 0 = -----. RX/TX B5 interrupt, Mode 1 = 10111. RX/TX B5 interrupt, Mode 2 = 10111 (2)",
    "bit 4-0 Mode 1, 2:\nEICODE4:EICODE0:\nInterrupt Code bits\nSee ICODE3:ICODE1 above.\nNote 1: To achieve maximum power saving and/or able to wake-up on CAN bus activity, switch CAN module in Disable mode before putting device to Sleep.\n2: If buffer is configured as receiver, EICODE bits will contain ' 10000 ' upon interrupt.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "EXAMPLE 23-1: CHANGING TO CONFIGURATION MODE\n```\n; Request Configuration mode. MOVLW B'10000000' ; Set to Configuration Mode. MOVWF CANCON ; A request to switch to Configuration mode may not be immediately honored. ; Module will wait for CAN bus to be idle before switching to Configuration Mode. ; Request for other modes such as Loopback, Disable etc. may be honored immediately. ; It is always good practice to wait and verify before continuing. ConfigWait: MOVF CANSTAT, W ; Read current mode state. ANDLW B'10000000' ; Interested in OPMODE bits only. TSTFSZ WREG ; Is it Configuration mode yet? BRA ConfigWait ; No. Continue to wait... ; Module is in Configuration mode now. ; Modify configuration registers as required. ; Switch back to Normal mode to be able to communicate.\n```",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\n```",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\n; Save application required context. ; Poll interrupt flags and determine source of interrupt ; This was found to be CAN interrupt ; TempCANCON and TempCANSTAT are variables defined in Access Bank low MOVFF CANCON, TempCANCON ; Save CANCON.WIN bits ; This is required to prevent CANCON ; from corrupting CAN buffer access ; in-progress while this interrupt ; occurred MOVFF CANSTAT, TempCANSTAT ; Save CANSTAT register ; This is required to make sure that ; we use same CANSTAT value rather ; than one changed by another CAN ; interrupt. MOVF TempCANSTAT, W ; Retrieve ICODE bits ANDLW B'00001110' ADDWF PCL, F ; Perform computed GOTO ; to corresponding interrupt cause BRA NoInterrupt ; 000 = No interrupt BRA ErrorInterrupt ; 001 = Error interrupt BRA TXB2Interrupt ; 010 = TXB2 interrupt BRA TXB1Interrupt ; 011 = TXB1 interrupt BRA TXB0Interrupt ; 100 = TXB0 interrupt BRA",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\nRXB1Interrupt ; 101 = RXB1 interrupt BRA RXB0Interrupt ; 110 = RXB0 interrupt ; 111 = Wake-up on interrupt WakeupInterrupt BCF PIR3, WAKIF ; Clear the interrupt flag ; ; User code to handle wake-up procedure ; ; ; Continue checking for other interrupt source or return from here \u2026 NoInterrupt \u2026 ; PC should never vector here. User may ; place a trap such as infinite loop or pin/port ; indication to catch this error.\n```",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nErrorInterrupt, 1 = ErrorInterrupt. ErrorInterrupt, 2 = . BCF, 1 = PIR3, ERRIF. BCF, 2 = ; Clear the interrupt flag. \u2026 RETFIE, 1 = \u2026 RETFIE. \u2026 RETFIE, 2 = ; Handle error.. TXB2Interrupt, 1 = TXB2Interrupt. TXB2Interrupt, 2 = . BCF, 1 = PIR3, TXB2IF. BCF, 2 = Clear the interrupt flag. GOTO, 1 = AccessBuffer. GOTO, 2 = ;. TXB1Interrupt, 1 = TXB1Interrupt. TXB1Interrupt, 2 = . BCF, 1 = PIR3, TXB1IF. BCF, 2 = Clear the interrupt flag. GOTO, 1 = AccessBuffer. GOTO, 2 = ;. TXB0Interrupt, 1 = TXB0Interrupt.",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nTXB0Interrupt, 2 = . BCF, 1 = PIR3, TXB0IF. BCF, 2 = Clear the interrupt flag. GOTO, 1 = AccessBuffer. GOTO, 2 = ;. RXB1Interrupt, 1 = RXB1Interrupt. RXB1Interrupt, 2 = . BCF, 1 = PIR3, RXB1IF. BCF, 2 = Clear the interrupt flag. GOTO, 1 = Accessbuffer. GOTO, 2 = ;. RXB0Interrupt, 1 = RXB0Interrupt. RXB0Interrupt, 2 = . BCF, 1 = PIR3, RXB0IF. BCF, 2 = ; Clear the interrupt flag. GOTO, 1 = AccessBuffer. GOTO, 2 = . AccessBuffer, 1 = AccessBuffer. AccessBuffer, 2 = ; This is either TX or RX interrupt. ; Copy, 1 =",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nCANSTAT.ICODE bits to. ; Copy, 2 = CANCON.WIN bits. MOVF, 1 = TempCANCON, W. MOVF, 2 = ; Clear CANCON.WIN bits before copying ; new ones.. ANDLW, 1 = B'11110001'. ANDLW, 2 = ; Use previously saved CANCON value to ; make sure same value.. MOVWF, 1 = TempCANCON. MOVWF, 2 = ; Copy masked value back to TempCANCON. MOVF, 1 = TempCANSTAT, W. MOVF, 2 = ; Retrieve ICODE bits. ANDLW, 1 = B'00001110'. ANDLW, 2 = ; Use previously saved CANSTAT value ; to make sure same value.. IORWF, 1 = TempCANCON. IORWF, 2 = ; Copy ICODE bits to WIN bits.. MOVFF, 1 = TempCANCON, CANCON. MOVFF, 2 = ; Copy the result to",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nactual CANCON. ; Access current buffer\u2026, 1 = ; Access current buffer\u2026. ; Access current buffer\u2026, 2 = . ; User code, 1 = ; User code. ; User code, 2 = . ; Restore MOVF, 1 = CANCON.WIN bits CANCON, W. ; Restore MOVF, 2 = ; Preserve current non WIN bits. ANDLW, 1 = B'11110001'. ANDLW, 2 = . IORWF, 1 = TempCANCON. IORWF, 2 = ; Restore original WIN bits. ; Do not need to restore CANSTAT -, 1 = ; Do not need to restore CANSTAT -. ; Do not need to restore CANSTAT -, 2 = it is read-only register.. ; Return from interrupt, 1 = or check. ; Return from interrupt, 2 = for another module interrupt source",
    "REGISTER 23-3: ECANCON: ENHANCED CAN CONTROL REGISTER\nR/W-0, 1 = R/W-0 R/W-0. R/W-0, 2 = R/W-1 R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. MDSEL1 (1) MDSEL0 (1) FIFOWM (2), 1 = EWIN4. MDSEL1 (1) MDSEL0 (1) FIFOWM (2), 2 = EWIN3. MDSEL1 (1) MDSEL0 (1) FIFOWM (2), 3 = EWIN2. MDSEL1 (1) MDSEL0 (1) FIFOWM (2), 4 = EWIN1. MDSEL1 (1) MDSEL0 (1) FIFOWM (2), 5 = EWIN0\nbit 7\nbit 0",
    "bit 7-6 MDSEL1:MDSEL0: Mode Select bits (1)\n00 = Legacy mode (Mode 0, default)\n01 = Enhanced Legacy mode (Mode 1)\n10 = Enhanced FIFO mode (Mode 2)\n11 = Reserved",
    "bit 5 FIFOWM: FIFO High Water Mark bit (2)\n1 = Will cause FIFO interrupt when one receive buffer remains (3)\n0 = Will cause FIFO interrupt when four receive buffers remain",
    "bit 4-0 EWIN4:EWIN0: Enhanced Window Address bits\nThese bits map the group of 16 banked CAN SFRs into access bank addresses 0F60-0F6Dh.\nExact group of registers to map is determined by binary value of these bits.\nMode 0:\nUnimplemented: Read as ' 0 '",
    "Mode 1, 2:\n00000 = Acceptance Filters 0, 1, 2 and BRGCON2, 3\n00001 = Acceptance Filters 3, 4, 5 and BRGCON1, CIOCON\n00010 = Acceptance Filter Masks, Error and Interrupt Control\n00011 = Transmit Buffer 0\n00100 = Transmit Buffer 1\n00101 = Transmit Buffer 2\n00110 = Acceptance Filters 6, 7, 8\n00111 = Acceptance Filters 9, 10, 11\n01000 = Acceptance Filters 12, 13, 14\n01001 = Acceptance Filters 15\n01010 01110 - = Reserved\n01111 = RXINT0, RXINT1\n10000 = Receive Buffer 0\n10001 = Receive Buffer 1\n10010 = TX/RX Buffer 0\n10011 = TX/RX Buffer 1\n10100 = TX/RX Buffer 2\n10101 = TX/RX Buffer 3\n10110 = TX/RX Buffer 4\n10111 = TX/RX Buffer 5\n11000 11111 -= Reserved\nNote 1: These  bits  can  only  be  changed  in  Configuration  mode.  See  Register 23-1  to change to Configuration mode.\n2: This bit is used in Mode 2 only.\n3: FIFO length of 4 or less will cause this bit to be set.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "COMSTAT: COMMUNICATION STATUS REGISTER\nMode 0, R/C-0 = RXB0OVFL. Mode 0, R/C-0 = RXB1OVFL. Mode 0, R-0 = TXBO. Mode 0, R-0 = TXBP. Mode 0, R-0 = RXBP. Mode 0, R-0 = TXWARN. Mode 0, R-0 = RXWARN. Mode 0, R-0 = EWARN. , R/C-0 = R/C-0. , R/C-0 = R/C-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R/C-0 = -. , R/C-0 = RXBnOVFL. , R-0 = TXB0. , R-0 = TXBP. , R-0 = RXBP. , R-0 = TXWARN. , R-0 = RXWARN. ,",
    "COMSTAT: COMMUNICATION STATUS REGISTER\nR-0 = EWARN. , R/C-0 = R/C-0. , R/C-0 = R/C-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R/C-0 = FIFOEMPTY. , R/C-0 = RXBnOVFL. , R-0 = TXBO. , R-0 = TXBP. , R-0 = RXBP. , R-0 = TXWARN. , R-0 = RXWARN. , R-0 = EWARN\nbit 7\nbit 0",
    "bit 7 Mode 0:\nRXB0OVFL: Receive Buffer 0 Overflow bit\n1 = Receive Buffer 0 overflowed\n0 = Receive Buffer 0 has not overflowed\nMode 1:\nUnimplemented: Read as ' 0 '\nMode 2:\nFIFOEMPTY: FIFO Not Empty bit\n1 = Receive FIFO is not empty\n0 = Receive FIFO is empty",
    "bit 6 Mode 0:\nRXB1OVFL: Receive Buffer 1 Overflow bit\n1 = Receive Buffer 1 overflowed\n0 = Receive Buffer 1 has not overflowed\nMode 1, 2:\nRXBnOVFL: Receive Buffer n Overflow bit\n1 = Receive Buffer n has overflowed\n0 = Receive Buffer n has not overflowed",
    "bit 5 TXBO: Transmitter Bus-Off bit\n1 = Transmit error counter > 255\n0 = Transmit error counter \uf0a3\uf020 255",
    "bit 4\nTXBP: Transmitter Bus Passive bit\n1 = Transmit error counter > 127\n0 = Transmit error counter \uf0a3\uf020 127",
    "bit 3\nRXBP: Receiver Bus Passive bit\n1 = Receive error counter > 127\n0 = Receive error counter \uf0a3\uf020 127",
    "bit 2\nTXWARN: Transmitter Warning bit\n1 = Transmit error counter > 95\n0 = Transmit error counter \uf0a3\uf020 95",
    "bit 1\nRXWARN: Receiver Warning bit\n1 = 127 \uf0b3 Receive error counter > 95\n0 = Receive error counter \uf0a3 95",
    "bit 0\nEWARN: Error Warning bit\nThis bit is a flag of the RXWARN and TXWARN bits.\n1 = The RXWARN or the TXWARN bits are set\n0 = Neither the RXWARN or the TXWARN bits are set",
    "Legend:\nC = Clearable bit\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "23.2.2 DEDICATED CAN TRANSMIT BUFFER REGISTERS\nThis  section  describes  the  dedicated  CAN  Transmit Buffer registers and their associated control registers.",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nMode 0, R/C-0 = TXBIF. Mode 0, R-0 = TXABT (1). Mode 0, R-0 = TXLARB (1). Mode 0, R-0 = TXERR (1). Mode 0, R/W-0 = TXREQ (2). Mode 0, U-0 = -. Mode 0, R/W-0 = TXPRI1 (3). Mode 0, R/W-0 = TXPRI0 (3). Mode 1, 2, R/C-0 = R/C-0. Mode 1, 2, R-0 = R-0. Mode 1, 2, R-0 = R-0. Mode 1, 2, R-0 = R-0. Mode 1, 2, R/W-0 = R/W-0. Mode 1, 2, U-0 = U-0. Mode 1, 2, R/W-0 = R/W-0. Mode 1, 2, R/W-0 = R/W-0. Mode 1,",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\n2, R/C-0 = TXBIF. Mode 1, 2, R-0 = TXABT (1). Mode 1, 2, R-0 = TXLARB (1). Mode 1, 2, R-0 = TXERR (1). Mode 1, 2, R/W-0 = TXREQ (2). Mode 1, 2, U-0 = -. Mode 1, 2, R/W-0 = TXPRI1 (3). Mode 1, 2, R/W-0 = TXPRI0 (3). Mode 1, 2, R/C-0 = bit 7. Mode 1, 2, R-0 = . Mode 1, 2, R-0 = . Mode 1, 2, R-0 = . Mode 1, 2, R/W-0 = . Mode 1, 2, U-0 = . Mode 1, 2, R/W-0 = . Mode 1, 2, R/W-0 = bit 0. bit 7, R/C-0 = TXBIF: Transmit Buffer Interrupt Flag bit",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\n1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. bit 7, R-0 = TXBIF: Transmit Buffer Interrupt Flag bit 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. bit 7, R-0 = TXBIF: Transmit Buffer Interrupt Flag bit 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. bit 7, R-0 = TXBIF: Transmit Buffer Interrupt Flag bit 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. bit 7, R/W-0 = TXBIF: Transmit Buffer Interrupt Flag bit 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. bit 7, U-0 = TXBIF: Transmit Buffer Interrupt Flag bit 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nmessage. bit 7, R/W-0 = TXBIF: Transmit Buffer Interrupt Flag bit 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. bit 7, R/W-0 = TXBIF: Transmit Buffer Interrupt Flag bit 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. bit 6, R/C-0 = TXABT: Transmission Aborted Status bit (1) 1 = Message was aborted 0 = Message was not aborted. bit 6, R-0 = TXABT: Transmission Aborted Status bit (1) 1 = Message was aborted 0 = Message was not aborted. bit 6, R-0 = TXABT: Transmission Aborted Status bit (1) 1 = Message was aborted 0 = Message was not aborted. bit 6, R-0 = TXABT: Transmission Aborted Status bit (1) 1 = Message was aborted 0 = Message was not aborted. bit 6, R/W-0 = TXABT:",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nTransmission Aborted Status bit (1) 1 = Message was aborted 0 = Message was not aborted. bit 6, U-0 = TXABT: Transmission Aborted Status bit (1) 1 = Message was aborted 0 = Message was not aborted. bit 6, R/W-0 = TXABT: Transmission Aborted Status bit (1) 1 = Message was aborted 0 = Message was not aborted. bit 6, R/W-0 = TXABT: Transmission Aborted Status bit (1) 1 = Message was aborted 0 = Message was not aborted. bit 5, R/C-0 = TXLARB: Transmission Lost Arbitration Status bit (1) 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. bit 5, R-0 = TXLARB: Transmission Lost Arbitration Status bit (1) 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. bit 5, R-0 = TXLARB: Transmission Lost Arbitration Status bit (1) 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nwhile being sent. bit 5, R-0 = TXLARB: Transmission Lost Arbitration Status bit (1) 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. bit 5, R/W-0 = TXLARB: Transmission Lost Arbitration Status bit (1) 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. bit 5, U-0 = TXLARB: Transmission Lost Arbitration Status bit (1) 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. bit 5, R/W-0 = TXLARB: Transmission Lost Arbitration Status bit (1) 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. bit 5, R/W-0 = TXLARB: Transmission Lost Arbitration Status bit (1) 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. bit 4, R/C-0 = TXERR: Transmission Error Detected Status bit (1) 1 = A bus error occurred while the message was being sent 0 = A bus",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nerror did not occur while the message was being sent. bit 4, R-0 = TXERR: Transmission Error Detected Status bit (1) 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. bit 4, R-0 = TXERR: Transmission Error Detected Status bit (1) 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. bit 4, R-0 = TXERR: Transmission Error Detected Status bit (1) 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. bit 4, R/W-0 = TXERR: Transmission Error Detected Status bit (1) 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. bit 4, U-0 = TXERR: Transmission Error Detected Status bit (1) 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nthe message was being sent. bit 4, R/W-0 = TXERR: Transmission Error Detected Status bit (1) 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. bit 4, R/W-0 = TXERR: Transmission Error Detected Status bit (1) 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. bit 3, R/C-0 = TXREQ: Transmit Request Status bit (2) = Requests sending a message. Clears the TXABT, TXLARB and TXERR bits.. bit 3, R-0 = TXREQ: Transmit Request Status bit (2) = Requests sending a message. Clears the TXABT, TXLARB and TXERR bits.. bit 3, R-0 = TXREQ: Transmit Request Status bit (2) = Requests sending a message. Clears the TXABT, TXLARB and TXERR bits.. bit 3, R-0 = TXREQ: Transmit Request",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nStatus bit (2) = Requests sending a message. Clears the TXABT, TXLARB and TXERR bits.. bit 3, R/W-0 = TXREQ: Transmit Request Status bit (2) = Requests sending a message. Clears the TXABT, TXLARB and TXERR bits.. bit 3, U-0 = TXREQ: Transmit Request Status bit (2) = Requests sending a message. Clears the TXABT, TXLARB and TXERR bits.. bit 3, R/W-0 = TXREQ: Transmit Request Status bit (2) = Requests sending a message. Clears the TXABT, TXLARB and TXERR bits.. bit 3, R/W-0 = TXREQ: Transmit Request Status bit (2) = Requests sending a message. Clears the TXABT, TXLARB and TXERR bits.. bit 2, R/C-0 = = Automatically cleared when the message is successfully sent Unimplemented: Read as ' 0 '. bit 2, R-0 = = Automatically cleared when the message is",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nsuccessfully sent Unimplemented: Read as ' 0 '. bit 2, R-0 = = Automatically cleared when the message is successfully sent Unimplemented: Read as ' 0 '. bit 2, R-0 = = Automatically cleared when the message is successfully sent Unimplemented: Read as ' 0 '. bit 2, R/W-0 = = Automatically cleared when the message is successfully sent Unimplemented: Read as ' 0 '. bit 2, U-0 = = Automatically cleared when the message is successfully sent Unimplemented: Read as ' 0 '. bit 2, R/W-0 = = Automatically cleared when the message is successfully sent Unimplemented: Read as ' 0 '. bit 2, R/W-0 = = Automatically cleared when the message is successfully sent Unimplemented: Read as ' 0 '. , R/C-0 = TXPRI1:TXPRI0: Transmit Priority bits (3). , R-0 = TXPRI1:TXPRI0: Transmit Priority bits (3). ,",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nR-0 = TXPRI1:TXPRI0: Transmit Priority bits (3). , R-0 = TXPRI1:TXPRI0: Transmit Priority bits (3). , R/W-0 = TXPRI1:TXPRI0: Transmit Priority bits (3). , U-0 = TXPRI1:TXPRI0: Transmit Priority bits (3). , R/W-0 = TXPRI1:TXPRI0: Transmit Priority bits (3). , R/W-0 = TXPRI1:TXPRI0: Transmit Priority bits (3). bit 1-0, R/C-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. bit 1-0, R-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nwhen TXREQ is set.. bit 1-0, R-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. bit 1-0, R-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. bit 1-0, R/W-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. bit 1-0, U-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. bit 1-0, R/W-0 = 11 = Priority Level",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\n3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. bit 1-0, R/W-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. , R/C-0 = Legend:. , R-0 = Legend:. , R-0 = Legend:. , R-0 = Legend:. , R/W-0 = Legend:. , U-0 = Legend:. , R/W-0 = Legend:. , R/W-0 = Legend:. , R/C-0 = C = Clearable bit -n = Value. , R-0 = at POR. , R-0 = R = Readable bit '1' = Bit is set. , R-0 = R = Readable bit '1' = Bit is set. , R/W-0 =",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nW=Writable bit '0' = Bit is cleared. , U-0 = U = Unimplemented bit, read as '0' x = Bit is unknown. , R/W-0 = U = Unimplemented bit, read as '0' x = Bit is unknown. , R/W-0 = U = Unimplemented bit, read as '0' x = Bit is unknown",
    "REGISTER 23-6: HIGH BYTE [0 \uf0a3 n \uf0a3 2]\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0\nbit 7-0\nSID10:SID3: Standard Identifier bits (if EXIDE (TXBnSIDL<3>) = 0 )\nExtended Identifier bits EID28:EID21 (if EXIDE = 1 ).",
    "REGISTER 23-6: HIGH BYTE [0 \uf0a3 n \uf0a3 2]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "TXBnSIDL: TRANSMIT BUFFER n STANDARD IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 2]\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = U-0. R/W-x, 4 = R/W-x. R/W-x, 5 = U-0. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = -. SID2, 4 = EXIDE. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5 SID2:SID0: Standard Identifier bits (if EXIDE (TXBnSIDL<3>) = 0 )\nExtended Identifier bits EID20:EID18 (if EXIDE = 1 ).\nbit 4\nUnimplemented: Read as ' 0 '\nbit 3\nEXIDE: Extended Identifier Enable bit",
    "TXBnSIDL: TRANSMIT BUFFER n STANDARD IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 2]\n1 = Message will transmit extended ID, SID10:SID0 become EID28:EID18\n0 = Message will transmit standard ID, EID17:EID0 are ignored\nbit 2\nUnimplemented: Read as ' 0 '\nbit 1-0 EID17:EID16: Extended Identifier bits\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-8: TXBnEIDH: TRANSMIT BUFFER n EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 2]\nEID15, R/W-x = EID14. EID15, R/W-x = EID13. EID15, R/W-x = EID12. EID15, R/W-x = EID11. EID15, R/W-x = EID10. EID15, R/W-x = EID9. EID15, R/W-x = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier bits (not used when transmitting standard identifier message)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-9: TXBnEIDL: TRANSMIT BUFFER n EXTENDED IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 2]\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0\nbit 7-0 EID7:EID0: Extended Identifier bits (not used when transmitting standard identifier message)",
    "REGISTER 23-9: TXBnEIDL: TRANSMIT BUFFER n EXTENDED IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 2]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-10: TXBnDm: TRANSMIT BUFFER n DATA FIELD BYTE m REGISTERS [0 \uf0a3 n \uf0a3 2, 0 \uf0a3 m \uf0a3 7]\nTXBnDm7, R/W-x = TXBnDm6. TXBnDm7, R/W-x = TXBnDm5. TXBnDm7, R/W-x = TXBnDm4. TXBnDm7, R/W-x = TXBnDm3. TXBnDm7, R/W-x = TXBnDm2. TXBnDm7, R/W-x = TXBnDm1. TXBnDm7, R/W-x = TXBnDm0. bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = bit 0",
    "REGISTER 23-10: TXBnDm: TRANSMIT BUFFER n DATA FIELD BYTE m REGISTERS [0 \uf0a3 n \uf0a3 2, 0 \uf0a3 m \uf0a3 7]\nTXBnDm7:TXBnDm0: Transmit Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 3 and 0 \uf0a3\uf020 m < 8) Each transmit buffer has an array of registers. For example, Transmit Buffer 0 has 7 registers:\nbit 7-0 TXB0D0 to TXB0D7.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-11: TXBnDLC: TRANSMIT BUFFER n DATA LENGTH CODE REGISTERS [0   n   2] \uf0a3 \uf0a3\nU-0, 1 = R/W-x. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = TXRTR. -, 2 = -. -, 3 = -. -, 4 = DLC3. -, 5 = DLC2. -, 6 = DLC1. -, 7 = DLC0\nbit 7\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6 TXRTR: Transmit Remote Frame Transmission Request bit\n1 = Transmitted message will have TXRTR bit set\n0 = Transmitted message will have TXRTR bit cleared\nbit 5-4 Unimplemented: Read as ' 0 '\nbit 3-0 DLC3:DLC0: Data Length Code bits\n1111 = Reserved\n1110 = Reserved\n1101 = Reserved\n1100 = Reserved\n1011 = Reserved",
    "REGISTER 23-11: TXBnDLC: TRANSMIT BUFFER n DATA LENGTH CODE REGISTERS [0   n   2] \uf0a3 \uf0a3\n1010 = Reserved\n1001 = Reserved\n1000 = Data length = 8 bytes\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 bytes\n0000 = Data length = 0 bytes\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR,  = '0' = Bit is cleared. -n = Value at POR,  = x = Bit is unknown",
    "REGISTER 23-12: TXERRCNT: TRANSMIT ERROR COUNT REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. TEC7, 1 = TEC6. TEC7, 2 = TEC5. TEC7, 3 = TEC4. TEC7, 4 = TEC3. TEC7, 5 = TEC2. TEC7, 6 = TEC1. TEC7, 7 = TEC0\nbit 7\nbit 0",
    "bit 7-0 TEC7:TEC0: Transmit Error Counter bits\nThis register contains a value which is derived from the rate at which errors occur. When the error count overflows, the bus-off state occurs. When the bus has 128 occurrences of 11 consecutive recessive bits, the counter value is cleared.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "EXAMPLE 23-3: TRANSMITTING A CAN MESSAGE USING BANKED METHOD\n```\n; Need to transmit Standard Identifier message 123h using TXB0 buffer. ; To successfully transmit, CAN module must be either in Normal or Loopback mode. ; TXB0 buffer is not in access bank.",
    "EXAMPLE 23-3: TRANSMITTING A CAN MESSAGE USING BANKED METHOD\nAnd since we want banked method, we need to make sure ; that correct bank is selected. BANKSEL TXB0CON ; One BANKSEL in beginning will make sure that we are ; in correct bank for rest of the buffer access. ; Now load transmit data into TXB0 buffer. MOVLW MY_DATA_BYTE1 ; Load first data byte into buffer MOVWF TXB0D0 ; Compiler will automatically set 'BANKED' bit ; Load rest of data bytes - up to 8 bytes into TXB0 buffer. ... ; Load message identifier MOVLW 60H ; Load SID2:SID0, EXIDE = 0 MOVWF TXB0SIDL MOVLW 24H ; Load SID10:SID3 MOVWF TXB0SIDH ; No need to load TXB0EIDL:TXB0EIDH, as we are transmitting Standard Identifier Message only. ; Now that all data bytes are loaded, mark it for transmission. MOVLW B'00001000' ; Normal priority; Request transmission MOVWF TXB0CON ; If required, wait",
    "EXAMPLE 23-3: TRANSMITTING A CAN MESSAGE USING BANKED METHOD\nfor message to get transmitted BTFSC TXB0CON, TXREQ ; Is it transmitted? BRA $-2 ; No.\nContinue to wait... ; Message is transmitted.\n```",
    "EXAMPLE 23-4: TRANSMITTING A CAN MESSAGE USING WIN BITS\n```\n; Need to transmit Standard Identifier message 123h using TXB0 buffer. ; To successfully transmit, CAN module must be either in Normal or Loopback mode. ; TXB0 buffer is not in access bank.  Use WIN bits to map it to RXB0 area. MOVF CANCON, W ; WIN bits are in lower 4 bits only.  Read CANCON ; register to preserve all other bits.  If operation ; mode is already known, there is no need to preserve ; other bits. ANDLW B'11110000' ; Clear WIN bits. IORLW B'00001000' ; Select Transmit Buffer 0 MOVWF CANCON ; Apply the changes. ; Now TXB0 is mapped in place of RXB0.",
    "EXAMPLE 23-4: TRANSMITTING A CAN MESSAGE USING WIN BITS\nAll future access to RXB0 registers will actually ; yield TXB0 register values. ; Load transmit data into TXB0 buffer. MOVLW MY_DATA_BYTE1 ; Load first data byte into buffer MOVWF RXB0D0 ; Access TXB0D0 via RXB0D0 address. ; Load rest of the data bytes - up to 8 bytes into 'TXB0' buffer using RXB0 registers. ... ; Load message identifier MOVLW 60H ; Load SID2:SID0, EXIDE = 0 MOVWF RXB0SIDL MOVLW 24H ; Load SID10:SID3 MOVWF RXB0SIDH ; No need to load RXB0EIDL:RXB0EIDH, as we are transmitting Standard Identifier Message only. ; Now that all data bytes are loaded, mark it for transmission. MOVLW B'00001000' ; Normal priority; Request transmission MOVWF RXB0CON ; If required, wait for message to get transmitted BTFSC",
    "EXAMPLE 23-4: TRANSMITTING A CAN MESSAGE USING WIN BITS\nRXB0CON, TXREQ ; Is it transmitted? BRA $-2 ; No.\nContinue to wait... ; Message is transmitted. ; If required, reset the WIN bits to default state.\n```",
    "23.2.3 DEDICATED CAN RECEIVE BUFFER REGISTERS\nThis section shows the dedicated CAN Receive Buffer registers with their associated control registers.",
    "REGISTER 23-13: RXB0CON: RECEIVE BUFFER 0 CONTROL REGISTER\nMode 0, R/C-0 = RXFUL (1). Mode 0, R/W-0 = RXM1. Mode 0, R/W-0 = RXM0. Mode 0, U-0 = -. Mode 0, R-0 = RXRTRRO. Mode 0, R/W-0 = RXB0DBEN. Mode 0, R-0 = JTOFF (2). Mode 0, R-0 = FILHIT0. Mode 1, 2, R/C-0 = R/C-0. Mode 1, 2, R/W-0 = R/W-0. Mode 1, 2, R/W-0 = R-0. Mode 1, 2, U-0 = R-0. Mode 1, 2, R-0 = R-0. Mode 1, 2, R/W-0 = R-0. Mode 1, 2, R-0 = R-0. Mode 1, 2, R-0 = R-0. Mode 1, 2, R/C-0 = RXFUL",
    "REGISTER 23-13: RXB0CON: RECEIVE BUFFER 0 CONTROL REGISTER\n(1). Mode 1, 2, R/W-0 = RXM1. Mode 1, 2, R/W-0 = RTRRO. Mode 1, 2, U-0 = FILHIT4. Mode 1, 2, R-0 = FILHIT3. Mode 1, 2, R/W-0 = FILHIT2. Mode 1, 2, R-0 = FILHIT1. Mode 1, 2, R-0 = FILHIT0\nbit 7\nbit 0",
    "bit 7 RXFUL: Receive Full Status bit (1)\n1 = Receive buffer contains a received message\n0 = Receive buffer is open to receive a new message",
    "bit 6 Mode 0:\nRXM1: Receive Buffer Mode bit 1\nCombines with RXM0 to form RXM<1:0> bits (see bit 5).\n- 11 = Receive all messages (including those with errors); filter criteria is ignored\n10 = Receive only valid messages with extended identifier; EXIDEN in RXFnSIDL must be ' 1 '\n01 = Receive only valid messages with standard identifier; EXIDEN in RXFnSIDL must be ' 0 '\n00 = Receive all valid messages as per EXIDEN bit in RXFnSIDL register",
    "Mode 1, 2:\nRXM1 : Receive Buffer Mode bit 1\n1 = Receive all messages (including those with errors); acceptance filters are ignored\n0 = Receive all valid messages as per acceptance filters",
    "bit 5 Mode 0:\nRXM0: Receive Buffer Mode bit 0\nCombines with RXM1 to form RXM<1:0> bits (see bit 6).\nMode 1, 2:\nRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received",
    "bit 4 Mode 0:\nUnimplemented: Read as ' 0 '\nMode 1, 2:\nFILHIT4: Filter Hit bit 4\nThis bit combines with other bits to form filter acceptance bits <4:0>.",
    "bit 3 Mode 0:\nRXRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received",
    "Mode 1, 2:\nFILHIT3: Filter Hit bit 3\nThis bit combines with other bits to form filter acceptance bits <4:0>.",
    "REGISTER 23-13: RXB0CON: RECEIVE BUFFER 0 CONTROL REGISTER (CONTINUED)\nbit 2\nMode 0:\nRXB0DBEN: Receive Buffer 0 Double-Buffer Enable bit\n1 = Receive Buffer 0 overflow will write to Receive Buffer 1\n0 = No Receive Buffer 0 overflow to Receive Buffer 1\nMode 1, 2:\nFILHIT2: Filter Hit bit 2\nThis bit combines with other bits to form filter acceptance bits <4:0>.",
    "bit 1 Mode 0:\nJTOFF: Jump Table Offset bit (read-only copy of RXB0DBEN) (2)\n1 = Allows jump table offset between 6 and 7\n0 = Allows jump table offset between 1 and 0\nMode 1, 2:\nFILHIT1: Filter Hit bit 1\nThis bit combines with other bits to form filter acceptance bits <4:0>.",
    "bit 0 Mode 0:\nFILHIT0: Filter Hit bit 0\nThis bit indicates which acceptance filter enabled the message reception into Receive Buffer 0.\n1 = Acceptance Filter 1 (RXF1)\n0 = Acceptance Filter 0 (RXF0)",
    "Mode 1, 2:\nFILHIT0: Filter Hit bit 0\nThis bit, in combination with FILHIT<4:1>, indicates which acceptance filter enabled the message reception into this receive buffer.\n01111 = Acceptance Filter 15 (RXF15)\n01110 = Acceptance Filter 14 (RXF14)\n...\n00000 = Acceptance Filter 0 (RXF0)\nNote 1: This bit is set by the CAN module upon receiving a message and must be cleared by software after the buffer is read. As long as RXFUL is set, no new message will be loaded and buffer will be considered full. After clearing the RXFUL flag, the PIR3 bit, RXB0IF, can be cleared. If RXB0IF is cleared, but RXFUL is not cleared, then RXB0IF is set again.\n- 2: This bit allows same filter jump table for both RXB0CON and RXB1CON.",
    "Legend:\nC = Clearable bit, 1 = R = Readable bit. C = Clearable bit, 2 = W=Writable bit. C = Clearable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-14: RXB1CON: RECEIVE BUFFER 1 CONTROL REGISTER\nMode 0, 1 = R/C-0. Mode 0, 2 = R/W-0. Mode 0, 3 = R/W-0. Mode 0, 4 = U-0. Mode 0, 5 = R-0. Mode 0, 6 = R/W-0. Mode 0, 7 = R-0. Mode 0, 8 = R-0. Mode 0, 1 = RXFUL (1). Mode 0, 2 = RXM1. Mode 0, 3 = RXM0. Mode 0, 4 = -. Mode 0, 5 = RXRTRRO. Mode 0, 6 = FILHIT2. Mode 0, 7 = FILHIT1. Mode 0, 8 = FILHIT0",
    "REGISTER 23-14: RXB1CON: RECEIVE BUFFER 1 CONTROL REGISTER\nMode 1, 2, 1 = R/C-0. Mode 1, 2, 2 = R/W-0. Mode 1, 2, 3 = R-0. Mode 1, 2, 4 = R-0. Mode 1, 2, 5 = R-0. Mode 1, 2, 6 = R-0. Mode 1, 2, 7 = R-0. Mode 1, 2, 8 = R-0. Mode 1, 2, 1 = RXFUL (1). Mode 1, 2, 2 = RXM1. Mode 1, 2, 3 = RTRRO. Mode 1, 2, 4 = FILHIT4. Mode 1, 2, 5 = FILHIT3. Mode 1, 2, 6 = FILHIT2. Mode 1, 2, 7 = FILHIT1. Mode 1, 2, 8 = FILHIT0\nbit 7\nbit 0",
    "bit 7\nRXFUL: Receive Full Status bit (1)\n1 = Receive buffer contains a received message\n0 = Receive buffer is open to receive a new message\nNote 1: This bit is set by the CAN module upon receiving a message and must be cleared by software after the buffer is read. As long as RXFUL is set, no new message will be loaded and buffer will be considered full.",
    "bit 6 Mode 0:\nRXM1: Receive Buffer Mode bit 1\nCombines with RXM0 to form RXM<1:0> bits (see bit 5).\n11 = Receive all messages (including those with errors); filter criteria is ignored\n10 = Receive only valid messages with extended identifier; EXIDEN in RXFnSIDL must be ' 1 '\n01 = Receive only valid messages with standard identifier, EXIDEN in RXFnSIDL must be ' 0 '\n00 = Receive all valid messages as per EXIDEN bit in RXFnSIDL register",
    "Mode 1, 2:\nRXM1: Receive Buffer Mode bit\n1 = Receive all messages (including those with errors); acceptance filters are ignored\n0 = Receive all valid messages as per acceptance filters",
    "bit 5 Mode 0:\nRXM0: Receive Buffer Mode bit 0\nCombines with RXM1 to form RXM<1:0> bits (see bit 6).",
    "Mode 1, 2:\nRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received",
    "bit 4 Mode 0:\nUnimplemented: Read as ' 0 '\nMode 1, 2:\nFILHIT4: Filter Hit bit 4\nThis bit combines with other bits to form filter acceptance bits <4:0>.",
    "bit 3 Mode 0:\nRXRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received",
    "Mode 1, 2:\nFILHIT3: Filter Hit bit 3\nThis bit combines with other bits to form filter acceptance bits <4:0>.",
    "REGISTER 23-14: RXB1CON: RECEIVE BUFFER 1 CONTROL REGISTER (CONTINUED)\nbit 2-0\nMode 0:\nFILHIT2:FILHIT0: Filter Hit bits\nThese bits indicate which acceptance filter enabled the last message reception into Receive Buffer 1.\n111 = Reserved\n110 = Reserved\n101 = Acceptance Filter 5 (RXF5)\n100 = Acceptance Filter 4 (RXF4)\n011 = Acceptance Filter 3 (RXF3)\n010 = Acceptance Filter 2 (RXF2)\n001 = Acceptance Filter 1 (RXF1), only possible when RXB0DBEN bit is set\n000 = Acceptance Filter 0 (RXF0), only possible when RXB0DBEN bit is set",
    "Mode 1, 2:\nFILHIT2:FILHIT0 Filter Hit bits <2:0>\nThese bits, in combination with FILHIT<4:3>, indicate which acceptance filter enabled the message reception into this receive buffer.\n01111 = Acceptance Filter 15 (RXF15)\n01110 = Acceptance Filter 14 (RXF14)\n...\n00000 = Acceptance Filter 0 (RXF0)",
    "Legend:\nC = Clearable bit\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-15: RXBnSIDH: RECEIVE BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 1]\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0\nbit 7-0 SID10:SID3: Standard Identifier bits (if EXID (RXBnSIDL<3>) = Extended Identifier bits EID28:EID21 (if EXID = 1 ).\n0 )",
    "REGISTER 23-15: RXBnSIDH: RECEIVE BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 1]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-16: RXBnSIDL: RECEIVE BUFFER n STANDARD IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = U-0. R-x, 6 = R-x. R-x, 7 = R-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = SRR. SID2, 4 = EXID. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5\nSID2:SID0: Standard Identifier bits (if EXID = 0 )\nExtended Identifier bits EID20:EID18 (if EXID = 1 ).\nbit 4\nSRR: Substitute Remote Request bit\nThis bit is always ' 0 ' when EXID = 1 or equal to the value of RXRTRRO (RBXnCON<3>) when EXID = 0 .",
    "bit 3\nEXID: Extended Identifier bit\n1 = Received message is an extended data frame, SID10:SID0 are EID28:EID18\n0 = Received message is a standard data frame\nbit 2\nUnimplemented:\nRead as '\n0\n'",
    "bit 1-0 EID17:EID16: Extended Identifier bits\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-17: RXBnEIDH: RECEIVE BUFFER n EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 1]\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. EID15, 1 = EID14. EID15, 2 = EID13. EID15, 3 = EID12. EID15, 4 = EID11. EID15, 5 = EID10. EID15, 6 = EID9. EID15, 7 = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-18: RXBnEIDL: RECEIVE BUFFER n EXTENDED IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-19: RXBnDLC: RECEIVE BUFFER n DATA LENGTH CODE REGISTERS [0   n   1] \uf0a3 \uf0a3\nU-0, 1 = R-x. U-0, 2 = R-x. U-0, 3 = R-x. U-0, 4 = R-x. U-0, 5 = R-x. U-0, 6 = R-x. U-0, 7 = R-x. -, 1 = RXRTR. -, 2 = RB1. -, 3 = RB0. -, 4 = DLC3. -, 5 = DLC2. -, 6 = DLC1. -, 7 = DLC0\nbit 7\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nRXRTR: Receiver Remote Transmission Request bit\n1 = Remote transfer request\n0 = No remote transfer request\nbit 5\nRB1:\nReserved bit 1\nReserved by CAN Spec and read as ' 0 '.",
    "bit 4 RB0: Reserved bit 0\nReserved by CAN Spec and read as ' 0 '.",
    "bit 3-0 DLC3:DLC0: Data Length Code bits\n1111 = Invalid\n1110 = Invalid\n1101 = Invalid\n1100 = Invalid\n1011 = Invalid\n1010 = Invalid\n1001 = Invalid\n1000 = Data length = 8 bytes\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 bytes\n0000 = Data length = 0 bytes\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "[0 \uf0a3 n \uf0a3 1, 0 \uf0a3 m \uf0a3 7]\nRXBnDm7, R-x = RXBnDm6. RXBnDm7, R-x = RXBnDm5. RXBnDm7, R-x = RXBnDm4. RXBnDm7, R-x = RXBnDm3. RXBnDm7, R-x = RXBnDm2. RXBnDm7, R-x = RXBnDm1. RXBnDm7, R-x = RXBnDm0. bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = bit 0\nbit 7-0 RXBnDm7:RXBnDm0: Receive Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 1 and 0 < m < 7) Each receive buffer has an array of registers. For example, Receive Buffer 0 has 8 registers:\nRXB0D0 to RXB0D7.",
    "[0 \uf0a3 n \uf0a3 1, 0 \uf0a3 m \uf0a3 7]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-21: RXERRCNT: RECEIVE ERROR COUNT REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. REC7, 1 = REC6. REC7, 2 = REC5. REC7, 3 = REC4. REC7, 4 = REC3. REC7, 5 = REC2. REC7, 6 = REC1. REC7, 7 = REC0\nbit 7\nbit 0",
    "bit 7-0 REC7:REC0: Receive Error Counter bits\nThis register contains the receive error value as defined by the CAN specifications. When RXERRCNT > 127, the module will go into an error-passive state. RXERRCNT does not have the ability to put the module in 'bus-off' state.",
    "Legend:\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR,  = '0' = Bit is cleared. -n = Value at POR,  = x = Bit is unknown",
    "EXAMPLE 23-5: READING A CAN MESSAGE\n```\n; Need to read a pending message from RXB0 buffer. ; To receive any message, filter, mask and RXM1:RXM0 bits in RXB0CON registers must be ; programmed correctly. ; ; Make sure that there is a message pending in RXB0. BTFSS RXB0CON, RXFUL ; Does RXB0 contain a message? BRA NoMessage ; No.  Handle this situation... ; We have verified that a message is pending in RXB0 buffer. ; If this buffer can receive both Standard or Extended Identifier messages, ; identify type of message received. BTFSS RXB0SIDL, EXID ; Is this Extended Identifier? BRA StandardMessage ; No.  This is Standard Identifier message. ; Yes.",
    "EXAMPLE 23-5: READING A CAN MESSAGE\nThis is Extended Identifier message. ; Read all 29-bits of Extended Identifier message. ... ; Now read all data bytes MOVFF RXB0DO, MY_DATA_BYTE1 ... ; Once entire message is read, mark the RXB0 that it is read and no longer FULL. BCF RXB0CON, RXFUL ; This will allow CAN Module to load new messages ; into this buffer. ...\n```",
    "23.2.3.1 Programmable TX/RX and Auto-RTR Buffers\nThe ECAN module contains 6 message buffers that can be programmed as transmit or receive buffers. Any of these buffers can also be programmed to automatically handle RTR messages.",
    "REGISTER 23-22: BnCON: TX/RX BUFFER n CONTROL REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. RXFUL (2), 1 = RXM1. RXFUL (2), 2 = RXRTRRO. RXFUL (2), 3 = FILHIT4. RXFUL (2), 4 = FILHIT3. RXFUL (2), 5 = FILHIT2. RXFUL (2), 6 = FILHIT1. RXFUL (2), 7 = FILHIT0\nbit 7\nbit 7\nbit 6\nbit 0\nRXFUL: Receive Full Status bit (2)",
    "REGISTER 23-22: BnCON: TX/RX BUFFER n CONTROL REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\n1 = Receive buffer contains a received message\n0 = Receive buffer is open to receive a new message\nRXM1: Receive Buffer Mode bit\n1 = Receive all messages including partial and invalid (acceptance filters are ignored)\n0 = Receive all valid messages as per acceptance filters",
    "bit 5 RXRTRRO: Read-Only Remote Transmission Request for Received Message bit\n1 = Received message is a remote transmission request\n0 = Received message is not a remote transmission request",
    "bit 4-0 FILHIT4:FILHIT0: Filter Hit bits\nThese bits indicate which acceptance filter enabled the last message reception into this buffer.\n= Acceptance Filter 15 (RXF15)\n01111\n01110 = Acceptance Filter 14 (RXF14)\n...\n00001 = Acceptance Filter 1 (RXF1)\n00000 = Acceptance Filter 0 (RXF0)\nNote 1: These registers are available in Mode 1 and 2 only.\n2: This bit is set by the CAN module upon receiving a message and must be cleared by software after the buffer is read. As long as RXFUL is set, no new message will be loaded and the buffer will be considered full.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR,  = '0' = Bit is cleared. -n = Value at POR,  = x = Bit is unknown",
    "REGISTER 23-23: [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\nR/W-0, 1 = R-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. TXBIF, 1 = TXABT. TXBIF, 2 = TXLARB. TXBIF, 3 = TXERR. TXBIF, 4 = TXREQ. TXBIF, 5 = RTREN. TXBIF, 6 = TXPRI1. TXBIF, 7 = TXPRI0\nbit 7\nbit 0\nbit 7 TXBIF: Transmit Buffer Interrupt Flag bit (3)\n1 = A message is successfully transmitted\n0 = No message was transmitted\nbit 6 TXABT: Transmission Aborted Status bit\n(3)\n1 = Message was aborted\n0 = Message was not aborted",
    "REGISTER 23-23: [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\nbit 5 TXLARB: Transmission Lost Arbitration Status bit (3)\n1 = Message lost arbitration while being sent\n0 = Message did not lose arbitration while being sent\nbit 4 TXERR: Transmission Error Detected Status bit (3)\n1 = A bus error occurred while the message was being sent\n0 = A bus error did not occur while the message was being sent\nbit 3\nTXREQ: Transmit Request Status bit (2,4)\n1 = Requests sending a message; clears the TXABT, TXLARB and TXERR bits\n0 = Automatically cleared when the message is successfully sent\nbit 2\nRTREN: Automatic Remote Transmission Request Enable bit\n1 = When a remote transmission request is received, TXREQ will be automatically set\n0 = When a remote transmission request is received, TXREQ will be unaffected\nbit 1-0\nTXPRI1:TXPRI0:\nTransmit Priority bits (5)\n11 = Priority Level 3 (highest priority)\n10 = Priority Level 2\n01 = Priority Level 1\n00 = Priority Level 0 (lowest priority)",
    "REGISTER 23-23: [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\nNote 1: These registers are available in Mode 1 and 2 only.\n2: Clearing this bit in software while the bit is set will request a message abort.\n3: This bit is automatically cleared when TXREQ is set.\n4: While TXREQ is set or transmission is in progress, transmit buffer registers remain read-only.\n5: These bits set the order in which the transmit buffer will be transferred. They do not alter the CAN message identifier.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR,  = '0' = Bit is cleared. -n = Value at POR,  = x = Bit is unknown",
    "REGISTER 23-24: BnSIDH: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0\nbit 7-0\nSID10:SID3: Standard Identifier bits (if EXIDE (BnSIDL<3>) = 0 )\nExtended Identifier bits EID28:EID21 (if EXIDE = 1 ).\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 23-24: BnSIDH: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-25: BnSIDH: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN TRANSMIT MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\nSID10, R/W-x = SID9. SID10, R/W-x = SID8. SID10, R/W-x = SID7. SID10, R/W-x = SID6. SID10, R/W-x = SID5. SID10, R/W-x = SID4. SID10, R/W-x = SID3\nbit 7\nbit 0\nbit 7-0 SID10:SID3: Standard Identifier bits (if EXIDE (BnSIDL<3>) = 0 ) Extended Identifier bits EID28:EID21 (if EXIDE = 1 ).",
    "REGISTER 23-25: BnSIDH: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN TRANSMIT MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\nNote 1: These registers are available in Mode 1 and 2 only.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-26: BnSIDL: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, LOW BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = U-0. R-x, 6 = R-x. R-x, 7 = R-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = SRR. SID2, 4 = EXID. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5\nSID2:SID0: Standard Identifier bits (if EXID = 0 )\nExtended Identifier bits EID20:EID18 (if EXID = 1 ).\nbit 4\nSRR: Substitute Remote Transmission Request bit (only when EXID = 1 )\n1 = Remote transmission request occurred\n0 = No remote transmission request occurred",
    "bit 3 EXID: Extended Identifier Enable bit\n1 = Received message is an extended identifier frame (SID10:SID0 are EID28:EID18)\n0 = Received message is a standard identifier frame\nbit 2\nUnimplemented: Read as ' 0 '\nbit 1-0\nEID17:EID16:\nExtended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-27: BnSIDL: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, LOW BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL0<n>) = \uf0a3 \uf0a3 1 ] (1)\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = U-0. R/W-x, 4 = R/W-x. R/W-x, 5 = U-0. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = -. SID2, 4 = EXIDE. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5\nSID2:SID0: Standard Identifier bits (if EXIDE = 0 )\nExtended Identifier bits EID20:EID18 (if EXIDE = 1 ).\nbit 4 Unimplemented: Read as ' 0 '",
    "REGISTER 23-27: BnSIDL: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, LOW BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL0<n>) = \uf0a3 \uf0a3 1 ] (1)\nbit 3\nEXIDE: Extended Identifier Enable bit\n1 = Received message is an extended identifier frame (SID10:SID0 are EID28:EID18)\n0 = Received message is a standard identifier frame",
    "bit 2 Unimplemented: Read as ' 0 '\nbit 1-0 EID17:EID16: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-28: BnEIDH: TX/RX BUFFER n EXTENDED IDENTIFIER REGISTERS, HIGH BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. EID15, 1 = EID14. EID15, 2 = EID13. EID15, 3 = EID12. EID15, 4 = EID11. EID15, 5 = EID10. EID15, 6 = EID9. EID15, 7 = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-29: BnEIDH: TX/RX BUFFER n EXTENDED IDENTIFIER REGISTERS, HIGH BYTE IN TRANSMIT MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 1] (1)\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID15, 1 = EID14. EID15, 2 = EID13. EID15, 3 = EID12. EID15, 4 = EID11. EID15, 5 = EID10. EID15, 6 = EID9. EID15, 7 = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-30: BnEIDL: TX/RX BUFFER n EXTENDED IDENTIFIER REGISTERS, LOW BYTE IN RECEIVE MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL<n>) = 0 ] (1)\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-31: BnEIDL: TX/RX BUFFER n EXTENDED IDENTIFIER REGISTERS, LOW BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL<n>) = \uf0a3 \uf0a3 1 ] (1)\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 7-0\nbit 0\nEID7:EID0:\nExtended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 23-31: BnEIDL: TX/RX BUFFER n EXTENDED IDENTIFIER REGISTERS, LOW BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL<n>) = \uf0a3 \uf0a3 1 ] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-32: BnDm: TX/RX BUFFER n DATA FIELD BYTE m REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 0 ] (1)\nBnDm7, R-x = BnDm6. BnDm7, R-x = BnDm5. BnDm7, R-x = BnDm4. BnDm7, R-x = BnDm3. BnDm7, R-x = BnDm2. BnDm7, R-x = BnDm1. BnDm7, R-x = BnDm0. bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = bit 0\nbit 7-0 BnDm7:BnDm0: Receive Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 3 and 0 < m < 8) Each receive buffer has an array of registers. For example, Receive Buffer 0 has 7 registers: B0D0 to B0D7.",
    "REGISTER 23-32: BnDm: TX/RX BUFFER n DATA FIELD BYTE m REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 0 ] (1)\nNote 1: These registers are available in Mode 1 and 2 only.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-33: BnDm: TX/RX BUFFER n DATA FIELD BYTE m REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 1 ] (1)\nBnDm7, R/W-x = BnDm6. BnDm7, R/W-x = BnDm5. BnDm7, R/W-x = BnDm4. BnDm7, R/W-x = BnDm3. BnDm7, R/W-x = BnDm2. BnDm7, R/W-x = BnDm1. BnDm7, R/W-x = BnDm0\nbit 7\nbit 0\nbit 7-0 BnDm7:BnDm0: Transmit Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 3 and 0 < m < 8) Each transmit buffer has an array of registers. For example, Transmit Buffer 0 has 7 registers: TXB0D0 to TXB0D7.",
    "REGISTER 23-33: BnDm: TX/RX BUFFER n DATA FIELD BYTE m REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 1 ] (1)\nNote 1: These registers are available in Mode 1 and 2 only.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-34: [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL<n>) = 0 ] (1)\nU-0, 1 = R-x. U-0, 2 = R-x. U-0, 3 = R-x. U-0, 4 = R-x. U-0, 5 = R-x. U-0, 6 = R-x. U-0, 7 = R-x. -, 1 = RXRTR. -, 2 = RB1. -, 3 = RB0. -, 4 = DLC3. -, 5 = DLC2. -, 6 = DLC1. -, 7 = DLC0\nbit 7\nbit 0",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6 RXRTR: Receiver Remote Transmission Request bit\n1 = This is a remote transmission request\n0 = This is not a remote transmission request",
    "bit 5\nRB1: Reserved bit 1\nReserved by CAN Spec and read as ' 0 '.\nbit 4\nRB0: Reserved bit 0\nReserved by CAN Spec and read as ' 0 '.",
    "bit 3-0 DLC3:DLC0: Data Length Code bits\n1111 = Reserved\n1110 = Reserved\n1101 = Reserved\n1100 = Reserved\n1011 = Reserved\n1010 = Reserved\n1001 = Reserved\n1000 = Data length = 8 bytes\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 bytes\n0000 = Data length = 0 bytes\nNote 1: These registers are available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-35: [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL<n>) = 1 ] (1)\nU-0, 1 = R/W-x. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = TXRTR. -, 2 = -. -, 3 = -. -, 4 = DLC3. -, 5 = DLC2. -, 6 = DLC1. -, 7 = DLC0\nbit 7\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nTXRTR: Transmitter Remote Transmission Request bit\n1 = Transmitted message will have RTR bit set\n0 = Transmitted message will have RTR bit cleared\nbit 5-4 Unimplemented: Read as ' 0 '\nbit 3-0 DLC3:DLC0: Data Length Code bits\n1111 - 1001 = Reserved\n1000 = Data length = 8 bytes",
    "REGISTER 23-35: [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL<n>) = 1 ] (1)\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 bytes\n0000 = Data length = 0 bytes\nNote 1: These registers are available in Mode 1 and 2 only.\n\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = '0' = Bit is cleared. -n = Value at POR, bit, = x = Bit is unknown",
    "REGISTER 23-36: BSEL0: BUFFER SELECT REGISTER 0 (1)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = U-0. R/W-0, 7 = U-0. B5TXEN, 1 = B4TXEN. B5TXEN, 2 = B3TXEN. B5TXEN, 3 = B2TXEN. B5TXEN, 4 = B1TXEN. B5TXEN, 5 = B0TXEN. B5TXEN, 6 = -. B5TXEN, 7 = -\nbit 7\nbit 0\nbit 7-2\nB5TXEN:B0TXEN: Buffer 5 to Buffer 0 Transmit Enable bit\n1 = Buffer is configured in Transmit mode\n0 = Buffer is configured in Receive mode",
    "REGISTER 23-36: BSEL0: BUFFER SELECT REGISTER 0 (1)\nbit 1-0 Unimplemented: Read as ' 0 '\nNote 1: This register is available in Mode 1 and 2 only.\n.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "23.2.3.2 Message Acceptance Filters and Masks\nThis section describes the message acceptance filters and masks for the CAN receive buffers.",
    "REGISTER 23-37: RXFnSIDH: RECEIVE ACCEPTANCE FILTER n STANDARD IDENTIFIER FILTER REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 15] (1)\nSID10, R/W-x = SID9. SID10, R/W-x = SID8. SID10, R/W-x = SID7. SID10, R/W-x = SID6. SID10, R/W-x = SID5. SID10, R/W-x = SID4. SID10, R/W-x = SID3\nbit 7\nbit 0\nbit 7-0\nSID10:SID3: Standard Identifier Filter bits (if EXIDEN = 0 )\nExtended Identifier Filter bits EID28:EID21 (if EXIDEN = 1 ).\nNote 1: Registers RXF6SIDH:RXF15SIDH are available in Mode 1 and 2 only.",
    "REGISTER 23-37: RXFnSIDH: RECEIVE ACCEPTANCE FILTER n STANDARD IDENTIFIER FILTER REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 15] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-38: RXFnSIDL: RECEIVE ACCEPTANCE FILTER n STANDARD IDENTIFIER FILTER REGISTERS, LOW BYTE [0   n   15] (1) \uf0a3 \uf0a3\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = U-0. R/W-x, 4 = R/W-x. R/W-x, 5 = U-0. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = -. SID2, 4 = EXIDEN (2). SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5 SID2:SID0: Standard Identifier Filter bits (if EXIDEN = 0 )\nExtended Identifier Filter bits EID20:EID18 (if EXIDEN = 1 ).\nbit 4 Unimplemented: Read as ' 0 '",
    "REGISTER 23-38: RXFnSIDL: RECEIVE ACCEPTANCE FILTER n STANDARD IDENTIFIER FILTER REGISTERS, LOW BYTE [0   n   15] (1) \uf0a3 \uf0a3\nbit 3 EXIDEN: Extended Identifier Filter Enable bit (2)\n1 = Filter will only accept extended ID messages\n0 = Filter will only accept standard ID messages",
    "bit 2 Unimplemented: Read as ' 0\n'\nbit 1-0 EID17:EID16: Extended Identifier Filter bits\nNote 1:\nRegisters RXF6SIDL:RXF15SIDL are available in Mode 1 and 2 only.\n- 2: In Mode 0, this bit must be set/cleared as required, irrespective of corresponding mask register value.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-39: RXFnEIDH: RECEIVE ACCEPTANCE FILTER n EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 15] (1)\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID15, 1 = EID14. EID15, 2 = EID13. EID15, 3 = EID12. EID15, 4 = EID11. EID15, 5 = EID10. EID15, 6 = EID9. EID15, 7 = EID8\nbit 7\nbit 7-0\nbit 0\nEID15:EID8:\nExtended Identifier Filter bits\nNote 1: Registers RXF6EIDH:RXF15EIDH are available in Mode 1 and 2 only.",
    "REGISTER 23-39: RXFnEIDH: RECEIVE ACCEPTANCE FILTER n EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 15] (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-40: RXFnEIDL: RECEIVE ACCEPTANCE FILTER n EXTENDED IDENTIFIER REGISTERS, LOW BYTE [0   n   15] (1) \uf0a3 \uf0a3\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier Filter bits\nNote 1: Registers RXF6EIDL:RXF15EIDL are available in Mode 1 and 2 only.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-41: RXMnSIDH: RECEIVE ACCEPTANCE MASK n STANDARD IDENTIFIER MASK REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 1]\nSID10, R/W-x = SID9. SID10, R/W-x = SID8. SID10, R/W-x = SID7. SID10, R/W-x = SID6. SID10, R/W-x = SID5. SID10, R/W-x = SID4. SID10, R/W-x = SID3\nbit 7\nbit 0",
    "bit 7-0 SID10:SID3: Standard Identifier Mask bits or Extended Identifier Mask bits EID28:EID21\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-42: REGISTERS, LOW BYTE [0   n   1] \uf0a3 \uf0a3\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = U-0. R/W-x, 4 = R/W-0. R/W-x, 5 = U-0. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = -. SID2, 4 = EXIDEN (1). SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5\nSID2:SID0: Standard Identifier Mask bits or Extended Identifier Mask bits EID20:EID18\nbit 4\nUnimplemented:\nRead as ' 0 '\nbit 3\nMode 0:\nUnimplemented:\nRead as ' 0 '\nMode 1, 2:\nEXIDEN: Extended Identifier Filter Enable Mask bit (1)",
    "REGISTER 23-42: REGISTERS, LOW BYTE [0   n   1] \uf0a3 \uf0a3\n1 = Messages selected by the EXIDEN bit in RXFnSIDL will be accepted\n0 = Both standard and extended identifier messages will be accepted\nNote 1: This bit is available in Mode 1 and 2 only.\nbit 2\nUnimplemented:\nRead as ' 0 '\nbit 1-0 EID17:EID16: Extended Identifier Mask bits\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-43: RXMnEIDH: RECEIVE ACCEPTANCE MASK n EXTENDED IDENTIFIER MASK REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 1]\nEID15, R/W-x = EID14. EID15, R/W-x = EID13. EID15, R/W-x = EID12. EID15, R/W-x = EID11. EID15, R/W-x = EID10. EID15, R/W-x = EID9. EID15, R/W-x = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier Mask bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-44: RXMnEIDL: RECEIVE ACCEPTANCE MASK n EXTENDED IDENTIFIER MASK REGISTERS, LOW BYTE [0   n   1] \uf0a3 \uf0a3\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier Mask bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-45: RXFCONn: RECEIVE FILTER CONTROL REGISTER n [0   n   1] (1) \uf0a3 \uf0a3\nRXFCON0\nR/W-0\nR/W-0\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nRXF7EN\nRXF6EN\nRXF5EN\nRXF4EN\nRXF3EN\nRXF2EN\nRXF1EN\nRXF0EN\nRXFCON1\nR/W-0\nR/W-0\nR/W-0\nR/W-1\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nRXF15EN\nRXF14EN\nRXF13EN\nRXF12EN\nRXF11EN\nRXF10EN\nRXF9EN\nRXF8EN\nbit 7\nbit 0\nbit 7-0\nRXFnEN:\nReceive Filter n Enable bits\n0 = Filter is disabled\n1 = Filter is enabled\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:\nRegisters 23-46 through 23-51are writable in Configuration mode only.",
    "REGISTER 23-46: SDFLC: STANDARD DATA BYTES FILTER LENGTH COUNT REGISTER (1)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = FLC4. -, 4 = FLC3. -, 5 = FLC2. -, 6 = FLC1. -, 7 = FLC0\nbit 7\nbit 0\nbit 7-5 Unimplemented: Read as ' 0 '\nbit 4-0\nFLC4:FLC0:\nFilter Length Count bits\nMode 0:\nNot used; forced to '\n00000 '.\n00000 10010 - = 0 18 bits are available for standard data byte filter. Actual number of bits used depends on DLC3:DLC0 bits (RXBnDLC<3:0> or BnDLC<3:0> if con-",
    "REGISTER 23-46: SDFLC: STANDARD DATA BYTES FILTER LENGTH COUNT REGISTER (1)\nfigured as RX buffer) of message being received.\nIf DLC3:DLC0= 0000 No bits will be compared with incoming data bits\nIf DLC3:DLC0= 0001 Up to 8 data bits of RXFnEID<7:0>, as determined by FLC2:FLC0, will be compared with the corresponding number of data bits of the incoming message\nIf DLC3:DLC0= 0010\nUp to 16 data bits of RXFnEID<15:0>, as determined by FLC3:FLC0, will be compared with the corresponding number of data bits of the incom- ing message\nIf DLC3:DLC0= 0011 Up to 18 data bits of RXFnEID<17:0>, as determined by FLC4:FLC0, will\nbe compared with the corresponding number of data bits of the incom- ing message\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nRXFBCON0, R/W-0 = F1BP_3. RXFBCON0, R/W-0 = F1BP_2. RXFBCON0, R/W-0 = F1BP_1. RXFBCON0, R/W-0 = F1BP_0. RXFBCON0, R/W-0 = F0BP_3. RXFBCON0, R/W-0 = F0BP_2. RXFBCON0, R/W-0 = F0BP_1. RXFBCON0, R/W-0 = F0BP_0. RXFBCON1, R/W-0 = R/W-0. RXFBCON1, R/W-0 = R/W-0. RXFBCON1, R/W-0 = R/W-0. RXFBCON1, R/W-0 = R/W-1. RXFBCON1, R/W-0 =",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nR/W-0. RXFBCON1, R/W-0 = R/W-0. RXFBCON1, R/W-0 = R/W-0. RXFBCON1, R/W-0 = R/W-1. RXFBCON1, R/W-0 = F3BP_3. RXFBCON1, R/W-0 = F3BP_2. RXFBCON1, R/W-0 = F3BP_1. RXFBCON1, R/W-0 = F3BP_0. RXFBCON1, R/W-0 = F2BP_3. RXFBCON1, R/W-0 = F2BP_2. RXFBCON1, R/W-0 = F2BP_1. RXFBCON1, R/W-0 = F2BP_0. RXFBCON2, R/W-0 = R/W-0. RXFBCON2,",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nR/W-0 = R/W-0. RXFBCON2, R/W-0 = R/W-0. RXFBCON2, R/W-0 = R/W-1. RXFBCON2, R/W-0 = R/W-0. RXFBCON2, R/W-0 = R/W-0. RXFBCON2, R/W-0 = R/W-0. RXFBCON2, R/W-0 = R/W-1. RXFBCON2, R/W-0 = F5BP_3. RXFBCON2, R/W-0 = F5BP_2. RXFBCON2, R/W-0 = F5BP_1. RXFBCON2, R/W-0 = F5BP_0. RXFBCON2, R/W-0 = F4BP_3. RXFBCON2, R/W-0 = F4BP_2.",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nRXFBCON2, R/W-0 = F4BP_1. RXFBCON2, R/W-0 = F4BP_0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = F7BP_3. RXFBCON3, R/W-0 = F7BP_2. RXFBCON3, R/W-0 =",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nF7BP_1. RXFBCON3, R/W-0 = F7BP_0. RXFBCON3, R/W-0 = F6BP_3. RXFBCON3, R/W-0 = F6BP_2. RXFBCON3, R/W-0 = F6BP_1. RXFBCON3, R/W-0 = F6BP_0. RXFBCON4, R/W-0 = R/W-0. RXFBCON4, R/W-0 = R/W-0. RXFBCON4, R/W-0 = R/W-0. RXFBCON4, R/W-0 = R/W-0. RXFBCON4, R/W-0 = R/W-0. RXFBCON4, R/W-0 = R/W-0. RXFBCON4, R/W-0 = R/W-0. RXFBCON4,",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nR/W-0 = R/W-0. RXFBCON4, R/W-0 = F9BP_3. RXFBCON4, R/W-0 = F9BP_2. RXFBCON4, R/W-0 = F9BP_1. RXFBCON4, R/W-0 = F9BP_0. RXFBCON4, R/W-0 = F8BP_3. RXFBCON4, R/W-0 = F8BP_2. RXFBCON4, R/W-0 = F8BP_1. RXFBCON4, R/W-0 = F8BP_0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 =",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nR/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = F11BP_3. , R/W-0 = F11BP_2. , R/W-0 = F11BP_1. , R/W-0 = F11BP_0. , R/W-0 = F10BP_3. , R/W-0 = F10BP_2. , R/W-0 = F10BP_1. , R/W-0 = F10BP_0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. ,",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nR/W-0 = R/W-0. , R/W-0 = F13BP_3. , R/W-0 = F13BP_2. , R/W-0 = F13BP_1. , R/W-0 = F13BP_0. , R/W-0 = F12BP_3. , R/W-0 = F12BP_2. , R/W-0 = F12BP_1. , R/W-0 = F12BP_0. RXFBCON7, R/W-0 = R/W-0. RXFBCON7, R/W-0 = R/W-0. RXFBCON7, R/W-0 = R/W-0. RXFBCON7, R/W-0 = R/W-0. RXFBCON7, R/W-0 = R/W-0. RXFBCON7, R/W-0 = R/W-0.",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nRXFBCON7, R/W-0 = R/W-0. RXFBCON7, R/W-0 = R/W-0. RXFBCON7, R/W-0 = F15BP_3. RXFBCON7, R/W-0 = F15BP_2. RXFBCON7, R/W-0 = F15BP_1. RXFBCON7, R/W-0 = F15BP_0. RXFBCON7, R/W-0 = F14BP_3. RXFBCON7, R/W-0 = F14BP_2. RXFBCON7, R/W-0 = F14BP_1. RXFBCON7, R/W-0 = F14BP_0. , R/W-0 = bit 7. , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\n= . , R/W-0 = . , R/W-0 = bit 0\nbit 7-0 FnBP_3:FnBP_0: Filter n Buffer Pointer Nibble bits\n0000 = Filter n is associated with RXB0\n0001 = Filter n is associated with RXB1\n0010 = Filter n is associated with B0\n0011 = Filter n is associated with B1\n...\n0111 = Filter n is associated with B5\n1111-1000 = Reserved\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-48: MSEL0: MASK SELECT REGISTER 0 (1)\nFIL3_1, R/W-1 = FIL3_0. FIL3_1, R/W-0 = FIL2_1. FIL3_1, R/W-1 = FIL2_0. FIL3_1, R/W-0 = FIL1_1. FIL3_1, R/W-0 = FIL1_0. FIL3_1, R/W-0 = FIL0_1. FIL3_1, R/W-0 = FIL0_0\nbit 7\nbit 0\nbit 7-6 FIL3_1:FIL3_0: Filter 3 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 5-4 FIL2_1:FIL2_0: Filter 2 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 3-2 FIL1_1:FIL1_0: Filter 1 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 1-0\nFIL0_1:FIL0_0: Filter 0 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-49: MSEL1: MASK SELECT REGISTER 1 (1)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-1. FIL7_1, 1 = FIL7_0. FIL7_1, 2 = FIL6_1. FIL7_1, 3 = FIL6_0. FIL7_1, 4 = FIL5_1. FIL7_1, 5 = FIL5_0. FIL7_1, 6 = FIL4_1. FIL7_1, 7 = FIL4_0\nbit 7\nbit 0\nbit 7-6 FIL7_1:FIL7_0: Filter 7 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "REGISTER 23-49: MSEL1: MASK SELECT REGISTER 1 (1)\nbit 5-4 FIL6_1:FIL6_0: Filter 6 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 3-2 FIL5_1:FIL5_0: Filter 5 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 1-0\nFIL4_1:FIL4_0: Filter 4 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-50: MSEL2: MASK SELECT REGISTER 2 (1)\nFIL11_1, R/W-0 = FIL11_0. FIL11_1, R/W-0 = FIL10_1. FIL11_1, R/W-0 = FIL10_0. FIL11_1, R/W-0 = FIL9_1. FIL11_1, R/W-0 = FIL9_0. FIL11_1, R/W-0 = FIL8_1. FIL11_1, R/W-0 = FIL8_0\nbit 7\nbit 0\nbit 7-6 FIL11_1:FIL11_0: Filter 11 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 5-4 FIL10_1:FIL10_0: Filter 10 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 3-2 FIL9_1:FIL9_0: Filter 9 Select bits 1 and 0\n11 = No mask",
    "REGISTER 23-50: MSEL2: MASK SELECT REGISTER 2 (1)\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 1-0\nFIL8_1:FIL8_0: Filter 8 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-51: MSEL3: MASK SELECT REGISTER 3 (1)\nFIL15_1, R/W-0 = FIL15_0. FIL15_1, R/W-0 = FIL14_1. FIL15_1, R/W-0 = FIL14_0. FIL15_1, R/W-0 = FIL13_1. FIL15_1, R/W-0 = FIL13_0. FIL15_1, R/W-0 = FIL12_1. FIL15_1, R/W-0 = FIL12_0\nbit 7\nbit 0\nbit 7-6 FIL15_1:FIL15_0: Filter 15 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 5-4 FIL14_1:FIL14_0: Filter 14 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 3-2 FIL13_1:FIL13_0: Filter 13 Select bits 1 and 0\n11 = No mask",
    "REGISTER 23-51: MSEL3: MASK SELECT REGISTER 3 (1)\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 1-0\nFIL12_1:FIL12_0:\nFilter 12 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "23.2.4 CAN BAUD RATE REGISTERS\nThis section describes the CAN Baud Rate registers.\nNote:, 1 = These registers are writable in Configuration mode only.",
    "REGISTER 23-52: BRGCON1: BAUD RATE CONTROL REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. SJW1, 1 = SJW0. SJW1, 2 = BRP5. SJW1, 3 = BRP4. SJW1, 4 = BRP3. SJW1, 5 = BRP2. SJW1, 6 = BRP1. SJW1, 7 = BRP0\nbit 7\nbit 0\nbit 7-6 SJW1:SJW0: Synchronized Jump Width bits\n11 = Synchronization jump width time = 4 x TQ\n10 = Synchronization jump width time = 3 x TQ\n01 = Synchronization jump width time = 2 x TQ",
    "REGISTER 23-52: BRGCON1: BAUD RATE CONTROL REGISTER 1\n00 = Synchronization jump width time = 1 x TQ\nBRP5:BRP0: Baud Rate Prescaler bits\n111111 = TQ = (2 x 64)/FOSC\n111110 = TQ = (2 x 63)/FOSC\n:\n:\n000001 = TQ = (2 x 2)/FOSC\n000000\n= TQ = (2 x 1)/FOSC",
    "Legend:\nR = Readable bit\n-n = Value at POR\nbit 5-0\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "REGISTER 23-53: BRGCON2: BAUD RATE CONTROL REGISTER 2\nSEG2PHTS, R/W-0 = SAM. SEG2PHTS, R/W-0 = SEG1PH2. SEG2PHTS, R/W-0 = SEG1PH1. SEG2PHTS, R/W-0 = SEG1PH0. SEG2PHTS, R/W-0 = PRSEG2. SEG2PHTS, R/W-0 = PRSEG1. SEG2PHTS, R/W-0 = PRSEG0\nbit 7",
    "bit 7\nbit 0\nSEG2PHTS: Phase Segment 2 Time Select bit\n1 = Freely programmable\n0 = Maximum of PHEG1 or Information Processing Time (IPT), whichever is greater",
    "bit 6 SAM: Sample of the CAN bus Line bit\n1 = Bus line is sampled three times prior to the sample point\n0 = Bus line is sampled once at the sample point",
    "bit 5-3 SEG1PH2:SEG1PH0: Phase Segment 1 bits\n111 = Phase Segment 1 time = 8 x TQ\n110 = Phase Segment 1 time = 7 x TQ\n101 = Phase Segment 1 time = 6 x TQ\n100 = Phase Segment 1 time = 5 x TQ\n011 = Phase Segment 1 time = 4 x TQ\n010 = Phase Segment 1 time = 3 x TQ\n001 = Phase Segment 1 time = 2 x TQ\n000 = Phase Segment 1 time = 1 x TQ",
    "bit 2-0 PRSEG2:PRSEG0: Propagation Time Select bits\n111 = Propagation time = 8 x TQ\n110 = Propagation time = 7 x TQ\n101 = Propagation time = 6 x TQ\n100 = Propagation time = 5 x TQ\n011 = Propagation time = 4 x TQ\n010 = Propagation time = 3 x TQ\n001 = Propagation time = 2 x TQ\n000 = Propagation time = 1 x TQ",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-54: BRGCON3: BAUD RATE CONTROL REGISTER 3\nR/W-0\nR/W-0\nU-0\nU-0\nU-0\nR/W-0\nR/W-0\nR/W-0\nWAKDIS\nWAKFIL\n-\n-\n-\nSEG2PH2\n(1)\nSEG2PH1\n(1)\nSEG2PH0 (1)\nbit 7\nbit 0\nbit 7\nWAKDIS: Wake-up Disable bit\n1 = Disable CAN bus activity wake-up feature\n0 = Enable CAN bus activity wake-up feature\nbit 6 WAKFIL: Selects CAN bus Line Filter for Wake-up bit\n1 = Use CAN bus line filter for wake-up\n0 = CAN bus line filter is not used for wake-up\nbit 5-3 Unimplemented: Read as ' 0 '\nbit 2-0\nSEG2PH2:SEG2PH0:\nPhase Segment 2 Time Select bits\n(1)\n111 = Phase Segment 2 time = 8 x TQ\n110 = Phase Segment 2 time = 7 x TQ\n101 = Phase Segment 2 time = 6 x TQ\n100 = Phase Segment 2 time = 5 x TQ\n011 = Phase Segment 2 time = 4 x TQ",
    "REGISTER 23-54: BRGCON3: BAUD RATE CONTROL REGISTER 3\n010 = Phase Segment 2 time = 3 x TQ\n001 = Phase Segment 2 time = 2 x TQ\n000 = Phase Segment 2 time = 1 x TQ\nNote 1: Ignored if SEG2PHTS bit (BRGCON2<7>) is ' 0 '.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "23.2.5 CAN MODULE I/O CONTROL REGISTER\nThis register controls the operation of the CAN module's I/O pins in relation to the rest of the microcontroller.",
    "REGISTER 23-55: CIOCON: CAN I/O CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = U-0. -, 1 = -. -, 2 = ENDRHI (1). -, 3 = CANCAP. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = -\nbit 7\nbit 7-6\nbit 5\nbit 4\nbit 3-0\nbit 0\nUnimplemented: Read as ' 0 '\nENDRHI: Enable Drive High bit (1)\n1 = CANTX pin will drive VDD when recessive\n0 = CANTX pin will be tri-state when recessive\nAlways set this bit when using differential bus to avoid signal crosstalk in CANTX\nNote 1: from other nearby pins.\nCANCAP: CAN Message Receive Capture Enable bit\n1 = Enable CAN capture, CAN message receive signal replaces input on RC2/CCP1",
    "REGISTER 23-55: CIOCON: CAN I/O CONTROL REGISTER\n0 = Disable CAN capture, RC2/CCP1 input to CCP1 module\nUnimplemented: Read as ' 0 '",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "23.2.6 CAN INTERRUPT REGISTERS\nThe registers in this section are the same as described\nin Section 9.0 'Interrupts'\n. They are duplicated here\nfor convenience.",
    "REGISTER 23-56: PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\nMode 0, R/W-0 = IRXIF. Mode 0, R/W-0 = WAKIF. Mode 0, R/W-0 = ERRIF. Mode 0, R/W-0 = TXB2IF. Mode 0, R/W-0 = TXB1IF (1). Mode 0, R/W-0 = TXB0IF (1). Mode 0, R/W-0 = RXB1IF. Mode 0, R/W-0 = RXB0IF. Mode 1, 2, R/W-0 = R/W-0. Mode 1, 2, R/W-0 = R/W-0. Mode 1, 2, R/W-0 = R/W-0. Mode 1, 2, R/W-0 = R/W-0. Mode 1, 2, R/W-0 = R/W-0. Mode 1, 2, R/W-0 = R/W-0. Mode 1, 2, R/W-0 = R/W-0. Mode 1,",
    "REGISTER 23-56: PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\n2, R/W-0 = R/W-0. Mode 1, 2, R/W-0 = IRXIF. Mode 1, 2, R/W-0 = WAKIF. Mode 1, 2, R/W-0 = ERRIF. Mode 1, 2, R/W-0 = TXBnIF. Mode 1, 2, R/W-0 = TXB1IF (1). Mode 1, 2, R/W-0 = TXB0IF (1). Mode 1, 2, R/W-0 = RXBnIF. Mode 1, 2, R/W-0 = FIFOWMIF\nbit 7\nbit 0",
    "bit 7\nIRXIF: CAN Invalid Received Message Interrupt Flag bit\n1 = An invalid message has occurred on the CAN bus\n0 = No invalid message on CAN bus\nWAKIF: CAN bus Activity Wake-up Interrupt Flag bit",
    "bit 6\n1 = Activity on CAN bus has occurred\n0 = No activity on CAN bus",
    "bit 5 ERRIF:\nCAN bus Error Interrupt Flag bit\n1 = An error has occurred in the CAN module (multiple sources)\n0 = No CAN module errors",
    "bit 4 When CAN is in Mode 0:\nTXB2IF: CAN Transmit Buffer 2 Interrupt Flag bit\n1 = Transmit Buffer 2 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 2 has not completed transmission of a message\nWhen CAN is in Mode 1 or 2:\nTXBnIF: Any Transmit Buffer Interrupt Flag bit\n1 = One or more transmit buffers have completed transmission of a message and may be reloaded\n0 = No transmit buffer is ready for reload bit 3 TXB1IF: CAN Transmit Buffer 1 Interrupt Flag bit (1)\n1 = Transmit Buffer 1 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 1 has not completed transmission of a message",
    "bit 2 TXB0IF: CAN Transmit Buffer 0 Interrupt Flag bit (1)\n1 = Transmit Buffer 0 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 0 has not completed transmission of a message",
    "bit 1 When CAN is in Mode 0:\nRXB1IF: CAN Receive Buffer 1 Interrupt Flag bit\n1 = Receive Buffer 1 has received a new message\n0 = Receive Buffer 1 has not received a new message",
    "When CAN is in Mode 1 or 2:\nRXBnIF: Any Receive Buffer Interrupt Flag bit\n- 1 = One or more receive buffers has received a new message\n0 = No receive buffer has received a new message",
    "bit 0 When CAN is in Mode 0:\nRXB0IF: CAN Receive Buffer 0 Interrupt Flag bit\n1 = Receive Buffer 0 has received a new message\n0 = Receive Buffer 0 has not received a new message\nWhen CAN is in Mode 1:\nUnimplemented: Read as ' 0 '",
    "When CAN is in Mode 2:\nFIFOWMIF: FIFO Watermark Interrupt Flag bit\n1 = FIFO high watermark is reached\n0 = FIFO high watermark is not reached\nNote 1:\nIn CAN Mode 1 and 2, this bit is forced to ' 0 '.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared x = Bit is unknown",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\nMode 1, 2, R/W-0.IRXIE = R/W-0. Mode 1, 2, R/W-0.WAKIE = R/W-0. Mode 1, 2, R/W-0.ERRIE = R/W-0. Mode 1, 2, R/W-0.TXB2IE = R/W-0. Mode 1, 2, R/W-0.TXB1IE (1) = R/W-0. Mode 1, 2, R/W-0.TXB0IE (1) = R/W-0. Mode 1, 2, R/W-0.RXB1IE = R/W-0. Mode 1, 2, R/W-0.RXB0IE = R/W-0. Mode 1, 2, R/W-0.IRXIE = IRXIE. Mode 1, 2, R/W-0.WAKIE = WAKIE. Mode 1, 2, R/W-0.ERRIE = ERRIE. Mode 1, 2, R/W-0.TXB2IE",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\n= TXBnIE. Mode 1, 2, R/W-0.TXB1IE (1) = TXB1IE (1). Mode 1, 2, R/W-0.TXB0IE (1) = TXB0IE (1). Mode 1, 2, R/W-0.RXB1IE = RXBnIE. Mode 1, 2, R/W-0.RXB0IE = FIFOWMIE. Mode 1, 2, R/W-0.IRXIE = bit 7. Mode 1, 2, R/W-0.WAKIE = . Mode 1, 2, R/W-0.ERRIE = . Mode 1, 2, R/W-0.TXB2IE = . Mode 1, 2, R/W-0.TXB1IE (1) = . Mode 1, 2, R/W-0.TXB0IE (1) = . Mode 1, 2, R/W-0.RXB1IE = . Mode 1, 2, R/W-0.RXB0IE = bit",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\n0. bit 7, R/W-0.IRXIE = IRXIE: CAN Invalid Received Message Interrupt Enable bit 1 = Enable invalid message received interrupt 0 = Disable invalid message received interrupt. bit 7, R/W-0.WAKIE = IRXIE: CAN Invalid Received Message Interrupt Enable bit 1 = Enable invalid message received interrupt 0 = Disable invalid message received interrupt. bit 7, R/W-0.ERRIE = IRXIE: CAN Invalid Received Message Interrupt Enable bit 1 = Enable invalid message received interrupt 0 = Disable invalid message received interrupt. bit 7, R/W-0.TXB2IE = IRXIE: CAN Invalid Received Message Interrupt Enable bit 1 = Enable invalid message received interrupt 0 = Disable invalid message received interrupt. bit 7, R/W-0.TXB1IE (1) = IRXIE: CAN Invalid Received Message Interrupt Enable bit 1 = Enable invalid message received interrupt 0 = Disable invalid message received interrupt. bit 7, R/W-0.TXB0IE (1) = IRXIE: CAN Invalid Received Message Interrupt Enable bit 1 = Enable invalid message received interrupt 0 = Disable invalid message received interrupt. bit",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\n7, R/W-0.RXB1IE = IRXIE: CAN Invalid Received Message Interrupt Enable bit 1 = Enable invalid message received interrupt 0 = Disable invalid message received interrupt. bit 7, R/W-0.RXB0IE = IRXIE: CAN Invalid Received Message Interrupt Enable bit 1 = Enable invalid message received interrupt 0 = Disable invalid message received interrupt. bit 6, R/W-0.IRXIE = WAKIE: CAN bus Activity Wake-up Interrupt Enable bit 1 = Enable bus activity wake-up interrupt 0 = Disable bus activity wake-up interrupt. bit 6, R/W-0.WAKIE = WAKIE: CAN bus Activity Wake-up Interrupt Enable bit 1 = Enable bus activity wake-up interrupt 0 = Disable bus activity wake-up interrupt. bit 6, R/W-0.ERRIE = WAKIE: CAN bus Activity Wake-up Interrupt Enable bit 1 = Enable bus activity wake-up interrupt 0 = Disable bus activity wake-up interrupt. bit 6, R/W-0.TXB2IE = WAKIE: CAN bus Activity Wake-up Interrupt Enable bit 1 = Enable bus activity",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\nwake-up interrupt 0 = Disable bus activity wake-up interrupt. bit 6, R/W-0.TXB1IE (1) = WAKIE: CAN bus Activity Wake-up Interrupt Enable bit 1 = Enable bus activity wake-up interrupt 0 = Disable bus activity wake-up interrupt. bit 6, R/W-0.TXB0IE (1) = WAKIE: CAN bus Activity Wake-up Interrupt Enable bit 1 = Enable bus activity wake-up interrupt 0 = Disable bus activity wake-up interrupt. bit 6, R/W-0.RXB1IE = WAKIE: CAN bus Activity Wake-up Interrupt Enable bit 1 = Enable bus activity wake-up interrupt 0 = Disable bus activity wake-up interrupt. bit 6, R/W-0.RXB0IE = WAKIE: CAN bus Activity Wake-up Interrupt Enable bit 1 = Enable bus activity wake-up interrupt 0 = Disable bus activity wake-up interrupt. bit 5, R/W-0.IRXIE = ERRIE: CAN bus Error Interrupt Enable bit 1 = Enable CAN bus error interrupt = Disable CAN bus error interrupt. bit",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\n5, R/W-0.WAKIE = ERRIE: CAN bus Error Interrupt Enable bit 1 = Enable CAN bus error interrupt = Disable CAN bus error interrupt. bit 5, R/W-0.ERRIE = ERRIE: CAN bus Error Interrupt Enable bit 1 = Enable CAN bus error interrupt = Disable CAN bus error interrupt. bit 5, R/W-0.TXB2IE = ERRIE: CAN bus Error Interrupt Enable bit 1 = Enable CAN bus error interrupt = Disable CAN bus error interrupt. bit 5, R/W-0.TXB1IE (1) = ERRIE: CAN bus Error Interrupt Enable bit 1 = Enable CAN bus error interrupt = Disable CAN bus error interrupt. bit 5, R/W-0.TXB0IE (1) = ERRIE: CAN bus Error Interrupt Enable bit 1 = Enable CAN bus error interrupt = Disable CAN bus error interrupt. bit 5, R/W-0.RXB1IE = ERRIE: CAN bus Error Interrupt Enable bit 1 = Enable CAN bus error interrupt = Disable CAN bus error interrupt. bit 5, R/W-0.RXB0IE",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\n= ERRIE: CAN bus Error Interrupt Enable bit 1 = Enable CAN bus error interrupt = Disable CAN bus error interrupt. bit 4, R/W-0.IRXIE = 0 When CAN is in Mode 0: TXB2IE: CAN Transmit Buffer 2 Interrupt Enable bit 1 = Enable Transmit Buffer 2 interrupt 0 = Disable Transmit Buffer 2 interrupt When CAN is in Mode 1 or 2: TXBnIE: CAN Transmit Buffer Interrupts Enable bit 1 = Enable transmit buffer interrupt; individual interrupt is enabled by TXBIE and BIE0 = Disable all transmit buffer interrupts. bit 4, R/W-0.WAKIE = 0 When CAN is in Mode 0: TXB2IE: CAN Transmit Buffer 2 Interrupt Enable bit 1 = Enable Transmit Buffer 2 interrupt 0 = Disable Transmit Buffer 2 interrupt When CAN is in Mode 1 or 2: TXBnIE: CAN Transmit Buffer Interrupts Enable bit 1 = Enable transmit buffer interrupt; individual interrupt is enabled by TXBIE and BIE0 = Disable all transmit buffer interrupts. bit 4, R/W-0.ERRIE = 0 When CAN is in Mode 0: TXB2IE: CAN Transmit Buffer 2 Interrupt Enable",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\nbit 1 = Enable Transmit Buffer 2 interrupt 0 = Disable Transmit Buffer 2 interrupt When CAN is in Mode 1 or 2: TXBnIE: CAN Transmit Buffer Interrupts Enable bit 1 = Enable transmit buffer interrupt; individual interrupt is enabled by TXBIE and BIE0 = Disable all transmit buffer interrupts. bit 4, R/W-0.TXB2IE = 0 When CAN is in Mode 0: TXB2IE: CAN Transmit Buffer 2 Interrupt Enable bit 1 = Enable Transmit Buffer 2 interrupt 0 = Disable Transmit Buffer 2 interrupt When CAN is in Mode 1 or 2: TXBnIE: CAN Transmit Buffer Interrupts Enable bit 1 = Enable transmit buffer interrupt; individual interrupt is enabled by TXBIE and BIE0 = Disable all transmit buffer interrupts. bit 4, R/W-0.TXB1IE (1) = 0 When CAN is in Mode 0: TXB2IE: CAN Transmit Buffer 2 Interrupt Enable bit 1 = Enable Transmit Buffer 2 interrupt 0 = Disable Transmit Buffer 2 interrupt When CAN is in Mode 1 or 2: TXBnIE: CAN Transmit Buffer Interrupts Enable bit 1 = Enable transmit buffer interrupt; individual interrupt is enabled by",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\nTXBIE and BIE0 = Disable all transmit buffer interrupts. bit 4, R/W-0.TXB0IE (1) = 0 When CAN is in Mode 0: TXB2IE: CAN Transmit Buffer 2 Interrupt Enable bit 1 = Enable Transmit Buffer 2 interrupt 0 = Disable Transmit Buffer 2 interrupt When CAN is in Mode 1 or 2: TXBnIE: CAN Transmit Buffer Interrupts Enable bit 1 = Enable transmit buffer interrupt; individual interrupt is enabled by TXBIE and BIE0 = Disable all transmit buffer interrupts. bit 4, R/W-0.RXB1IE = 0 When CAN is in Mode 0: TXB2IE: CAN Transmit Buffer 2 Interrupt Enable bit 1 = Enable Transmit Buffer 2 interrupt 0 = Disable Transmit Buffer 2 interrupt When CAN is in Mode 1 or 2: TXBnIE: CAN Transmit Buffer Interrupts Enable bit 1 = Enable transmit buffer interrupt; individual interrupt is enabled by TXBIE and BIE0 = Disable all transmit buffer interrupts. bit 4, R/W-0.RXB0IE = 0 When CAN is in Mode 0: TXB2IE: CAN Transmit Buffer 2 Interrupt",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\nEnable bit 1 = Enable Transmit Buffer 2 interrupt 0 = Disable Transmit Buffer 2 interrupt When CAN is in Mode 1 or 2: TXBnIE: CAN Transmit Buffer Interrupts Enable bit 1 = Enable transmit buffer interrupt; individual interrupt is enabled by TXBIE and BIE0 = Disable all transmit buffer interrupts. bit 3, R/W-0.IRXIE = TXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 1 interrupt. bit 3, R/W-0.WAKIE = TXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 1 interrupt. bit 3, R/W-0.ERRIE = TXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 1 interrupt. bit 3, R/W-0.TXB2IE = TXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 1 interrupt. bit 3, R/W-0.TXB1IE (1) = TXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 1",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\ninterrupt. bit 3, R/W-0.TXB0IE (1) = TXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 1 interrupt. bit 3, R/W-0.RXB1IE = TXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 1 interrupt. bit 3, R/W-0.RXB0IE = TXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 1 interrupt. bit 2, R/W-0.IRXIE = TXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 0 interrupt = Disable Transmit Buffer 0 interrupt. bit 2, R/W-0.WAKIE = TXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 0 interrupt = Disable Transmit Buffer 0 interrupt. bit 2, R/W-0.ERRIE = TXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 0 interrupt = Disable Transmit Buffer 0 interrupt.",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\nbit 2, R/W-0.TXB2IE = TXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 0 interrupt = Disable Transmit Buffer 0 interrupt. bit 2, R/W-0.TXB1IE (1) = TXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 0 interrupt = Disable Transmit Buffer 0 interrupt. bit 2, R/W-0.TXB0IE (1) = TXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 0 interrupt = Disable Transmit Buffer 0 interrupt. bit 2, R/W-0.RXB1IE = TXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 0 interrupt = Disable Transmit Buffer 0 interrupt. bit 2, R/W-0.RXB0IE = TXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1) 1 = Enable Transmit Buffer 0 interrupt = Disable Transmit Buffer 0 interrupt. bit 1, R/W-0.IRXIE = 0 When CAN is",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\nin Mode 0: RXB1IE: CAN Receive Buffer 1 Interrupt Enable bit 1 = Enable Receive Buffer 1 interrupt 0 = Disable Receive Buffer 1 interrupt When CAN is in Mode 1 or 2: RXBnIE: CAN Receive Buffer Interrupts Enable bit. bit 1, R/W-0.WAKIE = 0 When CAN is in Mode 0: RXB1IE: CAN Receive Buffer 1 Interrupt Enable bit 1 = Enable Receive Buffer 1 interrupt 0 = Disable Receive Buffer 1 interrupt When CAN is in Mode 1 or 2: RXBnIE: CAN Receive Buffer Interrupts Enable bit. bit 1, R/W-0.ERRIE = 0 When CAN is in Mode 0: RXB1IE: CAN Receive Buffer 1 Interrupt Enable bit 1 = Enable Receive Buffer 1 interrupt 0 = Disable Receive Buffer 1 interrupt When CAN is in Mode 1 or 2: RXBnIE: CAN Receive Buffer Interrupts Enable bit. bit 1, R/W-0.TXB2IE = 0 When CAN is in Mode 0: RXB1IE: CAN Receive Buffer 1 Interrupt Enable bit 1 = Enable Receive Buffer 1 interrupt 0 = Disable Receive Buffer 1 interrupt",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\nWhen CAN is in Mode 1 or 2: RXBnIE: CAN Receive Buffer Interrupts Enable bit. bit 1, R/W-0.TXB1IE (1) = 0 When CAN is in Mode 0: RXB1IE: CAN Receive Buffer 1 Interrupt Enable bit 1 = Enable Receive Buffer 1 interrupt 0 = Disable Receive Buffer 1 interrupt When CAN is in Mode 1 or 2: RXBnIE: CAN Receive Buffer Interrupts Enable bit. bit 1, R/W-0.TXB0IE (1) = 0 When CAN is in Mode 0: RXB1IE: CAN Receive Buffer 1 Interrupt Enable bit 1 = Enable Receive Buffer 1 interrupt 0 = Disable Receive Buffer 1 interrupt When CAN is in Mode 1 or 2: RXBnIE: CAN Receive Buffer Interrupts Enable bit. bit 1, R/W-0.RXB1IE = 0 When CAN is in Mode 0: RXB1IE: CAN Receive Buffer 1 Interrupt Enable bit 1 = Enable Receive Buffer 1 interrupt 0 = Disable Receive Buffer 1 interrupt When CAN is in Mode 1 or 2: RXBnIE: CAN Receive Buffer Interrupts Enable",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\nbit. bit 1, R/W-0.RXB0IE = 0 When CAN is in Mode 0: RXB1IE: CAN Receive Buffer 1 Interrupt Enable bit 1 = Enable Receive Buffer 1 interrupt 0 = Disable Receive Buffer 1 interrupt When CAN is in Mode 1 or 2: RXBnIE: CAN Receive Buffer Interrupts Enable bit. bit 0, R/W-0.IRXIE = When CAN RXB0IE:. bit 0, R/W-0.WAKIE = is in Mode CAN Receive. bit 0, R/W-0.ERRIE = 0: Buffer 0. bit 0, R/W-0.TXB2IE = Interrupt. bit 0, R/W-0.TXB1IE (1) = Enable bit. bit 0, R/W-0.TXB0IE (1) = When CAN RXB0IE:. bit 0, R/W-0.RXB1IE = When CAN RXB0IE:. bit 0, R/W-0.RXB0IE = When CAN RXB0IE:. ,",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\nR/W-0.IRXIE = Legend: U = Unimplemented bit, read as '0'. , R/W-0.WAKIE = Legend: U = Unimplemented bit, read as '0'. , R/W-0.ERRIE = Legend: U = Unimplemented bit, read as '0'. , R/W-0.TXB2IE = Legend: U = Unimplemented bit, read as '0'. , R/W-0.TXB1IE (1) = Legend: U = Unimplemented bit, read as '0'. , R/W-0.TXB0IE (1) = Legend: U = Unimplemented bit, read as '0'. , R/W-0.RXB1IE = Legend: U = Unimplemented bit, read as '0'. , R/W-0.RXB0IE = Legend: U = Unimplemented bit, read as '0'. , R/W-0.IRXIE = R",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\n= Readable bit -n. , R/W-0.WAKIE = = Value at POR. , R/W-0.ERRIE = W=Writable bit '1' = Bit is set. , R/W-0.TXB2IE = W=Writable bit '1' = Bit is set. , R/W-0.TXB1IE (1) = '0' = Bit. , R/W-0.TXB0IE (1) = is cleared. , R/W-0.RXB1IE = x = Bit. , R/W-0.RXB0IE = unknown",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nMode 1, 2, R/W-1.IRXIP = R/W-1. Mode 1, 2, R/W-1.WAKIP = R/W-1. Mode 1, 2, R/W-1.ERRIP = R/W-1. Mode 1, 2, R/W-1.TXB2IP = R/W-1. Mode 1, 2, R/W-1.TXB1IP (1) = R/W-1. Mode 1, 2, R/W-1.TXB0IP (1) = R/W-1. Mode 1, 2, R/W-1.RXB1IP = R/W-1. Mode 1, 2, R/W-1.RXB0IP = R/W-1. , R/W-1.IRXIP = IRXIP. , R/W-1.WAKIP = WAKIP. , R/W-1.ERRIP = ERRIP. , R/W-1.TXB2IP = TXBnIP. ,",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nR/W-1.TXB1IP (1) = TXB1IP (1). , R/W-1.TXB0IP (1) = TXB0IP (1). , R/W-1.RXB1IP = RXBnIP. , R/W-1.RXB0IP = FIFOWMIP. , R/W-1.IRXIP = bit 7. , R/W-1.WAKIP = . , R/W-1.ERRIP = . , R/W-1.TXB2IP = . , R/W-1.TXB1IP (1) = . , R/W-1.TXB0IP (1) = . , R/W-1.RXB1IP = . , R/W-1.RXB0IP = bit 0. bit 7, R/W-1.IRXIP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.WAKIP =",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nIRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.ERRIP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.TXB2IP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.TXB1IP (1) = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.TXB0IP (1) = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.RXB1IP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.RXB0IP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.IRXIP",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\n= WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.WAKIP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.ERRIP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.TXB2IP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.TXB1IP (1) = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.TXB0IP (1) = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.RXB1IP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\npriority. bit 6, R/W-1.RXB0IP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.IRXIP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.WAKIP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.ERRIP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.TXB2IP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.TXB1IP (1) = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.TXB0IP (1) = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5,",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nR/W-1.RXB1IP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.RXB0IP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1.IRXIP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit = High priority. bit 4, R/W-1.WAKIP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit = High priority. bit 4, R/W-1.ERRIP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nTransmit Buffer Interrupt Priority bit = High priority. bit 4, R/W-1.TXB2IP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit = High priority. bit 4, R/W-1.TXB1IP (1) = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit = High priority. bit 4, R/W-1.TXB0IP (1) = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit = High priority. bit 4, R/W-1.RXB1IP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\n= High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit = High priority. bit 4, R/W-1.RXB0IP = When CAN is in Mode 0: TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: TXBnIP: CAN Transmit Buffer Interrupt Priority bit = High priority. bit 3, R/W-1.IRXIP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.WAKIP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.ERRIP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.TXB2IP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.TXB1IP",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\n(1) = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.TXB0IP (1) = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.RXB1IP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 3, R/W-1.RXB0IP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.IRXIP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.WAKIP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.ERRIP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.TXB2IP",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\n= TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.TXB1IP (1) = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.TXB0IP (1) = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.RXB1IP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 2, R/W-1.RXB0IP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1) 1 = High priority. bit 1, R/W-1.IRXIP = 0 = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1,",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nR/W-1.WAKIP = 0 = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.ERRIP = 0 = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.TXB2IP = 0 = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.TXB1IP (1) = 0 = Low priority When CAN is in Mode 0:",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nRXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.TXB0IP (1) = 0 = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.RXB1IP = 0 = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 1, R/W-1.RXB0IP = 0 = Low priority When CAN is in Mode 0: RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nWhen CAN is in Mode 1 or 2: RXBnIP: CAN Receive Buffer Interrupts Priority bit 1 = High priority. bit 0, R/W-1.IRXIP = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.WAKIP = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.ERRIP = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nMode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.TXB2IP = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.TXB1IP (1) = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.TXB0IP (1) = 0 = Low priority When CAN is in Mode 0: RXB0IP:",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nCAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.RXB1IP = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. bit 0, R/W-1.RXB0IP = 0 = Low priority When CAN is in Mode 0: RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority When CAN is in Mode 1: Unimplemented: Read as ' 0 ' When CAN is in Mode 2: FIFOWMIP: FIFO Watermark Interrupt Priority bit. , R/W-1.IRXIP = Legend: R =",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nReadable bit W=Writable bit U = Unimplemented bit, read as '0'. , R/W-1.WAKIP = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. , R/W-1.ERRIP = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. , R/W-1.TXB2IP = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. , R/W-1.TXB1IP (1) = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. , R/W-1.TXB0IP (1) = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. , R/W-1.RXB1IP = Legend: R = Readable bit",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 5\nW=Writable bit U = Unimplemented bit, read as '0'. , R/W-1.RXB0IP = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'\nbit 1-0",
    "REGISTER 23-59: TXBIE: TRANSMIT BUFFERS INTERRUPT ENABLE REGISTER (1)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = U-0. U-0, 7 = U-0. -, 1 = -. -, 2 = -. -, 3 = TXB2IE (2). -, 4 = TXB1IE (2). -, 5 = TXB0IE (2). -, 6 = -. -, 7 = -\nbit 7\nbit 0\nbit 7-5 Unimplemented: Read as ' 0 '\nbit 4-2\nTXB2IE:TXB0IE: Transmit Buffer 2-0 Interrupt Enable bit (2)\n1 = Transmit buffer interrupt is enabled\n0 = Transmit buffer interrupt is disabled",
    "bit 1-0 Unimplemented: Read as ' 0 '\nNote 1: This register is available in Mode 1 and 2 only.\n2: TXBnIE in PIE3 register must be set to get an interrupt.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-60: BIE0: BUFFER INTERRUPT ENABLE REGISTER 0 (1)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. B5IE (2), 1 = B4IE (2). B5IE (2), 2 = B3IE (2). B5IE (2), 3 = B2IE (2). B5IE (2), 4 = B1IE (2). B5IE (2), 5 = B0IE (2). B5IE (2), 6 = RXB1IE (2). B5IE (2), 7 = RXB0IE (2). bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit",
    "REGISTER 23-60: BIE0: BUFFER INTERRUPT ENABLE REGISTER 0 (1)\n7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0\nbit 7-2 B5IE:B0IE: Programmable Transmit/Receive Buffer 5-0 Interrupt Enable bit (2)\n1 = Interrupt is enabled\n0 = Interrupt is disabled\nRXB1IE:RXB0IE: Dedicated Receive Buffer 1-0 Interrupt Enable bit (2)\n1 = Interrupt is enabled\n0 = Interrupt is disabled\nNote 1: This register is available in Mode 1 and 2 only.\n2: Either TXBnIE or RXBnIE in PIE3 register must be set to get an interrupt.",
    "REGISTER 23-60: BIE0: BUFFER INTERRUPT ENABLE REGISTER 0 (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nF7Fh, Name = SPBRGH (3). F7Fh, Address = F5Fh. F7Fh, Name = CANCON_RO0. F7Fh, Address = F3Fh. F7Fh, Name = CANCON_RO2. F7Fh, Address = F1Fh. F7Fh, Name = RXM1EIDL. F7Eh, Name = BAUDCON (3). F7Eh, Address = F5Eh. F7Eh, Name = CANSTAT_RO0. F7Eh, Address = F3Eh. F7Eh, Name = CANSTAT_RO2. F7Eh, Address = F1Eh. F7Eh, Name = RXM1EIDH. F7Dh, Name = - (4). F7Dh, Address = F5Dh. F7Dh, Name = RXB1D7. F7Dh, Address = F3Dh. F7Dh, Name = TXB1D7. F7Dh, Address = F1Dh. F7Dh, Name = RXM1SIDL.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nF7Ch, Name = - (4). F7Ch, Address = F5Ch. F7Ch, Name = RXB1D6. F7Ch, Address = F3Ch. F7Ch, Name = TXB1D6. F7Ch, Address = F1Ch. F7Ch, Name = RXM1SIDH. F7Bh, Name = - (4). F7Bh, Address = F5Bh. F7Bh, Name = RXB1D5. F7Bh, Address = F3Bh. F7Bh, Name = TXB1D5. F7Bh, Address = F1Bh. F7Bh, Name = RXM0EIDL. F7Ah, Name = - (4). F7Ah, Address = F5Ah. F7Ah, Name = RXB1D4. F7Ah, Address = F3Ah. F7Ah, Name = TXB1D4. F7Ah, Address = F1Ah. F7Ah, Name = RXM0EIDH. F79h, Name = ECCP1DEL",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\n(3). F79h, Address = F59h. F79h, Name = RXB1D3. F79h, Address = F39h. F79h, Name = TXB1D3. F79h, Address = F19h. F79h, Name = RXM0SIDL. F78h, Name = - (4). F78h, Address = F58h. F78h, Name = RXB1D2. F78h, Address = F38h. F78h, Name = TXB1D2. F78h, Address = F18h. F78h, Name = RXM0SIDH. F77h, Name = ECANCON. F77h, Address = F57h. F77h, Name = RXB1D1. F77h, Address = F37h. F77h, Name = TXB1D1. F77h, Address = F17h. F77h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nRXF5EIDL. F76h, Name = TXERRCNT. F76h, Address = F56h. F76h, Name = RXB1D0. F76h, Address = F36h. F76h, Name = TXB1D0. F76h, Address = F16h. F76h, Name = RXF5EIDH. F75h, Name = RXERRCNT. F75h, Address = F55h. F75h, Name = RXB1DLC. F75h, Address = F35h. F75h, Name = TXB1DLC. F75h, Address = F15h. F75h, Name = RXF5SIDL. F74h, Name = COMSTAT. F74h, Address = F54h. F74h, Name = RXB1EIDL. F74h, Address = F34h. F74h, Name = TXB1EIDL. F74h, Address = F14h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nF74h, Name = RXF5SIDH. F73h, Name = CIOCON. F73h, Address = F53h. F73h, Name = RXB1EIDH. F73h, Address = F33h. F73h, Name = TXB1EIDH. F73h, Address = F13h. F73h, Name = RXF4EIDL. F72h, Name = BRGCON3. F72h, Address = F52h. F72h, Name = RXB1SIDL. F72h, Address = F32h. F72h, Name = TXB1SIDL. F72h, Address = F12h. F72h, Name = RXF4EIDH. F71h, Name = BRGCON2. F71h, Address = F51h. F71h, Name = RXB1SIDH. F71h, Address = F31h. F71h, Name = TXB1SIDH.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nF71h, Address = F11h. F71h, Name = RXF4SIDL. F70h, Name = BRGCON1. F70h, Address = F50h. F70h, Name = RXB1CON. F70h, Address = F30h. F70h, Name = TXB1CON. F70h, Address = F10h. F70h, Name = RXF4SIDH. F6Fh, Name = CANCON. F6Fh, Address = F4Fh. F6Fh, Name = CANCON_RO1 (2). F6Fh, Address = F2Fh. F6Fh, Name = CANCON_RO3 (2). F6Fh, Address = F0Fh. F6Fh, Name = RXF3EIDL. F6Eh, Name = CANSTAT. F6Eh, Address = F4Eh. F6Eh, Name = CANSTAT_RO1 (2). F6Eh, Address = F2Eh. F6Eh, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nCANSTAT_RO3 (2). F6Eh, Address = F0Eh. F6Eh, Name = RXF3EIDH. F6Dh, Name = RXB0D7. F6Dh, Address = F4Dh. F6Dh, Name = TXB0D7. F6Dh, Address = F2Dh. F6Dh, Name = TXB2D7. F6Dh, Address = F0Dh. F6Dh, Name = RXF3SIDL. F6Ch, Name = RXB0D6. F6Ch, Address = F4Ch. F6Ch, Name = TXB0D6. F6Ch, Address = F2Ch. F6Ch, Name = TXB2D6. F6Ch, Address = F0Ch. F6Ch, Name = RXF3SIDH. F6Bh, Name = RXB0D5. F6Bh, Address = F4Bh. F6Bh, Name = TXB0D5. F6Bh, Address = F2Bh. F6Bh, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nTXB2D5. F6Bh, Address = F0Bh. F6Bh, Name = RXF2EIDL. F6Ah, Name = RXB0D4. F6Ah, Address = F4Ah. F6Ah, Name = TXB0D4. F6Ah, Address = F2Ah. F6Ah, Name = TXB2D4. F6Ah, Address = F0Ah. F6Ah, Name = RXF2EIDH. F69h, Name = RXB0D3. F69h, Address = F49h. F69h, Name = TXB0D3. F69h, Address = F29h. F69h, Name = TXB2D3. F69h, Address = F09h. F69h, Name = RXF2SIDL. F68h, Name = RXB0D2. F68h, Address = F48h. F68h, Name = TXB0D2. F68h, Address = F28h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nF68h, Name = TXB2D2. F68h, Address = F08h. F68h, Name = RXF2SIDH. F67h, Name = RXB0D1. F67h, Address = F47h. F67h, Name = TXB0D1. F67h, Address = F27h. F67h, Name = TXB2D1. F67h, Address = F07h. F67h, Name = RXF1EIDL. F66h, Name = RXB0D0. F66h, Address = F46h. F66h, Name = TXB0D0. F66h, Address = F26h. F66h, Name = TXB2D0. F66h, Address = F06h. F66h, Name = RXF1EIDH. F65h, Name = RXB0DLC. F65h, Address = F45h. F65h, Name = TXB0DLC. F65h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nAddress = F25h. F65h, Name = TXB2DLC. F65h, Address = F05h. F65h, Name = RXF1SIDL. F64h, Name = RXB0EIDL. F64h, Address = F44h. F64h, Name = TXB0EIDL. F64h, Address = F24h. F64h, Name = TXB2EIDL. F64h, Address = F04h. F64h, Name = RXF1SIDH. F63h, Name = RXB0EIDH. F63h, Address = F43h. F63h, Name = TXB0EIDH. F63h, Address = F23h. F63h, Name = TXB2EIDH. F63h, Address = F03h. F63h, Name = RXF0EIDL. F62h, Name = RXB0SIDL. F62h, Address = F42h. F62h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nTXB0SIDL. F62h, Address = F22h. F62h, Name = TXB2SIDL. F62h, Address = F02h. F62h, Name = RXF0EIDH. F61h, Name = RXB0SIDH. F61h, Address = F41h. F61h, Name = TXB0SIDH. F61h, Address = F21h. F61h, Name = TXB2SIDH. F61h, Address = F01h. F61h, Name = RXF0SIDL. F60h, Name = RXB0CON. F60h, Address = F40h. F60h, Name = TXB0CON. F60h, Address = F20h. F60h, Name = TXB2CON. F60h, Address = F00h. F60h, Name = RXF0SIDH",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nNote 1: Shaded registers are available in Access Bank low area, while the rest are available in Bank 15.\n2: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the controller register due to the Microchip header file requirement.\n3: These registers are not CAN registers.\n4: Unimplemented registers are read as ' 0 '.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nEFFh, Name = - (4). EFFh, Address = EDFh. EFFh, Name = - (4). EFFh, Address = EBFh. EFFh, Name = - (4). EFFh, Address = E9Fh. EFFh, Name = - (4). EFEh, Name = - (4). EFEh, Address = EDEh. EFEh, Name = - (4). EFEh, Address = EBEh. EFEh, Name = - (4). EFEh, Address = E9Eh. EFEh, Name = - (4). EFDh, Name = - (4). EFDh, Address = EDDh. EFDh, Name = - (4). EFDh, Address = EBDh. EFDh, Name = - (4). EFDh, Address = E9Dh. EFDh, Name = - (4). EFCh, Name = - (4). EFCh, Address = EDCh.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nEFCh, Name = - (4). EFCh, Address = EBCh. EFCh, Name = - (4). EFCh, Address = E9Ch. EFCh, Name = - (4). EFBh, Name = - (4). EFBh, Address = EDBh. EFBh, Name = - (4). EFBh, Address = EBBh. EFBh, Name = - (4). EFBh, Address = E9Bh. EFBh, Name = - (4). EFAh, Name = - (4). EFAh, Address = EDAh. EFAh, Name = - (4). EFAh, Address = EBAh. EFAh, Name = - (4). EFAh, Address = E9Ah. EFAh, Name = - (4). EF9h, Name = - (4). EF9h, Address = ED9h. EF9h, Name = - (4). EF9h, Address =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nEB9h. EF9h, Name = - (4). EF9h, Address = E99h. EF9h, Name = - (4). EF8h, Name = - (4). EF8h, Address = ED8h. EF8h, Name = - (4). EF8h, Address = EB8h. EF8h, Name = - (4). EF8h, Address = E98h. EF8h, Name = - (4). EF7h, Name = - (4). EF7h, Address = ED7h. EF7h, Name = - (4). EF7h, Address = EB7h. EF7h, Name = - (4). EF7h, Address = E97h. EF7h, Name = - (4). EF6h, Name = - (4). EF6h, Address = ED6h. EF6h, Name = - (4).",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nEF6h, Address = EB6h. EF6h, Name = - (4). EF6h, Address = E96h. EF6h, Name = - (4). EF5h, Name = - (4). EF5h, Address = ED5h. EF5h, Name = - (4). EF5h, Address = EB5h. EF5h, Name = - (4). EF5h, Address = E95h. EF5h, Name = - (4). EF4h, Name = - (4). EF4h, Address = ED4h. EF4h, Name = - (4). EF4h, Address = EB4h. EF4h, Name = - (4). EF4h, Address = E94h. EF4h, Name = - (4). EF3h, Name = - (4). EF3h, Address = ED3h. EF3h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\n- (4). EF3h, Address = EB3h. EF3h, Name = - (4). EF3h, Address = E93h. EF3h, Name = - (4). EF2h, Name = - (4). EF2h, Address = ED2h. EF2h, Name = - (4). EF2h, Address = EB2h. EF2h, Name = - (4). EF2h, Address = E92h. EF2h, Name = - (4). EF1h, Name = - (4). EF1h, Address = ED1h. EF1h, Name = - (4). EF1h, Address = EB1h. EF1h, Name = - (4). EF1h, Address = E91h. EF1h, Name = - (4). EF0h, Name = - (4). EF0h, Address = ED0h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nEF0h, Name = - (4). EF0h, Address = EB0h. EF0h, Name = - (4). EF0h, Address = E90h. EF0h, Name = - (4). EEFh, Name = - (4). EEFh, Address = ECFh. EEFh, Name = - (4). EEFh, Address = EAFh. EEFh, Name = - (4). EEFh, Address = E8Fh. EEFh, Name = - (4). EEEh, Name = - (4). EEEh, Address = ECEh. EEEh, Name = - (4). EEEh, Address = EAEh. EEEh, Name = - (4). EEEh, Address = E8Eh. EEEh, Name = - (4). EEDh, Name = - (4). EEDh, Address = ECDh. EEDh, Name = - (4). EEDh, Address = EADh. EEDh, Name = -",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\n(4). EEDh, Address = E8Dh. EEDh, Name = - (4). EECh, Name = - (4). EECh, Address = ECCh. EECh, Name = - (4). EECh, Address = EACh. EECh, Name = - (4). EECh, Address = E8Ch. EECh, Name = - (4). EEBh, Name = - (4). EEBh, Address = ECBh. EEBh, Name = - (4). EEBh, Address = EABh. EEBh, Name = - (4). EEBh, Address = E8Bh. EEBh, Name = - (4). EEAh, Name = - (4). EEAh, Address = ECAh. EEAh, Name = - (4). EEAh, Address = EAAh. EEAh, Name = - (4). EEAh, Address = E8Ah. EEAh, Name = - (4). EE9h, Name = - (4). EE9h, Address = EC9h. EE9h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\n- (4). EE9h, Address = EA9h. EE9h, Name = - (4). EE9h, Address = E89h. EE9h, Name = - (4). EE8h, Name = - (4). EE8h, Address = EC8h. EE8h, Name = - (4). EE8h, Address = EA8h. EE8h, Name = - (4). EE8h, Address = E88h. EE8h, Name = - (4). EE7h, Name = - (4). EE7h, Address = EC7h. EE7h, Name = - (4). EE7h, Address = EA7h. EE7h, Name = - (4). EE7h, Address = E87h. EE7h, Name = - (4). EE6h, Name = - (4). EE6h, Address = EC6h. EE6h, Name = - (4). EE6h, Address = EA6h. EE6h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nName = - (4). EE6h, Address = E86h. EE6h, Name = - (4). EE5h, Name = - (4). EE5h, Address = EC5h. EE5h, Name = - (4). EE5h, Address = EA5h. EE5h, Name = - (4). EE5h, Address = E85h. EE5h, Name = - (4). EE4h, Name = - (4). EE4h, Address = EC4h. EE4h, Name = - (4). EE4h, Address = EA4h. EE4h, Name = - (4). EE4h, Address = E84h. EE4h, Name = - (4). EE3h, Name = - (4). EE3h, Address = EC3h. EE3h, Name = - (4). EE3h, Address = EA3h. EE3h, Name = - (4). EE3h, Address = E83h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nEE3h, Name = - (4). EE2h, Name = - (4). EE2h, Address = EC2h. EE2h, Name = - (4). EE2h, Address = EA2h. EE2h, Name = - (4). EE2h, Address = E82h. EE2h, Name = - (4). EE1h, Name = - (4). EE1h, Address = EC1h. EE1h, Name = - (4). EE1h, Address = EA1h. EE1h, Name = - (4). EE1h, Address = E81h. EE1h, Name = - (4). EE0h, Name = - (4). EE0h, Address = EC0h. EE0h, Name = - (4). EE0h, Address = EA0h. EE0h, Name = - (4). EE0h, Address = E80h. EE0h, Name = - (4)",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nNote 1: Shaded registers are available in Access Bank low area, while the rest are available in Bank 15.\n2: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the controller register due to the Microchip header file requirement.\n3: These registers are not CAN registers.\n4: Unimplemented registers are read as ' 0 '.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nE7Fh, Name = CANCON_RO4 (2). E7Fh, Address = E5Fh. E7Fh, Name = CANCON_RO6 (2). E7Fh, Address = E3Fh. E7Fh, Name = CANCON_RO8 (2). E7Fh, Address = E1Fh. E7Fh, Name = - (4). E7Eh, Name = CANSTAT_RO4 (2). E7Eh, Address = E5Eh. E7Eh, Name = CANSTAT_RO6 (2). E7Eh, Address = E3Eh. E7Eh, Name = CANSTAT_RO8 (2). E7Eh, Address = E1Eh. E7Eh, Name = - (4). E7Dh, Name = B5D7. E7Dh, Address = E5Dh. E7Dh, Name = B3D7. E7Dh, Address = E3Dh. E7Dh, Name = B1D7. E7Dh, Address = E1Dh.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nE7Dh, Name = - (4). E7Ch, Name = B5D6. E7Ch, Address = E5Ch. E7Ch, Name = B3D6. E7Ch, Address = E3Ch. E7Ch, Name = B1D6. E7Ch, Address = E1Ch. E7Ch, Name = - (4). E7Bh, Name = B5D5. E7Bh, Address = E5Bh. E7Bh, Name = B3D5. E7Bh, Address = E3Bh. E7Bh, Name = B1D5. E7Bh, Address = E1Bh. E7Bh, Name = - (4). E7Ah, Name = B5D4. E7Ah, Address = E5Ah. E7Ah, Name = B3D4. E7Ah, Address = E3Ah. E7Ah, Name = B1D4. E7Ah, Address = E1Ah. E7Ah, Name = - (4). E79h, Name = B5D3. E79h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nAddress = E59h. E79h, Name = B3D3. E79h, Address = E39h. E79h, Name = B1D3. E79h, Address = E19h. E79h, Name = - (4). E78h, Name = B5D2. E78h, Address = E58h. E78h, Name = B3D2. E78h, Address = E38h. E78h, Name = B1D2. E78h, Address = E18h. E78h, Name = - (4). E77h, Name = B5D1. E77h, Address = E57h. E77h, Name = B3D1. E77h, Address = E37h. E77h, Name = B1D1. E77h, Address = E17h. E77h, Name = - (4). E76h, Name = B5D0. E76h, Address = E56h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nE76h, Name = B3D0. E76h, Address = E36h. E76h, Name = B1D0. E76h, Address = E16h. E76h, Name = - (4). E75h, Name = B5DLC. E75h, Address = E55h. E75h, Name = B3DLC. E75h, Address = E35h. E75h, Name = B1DLC. E75h, Address = E15h. E75h, Name = - (4). E74h, Name = B5EIDL. E74h, Address = E54h. E74h, Name = B3EIDL. E74h, Address = E34h. E74h, Name = B1EIDL. E74h, Address = E14h. E74h, Name = - (4). E73h, Name = B5EIDH. E73h, Address = E53h. E73h, Name = B3EIDH.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nE73h, Address = E33h. E73h, Name = B1EIDH. E73h, Address = E13h. E73h, Name = - (4). E72h, Name = B5SIDL. E72h, Address = E52h. E72h, Name = B3SIDL. E72h, Address = E32h. E72h, Name = B1SIDL. E72h, Address = E12h. E72h, Name = - (4). E71h, Name = B5SIDH. E71h, Address = E51h. E71h, Name = B3SIDH. E71h, Address = E31h. E71h, Name = B1SIDH. E71h, Address = E11h. E71h, Name = - (4). E70h, Name = B5CON. E70h, Address = E50h. E70h, Name = B3CON. E70h, Address =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nE30h. E70h, Name = B1CON. E70h, Address = E10h. E70h, Name = - (4). E6Fh, Name = CANCON_RO5. E6Fh, Address = E4Fh. E6Fh, Name = CANCON_RO7. E6Fh, Address = E2Fh. E6Fh, Name = CANCON_RO9. E6Fh, Address = E0Fh. E6Fh, Name = - (4). E6Eh, Name = CANSTAT_RO5. E6Eh, Address = E4Eh. E6Eh, Name = CANSTAT_RO7. E6Eh, Address = E2Eh. E6Eh, Name = CANSTAT_RO9. E6Eh, Address = E0Eh. E6Eh, Name = - (4). E6Dh, Name = B4D7. E6Dh, Address = E4Dh. E6Dh, Name = B2D7. E6Dh, Address = E2Dh. E6Dh,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nName = B0D7. E6Dh, Address = E0Dh. E6Dh, Name = - (4). E6Ch, Name = B4D6. E6Ch, Address = E4Ch. E6Ch, Name = B2D6. E6Ch, Address = E2Ch. E6Ch, Name = B0D6. E6Ch, Address = E0Ch. E6Ch, Name = - (4). E6Bh, Name = B4D5. E6Bh, Address = E4Bh. E6Bh, Name = B2D5. E6Bh, Address = E2Bh. E6Bh, Name = B0D5. E6Bh, Address = E0Bh. E6Bh, Name = - (4). E6Ah, Name = B4D4. E6Ah, Address = E4Ah. E6Ah, Name = B2D4. E6Ah, Address = E2Ah. E6Ah, Name = B0D4. E6Ah, Address = E0Ah. E6Ah, Name",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\n= - (4). E69h, Name = B4D3. E69h, Address = E49h. E69h, Name = B2D3. E69h, Address = E29h. E69h, Name = B0D3. E69h, Address = E09h. E69h, Name = - (4). E68h, Name = B4D2. E68h, Address = E48h. E68h, Name = B2D2. E68h, Address = E28h. E68h, Name = B0D2. E68h, Address = E08h. E68h, Name = - (4). E67h, Name = B4D1. E67h, Address = E47h. E67h, Name = B2D1. E67h, Address = E27h. E67h, Name = B0D1. E67h, Address = E07h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nE67h, Name = - (4). E66h, Name = B4D0. E66h, Address = E46h. E66h, Name = B2D0. E66h, Address = E26h. E66h, Name = B0D0. E66h, Address = E06h. E66h, Name = - (4). E65h, Name = B4DLC. E65h, Address = E45h. E65h, Name = B2DLC. E65h, Address = E25h. E65h, Name = B0DLC. E65h, Address = E05h. E65h, Name = - (4). E64h, Name = B4EIDL. E64h, Address = E44h. E64h, Name = B2EIDL. E64h, Address = E24h. E64h, Name = B0EIDL. E64h, Address = E04h. E64h, Name = - (4). E63h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nB4EIDH. E63h, Address = E43h. E63h, Name = B2EIDH. E63h, Address = E23h. E63h, Name = B0EIDH. E63h, Address = E03h. E63h, Name = - (4). E62h, Name = B4SIDL. E62h, Address = E42h. E62h, Name = B2SIDL. E62h, Address = E22h. E62h, Name = B0SIDL. E62h, Address = E02h. E62h, Name = - (4). E61h, Name = B4SIDH. E61h, Address = E41h. E61h, Name = B2SIDH. E61h, Address = E21h. E61h, Name = B0SIDH. E61h, Address = E01h. E61h, Name = - (4). E60h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nB4CON. E60h, Address = E40h. E60h, Name = B2CON. E60h, Address = E20h. E60h, Name = B0CON. E60h, Address = E00h. E60h, Name = - (4)\nNote 1: Shaded registers are available in Access Bank low area, while the rest are available in Bank 15.\n2: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the controller register due to the Microchip header file requirement.\n3: These registers are not CAN registers.\n4: Unimplemented registers are read as ' 0 '.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nDFFh, Name = - (4). DFFh, Address = DDFh. DFFh, Name = - (4). DFFh, Address = DBFh. DFFh, Name = - (4). DFFh, Address = D9Fh. DFFh, Name = - (4). DFEh, Name = - (4). DFEh, Address = DDEh. DFEh, Name = - (4). DFEh, Address = DBEh. DFEh, Name = - (4). DFEh, Address = D9Eh. DFEh, Name = - (4). DFDh, Name = - (4). DFDh, Address = DDDh. DFDh, Name = - (4). DFDh, Address = DBDh. DFDh, Name = - (4). DFDh, Address = D9Dh. DFDh, Name = - (4). DFCh, Name = TXBIE. DFCh, Address = DDCh. DFCh, Name = -",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\n(4). DFCh, Address = DBCh. DFCh, Name = - (4). DFCh, Address = D9Ch. DFCh, Name = - (4). DFBh, Name = - (4). DFBh, Address = DDBh. DFBh, Name = - (4). DFBh, Address = DBBh. DFBh, Name = - (4). DFBh, Address = D9Bh. DFBh, Name = - (4). DFAh, Name = BIE0. DFAh, Address = DDAh. DFAh, Name = - (4). DFAh, Address = DBAh. DFAh, Name = - (4). DFAh, Address = D9Ah. DFAh, Name = - (4). DF9h, Name = - (4). DF9h, Address = DD9h. DF9h, Name = - (4). DF9h, Address = DB9h. DF9h, Name = - (4). DF9h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nAddress = D99h. DF9h, Name = - (4). DF8h, Name = BSEL0. DF8h, Address = DD8h. DF8h, Name = SDFLC. DF8h, Address = DB8h. DF8h, Name = - (4). DF8h, Address = D98h. DF8h, Name = - (4). DF7h, Name = - (4). DF7h, Address = DD7h. DF7h, Name = - (4). DF7h, Address = DB7h. DF7h, Name = - (4). DF7h, Address = D97h. DF7h, Name = - (4). DF6h, Name = - (4). DF6h, Address = DD6h. DF6h, Name = - (4). DF6h, Address = DB6h. DF6h, Name = - (4). DF6h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nAddress = D96h. DF6h, Name = - (4). DF5h, Name = - (4). DF5h, Address = DD5h. DF5h, Name = RXFCON1. DF5h, Address = DB5h. DF5h, Name = - (4). DF5h, Address = D95h. DF5h, Name = - (4). DF4h, Name = - (4). DF4h, Address = DD4h. DF4h, Name = RXFCON0. DF4h, Address = DB4h. DF4h, Name = - (4). DF4h, Address = D94h. DF4h, Name = - (4). DF3h, Name = MSEL3. DF3h, Address = DD3h. DF3h, Name = - (4). DF3h, Address = DB3h. DF3h, Name = - (4).",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nDF3h, Address = D93h. DF3h, Name = RXF15EIDL. DF2h, Name = MSEL2. DF2h, Address = DD2h. DF2h, Name = - (4). DF2h, Address = DB2h. DF2h, Name = - (4). DF2h, Address = D92h. DF2h, Name = RXF15EIDH. DF1h, Name = MSEL1. DF1h, Address = DD1h. DF1h, Name = - (4). DF1h, Address = DB1h. DF1h, Name = - (4). DF1h, Address = D91h. DF1h, Name = RXF15SIDL. DF0h, Name = MSEL0. DF0h, Address = DD0h. DF0h, Name = - (4). DF0h, Address = DB0h. DF0h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\n- (4). DF0h, Address = D90h. DF0h, Name = RXF15SIDH. DEFh, Name = - (4). DEFh, Address = DCFh. DEFh, Name = - (4). DEFh, Address = DAFh. DEFh, Name = - (4). DEFh, Address = D8Fh. DEFh, Name = - (4). DEEh, Name = - (4). DEEh, Address = DCEh. DEEh, Name = - (4). DEEh, Address = DAEh. DEEh, Name = - (4). DEEh, Address = D8Eh. DEEh, Name = - (4). DEDh, Name = - (4). DEDh, Address = DCDh. DEDh, Name = - (4). DEDh, Address = DADh. DEDh, Name = - (4). DEDh, Address = D8Dh. DEDh, Name = - (4). DECh, Name = - (4). DECh, Address =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nDCCh. DECh, Name = - (4). DECh, Address = DACh. DECh, Name = - (4). DECh, Address = D8Ch. DECh, Name = - (4). DEBh, Name = - (4). DEBh, Address = DCBh. DEBh, Name = - (4). DEBh, Address = DABh. DEBh, Name = - (4). DEBh, Address = D8Bh. DEBh, Name = RXF14EIDL. DEAh, Name = - (4). DEAh, Address = DCAh. DEAh, Name = - (4). DEAh, Address = DAAh. DEAh, Name = - (4). DEAh, Address = D8Ah. DEAh, Name = RXF14EIDH. DE9h, Name = - (4). DE9h, Address = DC9h. DE9h, Name = - (4). DE9h, Address = DA9h. DE9h, Name = - (4). DE9h, Address =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nD89h. DE9h, Name = RXF14SIDL. DE8h, Name = - (4). DE8h, Address = DC8h. DE8h, Name = - (4). DE8h, Address = DA8h. DE8h, Name = - (4). DE8h, Address = D88h. DE8h, Name = RXF14SIDH. DE7h, Name = RXFBCON7. DE7h, Address = DC7h. DE7h, Name = - (4). DE7h, Address = DA7h. DE7h, Name = - (4). DE7h, Address = D87h. DE7h, Name = RXF13EIDL. DE6h, Name = RXFBCON6. DE6h, Address = DC6h. DE6h, Name = - (4). DE6h, Address = DA6h. DE6h, Name = - (4). DE6h, Address = D86h. DE6h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nRXF13EIDH. DE5h, Name = RXFBCON5. DE5h, Address = DC5h. DE5h, Name = - (4). DE5h, Address = DA5h. DE5h, Name = - (4). DE5h, Address = D85h. DE5h, Name = RXF13SIDL. DE4h, Name = RXFBCON4. DE4h, Address = DC4h. DE4h, Name = - (4). DE4h, Address = DA4h. DE4h, Name = - (4). DE4h, Address = D84h. DE4h, Name = RXF13SIDH. DE3h, Name = RXFBCON3. DE3h, Address = DC3h. DE3h, Name = - (4). DE3h, Address = DA3h. DE3h, Name = - (4). DE3h, Address = D83h. DE3h, Name = RXF12EIDL. DE2h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nName = RXFBCON2. DE2h, Address = DC2h. DE2h, Name = - (4). DE2h, Address = DA2h. DE2h, Name = - (4). DE2h, Address = D82h. DE2h, Name = RXF12EIDH. DE1h, Name = RXFBCON1. DE1h, Address = DC1h. DE1h, Name = - (4). DE1h, Address = DA1h. DE1h, Name = - (4). DE1h, Address = D81h. DE1h, Name = RXF12SIDL. DE0h, Name = RXFBCON0. DE0h, Address = DC0h. DE0h, Name = - (4). DE0h, Address = DA0h. DE0h, Name = - (4). DE0h, Address = D80h. DE0h, Name = RXF12SIDH",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nNote 1: Shaded registers are available in Access Bank low area, while the rest are available in Bank 15.\n2: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the controller register due to the Microchip header file requirement.\n3: These registers are not CAN registers.\n4: Unimplemented registers are read as ' 0 '.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nD7Fh, Name = - (4). D7Eh, Name = - (4). D7Dh, Name = - (4). D7Ch, Name = - (4). D7Bh, Name = RXF11EIDL. D7Ah, Name = RXF11EIDH. D79h, Name = RXF11SIDL. D78h, Name = RXF11SIDH. D77h, Name = RXF10EIDL. D76h, Name = RXF10EIDH. D75h, Name = RXF10SIDL. D74h, Name = RXF10SIDH. D73h, Name = RXF9EIDL. D72h, Name = RXF9EIDH. D71h, Name = RXF9SIDL. D70h, Name = RXF9SIDH. D6Fh, Name = - (4). D6Eh, Name = - (4). D6Dh, Name = - (4).",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nD6Ch, Name = - (4). D6Bh, Name = RXF8EIDL. D6Ah, Name = RXF8EIDH. D69h, Name = RXF8SIDL. D68h, Name = RXF8SIDH. D67h, Name = RXF7EIDL. D66h, Name = RXF7EIDH. D65h, Name = RXF7SIDL. D64h, Name = RXF7SIDH. D63h, Name = RXF6EIDL. D62h, Name = RXF6EIDH. D61h, Name = RXF6SIDL. D60h, Name = RXF6SIDH",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nNote 1: Shaded registers are available in Access Bank low area while the rest are available in Bank 15.\n2: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the controller register due to the Microchip header file requirement.\n3: These registers are not CAN registers.\n4: Unimplemented registers are read as ' 0 '.",
    "23.3.2 DISABLE MODE\nThe PIC18F2585/2680/4585/4680 has six main modes of operation:\n\u00b7 Configuration mode\n\u00b7 Disable mode\n\u00b7 Normal Operation mode\n\u00b7 Listen Only mode\n\u00b7 Loopback mode\n\u00b7 Error Recognition mode\nAll modes, except Error Recognition, are requested by setting the REQOP bits (CANCON<7:5>). Error Recognition mode is requested through the RXM bits of the Receive  Buffer register(s). Entry into a mode  is Acknowledged by monitoring the OPMODE bits.\nWhen  changing  modes,  the  mode  will  not  actually change  until  all  pending  message  transmissions  are complete. Because of this, the user must verify that the device has actually changed into the requested mode before further operations are executed.",
    "23.3.1 CONFIGURATION MODE\nThe  CAN  module  has  to  be  initialized  before  the activation. This is only possible if the module is in the Configuration mode. The Configuration mode is requested by setting the REQOP2 bit. Only when the status bit, OPMODE2, has a high level can the initialization be performed. Afterwards, the configuration registers, the acceptance mask registers and the acceptance filter registers can be written. The module is activated by setting the REQOP control bits to zero.\nThe  module  will  protect  the  user  from  accidentally violating the CAN  protocol through programming errors. All registers which control the configuration of the module can not be modified while the module is online. The CAN module will not be allowed to enter the Configuration mode while a transmission or reception is  taking  place.  The  Configuration mode serves as a lock to protect the following registers:\n\u00b7 Configuration Registers\n\u00b7 Functional Mode Selection Registers\n\u00b7 Bit Timing Registers\n\u00b7 Identifier Acceptance Filter Registers\n\u00b7 Identifier Acceptance Mask Registers\n\u00b7 Filter and Mask Control Registers\n\u00b7 Mask Selection Registers\nIn the Configuration mode, the module will not transmit or  receive.  The  error  counters  are  cleared  and  the interrupt flags remain unchanged. The programmer will have access to Configuration registers that are access restricted in other modes.",
    "23.3.1 CONFIGURATION MODE\nIn  Disable  mode,  the  module  will  not  transmit  or receive. The module has the ability to set the WAKIF bit due to bus activity; however, any pending interrupts will remain and the error counters will retain their value.\nIf the REQOP<2:0> bits are set to ' 001 ', the module will enter the module Disable mode. This mode is similar to disabling  other  peripheral  modules  by  turning  off  the module enables. This causes the module internal clock to  stop  unless  the  module  is  active  (i.e.,  receiving  or transmitting  a  message).  If  the  module  is  active,  the module will wait for 11 recessive bits on the CAN bus, detect  that  condition  as  an  Idle  bus,  then  accept  the module  disable command.  OPMODE<2:0>  = 001 indicates whether the module successfully went into the module Disable mode.",
    "23.3.1 CONFIGURATION MODE\nThe WAKIF interrupt is the only module interrupt that is still active  in  the  Disable  mode.  If  the  WAKDIS  is cleared and WAKIE is set, the processor will receive an interrupt  whenever  the  module  detects  recessive  to dominant transition. On wake-up, the module will automatically be set to the previous mode of operation. For example, if the module was switched from Normal to Disable mode on bus activity wake-up, the module will automatically enter into Normal mode and the first message that caused the module to wake-up is lost. The module  will  not  generate  any  error  frame.  Firmware logic  must  detect  this  condition  and  make  sure  that retransmission is requested. If the processor receives a wake-up interrupt while it is sleeping, more than one message may get lost. The actual number of messages lost would depend on the processor oscillator start-up time and incoming message bit rate.\nThe I/O pins will revert to normal I/O function when the module is in the Disable mode.",
    "23.3.3 NORMAL MODE\nThis is the standard operating mode of the PIC18F2585/2680/4585/4680  devices.  In  this  mode, the device actively monitors all bus messages and generates Acknowledge bits, error frames, etc. This is also the  only  mode  in  which  the  PIC18F2585/2680/4585/ 4680  devices  will  transmit  messages  over  the  CAN bus.",
    "23.3.4 LISTEN ONLY MODE\nListen Only mode provides a means for the PIC18F2585/2680/4585/4680  devices  to  receive  all messages, including messages with errors. This mode can  be  used  for  bus  monitor  applications  or  for detecting the baud rate in 'hot plugging' situations. For Auto-Baud Detection, it is necessary that there are at least two other nodes which are communicating with each other. The baud rate can be detected empirically by  testing  different  values  until  valid  messages  are received.  The  Listen  Only  mode  is  a  silent  mode, meaning no messages will be transmitted while in this state, including error flags or Acknowledge signals. The filters and masks can be used to allow only particular messages to be loaded into the receive registers or the filter masks can be set to all zeros to allow a message with any identifier to pass. The error counters are reset and deactivated in this state. The Listen Only mode is activated  by  setting  the  mode  request  bits  in  the CANCON register.",
    "23.3.5 LOOPBACK MODE\nThis mode will allow internal transmission of messages from the transmit buffers to the receive buffers without actually transmitting messages on the CAN bus. This mode can be used in system development and testing. In this mode, the ACK bit is ignored and the device will allow  incoming  messages  from  itself,  just  as  if  they were coming from another node. The Loopback mode is a silent mode,  meaning  no  messages  will  be transmitted while in this state, including error flags or Acknowledge signals. The TXCAN pin will revert to port I/O  while  the  device  is  in  this  mode.  The  filters  and masks can be used to allow only particular messages to be loaded into the receive registers. The masks can be set to all zeros to provide a mode that accepts all messages. The Loopback mode is activated by setting the mode request bits in the CANCON register.",
    "23.3.6 ERROR RECOGNITION MODE\nThe module can be set to ignore all errors and receive any message. In functional Mode 0, the Error Recognition mode is activated by setting the RXM<1:0> bits in the RXBnCON registers to ' 11 '. In this mode, the data which is in the message assembly buffer until the error time, is copied in the receive buffer and can be read via the CPU interface.",
    "23.4 ECAN Module Functional Modes\nIn addition to CAN modes of operation, the ECAN module offers a total of 3 functional modes. Each of these modes are identified as Mode 0, Mode 1 and Mode 2.",
    "23.4.1 MODE 0 - LEGACY MODE\nMode 0 is designed to be fully compatible with CAN modules used in PIC18CXX8 and PIC18FXX8 devices. This  is  the  default  mode  of  operation  on  all  Reset conditions.  As  a  result,  module  code  written  for  the PIC18XX8 CAN module may be used on the ECAN module without any code changes.\nThe following is the list of resources available in Mode 0:\n\u00b7 Three transmit buffers: TXB0, TXB1 and TXB2\n\u00b7 Two receive buffers: RXB0 and RXB1\n\u00b7 Two acceptance masks, one for each receive buffer: RXM0, RXM1\n\u00b7 Six acceptance filters, 2 for RXB0 and 4 for RXB1: RXF0, RXF1, RXF2, RXF3, RXF4, RXF5",
    "23.4.2 MODE 1 - ENHANCED LEGACY MODE\nMode 1 is similar to Mode 0, with the exception that more resources are available in Mode 1. There are 16 acceptance filters and two acceptance mask registers. Acceptance Filter 15 can be used as either an acceptance filter or an acceptance mask register. In addition to three transmit and two receive buffers, there are six more message buffers. One or more of these additional buffers can be programmed as transmit or receive buffers. These additional buffers can also be programmed to automatically handle RTR messages.\nFourteen of sixteen acceptance filter registers can be dynamically  associated  to  any  receive  buffer  and acceptance mask register. One can use this capability to associate more than one filter to any one buffer.\nWhen a receive buffer is programmed to use standard identifier  messages,  part  of  the  full  acceptance  filter register can be used as a data byte filter. The length of the data byte filter is programmable from 0 to 18 bits. This functionality simplifies implementation of high-level protocols, such as the DeviceNet protocol.\nThe following is the list of resources available in Mode 1:",
    "23.4.2 MODE 1 - ENHANCED LEGACY MODE\n\u00b7 Three transmit buffers: TXB0, TXB1 and TXB2\n\u00b7 Two receive buffers: RXB0 and RXB1\n\u00b7 Six buffers programmable as TX or RX: B0-B5\n\u00b7 Automatic RTR handling on B0-B5\n\u00b7 Sixteen dynamically assigned acceptance filters: RXF0-RXF15\n\u00b7 Two dedicated acceptance mask registers; RXF15 programmable as third mask: RXM0-RXM1, RXF15\n\u00b7 Programmable data filter on standard identifier messages: SDFLC",
    "23.4.3 MODE 2 - ENHANCED FIFO MODE\nIn Mode 2, two or more receive buffers are used to form the receive FIFO (first in, first out) buffer. There is no one-to-one relationship between the receive buffer and acceptance filter registers. Any filter that is enabled and linked to any FIFO  receive buffer can generate acceptance and cause FIFO to be updated.\nFIFO  length  is  user  programmable,  from  2-8  buffers deep.  FIFO  length  is  determined  by  the  very  first programmable buffer that is configured as a transmit buffer. For example, if Buffer 2 (B2) is programmed as a  transmit  buffer,  FIFO  consists  of  RXB0,  RXB1,  B0 and B1 - creating a FIFO length of 4. If all programmable buffers are configured as receive buffers, FIFO will have the maximum length of 8.\nThe following is the list of resources available in Mode 2:",
    "23.4.3 MODE 2 - ENHANCED FIFO MODE\n\u00b7 Three transmit buffers: TXB0, TXB1 and TXB2\n\u00b7 Two receive buffers: RXB0 and RXB1\n\u00b7 Six buffers programmable as TX or RX; receive buffers form FIFO: B0-B5\n\u00b7 Automatic RTR handling on B0-B5\n\u00b7 Sixteen acceptance filters: RXF0-RXF15\n\u00b7 Two dedicated acceptance mask registers; RXF15 programmable as third mask: RXM0-RXM1, RXF15\n\u00b7 Programmable data filter on standard identifier messages: SDFLC, useful for DeviceNet protocol",
    "23.5.1 DEDICATED TRANSMIT BUFFERS\nThe PIC18F2585/2680/4585/4680 devices implement three  dedicated  transmit  buffers  -  TXB0,  TXB1  and TXB2.  Each  of  these  buffers  occupies  14  bytes  of SRAM and are mapped into the SFR memory map. These  are  the only transmit buffers available in Mode 0. Mode 1 and 2 may access these and other additional buffers.\nEach  transmit  buffer  contains  one  control  register (TXBnCON), four identifier registers (TXBnSIDL, TXBnSIDH, TXBnEIDL, TXBnEIDH), one data length count register (TXBnDLC) and eight data byte registers (TXBnDm).",
    "23.5.2 DEDICATED RECEIVE BUFFERS\nThe PIC18F2585/2680/4585/4680 devices implement two dedicated receive buffers - RXB0 and RXB1. Each of these buffers occupies 14 bytes of SRAM and are mapped into SFR memory map. These are the only receive buffers available in Mode 0. Mode 1 and 2 may access these and other additional buffers.\nEach receive buffer contains one control register (RXBnCON),  four  identifier  registers  (RXBnSIDL,  RXBnSIDH, RXBnEIDL, RXBnEIDH), one data length count register  (RXBnDLC)  and  eight  data  byte  registers (RXBnDm).\nThere  is  also  a  separate  Message  Assembly  Buffer (MAB) which acts as an additional receive buffer. MAB is  always  committed  to  receiving  the  next  message from the bus and is not directly accessible to user firmware. The MAB assembles all incoming messages one by  one.  A  message  is  transferred  to  appropriate receive  buffers  only  if  the  corresponding  acceptance filter criteria is met.",
    "23.5.3 PROGRAMMABLE TRANSMIT/ RECEIVE BUFFERS\nThe ECAN module implements six new buffers: B0-B5. These buffers are individually programmable as either transmit or receive buffers. These buffers are available only in Mode 1 and 2. As with dedicated transmit and receive  buffers,  each  of  these  programmable  buffers occupies 14 bytes of SRAM and are mapped into SFR memory map.\nEach  buffer  contains  one  control  register  (BnCON), four  identifier  registers  (BnSIDL,  BnSIDH,  BnEIDL, BnEIDH), one data length count register (BnDLC) and eight data byte registers (BnDm). Each of these registers  contains  two  sets  of  control  bits.  Depending  on whether the buffer is configured as transmit or receive, one  would  use  the  corresponding  control  bit  set.  By default,  all  buffers  are  configured  as  receive  buffers. Each buffer can be individually configured as a transmit or receive buffer by setting the corresponding TXENn bit in the BSEL0 register.",
    "23.5.3 PROGRAMMABLE TRANSMIT/ RECEIVE BUFFERS\nWhen  configured  as  transmit  buffers,  user  firmware may  access  transmit  buffers  in  any  order  similar  to accessing dedicated transmit buffers. In receive configuration with Mode 1 enabled, user firmware may also access  receive  buffers  in  any  order  required.  But  in Mode 2, all receive buffers are combined to form a single FIFO. Actual FIFO length is programmable by user firmware. Access to FIFO must be done through the FIFO Pointer bits (FP<4:0>) in the CANCON register. It must  be  noted  that  there  is  no  hardware  protection against out of order FIFO reads.",
    "23.5.4 PROGRAMMABLE AUTO-RTR BUFFERS\nIn  Mode 1 and 2, any of six programmable transmit/ receive buffers may be programmed to automatically respond  to  predefined  RTR  messages  without  user firmware intervention. Automatic RTR  handling  is enabled by setting the TXnEN bit in the BSEL0 register and the RTREN bit in the BnCON register. After this setup, when an RTR request is received, the TXREQ bit is automatically set and the current buffer content is automatically queued  for transmission as a RTR response. As with all transmit buffers, once the TXREQ bit  is  set,  buffer  registers  become  read-only  and any writes to them will be ignored.\nThe following outlines the steps required to automatically handle RTR messages:\n1. Set buffer to Transmit mode by setting TXnEN bit to ' 1 ' in BSEL0 register.\n2. At least one acceptance filter must be associated with this buffer and preloaded with expected RTR identifier.\n3. Bit RTREN in BnCON register must be set to ' 1 '.\n4. Buffer  must  be  preloaded  with  the  data  to  be sent as a RTR response.",
    "23.5.4 PROGRAMMABLE AUTO-RTR BUFFERS\nNormally, user firmware will keep buffer data registers up to  date.  If  firmware  attempts  to  update  the  buffer while an automatic RTR response is in the process of transmission, all writes to buffers are ignored.",
    "23.6.1 INITIATING TRANSMISSION\nFor the MCU to have write access to the message buffer,  the  TXREQ  bit  must  be  clear,  indicating  that  the message buffer is clear of any pending message to be transmitted.",
    "Note:\nThe  time  between  the  clearing  of  the TXREQ bit and when the TX buffer has write access  can  be  as  long  as  four instruction cycles.\nAt a minimum, the SIDH, SIDL and DLC registers must be loaded. If data bytes are present in the message, the data registers must also be loaded. If the message is to use extended identifiers, the EIDH:EIDL registers must also be loaded and the EXIDE bit set.\nTo initiate message transmission, the TXREQ bit must be set for each buffer to be transmitted. When TXREQ is  set,  the  TXABT,  TXLARB  and  TXERR  bits  will  be cleared.  To  successfully  complete  the  transmission, there must be at least one node with matching baud rate on the network.\nSetting  the  TXREQ  bit  does  not  initiate  a  message transmission; it merely flags a message buffer as ready for transmission.  Transmission  will  start  when  the device detects that the bus is available. The device will then begin transmission of the highest priority message that is ready.\nWhen the transmission has completed successfully, the TXREQ bit will be cleared, the TXBnIF bit will be set and an interrupt will be generated if the TXBnIE bit is set.",
    "Note:\nIf the message transmission fails, the TXREQ will remain set, indicating that the message is still pending for transmission and one of the following condition flags will be set. If the message started to transmit but encountered an error condition, the TXERR and the IRXIF bits will be set and an interrupt will be generated. If the message lost arbitration, the TXLARB bit will be set.",
    "23.6.2 ABORTING TRANSMISSION\nThe MCU can request to abort a message by clearing the  TXREQ  bit  associated  with  the  corresponding message buffer (TXBnCON<3> or BnCON<3>). Setting the ABAT bit (CANCON<4>) will request an abort of all pending messages. If the message has not yet started transmission, or if the message started but is interrupted by loss of arbitration or an error, the abort will  be  processed.  The  abort  is  indicated  when  the module sets the TXABT bit for the corresponding buffer (TXBnCON<6>  or  BnCON<6>).  If  the  message  has started to transmit, it will attempt to transmit the current message fully.  If  the  current  message  is  transmitted fully and is not lost to arbitration or an error, the TXABT bit will not be set because the message was transmitted successfully. Likewise, if a message is being transmitted during an abort request and the message is lost to  arbitration  or  an  error,  the  message  will  not  be retransmitted and the TXABT bit will be set, indicating that the message was successfully aborted.",
    "23.6.2 ABORTING TRANSMISSION\nOnce  an  abort  is  requested  by  setting  the  ABAT  or TXABT bits, it cannot be cleared to cancel the abort request. Only  CAN  module  hardware  or  a  POR condition can clear it.",
    "23.6.3 TRANSMIT PRIORITY\nTransmit priority is a prioritization within the PIC18F2585/2680/4585/4680 devices of the pending transmittable messages. This is independent from and not related to any prioritization implicit in the message arbitration scheme built into the CAN protocol. Prior to sending  the  SOF,  the  priority  of  all  buffers  that  are queued for transmission is compared. The transmit buf- fer with the highest priority will be sent first. If two buffers have the same priority setting, the buffer with the highest buffer number will be sent first. There are four levels  of  transmit  priority.  If  TXP  bits  for  a  particular message buffer are set to ' 11 ', that buffer has the highest possible priority. If TXP bits for a particular message buffer are set to ' 00 ', that buffer has the lowest possible priority.",
    "23.7.1 RECEIVING A MESSAGE\nOf all receive buffers, the MAB is always committed to receiving  the  next  message  from  the  bus.  The  MCU can access one buffer while the other buffer is available for message reception or holding a previously received message.",
    "Note:\nThe entire contents of the MAB are moved into the receive buffer once a message is accepted. This means that regardless of the type of identifier (standard or extended) and the number of data bytes received, the entire receive buffer is overwritten with the MAB contents. Therefore, the  contents  of  all  registers  in  the  buffer must be assumed to have been modified when any message is received.\nWhen a message is moved into either of the receive buffers, the associated RXFUL bit is set. This bit must be cleared by the MCU when it has completed processing the message in the buffer in order to allow a new message  to  be  received  into  the  buffer.  This  bit provides a positive lockout to ensure that the firmware has  finished  with  the  message  before  the  module attempts to load a new message into the receive buffer. If  the receive interrupt is enabled, an interrupt will be generated to indicate that a valid message has been received.",
    "Note:\nOnce a message is loaded into any matching buffer, user firmware may determine exactly what filter caused this  reception  by  checking  the  filter  hit  bits  in  the RXBnCON or BnCON registers. In Mode 0, FILHIT<3:0>  of  RXBnCON  serve  as  filter  hit  bits.  In Mode 1 and 2, FILHIT<4:0> of BnCON serves as filter hit bits. The same registers also indicate whether the current message is an RTR frame or not. A received message is considered a standard identifier message if the EXID bit in the RXBnSIDL or the BnSIDL register is cleared.  Conversely,  a  set  EXID  bit  indicates  an extended identifier message. If the received message is a standard identifier message, user firmware needs to read the SIDL and SIDH registers. In the case of an extended identifier message, firmware should read the SIDL, SIDH, EIDL and EIDH registers. If the RXBnDLC or  BnDLC register contain non-zero data count, user firmware should also read the corresponding number of data  bytes  by  accessing  the  RXBnDm  or  the",
    "Note:\nBnDm registers. When a received message is an RTR and if the current buffer is not configured for automatic RTR handling, user firmware must take appropriate action and respond manually.",
    "Note:\nEach receive buffer contains RXM bits to set special Receive modes. In Mode 0, RXM<1:0> bits in RXBnCON define  a  total  of  four  Receive  modes.  In Mode 1 and 2, RXM1 bit, in combination with the EXID mask  and  filter  bit,  define  the  same  four  Receive modes. Normally, these bits are set to ' 00 '  to  enable reception of all valid messages as determined by the appropriate acceptance filters. In this case, the determination  of  whether  or  not  to  receive  standard  or extended messages is determined by the EXIDE bit in the acceptance filter register. In Mode 0, if the RXM bits are  set  to  ' 01 '  or  ' 10 ',  the  receiver  will  accept  only messages with standard or extended identifiers, respectively. If an acceptance filter has the EXIDE bit set  such  that  it  does  not  correspond  with  the  RXM mode,  that  acceptance  filter  is  rendered  useless.  In Mode 1 and 2, setting EXID in the SIDL Mask register will  ensure  that  only  standard  or  extended  identifiers are  received.  These  two  modes  of  RXM  bits  can",
    "Note:\nbe used in systems where it is known that only standard or extended messages will be on the bus. If the RXM bits are set to ' 11 ' (RXM1 = 1 in Mode 1 and 2), the buffer will  receive all  messages regardless of the values of the acceptance filters. Also, if a message has an error before the end of frame, that portion of the message assembled in the MAB before the error frame will be loaded  into  the  buffer.  This  mode  may  serve  as  a valuable  debugging  tool  for  a  given  CAN  network.  It should not be used in an actual system environment as the  actual  system  will  always  have  some  bus  errors and all nodes on the bus are expected to ignore them.\nIn  Mode  1  and  2,  when  a  programmable  buffer  is configured  as  a  transmit  buffer  and  one  or  more acceptance filters are associated with it, all incoming messages matching this acceptance filter criteria will be  discarded.  To  avoid  this  scenario,  user  firmware must make sure that there  are  no  acceptance  filters associated with a buffer configured as a transmit buffer.",
    "23.7.2 RECEIVE PRIORITY\nWhen in Mode 0, RXB0 is the higher priority buffer and has two message acceptance filters associated with it. RXB1 is the lower priority buffer and has four acceptance filters associated with it. The lower number of acceptance filters  makes  the  match  on  RXB0  more restrictive  and implies a higher priority for that buffer. Additionally, the RXB0CON register can be configured such that if RXB0 contains a valid message and another valid message is received, an overflow error will not occur and the new message  will  be  moved  into  RXB1  regardless  of  the acceptance criteria of RXB1.  There  are also two programmable acceptance filter masks available, one for each receive buffer (see Section 23.5 'CAN Message Buffers' ).\nIn Mode 1 and 2, there are a total of 16 acceptance filters available and each can be dynamically assigned to any of the receive buffers. A buffer with a lower number has higher priority. Given this, if an incoming message matches with two or more receive buffer acceptance criteria, the buffer with the lower number will be loaded with that message.",
    "23.7.3 ENHANCED FIFO MODE\nWhen  configured  for  Mode  2,  two  of  the  dedicated receive  buffers in combination  with  one  or  more programmable  transmit/receive  buffers,  are  used  to create a maximum of an 8 buffer deep FIFO buffer. In this mode, there is no direct correlation between filters and receive buffer registers.  Any filter  that  has  been enabled can generate an acceptance. When a message has been accepted, it is stored in the next available receive buffer register and an internal write pointer is incremented. The FIFO can be a maximum of 8 buffers deep. The entire FIFO must consist of contiguous receive buffers. The FIFO head begins at RXB0 buffer  and  its  tail  spans  toward  B5.  The  maximum length  of  the  FIFO  is  limited  by  the  presence  or absence of the first transmit buffer starting from B0. If a buffer  is  configured  as  a  transmit  buffer,  the  FIFO length  is  reduced  accordingly.  For  instance,  if  B3  is configured  as  a  transmit  buffer,  the  actual  FIFO  will consist  of  RXB0, RXB1, B0, B1 and B2, a total of 5 buffers.  If  B0  is  configured  as  a  transmit  buffer,  the FIFO  length  will  be  2.  If  none",
    "23.7.3 ENHANCED FIFO MODE\nof  the  programmable buffers are configured as a transmit buffer, the FIFO will be 8 buffers deep. A system that requires more transmit buffers should try to locate transmit buffers at the very end  of  B0-B5  buffers  to  maximize  available  FIFO length.\nWhen a message is received in FIFO mode, the interrupt  flag  code  bits  (EICODE<4:0>)  in  the  CANSTAT register  will  have  a  value  of  ' 10000 ',  indicating  the FIFO  has  received  a  message.  FIFO  Pointer  bits, FP<3:0> in the CANCON register, point to the buffer that contains data not yet read. The FIFO pointer bits, in this sense, serve as the FIFO read pointer. The user should use FP bits and read corresponding buffer data. When receive data is no longer needed, the RXFUL bit in the current buffer must be cleared, causing FP<3:0> to be updated by the module.",
    "23.7.3 ENHANCED FIFO MODE\nTo determine whether FIFO is empty or not, the user may use FP<3:0> bits to access the RXFUL bit in the current buffer. If RXFUL is cleared, the FIFO is considered to be empty. If it is set, the FIFO may contain one or more messages. In Mode 2, the module also provides a bit called FIFO High Water Mark (FIFOWM) in the ECANCON register. This bit can be used to cause an interrupt whenever the FIFO contains only one or four empty buffers. The FIFO high water mark interrupt can serve as an early warning to a full FIFO condition.",
    "23.7.4 TIME-STAMPING\nThe CAN module can be programmed to generate a time-stamp for every message that is received. When enabled,  the  module  generates  a  capture  signal  for CCP1, which in turn captures the value of either Timer1 or  Timer3.  This  value  can  be  used  as  the  message time-stamp.\nTo  use  the  time-stamp  capability,  the  CANCAP  bit (CIOCAN<4>) must be set. This replaces the capture input for CCP1 with the signal generated from the CAN module. In addition,  CCP1CON<3:0> must be set to ' 0011 ' to enable the CCP special event trigger for CAN events.",
    "23.8 Message Acceptance Filters and Masks\nThe message acceptance filters and masks are used to determine if a message in the Message Assembly Buffer  should  be  loaded  into  any  of  the  receive  buffers. Once a valid message has been received into the MAB, the identifier fields of the message are compared to the filter values. If there is a match, that message will be loaded  into  the  appropriate  receive  buffer.  The  filter masks are used to determine which bits in the identifier are  examined  with  the  filters.  A  truth  table  is  shown below in Table 23-2 that indicates how each bit in the identifier is compared to the masks and filters to determine if a message should be loaded into a receive buffer.  The  mask  essentially  determines  which  bits  to apply the acceptance filters to. If any mask bit is set to a  zero,  then  that  bit  will  automatically  be  accepted regardless of the filter bit.",
    "23.8 Message Acceptance Filters and Masks\nTABLE 23-2: FILTER/MASK TRUTH TABLE\n\n0, Filter bit n = x. 0, Message Identifier bit n001 = x. 0, Accept or Reject bit n = Accept. 1, Filter bit n = 0. 1, Message Identifier bit n001 = 0. 1, Accept or Reject bit n = Accept. 1, Filter bit n = 0. 1, Message Identifier bit n001 = 1. 1, Accept or Reject bit n = Reject. 1, Filter bit n = 1. 1, Message Identifier bit n001 = 0. 1, Accept or Reject bit n = Reject. 1, Filter bit n = 1. 1, Message Identifier bit n001 = 1. 1, Accept or Reject bit n = Accept\nLegend:\nx = don't care\nIn Mode 0, acceptance filters RXF0 and RXF1 and filter mask RXM0 are associated with RXB0. Filters RXF2, RXF3, RXF4 and RXF5 and mask RXM1  are associated with RXB1.",
    "PIC18F2585/2680/4585/4680\nIn Mode 1 and 2, there are an additional 10 acceptance filters,  RXF6-RXF15,  creating  a  total  of  16  available filters.  RXF15  can  be  used  either  as  an  acceptance filter or acceptance  mask  register.  Each  of  these acceptance  filters can  be individually enabled  or disabled by setting or clearing the RXFENn bit in the RXFCONn register. Any of these 16 acceptance filters can be dynamically associated with any of the receive buffers. Actual association is made by setting appropriate bits in the RXFBCONn register. Each RXFBCONn register contains a nibble for each filter. This nibble can be used to associate a specific filter to any of available receive  buffers.  User  firmware  may  associate  more than one filter to any one specific receive buffer.",
    "PIC18F2585/2680/4585/4680\nIn  addition  to  dynamic  filter  to  buffer  association,  in Mode 1 and 2, each filter can also be dynamically associated to available acceptance mask registers. The FIL-n_m bits in the MSELn register can be used to link a specific acceptance filter to an acceptance mask register.  As  with  filter  to  buffer  association,  one  can  also associate more than one mask to a specific acceptance filter.\nWhen a filter matches and a message is loaded into the receive buffer, the filter number that enabled the message  reception  is  loaded  into  the  FILHIT  bit(s).  In Mode 0 for RXB1, the RXB1CON register contains the FILHIT<2:0> bits. They are coded as follows:\n\u00b7 101 = Acceptance Filter 5 (RXF5)\n\u00b7 100 = Acceptance Filter 4 (RXF4)\n\u00b7 011 = Acceptance Filter 3 (RXF3)\n\u00b7 010 = Acceptance Filter 2 (RXF2)\n\u00b7 001 = Acceptance Filter 1 (RXF1)\n\u00b7 000 = Acceptance Filter 0 (RXF0)",
    "Note:\n' 000 ' and  ' 001 ' can  only  occur  if  the RXB0DBEN  bit  is  set  in  the  RXB0CON register, allowing RXB0  messages  to rollover into RXB1.",
    "FIGURE 23-3: MESSAGE ACCEPTANCE MASK AND FILTER OPERATION\nThe coding of the RXB0DBEN bit enables these three bits  to  be  used  similarly  to  the  FILHIT  bits  and  to distinguish  a  hit  on  filter  RXF0  and  RXF1,  in  either RXB0 or after a rollover into RXB1.\n\u00b7 111 = Acceptance Filter 1 (RXF1)\n\u00b7 110 = Acceptance Filter 0 (RXF0)\n\u00b7 001 = Acceptance Filter 1 (RXF1)\n\u00b7 000 = Acceptance Filter 0 (RXF0)\nIf  the  RXB0DBEN  bit  is  clear,  there  are  six  codes corresponding to the six filters. If the RXB0DBEN bit is set, there are six codes corresponding to the six filters, plus two additional codes corresponding to RXF0 and RXF1 filters, that rollover into RXB1.\nIn Mode 1 and 2, each buffer control register contains 5 bits of filter hit bits (FILHIT<4:0>). A binary value of ' 0 ' indicates a hit from RXF0 and 15 indicates RXF15.",
    "FIGURE 23-3: MESSAGE ACCEPTANCE MASK AND FILTER OPERATION\nIf more than one acceptance filter matches, the FILHIT bits  will  encode  the  binary  value  of  the  lowest  numbered filter that matched. In other words, if filter RXF2 and filter RXF4 match, FILHIT will be loaded with the value for RXF2. This essentially prioritizes the acceptance  filters  with  a  lower  number  filter  having higher  priority.  Messages  are  compared  to  filters  in ascending order of filter number.\nThe  mask  and  filter  registers  can  only  be  modified when the PIC18F2585/2680/4585/4680 devices are in Configuration mode.",
    "23.9 Baud Rate Setting\nAll  nodes  on  a  given  CAN  bus  must  have  the  same nominal bit rate. The CAN protocol uses Non-Returnto-Zero (NRZ) coding which does not encode a clock within  the  data  stream.  Therefore,  the  receive  clock must be recovered by the receiving nodes and synchronized to the transmitter's clock.\nAs  oscillators  and  transmission  time  may  vary  from node  to  node,  the  receiver  must  have  some  type  of Phase Lock Loop (PLL) synchronized to data transmission edges to synchronize and maintain the receiver clock. Since the data is NRZ coded, it is necessary to include  bit  stuffing  to  ensure  that  an  edge  occurs  at least every six bit times to maintain the Digital Phase Lock Loop (DPLL) synchronization.\nThe bit timing of the PIC18F2585/2680/4585/4680 is implemented using a DPLL that is configured to synchronize to the incoming data and provides the nominal timing for the transmitted data. The DPLL breaks each bit  time  into  multiple  segments  made  up  of  minimal periods of time called the Time Quanta (TQ).",
    "23.9 Baud Rate Setting\nBus timing functions executed within the bit time frame, such as synchronization to the local oscillator, network transmission  delay  compensation  and  sample  point positioning, are defined by the programmable bit timing logic of the DPLL.\nAll devices on the CAN bus must use the same bit rate. However, all devices are not required to have the same master oscillator clock frequency. For the different clock frequencies of the individual devices, the bit rate has to be  adjusted  by  appropriately  setting  the  baud  rate prescaler and number of Time Quanta in each segment.\nThe Nominal Bit Rate is the number of bits transmitted per second, assuming an ideal transmitter with an ideal oscillator,  in  the  absence  of  resynchronization.  The nominal bit rate is defined to be a maximum of 1 Mb/s.\nThe Nominal Bit Time is defined as:",
    "EQUATION 23-1:\nTBIT = 1/Nominal Bit Rate",
    "FIGURE 23-4: BIT TIME PARTITIONING\nThe  Nominal  Bit  Time  can  be  thought  of  as  being divided into separate, non-overlapping time segments. These segments (Figure 23-4) include:\n\u00b7 Synchronization Segment (Sync_Seg)\n\u00b7 Propagation Time Segment (Prop_Seg)\n\u00b7 Phase Buffer Segment 1 (Phase_Seg1)\n\u00b7 Phase Buffer Segment 2 (Phase_Seg2)\nThe time segments (and thus the Nominal Bit Time) are in  turn  made  up  of  integer  units  of  time  called  Time Quanta  or  TQ (see  Figure 23-4).  By  definition,  the Nominal Bit Time is programmable from a minimum of 8 TQ to a maximum of 25 TQ. Also by definition, the minimum Nominal Bit Time is 1 \uf06d s, corresponding to a maximum 1 Mb/s rate. The actual duration is given by the following relationship.",
    "EQUATION 23-2:\nNominal Bit Time=\nTQ * (Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2)\nThe  Time  Quantum  is  a  fixed  unit  derived  from  the oscillator period. It is also defined by the programmable baud rate prescaler, with integer values from 1 to 64, in addition to a fixed divide-by-two for clock generation. Mathematically, this is:",
    "EQUATION 23-3:\n<!-- formula-not-decoded -->\nwhere  FOSC  is  the  clock  frequency,  TOSC  is  the corresponding oscillator period and BRP is an integer (0  through  63)  represented  by  the  binary  values  of BRGCON1<5:0>.  The  equation  above  refers  to  the effective clock frequency used by the microcontroller. If, for example, a 10 MHz crystal in HS mode is used, then the  FOSC = 10 MHz  and  TOSC = 100 ns.  If  the  same 10 MHz  crystal  is  used  in  HS-PLL  mode,  then  the effective  frequency  is  FOSC = 40 MHz  and  TOSC = 25 ns.",
    "23.9.1 EXTERNAL CLOCK, INTERNAL CLOCK AND MEASURABLE JITTER IN HS-PLL BASED OSCILLATORS\nThe microcontroller clock frequency generated from a PLL circuit is subject to a jitter, also defined as Phase Jitter or Phase Skew. For its PIC18 Enhanced microcontrollers,  Microchip  specifies  phase jitter  ( P jitter )  as being  2%  (Gaussian  distribution,  within  3  standard deviations, see parameter F13 in Table 27-7) and Total Jitter ( T jitter ) as being 2 * P jitter .\nThe  CAN  protocol  uses  a  bit-stuffing  technique  that inserts a bit of a given polarity following five bits with the opposite polarity. This gives a total of 10 bits transmitted without re-synchronization (compensation for jitter or phase error).",
    "23.9.1 EXTERNAL CLOCK, INTERNAL CLOCK AND MEASURABLE JITTER IN HS-PLL BASED OSCILLATORS\nGiven the random nature of the jitter error added, it can be shown that the total error caused by the jitter tends to cancel itself over time. For a period of 10 bits, it is necessary to add only two jitter intervals to correct for jitter-induced error: one interval in the beginning of the 10-bit period and another at the end. The overall effect is shown in Figure 23-5.",
    "FIGURE 23-5: EFFECTS OF PHASE JITTER ON THE MICROCONTROLLER CLOCK AND CAN BIT TIME\nOnce these considerations are taken into account, it is possible to show that the relation between the jitter and the total frequency error can be defined as:\nFor example, assume a CAN bit rate of 125 Kb/s, which gives an NBT of 8 \uf06d s. For a 16 MHz clock generated from a 4x PLL, the jitter at this clock frequency is:\n<!-- formula-not-decoded -->\nwhere jitter is expressed in terms of time and NBT is the Nominal Bit Time.\n<!-- formula-not-decoded -->\nand resultant frequency error is:\n<!-- formula-not-decoded -->",
    "PIC18F2585/2680/4585/4680\nTable 23-3 shows the relation between the clock generated by the PLL and the frequency error from jitter (measured jitter-induced error of 2%, Gaussian distribution, within 3 standard deviations), as a percentage of the nominal clock frequency.\nThis is clearly smaller than the expected drift of a crystal oscillator, typically specified at 100 ppm or 0.01%. If we add jitter to oscillator drift, we have a total frequency drift of  0.0132%.  The  total  oscillator  frequency  errors  for common clock frequencies and bit rates, including both drift and jitter, are shown in Table 23-4.",
    "TABLE 23-3: FREQUENCY ERROR FROM JITTER AT VARIOUS PLL GENERATED CLOCK SPEEDS\n40 MHz, P jitter = 0.5 ns. 40 MHz, T jitter = 1 ns. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.00125%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.00250%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).2 \uf06d s (500 Kb/s) = 0.005%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).1 \uf06d s (1 Mb/s) = 0.01%. 24 MHz, P jitter = 0.83 ns. 24 MHz, T jitter = 1.67 ns. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.00209%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.00418%. 24 MHz, Frequency Error at Various Nominal Bit Times",
    "TABLE 23-3: FREQUENCY ERROR FROM JITTER AT VARIOUS PLL GENERATED CLOCK SPEEDS\n(Bit Rates).2 \uf06d s (500 Kb/s) = 0.008%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).1 \uf06d s (1 Mb/s) = 0.017%. 16 MHz, P jitter = 1.25 ns. 16 MHz, T jitter = 2.5 ns. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.00313%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.00625%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).2 \uf06d s (500 Kb/s) = 0.013%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).1 \uf06d s (1 Mb/s) = 0.025%",
    "TABLE 23-4: TOTAL FREQUENCY ERROR AT VARIOUS PLL GENERATED CLOCK SPEEDS (100 PPM OSCILLATOR DRIFT, INCLUDING ERROR FROM JITTER)\n40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.01125%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.01250%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).2 \uf06d s (500 Kb/s) = 0.015%. 40 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).1 \uf06d s (1 Mb/s) = 0.02%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.01209%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.01418%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).2 \uf06d s (500 Kb/s) = 0.018%. 24 MHz, Frequency Error at Various Nominal Bit Times (Bit",
    "TABLE 23-4: TOTAL FREQUENCY ERROR AT VARIOUS PLL GENERATED CLOCK SPEEDS (100 PPM OSCILLATOR DRIFT, INCLUDING ERROR FROM JITTER)\nRates).1 \uf06d s (1 Mb/s) = 0.027%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).8 \uf06d s (125 Kb/s) = 0.01313%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).4 \uf06d s (250 Kb/s) = 0.01625%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).2 \uf06d s (500 Kb/s) = 0.023%. 16 MHz, Frequency Error at Various Nominal Bit Times (Bit Rates).1 \uf06d s (1 Mb/s) = 0.035%",
    "23.9.2 TIME QUANTA\nAs already mentioned, the Time Quanta is a fixed unit derived  from  the  oscillator period and  baud  rate prescaler. Its relationship to TBIT and the Nominal Bit Rate is shown in Example 23-6.\nEXAMPLE 23-6:\nCALCULATING TQ, NOMINAL BIT RATE AND NOMINAL BIT TIME\nTQ ( \uf06d s) = (2 * (BRP + 1))/FOSC (MHz)\nTBIT ( \uf06d s) = TQ ( \uf06d s) * number of TQ per bit interval\nNominal Bit Rate (bits/s) = 1/TBIT\nThis frequency (FOSC) refers to the effective frequency used. If, for example, a 10 MHz external signal is used along with a PLL, then the effective frequency will be 4 x 10 MHz which equals 40 MHz.",
    "CASE 1:\nFor FOSC = 16 MHz, BRP<5:0> = 00h and Nominal Bit Time = 8 TQ:\nTQ = (2 * 1)/16 = 0.125 \uf06d s (125 ns)\nTBIT = 8 * 0.125 = 1 \uf06d s (10 -6 s)\nNominal Bit Rate = 1/10 -6 = 10 6 bits/s (1 Mb/s)",
    "CASE 2:\nFor FOSC = 20 MHz, BRP<5:0> = 01h and Nominal Bit Time = 8 TQ:\nTQ = (2 * 2)/20 = 0.2 \uf06d s (200 ns)\nTBIT = 8 * 0.2 = 1.6 \uf06d s (1.6 * 10 -6 s)\nNominal Bit Rate = 1/1.6 * 10 -6 s = 625,000 bits/s (625 Kb/s)",
    "CASE 3:\nFor FOSC = 25 MHz, BRP<5:0> = 3Fh and Nominal Bit Time = 25 TQ:\nTQ = (2 * 64)/25 = 5.12 \uf06d s\nTBIT = 25 * 5.12 = 128 \uf06d s (1.28 * 10 -4 s)\nNominal Bit Rate = 1/1.28 * 10 -4 = 7813 bits/s (7.8 Kb/s)\nThe frequencies of the oscillators in the different nodes must be coordinated in order to provide a system wide specified nominal bit time. This means that all oscillators must have a TOSC that is an integral divisor of TQ. It should also be noted that although the number of TQ is programmable from 4 to 25, the usable minimum is 8 TQ. There is no assurance that a bit time of less than 8 TQ in length will operate correctly.",
    "23.9.3 SYNCHRONIZATION SEGMENT\nThis  part  of  the  bit  time  is  used  to  synchronize  the various CAN nodes on the bus. The edge of the input signal is expected to occur during the sync segment. The duration is 1 TQ.",
    "23.9.4 PROPAGATION SEGMENT\nThis part of the bit time is used to compensate for physical delay times within the network. These delay times consist of the signal propagation time on the bus line and the internal delay time of the nodes. The length of the  Propagation  Segment  can  be  programmed  from 1 TQ to 8 TQ by setting the PRSEG2:PRSEG0 bits.",
    "23.9.5 PHASE BUFFER SEGMENTS\nThe  phase  buffer  segments  are  used  to  optimally locate the sampling point of the received bit within the nominal bit time. The sampling point occurs between Phase  Segment  1  and  Phase  Segment  2.  These segments  can  be  lengthened  or  shortened  by  the resynchronization process. The end of Phase Segment 1  determines  the  sampling  point  within  a  bit  time. Phase Segment 1 is programmable from 1 TQ to 8 TQ in  duration.  Phase  Segment  2  provides  delay  before the next transmitted data transition and is also programmable from 1 TQ to 8 TQ in duration. However, due to IPT requirements, the actual minimum length of Phase Segment 2 is 2 TQ, or it may be defined to be equal  to  the  greater  of  Phase  Segment  1  or  the Information Processing Time (IPT). The sampling point should be as late as possible or approximately 80% of the bit time.",
    "23.9.6 SAMPLE POINT\nThe sample point is the point of time at which the bus level  is  read  and  the  value  of  the  received  bit  is determined. The sampling point occurs at the end of Phase Segment 1. If the bit timing is slow and contains many TQ, it is possible to specify multiple sampling of the  bus  line  at  the  sample  point.  The  value  of  the received bit is determined to be the value of the majority  decision  of  three  values.  The  three  samples  are taken at the sample point and twice before, with a time of TQ/2 between each sample.",
    "23.9.7 INFORMATION PROCESSING TIME\nThe  Information  Processing  Time  (IPT)  is  the  time segment starting at the sample point that is reserved for  calculation  of  the  subsequent  bit  level.  The  CAN specification defines this time to be less than or equal to 2 TQ.  The  PIC18F2585/2680/4585/4680  devices define this time to be 2 TQ. Thus, Phase Segment 2 must be at least 2 TQ long.",
    "23.10 Synchronization\nTo compensate for phase shifts between the oscillator frequencies of each of the nodes on the bus, each CAN controller must be able to synchronize to the relevant signal edge of the incoming signal. When an edge in the transmitted data is detected, the logic will compare the  location  of  the  edge  to  the  expected  time  (Syn-c_Seg). The circuit will then adjust the values of Phase Segment 1 and Phase Segment 2 as necessary. There are two mechanisms used for synchronization.",
    "23.10.1 HARD SYNCHRONIZATION\nHard  synchronization  is  only  done  when  there  is  a recessive to dominant edge during a bus Idle condition, indicating the start of a message. After hard synchronization,  the  bit  time  counters  are  restarted  with  Syn-c_Seg.  Hard  synchronization  forces  the  edge  which has occurred to lie within the synchronization segment of the restarted bit time. Due to the rules of synchronization, if a hard synchronization occurs, there will not be a resynchronization within that bit time.",
    "23.10.2 RESYNCHRONIZATION\nAs  a  result  of  resynchronization,  Phase  Segment  1 may be lengthened or Phase Segment 2 may be shortened. The amount of lengthening or shortening of the phase buffer segments has an upper bound given by the Synchronization Jump Width (SJW). The value of the  SJW  will  be  added  to  Phase  Segment  1  (see Figure 23-6) or subtracted from Phase Segment 2 (see Figure 23-7). The SJW is programmable between 1 TQ and 4 TQ.\nClocking information will only be derived from recessive  to  dominant  transitions.  The  property,  that only a fixed maximum number of successive bits have the same value, ensures resynchronization to the bit stream during a frame.\nThe phase error of an edge is given by the position of the edge relative to Sync_Seg, measured in TQ. The phase error is defined in magnitude of TQ as follows:\n\u00b7 e = 0 if the edge lies within Sync_Seg.\n\u00b7 e > 0 if the edge lies before the sample point.\n\u00b7 e < 0 if the edge lies after the sample point of the previous bit.",
    "23.10.2 RESYNCHRONIZATION\nIf the magnitude of the phase error is less than, or equal to, the programmed value of the Synchronization Jump Width, the effect of a resynchronization is the same as that of a hard synchronization.\nIf  the magnitude of the phase error is larger than the Synchronization Jump Width and if the phase error is positive, then Phase Segment 1 is lengthened by an amount equal to the Synchronization Jump Width.\nIf  the magnitude of the phase error is larger than the resynchronization jump width and if the phase error is negative, then Phase Segment 2 is shortened by an amount equal to the Synchronization Jump Width.",
    "23.10.3 SYNCHRONIZATION RULES\n\u00b7 Only one synchronization within one bit time is allowed.\n\u00b7 An edge will be used for synchronization only if the value detected at the previous sample point (previously read bus value) differs from the bus value immediately after the edge.\n\u00b7 All other recessive to dominant edges fulfilling rules 1 and 2 will be used for resynchronization, with the exception that a node transmitting a dominant bit will not perform a resynchronization as a result of a recessive to dominant edge with a positive phase error.",
    "FIGURE 23-6: LENGTHENING A BIT PERIOD (ADDING SJW TO PHASE SEGMENT 1)\nFIGURE 23-7: SHORTENING A BIT PERIOD (SUBTRACTING SJW FROM PHASE SEGMENT 2)",
    "23.12 Oscillator Tolerance\nSome  requirements  for  programming  of  the  time segments:\n\u00b7 Prop_Seg + Phase_Seg 1 \uf0b3 Phase_Seg 2\n\u00b7 Phase_Seg 2 \uf0b3 Sync Jump Width.\nFor example, assume that a 125 kHz CAN baud rate is desired, using 20 MHz for FOSC. With a TOSC of 50 ns, a baud rate prescaler value of 04h gives a TQ of 500 ns. To obtain a Nominal Bit Rate of 125 kHz, the Nominal Bit Time must be 8 \uf06d s or 16 TQ.\nUsing 1 TQ for the Sync_Seg, 2 TQ for the Prop_Seg and 7 TQ for Phase Segment 1 would place the sample point at 10 TQ after the transition. This leaves 6 TQ for Phase Segment 2.\nBy the rules above, the Sync Jump Width could be the maximum of 4 TQ. However, normally a large SJW is only necessary when the clock generation of the different  nodes  is  inaccurate  or  unstable,  such  as  using ceramic resonators. Typically, an SJW of 1 is enough.",
    "23.12 Oscillator Tolerance\nAs a rule of thumb, the bit timing requirements allow ceramic  resonators  to  be  used  in  applications  with transmission rates of up to 125 Kbit/sec. For the full bus speed range of the CAN protocol, a quartz oscillator is required. A maximum node-to-node oscillator variation of 1.7% is allowed.",
    "23.13 Bit Timing Configuration Registers\nThe  Baud  Rate  Control  registers  (BRGCON1,  BRGCON2, BRGCON3) control the bit timing for the CAN bus  interface.  These  registers  can  only  be  modified when the PIC18F2585/2680/4585/4680 devices are in Configuration mode.",
    "23.13.1 BRGCON1\nThe  BRP  bits  control  the  baud  rate  prescaler.  The SJW<1:0> bits select the synchronization jump width in terms of multiples of TQ.",
    "23.13.2 BRGCON2\nThe PRSEG bits set the length of the propagation segment in terms of TQ. The SEG1PH bits set the length of Phase  Segment  1  in  TQ.  The  SAM  bit  controls  how many times the RXCAN pin is sampled. Setting this bit to a ' 1 ' causes the bus to be sampled three times: twice at TQ/2 before the sample point and once at the normal sample point (which is at the end of Phase Segment 1). The value of the bus is determined to be the value read during at least two of the samples. If the SAM bit is set to a ' 0 ', then the RXCAN pin is sampled only once at the sample point. The SEG2PHTS bit controls how the length of Phase Segment 2 is determined. If this bit is set  to  a  ' 1 ',  then  the  length  of  Phase  Segment  2",
    "23.13.2 BRGCON2\nis determined by the SEG2PH bits of BRGCON3. If the SEG2PHTS bit is set to a ' 0 ', then the length of Phase Segment 2 is the greater of Phase Segment 1 and the Information Processing Time (which is fixed at 2 TQ for the PIC18F2585/2680/4585/4680).",
    "23.13.3 BRGCON3\nThe PHSEG2<2:0> bits set the length (in TQ) of Phase Segment 2 if the SEG2PHTS bit is set to a ' 1 '.  If  the SEG2PHTS bit is set to a ' 0 ', then the PHSEG2<2:0> bits have no effect.",
    "23.14 Error Detection\nThe CAN protocol provides sophisticated error detection  mechanisms.  The  following  errors  can  be detected.",
    "23.14.1 CRC ERROR\nWith the Cyclic Redundancy Check (CRC), the transmitter calculates special check bits for the bit sequence, from the start of a frame until the end of the data  field.  This  CRC  sequence  is  transmitted  in  the CRC field. The receiving node also calculates the CRC sequence  using  the  same  formula  and  performs  a comparison to the received sequence. If a mismatch is detected, a CRC error has occurred and an error frame is generated. The message is repeated.",
    "23.14.2 ACKNOWLEDGE ERROR\nIn the Acknowledge field of a message, the transmitter checks if the Acknowledge slot (which was sent out as a recessive bit) contains a dominant bit. If not, no other node  has  received  the  frame  correctly.  An  Acknowledge error has occurred, an error frame is generated and the message will have to be repeated.",
    "23.14.3 FORM ERROR\nIf  a  node  detects  a  dominant  bit  in  one  of  the  four segments, including End-Of-Frame, interframe space, Acknowledge delimiter or CRC delimiter, then a form error  has  occurred  and  an  error  frame  is  generated. The message is repeated.",
    "23.14.4 BIT ERROR\nA bit error occurs if a transmitter sends a dominant bit and detects a recessive bit, or if it sends a recessive bit and detects a dominant bit, when monitoring the actual bus level and comparing it to the just transmitted bit. In the case where the transmitter sends a recessive bit and a dominant bit is  detected  during  the  arbitration field and the Acknowledge  slot, no bit error is generated because normal arbitration is occurring.",
    "23.14.5 STUFF BIT ERROR\nlf, between the Start-Of-Frame and the CRC delimiter, six consecutive bits with the same  polarity are detected, the bit stuffing rule has been violated. A stuff bit error occurs and an error frame is generated. The message is repeated.",
    "23.14.6 ERROR STATES\nDetected errors are made public to all other nodes via error frames. The  transmission of the erroneous message is aborted and the frame is repeated as soon as possible. Furthermore, each CAN node is in one of the three error states: 'error-active', 'error-passive' or 'bus-off',  according  to  the  value  of  the  internal  error counters.  The  error-active  state  is  the  usual  state where  the  bus  node  can  transmit  messages  and activate error frames (made of dominant bits) without any restrictions. In the error-passive state, messages and passive error frames (made of recessive bits) may be transmitted. The bus-off state makes it temporarily impossible  for  the  station  to  participate  in  the  bus communication. During this state, messages  can neither be received nor transmitted.",
    "23.14.7 ERROR MODES AND ERROR COUNTERS\nThe PIC18F2585/2680/4585/4680 devices contain two error counters: the Receive Error Counter (RXERRCNT) and  the  Transmit  Error  Counter  (TXERRCNT).  The values of both counters can be read by the MCU. These counters are incremented or decremented in accordance with the CAN bus specification.",
    "PIC18F2585/2680/4585/4680\nThe  PIC18F2585/2680/4585/4680  devices  are  erroractive if both error counters are below the error-passive limit of 128. They are error-passive if at least one of the error counters equals or exceeds 128. They go to busoff if the transmit error counter equals or exceeds the bus-off  limit  of  256.  The  devices  remain  in  this  state until  the  bus-off  recovery  sequence  is  received.  The bus-off recovery sequence consists of 128 occurrences of  11  consecutive  recessive  bits  (see  Figure 23-8). Note  that  the  CAN  module,  after  going  bus-off,  will recover back to error-active without any intervention by the MCU if the bus remains Idle for 128 x 11 bit times. If this is not desired, the error Interrupt Service Routine should  address  this.  The  current  Error  mode  of  the CAN  module  can  be  read  by  the  MCU  via  the COMSTAT register.\nAdditionally,  there  is  an  Error  State  Warning  flag  bit, EWARN, which is set if at least one of the error counters  equals  or  exceeds  the  error  warning  limit  of  96. EWARN is reset if both error counters are less than the error warning limit.",
    "23.15 CAN Interrupts\nThe module has several sources of interrupts. Each of these interrupts can be individually enabled or disabled.  The  PIR3  register  contains  interrupt  flags. The PIE3 register contains the enables for the 8 main interrupts. A  special set of read-only  bits in the CANSTAT  register,  the  ICODE  bits,  can  be  used  in combination with a jump table for efficient handling of interrupts.\nAll interrupts have one source, with the exception of the error interrupt and buffer interrupts in Mode 1 and 2. Any of the error interrupt sources can set the error interrupt flag. The source of the error interrupt can be determined by reading the Communication Status register, COMSTAT. In  Mode  1  and  2,  there  are  two  interrupt enable/disable and flag bits - one for all transmit buffers and the other for all receive buffers.\nThe interrupts can be broken up into two categories: receive and transmit interrupts.\nThe receive related interrupts are:\n\u00b7 Receive Interrupts\n\u00b7 Wake-up Interrupt\n\u00b7 Receiver Overrun Interrupt\n\u00b7 Receiver Warning Interrupt\n\u00b7 Receiver Error-Passive Interrupt\nThe transmit related interrupts are:\n\u00b7 Transmit Interrupts\n\u00b7 Transmitter Warning Interrupt\n\u00b7 Transmitter Error-Passive Interrupt\n\u00b7 Bus-Off Interrupt",
    "23.15.1 INTERRUPT CODE BITS\nTo simplify  the  interrupt  handling  process  in  user  firmware, the ECAN module encodes a special set of bits. In Mode 0,  these  bits  are  ICODE<3:1>  in  the  CANSTAT register. In Mode 1 and 2, these bits are EICODE<4:0> in the CANSTAT register. Interrupts are internally prioritized such that the higher priority interrupts are assigned lower values. Once the highest priority interrupt condition has been cleared, the code for the next highest priority interrupt that is pending (if any) will be reflected by the ICODE bits  (see  Table 23-5).  Note  that  only  those  interrupt sources that have their associated interrupt enable bit set will be reflected in the ICODE bits.\nIn Mode 2, when a receive message interrupt occurs, the EICODE bits will always consist of ' 10000 '.  User firmware may use FIFO pointer bits to actually access the next available buffer.",
    "23.15.2 TRANSMIT INTERRUPT\nWhen the transmit interrupt is enabled, an interrupt will be  generated  when  the  associated  transmit  buffer becomes empty and is ready to be loaded with a new message.  In  Mode  0,  there  are  separate  interrupt enable/disable and flag bits for each of the three dedicated transmit buffers. The TXBnIF bit will be set to indicate the source of the interrupt. The interrupt is cleared by the MCU, resetting the TXBnIF bit to a ' 0 '. In Mode 1 and 2, all transmit buffers share one interrupt enable/ disable bit and one flag bit. In Mode 1 and 2, TXBnIE in PIE3 and TXBnIF in PIR3 indicate when a transmit buffer has completed transmission of its message. TXBnIF, TXBnIE and TXBnIP in PIR3, PIE3 and IPR3, respectively, are not used in Mode 1 and 2. Individual transmit buffer interrupts can be enabled or disabled by setting or clearing TXBIE and BIE0 register bits. When a shared interrupt occurs, user firmware must poll the TXREQ bit of all transmit buffers to detect the source of interrupt.",
    "23.15.3 RECEIVE INTERRUPT\nWhen the receive interrupt is enabled, an interrupt will be generated when a message has been successfully received and loaded into the associated receive buffer. This interrupt is activated immediately after receiving the End-Of-Frame (EOF) field.\nIn Mode 0, the RXBnIF bit is set to indicate the source of the interrupt. The interrupt is cleared by the MCU, resetting the RXBnIF bit to a ' 0 '.\nIn  Mode  1  and  2,  all  receive  buffers  share  RXBIE, RXBIF and RXBIP in PIE3, PIR3 and IPR3, respectively. Bits RXBnIE, RXBnIF and RXBnIP are not used. Individual receive buffer interrupts can be controlled by the  TXBIE  and  BIE0  registers.  In  Mode  1,  when  a shared  receive  interrupt  occurs,  user  firmware  must poll the RXFUL bit of each receive buffer to detect the source  of  interrupt.  In  Mode  2,  a  receive  interrupt indicates that the new message is loaded into FIFO. FIFO can be read by using FIFO Pointer bits, FP.",
    "23.15.3 RECEIVE INTERRUPT\nTABLE 23-5: VALUES FOR ICODE<3:1>\n\n000, Interrupt = None. 000, Boolean Expression = ERR\u2022WAK\u2022TX0\u2022TX1\u2022TX2\u2022RX0\u2022RX1. 001, Interrupt = Error. 001, Boolean Expression = ERR. 010, Interrupt = TXB2. 010, Boolean Expression = ERR\u2022TX0\u2022TX1\u2022TX2. 011, Interrupt = TXB1. 011, Boolean Expression = ERR\u2022TX0\u2022TX1. 100, Interrupt = TXB0. 100, Boolean Expression = ERR\u2022TX0. 101, Interrupt = RXB1. 101, Boolean Expression = ERR\u2022TX0\u2022TX1\u2022TX2\u2022RX0\u2022RX1. 110, Interrupt = RXB0. 110, Boolean Expression = ERR\u2022TX0\u2022TX1\u2022TX2\u2022RX0. 111, Interrupt = Wake on Interrupt. 111, Boolean Expression = ERR\u2022TX0\u2022TX1\u2022TX2\u2022RX0\u2022RX1\u2022WAK",
    "Legend:\nERR = ERRIF * ERRIE\nRX0 = RXB0IF * RXB0IE\nTX0 = TXB0IF * TXB0IE\nRX1 = RXB1IF * RXB1IE\nTX1 = TXB1IF * TXB1IE\nWAK = WAKIF * WAKIE\nTX2 = TXB2IF * TXB2IE",
    "23.15.4 MESSAGE ERROR INTERRUPT\nWhen an error occurs during transmission or reception of a message, the message error flag, IRXIF, will be set and if the IRXIE bit is set, an interrupt will be generated. This  is  intended  to  be  used  to  facilitate  baud  rate determination  when  used  in  conjunction  with  Listen Only mode.",
    "23.15.6.3 Transmitter Warning\nWhen the PIC18F2585/2680/4585/4680 devices are in Sleep mode and the bus activity wake-up interrupt is enabled, an interrupt will be generated and the WAKIF bit will be set when activity is detected on the CAN bus. This interrupt causes  the PIC18F2585/2680/4585/ 4680 devices to exit Sleep mode. The interrupt is reset by the MCU, clearing the WAKIF bit.",
    "23.15.6 ERROR INTERRUPT\nWhen  the  error  interrupt  is  enabled,  an  interrupt  is generated if an overflow condition occurs or if the error state of the transmitter or receiver has changed. The error flags in COMSTAT  will  indicate  one  of  the following conditions.",
    "23.15.6.1 Receiver Overflow\nAn  overflow  condition  occurs  when  the  MAB  has assembled  a  valid  received  message  (the  message meets  the  criteria  of  the  acceptance  filters)  and  the receive buffer associated with the filter is not available for loading of a new  message.  The associated RXBnOVFL bit in the COMSTAT register will be set to indicate the overflow condition. This bit must be cleared by the MCU.",
    "23.15.6.2 Receiver Warning\nThe  receive  error  counter  has  reached  the  MCU warning limit of 96.\nThe  transmit  error  counter  has  reached  the  MCU warning limit of 96.",
    "23.15.6.4 Receiver Bus Passive\nThe  receive  error  counter  has  exceeded  the  errorpassive  limit  of  127  and  the  device  has  gone  to error-passive state.",
    "23.15.6.5 Transmitter Bus Passive\nThe  transmit  error  counter  has  exceeded  the  errorpassive  limit  of  127  and  the  device  has  gone  to error-passive state.",
    "23.15.6.6 Bus-Off\nThe transmit error counter has exceeded 255 and the device has gone to bus-off state.",
    "23.15.6.7 Interrupt Acknowledge\nInterrupts  are  directly  associated  with  one  or  more status flags in the PIR register. Interrupts are pending as long as one of the flags is set. Once an interrupt flag is set by the device, the flag can not be reset by the microcontroller until the interrupt condition is removed.",
    "24.0 SPECIAL FEATURES OF THE CPU\nPIC18F2585/2680/4585/4680 devices include several features intended to maximize reliability and minimize cost through elimination of external components. These are:\n\u00b7 Oscillator Selection\n\u00b7 Resets:\n-Power-on Reset (POR)\n-Power-up Timer (PWRT)\n-Oscillator Start-up Timer (OST)\n-Brown-out Reset (BOR)\n\u00b7 Interrupts\n\u00b7 Watchdog Timer (WDT)\n\u00b7 Fail-Safe Clock Monitor\n\u00b7 Two-Speed Start-up\n\u00b7 Code Protection\n\u00b7 ID Locations\n\u00b7 In-Circuit Serial Programming\nThe  oscillator  can  be  configured  for  the  application depending on frequency, power, accuracy and cost. All of  the  options  are  discussed  in  detail  in Section 2.0 'Oscillator Configurations' .\nA complete discussion of device Resets and interrupts is available in previous sections of this data sheet.\nIn  addition  to  their  Power-up  and  Oscillator  Start-up Timers  provided  for  Resets,  PIC18F2585/2680/4585/ 4680 devices have a Watchdog Timer, which is either permanently  enabled  via  the  Configuration  bits  or software controlled (if configured as disabled).",
    "24.0 SPECIAL FEATURES OF THE CPU\nThe inclusion of an internal RC oscillator also provides the  additional  benefits  of  a  Fail-Safe  Clock  Monitor (FSCM) and Two-Speed Start-up. FSCM provides for background  monitoring  of  the  peripheral  clock  and automatic switchover in the event of its failure.  TwoSpeed Start-up  enables  code  to  be  executed  almost immediately on start-up, while the primary clock source completes its start-up delays.\nAll  of  these  features  are  enabled  and  configured  by setting the appropriate Configuration register bits.",
    "24.1 Configuration Bits\nThe Configuration  bits  can  be  programmed  (read  as ' 0 ') or left unprogrammed (read as ' 1 ') to select various device configurations. These bits are mapped starting at program memory location 300000h.\nThe user will note that address 300000h is beyond the user program memory space. In fact, it belongs to the configuration memory space (300000h-3FFFFFh), which can only be accessed using table reads and table writes.\nProgramming the Configuration registers is done in a manner similar to programming the Flash memory. The WR bit in the EECON1 register starts a self-timed write to the Configuration register. In normal operation mode, a TBLWT instruction with the TBLPTR pointing to the Configuration register sets up the address and the data for the Configuration register write. Setting the WR bit starts  a  long write  to  the  Configuration  register.  The Configuration registers are written a byte at a time. To write or erase a configuration cell, a TBLWT instruction can write a ' 1 ' or a ' 0 ' into the cell. For additional details on Flash programming, refer to Section 5.5 'Writing to Flash Program Memory' .",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDs\n300001h, File Name = CONFIG1H. 300001h, Bit 7 = IESO. 300001h, Bit 6 = FCMEN. 300001h, Bit 5 = -. 300001h, Bit 4 = -. 300001h, Bit 3 = FOSC3. 300001h, Bit 2 = FOSC2. 300001h, Bit 1 = FOSC1. 300001h, Bit 0 = FOSC0. 300001h, Default/ Unprogrammed Value = 00-- 0111. 300001h, Default/ Unprogrammed Value = 00-- 0111. 300002h, File Name = CONFIG2L. 300002h, Bit 7 = -. 300002h, Bit 6 = -. 300002h, Bit 5 = -. 300002h, Bit 4 = BORV1. 300002h, Bit 3 = BORV0. 300002h, Bit 2 = BOREN1. 300002h, Bit 1 = BOREN0. 300002h, Bit 0 = PWRTEN.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDs\n300002h, Default/ Unprogrammed Value = ---1 1111. 300002h, Default/ Unprogrammed Value = ---1 1111. 300003h, File Name = CONFIG2H. 300003h, Bit 7 = -. 300003h, Bit 6 = -. 300003h, Bit 5 = -. 300003h, Bit 4 = WDTPS3. 300003h, Bit 3 = WDTPS2. 300003h, Bit 2 = WDTPS1. 300003h, Bit 1 = WDTPS0. 300003h, Bit 0 = WDTEN. 300003h, Default/ Unprogrammed Value = ---1 1111. 300003h, Default/ Unprogrammed Value = ---1 1111. 300005h, File Name = CONFIG3H. 300005h, Bit 7 = MCLRE. 300005h, Bit 6 = -. 300005h, Bit 5 = -. 300005h, Bit 4 = -.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDs\n300005h, Bit 3 = -. 300005h, Bit 2 = LPT1OSC. 300005h, Bit 1 = PBADEN. 300005h, Bit 0 = -. 300005h, Default/ Unprogrammed Value = 1---. 300005h, Default/ Unprogrammed Value = -01-. 300006h, File Name = CONFIG4L. 300006h, Bit 7 = DEBUG. 300006h, Bit 6 = XINST. 300006h, Bit 5 = BBSIZ1. 300006h, Bit 4 = BBSIZ2. 300006h, Bit 3 = -. 300006h, Bit 2 = LVP. 300006h, Bit 1 = -. 300006h, Bit 0 = STVREN. 300006h, Default/ Unprogrammed Value = 1000. 300006h, Default/ Unprogrammed Value = -1-1. 300008h, File Name = CONFIG5L. 300008h, Bit 7 = -.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDs\n300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3. 300008h, Bit 2 = CP2. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300008h, Default/ Unprogrammed Value = ----. 300008h, Default/ Unprogrammed Value = 1111. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 300009h, Default/ Unprogrammed Value = 11-- ----. 300009h, Default/ Unprogrammed Value = . 30000Ah, File Name",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDs\n= CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4 = -. 30000Ah, Bit 3 = WRT3. 30000Ah, Bit 2 = WRT2. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Ah, Default/ Unprogrammed Value = ---- 1111. 30000Ah, Default/ Unprogrammed Value = ---- 1111. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Bh, Default/ Unprogrammed Value = 111- ----. 30000Bh, Default/ Unprogrammed Value",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDs\n= 111- ----. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3. 30000Ch, Bit 2 = EBTR2. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Ch, Default/ Unprogrammed Value = ---- 1111. 30000Ch, Default/ Unprogrammed Value = ---- 1111. 30000Dh, File Name = CONFIG7H. 30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -. 30000Dh, Default/ Unprogrammed Value =",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDs\n-1--. 30000Dh, Default/ Unprogrammed Value = ----. 3FFFFEh, File Name = DEVID1. 3FFFFEh, Bit 7 = DEV2. 3FFFFEh, Bit 6 = DEV1. 3FFFFEh, Bit 5 = DEV0. 3FFFFEh, Bit 4 = REV4. 3FFFFEh, Bit 3 = REV3. 3FFFFEh, Bit 2 = REV2. 3FFFFEh, Bit 1 = REV1. 3FFFFEh, Bit 0 = REV0. 3FFFFEh, Default/ Unprogrammed Value = xxxx. 3FFFFEh, Default/ Unprogrammed Value = xxxx (1). 3FFFFFh, File Name = DEVID2. 3FFFFFh, Bit 7 = DEV10. 3FFFFFh, Bit 6 = DEV9. 3FFFFFh, Bit 5 = DEV8. 3FFFFFh, Bit 4 = DEV7. 3FFFFFh, Bit 3 = DEV6. 3FFFFFh, Bit 2 = DEV5.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDs\n3FFFFFh, Bit 1 = DEV4. 3FFFFFh, Bit 0 = DEV3. 3FFFFFh, Default/ Unprogrammed Value = 0000. 3FFFFFh, Default/ Unprogrammed Value = 1100\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition.\nShaded cells are unimplemented, read as ' 0 '.\nNote 1: See Register 24-14 for DEVID1 values. DEVID registers are read-only and cannot be programmed by the user.",
    "REGISTER 24-1:\nbit 7",
    "CONFIG1H: CONFIGURATION REGISTER 1 HIGH (BYTE ADDRESS 300001h)\nR/P-0, 1 = R/P-0. R/P-0, 2 = U-0. R/P-0, 3 = U-0. R/P-0, 4 = R/P-0. R/P-0, 5 = R/P-1. R/P-0, 6 = R/P-1. R/P-0, 7 = R/P-1. IESO, 1 = FCMEN. IESO, 2 = -. IESO, 3 = -. IESO, 4 = FOSC3. IESO, 5 = FOSC2. IESO, 6 = FOSC1. IESO, 7 = FOSC0\nbit 7\nbit 0\nIESO: Internal/External Oscillator Switchover bit\n1 = Oscillator Switchover mode enabled\n0 = Oscillator Switchover mode disabled bit 6 FCMEN: Fail-Safe Clock Monitor Enable bit\n1 = Fail-Safe Clock Monitor enabled\n0 = Fail-Safe Clock Monitor disabled bit 5-4 Unimplemented: Read as ' 0 '",
    "CONFIG1H: CONFIGURATION REGISTER 1 HIGH (BYTE ADDRESS 300001h)\nbit 3-0 FOSC3:FOSC0: Oscillator Selection bits\n11xx =External RC oscillator, CLKO function on RA6\n101x =External RC oscillator, CLKO function on RA6\n1001 =Internal oscillator block, CLKO function on RA6, port function on RA7\n1000 =Internal oscillator block, port function on RA6 and RA7\n0111 =External RC oscillator, port function on RA6\n0110 =HS oscillator, PLL enabled (Clock Frequency = 4 x FOSC1)\n0101 =EC oscillator, port function on RA6\n0100 =EC oscillator, CLKO function on RA6\n0011 =External RC oscillator, CLKO function on RA6\n0010 =HS oscillator\n0001 =XT oscillator\n0000 =LP oscillator",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state\nREGISTER 24-2:",
    "CONFIG2L: CONFIGURATION REGISTER 2 LOW (BYTE ADDRESS 300002h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/P-1. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = BORV1. -, 4 = BORV0. -, 5 = BOREN1 (1). -, 6 = BOREN0 (1). -, 7 = PWRTEN (1)\nbit 7\nbit 0\nbit 7-5 Unimplemented: Read as ' 0 '\nbit 4-3 BORV1:BORV0: Brown-out Reset Voltage bits\n11 = VBOR set to 2.1V\n10 = VBOR set to 2.8V\n01 = VBOR set to 4.3V\n00 = VBOR set to 4.6V",
    "CONFIG2L: CONFIGURATION REGISTER 2 LOW (BYTE ADDRESS 300002h)\nbit 2-1 BOREN1:BOREN0 Brown-out Reset Enable bits (1)\n11 =Brown-out Reset enabled in hardware only (SBOREN is disabled)\n10 =Brown-out Reset enabled in hardware only and disabled in Sleep mode\n(SBOREN is disabled)\n01 =Brown-out Reset enabled and controlled by software (SBOREN is enabled)\n00 =Brown-out Reset disabled in hardware and software\nPWRTEN:\nPower-up Timer Enable bit (1)\n1 = PWRT disabled\n0 = PWRT enabled\nNote 1: The Power-up Timer is decoupled from Brown-out Reset, allowing these features to be independently controlled.",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state\nbit 0",
    "CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/P-1. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = WDTPS3. -, 4 = WDTPS2. -, 5 = WDTPS1. -, 6 = WDTPS0. -, 7 = WDTEN\nbit 7\nbit 0\nbit 7-5 Unimplemented: Read as ' 0 '\nbit 4-1 WDTPS3:WDTPS0: Watchdog Timer Postscale Select bits\n1111 = 1:32,768\n1110 = 1:16,384\n1101 = 1:8,192\n1100 = 1:4,096\n1011 = 1:2,048\n1010 = 1:1,024\n1001 = 1:512",
    "CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\n1000 = 1:256\n0111 = 1:128\n0110 = 1:64\n0101 = 1:32\n0100 = 1:16\n0011 = 1:8\n0010 = 1:4\n0001 = 1:2\n0000 = 1:1",
    "bit 0 WDTEN: Watchdog Timer Enable bit\n1 = WDT enabled\n0 = WDT disabled (control is placed on the SWDTEN bit)",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "CONFIG3H: CONFIGURATION REGISTER 3 HIGH (BYTE ADDRESS 300005h)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = R/P-0. R/P-1, 6 = R/P-1. R/P-1, 7 = U-0. MCLRE, 1 = -. MCLRE, 2 = -. MCLRE, 3 = -. MCLRE, 4 = -. MCLRE, 5 = LPT1OSC. MCLRE, 6 = PBADEN. MCLRE, 7 = -\nbit 7\nbit 0",
    "bit 7\nMCLRE: MCLR Pin Enable bit\n1 = MCLR pin enabled; RE3 input pin disabled\n0 = RE3 input pin enabled; MCLR disabled\nbit 6-3 Unimplemented: Read as ' 0 '\nbit 2 LPT1OSC: Low-Power Timer 1 Oscillator Enable bit\n1 = Timer1 configured for low-power operation\n0 = Timer1 configured for higher power operation",
    "bit 1 PBADEN: PORTB A/D Enable bit\n(Affects ADCON1 Reset state. ADCON1 controls PORTB<4:0> pin configuration.)\n1 = PORTB<4:0> pins are configured as analog input channels on Reset\n0 = PORTB<4:0> pins are configured as digital I/O on Reset",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-5: CONFIG4L: CONFIGURATION REGISTER 4 LOW (BYTE ADDRESS 300006h)\nR/P-1, 1 = R/P-0. R/P-1, 2 = R/P-0. R/P-1, 3 = R/P-0. R/P-1, 4 = U-0. R/P-1, 5 = R/P-1. R/P-1, 6 = U-0. R/P-1, 7 = R/P-1. DEBUG, 1 = XINST. DEBUG, 2 = BBSIZ1. DEBUG, 3 = BBSIZ2. DEBUG, 4 = -. DEBUG, 5 = LVP. DEBUG, 6 = -. DEBUG, 7 = STVREN\nbit 7\nbit 0\nbit 7\nDEBUG: Background Debugger Enable bit\n1 = Background debugger disabled, RB6 and RB7 configured as general purpose I/O pins\n0 = Background debugger enabled, RB6 and RB7 are dedicated to In-Circuit Debug\nbit 6\nXINST: Extended Instruction Set Enable bit",
    "REGISTER 24-5: CONFIG4L: CONFIGURATION REGISTER 4 LOW (BYTE ADDRESS 300006h)\n1 = Instruction set extension and Indexed Addressing mode enabled\n0 = Instruction set extension and Indexed Addressing mode disabled (Legacy mode)\nbit 5 BBSIZ1: Boot Block Size Select Bit 1\n11 = 4K words (8 Kbytes) boot block\n10 = 4K words (8 Kbytes) boot block",
    "bit 4 BBSIZ2: Boot Block Size Select Bit 0\n01 = 2K words (4 Kbytes) boot block\n00 = 1K words (2 Kbytes) boot block\nbit 3 Unimplemented: Read as ' 0 '\nbit 2 LVP:\nSingle-Supply ICSP Enable bit\n1 = Single-Supply ICSP enabled\n0 = Single-Supply ICSP disabled\nbit 1 Unimplemented: Read as ' 0 '\nbit 0\nSTVREN: Stack Full/Underflow Reset Enable bit\n1 = Stack full/underflow will cause Reset\n0 = Stack full/underflow will not cause Reset",
    "Legend:\nR = Readable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "CONFIG5L: CONFIGURATION REGISTER 5 LOW (BYTE ADDRESS 300008h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = CP3 (1). -, 5 = CP2. -, 6 = CP1. -, 7 = CP0\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3 CP3: Code Protection bit (1)\n1 = Block 3 (00C000-00FFFFh) not code-protected\n0 = Block 3 (00C000-00FFFFh) code-protected\nNote 1: Unimplemented in PIC18FX585 devices; maintain this bit set.",
    "bit 2 CP2: Code Protection bit\n1 = Block 2 (008000-00BFFFh) not code-protected\n0 = Block 2 (008000-00BFFFh) code-protected\nbit 1 CP1: Code Protection bit\n1 = Block 1 (004000-007FFFh) not code-protected\n0 = Block 1 (004000-007FFFh) code-protected\nbit 0 CP0: Code Protection bit\n1 = Block 0 (000800-003FFFh) not code-protected\n0 = Block 0 (000800-003FFFh) code-protected",
    "Legend:\nR = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 24-7: CONFIG5H: CONFIGURATION REGISTER 5 HIGH (BYTE ADDRESS 300009h)\nR/C-1, 1 = R/C-1. R/C-1, 2 = U-0. R/C-1, 3 = U-0. R/C-1, 4 = U-0. R/C-1, 5 = U-0. R/C-1, 6 = U-0. R/C-1, 7 = U-0. CPD, 1 = CPB. CPD, 2 = -. CPD, 3 = -. CPD, 4 = -. CPD, 5 = -. CPD, 6 = -. CPD, 7 = -\nbit 7\nbit 0\nbit 7\nCPD: Data EEPROM Code Protection bit\n1 = Data EEPROM not code-protected\n0 = Data EEPROM code-protected",
    "bit 6\nCPB: Boot Block Code Protection bit\n1 = Boot block (000000-0007FFh) not code-protected\n0 = Boot block (000000-0007FFh) code-protected",
    "Legend:\nR = Readable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "CONFIG6L: CONFIGURATION REGISTER 6 LOW (BYTE ADDRESS 30000Ah)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = WRT3 (1). -, 5 = WRT2. -, 6 = WRT1. -, 7 = WRT0\nbit 7\nbit 0\n- bit 7-4 Unimplemented: Read as ' 0\n'\nbit 3 WRT3: Write Protection bit (1)\n1 = Block 3 (00C000-00FFFFh) not write-protected\n0 = Block 3 (00C000-00FFFFh) write-protected\nNote 1: Unimplemented in PIC18FX585 devices; maintain this bit set.",
    "bit 2 WRT2: Write Protection bit\n1 = Block 2 (008000-00BFFFh) not write-protected\n0 = Block 2 (008000-00BFFFh) write-protected\nbit 1 WRT1: Write Protection bit\n1 = Block 1 (004000-007FFFh) not write-protected\n0 = Block 1 (004000-007FFFh) write-protected\nbit 0 WRT0: Write Protection bit\n1 = Block 0 (000800-003FFFh) not write-protected\n0 = Block 0 (000800-003FFFh) write-protected",
    "Legend:\nR = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 24-9: CONFIG6H: CONFIGURATION REGISTER 6 HIGH (BYTE ADDRESS 30000Bh)\nR/C-1, 1 = R/C-1. R/C-1, 2 = R-1. R/C-1, 3 = U-0. R/C-1, 4 = U-0. R/C-1, 5 = U-0. R/C-1, 6 = U-0. R/C-1, 7 = U-0. WRTD, 1 = WRTB. WRTD, 2 = WRTC (1). WRTD, 3 = -. WRTD, 4 = -. WRTD, 5 = -. WRTD, 6 = -. WRTD, 7 = -\nbit 7\nbit 0\nbit 7 WRTD: Data EEPROM Write Protection bit\n1 = Data EEPROM not write-protected\n0 = Data EEPROM write-protected\nbit 6 WRTB: Boot Block Write Protection bit\n1 = Boot block (000000-0007FFh) not write-protected\n0 = Boot block (000000-0007FFh) write-protected",
    "REGISTER 24-9: CONFIG6H: CONFIGURATION REGISTER 6 HIGH (BYTE ADDRESS 30000Bh)\nbit 5 WRTC: Configuration Register Write Protection bit (1)\n1 = Configuration registers (300000-3000FFh) not write-protected\n0 = Configuration registers (300000-3000FFh) write-protected\nNote 1: This bit is read-only in normal execution mode; it can be written only in Program mode.",
    "Legend:\nR = Readable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-10: CONFIG7L: CONFIGURATION REGISTER 7 LOW (BYTE ADDRESS 30000Ch)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = EBTR3 (1). -, 5 = EBTR2. -, 6 = EBTR1. -, 7 = EBTR0\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3\nEBTR3: Table Read Protection bit (1)\n1 = Block 3 (00C000-00FFFFh) not protected from table reads executed in other blocks\n0 = Block 3 (00C000-00FFFFh) protected from table reads executed in other blocks\nNote 1: Unimplemented in PIC18FX585 devices; maintain this bit set.",
    "bit 2 EBTR2 : Table Read Protection bit\n1 = Block 2 (008000-00BFFFh) not protected from table reads executed in other blocks\n0 = Block 2 (008000-00BFFFh) protected from table reads executed in other blocks\nbit 1\nEBTR1: Table Read Protection bit\n1 = Block 1 (004000-007FFFh) not protected from table reads executed in other blocks\n0 = Block 1 (004000-007FFFh) protected from table reads executed in other blocks\nbit 0\nEBTR0: Table Read Protection bit\n1 = Block 0 (000800-003FFFh) not protected from table reads executed in other blocks\n0 = Block 0 (000800-003FFFh) protected from table reads executed in other blocks",
    "Legend:\nR = Readable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-11: CONFIG7H: CONFIGURATION REGISTER 7 HIGH (BYTE ADDRESS 30000Dh)\nU-0, 1 = R/C-1. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = U-0. -, 1 = EBTRB. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = -\nbit 7\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6 EBTRB: Boot Block Table Read Protection bit\n1 = Boot block (000000-0007FFh) not protected from table reads executed in other blocks\n0 = Boot block (000000-0007FFh) protected from table reads executed in other blocks\nbit 5-0 Unimplemented: Read as ' 0 '",
    "REGISTER 24-11: CONFIG7H: CONFIGURATION REGISTER 7 HIGH (BYTE ADDRESS 30000Dh)\nLegend:, 1 = Legend:. R = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 24-12: DEVICE ID REGISTER 1 FOR PIC18F2585/2680/4585/4680 DEVICES\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV2, 1 = DEV1. DEV2, 2 = DEV0. DEV2, 3 = REV4. DEV2, 4 = REV3. DEV2, 5 = REV2. DEV2, 6 = REV1. DEV2, 7 = REV0\nbit 7\nbit 0",
    "bit 7-5 DEV2:DEV0: Device ID bits\n111 = PIC18F2585\n110 = PIC18F2680\n101 = PIC18F4585\n100 = PIC18F4680",
    "bit 4-0 REV4:REV0: Revision ID bits\nThese bits are used to indicate the device revision.",
    "Legend:\nR = Read-only bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-13: DEVICE ID REGISTER 2 FOR PIC18F2585/2680/4585/4680 DEVICES\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV10, 1 = DEV9. DEV10, 2 = DEV8. DEV10, 3 = DEV7. DEV10, 4 = DEV6. DEV10, 5 = DEV5. DEV10, 6 = DEV4. DEV10, 7 = DEV3\nbit 7\nbit 0",
    "bit 7-0 DEV10:DEV3: Device ID bits\nThese bits are used with the DEV2:DEV0 bits in the Device ID Register 1 to identify the part number.\n0000 1110 = PIC18F2585/2680/4585/4680 devices\nNote:\nThese values for DEV10:DEV3 may be shared with other devices. The specific device is always identified by using the entire DEV10:DEV0 bit sequence.",
    "Legend:\nR = Read-only bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "24.2 Watchdog Timer (WDT)\nFor PIC18F2585/2680/4585/4680 devices, the WDT is driven  by  the  INTRC  source.  When  the  WDT  is enabled, the clock source is also enabled. The nominal WDT period is 4 ms and has the same stability as the INTRC oscillator.\nThe 4 ms period of the WDT is multiplied by a 16-bit postscaler. Any  output  of  the WDT  postscaler  is selected by a multiplexer, controlled by bits in Configuration Register 2H. Available periods range from 4 ms to  131.072  seconds  (2.18  minutes).  The  WDT  and postscaler are cleared when any of the following events occur: a SLEEP or CLRWDT instruction is executed, the IRCF  bits  (OSCCON<6:4>)  are  changed  or  a  clock failure has occurred.\n.",
    "24.2 Watchdog Timer (WDT)\nNote 1: The CLRWDT and SLEEP instructions clear  the  WDT  and  postscaler  counts when executed.\n2: Changing  the  setting  of  the  IRCF  bits (OSCCON<6:4>)  clears  the  WDT  and postscaler counts.\n3: When a CLRWDT instruction is executed, the postscaler count will be cleared.",
    "24.2.1 CONTROL REGISTER\nRegister 24-14 shows the WDTCON register. This is a readable and writable register which contains a control bit  that  allows  software  to  override  the  WDT  enable Configuration bit, but only if the Configuration bit has disabled the WDT.",
    "REGISTER 24-14: WDTCON: WATCHDOG TIMER CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = SWDTEN (1)\nbit 7\nbit 0\nbit 7-1 Unimplemented : Read as ' 0 '\nbit 0\nSWDTEN: Software Controlled Watchdog Timer Enable bit (1)\n1 = Watchdog Timer is on\n0 = Watchdog Timer is off\nNote 1: This bit has no effect if the Configuration bit, WDTEN, is enabled.\nLegend:, 1 = Legend:. R = Readable bit, 1 = W=Writable bit. U = Unimplemented bit, read as '0', 1 = -n = Value at POR",
    "TABLE 24-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nRCON, Bit 7 = IPEN. RCON, Bit 6 = SBOREN. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Reset Values on page = 45. WDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN. WDTCON, Reset Values on page = 47\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by the Watchdog Timer.",
    "24.3 Two-Speed Start-up\nThe Two-Speed Start-up feature helps to minimize the latency period from oscillator start-up to code execution by  allowing  the  microcontroller  to  use  the  INTRC oscillator  as  a  clock  source  until  the  primary  clock source is available. It is enabled by setting the IESO Configuration bit.\nTwo-Speed  Start-up  should  be  enabled  only  if  the primary  oscillator  mode  is  LP,  XT,  HS  or  HSPLL (Crystal-based modes). Other sources do not require an OST start-up delay; for these, Two-Speed Start-up should be disabled.\nWhen enabled, Resets and wake-ups from Sleep mode cause  the  device  to  configure  itself  to  run  from  the internal oscillator block as the clock source, following the time-out of the Power-up Timer after a Power-on Reset is enabled. This allows almost immediate code execution  while  the  primary  oscillator  starts  and  the OST is running. Once the OST times out, the device automatically switches to PRI_RUN mode.",
    "24.3 Two-Speed Start-up\nReset. For wake-ups from Sleep, the INTOSC or postscaler  clock  sources  can  be  selected  by  setting  the IRCF2:IRCF0 bits prior to entering Sleep mode.\nIn all other power managed modes, Two-Speed Start-up is not used. The device will be clocked by the currently selected  clock  source  until  the  primary  clock  source becomes  available.  The  setting  of  the  IESO  bit  is ignored.",
    "24.3.1 SPECIAL CONSIDERATIONS FOR USING TWO-SPEED START-UP\nWhile using the INTRC oscillator in Two-Speed Start-up, the device still obeys the normal command sequences for  entering  power  managed  modes,  including  serial SLEEP instructions  (refer  to Section 3.1.4  'Multiple Sleep Commands' ). In practice, this means that user code can change the SCS1:SCS0 bit settings or issue SLEEP instructions before the OST times out. This would allow an application to briefly wake-up, perform routine 'housekeeping'  tasks  and  return  to  Sleep  before  the device starts to operate from the primary oscillator.\nBecause  the  OSCCON  register  is  cleared  on  Reset events, the INTOSC (or postscaler) clock source is not initially available after a Reset event; the INTRC clock is used directly at its base frequency. To use a higher clock  speed  on  wake-up,  the  INTOSC  or  postscaler clock sources can be selected to provide a higher clock speed by setting bits, IRCF2:IRCF0, immediately after",
    "24.3.1 SPECIAL CONSIDERATIONS FOR USING TWO-SPEED START-UP\nUser code can also check if the primary clock source is currently providing the device clocking by checking the status of the OSTS bit (OSCCON<3>). If the bit is set, the primary oscillator is providing the clock. Otherwise, the internal oscillator block is providing the clock during wake-up from Reset or Sleep mode.",
    "24.4 Fail-Safe Clock Monitor\nThe Fail-Safe Clock Monitor (FSCM)  allows the microcontroller to continue operation in the event of an external oscillator failure by automatically switching the device clock to the internal oscillator block. The FSCM function is enabled by setting the FCMEN Configuration bit.\nWhen FSCM is enabled, the INTRC oscillator runs at all times to monitor clocks to peripherals and provide a backup  clock  in  the  event  of  a  clock  failure.  Clock monitoring (shown in Figure 24-3) is accomplished by creating a sample clock signal, which is the INTRC output  divided  by  64.  This  allows  ample  time  between FSCM sample clocks  for  a  peripheral  clock  edge  to occur.  The  peripheral  device  clock  and  the  sample clock are presented as inputs to the Clock Monitor latch (CM). The CM is set on the falling edge of the device clock  source,  but  cleared  on  the  rising  edge  of  the sample clock.",
    "FIGURE 24-3: FSCM BLOCK DIAGRAM\nClock  failure  is  tested  for  on  the  falling  edge  of  the sample  clock.  If  a  sample  clock  falling  edge  occurs while CM is still set, a clock failure has been detected (Figure 24-4). This causes the following:\n\u00b7 the FSCM generates an oscillator fail interrupt by setting bit OSCFIF (PIR2<7>);\n\u00b7 the device clock source is switched to the internal oscillator block (OSCCON is not updated to show the current clock source - this is the fail-safe condition); and\n\u00b7 the WDT is reset.\nDuring  switchover,  the  postscaler  frequency  from  the internal oscillator block may not be sufficiently stable for timing sensitive applications. In these cases, it may be desirable to select another clock configuration and enter an alternate power managed mode. This can be done to attempt a partial recovery or execute a controlled shutdown. See Section 3.1.4 'Multiple Sleep Commands' and Section 24.3.1 'Special Considerations for Using Two-Speed Start-up' for more details.",
    "FIGURE 24-3: FSCM BLOCK DIAGRAM\nTo use a higher clock speed on wake-up, the INTOSC or postscaler clock sources can be selected to provide a  higher  clock  speed  by  setting  bits,  IRCF2:IRCF0, immediately after Reset. For wake-ups from Sleep, the INTOSC or postscaler clock sources can be selected by setting the IRCF2:IRCF0 bits prior to entering Sleep mode.\nThe FSCM will detect failures of the primary or secondary clock sources only. If the internal oscillator block fails, no failure would be detected, nor would any action be possible.",
    "24.4.1 FSCM AND THE WATCHDOG TIMER\nBoth  the  FSCM  and  the  WDT  are  clocked  by  the INTRC  oscillator.  Since  the  WDT  operates  with  a separate divider and counter, disabling the WDT has no effect on the operation of the INTRC oscillator when the FSCM is enabled.\nAs already noted, the clock source is switched to the INTOSC  clock  when  a  clock  failure is detected. Depending on the frequency selected by the IRCF2:IRCF0 bits, this may mean a substantial change in the speed of code execution. If the WDT is enabled with a small prescale value, a decrease in clock speed allows  a  WDT  time-out  to  occur  and  a  subsequent device  Reset.  For  this  reason,  fail-safe  clock  events also reset the WDT and postscaler, allowing it to start timing from when execution speed was changed and decreasing the likelihood of an erroneous time-out.",
    "24.4.2 EXITING FAIL-SAFE OPERATION\nThe fail-safe condition is terminated by either a device Reset  or  by  entering  a  power  managed  mode.  On Reset,  the  controller  starts  the  primary  clock  source specified in Configuration Register 1H  (with any required  start-up  delays  that  are  required  for  the oscillator  mode,  such  as  OST  or  PLL  timer).  The INTOSC multiplexer provides the device clock until the primary clock source becomes ready (similar to a TwoSpeed Start-up). The clock source is then switched to the  primary  clock  (indicated  by  the  OSTS  bit  in  the OSCCON register becoming set). The Fail-Safe Clock Monitor then resumes monitoring the peripheral clock.\nThe  primary  clock  source  may  never  become  ready during start-up. In this case, operation is clocked by the INTOSC multiplexer. The OSCCON register will remain in  its  Reset  state  until  a  power  managed  mode  is entered.",
    "24.4.4 POR OR WAKE-UP FROM SLEEP\nBy entering a power  managed  mode,  the  clock multiplexer  selects  the  clock  source  selected  by  the OSCCON register. Fail-Safe Monitoring of the power managed clock source resumes in the power managed mode.\nIf  an  oscillator  failure  occurs  during  power  managed operation, the subsequent events depend on whether or  not  the  oscillator  failure  interrupt  is  enabled.  If enabled (OSCFIF = 1 ), code execution will be clocked by  the  INTOSC  multiplexer.  An  automatic  transition back to the failed clock source will not occur.\nIf the interrupt is disabled, subsequent interrupts while in  Idle  mode  will  cause  the  CPU  to  begin  executing instructions while being clocked by the INTOSC source.\nThe FSCM is designed to detect oscillator failure at any point  after  the  device  has  exited  Power-on  Reset (POR) or low-power Sleep mode. When the primary device clock is EC, RC or INTRC modes, monitoring can begin immediately following these events.",
    "24.4.4 POR OR WAKE-UP FROM SLEEP\nFor  oscillator  modes  involving  a  crystal  or  resonator (HS,  HSPLL,  LP  or  XT),  the  situation  is  somewhat different.  Since  the  oscillator  may  require  a  start-up time considerably longer than the FCSM sample clock time, a false clock failure may be detected. To prevent this, the internal oscillator block is automatically configured as the device clock and functions until the primary clock  is  stable  (the  OST  and  PLL  timers  have  timed out).  This  is  identical  to  Two-Speed  Start-up  mode. Once the primary clock is stable, the INTRC returns to its role as the FSCM source.",
    "PIC18F2585/2680/4585/4680\nNote:\nThe same logic that prevents false oscillator failure interrupts on POR, or wake from Sleep,  will  also  prevent  the  detection  of the oscillator's failure to start at all following these events. This can be avoided by monitoring  the  OSTS  bit  and  using  a timing routine to determine if the oscillator is  taking  too  long  to  start.  Even  so,  no oscillator failure interrupt will be flagged.\nAs  noted  in Section 24.3.1  'Special  Considerations for Using Two-Speed Start-up' ,  it  is  also  possible to select another clock configuration and enter an alternate power managed mode while waiting for the primary clock to become stable. When the new power managed mode is selected, the primary clock is disabled.",
    "24.5 Program Verification and Code Protection\nThe  overall  structure  of  the  code  protection  on  the PIC18  Flash  devices  differs  significantly  from  other PIC \u00ae  devices.\nThe user program memory is divided into five blocks. One of these is a boot block of 2 Kbytes. The remainder of  the  memory  is  divided  into  four  blocks  on  binary boundaries.\nEach of the five blocks has three code protection bits associated with them. They are:\n\u00b7 Code-Protect bit (CPn)\n\u00b7 Write-Protect bit (WRTn)\n\u00b7 External Block Table Read bit (EBTRn)\nFigure 24-5 shows the program memory organization for  48  and  64-Kbyte  devices  and  the  specific  code protection bit associated with each block. The actual locations of the bits are summarized in Table 24-3.",
    "FIGURE 24-5: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F2585/2680/4585/4680\nBoot Block, MEMORY SIZE/DEVICE.64 Kbytes (PIC18F2680/4680) = Boot Block. Boot Block, Address Range = 000000h 0007FFh. Boot Block, Block Code Protection.Controlled By: = CPB, WRTB, EBTRB. Block 0, MEMORY SIZE/DEVICE.64 Kbytes (PIC18F2680/4680) = Block 0. Block 0, Address Range = 000800h 003FFFh. Block 0, Block Code Protection.Controlled By: = CP0, WRT0, EBTR0. Block 1, MEMORY SIZE/DEVICE.64 Kbytes (PIC18F2680/4680) = Block 1. Block 1, Address Range = 004000h 007FFFh. Block 1, Block Code Protection.Controlled By: = CP1, WRT1, EBTR1. Block 2, MEMORY SIZE/DEVICE.64 Kbytes (PIC18F2680/4680) = Block 2. Block 2, Address Range = 008000h",
    "FIGURE 24-5: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F2585/2680/4585/4680\n00B7FFh. Block 2, Block Code Protection.Controlled By: = CP2, WRT2, EBTR2. Unimplemented Read ' 0 's, MEMORY SIZE/DEVICE.64 Kbytes (PIC18F2680/4680) = Block 3. Unimplemented Read ' 0 's, Address Range = 00C000h 00FFFFh. Unimplemented Read ' 0 's, Block Code Protection.Controlled By: = CP3, WRT3, EBTR3. Unimplemented Read ' 0 's, MEMORY SIZE/DEVICE.64 Kbytes (PIC18F2680/4680) = Unimplemented Read ' 0 's. Unimplemented Read ' 0 's, Address Range = (Unimplemented Memory Space). Unimplemented Read ' 0 's, Block Code Protection.Controlled By: = (Unimplemented Memory Space)",
    "TABLE 24-3: SUMMARY OF CODE PROTECTION REGISTERS\n300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3*. 300008h, Bit 2 = CP2. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4 = -.",
    "TABLE 24-3: SUMMARY OF CODE PROTECTION REGISTERS\n30000Ah, Bit 3 = WRT3*. 30000Ah, Bit 2 = WRT2. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3*. 30000Ch, Bit 2 = EBTR2. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Dh, File Name = CONFIG7H.",
    "TABLE 24-3: SUMMARY OF CODE PROTECTION REGISTERS\n30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -\nLegend: Shaded cells are unimplemented.\n- * Unimplemented in PIC18FX585 devices; maintain this bit set.",
    "24.5.1 PROGRAM MEMORY CODE PROTECTION\nNote:\nThe program memory may be read to or written from any  location  using  the  table  read  and  table  write instructions.  The  device  ID  may  be  read  with  table reads.  The  Configuration  registers  may  be  read  and written with the table read and table write instructions.\nIn normal execution mode, the CPn bits have no direct effect.  CPn  bits  inhibit  external  reads  and  writes.  A block  of  user  memory  may  be  protected  from  table writes if the WRTn Configuration bit is ' 0 '. The EBTRn bits  control  table  reads.  For  a  block  of  user  memory with the EBTRn bit set to ' 0 ',  a  table read instruction that executes from within that block is allowed to read. A table read instruction that executes from a location outside  of  that  block  is  not  allowed  to  read  and  will result in reading ' 0 's. Figures 24-6 through 24-8 illustrate table write and table read protection.",
    "24.5.1 PROGRAM MEMORY CODE PROTECTION\nCode protection bits may only be written to a ' 0 '  from a ' 1 '  state. It is not possible to write  a  ' 1 '  to  a  bit  in  the  ' 0 '  state.  Code protection bits are only set to ' 1 ' by a full chip erase or block erase function. The full chip erase and block erase functions can only be initiated  via  ICSP  or  an  external programmer.",
    "FIGURE 24-6: TABLE WRITE (WRTn) DISALLOWED\nTBLPTR = 0008FFh PC = 003FFEh, Program Memory = TBLWT*. TBLPTR = 0008FFh PC = 003FFEh, Program Memory = 003FFFh. TBLPTR = 0008FFh PC = 003FFEh, Configuration Bit Settings = WRT0, EBTR0 = 01. PC = 00BFFEh, Program Memory = TBLWT*. PC = 00BFFEh, Program Memory = 007FFFh 008000h 00BFFFh 00C000h. PC = 00BFFEh, Configuration Bit Settings = WRT1, EBTR1 = 11 WRT2, EBTR2 = 11 WRT3, EBTR3 = 11. Results: All table writes disabled to Blockn whenever WRTn = 0 ., Program Memory = Results: All table writes disabled to Blockn whenever WRTn = 0 .. Results: All table writes disabled to Blockn whenever WRTn = 0 ., Program Memory = Results: All table writes disabled to Blockn whenever WRTn = 0 .. Results: All",
    "FIGURE 24-6: TABLE WRITE (WRTn) DISALLOWED\ntable writes disabled to Blockn whenever WRTn = 0 ., Configuration Bit Settings = Results: All table writes disabled to Blockn whenever WRTn = 0 .",
    "FIGURE 24-7: EXTERNAL BLOCK TABLE READ (EBTRn) DISALLOWED\nTBLPTR = 0008FFh, Program Memory = . TBLPTR = 0008FFh, Program Memory = 000000h 0007FFh 000800h. TBLPTR = 0008FFh, Configuration Bit Settings = WRTB, EBTRB = 11 WRT0, EBTR0. PC = 007FFEh, Program Memory = TBLRD*. PC = 007FFEh, Program Memory = 003FFFh 004000h 007FFFh 008000h 00BFFFh. PC = 007FFEh, Configuration Bit Settings = WRT1, EBTR1 = 11 WRT2, EBTR2 = 11 WRT3, EBTR3 = 11. Results: All table reads from external blocks to Blockn are disabled whenever TABLAT register returns a value of ' 0 '., Program Memory = . Results: All table reads from external blocks to Blockn are disabled whenever TABLAT register returns a value of ' 0 '., Program Memory = . Results: All table reads from external blocks to Blockn are disabled whenever TABLAT register returns a",
    "FIGURE 24-7: EXTERNAL BLOCK TABLE READ (EBTRn) DISALLOWED\nvalue of ' 0 '., Configuration Bit Settings = EBTRn = 0 .",
    "FIGURE 24-8: EXTERNAL BLOCK TABLE READ (EBTRn) ALLOWED\nTBLPTR = 0008FFh PC = 003FFEh, Program Memory = . TBLPTR = 0008FFh PC = 003FFEh, Configuration Bit Settings = WRT0, EBTR0 = 10 WRT1, EBTR1 = 11 WRT2, EBTR2 = 11 WRT3, EBTR3 = 11. Results: Table reads permitted within Blockn, even when EBTRBn = 0 . TABLAT register returns the value of the data at the location, Program Memory = TBLPTR.. Results: Table reads permitted within Blockn, even when EBTRBn = 0 . TABLAT register returns the value of the data at the location, Configuration Bit Settings = ",
    "24.5.2 DATA EEPROM CODE PROTECTION\nThe entire  data  EEPROM  is  protected  from  external reads and writes by two bits: CPD and WRTD. CPD inhibits  external  reads  and  writes  of  data  EEPROM. WRTD  inhibits  internal  and  external  writes  to  data EEPROM. The CPU can continue to read and write data EEPROM regardless of the protection bit settings.",
    "24.5.3 CONFIGURATION REGISTER PROTECTION\nThe  Configuration  registers  can  be  write-protected. The WRTC bit controls protection of the Configuration registers. In normal execution mode, the WRTC bit is readable only. WRTC can only be written via ICSP or an external programmer.",
    "24.6 ID Locations\nEight memory locations (200000h-200007h) are designated as ID locations, where the user can store checksum or other code identification numbers. These locations are both readable and writable during normal execution through the TBLRD and TBLWT instructions or during program/verify. The ID locations can be read when the device is code-protected.",
    "24.7 In-Circuit Serial Programming\nPIC18F2585/2680/4585/4680 microcontrollers can be serially programmed while in the end application circuit. This is simply done with two lines for clock and data and  three  other  lines  for  power,  ground  and  the programming voltage. This allows customers to manufacture boards with unprogrammed devices and then program the microcontroller just before shipping the product. This also allows the most recent firmware or a custom firmware to be programmed.",
    "24.8 In-Circuit Debugger\nWhen the DEBUG Configuration bit is programmed to a ' 0 ',  the In-Circuit Debugger functionality is enabled. This function allows simple debugging functions when used with MPLAB \u00ae  IDE. When the microcontroller has this feature enabled, some resources are not available for general use. Table 24-4 shows which resources are required by the background debugger.",
    "TABLE 24-4: DEBUGGER RESOURCES\nI/O pins:, 1 = RB6, RB7. Stack:, 1 = 2 levels\nNote:\nMemory resources listed in MPLAB \u00ae  IDE.\nTo use the In-Circuit Debugger function of the microcontroller, the design must implement In-Circuit Serial Programming  connections  to  MCLR/VPP/RE3,  VDD, VSS, RB7 and RB6. This will interface to the In-Circuit debugger module available from Microchip or one of the third party development tool companies.",
    "24.9 Single-Supply ICSP Programming\nThe LVP Configuration bit enables Single-Supply ICSP programming  (formerly  known  as Low-Voltage  ICSP Programming or LVP ).  When  Single-Supply  Programming is enabled, the microcontroller can be programmed without  requiring  high  voltage  being  applied  to  the MCLR/VPP/RE3 pin, but the RB5/KBI1/PGM pin is then dedicated to controlling Program mode entry and is not available as a general purpose I/O pin.\nWhile programming using Single-Supply Programming, VDD is applied to the MCLR/VPP/RE3 pin as in normal execution mode. To enter Programming mode, VDD is applied to the PGM pin.",
    "PIC18F2585/2680/4585/4680\nNote 1: High-voltage programming is always available, regardless of the state of the LVP bit, by applying VIHH to the MCLR pin.\n2: While in Low-Voltage ICSP Programming mode, the RB5 pin can no longer be used as a general purpose I/O pin and should be held low during normal operation.\n3: When using Low-Voltage ICSP Programming (LVP) and the pull-ups on PORTB are enabled, bit 5 in the TRISB register must be cleared to disable the pull-up on RB5 and ensure the proper operation of the device.\n4: If  the  device  Master  Clear  is  disabled, verify that either of the following is done to ensure proper entry into ICSP mode:\na)disable Low-Voltage Programming (CONFIG4l<2> = 0 ); or\nb)make certain that RB5/PGM is held low during entry into ICSP.",
    "PIC18F2585/2680/4585/4680\nIf Single-Supply ICSP Programming mode will not be used, the LVP bit can be cleared. RB5/KBI1/PGM then becomes available as the digital I/O pin, RB5. The LVP bit  may  be  set  or  cleared  only  when  using  standard high-voltage programming (VIHH applied to the MCLR/ VPP/RE3 pin). Once LVP has been disabled, only the standard  high-voltage  programming  is  available  and must be used to program the device.\nMemory that is not code-protected can be erased using either a block erase, or erased row by row, then written at any specified VDD. If code-protected memory is to be erased, a block erase is required. If a block erase is to be performed when using Low-Voltage Programming, the device must be supplied with VDD   of 4.5V to 5.5V.",
    "25.0 INSTRUCTION SET SUMMARY\nPIC18F2585/2680/4585/4680 devices incorporate the standard set of 75 PIC18 core instructions, as well as an extended set of 8 new instructions, for the optimization of code that is recursive or that utilizes a software stack.  The  extended  set  is  discussed  later  in  this section.",
    "25.1 Standard Instruction Set\nThe standard PIC18 instruction set adds many enhancements to the previous PIC \u00ae  MCU instruction sets, while maintaining an easy migration from these PIC  MCU  instruction  sets.  Most  instructions  are  a single program memory word (16 bits), but there are four  instructions  that  require  two  program  memory locations.\nEach single-word instruction is  a  16-bit  word  divided into an opcode, which specifies the instruction type and one  or  more  operands,  which  further  specify  the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18 instruction set summary in Table 25-2 lists byte-oriented , bit-oriented , literal and control operations. Table 25-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')",
    "25.1 Standard Instruction Set\nThe  file  register  designator  'f'  specifies  which  file register is to be used by the instruction. The destination designator 'd' specifies where the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result is placed in the file register specified in the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "25.1 Standard Instruction Set\n\u00b7 A program memory address (specified by 'n')\n\u00b7 The mode of the CALL or RETURN instructions (specified by 's')\n\u00b7 The mode of the table read and table write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll  instructions  are  a  single  word,  except  for  four double-word instructions. These instructions were made double-word to contain the required information in 32 bits. In the second word, the 4 MSbs are ' 1 's. If this  second  word  is  executed  as  an  instruction  (by itself), it will execute as a NOP .\nAll  single-word  instructions  are  executed  in  a  single instruction cycle, unless a conditional test is true or the program counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles with the additional instruction cycle(s) executed as a NOP .\nThe double-word instructions execute in two instruction cycles.",
    "25.1 Standard Instruction Set\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \uf06d s. If a conditional test is true, or the program counter is changed as a result of an instruction,  the  instruction  execution  time  is  2 \uf06d s. Two-word branch instructions (if true) would take 3 \uf06d s.\nFigure 25-1 shows the general formats that the instructions can have. All examples use the convention 'nnh' to represent a hexadecimal number.\nThe  Instruction  Set  Summary,  shown  in  Table 25-2, lists the standard instructions recognized by the Microchip MPASM\u2122 Assembler.\nSection 25.1.1 'Standard Instruction Set' provides a description of each instruction.",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\na, Description = RAM access bit a = 0 : RAM location in Access RAM (BSR register is ignored) a = 1 : RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7).. BSR, Description = Bank Select Register. Used to select the current RAM bank.. C, DC, Z, OV,, Description = ALU Status bits: C arry, D igit C arry, Z ero, Ov erflow, N egative.. d, Description = Destination select bit d = 0 : store result in WREG d = 1 : store result in file register f. dest, Description = Destination: either the WREG register or the specified register file location.. f, Description = 8-bit Register file address (00h to FFh), or 2-bit FSR designator (0h to 3h).. f s, Description = 12-bit Register file address (000h to FFFh). This is the source address.. f d, Description = 12-bit Register file address (000h to FFFh). This",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\nis the destination address.. GIE, Description = Global Interrupt Enable bit.. k, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value). label, Description = Label name. mm, Description = The mode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions:. *, Description = No change to register (such as TBLPTR with table reads and writes) Post-Increment register (such as TBLPTR with table reads and writes). *+, Description = . *-, Description = Post-Decrement register (such as TBLPTR with table reads and writes). +*, Description = Pre-Increment register (such as TBLPTR with table reads and writes). n, Description = The relative address (2's complement number) for relative branch instructions or the direct address for Call/Branch and Return instructions. PCL, Description = Program Counter Low Byte.. PCH, Description = Program Counter High Byte.. PCLATH, Description = Program Counter High Byte Latch..",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\nPCLATU, Description = Program Counter Upper Byte Latch.. PD, Description = Power-down bit.. PRODH, Description = Product of Multiply High Byte.. PRODL, Description = Product of Multiply Low Byte.. s, Description = Fast Call/Return mode select bit s = 0 : do not update into/from shadow registers s = 1 : certain registers loaded into/from shadow registers (Fast mode). TBLPTR, Description = 21-bit Table Pointer (points to a Program Memory location).. TABLAT, Description = 8-bit Table Latch.. TO, Description = Time-out bit.. TOS, Description = Top-of-Stack.. u, Description = Unused or unchanged.. WDT, Description = Watchdog Timer.. WREG, Description = Working register (accumulator).. x, Description = Don't care (' 0 ' or ' 1 '). The assembler will generate code with x = 0 . It is the recommended form of use for compatibility with all Microchip software tools.. z s, Description = 7-bit offset value for indirect addressing of register files (source).. z",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\nd, Description = 7-bit offset value for indirect addressing of register files (destination).. { }, Description = Optional argument.. [text], Description = Indicates an indexed address.. (text), Description = The contents of text .. [expr]<n>, Description = Specifies bit n of the register indicated by the pointer expr .. \uf0ae, Description = Assigned to.. < >, Description = Register bit field.. \uf0ce, Description = In the set of. User defined. italics, Description = term (font is Courier).",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nBYTE-ORIENTED OPERATIONS, Mnemonic,.Operands = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Description.Description = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Cycles.Cycles = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Status Affected.Status Affected = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Notes.Notes = BYTE-ORIENTED OPERATIONS. ADDWF, Mnemonic,.Operands = f, d, a. ADDWF, Description.Description = Add WREG and f. ADDWF, Cycles.Cycles = 1. ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word.MSb = 01da. ADDWF, 16-Bit Instruction Word. = ffff. ADDWF,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n16-Bit Instruction Word.LSb = ffff. ADDWF, Status Affected.Status Affected = C, DC, Z, OV, N. ADDWF, Notes.Notes = 1, 2. ADDWFC, Mnemonic,.Operands = f, d, a. ADDWFC, Description.Description = Add WREG and Carry bit to f. ADDWFC, Cycles.Cycles = 1. ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word.MSb = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status Affected.Status Affected = C, DC, Z, OV, N. ADDWFC, Notes.Notes = 1, 2. ANDWF, Mnemonic,.Operands = f, d, a. ANDWF, Description.Description = AND WREG with f. ANDWF, Cycles.Cycles = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nANDWF, 16-Bit Instruction Word.MSb = 01da. ANDWF, 16-Bit Instruction Word. = ffff. ANDWF, 16-Bit Instruction Word.LSb = ffff. ANDWF, Status Affected.Status Affected = Z, N. ANDWF, Notes.Notes = 1,2. CLRF, Mnemonic,.Operands = f, a. CLRF, Description.Description = Clear f. CLRF, Cycles.Cycles = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word.MSb = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status Affected.Status Affected = Z. CLRF, Notes.Notes = 2. COMF, Mnemonic,.Operands = f, d, a. COMF, Description.Description = Complement f. COMF, Cycles.Cycles = 1. COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nWord.MSb = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status Affected.Status Affected = Z, N. COMF, Notes.Notes = 1, 2. CPFSEQ, Mnemonic,.Operands = f, a. CPFSEQ, Description.Description = Compare f with WREG, skip = 1. CPFSEQ, Cycles.Cycles = (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word.MSb = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status Affected.Status Affected = None. CPFSEQ, Notes.Notes = 4. CPFSGT, Mnemonic,.Operands = f, a. CPFSGT, Description.Description = Compare f with WREG, skip > 1. CPFSGT, Cycles.Cycles =",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n(2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word.MSb = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status Affected.Status Affected = None. CPFSGT, Notes.Notes = 4. CPFSLT, Mnemonic,.Operands = f, a. CPFSLT, Description.Description = Compare f with WREG, skip < 1. CPFSLT, Cycles.Cycles = (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word.MSb = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status Affected.Status Affected = None. CPFSLT, Notes.Notes = 1, 2. DECF, Mnemonic,.Operands = f, d, a.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nDECF, Description.Description = Decrement f. DECF, Cycles.Cycles = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word.MSb = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status Affected.Status Affected = C, DC, Z, OV, N. DECF, Notes.Notes = 1, 2, 3, 4. DECFSZ, Mnemonic,.Operands = f, d, a. DECFSZ, Description.Description = Decrement f, Skip if 0. DECFSZ, Cycles.Cycles = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word.MSb = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status Affected.Status Affected = None. DECFSZ,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nNotes.Notes = 1, 2, 3, 4. DCFSNZ, Mnemonic,.Operands = f, d, a. DCFSNZ, Description.Description = Decrement f, Skip if Not 0. DCFSNZ, Cycles.Cycles = 1 (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word.MSb = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ, 16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status Affected.Status Affected = None. DCFSNZ, Notes.Notes = 1, 2. INCF, Mnemonic,.Operands = f, d, a. INCF, Description.Description = Increment f. INCF, Cycles.Cycles = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word.MSb = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb =",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nffff. INCF, Status Affected.Status Affected = C, DC, Z, OV, N. INCF, Notes.Notes = 1, 2, 3, 4. INCFSZ, Mnemonic,.Operands = f, d, a. INCFSZ, Description.Description = Increment f, Skip if 0. INCFSZ, Cycles.Cycles = 1 (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word.MSb = 11da. INCFSZ, 16-Bit Instruction Word. = ffff. INCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status Affected.Status Affected = None. INCFSZ, Notes.Notes = 4. INFSNZ, Mnemonic,.Operands = f, d, a. INFSNZ, Description.Description = Increment f, Skip if Not 0. INFSNZ, Cycles.Cycles = 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n16-Bit Instruction Word.MSb = 10da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status Affected.Status Affected = None. INFSNZ, Notes.Notes = 1, 2. IORWF, Mnemonic,.Operands = f, d, a. IORWF, Description.Description = Inclusive OR WREG with f. IORWF, Cycles.Cycles = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word.MSb = 00da. IORWF, 16-Bit Instruction Word. = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status Affected.Status Affected = Z, N. IORWF, Notes.Notes = 1, 2. MOVF, Mnemonic,.Operands = f, d, a. MOVF, Description.Description = Move f. MOVF, Cycles.Cycles =",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n1. MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word.MSb = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status Affected.Status Affected = Z, N. MOVF, Notes.Notes = 1. MOVFF, Mnemonic,.Operands = f s , f d. MOVFF, Description.Description = Move f s (source) to 1st word f d (destination)2nd word 2. MOVFF, Cycles.Cycles = . MOVFF, 16-Bit Instruction Word.MSb = 1100 1111. MOVFF, 16-Bit Instruction Word.MSb = ffff. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word.LSb = ffff. MOVFF, Status Affected.Status Affected = None. MOVFF, Notes.Notes = . MOVWF, Mnemonic,.Operands = f, a.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nMOVWF, Description.Description = Move WREG to f. MOVWF, Cycles.Cycles = 1. MOVWF, 16-Bit Instruction Word.MSb = 0110. MOVWF, 16-Bit Instruction Word.MSb = ffff 111a. MOVWF, 16-Bit Instruction Word. = ffff ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff ffff. MOVWF, Status Affected.Status Affected = None. MOVWF, Notes.Notes = . MULWF, Mnemonic,.Operands = f, a. MULWF, Description.Description = Multiply WREG with f. MULWF, Cycles.Cycles = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word.MSb = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status Affected.Status Affected = None.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nMULWF, Notes.Notes = 1, 2. NEGF, Mnemonic,.Operands = f, a. NEGF, Description.Description = Negate f. NEGF, Cycles.Cycles = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word.MSb = 110a. NEGF, 16-Bit Instruction Word. = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status Affected.Status Affected = C, DC, Z, OV, N. NEGF, Notes.Notes = . RLCF, Mnemonic,.Operands = f, d, a. RLCF, Description.Description = Rotate Left f through Carry. RLCF, Cycles.Cycles = 1. RLCF, 16-Bit Instruction Word.MSb = 0011. RLCF, 16-Bit Instruction Word.MSb = 01da. RLCF, 16-Bit Instruction Word. = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nAffected.Status Affected = C, Z, N. RLCF, Notes.Notes = 1, 2. RLNCF, Mnemonic,.Operands = f, d, a. RLNCF, Description.Description = Rotate Left f (No Carry). RLNCF, Cycles.Cycles = 1. RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word.MSb = 01da. RLNCF, 16-Bit Instruction Word. = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status Affected.Status Affected = Z, N. RLNCF, Notes.Notes = . RRCF, Mnemonic,.Operands = f, d, a. RRCF, Description.Description = Rotate Right f through Carry. RRCF, Cycles.Cycles = 1. RRCF, 16-Bit Instruction Word.MSb = 0011. RRCF, 16-Bit Instruction Word.MSb = 00da. RRCF, 16-Bit Instruction",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nWord. = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status Affected.Status Affected = C, Z, N. RRCF, Notes.Notes = . RRNCF, Mnemonic,.Operands = f, d, a. RRNCF, Description.Description = Rotate Right f (No Carry). RRNCF, Cycles.Cycles = 1. RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word.MSb = 00da. RRNCF, 16-Bit Instruction Word. = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff. RRNCF, Status Affected.Status Affected = Z, N. RRNCF, Notes.Notes = . SETF, Mnemonic,.Operands = f, a. SETF, Description.Description = Set f. SETF, Cycles.Cycles = 1. SETF, 16-Bit Instruction Word.MSb = 0110. SETF, 16-Bit Instruction Word.MSb = 100a. SETF,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n16-Bit Instruction Word. = ffff. SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status Affected.Status Affected = None. SETF, Notes.Notes = 1, 2. SUBFWB, Mnemonic,.Operands = f, d, a. SUBFWB, Description.Description = Subtract f from WREG with borrow. SUBFWB, Cycles.Cycles = 1. SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word.MSb = 01da. SUBFWB, 16-Bit Instruction Word. = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff. SUBFWB, Status Affected.Status Affected = C, DC, Z, OV, N. SUBFWB, Notes.Notes = . SUBWF, Mnemonic,.Operands = f, d, a. SUBWF, Description.Description = Subtract WREG from f. SUBWF, Cycles.Cycles = 1. SUBWF,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n16-Bit Instruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word.MSb = 11da. SUBWF, 16-Bit Instruction Word. = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status Affected.Status Affected = C, DC, Z, OV, N. SUBWF, Notes.Notes = 1, 2. SUBWFB, Mnemonic,.Operands = f, d, a. SUBWFB, Description.Description = Subtract WREG from f with borrow. SUBWFB, Cycles.Cycles = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction Word.MSb = 10da. SUBWFB, 16-Bit Instruction Word. = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status Affected.Status Affected = C, DC, Z, OV, N. SUBWFB, Notes.Notes = . SWAPF, Mnemonic,.Operands = f, d,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\na. SWAPF, Description.Description = Swap nibbles in f. SWAPF, Cycles.Cycles = 1. SWAPF, 16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word.MSb = 10da. SWAPF, 16-Bit Instruction Word. = ffff. SWAPF, 16-Bit Instruction Word.LSb = ffff. SWAPF, Status Affected.Status Affected = None. SWAPF, Notes.Notes = 4. TSTFSZ, Mnemonic,.Operands = . TSTFSZ, Description.Description = . TSTFSZ, Cycles.Cycles = 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word.MSb = 0110. TSTFSZ, 16-Bit Instruction Word.MSb = 011a. TSTFSZ, 16-Bit Instruction Word. = ffff. TSTFSZ, 16-Bit Instruction Word.LSb = . TSTFSZ, Status Affected.Status Affected = None. TSTFSZ, Notes.Notes = . , Mnemonic,.Operands = f, a. , Description.Description = Test f, skip",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nif 0. , Cycles.Cycles = 1. , 16-Bit Instruction Word.MSb = 0001. , 16-Bit Instruction Word.MSb = 10da. , 16-Bit Instruction Word. = . , 16-Bit Instruction Word.LSb = ffff. , Status Affected.Status Affected = . , Notes.Notes = 1, 2. XORWF, Mnemonic,.Operands = f, d, a. XORWF, Description.Description = Exclusive OR WREG with f. XORWF, Cycles.Cycles = . XORWF, 16-Bit Instruction Word.MSb = . XORWF, 16-Bit Instruction Word.MSb = . XORWF, 16-Bit Instruction Word. = ffff. XORWF, 16-Bit Instruction Word.LSb = ffff. XORWF, Status Affected.Status Affected = Z, N. XORWF, Notes.Notes = ",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, 'd' = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nBIT-ORIENTED OPERATIONS, Mnemonic,.Operands = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Description.Description = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Cycles.Cycles = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word.LSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Status Affected.Status Affected = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Notes.Notes = BIT-ORIENTED OPERATIONS. BCF, Mnemonic,.Operands = f, b, a. BCF, Description.Description = Bit Clear f. BCF, Cycles.Cycles = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word.MSb = bbba. BCF, 16-Bit Instruction Word. = ffff. BCF, 16-Bit Instruction Word.LSb",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= ffff. BCF, Status Affected.Status Affected = None. BCF, Notes.Notes = 1, 2. BSF, Mnemonic,.Operands = f, b, a. BSF, Description.Description = Bit Set f. BSF, Cycles.Cycles = 1. BSF, 16-Bit Instruction Word.MSb = 1000. BSF, 16-Bit Instruction Word.MSb = bbba. BSF, 16-Bit Instruction Word. = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status Affected.Status Affected = None. BSF, Notes.Notes = 1, 2. BTFSC, Mnemonic,.Operands = f, b, a. BTFSC, Description.Description = Bit Test f, Skip if Clear. BTFSC, Cycles.Cycles = 1 (2 or 3). BTFSC, 16-Bit Instruction Word.MSb = 1011. BTFSC, 16-Bit Instruction Word.MSb = bbba. BTFSC, 16-Bit Instruction Word. = ffff. BTFSC,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n16-Bit Instruction Word.LSb = ffff. BTFSC, Status Affected.Status Affected = None. BTFSC, Notes.Notes = 3, 4. BTFSS, Mnemonic,.Operands = f, b, a. BTFSS, Description.Description = Bit Test f, Skip if Set. BTFSS, Cycles.Cycles = 1 (2 or 3). BTFSS, 16-Bit Instruction Word.MSb = 1010. BTFSS, 16-Bit Instruction Word.MSb = bbba. BTFSS, 16-Bit Instruction Word. = ffff. BTFSS, 16-Bit Instruction Word.LSb = ffff. BTFSS, Status Affected.Status Affected = None. BTFSS, Notes.Notes = 3, 4. BTG, Mnemonic,.Operands = f, b, a. BTG, Description.Description = Bit Toggle f. BTG, Cycles.Cycles = 1. BTG, 16-Bit Instruction Word.MSb = 0111. BTG, 16-Bit Instruction Word.MSb = bbba.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nBTG, 16-Bit Instruction Word. = ffff. BTG, 16-Bit Instruction Word.LSb = ffff. BTG, Status Affected.Status Affected = None. BTG, Notes.Notes = 1, 2. CONTROL OPERATIONS, Mnemonic,.Operands = CONTROL OPERATIONS. CONTROL OPERATIONS, Description.Description = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles.Cycles = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected.Status Affected = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes.Notes = CONTROL OPERATIONS. BC, Mnemonic,.Operands = n. BC, Description.Description = Branch if Carry. BC, Cycles.Cycles = 1 (2). BC, 16-Bit Instruction Word.MSb = 1110. BC, 16-Bit Instruction Word.MSb = 0010. BC, 16-Bit Instruction Word. = nnnn. BC,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n16-Bit Instruction Word.LSb = nnnn. BC, Status Affected.Status Affected = None. BC, Notes.Notes = . BN, Mnemonic,.Operands = n. BN, Description.Description = Branch if Negative. BN, Cycles.Cycles = 1 (2). BN, 16-Bit Instruction Word.MSb = 1110. BN, 16-Bit Instruction Word.MSb = 0110. BN, 16-Bit Instruction Word. = nnnn. BN, 16-Bit Instruction Word.LSb = nnnn. BN, Status Affected.Status Affected = None. BN, Notes.Notes = . BNC, Mnemonic,.Operands = n. BNC, Description.Description = Branch if Not Carry. BNC, Cycles.Cycles = 1 (2). BNC, 16-Bit Instruction Word.MSb = 1110. BNC, 16-Bit Instruction Word.MSb = 0011. BNC, 16-Bit Instruction Word. = nnnn. BNC, 16-Bit Instruction Word.LSb = nnnn. BNC, Status Affected.Status Affected",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= None. BNC, Notes.Notes = . BNN, Mnemonic,.Operands = n. BNN, Description.Description = Branch if Not Negative. BNN, Cycles.Cycles = 1 (2). BNN, 16-Bit Instruction Word.MSb = 1110. BNN, 16-Bit Instruction Word.MSb = 0111. BNN, 16-Bit Instruction Word. = nnnn. BNN, 16-Bit Instruction Word.LSb = nnnn. BNN, Status Affected.Status Affected = None. BNN, Notes.Notes = . BNOV, Mnemonic,.Operands = n. BNOV, Description.Description = Branch if Not Overflow. BNOV, Cycles.Cycles = 1 (2). BNOV, 16-Bit Instruction Word.MSb = 1110. BNOV, 16-Bit Instruction Word.MSb = 0101. BNOV, 16-Bit Instruction Word. = nnnn. BNOV, 16-Bit Instruction Word.LSb = nnnn. BNOV, Status Affected.Status Affected = None. BNOV,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNotes.Notes = . BNZ, Mnemonic,.Operands = n. BNZ, Description.Description = Branch if Not Zero. BNZ, Cycles.Cycles = 1 (2). BNZ, 16-Bit Instruction Word.MSb = 1110. BNZ, 16-Bit Instruction Word.MSb = 0001. BNZ, 16-Bit Instruction Word. = nnnn. BNZ, 16-Bit Instruction Word.LSb = nnnn. BNZ, Status Affected.Status Affected = None. BNZ, Notes.Notes = . BOV, Mnemonic,.Operands = n. BOV, Description.Description = Branch if Overflow. BOV, Cycles.Cycles = 1 (2). BOV, 16-Bit Instruction Word.MSb = 1110. BOV, 16-Bit Instruction Word.MSb = 0100. BOV, 16-Bit Instruction Word. = nnnn. BOV, 16-Bit Instruction Word.LSb = nnnn. BOV, Status Affected.Status Affected = None. BOV, Notes.Notes = . BRA,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = n. BRA, Description.Description = Branch Unconditionally. BRA, Cycles.Cycles = 2. BRA, 16-Bit Instruction Word.MSb = 1101. BRA, 16-Bit Instruction Word.MSb = 0nnn. BRA, 16-Bit Instruction Word. = nnnn. BRA, 16-Bit Instruction Word.LSb = nnnn. BRA, Status Affected.Status Affected = None. BRA, Notes.Notes = . BZ, Mnemonic,.Operands = n. BZ, Description.Description = Branch if Zero. BZ, Cycles.Cycles = 1 (2). BZ, 16-Bit Instruction Word.MSb = 1110. BZ, 16-Bit Instruction Word.MSb = 0000. BZ, 16-Bit Instruction Word. = nnnn. BZ, 16-Bit Instruction Word.LSb = nnnn. BZ, Status Affected.Status Affected = None. BZ, Notes.Notes = . CALL, Mnemonic,.Operands = n, s. CALL, Description.Description = Call",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nsubroutine1st word. CALL, Cycles.Cycles = 2. CALL, 16-Bit Instruction Word.MSb = 1110. CALL, 16-Bit Instruction Word.MSb = 110s. CALL, 16-Bit Instruction Word. = kkkk. CALL, 16-Bit Instruction Word.LSb = kkkk. CALL, Status Affected.Status Affected = None. CALL, Notes.Notes = . CLRWDT, Mnemonic,.Operands = -. CLRWDT, Description.Description = 2nd word Clear Watchdog Timer. CLRWDT, Cycles.Cycles = 1. CLRWDT, 16-Bit Instruction Word.MSb = 1111 0000. CLRWDT, 16-Bit Instruction Word.MSb = kkkk 0000. CLRWDT, 16-Bit Instruction Word. = kkkk 0000. CLRWDT, 16-Bit Instruction Word.LSb = kkkk 0100. CLRWDT, Status Affected.Status Affected = TO, PD. CLRWDT, Notes.Notes = . DAW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = -. DAW, Description.Description = Decimal Adjust WREG. DAW, Cycles.Cycles = 1. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word.LSb = 0111. DAW, Status Affected.Status Affected = C. DAW, Notes.Notes = . GOTO, Mnemonic,.Operands = n. GOTO, Description.Description = Go to address 1st word 2nd word. GOTO, Cycles.Cycles = 2. GOTO, 16-Bit Instruction Word.MSb = 1110. GOTO, 16-Bit Instruction Word.MSb = 1111. GOTO, 16-Bit Instruction Word. = kkkk. GOTO, 16-Bit Instruction Word.LSb = kkkk. GOTO, Status Affected.Status Affected = None. GOTO, Notes.Notes = . NOP, Mnemonic,.Operands = -. NOP,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nDescription.Description = No Operation. NOP, Cycles.Cycles = 1. NOP, 16-Bit Instruction Word.MSb = 1111 0000. NOP, 16-Bit Instruction Word.MSb = kkkk 0000. NOP, 16-Bit Instruction Word. = kkkk 0000. NOP, 16-Bit Instruction Word.LSb = kkkk 0000. NOP, Status Affected.Status Affected = None. NOP, Notes.Notes = . NOP, Mnemonic,.Operands = -. NOP, Description.Description = No Operation. NOP, Cycles.Cycles = 1. NOP, 16-Bit Instruction Word.MSb = 1111. NOP, 16-Bit Instruction Word.MSb = xxxx. NOP, 16-Bit Instruction Word. = xxxx. NOP, 16-Bit Instruction Word.LSb = xxxx. NOP, Status Affected.Status Affected = None. NOP, Notes.Notes = 4. POP, Mnemonic,.Operands = -. POP, Description.Description = top of return stack. POP,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nCycles.Cycles = . POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word.LSb = 0110. POP, Status Affected.Status Affected = None. POP, Notes.Notes = . PUSH, Mnemonic,.Operands = -. PUSH, Description.Description = Pop (TOS) Push top of return stack (TOS) 1 1. PUSH, Cycles.Cycles = . PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word.LSb = 0101. PUSH, Status Affected.Status Affected = None. PUSH, Notes.Notes = . RCALL, Mnemonic,.Operands = n. RCALL, Description.Description = Relative Call. RCALL, Cycles.Cycles = 2. RCALL, 16-Bit Instruction Word.MSb = 1101. RCALL,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n16-Bit Instruction Word.MSb = 1nnn. RCALL, 16-Bit Instruction Word. = nnnn. RCALL, 16-Bit Instruction Word.LSb = nnnn. RCALL, Status Affected.Status Affected = None. RCALL, Notes.Notes = . RESET, Mnemonic,.Operands = . RESET, Description.Description = Software device Reset. RESET, Cycles.Cycles = 1. RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word. = 1111. RESET, 16-Bit Instruction Word.LSb = 1111. RESET, Status Affected.Status Affected = All. RESET, Notes.Notes = . RETFIE, Mnemonic,.Operands = s. RETFIE, Description.Description = Return from interrupt enable. RETFIE, Cycles.Cycles = 2. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= 0001. RETFIE, 16-Bit Instruction Word.LSb = 000s. RETFIE, Status Affected.Status Affected = GIE/GIEH,. RETFIE, Notes.Notes = . RETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected.Status Affected = PEIE/GIEL None. RETLW, Notes.Notes = . , Mnemonic,.Operands = . , Description.Description = Return. , Cycles.Cycles = . , 16-Bit Instruction Word.MSb = 0000. , 16-Bit Instruction Word.MSb = . , 16-Bit Instruction Word. = . , 16-Bit Instruction Word.LSb = .",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n, Status Affected.Status Affected = None. , Notes.Notes = . RETURN, Mnemonic,.Operands = s. RETURN, Description.Description = from Subroutine. RETURN, Cycles.Cycles = 2. RETURN, 16-Bit Instruction Word.MSb = . RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word. = 0001. RETURN, 16-Bit Instruction Word.LSb = 001s. RETURN, Status Affected.Status Affected = . RETURN, Notes.Notes = . SLEEP, Mnemonic,.Operands = -. SLEEP, Description.Description = Go into Standby mode. SLEEP, Cycles.Cycles = 1. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word.LSb = 0011. SLEEP, Status Affected.Status Affected = TO, PD. SLEEP, Notes.Notes = ",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, 'd' = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nLITERAL OPERATIONS,  = LITERAL OPERATIONS. LITERAL OPERATIONS, Description. = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected. = LITERAL OPERATIONS. LITERAL OPERATIONS, Notes. = LITERAL OPERATIONS. ADDLW,  = k. ADDLW, Description. = Add literal and WREG. ADDLW, Cycles. = 1. ADDLW, 16-Bit Instruction Word.MSb = 0000. ADDLW, 16-Bit Instruction Word.MSb = 1111. ADDLW, 16-Bit Instruction Word. = kkkk. ADDLW, 16-Bit Instruction Word.LSb = kkkk. ADDLW, Status Affected. = C, DC, Z, OV,. ADDLW, Notes. = N. ANDLW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= k. ANDLW, Description. = AND literal with WREG. ANDLW, Cycles. = 1. ANDLW, 16-Bit Instruction Word.MSb = 0000. ANDLW, 16-Bit Instruction Word.MSb = 1011. ANDLW, 16-Bit Instruction Word. = kkkk. ANDLW, 16-Bit Instruction Word.LSb = kkkk. ANDLW, Status Affected. = Z, N. ANDLW, Notes. = . IORLW,  = k. IORLW, Description. = Inclusive OR literal with WREG. IORLW, Cycles. = 1. IORLW, 16-Bit Instruction Word.MSb = 0000. IORLW, 16-Bit Instruction Word.MSb = 1001. IORLW, 16-Bit Instruction Word. = kkkk. IORLW, 16-Bit Instruction Word.LSb = kkkk. IORLW, Status Affected. = Z, N. IORLW, Notes. = . LFSR,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= f, k. LFSR, Description. = Move literal (12-bit) 2nd word to FSR(f) 1st word. LFSR, Cycles. = 2. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word. = 00ff. LFSR, 16-Bit Instruction Word.LSb = kkkk. LFSR, Status Affected. = None. LFSR, Notes. = . MOVLB,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= k. MOVLB, Description. = Move literal to BSR<3:0>. MOVLB, Cycles. = 1. MOVLB, 16-Bit Instruction Word.MSb = 1111 0000. MOVLB, 16-Bit Instruction Word.MSb = 0000 0001. MOVLB, 16-Bit Instruction Word. = kkkk 0000. MOVLB, 16-Bit Instruction Word.LSb = kkkk kkkk. MOVLB, Status Affected. = None. MOVLB, Notes. = . MOVLW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= k. MOVLW, Description. = Move literal to WREG. MOVLW, Cycles. = 1. MOVLW, 16-Bit Instruction Word.MSb = 0000. MOVLW, 16-Bit Instruction Word.MSb = 1110. MOVLW, 16-Bit Instruction Word. = kkkk. MOVLW, 16-Bit Instruction Word.LSb = kkkk. MOVLW, Status Affected. = None. MOVLW, Notes. = . MULLW,  = k. MULLW, Description. = Multiply literal with WREG. MULLW, Cycles. = 1. MULLW, 16-Bit Instruction Word.MSb = 0000. MULLW, 16-Bit Instruction Word.MSb = 1101. MULLW, 16-Bit Instruction Word. = kkkk. MULLW, 16-Bit Instruction Word.LSb = kkkk. MULLW, Status Affected. = None. MULLW, Notes. = . RETLW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= k. RETLW, Description. = Return with literal in WREG. RETLW, Cycles. = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected. = None. RETLW, Notes. = . SUBLW,  = k. SUBLW, Description. = Subtract WREG from literal. SUBLW, Cycles. = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000. SUBLW, 16-Bit Instruction Word.MSb = 1000. SUBLW, 16-Bit Instruction Word. = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected. = C, DC, Z, OV,. SUBLW, Notes. = N. XORLW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= k. XORLW, Description. = Exclusive OR literal with WREG. XORLW, Cycles. = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word.MSb = 1010. XORLW, 16-Bit Instruction Word. = kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected. = Z, N. XORLW, Notes. = . DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Description. = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Cycles. = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word. = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.LSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Status Affected. = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Notes. = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. TBLRD*,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLRD*. TBLRD*, Description. = Table Read. TBLRD*, Cycles. = 2. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected. = None. TBLRD*, Notes. = . TBLRD*+,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLRD*+. TBLRD*+, Description. = Table Read with post-increment. TBLRD*+, Cycles. = . TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected. = None. TBLRD*+, Notes. = . TBLRD*-,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLRD*-. TBLRD*-, Description. = Table Read with post-decrement. TBLRD*-, Cycles. = . TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected. = None. TBLRD*-, Notes. = . TBLRD+*,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLRD+*. TBLRD+*, Description. = Table Read with pre-increment. TBLRD+*, Cycles. = . TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected. = None. TBLRD+*, Notes. = . TBLWT*,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLWT*. TBLWT*, Description. = Table Write. TBLWT*, Cycles. = 2. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status Affected. = None. TBLWT*, Notes. = 5. TBLWT*+,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLWT*+. TBLWT*+, Description. = Table Write with post-increment. TBLWT*+, Cycles. = . TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected. = None. TBLWT*+, Notes. = 5. TBLWT*-,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLWT*-. TBLWT*-, Description. = Table Write with post-decrement. TBLWT*-, Cycles. = . TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected. = None. TBLWT*-, Notes. = 5. TBLWT+*,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLWT+*. TBLWT+*, Description. = Table Write with pre-increment. TBLWT+*, Cycles. = . TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word.LSb = 1111. TBLWT+*, Status Affected. = None. TBLWT+*, Notes. = 5",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, 'd' = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "ADD Literal to W\nSyntax:\nADDLW     k\nOperands:\n0 \uf0a3 k \uf0a3 255\nOperation:\n(W) + k \uf0ae W\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0000\n1111\nkkkk\nkkkk\nDescription:\nThe contents of W are added to the 8-bit literal 'k' and the result is placed in W.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral 'k'\nProcess\nData\nWrite to W\nExample:\nADDLW 15h\nBefore Instruction\nW\n=\n10h\nAfter Instruction\nW = 25h",
    "ADD Literal to W\nADDWF, 1 = ADD Wto f. ADDWF, 2 = ADD Wto f. ADDWF, 3 = ADD Wto f. ADDWF, 4 = ADD Wto f. ADDWF, 5 = . Syntax:, 1 = ADDWF. Syntax:, 2 = f {,d {,a}}. Syntax:, 3 = f {,d {,a}}. Syntax:, 4 = f {,d {,a}}. Syntax:, 5 = . Operands:, 1 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 2 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 3 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 4 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 5 = . Operation:, 1 = (W) + (f) \uf0ae dest. Operation:, 2 = (W) + (f) \uf0ae dest. Operation:, 3 = (W) + (f) \uf0ae dest.",
    "ADD Literal to W\nOperation:, 4 = (W) + (f) \uf0ae dest. Operation:, 5 = . Status Affected:, 1 = N, OV, C, DC, Z. Status Affected:, 2 = N, OV, C, DC, Z. Status Affected:, 3 = N, OV, C, DC, Z. Status Affected:, 4 = N, OV, C, DC, Z. Status Affected:, 5 = . Encoding:, 1 = 0010. Encoding:, 2 = 01da. Encoding:, 3 = ffff. Encoding:, 4 = ffff. Encoding:, 5 = . Description:, 1 = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).. Description:, 2 = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).. Description:, 3 = Add Wto register",
    "ADD Literal to W\n'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).. Description:, 4 = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).. Description:, 5 = . , 1 = If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and. , 2 = If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction",
    "ADD Literal to W\noperates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and. , 3 = If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and. , 4 = If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and. , 5 = . Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = . Cycles:, 1 = 1.",
    "ADD Literal to W\nCycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Cycles:, 5 = . Q Cycle Activity: Q1 Decode, 1 = . Q Cycle Activity: Q1 Decode, 2 = . Q Cycle Activity: Q1 Decode, 3 = . Q Cycle Activity: Q1 Decode, 4 = . Q Cycle Activity: Q1 Decode, 5 = . , 1 = Q2. , 2 = Q3. , 3 = . , 4 = Q4. , 5 = . , 1 = Read register 'f'. , 2 = Process Data. , 3 = . , 4 = Write to destination. , 5 = \nExample:\nADDWF\nREG, 0, 0\nBefore Instruction\nW\n=\n17h\nREG\n=\n0C2h\nAfter Instruction\nW\n=\n0D9h\nREG\n=\n0C2h\nNote:\nAll PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction format then becomes: {label} instruction argument(s).",
    "PIC18F2585/2680/4585/4680\nSyntax:, ADD Wand Carry bit to f = ADDWFC. Syntax:, ADD Wand Carry bit to f = f {,d {,a}}. Syntax:, ADD Wand Carry bit to f = . Operands:, ADD Wand Carry bit to f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1] a \uf0ce\uf020 [0,1]. Operands:, ADD Wand Carry bit to f = . Operands:, ADD Wand Carry bit to f = . Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \uf0ae dest. Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \uf0ae dest. Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \uf0ae dest. Status Affected:, ADD Wand Carry bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand Carry bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand Carry bit to f = N,OV, C, DC, Z. Encoding:, ADD Wand Carry bit to",
    "PIC18F2585/2680/4585/4680\nf = 0010. Encoding:, ADD Wand Carry bit to f = 00da. Encoding:, ADD Wand Carry bit to f = ffff. Description:, ADD Wand Carry bit to f = ffff Add W, the Carry flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'.. Description:, ADD Wand Carry bit to f = ffff Add W, the Carry flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'.. Description:, ADD Wand Carry bit to f = ffff Add W, the Carry flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'.. , ADD Wand Carry bit to f = If 'a' is ' 0 ', the Access",
    "PIC18F2585/2680/4585/4680\nBank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).. , ADD Wand Carry bit to f = If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).. , ADD Wand Carry bit to f = If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).. , ADD Wand Carry bit to f = If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. , ADD Wand Carry bit to f = If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and",
    "PIC18F2585/2680/4585/4680\nBit-Oriented Instructions in Indexed. , ADD Wand Carry bit to f = If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Words:, ADD Wand Carry bit to f = 1. Words:, ADD Wand Carry bit to f = 1. Words:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Q Cycle Activity: Q1, ADD Wand Carry bit to f = Q2. Q Cycle Activity: Q1, ADD Wand Carry bit to f = Q3. Q Cycle Activity: Q1, ADD Wand Carry bit to f = Q4. Decode, ADD Wand Carry bit to f = Read register 'f'. Decode, ADD Wand Carry bit to f = Process Data. Decode, ADD Wand Carry bit to f = Write to destination",
    "PIC18F2585/2680/4585/4680\nSyntax:, AND Literal with W = ANDLW. Syntax:, AND Literal with W = k. Syntax:, AND Literal with W = . Syntax:, AND Literal with W = . Operands:, AND Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND Literal with W = . Operands:, AND Literal with W = . Operation:, AND Literal with W = (W) .AND. k \uf0ae W. Operation:, AND Literal with W = (W) .AND. k \uf0ae W. Operation:, AND Literal with W = . Operation:, AND Literal with W = . Status Affected:, AND Literal with W = N, Z. Status Affected:, AND Literal with W = . Status Affected:, AND Literal with W = . Status Affected:, AND Literal with W = . Encoding:, AND Literal with W = 0000. Encoding:, AND Literal with W = 1011. Encoding:, AND Literal with W = kkkk. Encoding:, AND Literal with W = kkkk. Description:, AND Literal with W = The contents of Ware ANDed with",
    "PIC18F2585/2680/4585/4680\nthe 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Words:, AND Literal with W = 1. Words:, AND Literal with W = . Words:, AND Literal with W = . Words:, AND Literal with W = . Cycles:, AND Literal with W = 1. Cycles:, AND Literal with W = . Cycles:, AND Literal with W = . Cycles:, AND Literal with W = . Q Cycle Activity:, AND Literal with W = . Q Cycle Activity:, AND Literal with W = . Q Cycle Activity:, AND Literal with W = . Q Cycle Activity:, AND Literal with W = . Q1, AND Literal with W = Q2.",
    "PIC18F2585/2680/4585/4680\nQ1, AND Literal with W = Q3. Q1, AND Literal with W = . Q1, AND Literal with W = Q4. Decode, AND Literal with W = Read literal 'k'. Decode, AND Literal with W = Process Data. Decode, AND Literal with W = . Decode, AND Literal with W = Write to W. Example:, AND Literal with W = ANDLW. Example:, AND Literal with W = 05Fh. Example:, AND Literal with W = . Example:, AND Literal with W = . Before Instruction W =, AND Literal with W = A3h. Before Instruction W =, AND Literal with W = . Before Instruction W =, AND Literal with W = . Before Instruction W =, AND Literal with W = . After Instruction W =, AND Literal with W = 03h. After Instruction W =, AND Literal with W = . After Instruction W =, AND Literal with W = . After Instruction W =, AND Literal with W = ",
    "Example:\nADDWFC\nREG, 0, 1\nBefore Instruction\nCarry bit =\n1\nREG\n=\n02h\nW\n=\n4Dh\nAfter Instruction\nCarry bit\n=\n0\nREG\n=\n02h\nW\n=\n50h\nDescription:",
    "PIC18F2585/2680/4585/4680\nSyntax:, AND Wwith f = ANDWF. Syntax:, AND Wwith f = f {,d {,a}}. Syntax:, AND Wwith f = f {,d {,a}}. Syntax:, AND Wwith f = f {,d {,a}}. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith",
    "PIC18F2585/2680/4585/4680\nf = N, Z. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Encoding:, AND Wwith f = 0001. Encoding:, AND Wwith f = 01da. Encoding:, AND Wwith f = ffff. Encoding:, AND Wwith f = ffff",
    "Branch if Carry\nThe contents of W are AND'ed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nANDWF\nBefore Instruction\nW\n=\n17h\nREG\n=\nC2h\nAfter Instruction\nW\n=\n02h\nREG\n=\nC2h\nREG, 0, 0",
    "Branch if Carry\nSyntax:, 1 = Syntax:. Syntax:, 2 = BC n. Syntax:, 3 = BC n. Syntax:, 4 = BC n. Syntax:, 5 = BC n. Operands:, 1 = Operands:. Operands:, 2 = -128 \uf0a3 n \uf0a3 127. Operands:, 3 = -128 \uf0a3 n \uf0a3 127. Operands:, 4 = -128 \uf0a3 n \uf0a3 127. Operands:, 5 = -128 \uf0a3 n \uf0a3 127. Operation:, 1 = Operation:. Operation:, 2 = if Carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 3 = if Carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 4 = if Carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 5 = if Carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 1110. Encoding:, 3 =",
    "Branch if Carry\n0010 nnnn. Encoding:, 4 = nnnn. Encoding:, 5 = nnnn. Description: If the will The, 1 = Description: If the will The. Description: If the will The, 2 = Carry bit is ' 1 ', then the program branch. 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description: If the will The, 3 = Carry bit is ' 1 ', then the program branch. 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description: If the will The, 4 = Carry bit is ' 1 ', then the program branch. 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a",
    "Branch if Carry\ntwo-cycle instruction.. Description: If the will The, 5 = Carry bit is ' 1 ', then the program branch. 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1(2). Cycles:, 3 = 1(2). Cycles:, 4 = 1(2). Cycles:, 5 = 1(2). Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q Cycle Activity:, 5 = . If Jump:, 1 = If Jump:. If Jump:, 2 = If Jump:. If Jump:, 3 = . If Jump:, 4 = . If Jump:, 5 = .",
    "Branch if Carry\nQ1, 1 = . Q1, 2 = Q2. Q1, 3 = Q3. Q1, 4 = Q4. Q1, 5 = Q4. , 1 = Decode. , 2 = Read literal 'n'. , 3 = Process Data. , 4 = Write to PC. , 5 = Write to PC. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation. , 5 = No operation. If No Jump:, 1 = If No Jump:. If No Jump:, 2 = If No Jump:. If No Jump:, 3 = . If No Jump:, 4 = . If No Jump:, 5 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = Q4. , 5 = Q4. , 1 = Decode. , 2 = Read literal. , 3 = Process Data. , 4 = No operation. , 5 = No operation. Example:, 1 = . Example:, 2 = . Example:, 3 = BC. Example:, 4 = . Example:, 5 = . , 1 = Before Instruction. , 2 = HERE.",
    "Branch if Carry\n, 3 = . , 4 = . , 5 = . PC, 1 = . PC, 2 = =. PC, 3 = address. PC, 4 = (HERE). PC, 5 = (HERE). After Instruction, 1 = . After Instruction, 2 = =. After Instruction, 3 = . After Instruction, 4 = . After Instruction, 5 = . , 1 = . , 2 = . , 3 = . , 4 = (HERE. , 5 = (HERE. , 1 = PC. , 2 = . , 3 = . , 4 = . , 5 = . , 1 = . , 2 = . , 3 = . , 4 = +. , 5 = +. , 1 = . , 2 = . , 3 = . , 4 = 2). , 5 = 2). , 1 = . , 2 = =. , 3 = . , 4 = . , 5 = . , 1 = . , 2 = . , 3 = address. , 4 = . , 5 = . If, 1 = . If, 2 = . If, 3 = . If, 4 = . If, 5 = . , 1 = Carry. , 2 = . , 3 = . , 4 = . , 5",
    "Branch if Carry\n= . If, 1 = . If, 2 = . If, 3 = . If, 4 = . If, 5 = . , 1 = Carry PC. , 2 = . , 3 = . , 4 = . , 5 = . , 1 = . , 2 = =. , 3 = . , 4 = . , 5 = . , 1 = . , 2 = . , 3 = . , 4 = 12). , 5 = 12). , 1 = . , 2 = . , 3 = . , 4 = +. , 5 = +. , 1 = . , 2 = 1;. , 3 = . , 4 = . , 5 = . , 1 = . , 2 = =. , 3 = . , 4 = . , 5 = . , 1 = . , 2 = . , 3 = . , 4 = (HERE. , 5 = (HERE. , 1 = . , 2 = . , 3 = . , 4 = address. , 5 = address. , 1 = . , 2 = 0;. , 3 = . , 4 = . , 5 = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Bit Clear f = BCF f, b {,a}. Syntax:, Bit Clear f = BCF f, b {,a}. Syntax:, Bit Clear f = BCF f, b {,a}. Syntax:, Bit Clear f = BCF f, b {,a}. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = 0 \uf0ae f<b>. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f =",
    "PIC18F2585/2680/4585/4680\nNone. Encoding:, Bit Clear f = 1001. Encoding:, Bit Clear f = bbba. Encoding:, Bit Clear f = ffff. Encoding:, Bit Clear f = ffff. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the",
    "PIC18F2585/2680/4585/4680\nBSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Q Cycle Activity:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = . Q1, Bit Clear f = Q2. Q1, Bit Clear f =",
    "PIC18F2585/2680/4585/4680\nQ2. Q1, Bit Clear f = Q3. Q1, Bit Clear f = Q4. Decode, Bit Clear f = Read register 'f'. Decode, Bit Clear f = Read register 'f'. Decode, Bit Clear f = Process Data. Decode, Bit Clear f = Write register 'f'. Example: BCF Before Instruction FLAG_REG = C7h, Bit Clear f = Example: BCF Before Instruction FLAG_REG = C7h. Example: BCF Before Instruction FLAG_REG = C7h, Bit Clear f = FLAG_REG,. Example: BCF Before Instruction FLAG_REG = C7h, Bit Clear f = . Example: BCF Before Instruction FLAG_REG = C7h, Bit Clear f = 7, 0",
    "Branch if Negative\nSyntax:, 1 = Syntax:. Syntax:, 2 = BN n. Syntax:, 3 = BN n. Syntax:, 4 = BN n. Syntax:, 5 = BN n. Operands:, 1 = Operands:. Operands:, 2 = -128 \uf0a3 n \uf0a3 127. Operands:, 3 = -128 \uf0a3 n \uf0a3 127. Operands:, 4 = -128 \uf0a3 n \uf0a3 127. Operands:, 5 = -128 \uf0a3 n \uf0a3 127. Operation:, 1 = Operation:. Operation:, 2 = if Negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 3 = if Negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 4 = if Negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 5 = if Negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 1110. Encoding:, 3 =",
    "Branch if Negative\n0110. Encoding:, 4 = nnnn nnnn. Encoding:, 5 = nnnn nnnn. Description:, 1 = Description:. Description:, 2 = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 3 = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 4 = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle",
    "Branch if Negative\ninstruction.. Description:, 5 = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1(2). Cycles:, 3 = 1(2). Cycles:, 4 = 1(2). Cycles:, 5 = 1(2). Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q Cycle Activity:, 5 = . If Jump:, 1 = If Jump:. If Jump:, 2 = If Jump:. If Jump:, 3 = . If Jump:, 4 = . If Jump:, 5 = . , 1 =",
    "Branch if Negative\nQ1. , 2 = Q2. , 3 = Q3. , 4 = Q4. , 5 = Q4. , 1 = Decode. , 2 = Read literal 'n'. , 3 = Process Data. , 4 = Write to PC. , 5 = Write to PC. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation. , 5 = No operation. If No Jump:, 1 = If No Jump:. If No Jump:, 2 = If No Jump:. If No Jump:, 3 = . If No Jump:, 4 = . If No Jump:, 5 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 5 = . , 1 = Decode. , 2 = literal 'n'. , 3 = Process Data. , 4 = Read. , 5 = Read. , 1 = . , 2 = . , 3 = BN. , 4 = . , 5 = . , 1 = Example:. , 2 = . , 3 = . , 4 = HERE. , 5 = HERE. , 1 = Before PC. , 2 = . , 3",
    "Branch if Negative\n= address. , 4 = Instruction =. , 5 = Instruction =. , 1 = After Instruction If Negative. , 2 = . , 3 = 1; address. , 4 = = =. , 5 = = =. , 1 = Negative. , 2 = . , 3 = . , 4 = . , 5 = . , 1 = PC. , 2 = . , 3 = . , 4 = . , 5 = . , 1 = . , 2 = =. , 3 = address. , 4 = . , 5 = . , 1 = . , 2 = . , 3 = . , 4 = 2). , 5 = 2). , 1 = If. , 2 = . , 3 = . , 4 = . , 5 = . , 1 = . , 2 = =. , 3 = . , 4 = . , 5 = . , 1 = . , 2 = . , 3 = . , 4 = +. , 5 = +. , 1 = . , 2 = 0;. , 3 = . , 4 = . , 5 = . , 1 = PC. , 2 = . , 3 = . , 4 = . , 5 = . , 1 = . , 2 = . , 3 =",
    "Branch if Negative\n(HERE. , 4 = . , 5 = . , 1 = . , 2 = . , 3 = . , 4 = (Jump). , 5 = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Carry = if Carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if Carry bit is",
    "PIC18F2585/2680/4585/4680\n' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Encoding:, Branch if Not Carry = 1110. Encoding:, Branch if Not Carry = 0011. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will",
    "PIC18F2585/2680/4585/4680\nbe. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be. Words:, Branch if Not Carry = two-cycle instruction. 1. Words:, Branch if Not Carry = two-cycle instruction. 1. Words:, Branch if Not Carry = two-cycle instruction. 1. Words:, Branch if Not Carry = two-cycle instruction. 1. Words:,",
    "PIC18F2585/2680/4585/4680\nBranch if Not Carry = two-cycle instruction. 1. Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Q Cycle Activity: If, Branch if Not Carry = . Q Cycle Activity: If, Branch if Not Carry = . Q Cycle Activity: If, Branch if Not Carry = . Q Cycle Activity: If, Branch if Not Carry = . Q Cycle Activity: If, Branch if Not Carry = . Jump:, Branch if Not Carry = . Jump:, Branch if Not Carry = . Jump:, Branch if Not Carry = . Jump:, Branch if Not Carry = . Jump:, Branch if Not Carry = . Q1, Branch if Not Carry = Q2. Q1, Branch if Not Carry = . Q1, Branch if Not Carry = Q3. Q1, Branch if Not Carry = . Q1, Branch if Not Carry = Q4. If No Jump:, Branch if Not Carry",
    "PIC18F2585/2680/4585/4680\n= Read literal 'n' Process Data Write to PC No operation No operation No operation. If No Jump:, Branch if Not Carry = Read literal 'n' Process Data Write to PC No operation No operation No operation. If No Jump:, Branch if Not Carry = Read literal 'n' Process Data Write to PC No operation No operation No operation. If No Jump:, Branch if Not Carry = Read literal 'n' Process Data Write to PC No operation No operation No operation. If No Jump:, Branch if Not Carry = Read literal 'n' Process Data Write to PC No operation No operation No operation. Q1, Branch if Not Carry = . Q1, Branch if Not Carry = . Q1, Branch if Not Carry = . Q1, Branch if Not Carry = . Q1, Branch if Not Carry = . , Branch if Not Carry = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Carry = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Carry = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Carry",
    "PIC18F2585/2680/4585/4680\n= Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Carry = Q2 Q3 Q4 Read literal 'n' Process Data No operation. Example:, Branch if Not Carry = HERE. Example:, Branch if Not Carry = BNC address. Example:, Branch if Not Carry = Jump (HERE). Example:, Branch if Not Carry = . Example:, Branch if Not Carry = . Before Instruction PC, Branch if Not Carry = = =. Before Instruction PC, Branch if Not Carry = 0; address (Jump). Before Instruction PC, Branch if Not Carry = . Before Instruction PC, Branch if Not Carry = . Before Instruction PC, Branch if Not Carry = . After Instruction If Carry PC If Carry, Branch if Not Carry = = =. After Instruction If Carry PC If Carry, Branch if Not Carry = 1;. After Instruction If Carry PC If Carry, Branch if Not Carry = . After Instruction If Carry PC If Carry, Branch if Not Carry = 2). After Instruction If Carry PC If Carry, Branch if Not Carry = . PC, Branch if Not Carry = =. PC, Branch if Not Carry =",
    "PIC18F2585/2680/4585/4680\naddress. PC, Branch if Not Carry = (HERE. PC, Branch if Not Carry = +. PC, Branch if Not Carry = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, BNN = Syntax:. Syntax:, Branch if Not Negative = BNN n. Syntax:, Branch if Not Negative = BNN n. Syntax:, Branch if Not Negative = BNN n. Syntax:, Branch if Not Negative = BNN n. Operands:, BNN = Operands:. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operation:, BNN = Operation:. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, BNN = Status",
    "PIC18F2585/2680/4585/4680\nAffected:. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Encoding:, BNN = Encoding:. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 0111. Encoding:, Branch if Not Negative = nnnn. Description:, BNN = Description:. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address",
    "PIC18F2585/2680/4585/4680\nwill be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, BNN = Words:. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Cycles:, BNN = Cycles:. Cycles:, Branch if Not Negative =",
    "PIC18F2585/2680/4585/4680\n1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Q Cycle Activity:, BNN = Q Cycle Activity:. Q Cycle Activity:, Branch if Not Negative = . Q Cycle Activity:, Branch if Not Negative = . Q Cycle Activity:, Branch if Not Negative = . Q Cycle Activity:, Branch if Not Negative = . If Jump:, BNN = If Jump:. If Jump:, Branch if Not Negative = . If Jump:, Branch if Not Negative = . If Jump:, Branch if Not Negative = . If Jump:, Branch if Not Negative = . , BNN = Q1. , Branch if Not Negative = . , Branch if Not Negative = Q2. , Branch if Not Negative = Q3. , Branch if Not Negative = . , BNN = Decode. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Process Data. , Branch if Not Negative = Process Data. ,",
    "PIC18F2585/2680/4585/4680\nBNN = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. If No Jump:, BNN = If No Jump:. If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . , BNN = Q1. , Branch if Not Negative = Q2. , Branch if Not Negative = Q2. , Branch if Not Negative = Q3. , Branch if Not Negative = Q3. , BNN = Decode. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Process Data. , Branch if Not Negative = Process Data. Example:, BNN = Example:. Example:, Branch if Not Negative = HERE. Example:, Branch if Not Negative = HERE. Example:, Branch if Not Negative = BNN. Example:, Branch if Not Negative = Jump. Before",
    "PIC18F2585/2680/4585/4680\nInstruction, BNN = Before Instruction. Before Instruction, Branch if Not Negative = Before Instruction. Before Instruction, Branch if Not Negative = . Before Instruction, Branch if Not Negative = . Before Instruction, Branch if Not Negative = . , BNN = PC. , Branch if Not Negative = PC. , Branch if Not Negative = =. , Branch if Not Negative = address. , Branch if Not Negative = (HERE). , BNN = After Instruction If Negative = PC. , Branch if Not Negative = After Instruction If Negative = PC. , Branch if Not Negative = 0; = 1;. , Branch if Not Negative = address. , Branch if Not Negative = (Jump). , BNN = If Negative = PC =. , Branch if Not Negative = If Negative = PC =. , Branch if Not Negative = . , Branch if Not Negative = address. , Branch if Not Negative = (HERE",
    "PIC18F2585/2680/4585/4680\nSyntax:, Branch if Not Overflow = BNOV n. Syntax:, Branch if Not Overflow = BNOV n. Syntax:, Branch if Not Overflow = BNOV n. Syntax:, Branch if Not Overflow = BNOV n. Syntax:, Branch if Not Overflow = BNOV n. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Overflow = if Overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if Overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if Overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if Overflow bit is ' 0 ' (PC) +",
    "PIC18F2585/2680/4585/4680\n2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if Overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 0101. Encoding:, Branch if Not Overflow = nnnn. Encoding:, Branch if Not Overflow = nnnn. Encoding:, Branch if Not Overflow = nnnn. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Not Overflow = If the Overflow",
    "PIC18F2585/2680/4585/4680\nbit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is",
    "PIC18F2585/2680/4585/4680\nadded to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Words:, Branch if Not Overflow = two-cycle instruction. 1. Words:, Branch if Not Overflow = two-cycle instruction. 1. Words:, Branch if Not Overflow = two-cycle instruction. 1. Words:, Branch if Not Overflow = two-cycle instruction. 1. Words:, Branch if Not Overflow = two-cycle instruction. 1. Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Q Cycle Activity: If, Branch if Not Overflow = . Q Cycle Activity: If, Branch if Not Overflow = . Q Cycle Activity: If, Branch if Not Overflow = . Q Cycle Activity: If, Branch if Not Overflow = . Q Cycle",
    "PIC18F2585/2680/4585/4680\nActivity: If, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Q1, Branch if Not Overflow = Q2. Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = Q3. Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = Q4. Decode, Branch if Not Overflow = . Decode, Branch if Not Overflow = . Decode, Branch if Not Overflow = . Decode, Branch if Not Overflow = . Decode, Branch if Not Overflow = . , Branch if Not Overflow = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if Not Overflow = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if Not Overflow = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if",
    "PIC18F2585/2680/4585/4680\nNot Overflow = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if Not Overflow = Read literal 'n' Process Data Write to PC No operation No operation No operation. Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = . , Branch if Not Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Not Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation. Example: Before, Branch if Not Overflow = HERE Instruction =. Example: Before, Branch if Not Overflow = BNOV address. Example: Before,",
    "PIC18F2585/2680/4585/4680\nBranch if Not Overflow = Jump (HERE). Example: Before, Branch if Not Overflow = . Example: Before, Branch if Not Overflow = . PC After Instruction If Overflow, Branch if Not Overflow = = =. PC After Instruction If Overflow, Branch if Not Overflow = 0; address. PC After Instruction If Overflow, Branch if Not Overflow = (Jump). PC After Instruction If Overflow, Branch if Not Overflow = . PC After Instruction If Overflow, Branch if Not Overflow = . PC If Overflow, Branch if Not Overflow = =. PC If Overflow, Branch if Not Overflow = 1; address. PC If Overflow, Branch if Not Overflow = . PC If Overflow, Branch if Not Overflow = + 2). PC If Overflow, Branch if Not Overflow = . PC, Branch if Not Overflow = =. PC, Branch if Not Overflow = . PC, Branch if Not Overflow = (HERE. PC, Branch if Not Overflow = . PC, Branch if Not Overflow = ",
    "Branch if Not Zero\nSyntax:, 1 = Syntax:. Syntax:, 2 = BNZ n. Syntax:, 3 = BNZ n. Syntax:, 4 = BNZ n. Syntax:, 5 = BNZ n. Syntax:, 6 = BNZ n. Syntax:, 7 = BNZ n. Operands:, 1 = Operands:. Operands:, 2 = -128 \uf0a3 n \uf0a3 127. Operands:, 3 = -128 \uf0a3 n \uf0a3 127. Operands:, 4 = -128 \uf0a3 n \uf0a3 127. Operands:, 5 = -128 \uf0a3 n \uf0a3 127. Operands:, 6 = -128 \uf0a3 n \uf0a3 127. Operands:, 7 = -128 \uf0a3 n \uf0a3 127. Operation:, 1 = Operation:. Operation:, 2 = if Zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 3 = if Zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 4 = if Zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 5 = if Zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 6 = if Zero bit is ' 0 ' (PC) + 2 +",
    "Branch if Not Zero\n2n \uf0ae PC. Operation:, 7 = if Zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Status Affected:, 6 = None. Status Affected:, 7 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 1110. Encoding:, 3 = 0001. Encoding:, 4 = nnnn. Encoding:, 5 = nnnn. Encoding:, 6 = . Encoding:, 7 = . Description:, 1 = Description:. Description:, 2 = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 3 = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to",
    "Branch if Not Zero\nthe PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 4 = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 5 = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 6 = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then",
    "Branch if Not Zero\na two-cycle instruction.. Description:, 7 = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Words:, 6 = 1. Words:, 7 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1(2). Cycles:, 3 = 1(2). Cycles:, 4 = 1(2). Cycles:, 5 = 1(2). Cycles:, 6 = 1(2). Cycles:, 7 = 1(2). Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q Cycle Activity:, 5 = . Q Cycle Activity:, 6",
    "Branch if Not Zero\n= . Q Cycle Activity:, 7 = . If Jump:, 1 = If Jump:. If Jump:, 2 = If Jump:. If Jump:, 3 = . If Jump:, 4 = . If Jump:, 5 = . If Jump:, 6 = . If Jump:, 7 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = Q4. , 5 = Q4. , 6 = . , 7 = . , 1 = Decode. , 2 = Read literal 'n'. , 3 = Process Data. , 4 = Process Data. , 5 = . , 6 = . , 7 = . , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation. , 5 = . , 6 = . , 7 = . If No Jump:, 1 = . If No Jump:, 2 = . If No Jump:, 3 = . If No Jump:, 4 = . If No Jump:, 5 = . If No Jump:, 6 = . If No Jump:, 7 = . Q1, 1 = Decode. Q1, 2 = Read literal",
    "Branch if Not Zero\n'n'. Q1, 3 = Process Data. Q1, 4 = . Q1, 5 = . Q1, 6 = . Q1, 7 = . Example:, 1 = . Example:, 2 = HERE. Example:, 3 = BNZ. Example:, 4 = . Example:, 5 = . Example:, 6 = . Example:, 7 = . Before Instruction, 1 = . Before Instruction, 2 = . Before Instruction, 3 = . Before Instruction, 4 = . Before Instruction, 5 = . Before Instruction, 6 = . Before Instruction, 7 = . PC After, 1 = Instruction. PC After, 2 = =. PC After, 3 = address. PC After, 4 = . PC After, 5 = . PC After, 6 = . PC After, 7 = . If, 1 = Zero. If, 2 = =. If, 3 = . If, 4 = . If, 5 = . If, 6 = . If, 7 = . If, 1 = . If, 2 = =. If, 3 = . If, 4 = . If, 5 = . If, 6 = . If, 7 = . , 1 = . , 2 = . , 3 =",
    "Branch if Not Zero\n(HERE. , 4 = . , 5 = . , 6 = . , 7 = . PC, 1 = . PC, 2 = . PC, 3 = . PC, 4 = . PC, 5 = . PC, 6 = . PC, 7 = . , 1 = . , 2 = . , 3 = address. , 4 = . , 5 = . , 6 = . , 7 = . Zero, 1 = . Zero, 2 = . Zero, 3 = . Zero, 4 = . Zero, 5 = . Zero, 6 = . Zero, 7 = . , 1 = . , 2 = . , 3 = . , 4 = 2). , 5 = 2). , 6 = . , 7 = . , 1 = . , 2 = =. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 1 = . , 2 = . , 3 = . , 4 = +. , 5 = +. , 6 = . , 7 = . , 1 = PC. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 1 = . , 2 = 1;. , 3 = .",
    "Branch if Not Zero\n, 4 = . , 5 = . , 6 = . , 7 = . , 1 = . , 2 = =. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 1 = . , 2 = . , 3 = (Jump). , 4 = (Jump). , 5 = (Jump). , 6 = (Jump). , 7 = (Jump). , 1 = . , 2 = . , 3 = address. , 4 = address. , 5 = address. , 6 = . , 7 = ",
    "Unconditional Branch\nSyntax:\nBRA    n\nOperands:\n-1024 \uf0a3 n \uf0a3 1023\nOperation:\n(PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1101\n0nnn\nnnnn\nnnnn\nDescription:\nAdd the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE\nBRA Jump\nBefore Instruction\nPC\n=\naddress\n(HERE)\nAfter Instruction\nPC\n=\naddress\n(Jump)",
    "Bit Set f\nSyntax:\nBSF    f, b {,a}\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b \uf0a3 7\na \uf0ce\uf020 [0,1]\nOperation:\n1 \uf0ae f<b>\nStatus Affected:\nNone\nEncoding:\n1000\nbbba\nffff\nffff\nDescription:\nBit 'b' in register 'f' is set.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite\nregister 'f'\nExample:\nBSF\nFLAG_REG, 7, 1\nBefore Instruction\nFLAG_REG\n=\n0Ah\nAfter Instruction\nFLAG_REG\n=\n8Ah",
    "Bit Test File, Skip if Clear\nSyntax:\nBTFSC   f, b {,a}\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b \uf0a3 7\na \uf0ce\uf020 [0,1]\nOperation:\nskip if (f<b>) = 0\nStatus Affected:\nNone\nEncoding:\n1011\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nIf 'a' is '\n0\n' and the extended instruction set\nis enabled, this instruction operates in\nIndexed Literal Offset Addressing\nmode whenever f\n\uf0a3\uf020\n95 (5Fh).\nSee Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\nWords:\n1\nCycles:\n1(2)",
    "Bit Test File, Skip if Set\nSyntax:\nBTFSS  f, b {,a}\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b < 7\na \uf0ce\uf020 [0,1]\nOperation:\nskip if (f<b>) = 1\nStatus Affected:\nNone\nEncoding:\n1010\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nIf 'a' is ' 0 ' and the extended instruction in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh).\nset is enabled, this instruction operates See Section 25.2.3 'Byte-Oriented and\nBit-Oriented Instructions in Indexed Literal Offset Mode' for details.\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.\nCycles:\n1(2)\nNote:",
    "Bit Test File, Skip if Set\n3 cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:",
    "Bit Test File, Skip if Set\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. skip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 =",
    "Bit Test File, Skip if Set\nNo operation. No operation, Q4 = No operation. Example:, Q2 = HERE. Example:, Q3 = BTFSC FLAG,. Example:, Q4 = 1, 0. Before Instruction, Q2 = Before Instruction. Before Instruction, Q3 = Before Instruction. Before Instruction, Q4 = Before Instruction. PC, Q2 = =. PC, Q3 = address (HERE). PC, Q4 = . After Instruction, Q2 = After Instruction. After Instruction, Q3 = After Instruction. After Instruction, Q4 = After Instruction. If FLAG<1> PC, Q2 = = =. If FLAG<1> PC, Q3 = 0; address (TRUE). If FLAG<1> PC, Q4 = . If FLAG<1>, Q2 = =. If FLAG<1>, Q3 = 1; address. If FLAG<1>, Q4 = . PC, Q2 = =. PC, Q3 = (FALSE). PC, Q4 = ",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. If skip:, Q2 = . If skip:, Q3 = . If skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. If skip and followed by 2-word instruction:, Q2 = . If skip and followed by 2-word instruction:, Q3 = . If skip and followed by 2-word instruction:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. Example:, Q2 = HERE. Example:, Q3 = BTFSS",
    "Q Cycle Activity:\nFLAG,. Example:, Q4 = 1, 0. Before Instruction PC, Q2 = =. Before Instruction PC, Q3 = address (HERE). Before Instruction PC, Q4 = . After Instruction If FLAG<1> PC, Q2 = = =. After Instruction If FLAG<1> PC, Q3 = 0; address (FALSE). After Instruction If FLAG<1> PC, Q4 = . If FLAG<1> PC, Q2 = = =. If FLAG<1> PC, Q3 = 1; address (TRUE). If FLAG<1> PC, Q4 = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Bit Toggle f = BTG f, b {,a}. Syntax:, Bit Toggle f = BTG f, b {,a}. Syntax:, Bit Toggle f = BTG f, b {,a}. Syntax:, Bit Toggle f = BTG f, b {,a}. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255. , Bit Toggle f = 0 \uf0a3 b < 7. , Bit Toggle f = 0 \uf0a3 b < 7. , Bit Toggle f = 0 \uf0a3 b < 7. , Bit Toggle f = 0 \uf0a3 b < 7. , Bit Toggle f = a \uf0ce\uf020 [0,1]. , Bit Toggle f = a \uf0ce\uf020 [0,1]. , Bit Toggle f = a \uf0ce\uf020 [0,1]. , Bit Toggle f = a \uf0ce\uf020 [0,1]. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:,",
    "PIC18F2585/2680/4585/4680\nBit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Encoding:, Bit Toggle f = 0111. Encoding:, Bit Toggle f = bbba. Encoding:, Bit Toggle f = ffff. Encoding:, Bit Toggle f = ffff\nDescription:\nBit 'b' in data memory location 'f' is inverted.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).",
    "PIC18F2585/2680/4585/4680\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write register 'f'\nExample:\nBTG\nPORTC,\n4, 0\nBefore Instruction:\nPORTC\n=\n0111 0101\n[75h]\nAfter Instruction:\nPORTC\n=\n0110 0101 [65h]",
    "PIC18F2585/2680/4585/4680\nSyntax:, Branch if Overflow = BOV n. Syntax:, Branch if Overflow = BOV n. Syntax:, Branch if Overflow = BOV n. Syntax:, Branch if Overflow = BOV n. Syntax:, Branch if Overflow = BOV n. Syntax:, Branch if Overflow = BOV n. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow =",
    "PIC18F2585/2680/4585/4680\nif Overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Encoding:, Branch if Overflow = 1110. Encoding:, Branch if Overflow = 1110. Encoding:, Branch if Overflow = 0100. Encoding:, Branch if Overflow = nnnn. Encoding:, Branch if Overflow = nnnn. Encoding:, Branch if Overflow = nnnn. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to",
    "PIC18F2585/2680/4585/4680\nthe PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 +",
    "PIC18F2585/2680/4585/4680\n2n. This instruction is then a. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Words:, Branch if Overflow = 1. Words:, Branch if Overflow = 1. Words:, Branch if Overflow = 1. Words:, Branch if Overflow = 1. Words:, Branch if Overflow = 1. Words:, Branch if Overflow = 1. Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:,",
    "PIC18F2585/2680/4585/4680\nBranch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Q Cycle Activity:, Branch if Overflow = . Q Cycle Activity:, Branch if Overflow = . Q Cycle Activity:, Branch if Overflow = . Q Cycle Activity:, Branch if Overflow = . Q Cycle Activity:, Branch if Overflow = . Q Cycle Activity:, Branch if Overflow = . If Jump:, Branch if Overflow = . If Jump:, Branch if Overflow = . If Jump:, Branch if Overflow = . If Jump:, Branch if Overflow = . If Jump:, Branch if Overflow = . If Jump:, Branch if Overflow = . Q1, Branch if Overflow = Q2. Q1, Branch if Overflow = . Q1, Branch if Overflow = Q3. Q1, Branch if Overflow = . Q1, Branch if Overflow = . Q1, Branch if Overflow = Q4. Decode, Branch if Overflow",
    "PIC18F2585/2680/4585/4680\n= Read literal. Decode, Branch if Overflow = . Decode, Branch if Overflow = Process. Decode, Branch if Overflow = . Decode, Branch if Overflow = Write. Decode, Branch if Overflow = to PC. Q1, Branch if Overflow = . Q1, Branch if Overflow = . Q1, Branch if Overflow = . Q1, Branch if Overflow = . Q1, Branch if Overflow = . Q1, Branch if Overflow = . , Branch if Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation. , Branch if Overflow = Q2 Q3 Q4 Read literal 'n' Process Data No operation. Example:,",
    "PIC18F2585/2680/4585/4680\nBranch if Overflow = HERE. Example:, Branch if Overflow = address. Example:, Branch if Overflow = BOV. Example:, Branch if Overflow = Jump (HERE). Example:, Branch if Overflow = . Example:, Branch if Overflow = . Before Instruction PC After Instruction If Overflow, Branch if Overflow = = = =. Before Instruction PC After Instruction If Overflow, Branch if Overflow = 1; address. Before Instruction PC After Instruction If Overflow, Branch if Overflow = . Before Instruction PC After Instruction If Overflow, Branch if Overflow = (Jump). Before Instruction PC After Instruction If Overflow, Branch if Overflow = . Before Instruction PC After Instruction If Overflow, Branch if Overflow = . PC If Overflow, Branch if Overflow = =. PC If Overflow, Branch if Overflow = 0;. PC If Overflow, Branch if Overflow = . PC If Overflow, Branch if Overflow = . PC If Overflow, Branch if Overflow = + 2). PC If Overflow, Branch if Overflow = . PC, Branch if Overflow = =. PC, Branch",
    "PIC18F2585/2680/4585/4680\nif Overflow = . PC, Branch if Overflow = address. PC, Branch if Overflow = (HERE. PC, Branch if Overflow = . PC, Branch if Overflow = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Zero = if Zero bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero = if Zero bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero = if Zero bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero = if Zero bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC.",
    "PIC18F2585/2680/4585/4680\nOperation:, Branch if Zero = if Zero bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero = if Zero bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Encoding:, Branch if Zero = 1110. Encoding:, Branch if Zero = 1110. Encoding:, Branch if Zero = 0000. Encoding:, Branch if Zero = nnnn. Encoding:, Branch if Zero = nnnn. Encoding:, Branch if Zero = nnnn. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a.",
    "PIC18F2585/2680/4585/4680\nDescription:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number '2n'",
    "PIC18F2585/2680/4585/4680\nis added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Words:, Branch if Zero = two-cycle instruction. 1. Words:, Branch if Zero = two-cycle instruction. 1. Words:, Branch if Zero = two-cycle instruction. 1. Words:, Branch if Zero = two-cycle instruction. 1. Words:, Branch if Zero = two-cycle instruction. 1. Words:, Branch if Zero = two-cycle instruction. 1. Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2).",
    "PIC18F2585/2680/4585/4680\nCycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Q Cycle Activity: If, Branch if Zero = . Q Cycle Activity: If, Branch if Zero = . Q Cycle Activity: If, Branch if Zero = . Q Cycle Activity: If, Branch if Zero = . Q Cycle Activity: If, Branch if Zero = . Q Cycle Activity: If, Branch if Zero = . Jump:, Branch if Zero = . Jump:, Branch if Zero = . Jump:, Branch if Zero = . Jump:, Branch if Zero = . Jump:, Branch if Zero = . Jump:, Branch if Zero = . Q1, Branch if Zero = Q2. Q1, Branch if Zero = . Q1, Branch if Zero = . Q1, Branch if Zero = Q3. Q1, Branch if Zero = . Q1, Branch if Zero = Q4. , Branch if Zero = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if Zero = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if Zero = Read",
    "PIC18F2585/2680/4585/4680\nliteral 'n' Process Data Write to PC No operation No operation No operation. , Branch if Zero = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if Zero = Read literal 'n' Process Data Write to PC No operation No operation No operation. , Branch if Zero = Read literal 'n' Process Data Write to PC No operation No operation No operation. Q1, Branch if Zero = . Q1, Branch if Zero = . Q1, Branch if Zero = . Q1, Branch if Zero = . Q1, Branch if Zero = . Q1, Branch if Zero = . Decode, Branch if Zero = Q2 Q3 Q4 Read literal 'n' Process Data No operation. Decode, Branch if Zero = Q2 Q3 Q4 Read literal 'n' Process Data No operation. Decode, Branch if Zero = Q2 Q3 Q4 Read literal 'n' Process Data No operation. Decode, Branch if Zero = Q2 Q3 Q4 Read literal 'n' Process Data No operation. Decode, Branch if Zero = Q2 Q3 Q4 Read literal 'n' Process Data",
    "PIC18F2585/2680/4585/4680\nNo operation. Decode, Branch if Zero = Q2 Q3 Q4 Read literal 'n' Process Data No operation. Example:, Branch if Zero = HERE. Example:, Branch if Zero = address. Example:, Branch if Zero = BZ. Example:, Branch if Zero = Jump (HERE). Example:, Branch if Zero = . Example:, Branch if Zero = . Before Instruction PC After Instruction If Zero, Branch if Zero = = =. Before Instruction PC After Instruction If Zero, Branch if Zero = 1; address. Before Instruction PC After Instruction If Zero, Branch if Zero = . Before Instruction PC After Instruction If Zero, Branch if Zero = (Jump). Before Instruction PC After Instruction If Zero, Branch if Zero = . Before Instruction PC After Instruction If Zero, Branch if Zero = . PC If Zero PC, Branch if Zero = = = =. PC If Zero PC, Branch if Zero = 0;. PC If Zero PC, Branch if Zero = address. PC If Zero PC, Branch if Zero = (HERE. PC If Zero PC, Branch if Zero = + 2). PC If Zero PC, Branch if Zero = ",
    "Subroutine Call\nSyntax:\nCALL   k {,s}\nOperands:\n0 \uf0a3 k \uf0a3 1048575\ns \uf0ce\uf020 [0,1]\nOperation:\n(PC) + 4 \uf0ae TOS,\nk \uf0ae PC<20:1>,\nif s = 1\n(W) \uf0ae WS,\n(STATUS) \uf0ae STATUSS,\n(BSR)\n\uf0ae\nBSRS\nStatus Affected:\nNone\nEncoding:\n1st word (k<7:0>) 2nd word(k<19:8>)\n1110\n1111\n110s\nk 19 kkk\nk 7\nkkk\nkkkk\nkkkk 0\nkkkk 8\nDescription:\nSubroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, STATUS and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.\nWords:\n2\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'k'<7:0>,",
    "Subroutine Call\nPush PC to\nstack\nRead literal\n'k'<19:8>,\nWrite to PC\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation",
    "Example:\nHERE\nCALL   THERE, 1\nBefore Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. Before Instruction, 3 = Before Instruction. PC, 1 = =. PC, 2 = address. PC, 3 = (HERE). After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. After Instruction, 3 = After Instruction. PC, 1 = =. PC, 2 = address. PC, 3 = (THERE). TOS, 1 = =. TOS, 2 = address. TOS, 3 = (HERE + 4). WS, 1 = =. WS, 2 = W. WS, 3 = . BSRS, 1 = =. BSRS, 2 = BSR. BSRS, 3 = . STATUSS=, 1 = STATUSS=. STATUSS=, 2 = STATUS. STATUSS=, 3 = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Clear f = CLRF f {,a}. Syntax:, Clear f = CLRF f {,a}. Syntax:, Clear f = CLRF f {,a}. Syntax:, Clear f = CLRF f {,a}. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operation:, Clear f = 000h \uf0ae f 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f 1 \uf0ae Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Encoding:, Clear f = 0110. Encoding:, Clear f = 101a. Encoding:, Clear f = ffff. Encoding:, Clear f =",
    "PIC18F2585/2680/4585/4680\nffff. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f =",
    "PIC18F2585/2680/4585/4680\n1. Words:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q1, Clear f = Q2. Q1, Clear f = Q2. Q1, Clear f = Q3. Q1, Clear f = Q4. Decode, Clear f = Read register 'f'. Decode, Clear f = Read register 'f'. Decode, Clear f = Process Data. Decode, Clear f = Write register 'f'. Example:, Clear f = CLRF. Example:, Clear f = . Example:, Clear f = FLAG_REG,1. Example:, Clear f = . Before Instruction FLAG_REG, Clear f = =. Before Instruction FLAG_REG, Clear f = 5Ah. Before Instruction FLAG_REG, Clear f = . Before Instruction FLAG_REG, Clear f = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO, 1 \uf0ae PD. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO, 1 \uf0ae PD. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO, 1 \uf0ae PD. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO, 1 \uf0ae PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO,",
    "PIC18F2585/2680/4585/4680\nPD. Status Affected:, Clear Watchdog Timer = TO, PD. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0100. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post- scaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post- scaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post- scaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post- scaler of the WDT. Status bits TO and PD are set.. Words:, Clear Watchdog Timer = 1.",
    "PIC18F2585/2680/4585/4680\nWords:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = . Q1, Clear Watchdog Timer = Q4. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = . Decode, Clear Watchdog Timer = No operation\nExample:\nCLRWDT\nBefore Instruction\nWDT Counter\n=\n?\nAfter Instruction\nWDT Counter\n=\n00h\nWDT Postscaler\n=\n0\nTO",
    "PIC18F2585/2680/4585/4680\n=\n1\nPD\n=\n1",
    "PIC18F2585/2680/4585/4680\nSyntax:, Complement f = COMF. Syntax:, Complement f = f {,d {,a}}. Syntax:, Complement f = f {,d {,a}}. Syntax:, Complement f = f {,d {,a}}. Operands:, Complement f = 0 \uf0a3 f \uf0a3 255. Operands:, Complement f = 0 \uf0a3 f \uf0a3 255. Operands:, Complement f = 0 \uf0a3 f \uf0a3 255. Operands:, Complement f = 0 \uf0a3 f \uf0a3 255. , Complement f = d \uf0ce [0,1]. , Complement f = d \uf0ce [0,1]. , Complement f = d \uf0ce [0,1]. , Complement f = d \uf0ce [0,1]. , Complement f = a \uf0ce [0,1]. , Complement f = a \uf0ce [0,1]. , Complement f = a \uf0ce [0,1]. , Complement f = a \uf0ce [0,1]. Operation:, Complement f = \uf0ae dest (f). Operation:, Complement f = \uf0ae dest (f). Operation:, Complement f = \uf0ae dest (f). Operation:, Complement f = \uf0ae dest (f). Status Affected:, Complement",
    "PIC18F2585/2680/4585/4680\nf = N, Z. Status Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z. Encoding:, Complement f = 0001. Encoding:, Complement f = 11da. Encoding:, Complement f = ffff. Encoding:, Complement f = ffff\nDescription:\nThe contents of register 'f' are complemented. If 'd' is ' 1 ', the result is stored in W. If 'd' is ' 0 ', the result is stored back in register 'f' (default).\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:",
    "PIC18F2585/2680/4585/4680\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nCOMF\nREG, 0, 0\nBefore Instruction\nREG\n=\n13h\nAfter Instruction\nREG\n=\n13h\nW\n=\nECh",
    "PIC18F2585/2680/4585/4680\nSyntax:, CPFSEQ = Syntax:. Syntax:, Compare f with W, Skip if f = W = CPFSEQ f {,a}. Syntax:, Compare f with W, Skip if f = W = CPFSEQ f {,a}. Syntax:, Compare f with W, Skip if f = W = CPFSEQ f {,a}. Operands:, CPFSEQ = Operands:. Operands:, Compare f with W, Skip if f = W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f = W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f = W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, CPFSEQ = Operation:. Operation:, Compare f with W, Skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, Skip if f = W = (f) - (W), skip if",
    "PIC18F2585/2680/4585/4680\n(f) = (W) (unsigned comparison). Operation:, Compare f with W, Skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Status Affected:, CPFSEQ = Status Affected:. Status Affected:, Compare f with W, Skip if f = W = None. Status Affected:, Compare f with W, Skip if f = W = None. Status Affected:, Compare f with W, Skip if f = W = None. Encoding:, CPFSEQ = Encoding:. Encoding:, Compare f with W, Skip if f = W = 0110 001a. Encoding:, Compare f with W, Skip if f = W = ffff. Encoding:, Compare f with W, Skip if f = W = ffff. Description:, CPFSEQ = Description:. Description:, Compare f with W, Skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W, then the fetched instruction is discarded and a NOP",
    "PIC18F2585/2680/4585/4680\nis executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 0 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details. 1. Description:, Compare f with W, Skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 0 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing",
    "PIC18F2585/2680/4585/4680\nmode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details. 1. Description:, Compare f with W, Skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 0 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details. 1. Cycles:, CPFSEQ = Cycles:. Cycles:, Compare f with W, Skip if f = W = 1(2) Note: 3 cycles if skip and followed by",
    "PIC18F2585/2680/4585/4680\na 2-word instruction.. Cycles:, Compare f with W, Skip if f = W = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Compare f with W, Skip if f = W = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycle Activity: Q1, CPFSEQ = Cycle Activity: Q1. Cycle Activity: Q1, Compare f with W, Skip if f = W = Q2. Cycle Activity: Q1, Compare f with W, Skip if f = W = Q3. Cycle Activity: Q1, Compare f with W, Skip if f = W = Q4. Decode, CPFSEQ = Read register 'f'. Decode, Compare f with W, Skip if f = W = Read register 'f'. Decode, Compare f with W, Skip if f = W = Process Data. Decode, Compare f with W, Skip if f = W = No operation. If skip:, CPFSEQ = If skip:. If skip:, Compare f with W,",
    "PIC18F2585/2680/4585/4680\nSkip if f = W = If skip:. If skip:, Compare f with W, Skip if f = W = If skip:. If skip:, Compare f with W, Skip if f = W = If skip:. Q1, CPFSEQ = Q2. Q1, Compare f with W, Skip if f = W = Q2. Q1, Compare f with W, Skip if f = W = Q3. Q1, Compare f with W, Skip if f = W = Q4. No operation, CPFSEQ = No operation. No operation, Compare f with W, Skip if f = W = No operation. No operation, Compare f with W, Skip if f = W = No. No operation, Compare f with W, Skip if f = W = No operation. If skip and followed by 2-word instruction:, CPFSEQ = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, Skip if f = W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:,",
    "PIC18F2585/2680/4585/4680\nCompare f with W, Skip if f = W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, Skip if f = W = If skip and followed by 2-word instruction:. Q1, CPFSEQ = Q2. Q1, Compare f with W, Skip if f = W = Q2. Q1, Compare f with W, Skip if f = W = Q3. Q1, Compare f with W, Skip if f = W = Q4. No operation, CPFSEQ = No operation. No operation, Compare f with W, Skip if f = W = No operation. No operation, Compare f with W, Skip if f = W = No operation. No operation, Compare f with W, Skip if f = W = No operation. No operation, CPFSEQ = No operation. No operation, Compare f with W, Skip if f = W = No operation. No operation, Compare f with W, Skip if f = W = No operation. No operation, Compare f with W, Skip if f = W = No operation.",
    "PIC18F2585/2680/4585/4680\nExample:, CPFSEQ = HERE. Example:, Compare f with W, Skip if f = W = HERE. Example:, Compare f with W, Skip if f = W = CPFSEQ : :. Example:, Compare f with W, Skip if f = W = 0. Before Instruction, CPFSEQ = Before Instruction. Before Instruction, Compare f with W, Skip if f = W = NEQUAL EQUAL. Before Instruction, Compare f with W, Skip if f = W = NEQUAL EQUAL. Before Instruction, Compare f with W, Skip if f = W = \nIf skip:\nQ2",
    "PIC18F2585/2680/4585/4680\nSyntax:, Compare f with W, Skip if f > W = CPFSGT. Syntax:, Compare f with W, Skip if f > W = f {,a}. Syntax:, Compare f with W, Skip if f > W = . Syntax:, Compare f with W, Skip if f > W = . Operands:, Compare f with W, Skip if f > W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f > W = . Operands:, Compare f with W, Skip if f > W = . Operands:, Compare f with W, Skip if f > W = . Operation:, Compare f with W, Skip if f > W = (f) \uf02d\uf020\uf028 W), skip if (f) > (W) (unsigned. Operation:, Compare f with W, Skip if f > W = comparison). Operation:, Compare f with W, Skip if f > W = . Operation:, Compare f with W, Skip if f > W = . Status Affected:, Compare f with W, Skip if f > W = None. Status Affected:, Compare",
    "PIC18F2585/2680/4585/4680\nf with W, Skip if f > W = . Status Affected:, Compare f with W, Skip if f > W = . Status Affected:, Compare f with W, Skip if f > W = . Encoding:, Compare f with W, Skip if f > W = 0110. Encoding:, Compare f with W, Skip if f > W = 010a. Encoding:, Compare f with W, Skip if f > W = ffff. Encoding:, Compare f with W, Skip if f > W = ffff. Description:, Compare f with W, Skip if f > W = Compares the contents of data memory. Description:, Compare f with W, Skip if f > W = Compares the contents of data memory. Description:, Compare f with W, Skip if f > W = Compares the contents of data memory. Description:, Compare f with W, Skip if f > W = Compares the contents of data memory\nCompares the contents of data memory location 'f' to the contents of the W by performing an unsigned subtraction.",
    "PIC18F2585/2680/4585/4680\nIf the contents of 'f' are greater than the contents of WREG  then the fetched , instruction is discarded and a NOP is executed instead, making this a two-cycle instruction.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\nWords:\n1\nCycles:\n1(2)\nNote:",
    "Q Cycle Activity:\nQ1\nDecode\nQ1\nNo\n3 cycles if skip and followed by a 2-word instruction.\nQ3\nQ4\nRead register 'f'\nQ2\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation\nQ4\nNo operation\nQ4\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nHERE      CPFSGT REG, 0\nNGREATER  :\nGREATER   :\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nW\n=\n?\nAfter Instruction\nIf REG\n\uf03e\nW;\nPC\n=\nAddress (GREATER)\nIf REG\n\uf0a3\nW;\nPC\n=\nAddress (NGREATER)",
    "Compare f with W, Skip if f < W\nSyntax:\nCPFSLT    f {,a}\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce [0,1]\nOperation:\n(f) - \uf020\uf028 W),\nskip if (f) < (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n000a\nffff\nffff\nDescription:\nCompares the contents of data memory location 'f' to the contents of W by performing an unsigned subtraction.\nIf the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. skip:, Q2 = . skip:, Q3 = . skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:",
    "Q Cycle Activity:\nHERE    CPFSLT REG, 1\nNLESS   :\nLESS    :\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nW\n=\n?\nAfter Instruction\nIf REG\n<\nW;\nPC\n= Address (LESS) \uf0b3 W;\nIf REG\nPC\n= Address (NLESS)\nExample 1:",
    "PIC18F2585/2680/4585/4680\nSyntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1 ] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0>; If [W<7:4> >9] or [C = 1 ] then ( W<7:4>) + 6 \uf0ae W<7:4>; C = 1 ; else (W<7:4>) \uf0ae W<7:4>;. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1 ] then",
    "PIC18F2585/2680/4585/4680\n(W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0>; If [W<7:4> >9] or [C = 1 ] then ( W<7:4>) + 6 \uf0ae W<7:4>; C = 1 ; else (W<7:4>) \uf0ae W<7:4>;. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1 ] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0>; If [W<7:4> >9] or [C = 1 ] then ( W<7:4>) + 6 \uf0ae W<7:4>; C = 1 ; else (W<7:4>) \uf0ae W<7:4>;. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1 ] then (W<3:0>) + 6 \uf0ae",
    "PIC18F2585/2680/4585/4680\nW<3:0>; else ( W<3:0>) \uf0ae W<3:0>; If [W<7:4> >9] or [C = 1 ] then ( W<7:4>) + 6 \uf0ae W<7:4>; C = 1 ; else (W<7:4>) \uf0ae W<7:4>;. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0111. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in",
    "PIC18F2585/2680/4585/4680\nW, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Q Cycle Activity: Q1, Decimal Adjust WRegister = Q2. Q Cycle Activity: Q1, Decimal Adjust WRegister = Q3.",
    "PIC18F2585/2680/4585/4680\nQ Cycle Activity: Q1, Decimal Adjust WRegister = Q3. Q Cycle Activity: Q1, Decimal Adjust WRegister = Q4. Decode, Decimal Adjust WRegister = . Decode, Decimal Adjust WRegister = Read register W Process Data. Decode, Decimal Adjust WRegister = Read register W Process Data. Decode, Decimal Adjust WRegister = Write W\nDAW\nBefore Instruction\nW\n=\nA5h\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n=\n05h\nC\n=\n1\nDC\n=\n0\nExample 2:\nBefore Instruction\nW\n=\nCEh\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n=\n34h\nC\n=\n1\nDC\n=\n0",
    "PIC18F2585/2680/4585/4680\nSyntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255. , Decrement f = d \uf0ce [0,1]. , Decrement f = d \uf0ce [0,1]. , Decrement f = d \uf0ce [0,1]. , Decrement f = d \uf0ce [0,1]. , Decrement f = a \uf0ce [0,1]. , Decrement f = a \uf0ce [0,1]. , Decrement f = a \uf0ce [0,1]. , Decrement f = a \uf0ce [0,1]. Operation:, Decrement",
    "PIC18F2585/2680/4585/4680\nf = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Encoding:, Decrement f = 0000. Encoding:, Decrement f = 01da. Encoding:, Decrement f = ffff. Encoding:, Decrement f = ffff\nDescription:\nDecrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).",
    "PIC18F2585/2680/4585/4680\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\n1\n1\nWords:\nCycles:\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nDECF    CNT, 1, 0\nBefore Instruction\nCNT\n=\nZ\n=\nAfter Instruction\nCNT\nZ\n=\n=\n01h\n0\n00h\n1",
    "PIC18F2585/2680/4585/4680\nSyntax:, DECFSZ = Syntax:. Syntax:, Decrement f, Skip if 0 = DECFSZ f {,d {,a}}. Syntax:, Decrement f, Skip if 0 = DECFSZ f {,d {,a}}. Syntax:, Decrement f, Skip if 0 = DECFSZ f {,d {,a}}. Syntax:, Decrement f, Skip if 0 = DECFSZ f {,d {,a}}. Operands:, DECFSZ = Operands:. Operands:, Decrement f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:,",
    "PIC18F2585/2680/4585/4680\nDECFSZ = Operation:. Operation:, Decrement f, Skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, Decrement f, Skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, Decrement f, Skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, Decrement f, Skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Status Affected:, DECFSZ = Status Affected:. Status Affected:, Decrement f, Skip if 0 = None. Status Affected:, Decrement f, Skip if 0 = None. Status Affected:, Decrement f, Skip if 0 = None. Status Affected:, Decrement f, Skip if 0 = None. Encoding:, DECFSZ = Encoding:. Encoding:, Decrement f, Skip if 0 = 0010. Encoding:, Decrement f, Skip if 0 = 11da. Encoding:, Decrement f, Skip if 0 = ffff. Encoding:,",
    "PIC18F2585/2680/4585/4680\nDecrement f, Skip if 0 = ffff. Description:, DECFSZ = Description:. Description:, Decrement f, Skip if 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Decrement f, Skip if 0 = The contents of register 'f' are decremented.",
    "PIC18F2585/2680/4585/4680\nIf 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Decrement f, Skip if 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0",
    "PIC18F2585/2680/4585/4680\n', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Decrement f, Skip if 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If",
    "PIC18F2585/2680/4585/4680\n'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Words:, DECFSZ = Words:. Words:, Decrement f, Skip if 0 = 1. Words:, Decrement f, Skip if 0 = 1. Words:, Decrement f, Skip if 0 = 1. Words:, Decrement f, Skip if 0 = 1. Cycles:, DECFSZ = Cycles:. Cycles:, Decrement f, Skip if 0 = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Decrement f, Skip if 0 = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Cycles:, Decrement f, Skip if 0 = 1(2) Note: 3",
    "PIC18F2585/2680/4585/4680\ncycles if skip and followed by a 2-word instruction.. Cycles:, Decrement f, Skip if 0 = 1(2) Note: 3 cycles if skip and followed by a 2-word instruction.. Q1, DECFSZ = . Q1, Decrement f, Skip if 0 = Q2. Q1, Decrement f, Skip if 0 = Q2. Q1, Decrement f, Skip if 0 = Q3. Q1, Decrement f, Skip if 0 = Q4. Decode, DECFSZ = . Decode, Decrement f, Skip if 0 = Read register 'f'. Decode, Decrement f, Skip if 0 = Read register 'f'. Decode, Decrement f, Skip if 0 = Process Data. Decode, Decrement f, Skip if 0 = Write to destination. If skip:, DECFSZ = If skip:. If skip:, Decrement f, Skip if 0 = If skip:. If skip:, Decrement f, Skip if 0 = If skip:. If skip:, Decrement",
    "PIC18F2585/2680/4585/4680\nf, Skip if 0 = If skip:. If skip:, Decrement f, Skip if 0 = If skip:. Q1, DECFSZ = . Q1, Decrement f, Skip if 0 = Q2. Q1, Decrement f, Skip if 0 = Q2. Q1, Decrement f, Skip if 0 = Q3. Q1, Decrement f, Skip if 0 = Q4. No operation, DECFSZ = . No operation, Decrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. If skip and followed by 2-word instruction:, DECFSZ = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if 0 = If skip",
    "PIC18F2585/2680/4585/4680\nand followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if 0 = If skip and followed by 2-word instruction:. Q1, DECFSZ = Q2. Q1, Decrement f, Skip if 0 = . Q1, Decrement f, Skip if 0 = . Q1, Decrement f, Skip if 0 = Q3. Q1, Decrement f, Skip if 0 = Q4. operation, DECFSZ = No. operation, Decrement f, Skip if 0 = No operation. operation, Decrement f, Skip if 0 = No operation. operation, Decrement f, Skip if 0 = No operation. operation, Decrement f, Skip if 0 = No operation. No operation, DECFSZ = . No operation, Decrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. No operation,",
    "PIC18F2585/2680/4585/4680\nDecrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. Example:, DECFSZ = Example:. Example:, Decrement f, Skip if 0 = HERE. Example:, Decrement f, Skip if 0 = HERE. Example:, Decrement f, Skip if 0 = DECFSZ GOTO. Example:, Decrement f, Skip if 0 = CNT, 1, 1 LOOP. CONTINUE, DECFSZ = CONTINUE. CONTINUE, Decrement f, Skip if 0 = CONTINUE. CONTINUE, Decrement f, Skip if 0 = CONTINUE. CONTINUE, Decrement f, Skip if 0 = CONTINUE. CONTINUE, Decrement f, Skip if 0 = CONTINUE. Before Instruction, DECFSZ = =. Before Instruction, Decrement f, Skip if 0 = Before Instruction. Before Instruction, Decrement f, Skip if 0 = Address. Before Instruction, Decrement f, Skip if 0 = . Before Instruction, Decrement f, Skip if 0 = . PC After Instruction, DECFSZ = . PC After Instruction,",
    "PIC18F2585/2680/4585/4680\nDecrement f, Skip if 0 = . PC After Instruction, Decrement f, Skip if 0 = . PC After Instruction, Decrement f, Skip if 0 = (HERE). PC After Instruction, Decrement f, Skip if 0 = . , DECFSZ = CNT = If CNT = PC =. , Decrement f, Skip if 0 = CNT - 1 0;. , Decrement f, Skip if 0 = CNT - 1 0;. , Decrement f, Skip if 0 = (CONTINUE). , Decrement f, Skip if 0 = . If CNT, DECFSZ = \uf0b9 PC =. If CNT, Decrement f, Skip if 0 = Address 0; Address. If CNT, Decrement f, Skip if 0 = Address 0; Address. If CNT, Decrement f, Skip if 0 = (HERE + 2). If CNT, Decrement f, Skip if 0 = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, DCFSNZ = Syntax:. Syntax:, Decrement f, Skip if not 0 = DCFSNZ f {,d {,a}}. Syntax:, Decrement f, Skip if not 0 = DCFSNZ f {,d {,a}}. Syntax:, Decrement f, Skip if not 0 = DCFSNZ f {,d {,a}}. Syntax:, Decrement f, Skip if not 0 = DCFSNZ f {,d {,a}}. Operands:, DCFSNZ = Operands:. Operands:, Decrement f, Skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce",
    "PIC18F2585/2680/4585/4680\n[0,1]. Operation:, DCFSNZ = Operation:. Operation:, Decrement f, Skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, Skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, Skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, Skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Status Affected:, DCFSNZ = Status Affected:. Status Affected:, Decrement f, Skip if not 0 = None. Status Affected:, Decrement f, Skip if not 0 = None. Status Affected:, Decrement f, Skip if not 0 = None. Status Affected:, Decrement f, Skip if not 0 = None. Encoding:, DCFSNZ = Encoding:. Encoding:, Decrement f, Skip if not 0 = . Encoding:, Decrement f, Skip if not 0 = . Encoding:, Decrement f,",
    "PIC18F2585/2680/4585/4680\nSkip if not 0 = . Encoding:, Decrement f, Skip if not 0 = . Description:, DCFSNZ = Description:. Description:, Decrement f, Skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Decrement f, Skip if not 0 = The",
    "PIC18F2585/2680/4585/4680\ncontents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Decrement f, Skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register",
    "PIC18F2585/2680/4585/4680\n'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Decrement f, Skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If",
    "PIC18F2585/2680/4585/4680\n'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Words:, DCFSNZ = Words:. Words:, Decrement f, Skip if not 0 = 1. Words:, Decrement f, Skip if not 0 = 1. Words:, Decrement f, Skip if not 0 = 1. Words:, Decrement f, Skip if not 0 = 1. Cycles: 1(2) Note: 3 cycles if skip and followed by a 2-word instruction. Q Cycle Activity:, DCFSNZ = Cycles: 1(2) Note: 3 cycles if skip and followed by a 2-word instruction. Q Cycle Activity:. Cycles: 1(2) Note: 3 cycles if skip and followed by a",
    "PIC18F2585/2680/4585/4680\n2-word instruction. Q Cycle Activity:, Decrement f, Skip if not 0 = Cycles: 1(2) Note: 3 cycles if skip and followed by a 2-word instruction. Q Cycle Activity:. Cycles: 1(2) Note: 3 cycles if skip and followed by a 2-word instruction. Q Cycle Activity:, Decrement f, Skip if not 0 = Cycles: 1(2) Note: 3 cycles if skip and followed by a 2-word instruction. Q Cycle Activity:. Cycles: 1(2) Note: 3 cycles if skip and followed by a 2-word instruction. Q Cycle Activity:, Decrement f, Skip if not 0 = Cycles: 1(2) Note: 3 cycles if skip and followed by a 2-word instruction. Q Cycle Activity:. Cycles: 1(2) Note: 3 cycles if skip and followed by a 2-word instruction. Q Cycle Activity:, Decrement f, Skip if not 0 = Cycles: 1(2) Note: 3 cycles if skip and followed by a 2-word instruction. Q Cycle Activity:. , DCFSNZ = Q1. ,",
    "PIC18F2585/2680/4585/4680\nDecrement f, Skip if not 0 = Q2. , Decrement f, Skip if not 0 = . , Decrement f, Skip if not 0 = Q3. , Decrement f, Skip if not 0 = Q4. Decode, DCFSNZ = Decode. Decode, Decrement f, Skip if not 0 = Read register 'f'. Decode, Decrement f, Skip if not 0 = Read register 'f'. Decode, Decrement f, Skip if not 0 = Process Data. Decode, Decrement f, Skip if not 0 = Write to destination. Q1, DCFSNZ = . Q1, Decrement f, Skip if not 0 = Q2. Q1, Decrement f, Skip if not 0 = . Q1, Decrement f, Skip if not 0 = Q3. Q1, Decrement f, Skip if not 0 = Q4. No, DCFSNZ = . No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = . No,",
    "PIC18F2585/2680/4585/4680\nDecrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. operation, DCFSNZ = . operation, Decrement f, Skip if not 0 = operation. operation, Decrement f, Skip if not 0 = . operation, Decrement f, Skip if not 0 = operation. operation, Decrement f, Skip if not 0 = operation. If skip and followed by 2-word instruction:, DCFSNZ = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if not 0 = If skip and followed by 2-word instruction:.",
    "PIC18F2585/2680/4585/4680\nQ1, DCFSNZ = . Q1, Decrement f, Skip if not 0 = Q2. Q1, Decrement f, Skip if not 0 = . Q1, Decrement f, Skip if not 0 = Q3. Q1, Decrement f, Skip if not 0 = Q4. No operation, DCFSNZ = No. No operation, Decrement f, Skip if not 0 = operation. No operation, Decrement f, Skip if not 0 = . No operation, Decrement f, Skip if not 0 = No operation. No operation, Decrement f, Skip if not 0 = No operation. No, DCFSNZ = . No, Decrement f, Skip if not 0 = No operation. No, Decrement f, Skip if not 0 = . No, Decrement f, Skip if not 0 = No operation. No, Decrement f, Skip if not 0 = No operation. Example:, DCFSNZ = Example:. Example:, Decrement f, Skip if not 0 = HERE ZERO. Example:, Decrement f, Skip if not",
    "PIC18F2585/2680/4585/4680\n0 = :. Example:, Decrement f, Skip if not 0 = DCFSNZ TEMP,. Example:, Decrement f, Skip if not 0 = 1, 0. , DCFSNZ = . , Decrement f, Skip if not 0 = NZERO. , Decrement f, Skip if not 0 = :. , Decrement f, Skip if not 0 = . , Decrement f, Skip if not 0 = . Before Instruction, DCFSNZ = Before Instruction. Before Instruction, Decrement f, Skip if not 0 = Before Instruction. Before Instruction, Decrement f, Skip if not 0 = =. Before Instruction, Decrement f, Skip if not 0 = ?. Before Instruction, Decrement f, Skip if not 0 = . TEMP, DCFSNZ = TEMP. TEMP, Decrement f, Skip if not 0 = TEMP. TEMP, Decrement f, Skip if not 0 = . TEMP, Decrement f, Skip if not 0 = TEMP - 0;. TEMP, Decrement f, Skip if not 0 = . After",
    "PIC18F2585/2680/4585/4680\nInstruction TEMP, DCFSNZ = After Instruction TEMP. After Instruction TEMP, Decrement f, Skip if not 0 = After Instruction TEMP. After Instruction TEMP, Decrement f, Skip if not 0 = =. After Instruction TEMP, Decrement f, Skip if not 0 = 1,. After Instruction TEMP, Decrement f, Skip if not 0 = . If TEMP PC, DCFSNZ = If TEMP PC. If TEMP PC, Decrement f, Skip if not 0 = If TEMP PC. If TEMP PC, Decrement f, Skip if not 0 = = =. If TEMP PC, Decrement f, Skip if not 0 = Address. If TEMP PC, Decrement f, Skip if not 0 = (ZERO ). If TEMP PC, DCFSNZ = If TEMP PC. If TEMP PC, Decrement f, Skip if not 0 = If TEMP PC. If TEMP PC, Decrement f, Skip if not 0 = \uf0b9 =. If TEMP PC, Decrement f, Skip if not 0 = 0; Address.",
    "PIC18F2585/2680/4585/4680\nIf TEMP PC, Decrement f, Skip if not 0 = (NZERO)",
    "PIC18F2585/2680/4585/4680\nSyntax:, Unconditional Branch = GOTO k. Syntax:, Unconditional Branch = GOTO k. Syntax:, Unconditional Branch = GOTO k. Syntax:, Unconditional Branch = GOTO k. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional",
    "PIC18F2585/2680/4585/4680\nBranch = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = 1111 k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = kkkk 0 kkkk 8. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere",
    "PIC18F2585/2680/4585/4680\nwithin entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q1, Unconditional Branch =",
    "PIC18F2585/2680/4585/4680\nQ2. Q1, Unconditional Branch = Q3. Q1, Unconditional Branch = Q3. Q1, Unconditional Branch = Q4. Decode, Unconditional Branch = Read literal 'k'<7:0>,. Decode, Unconditional Branch = No operation. Decode, Unconditional Branch = No operation. Decode, Unconditional Branch = Read literal 'k'<19:8>, Write to PC. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. Example:, Unconditional Branch = GOTO THERE. Example:, Unconditional Branch = GOTO THERE. Example:, Unconditional Branch = . Example:, Unconditional Branch = . After Instruction PC =, Unconditional Branch = Address (THERE). After Instruction PC =, Unconditional Branch = Address (THERE). After Instruction PC =, Unconditional Branch = . After Instruction PC =, Unconditional Branch = \nWords:\nCycles:",
    "PIC18F2585/2680/4585/4680\nSyntax:, Increment f = INCF. Syntax:, Increment f = f {,d {,a}}. Syntax:, Increment f = . Syntax:, Increment f = . Operands:, Increment f = 0 \uf0a3 f \uf0a3 255. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255. Operands:, Increment f = . Operands:, Increment f = . , Increment f = d \uf0ce [0,1]. , Increment f = d \uf0ce [0,1]. , Increment f = . , Increment f = . , Increment f = a \uf0ce [0,1]. , Increment f = a \uf0ce [0,1]. , Increment f = . , Increment f = . Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = . Operation:, Increment f = . Status Affected:, Increment f = C, DC, N, OV,",
    "PIC18F2585/2680/4585/4680\nZ. Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = . Status Affected:, Increment f = . Encoding:, Increment f = 0010. Encoding:, Increment f = 10da. Encoding:, Increment f = ffff. Encoding:, Increment f = ffff\nDescription:\nThe contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\n1\n1\nQ Cycle Activity:",
    "PIC18F2585/2680/4585/4680\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nINCF\nBefore Instruction\nCNT\n=\nFFh\nZ\n=\n0\nC\n=\n?\nDC\n=\n?\nAfter Instruction\nCNT\n=\n00h\nZ\n=\n1\nC\n=\n1\nDC\n=\n1\nCNT, 1, 0",
    "PIC18F2585/2680/4585/4680\nSyntax:, INCFSZ = Syntax:. Syntax:, Increment f, Skip if 0 = INCFSZ f {,d {,a}}. Syntax:, Increment f, Skip if 0 = INCFSZ f {,d {,a}}. Syntax:, Increment f, Skip if 0 = INCFSZ f {,d {,a}}. Syntax:, Increment f, Skip if 0 = INCFSZ f {,d {,a}}. Syntax:, Increment f, Skip if 0 = INCFSZ f {,d {,a}}. Operands:, INCFSZ = Operands:. Operands:, Increment f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment",
    "PIC18F2585/2680/4585/4680\nf, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, INCFSZ = Operation:. Operation:, Increment f, Skip if 0 = (f) + 1 \uf0ae dest, skip if result = 0. Operation:, Increment f, Skip if 0 = (f) + 1 \uf0ae dest, skip if result = 0. Operation:, Increment f, Skip if 0 = (f) + 1 \uf0ae dest, skip if result = 0. Operation:, Increment f, Skip if 0 = (f) + 1 \uf0ae dest, skip if result = 0. Operation:, Increment f, Skip if 0 = (f) + 1 \uf0ae dest, skip if result = 0. Status Affected:, INCFSZ = Status Affected:. Status Affected:, Increment f, Skip if 0 = None. Status Affected:, Increment f, Skip if 0 = None. Status Affected:, Increment f,",
    "PIC18F2585/2680/4585/4680\nSkip if 0 = None. Status Affected:, Increment f, Skip if 0 = None. Status Affected:, Increment f, Skip if 0 = None. Encoding:, INCFSZ = Encoding:. Encoding:, Increment f, Skip if 0 = 0011. Encoding:, Increment f, Skip if 0 = 0011. Encoding:, Increment f, Skip if 0 = 11da. Encoding:, Increment f, Skip if 0 = ffff. Encoding:, Increment f, Skip if 0 = ffff. Description:, INCFSZ = Description:. Description:, Increment f, Skip if 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is",
    "PIC18F2585/2680/4585/4680\nselected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Increment f, Skip if 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in",
    "PIC18F2585/2680/4585/4680\nIndexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Increment f, Skip if 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Increment",
    "PIC18F2585/2680/4585/4680\nf, Skip if 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Increment f, Skip if 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is",
    "PIC18F2585/2680/4585/4680\nplaced back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Words:, INCFSZ = Words:. Words:, Increment f, Skip if 0 = 1. Words:, Increment f, Skip if 0 = 1. Words:, Increment f, Skip if 0 = 1. Words:, Increment f, Skip if 0 = 1. Words:, Increment f, Skip if 0 = 1. Cycles:, INCFSZ = Cycles:. Cycles:, Increment f,",
    "PIC18F2585/2680/4585/4680\nSkip if 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Increment f, Skip if 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Increment f, Skip if 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Increment f, Skip if 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Increment f, Skip if 0 = 1(2) Note: 3 cycles if skip and followed. Cycle Activity:, INCFSZ = Cycle Activity:. Cycle Activity:, Increment f, Skip if 0 = Cycle Activity:. Cycle Activity:, Increment f, Skip if 0 = Cycle Activity:. Cycle Activity:, Increment f, Skip if 0 = Cycle Activity:. Cycle Activity:, Increment f, Skip if 0 = Cycle Activity:. Cycle Activity:, Increment f, Skip if 0 = Cycle Activity:. , INCFSZ = Q2. , Increment f, Skip if 0 = Q2. , Increment f, Skip",
    "PIC18F2585/2680/4585/4680\nif 0 = . , Increment f, Skip if 0 = . , Increment f, Skip if 0 = . , Increment f, Skip if 0 = . Q1, INCFSZ = . Q1, Increment f, Skip if 0 = . Q1, Increment f, Skip if 0 = Q3. Q1, Increment f, Skip if 0 = Q3. Q1, Increment f, Skip if 0 = Q3. Q1, Increment f, Skip if 0 = Q4. Decode Read register 'f' Process Data Write to destination If skip:, INCFSZ = Decode Read register 'f' Process Data Write to destination If skip:. Decode Read register 'f' Process Data Write to destination If skip:, Increment f, Skip if 0 = Decode Read register 'f' Process Data Write to destination If skip:. Decode Read register 'f' Process Data Write to destination If skip:, Increment f, Skip if 0 = Decode Read register 'f' Process Data Write to destination If skip:. Decode Read register",
    "PIC18F2585/2680/4585/4680\n'f' Process Data Write to destination If skip:, Increment f, Skip if 0 = Decode Read register 'f' Process Data Write to destination If skip:. Decode Read register 'f' Process Data Write to destination If skip:, Increment f, Skip if 0 = Decode Read register 'f' Process Data Write to destination If skip:. Decode Read register 'f' Process Data Write to destination If skip:, Increment f, Skip if 0 = Decode Read register 'f' Process Data Write to destination If skip:. Q1, INCFSZ = Q2. Q1, Increment f, Skip if 0 = Q2. Q1, Increment f, Skip if 0 = Q3. Q1, Increment f, Skip if 0 = Q3. Q1, Increment f, Skip if 0 = Q3. Q1, Increment f, Skip if 0 = Q4. No, INCFSZ = No. No, Increment f, Skip if 0 = No. No, Increment f, Skip if 0 = No. No,",
    "PIC18F2585/2680/4585/4680\nIncrement f, Skip if 0 = No. No, Increment f, Skip if 0 = No. No, Increment f, Skip if 0 = No. operation operation operation operation If skip and followed by 2-word instruction:, INCFSZ = operation operation operation operation If skip and followed by 2-word instruction:. operation operation operation operation If skip and followed by 2-word instruction:, Increment f, Skip if 0 = operation operation operation operation If skip and followed by 2-word instruction:. operation operation operation operation If skip and followed by 2-word instruction:, Increment f, Skip if 0 = operation operation operation operation If skip and followed by 2-word instruction:. operation operation operation operation If skip and followed by 2-word instruction:, Increment f, Skip if 0 = operation operation operation operation If skip and followed by 2-word instruction:. operation operation operation operation If skip and followed by 2-word instruction:, Increment f, Skip if 0 = operation operation operation operation If skip and followed by 2-word instruction:. operation operation operation operation If skip and followed by 2-word instruction:,",
    "PIC18F2585/2680/4585/4680\nIncrement f, Skip if 0 = operation operation operation operation If skip and followed by 2-word instruction:. Q1, INCFSZ = Q2. Q1, Increment f, Skip if 0 = Q2. Q1, Increment f, Skip if 0 = Q3. Q1, Increment f, Skip if 0 = Q3. Q1, Increment f, Skip if 0 = Q3. Q1, Increment f, Skip if 0 = Q4. No operation, INCFSZ = No operation. No operation, Increment f, Skip if 0 = No operation. No operation, Increment f, Skip if 0 = No operation. No operation, Increment f, Skip if 0 = No operation. No operation, Increment f, Skip if 0 = No operation. No operation, Increment f, Skip if 0 = No operation. No operation, INCFSZ = No operation. No operation, Increment f, Skip if 0 = No operation. No operation, Increment f, Skip if 0 = No operation. No operation, Increment f,",
    "PIC18F2585/2680/4585/4680\nSkip if 0 = No operation. No operation, Increment f, Skip if 0 = No operation. No operation, Increment f, Skip if 0 = No operation. Example:, INCFSZ = Example:. Example:, Increment f, Skip if 0 = HERE NZERO : ZERO :. Example:, Increment f, Skip if 0 = HERE NZERO : ZERO :. Example:, Increment f, Skip if 0 = INCFSZ. Example:, Increment f, Skip if 0 = CNT, 1, 0. Example:, Increment f, Skip if 0 = CNT, 1, 0. Before Instruction, INCFSZ = Before Instruction. Before Instruction, Increment f, Skip if 0 = . Before Instruction, Increment f, Skip if 0 = . Before Instruction, Increment f, Skip if 0 = . Before Instruction, Increment f, Skip if 0 = . Before Instruction, Increment f, Skip if 0 = . PC = Address, INCFSZ = PC = Address. PC = Address, Increment f, Skip if 0 = PC =",
    "PIC18F2585/2680/4585/4680\nAddress. PC = Address, Increment f, Skip if 0 = PC = Address. PC = Address, Increment f, Skip if 0 = PC = Address. PC = Address, Increment f, Skip if 0 = PC = Address. PC = Address, Increment f, Skip if 0 = PC = Address. After Instruction, INCFSZ = . After Instruction, Increment f, Skip if 0 = . After Instruction, Increment f, Skip if 0 = (HERE). After Instruction, Increment f, Skip if 0 = (HERE). After Instruction, Increment f, Skip if 0 = (HERE). After Instruction, Increment f, Skip if 0 = . CNT If CNT, INCFSZ = = =. CNT If CNT, Increment f, Skip if 0 = = =. CNT If CNT, Increment f, Skip if 0 = CNT + 1. CNT If CNT, Increment f, Skip if 0 = CNT + 1. CNT If CNT, Increment f, Skip if 0 = CNT +",
    "PIC18F2585/2680/4585/4680\n1. CNT If CNT, Increment f, Skip if 0 = . PC If CNT PC, INCFSZ = = \uf0b9 0; =. PC If CNT PC, Increment f, Skip if 0 = = \uf0b9 0; =. PC If CNT PC, Increment f, Skip if 0 = Address (ZERO) Address (NZERO). PC If CNT PC, Increment f, Skip if 0 = Address (ZERO) Address (NZERO). PC If CNT PC, Increment f, Skip if 0 = Address (ZERO) Address (NZERO). PC If CNT PC, Increment f, Skip if 0 = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Increment f, Skip if Not 0 = INFSNZ. Syntax:, Increment f, Skip if Not 0 = f {,d {,a}}. Syntax:, Increment f, Skip if Not 0 = . Syntax:, Increment f, Skip if Not 0 = . Operands:, Increment f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Increment f, Skip if Not 0 = (f) + 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Increment f, Skip if Not 0 = (f) + 1 \uf0ae dest, skip if result \uf0b9 0.",
    "PIC18F2585/2680/4585/4680\nOperation:, Increment f, Skip if Not 0 = (f) + 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Increment f, Skip if Not 0 = (f) + 1 \uf0ae dest, skip if result \uf0b9 0. Status Affected:, Increment f, Skip if Not 0 = None. Status Affected:, Increment f, Skip if Not 0 = None. Status Affected:, Increment f, Skip if Not 0 = None. Status Affected:, Increment f, Skip if Not 0 = None. Encoding:, Increment f, Skip if Not 0 = 0100. Encoding:, Increment f, Skip if Not 0 = 10da. Encoding:, Increment f, Skip if Not 0 = ffff. Encoding:, Increment f, Skip if Not 0 = ffff. Description:, Increment f, Skip if Not 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f'",
    "PIC18F2585/2680/4585/4680\n(default). If the result is not ' 0 ', the next instruction which is already fetched is. Description:, Increment f, Skip if Not 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is. Description:, Increment f, Skip if Not 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is. Description:, Increment f, Skip if Not 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is",
    "PIC18F2585/2680/4585/4680\nplaced back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is. , Increment f, Skip if Not 0 = instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the. , Increment f, Skip if Not 0 = instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the. , Increment f, Skip if Not 0 = instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the. , Increment f, Skip if Not 0 = instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the. , Increment f, Skip if Not 0 = GPR bank (default). If 'a' is ' 0 ' and the",
    "PIC18F2585/2680/4585/4680\nextended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See. , Increment f, Skip if Not 0 = GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See. , Increment f, Skip if Not 0 = GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See. , Increment f, Skip if Not 0 = GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See. Words:, Increment f, Skip if Not 0 = 1. Words:, Increment f, Skip if Not 0 = 1. Words:, Increment f, Skip if Not 0 = 1. Words:, Increment f, Skip",
    "PIC18F2585/2680/4585/4680\nif Not 0 = 1. Cycles:, Increment f, Skip if Not 0 = 1(2). Cycles:, Increment f, Skip if Not 0 = 1(2). Cycles:, Increment f, Skip if Not 0 = 1(2). Cycles:, Increment f, Skip if Not 0 = 1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "PIC18F2585/2680/4585/4680\nskip:, Q2.Read register 'f' = skip:. skip:, Q3.Process Data = skip:. skip:, Q4.Write to destination = skip:. Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.Write to destination = Q4. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination = No operation. skip and followed by 2-word instruction:, Q2.Read register 'f' = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3.Process Data = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4.Write to destination = skip and followed by 2-word instruction:. Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.Write to destination = Q4.",
    "PIC18F2585/2680/4585/4680\nNo operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination = No operation. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination = No operation\nExample:\nHERE    INFSNZ  REG, 1, 0\nZERO\nNZERO\nBefore Instruction\nPC\n=\nAddress (HERE)\nAfter Instruction\nREG\n=\nREG + 1\nIf REG\n\uf0b9\n0;\nPC\n=\nAddress (NZERO)\nIf REG\n=\n0;\nPC\n=\nAddress (ZERO)",
    "PIC18F2585/2680/4585/4680\nSyntax:, Inclusive OR Literal with W = IORLW k. Syntax:, Inclusive OR Literal with W = IORLW k. Syntax:, Inclusive OR Literal with W = IORLW k. Syntax:, Inclusive OR Literal with W = IORLW k. Operands:, Inclusive OR Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Inclusive OR Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Inclusive OR Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Inclusive OR Literal with W = 0 \uf0a3 k \uf0a3 255. Operation:, Inclusive OR Literal with W = (W) .OR. k \uf0ae W. Operation:, Inclusive OR Literal with W = (W) .OR. k \uf0ae W. Operation:, Inclusive OR Literal with W = (W) .OR. k \uf0ae W. Operation:, Inclusive OR Literal with W = (W) .OR. k \uf0ae W. Status Affected:, Inclusive OR Literal with W = N, Z. Status Affected:, Inclusive OR Literal with W = N, Z. Status Affected:, Inclusive OR Literal with W = N, Z. Status Affected:, Inclusive OR Literal with W = N, Z.",
    "PIC18F2585/2680/4585/4680\nEncoding:, Inclusive OR Literal with W = 0000. Encoding:, Inclusive OR Literal with W = 1001. Encoding:, Inclusive OR Literal with W = kkkk. Encoding:, Inclusive OR Literal with W = kkkk. Description:, Inclusive OR Literal with W = The contents of Ware ORed with the eight-bit literal 'k'. The result is placed in W.. Description:, Inclusive OR Literal with W = The contents of Ware ORed with the eight-bit literal 'k'. The result is placed in W.. Description:, Inclusive OR Literal with W = The contents of Ware ORed with the eight-bit literal 'k'. The result is placed in W.. Description:, Inclusive OR Literal with W = The contents of Ware ORed with the eight-bit literal 'k'. The result is placed in W.. Words:, Inclusive OR Literal with W = 1. Words:, Inclusive OR Literal with W = 1. Words:, Inclusive OR Literal with W = 1. Words:, Inclusive OR Literal with W = 1. Cycles:, Inclusive OR Literal with W = 1. Cycles:, Inclusive OR",
    "PIC18F2585/2680/4585/4680\nLiteral with W = 1. Cycles:, Inclusive OR Literal with W = 1. Cycles:, Inclusive OR Literal with W = 1. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q1, Inclusive OR Literal with W = Q2. Q1, Inclusive OR Literal with W = Q3. Q1, Inclusive OR Literal with W = Q4. Q1, Inclusive OR Literal with W = Q4. Decode, Inclusive OR Literal with W = Read literal 'k'. Decode, Inclusive OR Literal with W = Process Data. Decode, Inclusive OR Literal with W = Write to W. Decode, Inclusive OR Literal with W = Write to W. Example:, Inclusive OR Literal with W = IORLW. Example:, Inclusive OR Literal with W = 35h. Example:, Inclusive OR Literal with W = . Example:, Inclusive OR Literal with W = . Before Instruction W",
    "PIC18F2585/2680/4585/4680\n=, Inclusive OR Literal with W = 9Ah. Before Instruction W =, Inclusive OR Literal with W = . Before Instruction W =, Inclusive OR Literal with W = . Before Instruction W =, Inclusive OR Literal with W = . After Instruction W =, Inclusive OR Literal with W = BFh. After Instruction W =, Inclusive OR Literal with W = . After Instruction W =, Inclusive OR Literal with W = . After Instruction W =, Inclusive OR Literal with W = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Inclusive OR Wwith f = IORWF. Syntax:, Inclusive OR Wwith f = f {,d {,a}}. Syntax:, Inclusive OR Wwith f = . Syntax:, Inclusive OR Wwith f = . Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Status",
    "PIC18F2585/2680/4585/4680\nAffected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Encoding:, Inclusive OR Wwith f = 0001. Encoding:, Inclusive OR Wwith f = 00da. Encoding:, Inclusive OR Wwith f = ffff. Encoding:, Inclusive OR Wwith f = ffff. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is",
    "PIC18F2585/2680/4585/4680\n' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).. , Inclusive OR Wwith f = If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).. , Inclusive OR Wwith f = If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).. , Inclusive OR Wwith f = If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).. , Inclusive OR Wwith f = If",
    "PIC18F2585/2680/4585/4680\n'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).. , Inclusive OR Wwith f = If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. , Inclusive OR Wwith f = If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. , Inclusive OR Wwith f = If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. , Inclusive OR Wwith f = If 'a' is ' 0 ' and the extended instruction set is enabled,",
    "PIC18F2585/2680/4585/4680\nthis instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Words:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Q Cycle Activity: Q1, Inclusive OR Wwith f = Q2. Q Cycle Activity: Q1, Inclusive OR Wwith f = Q3. Q Cycle Activity: Q1, Inclusive OR Wwith f = . Q Cycle Activity: Q1, Inclusive OR Wwith f = Q4. Decode, Inclusive OR Wwith f = Read register 'f'. Decode, Inclusive OR Wwith f = Process Data. Decode, Inclusive OR Wwith f = . Decode, Inclusive OR Wwith f = Write to destination\nExample:",
    "PIC18F2585/2680/4585/4680\nIORWF  RESULT, 0, 1\nBefore Instruction\nRESULT =\n13h\nW\n=\n91h\nAfter Instruction\nRESULT =\n13h\nW\n=\n93h",
    "PIC18F2585/2680/4585/4680\nSyntax:, Load FSR = LFSR f, k. Syntax:, Load FSR = LFSR f, k. Syntax:, Load FSR = LFSR f, k. Syntax:, Load FSR = LFSR f, k. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operation:, Load FSR = k \uf0ae FSRf. Operation:, Load FSR = k \uf0ae FSRf. Operation:, Load FSR = k \uf0ae FSRf. Operation:, Load FSR = k \uf0ae FSRf. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Encoding:, Load FSR = 1110 1111. Encoding:, Load FSR = 1110 0000. Encoding:, Load FSR",
    "PIC18F2585/2680/4585/4680\n= 00ff k 7 kkk. Encoding:, Load FSR = k 11 kkk kkkk. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Words:, Load FSR = 2. Words:, Load FSR = 2. Words:, Load FSR = 2. Words:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q Cycle Activity:, Load FSR = Q Cycle",
    "PIC18F2585/2680/4585/4680\nActivity:. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q1, Load FSR = Q2. Q1, Load FSR = Q3. Q1, Load FSR = . Q1, Load FSR = Q4. Decode, Load FSR = Read literal 'k' MSB. Decode, Load FSR = Process Data. Decode, Load FSR = Process Data. Decode, Load FSR = Write literal 'k' MSB to FSRfH. Decode, Load FSR = Read literal 'k' LSB. Decode, Load FSR = Process Data. Decode, Load FSR = Process Data. Decode, Load FSR = Write literal 'k' to FSRfL\nExample:\nLFSR 2, 3ABh\nAfter Instruction\nFSR2H FSR2L\n=\n03h\n=\nABh\nWords:\nCycles:",
    "PIC18F2585/2680/4585/4680\nSyntax:, Move f = MOVF. Syntax:, Move f = f {,d {,a}}. Syntax:, Move f = f {,d {,a}}. Syntax:, Move f = f {,d {,a}}. Operands:, Move f = 0 \uf0a3 f \uf0a3 255. Operands:, Move f = 0 \uf0a3 f \uf0a3 255. Operands:, Move f = 0 \uf0a3 f \uf0a3 255. Operands:, Move f = 0 \uf0a3 f \uf0a3 255. , Move f = d \uf0ce [0,1]. , Move f = d \uf0ce [0,1]. , Move f = d \uf0ce [0,1]. , Move f = d \uf0ce [0,1]. , Move f = a \uf0ce [0,1]. , Move f = a \uf0ce [0,1]. , Move f = a \uf0ce [0,1]. , Move f = a \uf0ce [0,1]. Operation:, Move f = f \uf0ae dest. Operation:, Move f = f \uf0ae dest. Operation:, Move f = f \uf0ae dest. Operation:, Move f = f \uf0ae dest. Status Affected:, Move f = N, Z. Status",
    "PIC18F2585/2680/4585/4680\nAffected:, Move f = N, Z. Status Affected:, Move f = N, Z. Status Affected:, Move f = N, Z. Encoding:, Move f = 0101. Encoding:, Move f = 00da. Encoding:, Move f = ffff. Encoding:, Move f = ffff\nDescription:\nThe contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\n1",
    "PIC18F2585/2680/4585/4680\n1\nQ Cycle Activity:\nExample:, Q2.Read register 'f' = MOVF. Example:, Q3.Process Data = REG, 0, 0. Example:, Q4.Write W = . Before Instruction REG W After Instruction, Q2.Read register 'f' = = =. Before Instruction REG W After Instruction, Q3.Process Data = 22h FFh. Before Instruction REG W After Instruction, Q4.Write W = . REG W, Q2.Read register 'f' = = =. REG W, Q3.Process Data = 22h 22h. REG W, Q4.Write W = ",
    "PIC18F2585/2680/4585/4680\nMOVFF, 1 = Move f to f. MOVFF, 2 = Move f to f. MOVFF, 3 = Move f to f. MOVFF, 4 = Move f to f. Syntax:, 1 = MOVFF f s ,f d. Syntax:, 2 = MOVFF f s ,f d. Syntax:, 3 = MOVFF f s ,f d. Syntax:, 4 = MOVFF f s ,f d. Operands:, 1 = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, 2 = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, 3 = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, 4 = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operation:, 1 = (f s ) \uf0ae f d. Operation:, 2 = (f s ) \uf0ae f d. Operation:, 3 = (f s ) \uf0ae f d. Operation:, 4 = (f s ) \uf0ae f d. Status Affected:, 1 = None. Status Affected:, 2 = None. Status",
    "PIC18F2585/2680/4585/4680\nAffected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = . Encoding:, 2 = . Encoding:, 3 = . Encoding:, 4 = . 1st word (source) 2nd word (destin.), 1 = 1100 1111. 1st word (source) 2nd word (destin.), 2 = ffff ffff. 1st word (source) 2nd word (destin.), 3 = ffff ffff. 1st word (source) 2nd word (destin.), 4 = ffff s ffff d. Description:, 1 = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W. Description:, 2 = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space",
    "PIC18F2585/2680/4585/4680\n(000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W. Description:, 3 = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W. Description:, 4 = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W. Words:, 1 = 2. Words:, 2 = 2. Words:, 3 = 2. Words:, 4 = 2. Cycles:, 1 = 2. Cycles:, 2 = 2. Cycles:, 3 =",
    "PIC18F2585/2680/4585/4680\n2. Cycles:, 4 = 2. Q Cycle Activity: Q1, 1 = Q2. Q Cycle Activity: Q1, 2 = Q3. Q Cycle Activity: Q1, 3 = Q3. Q Cycle Activity: Q1, 4 = Q4. Decode, 1 = Read register 'f' (src) No. Decode, 2 = Process Data. Decode, 3 = Process Data. Decode, 4 = No operation. Decode, 1 = operation No dummy. Decode, 2 = No operation. Decode, 3 = No operation. Decode, 4 = Write register 'f' (dest)",
    "PIC18F2585/2680/4585/4680\nSyntax:, Move Literal to Low Nibble in BSR = MOVLW k. Syntax:, Move Literal to Low Nibble in BSR = MOVLW k. Syntax:, Move Literal to Low Nibble in BSR = MOVLW k. Syntax:, Move Literal to Low Nibble in BSR = MOVLW k. Operands:, Move Literal to Low Nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to Low Nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to Low Nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to Low Nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operation:, Move Literal to Low Nibble in BSR = k \uf0ae BSR. Operation:, Move Literal to Low Nibble in BSR = k \uf0ae BSR. Operation:, Move Literal to Low Nibble in BSR = k \uf0ae BSR. Operation:, Move Literal to Low Nibble in BSR = k \uf0ae BSR. Status Affected:, Move Literal to Low Nibble in BSR = None. Status Affected:, Move Literal to Low Nibble",
    "PIC18F2585/2680/4585/4680\nin BSR = None. Status Affected:, Move Literal to Low Nibble in BSR = None. Status Affected:, Move Literal to Low Nibble in BSR = None. Encoding:, Move Literal to Low Nibble in BSR = 0000. Encoding:, Move Literal to Low Nibble in BSR = 0001. Encoding:, Move Literal to Low Nibble in BSR = kkkk. Encoding:, Move Literal to Low Nibble in BSR = kkkk. Description:, Move Literal to Low Nibble in BSR = The eight-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains ' 0 ', regardless of the value of k 7 :k 4 .. Description:, Move Literal to Low Nibble in BSR = The eight-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains ' 0 ', regardless of the value of k 7 :k 4 .. Description:, Move Literal to Low Nibble in BSR = The",
    "PIC18F2585/2680/4585/4680\neight-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains ' 0 ', regardless of the value of k 7 :k 4 .. Description:, Move Literal to Low Nibble in BSR = The eight-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains ' 0 ', regardless of the value of k 7 :k 4 .. Words:, Move Literal to Low Nibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Q Cycle Activity:, Move Literal to Low Nibble in BSR",
    "PIC18F2585/2680/4585/4680\n= . Q Cycle Activity:, Move Literal to Low Nibble in BSR = . Q Cycle Activity:, Move Literal to Low Nibble in BSR = . Q Cycle Activity:, Move Literal to Low Nibble in BSR = . Q1, Move Literal to Low Nibble in BSR = Q2. Q1, Move Literal to Low Nibble in BSR = Q2. Q1, Move Literal to Low Nibble in BSR = Q3. Q1, Move Literal to Low Nibble in BSR = Q4. Decode, Move Literal to Low Nibble in BSR = Read literal 'k'. Decode, Move Literal to Low Nibble in BSR = Read literal 'k'. Decode, Move Literal to Low Nibble in BSR = Process Data. Decode, Move Literal to Low Nibble in BSR = Write literal 'k' to BSR. Example:, Move Literal to Low Nibble in BSR = MOVLB. Example:, Move Literal to Low Nibble in BSR = MOVLB. Example:, Move Literal to Low Nibble in BSR = 5. Example:,",
    "PIC18F2585/2680/4585/4680\nMove Literal to Low Nibble in BSR = . Before Instruction BSR Register =, Move Literal to Low Nibble in BSR = Before Instruction BSR Register =. Before Instruction BSR Register =, Move Literal to Low Nibble in BSR = 02h. Before Instruction BSR Register =, Move Literal to Low Nibble in BSR = . Before Instruction BSR Register =, Move Literal to Low Nibble in BSR = ",
    "Example:\nMOVFF   REG1, REG2\nBefore Instruction\nREG1\n=\n33h\nREG2\n=\n11h\nAfter Instruction\nREG1\n=\n33h\nREG2\n=\n33h",
    "PIC18F2585/2680/4585/4680\nSyntax:, Move Literal to W = MOVLW k. Syntax:, Move Literal to W = MOVLW k. Syntax:, Move Literal to W = MOVLW k. Syntax:, Move Literal to W = MOVLW k. Operands:, Move Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to W = 0 \uf0a3 k \uf0a3 255. Operation:, Move Literal to W = k \uf0ae W. Operation:, Move Literal to W = k \uf0ae W. Operation:, Move Literal to W = k \uf0ae W. Operation:, Move Literal to W = k \uf0ae W. Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = None. Encoding:, Move Literal to W = 0000. Encoding:, Move Literal to W = 1110. Encoding:, Move Literal to W = kkkk. Encoding:, Move Literal to W = kkkk.",
    "PIC18F2585/2680/4585/4680\nDescription:, Move Literal to W = The eight-bit literal 'k' is loaded into W.. Description:, Move Literal to W = The eight-bit literal 'k' is loaded into W.. Description:, Move Literal to W = The eight-bit literal 'k' is loaded into W.. Description:, Move Literal to W = The eight-bit literal 'k' is loaded into W.. Words:, Move Literal to W = 1. Words:, Move Literal to W = 1. Words:, Move Literal to W = 1. Words:, Move Literal to W = 1. Cycles:, Move Literal to W = 1. Cycles:, Move Literal to W = 1. Cycles:, Move Literal to W = 1. Cycles:, Move Literal to W = 1. Q Cycle Activity:, Move Literal to W = Q Cycle Activity:. Q Cycle Activity:, Move Literal to W = Q Cycle Activity:. Q Cycle Activity:, Move Literal to W = Q Cycle Activity:. Q Cycle Activity:, Move Literal to W = Q Cycle Activity:. Q1, Move Literal to W = Q2. Q1,",
    "PIC18F2585/2680/4585/4680\nMove Literal to W = Q3. Q1, Move Literal to W = Q4. Q1, Move Literal to W = Q4. Decode, Move Literal to W = Read literal 'k'. Decode, Move Literal to W = Process Data. Decode, Move Literal to W = Write to W. Decode, Move Literal to W = Write to W. Example:, Move Literal to W = MOVLW. Example:, Move Literal to W = 5Ah. Example:, Move Literal to W = . Example:, Move Literal to W = . After Instruction W =, Move Literal to W = 5Ah. After Instruction W =, Move Literal to W = . After Instruction W =, Move Literal to W = . After Instruction W =, Move Literal to W = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Move Wto f = MOVWF. Syntax:, Move Wto f = f {,a}. Syntax:, Move Wto f = . Syntax:, Move Wto f = . Operands:, Move Wto f = 0 \uf0a3 f \uf0a3 a \uf0ce [0,1]. Operands:, Move Wto f = 255. Operands:, Move Wto f = . Operands:, Move Wto f = . Operation:, Move Wto f = (W) \uf0ae. Operation:, Move Wto f = f. Operation:, Move Wto f = . Operation:, Move Wto f = . Status Affected:, Move Wto f = None. Status Affected:, Move Wto f = . Status Affected:, Move Wto f = . Status Affected:, Move Wto f = . Encoding:, Move Wto f = 0110. Encoding:, Move Wto f = 111a. Encoding:, Move Wto f = ffff. Encoding:, Move Wto f = ffff. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can",
    "PIC18F2585/2680/4585/4680\nbe anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Move Wto f = Move data from Wto register",
    "PIC18F2585/2680/4585/4680\n'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Words:, Move Wto f =",
    "PIC18F2585/2680/4585/4680\n1. Words:, Move Wto f = . Words:, Move Wto f = . Words:, Move Wto f = . Cycles:, Move Wto f = 1. Cycles:, Move Wto f = . Cycles:, Move Wto f = . Cycles:, Move Wto f = . Q Cycle Activity:, Move Wto f = . Q Cycle Activity:, Move Wto f = . Q Cycle Activity:, Move Wto f = . Q Cycle Activity:, Move Wto f = . Q1, Move Wto f = Q2. Q1, Move Wto f = Q3. Q1, Move Wto f = . Q1, Move Wto f = Q4. Decode, Move Wto f = . Decode, Move Wto f = Read register 'f'. Decode, Move Wto f = Process Data. Decode, Move Wto f = Write register 'f'. Example: MOVWF, Move Wto f = Example: MOVWF. Example: MOVWF, Move Wto f = . Example: MOVWF, Move Wto",
    "PIC18F2585/2680/4585/4680\nf = REG, 0. Example: MOVWF, Move Wto f = . Before Instruction, Move Wto f = Before Instruction. Before Instruction, Move Wto f = . Before Instruction, Move Wto f = . Before Instruction, Move Wto f = . W REG, Move Wto f = = =. W REG, Move Wto f = 4Fh FFh. W REG, Move Wto f = . W REG, Move Wto f = . After Instruction, Move Wto f = After Instruction. After Instruction, Move Wto f = . After Instruction, Move Wto f = . After Instruction, Move Wto f = . W REG, Move Wto f = = 4Fh = 4Fh. W REG, Move Wto f = . W REG, Move Wto f = . W REG, Move Wto f = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Multiply Literal with W = MULLW. Syntax:, Multiply Literal with W = k. Syntax:, Multiply Literal with W = k. Operands:, Multiply Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Multiply Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Multiply Literal with W = 0 \uf0a3 k \uf0a3 255. Operation:, Multiply Literal with W = (W) x k \uf0ae PRODH:PRODL. Operation:, Multiply Literal with W = (W) x k \uf0ae PRODH:PRODL. Operation:, Multiply Literal with W = (W) x k \uf0ae PRODH:PRODL. Status Affected:, Multiply Literal with W = None. Status Affected:, Multiply Literal with W = None. Status Affected:, Multiply Literal with W = None. Encoding:, Multiply Literal with W = 0000. Encoding:, Multiply Literal with W = 1101 kkkk. Encoding:, Multiply Literal with W = kkkk. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'.",
    "PIC18F2585/2680/4585/4680\nThe 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Words:, Multiply Literal with",
    "PIC18F2585/2680/4585/4680\nW = 1. Words:, Multiply Literal with W = 1. Words:, Multiply Literal with W = 1. Cycles:, Multiply Literal with W = 1. Cycles:, Multiply Literal with W = 1. Cycles:, Multiply Literal with W = 1. Q Cycle Activity:, Multiply Literal with W = Q Cycle Activity:. Q Cycle Activity:, Multiply Literal with W = Q Cycle Activity:. Q Cycle Activity:, Multiply Literal with W = Q Cycle Activity:. Q1, Multiply Literal with W = Q2. Q1, Multiply Literal with W = Q3. Q1, Multiply Literal with W = Q4. Decode, Multiply Literal with W = Read literal 'k'. Decode, Multiply Literal with W = Process Data. Decode, Multiply Literal with W = Write registers PRODH: PRODL",
    "Example:\nMULLW   0C4h\nBefore Instruction\nW\n=\nE2h\nPRODH\n=\n?\nPRODL\n=\n?\nAfter Instruction\nW\n=\nE2h\nPRODH\n=\nADh\nPRODL\n=\n08h",
    "Example:\nSyntax:, Multiply Wwith f = MULWF. Syntax:, Multiply Wwith f = f {,a}. Syntax:, Multiply Wwith f = . Syntax:, Multiply Wwith f = . Operands:, Multiply Wwith f = 0 \uf0a3 f \uf0a3 255. Operands:, Multiply Wwith f = . Operands:, Multiply Wwith f = . Operands:, Multiply Wwith f = . , Multiply Wwith f = a \uf0ce [0,1]. , Multiply Wwith f = . , Multiply Wwith f = . , Multiply Wwith f = . Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = . Status Affected:, Multiply Wwith f",
    "Example:\n= . Status Affected:, Multiply Wwith f = . Encoding:, Multiply Wwith f = 0000. Encoding:, Multiply Wwith f = 001a. Encoding:, Multiply Wwith f = ffff. Encoding:, Multiply Wwith f = ffff\nDescription:\nAn unsigned multiplication is carried out between the contents of W and the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both W and 'f' are unchanged.\nNone of the Status flags are affected.\nNote that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\n1\n1\nWords:\nCycles:\nQ Cycle Activity:",
    "Example:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write registers PRODH: PRODL\nMULWF   REG, 1\nW REG,  = = =. W REG, C4h = B5h. PRODH,  = =. PRODH, C4h = ?. PRODL,  = =. PRODL, C4h = ?. After Instruction,  = . After Instruction, C4h = . W,  = =. W, C4h = C4h. REG,  = =. REG, C4h = B5h. PRODH,  = =. PRODH, C4h = 8Ah. PRODL,  = =. PRODL, C4h = 94h\nCycles:",
    "PIC18F2585/2680/4585/4680\nSyntax:, Negate f = NEGF. Syntax:, Negate f = f {,a}. Syntax:, Negate f = . Syntax:, Negate f = . Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC,",
    "PIC18F2585/2680/4585/4680\nZ. Encoding:, Negate f = 0110. Encoding:, Negate f = 110a. Encoding:, Negate f = ffff. Encoding:, Negate f = ffff. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the.",
    "PIC18F2585/2680/4585/4680\nDescription:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = 1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write register 'f'\nBefore Instruction REG =, NEGF = 0011. Before Instruction REG =, REG, = 1010. Before Instruction REG =, 1 = [3Ah]. After Instruction REG =, NEGF = 1100. After Instruction REG =, REG, = 0110. After Instruction REG =, 1 = [C6h]",
    "No Operation\nSyntax:, 1 = NOP. Syntax:, 2 = NOP. Syntax:, 3 = NOP. Syntax:, 4 = NOP. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = No operation. Operation:, 2 = No operation. Operation:, 3 = No operation. Operation:, 4 = No operation. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000 1111. Encoding:, 2 = 0000 xxxx. Encoding:, 3 = 0000 xxxx. Encoding:, 4 = 0000 xxxx. Description:, 1 = No operation.. Description:, 2 = No operation.. Description:, 3 = No operation.. Description:, 4 = No operation.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1.",
    "No Operation\nCycles:, 4 = 1. Q Cycle Activity: Q1, 1 = Q2. Q Cycle Activity: Q1, 2 = Q3. Q Cycle Activity: Q1, 3 = Q3. Q Cycle Activity: Q1, 4 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation. Decode, 4 = No operation\nExample:\nNone.",
    "Pop Top of Return Stack\nSyntax:, 1 = POP. Syntax:, 2 = POP. Syntax:, 3 = POP. Syntax:, 4 = POP. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = (TOS) \uf0ae bit bucket. Operation:, 2 = (TOS) \uf0ae bit bucket. Operation:, 3 = (TOS) \uf0ae bit bucket. Operation:, 4 = (TOS) \uf0ae bit bucket. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Encoding:, 4 = 0110. Description:, 1 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 2 = The TOS value is pulled off the return stack and is discarded. The TOS",
    "Pop Top of Return Stack\nvalue then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 3 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 4 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q1, 1 = Q2. Q1, 2 =",
    "Pop Top of Return Stack\nQ3. Q1, 3 = Q3. Q1, 4 = Q4. Decode, 1 = No operation. Decode, 2 = POP TOS value. Decode, 3 = POP TOS value. Decode, 4 = No operation. Example:, 1 = POP. Example:, 2 = . Example:, 3 = . Example:, 4 = . Before Instruction, 1 = GOTO. Before Instruction, 2 = NEW =. Before Instruction, 3 = . Before Instruction, 4 = . TOS Stack (1 level down), 1 = TOS Stack (1 level down). TOS Stack (1 level down), 2 = =. TOS Stack (1 level down), 3 = 014332h. TOS Stack (1 level down), 4 = 0031A2h. After Instruction, 1 = After Instruction. After Instruction, 2 = =. After Instruction, 3 = 014332h NEW. After Instruction, 4 = . TOS PC, 1 = TOS PC. TOS PC, 2 = =. TOS PC, 3 = . TOS PC, 4 = ",
    "Push Top of Return Stack\nSyntax:, 1 = PUSH. Syntax:, 2 = PUSH. Syntax:, 3 = PUSH. Syntax:, 4 = PUSH. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = (PC + 2) \uf0ae TOS. Operation:, 2 = (PC + 2) \uf0ae TOS. Operation:, 3 = (PC + 2) \uf0ae TOS. Operation:, 4 = (PC + 2) \uf0ae TOS. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Encoding:, 4 = 0101. Description:, 1 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, 2 = The PC + 2 is pushed onto the top of the return stack. The previous TOS",
    "Push Top of Return Stack\nvalue is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, 3 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, 4 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q3. Q1, 4 =",
    "Push Top of Return Stack\nQ4. Decode, 1 = PUSH PC + 2 onto return stack. Decode, 2 = No operation. Decode, 3 = No operation. Decode, 4 = No operation. Example:, 1 = PUSH. Example:, 2 = PUSH. Example:, 3 = PUSH. Example:, 4 = PUSH. Before Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. Before Instruction, 3 = Before Instruction. Before Instruction, 4 = Before Instruction. TOS, 1 = TOS. TOS, 2 = =. TOS, 3 = 345Ah. TOS, 4 = . PC, 1 = PC. PC, 2 = =. PC, 3 = 0124h. PC, 4 = . After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. After Instruction, 3 = After Instruction. After Instruction, 4 = After Instruction. PC, 1 = PC. PC, 2 = =. PC, 3 = 0126h. PC, 4 = . TOS, 1 = TOS. TOS, 2 = =. TOS, 3 = 0126h. TOS, 4 = . Stack (1 level down), 1 = Stack",
    "Push Top of Return Stack\n(1 level down). Stack (1 level down), 2 = =. Stack (1 level down), 3 = 345Ah. Stack (1 level down), 4 = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Relative Call = RCALL n. Syntax:, Relative Call = RCALL n. Syntax:, Relative Call = RCALL n. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Encoding:, Relative Call = 1101. Encoding:, Relative Call = 1nnn. Encoding:, Relative Call = nnnn nnnn. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then,",
    "PIC18F2585/2680/4585/4680\nadd the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Words:, Relative Call = 1. Words:,",
    "PIC18F2585/2680/4585/4680\nRelative Call = 1. Words:, Relative Call = 1. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Q Cycle Activity:, Relative Call = . Q Cycle Activity:, Relative Call = . Q Cycle Activity:, Relative Call = . Q1, Relative Call = Q2. Q1, Relative Call = Q3. Q1, Relative Call = Q4. Decode, Relative Call = Read literal 'n' Push PC to stack. Decode, Relative Call = Process Data. Decode, Relative Call = Write to PC. No operation, Relative Call = No operation. No operation, Relative Call = No operation. No operation, Relative Call = No operation",
    "PIC18F2585/2680/4585/4680\nSyntax:, Reset = RESET. Syntax:, Reset = RESET. Syntax:, Reset = RESET. Syntax:, Reset = RESET. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Encoding:, Reset = 0000. Encoding:, Reset = 0000. Encoding:, Reset = 1111. Encoding:, Reset = 1111. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in",
    "PIC18F2585/2680/4585/4680\nsoftware.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q1, Reset = Q2. Q1, Reset = Q3. Q1, Reset = Q4. Q1, Reset = Q4. Decode, Reset = Start Reset. Decode, Reset = No operation. Decode, Reset = No operation. Decode, Reset = No operation. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset = RESET. After Instruction Registers",
    "PIC18F2585/2680/4585/4680\n= Flags* =, Reset = Reset Value. After Instruction Registers = Flags* =, Reset = Reset Value. After Instruction Registers = Flags* =, Reset = Reset Value. After Instruction Registers = Flags* =, Reset = Reset Value",
    "Example:\nHERE\nRCALL Jump\nBefore Instruction\nPC = Address (HERE)\nAfter Instruction\nPC =\nAddress\n(Jump)\nTOS=\nAddress\n(HERE + 2)",
    "PIC18F2585/2680/4585/4680\nSyntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae GIE/GIEH or PEIE/GIEL,",
    "PIC18F2585/2680/4585/4680\nif s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0001. Encoding:, Return from Interrupt = 000s. Description:, Return from Interrupt = Return from Interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt",
    "PIC18F2585/2680/4585/4680\nenable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from Interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from Interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and",
    "PIC18F2585/2680/4585/4680\nBSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from Interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs (default).. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:,",
    "PIC18F2585/2680/4585/4680\nReturn from Interrupt = Q Cycle Activity:. Q1, Return from Interrupt = Q2. Q1, Return from Interrupt = Q3. Q1, Return from Interrupt = Q4. Q1, Return from Interrupt = Q4. Decode, Return from Interrupt = No operation. Decode, Return from Interrupt = No operation. Decode, Return from Interrupt = POP PC from stack Set GIEH or. Decode, Return from Interrupt = POP PC from stack Set GIEH or. No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation\nExample:\nRETFIE  1\nAfter Interrupt\nPC\n=\nTOS\nW\n=\nWS\nBSR\n=\nBSRS\nSTATUS\n=\nSTATUSS\nGIE/GIEH, PEIE/GIEL\n=\n1",
    "PIC18F2585/2680/4585/4680\nSyntax:, Return Literal to W = RETLW k. Syntax:, Return Literal to W = RETLW k. Syntax:, Return Literal to W = RETLW k. Syntax:, Return Literal to W = RETLW k. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to W",
    "PIC18F2585/2680/4585/4680\n= None. Status Affected:, Return Literal to W = None. Encoding:, Return Literal to W = 0000. Encoding:, Return Literal to W = 1100. Encoding:, Return Literal to W = kkkk. Encoding:, Return Literal to W = kkkk. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of",
    "PIC18F2585/2680/4585/4680\nthe stack (the return address). The high address latch (PCLATH) remains unchanged.. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q1, Return Literal to W = Q2. Q1, Return Literal to W = Q3. Q1, Return Literal to W = . Q1, Return Literal to W = Q4. Decode, Return Literal to W = Read literal 'k'. Decode, Return Literal to W = Process Data. Decode, Return Literal to W = . Decode, Return Literal",
    "PIC18F2585/2680/4585/4680\nto W = POP PC from stack, Write to W. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation. No operation, Return Literal to W = . No operation, Return Literal to W = No operation",
    "Example:\nCALL  TABLE; W contains table\n; offset value\n; W now has\n; table value\n:\nTABLE\nADDWF PCL; W = offset\nRETLW k0; Begin table\nRETLW k1;\n:\n:\nRETLW kn; End of table\nBefore Instruction\nW\n= 07h\nAfter Instruction\nW\n=\nvalue of kn",
    "PIC18F2585/2680/4585/4680\nSyntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operation:, Return from Subroutine = (TOS) \uf0ae PC, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Subroutine = (TOS) \uf0ae PC, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Subroutine = (TOS) \uf0ae PC, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,.",
    "PIC18F2585/2680/4585/4680\nOperation:, Return from Subroutine = (TOS) \uf0ae PC, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0001. Encoding:, Return from Subroutine = 001s. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The",
    "PIC18F2585/2680/4585/4680\nstack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If",
    "PIC18F2585/2680/4585/4680\n's' = 0 , no update of these registers occurs (default).. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q1, Return from Subroutine = Q2. Q1, Return from Subroutine = Q3. Q1, Return from Subroutine = . Q1, Return from Subroutine = Q4. Decode, Return from Subroutine = . Decode, Return from Subroutine = No operation. Decode, Return from",
    "PIC18F2585/2680/4585/4680\nSubroutine = Process Data. Decode, Return from Subroutine = POP PC from stack. , Return from Subroutine = No operation. , Return from Subroutine = No operation. , Return from Subroutine = No operation. , Return from Subroutine = No operation\nExample:\nRETURN\nAfter Interrupt PC = TOS",
    "PIC18F2585/2680/4585/4680\nSyntax:, Rotate Left f through Carry = RLCF f {,d {,a}}. Syntax:, Rotate Left f through Carry = RLCF f {,d {,a}}. Syntax:, Rotate Left f through Carry = RLCF f {,d {,a}}. Syntax:, Rotate Left f through Carry = RLCF f {,d {,a}}. Syntax:, Rotate Left f through Carry = RLCF f {,d {,a}}. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1].",
    "PIC18F2585/2680/4585/4680\nOperation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = . Status Affected:, Rotate Left f through Carry = . Status Affected:,",
    "PIC18F2585/2680/4585/4680\nRotate Left f through Carry = . Status Affected:, Rotate Left f through Carry = . Encoding:, Rotate Left f through Carry = 0011. Encoding:, Rotate Left f through Carry = 01da. Encoding:, Rotate Left f through Carry = ffff. Encoding:, Rotate Left f through Carry = ffff. Encoding:, Rotate Left f through Carry = ffff. Description:, Rotate Left f through Carry = The contents one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Rotate Left",
    "PIC18F2585/2680/4585/4680\nf through Carry = of register. Description:, Rotate Left f through Carry = The contents one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Rotate Left f through Carry = The contents one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If",
    "PIC18F2585/2680/4585/4680\n'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Rotate Left f through Carry = rotated. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = . Words:, Rotate Left f through Carry = . Words:, Rotate Left f through Carry = . Words:, Rotate Left f through Carry = . Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = . Cycles:, Rotate Left f through Carry = . Cycles:, Rotate Left f through Carry = . Cycles:, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = Q2 Read. Q Cycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry =",
    "PIC18F2585/2680/4585/4680\nQ3. Q Cycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = Q4. Decode Example:, Rotate Left f through Carry = register 'f'. Decode Example:, Rotate Left f through Carry = Process Data. Decode Example:, Rotate Left f through Carry = . Decode Example:, Rotate Left f through Carry = Write to destination. Decode Example:, Rotate Left f through Carry = Write to destination. Before Instruction REG C, Rotate Left f through Carry = RLCF = 1110 = 0. Before Instruction REG C, Rotate Left f through Carry = 0, 0110. Before Instruction REG C, Rotate Left f through Carry = REG,. Before Instruction REG C, Rotate Left f through Carry = . Before Instruction REG C, Rotate Left f through Carry = . Instruction, Rotate Left f through Carry = . Instruction, Rotate Left f through Carry = 0110. Instruction, Rotate Left f through Carry = . Instruction, Rotate Left f through Carry = . Instruction, Rotate Left f through Carry = . After REG W C, Rotate Left f through Carry = = 1110 = 1100",
    "PIC18F2585/2680/4585/4680\n= 1. After REG W C, Rotate Left f through Carry = 1100. After REG W C, Rotate Left f through Carry = . After REG W C, Rotate Left f through Carry = . After REG W C, Rotate Left f through Carry = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Rotate Left f (No Carry) = RLNCF. Syntax:, Rotate Left f (No Carry) = f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = f {,d {,a}}. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (No Carry) =",
    "PIC18F2585/2680/4585/4680\n(f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Encoding:, Rotate Left f (No Carry) = 0100. Encoding:, Rotate Left f (No Carry) = 01da. Encoding:, Rotate Left f (No Carry) = ffff. Encoding:, Rotate Left f (No Carry) = ffff. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit",
    "PIC18F2585/2680/4585/4680\nto the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If",
    "PIC18F2585/2680/4585/4680\n'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0",
    "PIC18F2585/2680/4585/4680\n', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Q Cycle Activity:, Rotate Left f (No Carry) = .",
    "PIC18F2585/2680/4585/4680\nQ Cycle Activity:, Rotate Left f (No Carry) = . Q Cycle Activity:, Rotate Left f (No Carry) = . Q Cycle Activity:, Rotate Left f (No Carry) = . Q1 Decode, Rotate Left f (No Carry) = Q2 Read register 'f'. Q1 Decode, Rotate Left f (No Carry) = Q3 Process. Q1 Decode, Rotate Left f (No Carry) = Q3 Process. Q1 Decode, Rotate Left f (No Carry) = Q4 Write to destination. Example:, Rotate Left f (No Carry) = RLNCF. Example:, Rotate Left f (No Carry) = REG,. Example:, Rotate Left f (No Carry) = 1,. Example:, Rotate Left f (No Carry) = 0",
    "PIC18F2585/2680/4585/4680\nSyntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1].",
    "PIC18F2585/2680/4585/4680\nOperation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry =",
    "PIC18F2585/2680/4585/4680\nC, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section",
    "PIC18F2585/2680/4585/4680\n25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1",
    "PIC18F2585/2680/4585/4680\n', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed",
    "PIC18F2585/2680/4585/4680\nLiteral Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Words:, Rotate",
    "PIC18F2585/2680/4585/4680\nRight f through Carry = 1. Words:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Q Cycle Activity:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through Carry = . Q1, Rotate Right f through Carry = Q2 Q3. Q1, Rotate Right f through Carry = Q2 Q3. Q1, Rotate Right f through Carry = Q2 Q3. Q1, Rotate Right f through Carry = Q4. Q1, Rotate Right f through Carry = Q4. Decode, Rotate Right f through Carry = Read register 'f' Process Data. Decode, Rotate Right f through Carry = Read register 'f' Process Data. Decode, Rotate Right f through Carry =",
    "PIC18F2585/2680/4585/4680\nRead register 'f' Process Data. Decode, Rotate Right f through Carry = Write to destination. Decode, Rotate Right f through Carry = Write to destination. Example: RRCF REG, 0, 0, Rotate Right f through Carry = Example: RRCF REG, 0, 0. Example: RRCF REG, 0, 0, Rotate Right f through Carry = Example: RRCF REG, 0, 0. Example: RRCF REG, 0, 0, Rotate Right f through Carry = Example: RRCF REG, 0, 0. Example: RRCF REG, 0, 0, Rotate Right f through Carry = Example: RRCF REG, 0, 0. Example: RRCF REG, 0, 0, Rotate Right f through Carry = Example: RRCF REG, 0, 0. Before Instruction REG, Rotate Right f through Carry = = 1110. Before Instruction REG, Rotate Right f through Carry = 0110. Before Instruction REG, Rotate Right f through Carry = . Before Instruction REG, Rotate Right f through Carry = . Before Instruction REG, Rotate Right f through Carry = . C, Rotate Right f through Carry =",
    "PIC18F2585/2680/4585/4680\n= 0. C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. REG, Rotate Right f through Carry = = 1110. REG, Rotate Right f through Carry = 0110. REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . W C, Rotate Right f through Carry = = 0111 = 0. W C, Rotate Right f through Carry = 0011. W C, Rotate Right f through Carry = . W C, Rotate Right f through Carry = . W C, Rotate Right f through Carry = \nDescription:",
    "PIC18F2585/2680/4585/4680\nSyntax:, Rotate Right f (No Carry) = RRNCF. Syntax:, Rotate Right f (No Carry) = f {,d {,a}}. Syntax:, Rotate Right f (No Carry) = . Syntax:, Rotate Right f (No Carry) = . Operands:, Rotate Right f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (No Carry) = . Operands:, Rotate Right f (No Carry) = . Operands:, Rotate Right f (No Carry) = . Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate",
    "PIC18F2585/2680/4585/4680\nRight f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = . Status Affected:, Rotate Right f (No Carry) = . Status Affected:, Rotate Right f (No Carry) = . Encoding:, Rotate Right f (No Carry) = 0100. Encoding:, Rotate Right f (No Carry) = 00da. Encoding:, Rotate Right f (No Carry) = ffff. Encoding:, Rotate Right f (No Carry) = ffff",
    "Set f\nThe contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).\nIf 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\n1\n1\nWords:\nCycles:\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "Example 1:\nRRNCF   REG, 1, 0\nBefore Instruction\nREG\n=\n1101 0111\nAfter Instruction\nREG\n=\n1110 1011",
    "Example 2:\nRRNCF   REG, 0, 0\nBefore Instruction\nW\n=\n?\nREG\n=\n1101 0111\nAfter Instruction\nW\n=\n1110 1011\nREG =\n1101 0111\nSyntax:\nSETF    f {,a}\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce\uf020 [0,1]\nOperation:\nFFh \uf0ae f\nStatus Affected:\nNone\nEncoding:\n0110\n100a\nffff\nffff\nDescription:\nThe contents of the specified register are set to FFh.\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite\nregister 'f'",
    "Example:\nSETF\nREG,1\nBefore Instruction\nREG\n=\n5Ah\nAfter Instruction\nREG\n=\nFFh",
    "PIC18F2585/2680/4585/4680\nSyntax:, SLEEP = Syntax:. Syntax:, Enter Sleep mode = SLEEP. Syntax:, Enter Sleep mode = SLEEP. Syntax:, Enter Sleep mode = SLEEP. Operands:, SLEEP = Operands:. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operation:, SLEEP = Operation:. Operation:, Enter Sleep mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler, 1 \uf0ae TO, 0 \uf0ae PD. Operation:, Enter Sleep mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler, 1 \uf0ae TO, 0 \uf0ae PD. Operation:, Enter Sleep mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler, 1 \uf0ae TO, 0 \uf0ae PD. Status Affected:, SLEEP = Status Affected:. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Encoding:, SLEEP = Encoding:. Encoding:, Enter Sleep mode = 0000. Encoding:, Enter Sleep mode = 0000. Encoding:, Enter Sleep mode = 0000.",
    "PIC18F2585/2680/4585/4680\nDescription:, SLEEP = Description:. Description:, Enter Sleep mode = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its posts- caler are cleared. The processor is put into Sleep mode. Description:, Enter Sleep mode = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its posts- caler are cleared. The processor is put into Sleep mode. Description:, Enter Sleep mode = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its posts- caler are cleared. The processor is put into Sleep mode. Words:, SLEEP = Words:. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Cycles:, SLEEP = Cycles:. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Q Cycle Activity:, SLEEP = Q1. Q",
    "PIC18F2585/2680/4585/4680\nCycle Activity:, Enter Sleep mode = Q2. Q Cycle Activity:, Enter Sleep mode = Q3. Q Cycle Activity:, Enter Sleep mode = Q3. , SLEEP = Decode. , Enter Sleep mode = No operation. , Enter Sleep mode = Process Data. , Enter Sleep mode = Process Data\nExample:\nSLEEP\nBefore Instruction\nTO\n=\n?\nPD\n=\n?\nAfter Instruction\nTO = 1 \u2020\nPD\n=\n0\n- \u2020   If WDT causes wake-up, this bit is cleared.",
    "PIC18F2585/2680/4585/4680\nSyntax:, Subtract f from Wwith Borrow = SUBFWB f {,d {,a}}. Syntax:, Subtract f from Wwith Borrow = SUBFWB f {,d {,a}}. Syntax:, Subtract f from Wwith Borrow = SUBFWB f {,d {,a}}. Syntax:, Subtract f from Wwith Borrow = SUBFWB f {,d {,a}}. Syntax:, Subtract f from Wwith Borrow = SUBFWB f {,d {,a}}. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce",
    "PIC18F2585/2680/4585/4680\n[0,1]. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Status Affected:, Subtract f from Wwith Borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith Borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith Borrow = N, OV, C, DC, Z. Status Affected:,",
    "PIC18F2585/2680/4585/4680\nSubtract f from Wwith Borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith Borrow = N, OV, C, DC, Z. Encoding:, Subtract f from Wwith Borrow = 0101. Encoding:, Subtract f from Wwith Borrow = 01da. Encoding:, Subtract f from Wwith Borrow = ffff. Encoding:, Subtract f from Wwith Borrow = . Encoding:, Subtract f from Wwith Borrow = ffff. Description:, Subtract f from Wwith Borrow = Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSRis used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is",
    "PIC18F2585/2680/4585/4680\nenabled, this instruction operates. Description:, Subtract f from Wwith Borrow = Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSRis used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates. Description:, Subtract f from Wwith Borrow = Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSRis used to select the",
    "PIC18F2585/2680/4585/4680\nGPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates. Description:, Subtract f from Wwith Borrow = Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSRis used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates. Description:, Subtract f from Wwith Borrow = Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access",
    "PIC18F2585/2680/4585/4680\nBank is selected. If 'a' is ' 1 ', the BSRis used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates. Words:, Subtract f from Wwith Borrow = 1. Words:, Subtract f from Wwith Borrow = 1. Words:, Subtract f from Wwith Borrow = 1. Words:, Subtract f from Wwith Borrow = 1. Words:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Q Cycle Activity: Q1 Decode, Subtract f from Wwith Borrow = Q2 Read register 'f'. Q Cycle Activity: Q1 Decode, Subtract f from Wwith Borrow = Process. Q Cycle Activity: Q1 Decode,",
    "PIC18F2585/2680/4585/4680\nSubtract f from Wwith Borrow = Q3. Q Cycle Activity: Q1 Decode, Subtract f from Wwith Borrow = . Q Cycle Activity: Q1 Decode, Subtract f from Wwith Borrow = Q4 Write to. Example 1:, Subtract f from Wwith Borrow = . Example 1:, Subtract f from Wwith Borrow = Data. Example 1:, Subtract f from Wwith Borrow = . Example 1:, Subtract f from Wwith Borrow = . Example 1:, Subtract f from Wwith Borrow = destination. , Subtract f from Wwith Borrow = SUBFWB. , Subtract f from Wwith Borrow = REG,. , Subtract f from Wwith Borrow = 1,. , Subtract f from Wwith Borrow = 0. , Subtract f from Wwith Borrow = . Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f",
    "PIC18F2585/2680/4585/4680\nfrom Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. REG, Subtract f from Wwith Borrow = =. REG, Subtract f from Wwith Borrow = 3. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = =. W, Subtract f from Wwith Borrow = 2. W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = =. C, Subtract f from Wwith Borrow = 1. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = =. After Instruction, Subtract f from Wwith Borrow = FF. After Instruction,",
    "PIC18F2585/2680/4585/4680\nSubtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . REG W, Subtract f from Wwith Borrow = =. REG W, Subtract f from Wwith Borrow = 2 0. REG W, Subtract f from Wwith Borrow = . REG W, Subtract f from Wwith Borrow = . REG W, Subtract f from Wwith Borrow = . C Z, Subtract f from Wwith Borrow = = =. C Z, Subtract f from Wwith Borrow = 0. C Z, Subtract f from Wwith Borrow = . C Z, Subtract f from Wwith Borrow = . C Z, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = 1. N, Subtract f from Wwith Borrow = is negative. N, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = . , Subtract f from",
    "PIC18F2585/2680/4585/4680\nWwith Borrow = =. , Subtract f from Wwith Borrow = ; result. , Subtract f from Wwith Borrow = . , Subtract f from Wwith Borrow = . , Subtract f from Wwith Borrow = . Example 2: SUBFWB REG, 0, 0, Subtract f from Wwith Borrow = Example 2: SUBFWB REG, 0, 0. Example 2: SUBFWB REG, 0, 0, Subtract f from Wwith Borrow = Example 2: SUBFWB REG, 0, 0. Example 2: SUBFWB REG, 0, 0, Subtract f from Wwith Borrow = Example 2: SUBFWB REG, 0, 0. Example 2: SUBFWB REG, 0, 0, Subtract f from Wwith Borrow = Example 2: SUBFWB REG, 0, 0. Example 2: SUBFWB REG, 0, 0, Subtract f from Wwith Borrow = Example 2: SUBFWB REG, 0, 0. Before Instruction REG, Subtract f from Wwith Borrow = =.",
    "PIC18F2585/2680/4585/4680\nBefore Instruction REG, Subtract f from Wwith Borrow = 2. Before Instruction REG, Subtract f from Wwith Borrow = . Before Instruction REG, Subtract f from Wwith Borrow = . Before Instruction REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = =. W, Subtract f from Wwith Borrow = 5. W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = =. C, Subtract f from Wwith Borrow = 1. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from",
    "PIC18F2585/2680/4585/4680\nWwith Borrow = . REG, Subtract f from Wwith Borrow = =. REG, Subtract f from Wwith Borrow = 2 3. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W C, Subtract f from Wwith Borrow = = =. W C, Subtract f from Wwith Borrow = 1. W C, Subtract f from Wwith Borrow = . W C, Subtract f from Wwith Borrow = . W C, Subtract f from Wwith Borrow = . Z N, Subtract f from Wwith Borrow = =. Z N, Subtract f from Wwith Borrow = 0. Z N, Subtract f from Wwith Borrow = result is. Z N, Subtract f from Wwith Borrow = . Z N, Subtract f from Wwith Borrow = . , Subtract f from Wwith Borrow = = ;. , Subtract f from Wwith Borrow = 0. , Subtract f from Wwith Borrow = positive.",
    "PIC18F2585/2680/4585/4680\n, Subtract f from Wwith Borrow = . , Subtract f from Wwith Borrow = . Example 3: SUBFWB REG, 1, 0 Before Instruction, Subtract f from Wwith Borrow = Example 3: SUBFWB REG, 1, 0 Before Instruction. Example 3: SUBFWB REG, 1, 0 Before Instruction, Subtract f from Wwith Borrow = Example 3: SUBFWB REG, 1, 0 Before Instruction. Example 3: SUBFWB REG, 1, 0 Before Instruction, Subtract f from Wwith Borrow = Example 3: SUBFWB REG, 1, 0 Before Instruction. Example 3: SUBFWB REG, 1, 0 Before Instruction, Subtract f from Wwith Borrow = Example 3: SUBFWB REG, 1, 0 Before Instruction. Example 3: SUBFWB REG, 1, 0 Before Instruction, Subtract f from Wwith Borrow = Example 3: SUBFWB REG, 1, 0 Before Instruction. REG, Subtract f from Wwith Borrow = =. REG, Subtract f from Wwith Borrow = 1",
    "PIC18F2585/2680/4585/4680\n2. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = =. W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = =. C, Subtract f from Wwith Borrow = 0. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. REG, Subtract f",
    "PIC18F2585/2680/4585/4680\nfrom Wwith Borrow = =. REG, Subtract f from Wwith Borrow = 0. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = =. W, Subtract f from Wwith Borrow = 2. W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C Z, Subtract f from Wwith Borrow = =. C Z, Subtract f from Wwith Borrow = 1 1. C Z, Subtract f from Wwith Borrow = . C Z, Subtract f from Wwith Borrow = . C Z, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = = ; =. N, Subtract f from Wwith Borrow = 0. N, Subtract f from Wwith Borrow = result is zero. N, Subtract f from Wwith Borrow = .",
    "PIC18F2585/2680/4585/4680\nN, Subtract f from Wwith Borrow = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Subtract Wfrom Literal = SUBLW k. Syntax:, Subtract Wfrom Literal = SUBLW k. Syntax:, Subtract Wfrom Literal = SUBLW k. Syntax:, Subtract Wfrom Literal = SUBLW k. Operands:, Subtract Wfrom Literal = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Subtract Wfrom Literal = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Subtract Wfrom Literal = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Subtract Wfrom Literal = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operation:, Subtract Wfrom Literal = k - (W) \uf0ae\uf020 W. Operation:, Subtract Wfrom Literal = k - (W) \uf0ae\uf020 W. Operation:, Subtract Wfrom Literal = k - (W) \uf0ae\uf020 W. Operation:, Subtract Wfrom Literal = k - (W) \uf0ae\uf020 W. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C,",
    "PIC18F2585/2680/4585/4680\nDC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Encoding:, Subtract Wfrom Literal = 0000 1000. Encoding:, Subtract Wfrom Literal = 0000 1000. Encoding:, Subtract Wfrom Literal = kkkk. Encoding:, Subtract Wfrom Literal = kkkk. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W..",
    "PIC18F2585/2680/4585/4680\nWords:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q1, Subtract Wfrom Literal = Q2. Q1, Subtract Wfrom Literal = . Q1, Subtract Wfrom Literal = . Q1, Subtract Wfrom Literal = . Decode, Subtract Wfrom Literal = Read literal",
    "PIC18F2585/2680/4585/4680\n'k'. Decode, Subtract Wfrom Literal = Process Data Write to W. Decode, Subtract Wfrom Literal = Process Data Write to W. Decode, Subtract Wfrom Literal = Process Data Write to W. Example 1:, Subtract Wfrom Literal = SUBLW. Example 1:, Subtract Wfrom Literal = 02h. Example 1:, Subtract Wfrom Literal = 02h. Example 1:, Subtract Wfrom Literal = 02h. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. W C, Subtract Wfrom Literal = = 01h ?. W C, Subtract Wfrom Literal = . W C, Subtract Wfrom Literal = . W C, Subtract Wfrom Literal = . = After Instruction, Subtract Wfrom Literal = = After Instruction. = After",
    "PIC18F2585/2680/4585/4680\nInstruction, Subtract Wfrom Literal = = After Instruction. = After Instruction, Subtract Wfrom Literal = = After Instruction. = After Instruction, Subtract Wfrom Literal = = After Instruction. W C, Subtract Wfrom Literal = = 01h. W C, Subtract Wfrom Literal = . W C, Subtract Wfrom Literal = . W C, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = = 1 = 0. Z, Subtract Wfrom Literal = ; result is positive. Z, Subtract Wfrom Literal = ; result is positive. Z, Subtract Wfrom Literal = ; result is positive. N, Subtract Wfrom Literal = = 0. N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . Example 2:, Subtract Wfrom Literal = . Example 2:, Subtract Wfrom Literal = 02h. Example 2:, Subtract Wfrom Literal",
    "PIC18F2585/2680/4585/4680\n= 02h. Example 2:, Subtract Wfrom Literal = 02h. , Subtract Wfrom Literal = SUBLW. , Subtract Wfrom Literal = . , Subtract Wfrom Literal = . , Subtract Wfrom Literal = . W C After Instruction W C, Subtract Wfrom Literal = = 02h = ? = 00h 1 1. W C After Instruction W C, Subtract Wfrom Literal = . W C After Instruction W C, Subtract Wfrom Literal = . W C After Instruction W C, Subtract Wfrom Literal = . Example 3: Before, Subtract Wfrom Literal = = = 0. Example 3: Before, Subtract Wfrom Literal = ; result is zero. Example 3: Before, Subtract Wfrom Literal = ; result is zero. Example 3: Before, Subtract Wfrom Literal = ; result is zero. Z N, Subtract Wfrom Literal = =. Z N, Subtract Wfrom Literal = 02h. Z N, Subtract",
    "PIC18F2585/2680/4585/4680\nWfrom Literal = 02h. Z N, Subtract Wfrom Literal = 02h. , Subtract Wfrom Literal = SUBLW. , Subtract Wfrom Literal = . , Subtract Wfrom Literal = . , Subtract Wfrom Literal = . Instruction W C, Subtract Wfrom Literal = = 03h = ? 0 0 1. Instruction W C, Subtract Wfrom Literal = . Instruction W C, Subtract Wfrom Literal = . Instruction W C, Subtract Wfrom Literal = . After Instruction, Subtract Wfrom Literal = =. After Instruction, Subtract Wfrom Literal = FFh; (2's complement). After Instruction, Subtract Wfrom Literal = FFh; (2's complement). After Instruction, Subtract Wfrom Literal = FFh; (2's complement). W C, Subtract Wfrom Literal = =. W C, Subtract Wfrom Literal = ; result is negative. W C, Subtract Wfrom Literal = ;",
    "PIC18F2585/2680/4585/4680\nresult is negative. W C, Subtract Wfrom Literal = ; result is negative. Z N, Subtract Wfrom Literal = . Z N, Subtract Wfrom Literal = . Z N, Subtract Wfrom Literal = . Z N, Subtract Wfrom Literal = . , Subtract Wfrom Literal = =. , Subtract Wfrom Literal = . , Subtract Wfrom Literal = . , Subtract Wfrom Literal = . , Subtract Wfrom Literal = =. , Subtract Wfrom Literal = . , Subtract Wfrom Literal = . , Subtract Wfrom Literal = ",
    "PIC18F2585/2680/4585/4680\nSyntax:, Subtract Wfrom = SUBWF. Syntax:, f = f {,d {,a}}. Syntax:, f = . Syntax:, f = . Syntax:, f = . Operands:, Subtract Wfrom = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Subtract Wfrom = (f) - (W) \uf0ae\uf020 dest. Operation:, f = (f) - (W) \uf0ae\uf020 dest. Operation:, f = . Operation:, f = . Operation:, f = . Status Affected:, Subtract Wfrom = N, OV, C, DC, Z. Status Affected:, f",
    "PIC18F2585/2680/4585/4680\n= N, OV, C, DC, Z. Status Affected:, f = N, OV, C, DC, Z. Status Affected:, f = N, OV, C, DC, Z. Status Affected:, f = N, OV, C, DC, Z. Encoding:, Subtract Wfrom = 0101. Encoding:, f = 11da. Encoding:, f = ffff. Encoding:, f = ffff. Encoding:, f = ffff. Description:, Subtract Wfrom = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSRis used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing. Description:, f",
    "PIC18F2585/2680/4585/4680\n= Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSRis used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing. Description:, f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSRis used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed",
    "PIC18F2585/2680/4585/4680\nLiteral Offset Addressing. Description:, f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSRis used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing. Description:, f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSRis used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set",
    "PIC18F2585/2680/4585/4680\nis enabled, this instruction operates in Indexed Literal Offset Addressing. Words:, Subtract Wfrom = 1. Words:, f = 1. Words:, f = 1. Words:, f = 1. Words:, f = 1. Cycles:, Subtract Wfrom = 1. Cycles:, f = 1. Cycles:, f = 1. Cycles:, f = 1. Cycles:, f = 1. Q Cycle Activity: Q1, Subtract Wfrom = Q2 Read. Q Cycle Activity: Q1, f = . Q Cycle Activity: Q1, f = Q3. Q Cycle Activity: Q1, f = . Q Cycle Activity: Q1, f = Q4. Example 1:, Subtract Wfrom = register 'f'. Example 1:, f = Process Data 1,. Example 1:, f = Process Data 1,. Example 1:, f = Write to. Example 1:, f = destination. , Subtract Wfrom = SUBWF. , f = REG,. , f = 0. , f = . , f = . REG",
    "PIC18F2585/2680/4585/4680\nW, Subtract Wfrom = = 3 =. REG W, f = 1. REG W, f = . REG W, f = . REG W, f = . C, Subtract Wfrom = 2 =. C, f = ?. C, f = . C, f = . C, f = . After Instruction REG W C, Subtract Wfrom = = = 2 = =. After Instruction REG W C, f = 1 ; result 0 0. After Instruction REG W C, f = is positive. After Instruction REG W C, f = . After Instruction REG W C, f = . Z N 2:, Subtract Wfrom = =. Z N 2:, f = . Z N 2:, f = . Z N 2:, f = . Z N 2:, f = . Example, Subtract Wfrom = . Example, f = SUBWF 2. Example, f = REG, 0, 0. Example, f = . Example, f = . Before REG W C, Subtract Wfrom = Instruction =. Before REG W C, f = 2.",
    "PIC18F2585/2680/4585/4680\nBefore REG W C, f = . Before REG W C, f = . Before REG W C, f = . After, Subtract Wfrom = = =. After, f = ?. After, f = . After, f = . After, f = . Instruction, Subtract Wfrom = Instruction. Instruction, f = Instruction. Instruction, f = Instruction. Instruction, f = Instruction. Instruction, f = Instruction. REG W, Subtract Wfrom = =. REG W, f = 2. REG W, f = . REG W, f = . REG W, f = . , Subtract Wfrom = = =. , f = 0 1. , f = . , f = . , f = . , Subtract Wfrom = =. , f = 1. , f = result is zero. , f = . , f = . C Z, Subtract Wfrom = . C Z, f = ;. C Z, f = . C Z, f = . C Z, f = . N, Subtract Wfrom = =. N, f = 0.",
    "PIC18F2585/2680/4585/4680\nN, f = . N, f = . N, f = . Example 3: SUBWF REG, 1, 0 Before Instruction, Subtract Wfrom = Example 3: SUBWF REG, 1, 0 Before Instruction. Example 3: SUBWF REG, 1, 0 Before Instruction, f = Example 3: SUBWF REG, 1, 0 Before Instruction. Example 3: SUBWF REG, 1, 0 Before Instruction, f = Example 3: SUBWF REG, 1, 0 Before Instruction. Example 3: SUBWF REG, 1, 0 Before Instruction, f = Example 3: SUBWF REG, 1, 0 Before Instruction. Example 3: SUBWF REG, 1, 0 Before Instruction, f = Example 3: SUBWF REG, 1, 0 Before Instruction. REG, Subtract Wfrom = =. REG, f = 1. REG, f = . REG, f = . REG, f = . W, Subtract Wfrom = . W, f = 2. W, f = . W, f = . W, f = . C, Subtract Wfrom =",
    "PIC18F2585/2680/4585/4680\n= =. C, f = ?. C, f = . C, f = . C, f = . After Instruction, Subtract Wfrom = After Instruction. After Instruction, f = After Instruction. After Instruction, f = After Instruction. After Instruction, f = After Instruction. After Instruction, f = After Instruction. REG, Subtract Wfrom = =. REG, f = FFh. REG, f = ;(2's complement). REG, f = . REG, f = . W C, Subtract Wfrom = = =. W C, f = 2 0. W C, f = ; result is negative. W C, f = . W C, f = . Z N, Subtract Wfrom = =. Z N, f = 0. Z N, f = . Z N, f = . Z N, f = . , Subtract Wfrom = =. , f = 1. , f = . , f = . , f = \nQ Cycle Activity:",
    "PIC18F2585/2680/4585/4680\nSyntax:, Subtract Wfrom f with Borrow = SUBWFB. Syntax:, Subtract Wfrom f with Borrow = f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = . Syntax:, Subtract Wfrom f with Borrow = . Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest.",
    "PIC18F2585/2680/4585/4680\nOperation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Encoding:, Subtract Wfrom f with Borrow = 0101. Encoding:, Subtract Wfrom f with Borrow = 10da. Encoding:, Subtract Wfrom f with Borrow = ffff. Encoding:, Subtract Wfrom f with Borrow = ffff. Description:, Subtract Wfrom f with Borrow = Subtract Wand the Carry flag (borrow) from",
    "PIC18F2585/2680/4585/4680\nregister 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing. Description:, Subtract Wfrom f with Borrow = Subtract Wand the Carry flag (borrow) from register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set",
    "PIC18F2585/2680/4585/4680\nis enabled, this instruction operates in Indexed Literal Offset Addressing. Description:, Subtract Wfrom f with Borrow = Subtract Wand the Carry flag (borrow) from register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing. Description:, Subtract Wfrom f with Borrow = Subtract Wand the Carry flag (borrow) from register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If",
    "PIC18F2585/2680/4585/4680\n'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1",
    "PIC18F2585/2680/4585/4680\nExample 1: SUBWFB,  = Example 1: SUBWFB. Example 1: SUBWFB, Q2 Read register 'f'. = . Example 1: SUBWFB, Q3 Process Data.0 = REG, 1,. Example 1: SUBWFB,  = . Before Instruction,  = Before Instruction. Before Instruction, Q2 Read register 'f'. = . Before Instruction, Q3 Process Data.0 = . Before Instruction,  = . REG,  = =. REG, Q2 Read register 'f'. = 19h. REG, Q3 Process Data.0 = ( 0001 1001. REG,  = . W,  = =. W, Q2 Read register 'f'. = 0Dh. W, Q3 Process Data.0 = ( 0000 1101. W,  = . C,  = =. C, Q2 Read register 'f'. = 1. C, Q3 Process Data.0 = . C,  = . After Instruction,  = After Instruction. After Instruction, Q2 Read register 'f'. = . After Instruction, Q3 Process Data.0 = . After Instruction,  = . REG,",
    "PIC18F2585/2680/4585/4680\n= =. REG, Q2 Read register 'f'. = 0Ch. REG, Q3 Process Data.0 = ( 0000. REG,  = . W,  = =. W, Q2 Read register 'f'. = 0Dh. W, Q3 Process Data.0 = ( 0000. W,  = . C,  = =. C, Q2 Read register 'f'. = 1. C, Q3 Process Data.0 = 1101. C,  = . Z,  = =. Z, Q2 Read register 'f'. = 0. Z, Q3 Process Data.0 = . Z,  = . N,  = =. N, Q2 Read register 'f'. = 0. N, Q3 Process Data.0 = ; result is positive. N,  = ; result is positive. Example 2: SUBWFB,  = Example 2: SUBWFB. Example 2: SUBWFB, Q2 Read register 'f'. = Example 2: SUBWFB. Example 2: SUBWFB, Q3 Process Data.0 = REG, 0,. Example 2: SUBWFB,",
    "PIC18F2585/2680/4585/4680\n= . Before Instruction,  = Before Instruction. Before Instruction, Q2 Read register 'f'. = Before Instruction. Before Instruction, Q3 Process Data.0 = . Before Instruction,  = . REG,  = =. REG, Q2 Read register 'f'. = 1Bh. REG, Q3 Process Data.0 = ( 0001 1011. REG,  = . W,  = =. W, Q2 Read register 'f'. = 1Ah. W, Q3 Process Data.0 = ( 0001. W,  = . C,  = =. C, Q2 Read register 'f'. = 0. C, Q3 Process Data.0 = 1010. C,  = . After Instruction,  = After Instruction. After Instruction, Q2 Read register 'f'. = . After Instruction, Q3 Process Data.0 = . After Instruction,  = . REG,  = =. REG, Q2 Read register 'f'. = 1Bh. REG, Q3 Process Data.0 = ( 0001 1011. REG,  = . W,",
    "PIC18F2585/2680/4585/4680\n= =. W, Q2 Read register 'f'. = 00h. W, Q3 Process Data.0 = . W,  = . C,  = =. C, Q2 Read register 'f'. = 1. C, Q3 Process Data.0 = . C,  = . Z,  = =. Z, Q2 Read register 'f'. = 1. Z, Q3 Process Data.0 = ; result is zero. Z,  = . N,  = =. N, Q2 Read register 'f'. = 0. N, Q3 Process Data.0 = . N,  = . Example 3: SUBWFB,  = Example 3: SUBWFB. Example 3: SUBWFB, Q2 Read register 'f'. = Example 3: SUBWFB. Example 3: SUBWFB, Q3 Process Data.0 = REG, 1,. Example 3: SUBWFB,  = . Before Instruction,  = Before Instruction. Before Instruction, Q2 Read register 'f'. = Before Instruction. Before Instruction, Q3 Process Data.0 = . Before Instruction,  = . REG,",
    "PIC18F2585/2680/4585/4680\n= =. REG, Q2 Read register 'f'. = 03h. REG, Q3 Process Data.0 = ( 0000 0011. REG,  = . W,  = =. W, Q2 Read register 'f'. = 0Eh. W, Q3 Process Data.0 = ( 0000 1101. W,  = . C,  = =. C, Q2 Read register 'f'. = 1. C, Q3 Process Data.0 = . C,  = . After Instruction,  = After Instruction. After Instruction, Q2 Read register 'f'. = After Instruction. After Instruction, Q3 Process Data.0 = . After Instruction,  = . REG,  = =. REG, Q2 Read register 'f'. = F5h. REG, Q3 Process Data.0 = ( 1111 0100 ) ; [2's comp]. REG,  = . W,  = =. W, Q2 Read register 'f'. = 0Eh. W, Q3 Process Data.0 = ( 0000 1101. W,  = . C,",
    "PIC18F2585/2680/4585/4680\n= =. C, Q2 Read register 'f'. = 0. C, Q3 Process Data.0 = ). C,  = . Z,  = =. Z, Q2 Read register 'f'. = 0. Z, Q3 Process Data.0 = . Z,  = . N,  = =. N, Q2 Read register 'f'. = 1. N, Q3 Process Data.0 = ; result is negative. N,  = ; result is negative\nWords:\nCycles:",
    "PIC18F2585/2680/4585/4680\nSyntax:, Swap f = SWAPF. Syntax:, Swap f = f {,d {,a}}. Syntax:, Swap f = f {,d {,a}}. Syntax:, Swap f = f {,d {,a}}. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:,",
    "PIC18F2585/2680/4585/4680\nSwap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Encoding:, Swap f = 0011. Encoding:, Swap f = 10da. Encoding:, Swap f = ffff. Encoding:, Swap f = ffff\nDescription:\nThe upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default).\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default).",
    "PIC18F2585/2680/4585/4680\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed\nLiteral Offset Mode' for details.\n1\n1\nQ Cycle Activity:\nExample:, Q2.Read register 'f' = SWAPF. Example:, Q3.Process Data = REG, 1, 0. Example:, Q4.Write to destination = . Before Instruction REG = After Instruction REG =, Q2.Read register 'f' = 53h. Before Instruction REG = After Instruction REG =, Q3.Process Data = . Before Instruction REG = After Instruction REG =, Q4.Write to destination = ",
    "PIC18F2585/2680/4585/4680\nTBLRD, 1 = TBLRD. TBLRD, 2 = Table Read. TBLRD, 3 = Table Read. TBLRD, 4 = Table Read. TBLRD, 5 = Table Read. Syntax:, 1 = Syntax:. Syntax:, 2 = TBLRD ( *; *+; *-; +*). Syntax:, 3 = TBLRD ( *; *+; *-; +*). Syntax:, 4 = TBLRD ( *; *+; *-; +*). Syntax:, 5 = TBLRD ( *; *+; *-; +*). Operands:, 1 = Operands:. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operands:, 5 = None. Operation:, 1 = Operation:. Operation:, 2 = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT;",
    "PIC18F2585/2680/4585/4680\n(TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*,. Operation:, 3 = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*,. Operation:, 4 = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT;",
    "PIC18F2585/2680/4585/4680\n(TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*,. Operation:, 5 = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*,. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Encoding:, 4 = 0000. Encoding:, 5 = 10nn nn=0 * =1 *+ =2 *-. Description:, 1 = Description:. Description:, 2 = This instruction is used to read the contents of Program Memory",
    "PIC18F2585/2680/4585/4680\n(P.M.). To address the program memory, a pointer, called Table Pointer (TBLPTR), is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 :Least Significant Byte of Program Memory Word TBLPTR[0] = 1 :Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement \u2022 pre-increment. Description:, 3 = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer, called Table Pointer (TBLPTR), is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 :Least Significant Byte of Program Memory Word TBLPTR[0] = 1 :Most Significant Byte of Program Memory Word The TBLRD",
    "PIC18F2585/2680/4585/4680\ninstruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement \u2022 pre-increment. Description:, 4 = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer, called Table Pointer (TBLPTR), is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 :Least Significant Byte of Program Memory Word TBLPTR[0] = 1 :Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement \u2022 pre-increment. Description:, 5 = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer, called Table Pointer (TBLPTR), is used. The TBLPTR (a 21-bit pointer) points to each byte in the program",
    "PIC18F2585/2680/4585/4680\nmemory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 :Least Significant Byte of Program Memory Word TBLPTR[0] = 1 :Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement \u2022 pre-increment. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 2. Cycles:, 3 = 2. Cycles:, 4 = 2. Cycles:, 5 = 2. Q Cycle Activity: Q1 Decode, 1 = . Q Cycle Activity: Q1 Decode, 2 = . Q Cycle Activity: Q1 Decode, 3 = . Q Cycle Activity: Q1 Decode, 4 = . Q Cycle Activity: Q1 Decode, 5 = . , 1 = . , 2 = Q2. , 3 = Q3. , 4 = Q3. , 5 =",
    "PIC18F2585/2680/4585/4680\nQ4. , 1 = . , 2 = No operation. , 3 = No operation. , 4 = No operation. , 5 = No operation. , 1 = No operation. , 2 = No operation (Read Program Memory). , 3 = No operation. , 4 = No operation. , 5 = No operation (Write TABLAT)",
    "Table Read (Continued)\nExample 1:, 1 = TBLRD. Example 1:, 2 = ;. Example 1:, 3 = . Before Instruction TABLAT, 1 = Before Instruction TABLAT. Before Instruction TABLAT, 2 = =. Before Instruction TABLAT, 3 = 55h. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 00A356h. MEMORY(00A356h), 1 = MEMORY(00A356h). MEMORY(00A356h), 2 = =. MEMORY(00A356h), 3 = 34h. After Instruction TABLAT, 1 = After Instruction TABLAT. After Instruction TABLAT, 2 = =. After Instruction TABLAT, 3 = 34h. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 00A357h. Example 2:, 1 = TBLRD +*. Example 2:, 2 = ;. Example 2:, 3 = . Before Instruction TABLAT, 1 = Before Instruction TABLAT. Before Instruction TABLAT, 2 = =. Before Instruction TABLAT, 3 =",
    "Table Read (Continued)\n0AAh. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 01A357h. MEMORY(01A357h), 1 = MEMORY(01A357h). MEMORY(01A357h), 2 = =. MEMORY(01A357h), 3 = 12h. MEMORY(01A358h), 1 = MEMORY(01A358h). MEMORY(01A358h), 2 = =. MEMORY(01A358h), 3 = 34h. After Instruction TABLAT, 1 = After Instruction TABLAT. After Instruction TABLAT, 2 = =. After Instruction TABLAT, 3 = 34h. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 01A358h\nTBLWT\nSyntax:\nOperands:\nOperation:\nStatus Affected: Encoding:\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nTable Write\nTBLWT ( *; *+; *-; +*)\nNone if TBLWT*,\n(TABLAT)\n\uf0ae\nHolding Register;\nTBLPTR - No Change;",
    "Table Read (Continued)\nif TBLWT*+,\n(TABLAT)\n\uf0ae\nHolding Register;\n(TBLPTR) + 1\n\uf0ae\nTBLPTR;\nif TBLWT*-,\n(TABLAT)\n\uf0ae\nHolding Register;\n(TBLPTR) - 1\n\uf0ae\nTBLPTR;\nif TBLWT+*,\n(TBLPTR) + 1\n\uf0ae\nTBLPTR;\n(TABLAT)\n\uf0ae\nHolding Register;\nNone\n0000\n0000\n0000",
    "PIC18F2585/2680/4585/4680\n11nn nn=0 *\n=1 *+\n=2 *-\n=3 +*\nThis instruction uses the 3 LSBs of the\nTBLPTR to determine which of the 8 holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to Section 5.0 'Flash Program Memory' for additional details on programming Flash memory.)",
    "PIC18F2585/2680/4585/4680\nExample 1:, Table Write = TBLWT *+;. Example 1:, (Continued) = TBLWT *+;. Example 1:, (Continued) = TBLWT *+;. Before Instruction, Table Write = Before Instruction. Before Instruction, (Continued) = Before Instruction. Before Instruction, (Continued) = Before Instruction. TABLAT, Table Write = TABLAT. TABLAT, (Continued) = =. TABLAT, (Continued) = 55h. TBLPTR, Table Write = TBLPTR. TBLPTR, (Continued) = =. TBLPTR, (Continued) = 00A356h. HOLDING REGISTER (00A356h), Table Write = HOLDING REGISTER (00A356h). HOLDING REGISTER (00A356h), (Continued) = =. HOLDING REGISTER (00A356h), (Continued) = FFh. After Instructions (table write completion), Table Write = After Instructions (table write completion). After Instructions (table write completion), (Continued) = After Instructions (table write completion). After Instructions (table write completion), (Continued)",
    "PIC18F2585/2680/4585/4680\n= After Instructions (table write completion). TABLAT, Table Write = TABLAT. TABLAT, (Continued) = =. TABLAT, (Continued) = 55h. TBLPTR, Table Write = TBLPTR. TBLPTR, (Continued) = =. TBLPTR, (Continued) = 00A357h. HOLDING REGISTER (00A356h), Table Write = HOLDING REGISTER (00A356h). HOLDING REGISTER (00A356h), (Continued) = =. HOLDING REGISTER (00A356h), (Continued) = 55h. Example 2:, Table Write = TBLWT +*;. Example 2:, (Continued) = TBLWT +*;. Example 2:, (Continued) = TBLWT +*;. Before Instruction, Table Write = Before Instruction. Before Instruction, (Continued) = Before Instruction. Before Instruction, (Continued) = Before Instruction. TABLAT, Table Write = TABLAT. TABLAT, (Continued) = =. TABLAT, (Continued) = 34h. TBLPTR, Table Write = TBLPTR.",
    "PIC18F2585/2680/4585/4680\nTBLPTR, (Continued) = =. TBLPTR, (Continued) = 01389Ah. HOLDING REGISTER (01389Ah), Table Write = HOLDING REGISTER (01389Ah). HOLDING REGISTER (01389Ah), (Continued) = =. HOLDING REGISTER (01389Ah), (Continued) = FFh. HOLDING REGISTER (01389Bh), Table Write = HOLDING REGISTER (01389Bh). HOLDING REGISTER (01389Bh), (Continued) = =. HOLDING REGISTER (01389Bh), (Continued) = FFh. After Instruction (table write completion), Table Write = After Instruction (table write completion). After Instruction (table write completion), (Continued) = After Instruction (table write completion). After Instruction (table write completion), (Continued) = After Instruction (table write completion). TABLAT, Table Write = TABLAT. TABLAT, (Continued) = =. TABLAT, (Continued) = 34h. TBLPTR, Table Write = TBLPTR. TBLPTR, (Continued) = =. TBLPTR, (Continued)",
    "PIC18F2585/2680/4585/4680\n= 01389Bh. HOLDING REGISTER (01389Ah), Table Write = HOLDING REGISTER (01389Ah). HOLDING REGISTER (01389Ah), (Continued) = =. HOLDING REGISTER (01389Ah), (Continued) = FFh. HOLDING REGISTER (01389Bh), Table Write = HOLDING REGISTER (01389Bh). HOLDING REGISTER (01389Bh), (Continued) = =. HOLDING REGISTER (01389Bh), (Continued) = 34h\nThe TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MBtye address range. The LSb of the TBLPTR selects which byte of the program memory location to access.\nTBLPTR[0] = :Least Significant Byte of\n0 Program Memory Word TBLPTR[0] = 1 :Most Significant Byte of Program Memory Word\nThe TBLWT instruction can modify the value of TBLPTR as follows:\n\u00b7 no change\n\u00b7 post-increment\n\u00b7 post-decrement\n\u00b7 pre-increment\n1\n2\nQ1\nQ2\nQ3\nQ4",
    "PIC18F2585/2680/4585/4680\nDecode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation. No operation, 1 = No operation (Read TABLAT). No operation, 2 = No operation. No operation, 3 = No operation (Write to Holding Register )",
    "PIC18F2585/2680/4585/4680\nSyntax:, Test f, Skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, Skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, Skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, Skip if 0 = TSTFSZ f {,a}. Operands:, Test f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = skip if f = 0. Status Affected:, Test f, Skip if 0 = None. Status Affected:, Test",
    "PIC18F2585/2680/4585/4680\nf, Skip if 0 = None. Status Affected:, Test f, Skip if 0 = None. Status Affected:, Test f, Skip if 0 = None. Encoding:, Test f, Skip if 0 = 0110. Encoding:, Test f, Skip if 0 = 011a. Encoding:, Test f, Skip if 0 = ffff. Encoding:, Test f, Skip if 0 = ffff. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction fetched during the current",
    "PIC18F2585/2680/4585/4680\ninstruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and. Description:, Test f, Skip",
    "PIC18F2585/2680/4585/4680\nif 0 = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See Section 25.2.3 'Byte-Oriented and. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = 1. Cycles:, Test f, Skip if 0 = 1(2). Cycles:, Test f, Skip if 0 = 1(2). Cycles:, Test f, Skip if 0 = 1(2). Cycles:, Test f, Skip if 0 = 1(2)",
    "PIC18F2585/2680/4585/4680\nSyntax:, Exclusive OR Literal with W = XORLW k. Syntax:, Exclusive OR Literal with W = XORLW k. Syntax:, Exclusive OR Literal with W = XORLW k. Operands:, Exclusive OR Literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR Literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR Literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operation:, Exclusive OR Literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR Literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR Literal with W = (W) .XOR. k \uf0ae\uf020 W. Status Affected:, Exclusive OR Literal with W = N, Z. Status Affected:, Exclusive OR Literal with W = N, Z. Status Affected:, Exclusive OR Literal with W = N, Z. Encoding:, Exclusive OR Literal with W = 0000. Encoding:, Exclusive OR Literal with W = 1010. Encoding:, Exclusive OR Literal with W = kkkk kkkk. Description:, Exclusive OR Literal with W = The contents of Ware XORed with",
    "PIC18F2585/2680/4585/4680\nthe 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Words:, Exclusive OR Literal with W = 1. Words:, Exclusive OR Literal with W = 1. Words:, Exclusive OR Literal with W = 1. Cycles:, Exclusive OR Literal with W = 1. Cycles:, Exclusive OR Literal with W = 1. Cycles:, Exclusive OR Literal with W = 1. Q Cycle Activity:, Exclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Exclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Exclusive OR Literal with W = Q Cycle Activity:. Q1, Exclusive OR Literal with W = Q2. Q1, Exclusive OR Literal with W = Q3. Q1, Exclusive OR Literal with W = Q4. Decode, Exclusive OR Literal with W =",
    "PIC18F2585/2680/4585/4680\nRead literal 'k'. Decode, Exclusive OR Literal with W = Process Data. Decode, Exclusive OR Literal with W = Write to W. Example:, Exclusive OR Literal with W = XORLW. Example:, Exclusive OR Literal with W = 0AFh. Example:, Exclusive OR Literal with W = . Before Instruction W =, Exclusive OR Literal with W = B5h. Before Instruction W =, Exclusive OR Literal with W = . Before Instruction W =, Exclusive OR Literal with W = . After Instruction W =, Exclusive OR Literal with W = 1Ah. After Instruction W =, Exclusive OR Literal with W = . After Instruction W =, Exclusive OR Literal with W = \nNote:\n3 cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:",
    "PIC18F2585/2680/4585/4680\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. skip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No",
    "PIC18F2585/2680/4585/4680\noperation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE    TSTFSZ  CNT, 1\nNZERO   :\nZERO    :\nBefore Instruction\nPC\n=\nAddress ( HERE )\nAfter Instruction\nIf CNT\n=\n00h,\nPC\n=\nAddress\n(ZERO)\nIf CNT\n\uf0b9\n00h,\nPC\n=\nAddress (NZERO)",
    "PIC18F2585/2680/4585/4680\nSyntax:, Exclusive OR Wwith f = XORWF. Syntax:, Exclusive OR Wwith f = f {,d {,a}}. Syntax:, Exclusive OR Wwith f = f {,d {,a}}. Syntax:, Exclusive OR Wwith f = f {,d {,a}}. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest.",
    "PIC18F2585/2680/4585/4680\nOperation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Encoding:, Exclusive OR Wwith f = 0001. Encoding:, Exclusive OR Wwith f = 10da. Encoding:, Exclusive OR Wwith f = ffff. Encoding:, Exclusive OR Wwith f = ffff. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled,",
    "PIC18F2585/2680/4585/4680\nthis instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the",
    "PIC18F2585/2680/4585/4680\nBSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank (default). If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \uf0a3\uf020 95 (5Fh). See. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1.",
    "PIC18F2585/2680/4585/4680\nCycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Q Cycle Activity: Q1, Exclusive OR Wwith f = Q2. Q Cycle Activity: Q1, Exclusive OR Wwith f = Q3. Q Cycle Activity: Q1, Exclusive OR Wwith f = Q3. Q Cycle Activity: Q1, Exclusive OR Wwith f = Q4. Decode, Exclusive OR Wwith f = Read register 'f'. Decode, Exclusive OR Wwith f = Process Data. Decode, Exclusive OR Wwith f = Process Data. Decode, Exclusive OR Wwith f = Write to destination. Example:, Exclusive OR Wwith f = XORWF. Example:, Exclusive OR Wwith f = REG, 1,. Example:, Exclusive OR Wwith f = 0. Example:, Exclusive OR Wwith f = . Before Instruction REG = W = Instruction, Exclusive OR Wwith f = AFh B5h. Before Instruction REG = W = Instruction, Exclusive OR Wwith f = . Before Instruction REG = W = Instruction, Exclusive",
    "PIC18F2585/2680/4585/4680\nOR Wwith f = . Before Instruction REG = W = Instruction, Exclusive OR Wwith f = . After REG W, Exclusive OR Wwith f = 1Ah B5h. After REG W, Exclusive OR Wwith f = . After REG W, Exclusive OR Wwith f = . After REG W, Exclusive OR Wwith f = ",
    "25.2 Extended Instruction Set\nIn addition to the standard 75 instructions of the PIC18 instruction  set,  PIC18F2585/2680/4585/4680  devices also  provide  an  optional  extension  to  the  core  CPU functionality. The added features include eight additional instructions that augment indirect and indexed addressing operations and the implementation of Indexed Literal Offset Addressing mode for many of the standard PIC18 instructions.\nThe  additional  features  are  disabled  by  default.  To enable them, users must set the XINST Configuration bit.\nThe  instructions in the extended  set can  all be classified as literal operations, which either manipulate the  File  Select  Registers  or  use  them  for  indexed addressing.  Two  of  the  instructions, ADDFSR and SUBFSR , each have an additional special instantiation for using FSR2. These versions ( ADDULNK and SUBULNK ) allow for automatic return after execution.\nThe extended instructions are specifically implemented to optimize re-entrant program code (that is, code that is  recursive  or  that  uses  a  software  stack)  written  in high-level languages,  particularly C. Among  other things, they allow users working in high-level languages  to perform  certain operations on  data structures more efficiently. These include:",
    "25.2 Extended Instruction Set\n\u00b7 dynamic allocation and de-allocation of software stack space when entering and leaving subroutines\n\u00b7 function pointer invocation\n\u00b7 software stack pointer manipulation\nA summary of the instructions in the extended instruction set is provided in Table 25-3. Detailed descriptions are provided in Section 25.2.2 'Extended Instruction Set' . The opcode field descriptions in Table 25-1 apply to  both  the  standard and extended PIC18 instruction sets.\nNote:\nThe  instruction set extension  and  the Indexed  Literal  Offset  Addressing  mode were designed for optimizing applications written in C; the user may likely never use these  instructions  directly  in  assembler. The  syntax  for  these  commands  is  provided as a reference for users who may be reviewing code that has been generated by a compiler.",
    "25.2.1 EXTENDED INSTRUCTION SYNTAX\nMost of the extended instructions use indexed arguments, using one of the File Select Registers and some offset to specify a source or destination register. When an argument for an instruction serves as part of indexed addressing, it is enclosed in square brackets ('[ ]'). This is done to indicate that the argument is used as an index or offset. MPASM\u2122 Assembler will flag an error if it determines that an index or offset value is not bracketed.\nWhen the extended instruction set is enabled, brackets are  also  used  to  indicate  index  arguments  in  bitoriented  and  byte-oriented  instructions.  This  is  in addition  to  other  changes  in  their  syntax.  For  more details, see Section 25.2.3.1 'Extended Instruction Syntax with Standard PIC18 Commands' .\n- \u00b7 manipulation of variables located in a software stack\nNote:\nIn  the  past,  square  brackets  have  been used to denote optional arguments in the PIC18 and earlier  instruction  sets.  In  this text and going forward, optional arguments are denoted by braces ('{ }').",
    "TABLE 25-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\nADDFSR, Mnemonic,.Operands = f, k. ADDFSR, Description. = Add literal to FSR. ADDFSR, Cycles. = 1. ADDFSR, 16-Bit Instruction Word.MSb = 1110. ADDFSR, 16-Bit Instruction Word.MSb = 1000. ADDFSR, 16-Bit Instruction Word.LSb = ffkk. ADDFSR, 16-Bit Instruction Word. = kkkk. ADDFSR, Status Affected. = None. ADDULNK, Mnemonic,.Operands = k. ADDULNK, Description. = Add literal to FSR2 and return. ADDULNK, Cycles. = 2. ADDULNK, 16-Bit Instruction Word.MSb = 1110. ADDULNK, 16-Bit Instruction Word.MSb = 1000. ADDULNK, 16-Bit Instruction Word.LSb = 11kk. ADDULNK, 16-Bit Instruction Word. = kkkk. ADDULNK, Status Affected. = None. CALLW, Mnemonic,.Operands = . CALLW, Description. = Call subroutine using",
    "TABLE 25-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\nWREG. CALLW, Cycles. = 2. CALLW, 16-Bit Instruction Word.MSb = 0000. CALLW, 16-Bit Instruction Word.MSb = 0000. CALLW, 16-Bit Instruction Word.LSb = 0001. CALLW, 16-Bit Instruction Word. = 0100. CALLW, Status Affected. = None. MOVSF, Mnemonic,.Operands = z s , f d. MOVSF, Description. = Move z s (source) to 1st word f d (destination) 2nd word. MOVSF, Cycles. = 2. MOVSF, 16-Bit Instruction Word.MSb = 1110. MOVSF, 16-Bit Instruction Word.MSb = 1011. MOVSF, 16-Bit Instruction Word.LSb = 0zzz. MOVSF, 16-Bit Instruction Word. = zzzz. MOVSF, Status Affected. = None. MOVSS, Mnemonic,.Operands = z s , z d. MOVSS, Description. = Move z s (source) to 1st word z d (destination) 2nd",
    "TABLE 25-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\nword. MOVSS, Cycles. = 2. MOVSS, 16-Bit Instruction Word.MSb = 1110. MOVSS, 16-Bit Instruction Word.MSb = 1011. MOVSS, 16-Bit Instruction Word.LSb = 1zzz. MOVSS, 16-Bit Instruction Word. = zzzz. MOVSS, Status Affected. = None. PUSHL, Mnemonic,.Operands = k. PUSHL, Description. = Store literal at FSR2, decrement FSR2. PUSHL, Cycles. = 1. PUSHL, 16-Bit Instruction Word.MSb = 1111 1110. PUSHL, 16-Bit Instruction Word.MSb = xxxx 1010. PUSHL, 16-Bit Instruction Word.LSb = xzzz kkkk. PUSHL, 16-Bit Instruction Word. = zzzz kkkk. PUSHL, Status Affected. = None. SUBFSR, Mnemonic,.Operands = f, k. SUBFSR, Description. = Subtract literal from FSR. SUBFSR, Cycles. =",
    "TABLE 25-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\n1. SUBFSR, 16-Bit Instruction Word.MSb = 1110. SUBFSR, 16-Bit Instruction Word.MSb = 1001. SUBFSR, 16-Bit Instruction Word.LSb = ffkk. SUBFSR, 16-Bit Instruction Word. = kkkk. SUBFSR, Status Affected. = None. SUBULNK, Mnemonic,.Operands = k. SUBULNK, Description. = Subtract literal from FSR2 and return. SUBULNK, Cycles. = 2. SUBULNK, 16-Bit Instruction Word.MSb = 1110. SUBULNK, 16-Bit Instruction Word.MSb = 1001. SUBULNK, 16-Bit Instruction Word.LSb = 11kk. SUBULNK, 16-Bit Instruction Word. = kkkk. SUBULNK, Status Affected. = None",
    "25.2.2 EXTENDED INSTRUCTION SET\nSyntax:, Add Literal to FSR = ADDFSR f, k. Syntax:, Add Literal to FSR = ADDFSR f, k. Syntax:, Add Literal to FSR = ADDFSR f, k. Syntax:, Add Literal to FSR = ADDFSR f, k. Operands:, Add Literal to FSR = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operands:, Add Literal to FSR = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operands:, Add Literal to FSR = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operands:, Add Literal to FSR = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operation:, Add Literal to FSR = FSR(f) + k \uf0ae FSR(f). Operation:, Add Literal to FSR = FSR(f) + k \uf0ae FSR(f). Operation:, Add Literal to FSR = FSR(f) + k \uf0ae FSR(f). Operation:, Add Literal to FSR = FSR(f) + k \uf0ae FSR(f). Status Affected:, Add Literal to",
    "25.2.2 EXTENDED INSTRUCTION SET\nFSR = None. Status Affected:, Add Literal to FSR = None. Status Affected:, Add Literal to FSR = None. Status Affected:, Add Literal to FSR = None. Encoding:, Add Literal to FSR = 1110. Encoding:, Add Literal to FSR = 1000. Encoding:, Add Literal to FSR = ffkk. Encoding:, Add Literal to FSR = kkkk. Description:, Add Literal to FSR = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Description:, Add Literal to FSR = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Description:, Add Literal to FSR = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Description:, Add Literal to FSR = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Words:, Add Literal to FSR = 1. Words:, Add Literal to FSR = 1. Words:, Add Literal",
    "25.2.2 EXTENDED INSTRUCTION SET\nto FSR = 1. Words:, Add Literal to FSR = 1. Cycles:, Add Literal to FSR = 1. Cycles:, Add Literal to FSR = 1. Cycles:, Add Literal to FSR = 1. Cycles:, Add Literal to FSR = 1. Q Cycle Activity: Q1, Add Literal to FSR = Q2. Q Cycle Activity: Q1, Add Literal to FSR = Q3. Q Cycle Activity: Q1, Add Literal to FSR = . Q Cycle Activity: Q1, Add Literal to FSR = Q4. Decode, Add Literal to FSR = Read literal 'k'. Decode, Add Literal to FSR = Process Data. Decode, Add Literal to FSR = . Decode, Add Literal to FSR = Write to FSR\nExample:\nADDFSR 2, 23h\nBefore Instruction\nFSR2\n=\n03FFh\nAfter Instruction\nFSR2\n=\n0422h",
    "25.2.2 EXTENDED INSTRUCTION SET\nSyntax:, Add Literal to FSR2 and Return = ADDULNK k. Syntax:, Add Literal to FSR2 and Return = ADDULNK k. Syntax:, Add Literal to FSR2 and Return = ADDULNK k. Syntax:, Add Literal to FSR2 and Return = ADDULNK k. Operands:, Add Literal to FSR2 and Return = 0 \uf0a3 k \uf0a3 63. Operands:, Add Literal to FSR2 and Return = 0 \uf0a3 k \uf0a3 63. Operands:, Add Literal to FSR2 and Return = 0 \uf0a3 k \uf0a3 63. Operands:, Add Literal to FSR2 and Return = 0 \uf0a3 k \uf0a3 63. Operation:, Add Literal to FSR2 and Return = FSR2 + k \uf0ae FSR2, PC = (TOS). Operation:, Add Literal to FSR2 and Return = FSR2 + k \uf0ae FSR2, PC = (TOS). Operation:, Add Literal to FSR2 and Return = FSR2 + k \uf0ae FSR2, PC = (TOS). Operation:, Add Literal to FSR2 and Return = FSR2 + k \uf0ae FSR2, PC = (TOS).",
    "25.2.2 EXTENDED INSTRUCTION SET\nStatus Affected:, Add Literal to FSR2 and Return = None. Status Affected:, Add Literal to FSR2 and Return = None. Status Affected:, Add Literal to FSR2 and Return = None. Status Affected:, Add Literal to FSR2 and Return = None. Encoding:, Add Literal to FSR2 and Return = 1110. Encoding:, Add Literal to FSR2 and Return = 1000. Encoding:, Add Literal to FSR2 and Return = 11kk. Encoding:, Add Literal to FSR2 and Return = kkkk. Description:, Add Literal to FSR2 and Return = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS.. Description:, Add Literal to FSR2 and Return = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS.. Description:, Add Literal to FSR2 and Return = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the",
    "25.2.2 EXTENDED INSTRUCTION SET\nPC with the TOS.. Description:, Add Literal to FSR2 and Return = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS.. , Add Literal to FSR2 and Return = The instruction takes two cycles to execute; a NOP is performed during the second cycle.. , Add Literal to FSR2 and Return = The instruction takes two cycles to execute; a NOP is performed during the second cycle.. , Add Literal to FSR2 and Return = The instruction takes two cycles to execute; a NOP is performed during the second cycle.. , Add Literal to FSR2 and Return = The instruction takes two cycles to execute; a NOP is performed during the second cycle.. , Add Literal to FSR2 and Return = This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary ' 11 '); it operates only on FSR2.. , Add Literal to FSR2 and Return = This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary ' 11",
    "25.2.2 EXTENDED INSTRUCTION SET\n'); it operates only on FSR2.. , Add Literal to FSR2 and Return = This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary ' 11 '); it operates only on FSR2.. , Add Literal to FSR2 and Return = This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary ' 11 '); it operates only on FSR2.. Words:, Add Literal to FSR2 and Return = 1. Words:, Add Literal to FSR2 and Return = . Words:, Add Literal to FSR2 and Return = . Words:, Add Literal to FSR2 and Return = . Cycles:, Add Literal to FSR2 and Return = 2. Cycles:, Add Literal to FSR2 and Return = . Cycles:, Add Literal to FSR2 and Return = . Cycles:, Add Literal to FSR2 and Return = ",
    "Q Cycle Activity:\nDecode, Q2 = Read literal 'k'. Decode, Q3 = Process Data. Decode, Q4 = Write to FSR. No Operation, Q2 = No Operation. No Operation, Q3 = No Operation. No Operation, Q4 = No Operation\nExample:\nADDULNK 23h\nBefore Instruction\nFSR2\n= 03FFh\nPC\n=\n0100h\nTOS\n= 02AFh\nAfter Instruction\nFSR2 =\n0422h\nPC\n=\n02AFh\nTOS\n=\nTOS - 1\nNote:\nAll PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction syntax then becomes: {label} instruction argument(s).",
    "PIC18F2585/2680/4585/4680\nSyntax:, Subroutine Call Using WREG = CALLW. Syntax:, Subroutine Call Using WREG = CALLW. Syntax:, Subroutine Call Using WREG = CALLW. Syntax:, Subroutine Call Using WREG = CALLW. Operands:, Subroutine Call Using WREG = None. Operands:, Subroutine Call Using WREG = None. Operands:, Subroutine Call Using WREG = None. Operands:, Subroutine Call Using WREG = None. Operation:, Subroutine Call Using WREG = (PC + 2) \uf0ae TOS, (W) \uf0ae PCL, (PCLATH) \uf0ae PCH, (PCLATU) \uf0ae PCU. Operation:, Subroutine Call Using WREG = (PC + 2) \uf0ae TOS, (W) \uf0ae PCL, (PCLATH) \uf0ae PCH, (PCLATU) \uf0ae PCU. Operation:, Subroutine Call Using WREG = (PC + 2) \uf0ae TOS, (W) \uf0ae PCL, (PCLATH) \uf0ae PCH, (PCLATU) \uf0ae PCU. Operation:, Subroutine Call",
    "PIC18F2585/2680/4585/4680\nUsing WREG = (PC + 2) \uf0ae TOS, (W) \uf0ae PCL, (PCLATH) \uf0ae PCH, (PCLATU) \uf0ae PCU. Status Affected:, Subroutine Call Using WREG = None. Status Affected:, Subroutine Call Using WREG = None. Status Affected:, Subroutine Call Using WREG = None. Status Affected:, Subroutine Call Using WREG = None. Encoding:, Subroutine Call Using WREG = 0000. Encoding:, Subroutine Call Using WREG = 0000. Encoding:, Subroutine Call Using WREG = 0001. Encoding:, Subroutine Call Using WREG = 0100. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL , there is no option to update",
    "PIC18F2585/2680/4585/4680\nW, STATUS or BSR.. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL , there is no option to update W, STATUS or BSR.. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL , there is no option to update W, STATUS or BSR.. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return",
    "PIC18F2585/2680/4585/4680\nstack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL , there is no option to update W, STATUS or BSR.. Words:, Subroutine Call Using WREG = 1. Words:, Subroutine Call Using WREG = 1. Words:, Subroutine Call Using WREG = 1. Words:, Subroutine Call Using WREG = 1. Cycles:, Subroutine Call Using WREG = 2. Cycles:, Subroutine Call Using WREG = 2. Cycles:, Subroutine Call Using WREG = 2. Cycles:, Subroutine Call Using WREG = 2. Q Cycle Activity: Q1, Subroutine Call Using WREG = Q2. Q Cycle Activity: Q1, Subroutine Call Using WREG = Q3. Q Cycle Activity: Q1, Subroutine Call Using WREG = Q3. Q Cycle Activity:",
    "PIC18F2585/2680/4585/4680\nQ1, Subroutine Call Using WREG = Q4. Decode, Subroutine Call Using WREG = Read WREG. Decode, Subroutine Call Using WREG = Push PC to stack. Decode, Subroutine Call Using WREG = Push PC to stack. Decode, Subroutine Call Using WREG = No operation. No operation, Subroutine Call Using WREG = No operation. No operation, Subroutine Call Using WREG = No operation. No operation, Subroutine Call Using WREG = No operation. No operation, Subroutine Call Using WREG = No operation",
    "Example:\nHERE\nCALLW\nBefore Instruction\nPC\n=\naddress (HERE)\nPCLATH =\n10h\nPCLATU =\n00h\nW\n=\n06h\nAfter Instruction\nPC\n=\n001006h\nTOS\n=\naddress (HERE + 2)\nPCLATH =\n10h\nPCLATU =\n00h\nW\n=\n06h",
    "Example:\nSyntax:, Move Indexed to f = MOVSF [z s ], f d. Syntax:, Move Indexed to f = MOVSF [z s ], f d. Syntax:, Move Indexed to f = MOVSF [z s ], f d. Syntax:, Move Indexed to f = MOVSF [z s ], f d. Operands:, Move Indexed to f = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 f d \uf0a3 4095. Operands:, Move Indexed to f = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 f d \uf0a3 4095. Operands:, Move Indexed to f = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 f d \uf0a3 4095. Operands:, Move Indexed to f = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 f d \uf0a3 4095. Operation:, Move Indexed to f = ((FSR2) + z s ) \uf0ae f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \uf0ae f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \uf0ae f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \uf0ae f d. Status Affected:, Move Indexed to f = None. Status",
    "Example:\nAffected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Encoding:, Move Indexed to f = . Encoding:, Move Indexed to f = . Encoding:, Move Indexed to f = . Encoding:, Move Indexed to f = . 1st word (source), Move Indexed to f = 1110. 1st word (source), Move Indexed to f = 1011. 1st word (source), Move Indexed to f = 0zzz. 1st word (source), Move Indexed to f = zzzz s. 2nd word (destin.), Move Indexed to f = 1111. 2nd word (destin.), Move Indexed to f = ffff. 2nd word (destin.), Move Indexed to f = ffff. 2nd word (destin.), Move Indexed to f = ffff d\nDescription:",
    "Example:\nThe contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space (000h to FFFh).\nThe MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.\nIf the resultant source address points to an indirect addressing register, the value returned will be 00h.\nWords:\n2\nCycles:\n2\nQ Cycle Activity:\nDecode, Q2 = Determine source addr. Decode, Q3 = Determine source addr. Decode, Q4 = Read source reg. Decode, Q2 = No operation No dummy read. Decode, Q3 = No operation. Decode, Q4 = Write register 'f' (dest)\nMOVSF   [05h], REG2\nBefore Instruction\nFSR2\n=\n80h\nContents\nof 85h\n= 33h\nREG2\n= 11h\nAfter Instruction\nFSR2",
    "Example:\n= 80h\nContents\nof 85h\n= 33h\nREG2\n=\n33h\nDescription",
    "PIC18F2585/2680/4585/4680\nSyntax:, Move Indexed to Indexed = MOVSS [z s ], [z d ]. Syntax:, Move Indexed to Indexed = MOVSS [z s ], [z d ]. Syntax:, Move Indexed to Indexed = MOVSS [z s ], [z d ]. Syntax:, Move Indexed to Indexed = MOVSS [z s ], [z d ]. Operands:, Move Indexed to Indexed = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 z d \uf0a3 127. Operands:, Move Indexed to Indexed = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 z d \uf0a3 127. Operands:, Move Indexed to Indexed = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 z d \uf0a3 127. Operands:, Move Indexed to Indexed = 0 \uf0a3 z s \uf0a3 127 0 \uf0a3 z d \uf0a3 127. Operation:, Move Indexed to Indexed = ((FSR2) + z s ) \uf0ae ((FSR2) + z d ). Operation:, Move Indexed to Indexed = ((FSR2) + z s ) \uf0ae ((FSR2) + z d ). Operation:, Move Indexed to Indexed = ((FSR2) + z s ) \uf0ae ((FSR2) + z d",
    "PIC18F2585/2680/4585/4680\n). Operation:, Move Indexed to Indexed = ((FSR2) + z s ) \uf0ae ((FSR2) + z d ). Status Affected:, Move Indexed to Indexed = None. Status Affected:, Move Indexed to Indexed = None. Status Affected:, Move Indexed to Indexed = None. Status Affected:, Move Indexed to Indexed = None. Encoding:, Move Indexed to Indexed = . Encoding:, Move Indexed to Indexed = . Encoding:, Move Indexed to Indexed = . Encoding:, Move Indexed to Indexed = . 1st word (source), Move Indexed to Indexed = 1110. 1st word (source), Move Indexed to Indexed = 1011. 1st word (source), Move Indexed to Indexed = 1zzz. 1st word (source), Move Indexed to Indexed = zzzz s. 2nd word (dest.), Move Indexed to Indexed = 1111. 2nd word (dest.), Move Indexed to Indexed = xxxx. 2nd word (dest.), Move Indexed to Indexed = xzzz. 2nd word (dest.), Move Indexed to Indexed = zzzz d",
    "PIC18F2585/2680/4585/4680\nmoved to the destination register. The registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh).\nThe contents of the source register are addresses of the source and destination\nThe MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.\nIf the resultant source address points to an indirect addressing register, the value returned will be 00h. If the resultant destination address points to an indirect addressing register, the instruction will execute as a NOP .\n2\n2",
    "PIC18F2585/2680/4585/4680\nSyntax:, Store Literal at FSR2, Decrement FSR2 = PUSHL k. Syntax:, Store Literal at FSR2, Decrement FSR2 = . Syntax:, Store Literal at FSR2, Decrement FSR2 = . Syntax:, Store Literal at FSR2, Decrement FSR2 = . Operands:, Store Literal at FSR2, Decrement FSR2 = 0 \uf020\uf0a3\uf020 k \uf0a3 255. Operands:, Store Literal at FSR2, Decrement FSR2 = . Operands:, Store Literal at FSR2, Decrement FSR2 = . Operands:, Store Literal at FSR2, Decrement FSR2 = . Operation:, Store Literal at FSR2, Decrement FSR2 = k \uf0ae (FSR2), FSR2 - 1 \uf0ae FSR2. Operation:, Store Literal at FSR2, Decrement FSR2 = . Operation:, Store Literal at FSR2, Decrement FSR2 = . Operation:, Store Literal at FSR2, Decrement FSR2 = . Status",
    "PIC18F2585/2680/4585/4680\nAffected:, Store Literal at FSR2, Decrement FSR2 = None. Status Affected:, Store Literal at FSR2, Decrement FSR2 = . Status Affected:, Store Literal at FSR2, Decrement FSR2 = . Status Affected:, Store Literal at FSR2, Decrement FSR2 = . Encoding:, Store Literal at FSR2, Decrement FSR2 = 1111. Encoding:, Store Literal at FSR2, Decrement FSR2 = 1010. Encoding:, Store Literal at FSR2, Decrement FSR2 = kkkk. Encoding:, Store Literal at FSR2, Decrement FSR2 = kkkk\nDescription:\nThe 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation.\nThis instruction allows users to push values onto a software stack.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:",
    "PIC18F2585/2680/4585/4680\nDecode, Q2 = Read 'k'. Decode, Q3 = Process data. Decode, Q4 = Write to destination\nBefore Instruction, PUSHL 08h = . Before Instruction,  = . FSR2H:FSR2L, PUSHL 08h = =. FSR2H:FSR2L,  = 01ECh. Memory (01ECh), PUSHL 08h = =. Memory (01ECh),  = 00h. After Instruction, PUSHL 08h = . After Instruction,  = . FSR2H:FSR2L, PUSHL 08h = =. FSR2H:FSR2L,  = 01EBh. Memory (01ECh), PUSHL 08h = =. Memory (01ECh),  = 08h\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nQ2\nQ3\nDecode, 1 = Determine source addr. Decode, 2 = Determine source addr. Decode, 3 = Read source reg. Decode, 1 = Determine dest addr. Decode, 2 = Determine dest addr. Decode, 3 = Write to dest reg",
    "Example:\nMOVSS  [05h], [06h]\nBefore Instruction\nFSR2\n=\n80h\nContents\nof 85h\n= 33h\nContents\nof 86h\n= 11h\nAfter Instruction\nFSR2\n=\n80h\nContents\nof 85h\n= 33h\nContents\nof 86h\n=\n33h\nQ4",
    "PIC18F2585/2680/4585/4680\nSyntax:, Subtract Literal from FSR = SUBFSR f, k. Syntax:, Subtract Literal from FSR = SUBFSR f, k. Syntax:, Subtract Literal from FSR = SUBFSR f, k. Syntax:, Subtract Literal from FSR = SUBFSR f, k. Operands:, Subtract Literal from FSR = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operands:, Subtract Literal from FSR = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operands:, Subtract Literal from FSR = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operands:, Subtract Literal from FSR = 0 \uf0a3 k \uf0a3 63 f \uf0ce [ 0, 1, 2 ]. Operation:, Subtract Literal from FSR = FSRf - k \uf0ae FSRf. Operation:, Subtract Literal from FSR = FSRf - k \uf0ae FSRf. Operation:, Subtract Literal from FSR = FSRf - k \uf0ae FSRf. Operation:, Subtract Literal from FSR = FSRf",
    "PIC18F2585/2680/4585/4680\n- k \uf0ae FSRf. Status Affected:, Subtract Literal from FSR = None. Status Affected:, Subtract Literal from FSR = None. Status Affected:, Subtract Literal from FSR = None. Status Affected:, Subtract Literal from FSR = None. Encoding:, Subtract Literal from FSR = 1110. Encoding:, Subtract Literal from FSR = 1001. Encoding:, Subtract Literal from FSR = ffkk. Encoding:, Subtract Literal from FSR = kkkk. Description:, Subtract Literal from FSR = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f'.. Description:, Subtract Literal from FSR = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f'.. Description:, Subtract Literal from FSR = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f'.. Description:, Subtract Literal from FSR = The 6-bit",
    "PIC18F2585/2680/4585/4680\nliteral 'k' is subtracted from the contents of the FSR specified by 'f'.. Words:, Subtract Literal from FSR = 1. Words:, Subtract Literal from FSR = 1. Words:, Subtract Literal from FSR = 1. Words:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Q Cycle Activity: Q1, Subtract Literal from FSR = Q2. Q Cycle Activity: Q1, Subtract Literal from FSR = Q3. Q Cycle Activity: Q1, Subtract Literal from FSR = . Q Cycle Activity: Q1, Subtract Literal from FSR = Q4. Decode, Subtract Literal from FSR = Read register 'f'. Decode, Subtract Literal from FSR = Process Data. Decode, Subtract Literal from FSR = . Decode,",
    "PIC18F2585/2680/4585/4680\nSubtract Literal from FSR = Write to destination\nExample:\nSUBFSR 2, 23h\nBefore Instruction\nFSR2\n=\n03FFh\nAfter Instruction\nFSR2\n=\n03DCh",
    "PIC18F2585/2680/4585/4680\nSUBULNK, 1 = SUBULNK. SUBULNK, 2 = Subtract Literal from FSR2 and Return. SUBULNK, 3 = Subtract Literal from FSR2 and Return. SUBULNK, 4 = Subtract Literal from FSR2 and Return. Syntax:, 1 = Syntax:. Syntax:, 2 = SUBULNK k. Syntax:, 3 = SUBULNK k. Syntax:, 4 = SUBULNK k. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 k \uf0a3 63. Operands:, 3 = 0 \uf0a3 k \uf0a3 63. Operands:, 4 = 0 \uf0a3 k \uf0a3 63. Operation:, 1 = Operation:. Operation:, 2 = FSR2 - k \uf0ae FSR2 (TOS) \uf0ae\uf020 PC. Operation:, 3 = FSR2 - k \uf0ae FSR2 (TOS) \uf0ae\uf020 PC. Operation:, 4 = FSR2 - k \uf0ae FSR2 (TOS) \uf0ae\uf020 PC. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1",
    "PIC18F2585/2680/4585/4680\n= Encoding:. Encoding:, 2 = 1110. Encoding:, 3 = 1001. Encoding:, 4 = 11kk. Description:, 1 = Description:. Description:, 2 = The 6-bit literal 'k' is subtracted from the contents of the FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary ' 11 '); it operates only on FSR2.. Description:, 3 = The 6-bit literal 'k' is subtracted from the contents of the FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary ' 11 '); it operates only on FSR2.. Description:, 4 = The 6-bit literal 'k' is subtracted from the contents of",
    "PIC18F2585/2680/4585/4680\nthe FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary ' 11 '); it operates only on FSR2.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 2. Cycles:, 3 = 2. Cycles:, 4 = 2. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q1. , 3 = Q2. , 4 = Q3. , 1 = Decode. , 2 = Decode. , 3 = Read register 'f'. , 4 = Process Data. , 1 = No Operation. , 2 = No Operation.",
    "PIC18F2585/2680/4585/4680\n, 3 = No Operation. , 4 = No Operation\nExample:\nSUBULNK 23h\nBefore Instruction\nFSR2\n=\n03FFh\nPC\n=\n0100h\nAfter Instruction\nFSR2\n=\n03DCh\nPC\n=\n(TOS)\n25.2.3\nBYTE-ORIENTED AND BIT-ORIENTED INSTRUCTIONS IN INDEXED LITERAL OFFSET MODE",
    "25.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nNote:\nEnabling the PIC18 instruction set extension may cause legacy applications to behave erratically or fail entirely.\nIn addition to eight new commands in the extended set, enabling  the  extended  instruction  set  also  enables Indexed Literal Offset Addressing mode ( Section 6.6.1 'Indexed Addressing with Literal Offset' ). This has a significant impact on the way that many commands of the standard PIC18 instruction set are interpreted.\nWhen the extended set is disabled, addresses embedded in opcodes are treated as literal memory locations: either as a location in the Access Bank (a = 0 ), or in a GPR bank designated by the BSR (a = 1 ).  When the extended instruction set is enabled and a = 0 , however, a file register argument of 5Fh or less is interpreted as an offset from the pointer value in FSR2 and not as a literal address. For practical purposes, this means that all  instructions  that  use  the  Access  RAM  bit  as  an argument  -  that  is,  all  bit-oriented  and  byte-oriented instructions, or almost half of the core PIC18 instructions - may behave differently when the extended instruction set is enabled.",
    "25.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nWhen the content of FSR2 is 00h, the boundaries of the Access RAM are essentially remapped to their original values.  This  may  be  useful  in  creating  backward compatible code. If this technique is used, it may be necessary  to  save  the  value  of  FSR2  and  restore  it when moving back and forth between 'C' and assembly routines in order to preserve the Stack Pointer. Users must also keep in mind the syntax requirements of the extended instruction set (see Section 25.2.3.1 'Extended Instruction Syntax with Standard PIC18 Commands' ).\nAlthough the Indexed Literal Offset Addressing mode can  be  very  useful  for  dynamic  stack  and  pointer manipulation, it can also be very annoying if a simple arithmetic operation is carried out on  the wrong register.  Users  who  are  accustomed  to  the  PIC18 programming  must  keep  in  mind  that,  when  the extended instruction set is enabled, register addresses of  5Fh  or  less  are  used  for  Indexed  Literal  Offset Addressing.\nRepresentative examples of typical byte-oriented and bit-oriented  instructions  in  the  Indexed  Literal  Offset Addressing mode are provided on the following page to show how execution is affected. The operand conditions shown in the examples are applicable to all instructions of these types.",
    "25.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nWhen the extended instruction set is enabled, the file register argument, 'f', in the standard byte-oriented and bit-oriented commands, is replaced with the literal offset value, 'k'. As already noted, this occurs only when 'f' is less than or equal to 5Fh. When an offset value is used, it must be indicated by square brackets ('[ ]'). As with the extended instructions, the use of brackets indicates to the compiler that the value is to be interpreted as an index or an offset. Omitting the brackets, or using a value greater than 5Fh within brackets, will generate an error in the MPASM\u2122 Assembler.\nIf the index argument is properly bracketed for Indexed Literal Offset Addressing, the Access RAM argument is never specified; it will automatically be assumed to be ' 0 '. This is in contrast to standard operation (extended instruction set disabled) when 'a' is set on the basis of the  target  address.  Declaring  the  Access  RAM  bit  in this  mode  will  also  generate  an  error  in  the  MPASM Assembler.\nThe destination argument, 'd', functions as before.",
    "25.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nIn the latest versions  of the MPASM  Assembler, language support for the extended instruction set must be  explicitly  invoked.  This  is  done  with  either  the command line  option, /y ,  or  the  PE  directive  in  the source listing.",
    "25.2.4 CONSIDERATIONS WHEN ENABLING THE EXTENDED INSTRUCTION SET\nIt is important to note that the extensions to the instruction set may not be beneficial to all users. In particular, users who are not writing code that uses a software stack may not benefit from using the extensions to the instruction set.\nAdditionally, the  Indexed  Literal  Offset  Addressing mode  may  create  issues  with  legacy  applications written to the  PIC18  assembler.  This  is  because instructions in the legacy code may attempt to address registers in the Access Bank below 5Fh. Since these addresses  are  interpreted  as  literal  offsets  to  FSR2 when  the  instruction  set  extension  is  enabled,  the application  may  read  or  write  to  the  wrong  data addresses.\nWhen porting an application to the PIC18F2585/2680/ 4585/4680, it is very important to consider the type of code. A large, re-entrant application that is written in 'C' and would benefit from efficient compilation will do well when  using  the  instruction  set  extensions.  Legacy applications that heavily use the Access Bank will most likely  not  benefit  from  using  the  extended  instruction set.",
    "ADD W to Indexed\nADDWF",
    "(Indexed Literal Offset mode)\nSyntax:\nADDWF      [k] {,d}\nOperands:\n0 \uf0a3 k \uf0a3 95\nd \uf0ce [0,1]\na \uf03d\uf020 0\nOperation:\n(W) + ((FSR2) + k) \uf0ae dest\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0010\n01d0\nkkkk\nkkkk\nDescription:\nThe contents of W are added to the contents of the register indicated by FSR2, offset by the value 'k'.\nIf 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead 'k'\nProcess\nData\nWrite to\ndestination",
    "Example:\nADDWF\n[OFST] ,0\nBefore Instruction\nW\n=\n17h\nOFST\n=\n2Ch\nFSR2\n=\n0A00h\nContents\nof 0A2Ch\n=\n20h\nAfter Instruction\nW\n=\n37h\nContents\nof 0A2Ch\n=\n20h",
    "Example:\nSyntax:, (Indexed Literal Offset mode) = BSF [k], b. Syntax:, (Indexed Literal Offset mode) = BSF [k], b. Syntax:, (Indexed Literal Offset mode) = BSF [k], b. Syntax:, (Indexed Literal Offset mode) = BSF [k], b. Operands:, (Indexed Literal Offset mode) = 0 \uf0a3 f \uf0a3 95 0 \uf0a3 b \uf0a3 7 a = 0. Operands:, (Indexed Literal Offset mode) = 0 \uf0a3 f \uf0a3 95 0 \uf0a3 b \uf0a3 7 a = 0. Operands:, (Indexed Literal Offset mode) = 0 \uf0a3 f \uf0a3 95 0 \uf0a3 b \uf0a3 7 a = 0. Operands:, (Indexed Literal Offset mode) = 0 \uf0a3 f \uf0a3 95 0 \uf0a3 b \uf0a3 7 a = 0. Operation:, (Indexed Literal Offset mode) = 1 \uf0ae ((FSR2 + k))<b>. Operation:, (Indexed Literal Offset mode) = 1 \uf0ae ((FSR2 + k))<b>. Operation:, (Indexed Literal Offset mode) = 1 \uf0ae ((FSR2 + k))<b>. Operation:, (Indexed Literal Offset mode) = 1 \uf0ae ((FSR2 + k))<b>. Status",
    "Example:\nAffected:, (Indexed Literal Offset mode) = None. Status Affected:, (Indexed Literal Offset mode) = None. Status Affected:, (Indexed Literal Offset mode) = None. Status Affected:, (Indexed Literal Offset mode) = None. Encoding:, (Indexed Literal Offset mode) = 1000. Encoding:, (Indexed Literal Offset mode) = bbb0. Encoding:, (Indexed Literal Offset mode) = kkkk. Encoding:, (Indexed Literal Offset mode) = kkkk. Description:, (Indexed Literal Offset mode) = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set.. Description:, (Indexed Literal Offset mode) = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set.. Description:, (Indexed Literal Offset mode) = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set.. Description:, (Indexed Literal Offset mode) = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set.. Words:, (Indexed Literal Offset mode)",
    "Example:\n= 1. Words:, (Indexed Literal Offset mode) = 1. Words:, (Indexed Literal Offset mode) = 1. Words:, (Indexed Literal Offset mode) = 1. Cycles:, (Indexed Literal Offset mode) = 1. Cycles:, (Indexed Literal Offset mode) = 1. Cycles:, (Indexed Literal Offset mode) = 1. Cycles:, (Indexed Literal Offset mode) = 1\nQ Cycle Activity:\nExample:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. , Q2 = BSF. , Q3 = [FLAG_OFST],. , Q4 = 7. Before Instruction FLAG_OFST FSR2, Q2 = Before Instruction FLAG_OFST FSR2. Before Instruction FLAG_OFST FSR2, Q3 = 0Ah 0A00h 55h. Before Instruction FLAG_OFST FSR2, Q4 = ",
    "Set Indexed\nSyntax:, (Indexed Literal Offset mode) = SETF [k]. Syntax:, (Indexed Literal Offset mode) = SETF [k]. Syntax:, (Indexed Literal Offset mode) = SETF [k]. Syntax:, (Indexed Literal Offset mode) = SETF [k]. Operands:, (Indexed Literal Offset mode) = 0 \uf0a3 k \uf0a3 95. Operands:, (Indexed Literal Offset mode) = 0 \uf0a3 k \uf0a3 95. Operands:, (Indexed Literal Offset mode) = 0 \uf0a3 k \uf0a3 95. Operands:, (Indexed Literal Offset mode) = 0 \uf0a3 k \uf0a3 95. Operation:, (Indexed Literal Offset mode) = FFh \uf0ae ((FSR2) + k). Operation:, (Indexed Literal Offset mode) = FFh \uf0ae ((FSR2) + k). Operation:, (Indexed Literal Offset mode) = FFh \uf0ae ((FSR2) + k). Operation:, (Indexed Literal Offset mode) = FFh \uf0ae ((FSR2) + k). Status Affected:, (Indexed Literal Offset mode) = None. Status Affected:, (Indexed Literal Offset mode) = None. Status Affected:, (Indexed Literal Offset mode) = None. Status",
    "Set Indexed\nAffected:, (Indexed Literal Offset mode) = None. Encoding:, (Indexed Literal Offset mode) = 0110. Encoding:, (Indexed Literal Offset mode) = 1000. Encoding:, (Indexed Literal Offset mode) = kkkk. Encoding:, (Indexed Literal Offset mode) = kkkk. Description:, (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Words:, (Indexed Literal Offset mode) = 1. Words:, (Indexed Literal Offset mode) = 1. Words:, (Indexed Literal Offset mode) = 1. Words:, (Indexed Literal Offset mode) = 1. Cycles:, (Indexed",
    "Set Indexed\nLiteral Offset mode) = 1. Cycles:, (Indexed Literal Offset mode) = 1. Cycles:, (Indexed Literal Offset mode) = 1. Cycles:, (Indexed Literal Offset mode) = 1. Q Cycle Activity:, (Indexed Literal Offset mode) = Q Cycle Activity:. Q Cycle Activity:, (Indexed Literal Offset mode) = Q Cycle Activity:. Q Cycle Activity:, (Indexed Literal Offset mode) = Q Cycle Activity:. Q Cycle Activity:, (Indexed Literal Offset mode) = Q Cycle Activity:. Q1, (Indexed Literal Offset mode) = Q2. Q1, (Indexed Literal Offset mode) = Q3. Q1, (Indexed Literal Offset mode) = . Q1, (Indexed Literal Offset mode) = Q4. Decode, (Indexed Literal Offset mode) = Read 'k'. Decode, (Indexed Literal Offset mode) = Process Data. Decode, (Indexed Literal Offset mode) = . Decode, (Indexed Literal Offset mode) = Write register",
    "Set Indexed\nBefore Instruction OFST, SETF = =. Before Instruction OFST, [OFST] = 2Ch. FSR2, SETF = =. FSR2, [OFST] = 0A00h. Contents of 0A2Ch, SETF = =. Contents of 0A2Ch, [OFST] = 00h. After Instruction Contents of 0A2Ch, SETF = =. After Instruction Contents of 0A2Ch, [OFST] = FFh",
    "25.2.5 SPECIAL CONSIDERATIONS WITH MICROCHIP MPLAB \u00ae  IDE TOOLS\nThe latest versions of Microchip's software tools have been designed to fully support the extended instruction set of the PIC18F2585/2680/4585/4680  family of devices.  This  includes  the  MPLAB  C18  C compiler, MPASM  assembly  language  and  MPLAB  Integrated Development Environment (IDE).\nWhen selecting  a  target  device  for  software  development, MPLAB IDE will automatically set default Configuration bits for that device. The default setting for the XINST Configuration bit is ' 0 ', disabling the extended instruction  set  and  Indexed  Literal  Offset  Addressing mode. For proper execution of applications developed to take advantage of the extended instruction set, XINST must be set during programming.\nTo develop software for the extended instruction set, the user must enable support for the instructions and the Indexed Addressing mode in their language tool(s). Depending on the environment being used, this may be done in several ways:\n\u00b7 A menu option, or dialog box within the environment, that allows the user to configure the language tool and its settings for the project\n\u00b7 A command line option\n\u00b7 A directive in the source code",
    "25.2.5 SPECIAL CONSIDERATIONS WITH MICROCHIP MPLAB \u00ae  IDE TOOLS\nThese options vary between different compilers, assemblers and development environments. Users are encouraged to review the documentation accompanying  their  development  systems  for  the  appropriate information.",
    "26.0 DEVELOPMENT SUPPORT\nThe PIC \u00ae   microcontrollers  (MCU)  and  dsPIC \u00ae   digital signal controllers (DSC) are supported with a full range of software and hardware development tools:",
    "26.1 MPLAB X Integrated Development Environment Software\n\u00b7 Integrated Development Environment\n-MPLAB \u00ae  X IDE Software\n\u00b7 Compilers/Assemblers/Linkers\n-MPLAB XC Compiler\n-MPASM TM  Assembler\n-MPLINK TM  Object Linker/ MPLIB TM  Object Librarian\n-MPLAB Assembler/Linker/Librarian for Various Device Families\n\u00b7 Simulators\n-MPLAB X SIM Software Simulator\n\u00b7 Emulators\n-MPLAB REAL ICE\u2122 In-Circuit Emulator\n\u00b7 In-Circuit Debuggers/Programmers\n-MPLAB ICD 3\n-PICkit\u2122 3\n\u00b7 Device Programmers\n-MPLAB PM3 Device Programmer\n\u00b7 Low-Cost Demonstration/Development Boards, Evaluation Kits and Starter Kits\n\u00b7 Third-party development tools",
    "26.1 MPLAB X Integrated Development Environment Software\nThe MPLAB X IDE is a single, unified graphical user interface  for  Microchip  and  third-party  software,  and hardware  development  tool  that  runs  on  Windows \u00ae , Linux and Mac OS \u00ae  X. Based on the NetBeans IDE, MPLAB X IDE is an entirely new IDE with a host of free software components and plug-ins for highperformance application development and debugging. Moving  between  tools  and  upgrading  from  software simulators  to  hardware  debugging  and  programming tools is simple with the seamless user interface.\nWith complete project management, visual call graphs, a configurable watch window and a feature-rich editor that  includes  code  completion  and  context  menus, MPLAB X IDE is flexible and friendly enough for new users.  With  the  ability  to  support  multiple  tools  on multiple projects with simultaneous debugging, MPLAB X  IDE  is  also  suitable  for  the  needs  of  experienced users.",
    "Feature-Rich Editor:\n\u00b7 Color syntax highlighting\n\u00b7 Smart code completion makes suggestions and provides hints as you type\n\u00b7 Automatic code formatting based on user-defined rules\n\u00b7 Live parsing\nUser-Friendly, Customizable Interface:\n\u00b7 Fully customizable interface: toolbars, toolbar buttons, windows, window placement, etc.\n\u00b7 Call graph window\nProject-Based Workspaces:\n\u00b7 Multiple projects\n\u00b7 Multiple tools\n\u00b7 Multiple configurations\n\u00b7 Simultaneous debugging sessions\nFile History and Bug Tracking:\n\u00b7 Local file history feature\n\u00b7 Built-in support for Bugzilla issue tracker",
    "26.2 MPLAB XC Compilers\nThe  MPLAB  XC  Compilers  are  complete  ANSI  C compilers for all of Microchip's 8, 16, and 32-bit MCU and DSC devices. These compilers provide powerful integration capabilities, superior code optimization and ease of use. MPLAB XC Compilers run on Windows, Linux or MAC OS X.\nFor easy source level debugging, the compilers provide debug information that is  optimized to the MPLAB X IDE.\nThe  free  MPLAB  XC  Compiler  editions  support  all devices  and  commands,  with  no  time  or  memory restrictions,  and  offer  sufficient  code  optimization  for most applications.\nMPLAB XC Compilers include an assembler, linker and utilities.  The  assembler  generates  relocatable  object files that can then be archived or linked with other relocatable object files and archives to create an executable file. MPLAB XC Compiler uses the assembler to produce its object file. Notable features of the assembler include:\n\u00b7 Support for the entire device instruction set\n\u00b7 Support for fixed-point and floating-point data\n\u00b7 Command-line interface\n\u00b7 Rich directive set\n\u00b7 Flexible macro language\n\u00b7 MPLAB X IDE compatibility",
    "26.3 MPASM Assembler\nThe  MPASM  Assembler  is  a  full-featured,  universal macro assembler for PIC10/12/16/18 MCUs.\nThe MPASM Assembler generates relocatable object files for the MPLINK Object Linker, Intel \u00ae standard HEX files,  MAP  files  to  detail  memory  usage  and  symbol reference, absolute LST files that contain source lines and  generated  machine  code,  and  COFF  files  for debugging.\nThe MPASM Assembler features include:\n\u00b7 Integration into MPLAB X IDE projects\n\u00b7 User-defined macros to streamline assembly code\n\u00b7 Conditional assembly for multipurpose source files\n\u00b7 Directives that allow complete control over the assembly process",
    "26.4 MPLINK Object Linker/ MPLIB Object Librarian\nThe  MPLINK  Object  Linker  combines  relocatable objects created by the MPASM Assembler. It can link relocatable  objects  from  precompiled  libraries,  using directives from a linker script.\nThe MPLIB Object Librarian manages the creation and modification of library files of precompiled code. When a routine from a library is called from a source file, only the modules that contain that routine will be linked in with  the  application.  This  allows  large  libraries  to  be used efficiently in many different applications.\nThe object linker/library features include:\n\u00b7 Efficient linking of single libraries instead of many smaller files\n\u00b7 Enhanced code maintainability by grouping related modules together\n\u00b7 Flexible creation of libraries with easy module listing, replacement, deletion and extraction",
    "26.5 MPLAB Assembler, Linker and Librarian for Various Device Families\nMPLAB  Assembler  produces  relocatable machine code  from  symbolic  assembly  language  for  PIC24, PIC32 and dsPIC DSC devices. MPLAB XC Compiler uses  the  assembler  to  produce  its  object  file.  The assembler generates relocatable object files that can then be archived or linked with other relocatable object files and archives to create an executable file. Notable features of the assembler include:\n\u00b7 Support for the entire device instruction set\n\u00b7 Support for fixed-point and floating-point data\n\u00b7 Command-line interface\n\u00b7 Rich directive set\n\u00b7 Flexible macro language\n\u00b7 MPLAB X IDE compatibility",
    "26.6 MPLAB X SIM Software Simulator\nThe  MPLAB  X  SIM  Software  Simulator  allows  code development in a PC-hosted environment by simulating the PIC MCUs and dsPIC DSCs on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a comprehensive stimulus controller. Registers can be logged to files for further run-time analysis. The trace buffer and logic analyzer display extend the power of the simulator to record and track program execution, actions on I/O, most peripherals and internal registers.\nThe MPLAB X SIM Software Simulator fully supports symbolic debugging using the MPLAB XC Compilers, and  the  MPASM  and  MPLAB  Assemblers.  The  software  simulator  offers  the  flexibility  to  develop  and debug code outside of the hardware laboratory environment, making it an excellent, economical software development tool.",
    "26.7 MPLAB REAL ICE In-Circuit Emulator System\nThe MPLAB REAL ICE In-Circuit Emulator System is Microchip's  next  generation  high-speed  emulator  for Microchip Flash DSC and MCU devices. It debugs and programs all 8, 16 and 32-bit MCU, and DSC devices with the easy-to-use, powerful graphical user interface of the MPLAB X IDE.\nThe emulator is connected to the design engineer's PC  using  a  high-speed  USB  2.0  interface  and  is connected  to  the  target  with either a connector compatible with in-circuit debugger systems (RJ-11) or  with  the  new  high-speed,  noise  tolerant,  LowVoltage  Differential  Signal  (LVDS)  interconnection (CAT5).\nThe emulator is field upgradable through future firmware downloads in MPLAB X IDE. MPLAB REAL ICE offers significant advantages over competitive emulators including full-speed emulation, run-time variable watches,  trace  analysis,  complex  breakpoints,  logic probes,  a  ruggedized  probe  interface  and  long  (up  to three meters) interconnection cables.",
    "26.8 MPLAB ICD 3 In-Circuit Debugger System\nThe  MPLAB  ICD  3  In-Circuit  Debugger  System  is Microchip's most cost-effective, high-speed hardware debugger/programmer  for  Microchip  Flash  DSC  and MCU  devices.  It  debugs  and  programs  PIC  Flash microcontrollers  and  dsPIC  DSCs  with  the  powerful, yet easy-to-use graphical user interface of the MPLAB IDE.\nThe  MPLAB  ICD  3  In-Circuit  Debugger  probe  is connected to the design engineer's PC using a highspeed USB 2.0 interface and is connected to the target with a connector compatible with the MPLAB ICD 2 or MPLAB  REAL  ICE  systems  (RJ-11).  MPLAB  ICD  3 supports all MPLAB ICD 2 headers.",
    "26.9 PICkit 3 In-Circuit Debugger/ Programmer\nThe MPLAB PICkit 3 allows debugging and programming of PIC and dsPIC Flash microcontrollers at a most affordable price point using the powerful graphical user interface of the MPLAB IDE. The MPLAB PICkit 3 is connected  to  the  design  engineer's  PC  using  a  fullspeed USB interface and can be connected to the target via a Microchip debug (RJ-11) connector (compatible with MPLAB ICD 3 and MPLAB REAL ICE). The connector uses two device I/O pins and the Reset line to implement in-circuit debugging and In-Circuit Serial Programming\u2122 (ICSP\u2122).",
    "26.10 MPLAB PM3 Device Programmer\nThe MPLAB PM3 Device Programmer is a universal, CE compliant device programmer with programmable voltage verification at VDDMIN and VDDMAX for maximum  reliability.  It  features  a  large  LCD  display (128 x 64) for menus and error messages, and a modular,  detachable  socket  assembly  to  support  various package types. The ICSP cable assembly is included as a standard item. In Stand-Alone mode, the MPLAB PM3 Device Programmer can read, verify and program PIC devices without a PC connection. It can also set code  protection in this mode.  The  MPLAB  PM3 connects to the host PC via an RS-232 or USB cable. The MPLAB PM3 has high-speed communications and optimized  algorithms  for  quick  programming  of  large memory devices, and incorporates an MMC card for file storage and data applications.",
    "26.12 Third-Party Development Tools\nA  wide  variety  of  demonstration,  development  and evaluation  boards  for  various  PIC  MCUs  and  dsPIC DSCs  allows  quick  application  development  on  fully functional  systems.  Most  boards  include  prototyping areas for adding custom circuitry and provide application  firmware  and  source  code  for  examination  and modification.\nThe boards support a variety of features, including LEDs, temperature sensors, switches, speakers, RS-232 interfaces, LCD displays, potentiometers and additional EEPROM memory.\nThe  demonstration  and  development  boards  can  be used in teaching environments, for prototyping custom circuits and for learning about various microcontroller applications.\nIn addition to the PICDEM\u2122  and  dsPICDEM\u2122 demonstration/development  board  series  of  circuits, Microchip has a line of evaluation kits and demonstration software for analog filter design, KEELOQ \u00ae  security ICs,  CAN,  IrDA \u00ae ,  PowerSmart  battery  management, SEEVAL \u00ae   evaluation  system,  Sigma-Delta  ADC,  flow rate sensing, plus many more.\nAlso available are starter kits that contain everything needed to experience the specified device. This usually includes a single application and debug capability, all on one board.",
    "26.12 Third-Party Development Tools\nCheck the Microchip web page (www.microchip.com) for  the  complete  list  of  demonstration,  development and evaluation kits.\nMicrochip  also  offers  a  great  collection  of  tools  from third-party vendors. These tools are carefully selected to offer good value and unique functionality.\n\u00b7 Device Programmers and Gang Programmers from companies, such as SoftLog and CCS\n\u00b7 Software Tools from companies, such as Gimpel and Trace Systems\n\u00b7 Protocol Analyzers from companies, such as Saleae and Total Phase\n\u00b7 Demonstration Boards from companies, such as MikroElektronika, Digilent \u00ae  and Olimex\n\u00b7 Embedded Ethernet Solutions from companies, such as EZ Web Lynx, WIZnet and IPLogika \u00ae",
    "Absolute Maximum Ratings  (\u2020)\nAmbient temperature under bias.............................................................................................................-40\u00b0C to +125\u00b0C",
    "Absolute Maximum Ratings  (\u2020)\nStorage temperature .............................................................................................................................. -65\u00b0C to +150\u00b0C\nVoltage on any pin with respect to VSS (except VDD and MCLR) ................................................... -0.3V to (VDD + 0.3V)",
    "Absolute Maximum Ratings  (\u2020)\nVoltage on VDD with respect to VSS  .........................................................................................................  -0.3V to +7.5V\nVoltage on MCLR with respect to VSS (Note 2)\n......................................................................................... 0V to +13.25V\nTotal power dissipation (Note 1)",
    "Absolute Maximum Ratings  (\u2020)\n...............................................................................................................................1.0W",
    "Absolute Maximum Ratings  (\u2020)\nMaximum current out of VSS pin ...........................................................................................................................300 mA",
    "Absolute Maximum Ratings  (\u2020)\nMaximum current into VDD pin ..............................................................................................................................250 mA\nInput clamp current, IIK (VI < 0 or VI > VDD)\n\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e \uf0b1\n20 mA\nOutput clamp current, IOK (VO < 0 or VO > VDD)\n\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e \uf0b1\n20 mA",
    "Absolute Maximum Ratings  (\u2020)\nMaximum output current sunk by any I/O pin..........................................................................................................25 mA\nMaximum output current sourced by any I/O pin ....................................................................................................25 mA",
    "Absolute Maximum Ratings  (\u2020)\nMaximum current sunk by all ports .......................................................................................................................200 mA \uf020\nMaximum current sourced by all ports ..................................................................................................................200 mA",
    "Absolute Maximum Ratings  (\u2020)\nNote 1: Power dissipation is calculated as follows: Pdis = VDD x {IDD -\uf0e5 IOH} + \uf0e5 {(VDD - VOH) x IOH} + \uf0e5 (VOL x IOL)\n- 2: Voltage spikes below VSS at the MCLR/VPP pin, inducing currents greater than 80 mA, may cause latch-up. Thus, a series resistor of 50-100 \uf057 should be used when applying a 'low' level to the MCLR/VPP/RE3 pin, rather than pulling this pin directly to VSS.\n\u2020 NOTICE: Stresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure to maximum rating conditions for extended periods may affect device reliability.\nFIGURE 27-1: PIC18F2585/2680/4585/4680 VOLTAGE-FREQUENCY GRAPH (INDUSTRIAL AND EXTENDED)",
    "27.1 DC Characteristics:\nSupply Voltage",
    "PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial)\nPIC18LF2585/2680/4585/4680\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F2585/2680/4585/4680\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial)\nD001, Symbol = VDD. D001, Characteristic = Supply Voltage. D001, Min = Supply Voltage. D001, Typ = Supply Voltage. D001, Max = Supply Voltage. D001, Units = Supply Voltage. D001, Conditions = Supply Voltage. D001, Symbol = VDD. D001, Characteristic = PIC18LFX585/X680. D001, Min = 2.0. D001, Typ = -. D001, Max = 5.5. D001, Units = V. D001, Conditions = . D001, Symbol = VDD. D001, Characteristic = PIC18FX585/X680. D001, Min = 4.2. D001, Typ = -. D001, Max = 5.5. D001, Units = V. D001, Conditions = . D002, Symbol = VDR. D002, Characteristic = RAM Data Retention",
    "PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial)\nVoltage (1). D002, Min = 1.5. D002, Typ = -. D002, Max = -. D002, Units = V. D002, Conditions = . D003, Symbol = VPOR. D003, Characteristic = VDD Start Voltage to ensure internal Power-on Reset signal. D003, Min = -. D003, Typ = -. D003, Max = 0.7. D003, Units = V. D003, Conditions = See section on Power-on Reset for details. D004, Symbol = SVDD. D004, Characteristic = VDD Rise Rate to ensure internal Power-on Reset signal. D004, Min = 0.05. D004, Typ = -. D004, Max = -. D004, Units = V/ms. D004, Conditions = See section on Power-on Reset for details. D005, Symbol = VBOR. D005, Characteristic =",
    "PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial)\nBrown-out Reset Voltage. D005, Min = Brown-out Reset Voltage. D005, Typ = Brown-out Reset Voltage. D005, Max = Brown-out Reset Voltage. D005, Units = Brown-out Reset Voltage. D005, Conditions = Brown-out Reset Voltage. D005, Symbol = VBOR. D005, Characteristic = PIC18LFX585/X680. D005, Min = PIC18LFX585/X680. D005, Typ = PIC18LFX585/X680. D005, Max = PIC18LFX585/X680. D005, Units = PIC18LFX585/X680. D005, Conditions = PIC18LFX585/X680. D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 11. D005, Min = 2.00. D005, Typ",
    "PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial)\n= 2.05. D005, Max = 2.16. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 10. D005, Min = 2.65. D005, Typ = 2.79. D005, Max = 2.93. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = All Devices. D005, Min = All Devices. D005, Typ = All Devices. D005, Max = All Devices. D005, Units = All Devices. D005, Conditions = All Devices. D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 01. D005, Min = 4.11. D005, Typ = 4.33. D005, Max =",
    "PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial)\n4.55. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 00. D005, Min = 4.36. D005, Typ = 4.59. D005, Max = 4.82. D005, Units = V. D005, Conditions = \nLegend: Shading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in Sleep mode, or during a device Reset, without losing RAM data.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial)\nPIC18LF2585/2680/4585/4680\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18F2585/2680/4585/4680\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial)\n, Device = Power-down Current (I PD ) (1). , Typ = Power-down Current (I PD ) (1). , Max = Power-down Current (I PD ) (1). , Units = Power-down Current (I PD ) (1). , Conditions = Power-down Current (I PD ) (1). , Conditions = Power-down Current (I PD ) (1). , Device = PIC18LFX585/X680. , Typ = 0.25. , Max = 0.95. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V, ( Sleep mode). , Device = PIC18LFX585/X680. , Typ = 0.3. , Max = 1.0. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V, ( Sleep mode). , Device =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial)\nPIC18LFX585/X680. , Typ = 3.0. , Max = 6.0. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V, ( Sleep mode). , Device = PIC18LFX585/X680. , Typ = 0.3. , Max = 1.4. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V, ( Sleep mode). , Device = PIC18LFX585/X680. , Typ = 0.35. , Max = 2.0. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V, ( Sleep mode). , Device = PIC18LFX585/X680. , Typ = 3.5. , Max = 8.0. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial)\nVDD = 3.0V, ( Sleep mode). , Device = All devices. , Typ = 0.5. , Max = 1.9. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V, ( Sleep mode). , Device = All devices. , Typ = 0.5. , Max = 2.0. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V, ( Sleep mode). , Device = All devices. , Typ = 6.0. , Max = 15. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V, ( Sleep mode). , Device = PIC18FX585/X680. , Typ = 10.00. , Max = 120.00. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V, ( Sleep",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial)\nmode)",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption. The test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.\n27.2 DC Characteristics:",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LF2585/2680/4585/4680\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F2585/2680/4585/4680\n(Industrial, Extended)\nParam No.\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended\nDevice\nTyp\nMax\nUnits\nConditions",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Supply Current (I DD) (2,3) = 19.00. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 35.00. PIC18LFX585/X680, Supply Current (I DD) (2,3) = \uf06d A. PIC18LFX585/X680, Supply Current (I DD) (2,3) = -40\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 2.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 31 kHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 20.00.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Supply Current (I DD) (2,3) = 35.00. PIC18LFX585/X680, Supply Current (I DD) (2,3) = \uf06d A. PIC18LFX585/X680, Supply Current (I DD) (2,3) = +25\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 2.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 31 kHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 22.00. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 35.00.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Supply Current (I DD) (2,3) = \uf06d A. PIC18LFX585/X680, Supply Current (I DD) (2,3) = +85\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 2.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 31 kHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 57.00. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 60.00. PIC18LFX585/X680, Supply Current (I DD) (2,3) = \uf06d A.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Supply Current (I DD) (2,3) = -40\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 3.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 31 kHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 47.00. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 60.00. PIC18LFX585/X680, Supply Current (I DD) (2,3) = \uf06d A. PIC18LFX585/X680, Supply Current (I DD) (2,3) = +25\u00b0C.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 3.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 31 kHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 42.00. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 60.00. PIC18LFX585/X680, Supply Current (I DD) (2,3) = \uf06d A. PIC18LFX585/X680, Supply Current (I DD) (2,3) = +85\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 3.0V.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 31 kHz ( RC_RUN mode, Internal oscillator source). All devices, Supply Current (I DD) (2,3) = 150.00. All devices, Supply Current (I DD) (2,3) = 170.00. All devices, Supply Current (I DD) (2,3) = \uf06d A. All devices, Supply Current (I DD) (2,3) = -40\u00b0C. All devices, Supply Current (I DD) (2,3) = VDD = 5.0V. All devices, Supply Current (I DD) (2,3) = FOSC = 31 kHz ( RC_RUN mode, Internal oscillator source). All devices, Supply Current (I DD) (2,3) = 120.00. All devices, Supply Current (I DD) (2,3) =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n170.00. All devices, Supply Current (I DD) (2,3) = \uf06d A. All devices, Supply Current (I DD) (2,3) = +25\u00b0C. All devices, Supply Current (I DD) (2,3) = VDD = 5.0V. All devices, Supply Current (I DD) (2,3) = FOSC = 31 kHz ( RC_RUN mode, Internal oscillator source). All devices, Supply Current (I DD) (2,3) = 98.00. All devices, Supply Current (I DD) (2,3) = 170.00. All devices, Supply Current (I DD) (2,3) = \uf06d A. All devices, Supply Current (I DD) (2,3) = +85\u00b0C. All devices, Supply Current (I DD) (2,3) = VDD = 5.0V. All devices, Supply Current (I DD) (2,3) =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nFOSC = 31 kHz ( RC_RUN mode, Internal oscillator source). PIC18FX585/X680, Supply Current (I DD) (2,3) = 100.00. PIC18FX585/X680, Supply Current (I DD) (2,3) = 250.00. PIC18FX585/X680, Supply Current (I DD) (2,3) = \uf06d A. PIC18FX585/X680, Supply Current (I DD) (2,3) = +125\u00b0C. PIC18FX585/X680, Supply Current (I DD) (2,3) = VDD = 2.0V. PIC18FX585/X680, Supply Current (I DD) (2,3) = FOSC = 31 kHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nCurrent (I DD) (2,3) = 0.53. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 1.10. PIC18LFX585/X680, Supply Current (I DD) (2,3) = mA. PIC18LFX585/X680, Supply Current (I DD) (2,3) = -40\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = . PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 1 MHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 0.55. PIC18LFX585/X680, Supply Current (I DD) (2,3) =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n1.10. PIC18LFX585/X680, Supply Current (I DD) (2,3) = mA. PIC18LFX585/X680, Supply Current (I DD) (2,3) = +25\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = . PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 1 MHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 0.56. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 1.10. PIC18LFX585/X680, Supply Current (I DD) (2,3) = mA.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Supply Current (I DD) (2,3) = +85\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = . PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 1 MHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 0.94. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 1.20. PIC18LFX585/X680, Supply Current (I DD) (2,3) = mA. PIC18LFX585/X680, Supply Current (I DD) (2,3) = -40\u00b0C. PIC18LFX585/X680,",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nSupply Current (I DD) (2,3) = VDD = 3.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 1 MHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 0.90. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 1.20. PIC18LFX585/X680, Supply Current (I DD) (2,3) = mA. PIC18LFX585/X680, Supply Current (I DD) (2,3) = +25\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 3.0V. PIC18LFX585/X680, Supply",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nCurrent (I DD) (2,3) = FOSC = 1 MHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 0.88. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 1.20. PIC18LFX585/X680, Supply Current (I DD) (2,3) = mA. PIC18LFX585/X680, Supply Current (I DD) (2,3) = +85\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 3.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 1 MHz ( RC_RUN mode, Internal oscillator source). All",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\ndevices, Supply Current (I DD) (2,3) = 1.80. All devices, Supply Current (I DD) (2,3) = 2.30. All devices, Supply Current (I DD) (2,3) = mA. All devices, Supply Current (I DD) (2,3) = -40\u00b0C. All devices, Supply Current (I DD) (2,3) = VDD = 5.0V. All devices, Supply Current (I DD) (2,3) = FOSC = 1 MHz ( RC_RUN mode, Internal oscillator source). All devices, Supply Current (I DD) (2,3) = 1.70. All devices, Supply Current (I DD) (2,3) = 2.30. All devices, Supply Current (I DD) (2,3) = mA. All devices, Supply Current (I DD) (2,3) = +25\u00b0C. All devices, Supply Current",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(I DD) (2,3) = VDD = 5.0V. All devices, Supply Current (I DD) (2,3) = FOSC = 1 MHz ( RC_RUN mode, Internal oscillator source). All devices, Supply Current (I DD) (2,3) = 1.60. All devices, Supply Current (I DD) (2,3) = 2.30. All devices, Supply Current (I DD) (2,3) = mA. All devices, Supply Current (I DD) (2,3) = +85\u00b0C. All devices, Supply Current (I DD) (2,3) = VDD = 5.0V. All devices, Supply Current (I DD) (2,3) = FOSC = 1 MHz ( RC_RUN mode, Internal oscillator source). PIC18FX585/X680, Supply Current (I DD) (2,3) = 2.60.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18FX585/X680, Supply Current (I DD) (2,3) = 3.60. PIC18FX585/X680, Supply Current (I DD) (2,3) = mA. PIC18FX585/X680, Supply Current (I DD) (2,3) = +125\u00b0C. PIC18FX585/X680, Supply Current (I DD) (2,3) = . PIC18FX585/X680, Supply Current (I DD) (2,3) = FOSC = 1 MHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 1.50. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 2.10. PIC18LFX585/X680, Supply",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nCurrent (I DD) (2,3) = mA. PIC18LFX585/X680, Supply Current (I DD) (2,3) = -40\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 2.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 4 MHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 1.50. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 2.10. PIC18LFX585/X680, Supply Current (I DD) (2,3) = mA. PIC18LFX585/X680, Supply Current (I DD)",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(2,3) = +25\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 2.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 4 MHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 1.50. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 2.10. PIC18LFX585/X680, Supply Current (I DD) (2,3) = mA. PIC18LFX585/X680, Supply Current (I DD) (2,3) = +85\u00b0C. PIC18LFX585/X680, Supply Current (I DD)",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(2,3) = VDD = 2.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 4 MHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 2.40. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 3.30. PIC18LFX585/X680, Supply Current (I DD) (2,3) = mA. PIC18LFX585/X680, Supply Current (I DD) (2,3) = -40\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 3.0V. PIC18LFX585/X680, Supply Current (I DD)",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(2,3) = FOSC = 4 MHz ( RC_RUN mode, Internal oscillator source). PIC18LFX585/X680, Supply Current (I DD) (2,3) = 2.40. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 3.30. PIC18LFX585/X680, Supply Current (I DD) (2,3) = mA. PIC18LFX585/X680, Supply Current (I DD) (2,3) = +25\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 3.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 4 MHz ( RC_RUN mode, Internal oscillator source).",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Supply Current (I DD) (2,3) = 2.40. PIC18LFX585/X680, Supply Current (I DD) (2,3) = 3.30. PIC18LFX585/X680, Supply Current (I DD) (2,3) = mA. PIC18LFX585/X680, Supply Current (I DD) (2,3) = +85\u00b0C. PIC18LFX585/X680, Supply Current (I DD) (2,3) = VDD = 3.0V. PIC18LFX585/X680, Supply Current (I DD) (2,3) = FOSC = 4 MHz ( RC_RUN mode, Internal oscillator source). All devices, Supply Current (I DD) (2,3) = 4.40. All devices, Supply Current (I DD)",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(2,3) = 5.20. All devices, Supply Current (I DD) (2,3) = mA. All devices, Supply Current (I DD) (2,3) = -40\u00b0C. All devices, Supply Current (I DD) (2,3) = VDD = 5.0V. All devices, Supply Current (I DD) (2,3) = FOSC = 4 MHz ( RC_RUN mode, Internal oscillator source). All devices, Supply Current (I DD) (2,3) = 4.40. All devices, Supply Current (I DD) (2,3) = 5.20. All devices, Supply Current (I DD) (2,3) = mA. All devices, Supply Current (I DD) (2,3) = +25\u00b0C. All devices, Supply Current (I DD) (2,3) = VDD = 5.0V. All devices, Supply Current (I DD)",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(2,3) = FOSC = 4 MHz ( RC_RUN mode, Internal oscillator source). All devices, Supply Current (I DD) (2,3) = 4.40. All devices, Supply Current (I DD) (2,3) = 5.20. All devices, Supply Current (I DD) (2,3) = mA. All devices, Supply Current (I DD) (2,3) = +85\u00b0C. All devices, Supply Current (I DD) (2,3) = VDD = 5.0V. All devices, Supply Current (I DD) (2,3) = FOSC = 4 MHz ( RC_RUN mode, Internal oscillator source). PIC18FX585/X680, Supply Current (I DD) (2,3) = 9.20. PIC18FX585/X680, Supply Current (I DD) (2,3) = 11.00.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18FX585/X680, Supply Current (I DD) (2,3) = mA. PIC18FX585/X680, Supply Current (I DD) (2,3) = +125\u00b0C. PIC18FX585/X680, Supply Current (I DD) (2,3) = VDD = 5.0V. PIC18FX585/X680, Supply Current (I DD) (2,3) = FOSC = 4 MHz ( RC_RUN mode, Internal oscillator source)\n- Legend:\nShading of rows is to assist in readability of the table.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption. The test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.\nPIC18LF2585/2680/4585/4680\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F2585/2680/4585/4680\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nSupply, Device = Current (I DD) (2,3). Supply, Typ = . Supply, Max = . Supply, Units = . Supply, Conditions = . Supply, Conditions = . , Device = PIC18LFX585/X680. , Typ = 6.10. , Max = 8.40. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 6.70. , Max = 8.40. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 7.40. , Max = 22.0. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 9.60. , Max = 12.00. , Units = \uf06d A.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n, Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 11.00. , Max = 12.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 12.00. , Max = 33.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 20.00. , Max = 28.00. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = All devices. , Typ = 22.00. , Max = 28.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = All devices. , Typ = 24.00. , Max = 33.00. , Units = \uf06d A. , Conditions =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n+85\u00b0C. , Conditions = . , Device = PIC18FX585/X680. , Typ = 84.00. , Max = 200.00. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 300.00. , Max = 390.00. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 320.00. , Max = 390.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 330.00. , Max = 390.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n450.00. , Max = 550.00. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 470.00. , Max = 550.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 490.00. , Max = 550.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 0.84. , Max = 1.10. , Units = mA. , Conditions = -40\u00b0C. , Conditions = . , Device = All devices. , Typ = 0.88. , Max = 1.10. , Units = mA. , Conditions = +25\u00b0C. , Conditions = . , Device = All devices. , Typ = 0.90. , Max =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n1.10. , Units = mA. , Conditions = +85\u00b0C. , Conditions = . , Device = PIC18FX585/X680. , Typ = 2.80. , Max = 3.20. , Units = mA. , Conditions = +125\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 0.76. , Max = 1.10. , Units = mA. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 0.79. , Max = 1.10. , Units = mA. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 0.81. , Max = 1.10. , Units = mA. , Conditions = +85\u00b0C. , Conditions = . , Device =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680. , Typ = 1.20. , Max = 1.50. , Units = mA. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 1.30. , Max = 1.50. , Units = mA. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 1.30. , Max = 1.50. , Units = mA. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 2.20. , Max = 2.70. , Units = mA. , Conditions = -40\u00b0C. , Conditions = . , Device = All devices. , Typ = 2.30. , Max = 2.70. , Units = mA. , Conditions = +25\u00b0C. , Conditions = . , Device",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n= All devices. , Typ = 2.30. , Max = 2.70. , Units = mA. , Conditions = +85\u00b0C. , Conditions = . , Device = PIC18FX585/X680. , Typ = 4.70. , Max = 5.50. , Units = mA. , Conditions = +125\u00b0C. , Conditions = \nLegend:\nShading of rows is to assist in readability of the table.\nNote",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption. The test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.\n27.2 DC Characteristics:\nPIC18LF2585/2680/4585/4680\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F2585/2680/4585/4680\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nSupply Current (I DD) (2,3), Typ = . Supply Current (I DD) (2,3), Max = . Supply Current (I DD) (2,3), Units = . Supply Current (I DD) (2,3), Conditions = . Supply Current (I DD) (2,3), Conditions = . Supply Current (I DD) (2,3), Conditions = . PIC18LFX585/X680, Typ = 410.00. PIC18LFX585/X680, Max = 550.00. PIC18LFX585/X680, Units = \uf06d A. PIC18LFX585/X680, Conditions = -40\u00b0C. PIC18LFX585/X680, Conditions = VDD = 2.0V. PIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Typ = 420.00.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Max = 550.00. PIC18LFX585/X680, Units = \uf06d A. PIC18LFX585/X680, Conditions = +25\u00b0C. PIC18LFX585/X680, Conditions = VDD = 2.0V. PIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Typ = 420.00. PIC18LFX585/X680, Max = 550.00. PIC18LFX585/X680, Units = \uf06d A. PIC18LFX585/X680, Conditions = +85\u00b0C. PIC18LFX585/X680, Conditions = VDD = 2.0V. PIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Typ = 0.87.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Max = 0.88. PIC18LFX585/X680, Units = mA. PIC18LFX585/X680, Conditions = -40\u00b0C. PIC18LFX585/X680, Conditions = VDD = 3.0V. PIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Typ = 0.77. PIC18LFX585/X680, Max = 0.88. PIC18LFX585/X680, Units = mA. PIC18LFX585/X680, Conditions = +25\u00b0C. PIC18LFX585/X680, Conditions = VDD = 3.0V. PIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Typ = 0.72.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Max = 0.88. PIC18LFX585/X680, Units = mA. PIC18LFX585/X680, Conditions = +85\u00b0C. PIC18LFX585/X680, Conditions = VDD = 3.0V. PIC18LFX585/X680, Conditions = . All devices, Typ = 1.90. All devices, Max = 3.00. All devices, Units = mA. All devices, Conditions = -40\u00b0C. All devices, Conditions = VDD = 5.0V. All devices, Conditions = . All devices, Typ = 1.60. All devices, Max = 3.00. All devices, Units = mA. All devices, Conditions = +25\u00b0C. All devices, Conditions = VDD = 5.0V. All devices, Conditions = . All devices, Typ = 1.50. All devices, Max =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n3.00. All devices, Units = mA. All devices, Conditions = +85\u00b0C. All devices, Conditions = VDD = 5.0V. All devices, Conditions = . PIC18FX585/X680, Typ = 1.50. PIC18FX585/X680, Max = 3.30. PIC18FX585/X680, Units = mA. PIC18FX585/X680, Conditions = +125\u00b0C. PIC18FX585/X680, Conditions = VDD = 5.0V. PIC18FX585/X680, Conditions = . PIC18LFX585/X680, Typ = 1.40. PIC18LFX585/X680, Max = 2.20. PIC18LFX585/X680, Units = mA. PIC18LFX585/X680, Conditions = -40\u00b0C.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Conditions = VDD = 3.0V. PIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Typ = 1.40. PIC18LFX585/X680, Max = 2.20. PIC18LFX585/X680, Units = mA. PIC18LFX585/X680, Conditions = +25\u00b0C. PIC18LFX585/X680, Conditions = VDD = 3.0V. PIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Typ = 1.40. PIC18LFX585/X680, Max = 2.20. PIC18LFX585/X680, Units = mA. PIC18LFX585/X680, Conditions = +85\u00b0C.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Conditions = VDD = 3.0V. PIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Typ = 2.30. PIC18LFX585/X680, Max = 3.30. PIC18LFX585/X680, Units = mA. PIC18LFX585/X680, Conditions = -40\u00b0C. PIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Typ = 2.30. PIC18LFX585/X680, Max = 3.30. PIC18LFX585/X680, Units = mA. PIC18LFX585/X680, Conditions = +25\u00b0C. PIC18LFX585/X680, Conditions = .",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Typ = 2.30. PIC18LFX585/X680, Max = 3.30. PIC18LFX585/X680, Units = mA. PIC18LFX585/X680, Conditions = +85\u00b0C. PIC18LFX585/X680, Conditions = . PIC18LFX585/X680, Conditions = . All devices, Typ = 4.50. All devices, Max = 6.60. All devices, Units = mA. All devices, Conditions = -40\u00b0C. All devices, Conditions = VDD = 5.0V. All devices, Conditions = . All devices, Typ = 4.30. All devices, Max = 6.60. All devices, Units = mA. All devices, Conditions = +25\u00b0C. All devices, Conditions = VDD =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n5.0V. All devices, Conditions = . All devices, Typ = 4.30. All devices, Max = 6.60. All devices, Units = mA. All devices, Conditions = +85\u00b0C. All devices, Conditions = VDD = 5.0V. All devices, Conditions = . PIC18FX585/X680, Typ = 5.00. PIC18FX585/X680, Max = 7.70. PIC18FX585/X680, Units = mA. PIC18FX585/X680, Conditions = +125\u00b0C. PIC18FX585/X680, Conditions = VDD = 5.0V. PIC18FX585/X680, Conditions = \nLegend:\nShading of rows is to assist in readability of the table.\nNote",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption. The test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F2585/2680/4585/4680\n27.2 DC Characteristics:",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LF2585/2680/4585/4680\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\nPIC18F2585/2680/4585/4680\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nSupply, Device = Current (I DD) (2,3). Supply, Typ = . Supply, Max = . Supply, Units = . Supply, Conditions = . Supply, Conditions = . Supply, Conditions = . , Device = PIC18FX585/X680. , Typ = 15.00. , Max = 23.00. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 25 MHZ ( PRI_RUN , EC oscillator). , Device = PIC18FX585/X680. , Typ = 20.00. , Max = 31.00. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 25 MHZ ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 30.00. , Max =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n38.00. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 31.00. , Max = 38.00. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 31.00. , Max = 38.00. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 37.00. , Max = 44.00. , Units = mA. , Conditions =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n-40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 38.00. , Max = 44.00. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 39.00. , Max = 44.00. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 7.50. , Max = 16.00. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n4.2V. , Conditions = FOSC = 4 MHZ ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 7.40. , Max = 15.00. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 4 MHZ ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 7.30. , Max = 14.00. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 4 MHZ ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 10.00. , Max = 21.00. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHZ ( PRI_RUN",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nHS+PLL ). , Device = All devices. , Typ = 10.00. , Max = 20.00. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHZ ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 9.70. , Max = 19.00. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHZ ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 17.00. , Max = 35.00. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 10 MHZ ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 17.00. ,",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nMax = 35.00. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 10 MHZ ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 17.00. , Max = 35.00. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 10 MHZ ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 23.00. , Max = 40.00. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 10 MHZ ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 23.00. , Max = 40.00. , Units = mA. , Conditions = +25\u00b0C. , Conditions",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n= VDD = 5.0V. , Conditions = FOSC = 10 MHZ ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 23.00. , Max = 40.00. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 10 MHZ ( PRI_RUN HS+PLL )\nLegend:\nShading of rows is to assist in readability of the table.\nNote",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption. The test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.\n27.2 DC Characteristics:\nPIC18LF2585/2680/4585/4680 (Industrial)\nPIC18F2585/2680/4585/4680\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nSupply, Device = Current (I DD) (2,3). Supply, Typ = . Supply, Max = . Supply, Units = . Supply, Conditions = . Supply, Conditions = . Supply, Conditions = . , Device = PIC18LFX585/X680. , Typ = 160.000. , Max = 220.00. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 160.000. , Max = 220.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 170.000. , Max = 220.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n, Conditions = . , Device = PIC18LFX585/X680. , Typ = 250.00. , Max = 330.00. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 250.00. , Max = 330.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHz. , Device = PIC18LFX585/X680. , Typ = 260.00. , Max = 330.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ = 460.00. , Max =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n550.00. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 470.00. , Max = 550.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 480.00. , Max = 550.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = PIC18FX585/X680. , Typ = 0.79. , Max = 0.92. , Units = mA. , Conditions = +125\u00b0C. , Conditions = . , Conditions = . , Device = PIC18LFX585/X680. , Typ = 640.00. , Max = 715.00. , Units = \uf06d",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nA. , Conditions = -40\u00b0C. , Conditions = . , Conditions = . , Device = PIC18LFX585/X680. , Typ = 650.00. , Max = 715.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 660.00. , Max = 715.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 0.98. , Max = 1.40. , Units = mA. , Conditions = -40\u00b0C. , Conditions = . , Conditions = . , Device = PIC18LFX585/X680. , Typ = 1.00. , Max = 1.40.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n, Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD. , Conditions = FOSC = 4 MHz. , Device = PIC18LFX585/X680. , Typ = 1.00. , Max = 1.40. , Units = mA. , Conditions = +85\u00b0C. , Conditions = . , Conditions = ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ = 1.90. , Max = 2.20. , Units = mA. , Conditions = -40\u00b0C. , Conditions = . , Conditions = . , Device = All devices. , Typ = 1.90. , Max = 2.20. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD. , Conditions = . , Device = All devices. , Typ = 1.90. , Max = 2.20. , Units = mA. , Conditions = +85\u00b0C. , Conditions",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n= . , Conditions = . , Device = PIC18FX585/X680. , Typ = 2.10. , Max = 2.40. , Units = mA. , Conditions = +125\u00b0C. , Conditions = . , Conditions = . , Device = PIC18FX585/X680. , Typ = 9.50. , Max = 11.00. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 25 MHz. , Device = PIC18FX585/X680. , Typ = 14.00. , Max = 16.00. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ = 15.00. , Max = 18.00. , Units =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nmA. , Conditions = -40\u00b0C. , Conditions = VDD = 4.2V. , Conditions = . , Device = All devices. , Typ = 16.00. , Max = 18.00. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 4.2V. , Conditions = . , Device = All devices. , Typ = 16.00. , Max = 18.00. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 40 MHz. , Device = All devices. , Typ = 19.00. , Max = 22.00. , Units = mA. , Conditions = -40\u00b0C. , Conditions = . , Conditions = ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ = 19.00. , Max = 22.00. , Units = mA. , Conditions =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n+25\u00b0C. , Conditions = VDD. , Conditions = . , Device = All devices. , Typ = 19.00. , Max = 22.00. , Units = mA. , Conditions = +85\u00b0C. , Conditions = . , Conditions = \nLegend: Shading of rows is to assist in readability of the table.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption. The test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.\n27.2 DC Characteristics:\nPIC18LF2585/2680/4585/4680\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F2585/2680/4585/4680\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nSupply, Device = Current (I DD) (2,3). Supply, Typ = Current (I DD) (2,3). Supply, Max = Current (I DD) (2,3). Supply, Units = Current (I DD) (2,3). Supply, Conditions = Current (I DD) (2,3). Supply, Conditions = Current (I DD) (2,3). Supply, Conditions = Current (I DD) (2,3). , Device = PIC18LFX585/X680. , Typ = 22.00. , Max = 44.00. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 20.00. , Max = 44.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n2.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 19.00. , Max = 44.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 56.00. , Max = 71.00. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 45.00. , Max = 71.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 41.00. , Max = 71.00. , Units = \uf06d",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nA. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ = 138.00. , Max = 162.00. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 106.00. , Max = 162.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 95.00. , Max = 162.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 6.20. , Max = 24.00. , Units = \uf06d A. , Conditions =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n-40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 6.60. , Max = 24.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 7.70. , Max = 24.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LFX585/X680. , Typ = 9.30. , Max = 33.00. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Conditions = . , Device = PIC18LFX585/X680. , Typ = 9.40. , Max = 33.00.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n, Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Conditions = . , Device = PIC18LFX585/X680. , Typ = 11.00. , Max = 33.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Conditions = . , Device = All devices. , Typ = 17.00. , Max = 50.00. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 17.00. , Max = 50.00. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 20.00. , Max = 50.00. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD =",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n5.0V. , Conditions = \nLegend:\nShading of rows is to assist in readability of the table.",
    "Note\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption. The test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Note\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F2585/2680/4585/4680\n27.2 DC Characteristics:",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(, PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 1.00. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 7.60. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nfor industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40\u00b0C. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nI BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 1.30. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 8.00. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25\u00b0C. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nA \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 1.40. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 8.40. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nBOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +85\u00b0C. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated)",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 1.90. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 11.40. (, Standard Operating Operating",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\ntemperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40\u00b0C. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 3.0V. (, Conditions (unless otherwise stated)",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 2.20. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n, \uf044 I OSCB, \uf044 I AD) = 12.00. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25\u00b0C. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD)",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n= VDD = 3.0V. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 2.40. (, Standard Operating Operating temperature.Standard Operating Operating",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\ntemperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 12.60. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +85\u00b0C. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nI WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 5.50.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(, Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 14.30. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40\u00b0C. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n+125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 5.0V. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nI BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 6.10. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 15.00. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25\u00b0C. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated)",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. (, Standard Operating Operating temperature.Standard Operating Operating",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\ntemperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 6.50. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 15.80. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +85\u00b0C. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n+85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nTimer. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 7.80. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 19.00. (, Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +125\u00b0C. (, Conditions",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . (, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D022A ( \uf044 I BOR), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nI BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Brown-out Reset. D022A ( \uf044 I BOR), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 26.00. D022A ( \uf044 I BOR), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 50.00. D022A ( \uf044 I BOR), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022A ( \uf044 I BOR), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C to +85 \uf0b0 C. D022A ( \uf044 I BOR), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 3.0V. D022A ( \uf044 I BOR), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nI WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D022A ( \uf044 I BOR), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Brown-out Reset. D022A ( \uf044 I BOR), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 27.00. D022A ( \uf044 I BOR), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 52.00. D022A ( \uf044 I BOR), Standard Operating",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nOperating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022A ( \uf044 I BOR), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C to +85 \uf0b0 C. D022A ( \uf044 I BOR), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nAD) = VDD = 5.0V. D022A ( \uf044 I BOR), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D022B ( \uf044 I LVD ), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = High/Low-Voltage Detect. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nBOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 16.00. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 42.00. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C to +85 \uf0b0 C.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nD022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V VDD = 3.0V. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D022B ( \uf044 I LVD ), PIC18LF2585/2680/4585/4680",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = High/Low-Voltage Detect. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 17.00. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 44.00. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022B ( \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nLVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C to +85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated)",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D022B ( \uf044 I LVD ), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = High/Low-Voltage Detect. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 19.00. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nWDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 50.00. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C to +85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n-40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D022B ( \uf044 I LVD ), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = High/Low-Voltage Detect. D022B ( \uf044",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nI LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 19.00. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 50.00. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nWDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +125\u00b0C. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 5.0V. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D025 ( \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nOSCB), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 4.00. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 8.00. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nOSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40\u00b0C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V VDD = 3.0V. D025 ( \uf044 I OSCB), Conditions (unless otherwise",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nstated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 4.00.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nD025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 8.00. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25\u00b0C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nindustrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V VDD = 3.0V. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial,",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nExtended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 4.00. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 8.00. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\notherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +85\u00b0C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V VDD = 3.0V. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n+125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 4.20. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nI AD) = 8.20. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40\u00b0C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nWDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\ntemperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 4.20. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 8.20. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD)",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n= +25\u00b0C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), PIC18LF2585/2680/4585/4680",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 4.20. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 8.20. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +85\u00b0C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n-40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D025 ( \uf044 I OSCB), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 5.00. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nAD) = 10.00. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40\u00b0C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nI BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 5.0V. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nOperating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 5.00. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 10.00. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nAD) = +25\u00b0C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 5.0V. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB),",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 5.00. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 10.00. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nAD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +85\u00b0C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nstated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1 (4). D026 ( \uf044 I AD ), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = A/D Converter. D026 ( \uf044 I AD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 1.0. D026 ( \uf044 I AD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nI WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 2.0. D026 ( \uf044 I AD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C to +85 \uf0b0 C. D026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n+125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V. D026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D026 ( \uf044 I AD ), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = A/D Converter. D026 ( \uf044 I AD ), Standard",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nOperating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 1.0. D026 ( \uf044 I AD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 2.0. D026 ( \uf044 I AD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nOSCB, \uf044 I AD) = -40 \uf0b0 C to +85 \uf0b0 C. D026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 3.0V. D026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D026 ( \uf044 I AD ),",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nPIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = A/D Converter. D026 ( \uf044 I AD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 1.0. D026 ( \uf044 I AD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 2.0. D026 ( \uf044 I AD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nD026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C to +85 \uf0b0 C. D026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 5.0V. D026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D026 ( \uf044 I AD ), PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = A/D Converter. D026 ( \uf044 I AD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 2.0. D026 ( \uf044 I AD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nBOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 8.0. D026 ( \uf044 I AD ), Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +125 \uf0b0 C. D026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nextended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . D026 ( \uf044 I AD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . , PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . , Standard Operating Operating temperature.Standard Operating Operating temperature.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nOSCB, \uf044 I AD) = . , Standard Operating Operating temperature.Standard Operating Operating temperature.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . , Standard Operating Operating temperature.Standard Operating Operating temperature.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . , Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . , Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nextended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = . , Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \nLegend:\nShading of rows is to assist in readability of the table.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption. The test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Power-Down and Supply Current PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "DC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 TA \uf0a3 +85\u00b0C for industrial",
    "DC CHARACTERISTICS\nD030, Symbol = VIL. D030, Characteristic = Input Low Voltage I/O ports: with TTL buffer. D030, Min = VSS - VSS VSS VSS VSS VSS VSS. D030, Max = 0.15 VDD 0.8 0.2 VDD 0.3 VDD 0.8 0.2 VDD 0.3 VDD 0.2 VDD 0.3 0.3 VDD VDD VDD VDD. D030, Units = V V V V V V V V V. D030, Conditions = VDD < 4.5V 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V I 2 C\u2122enabled SMBus enabled. D030A D031 D031A D031B D032, Symbol = . D030A D031 D031A D031B D032, Characteristic = with Schmitt Trigger buffer RC3 and RC4. D030A D031 D031A D031B D032, Min = . D030A D031 D031A D031B D032, Max =",
    "DC CHARACTERISTICS\n. D030A D031 D031A D031B D032, Units = . D030A D031 D031A D031B D032, Conditions = . D033 D033A, Symbol = . D033 D033A, Characteristic = MCLR OSC1 OSC1. D033 D033A, Min = . D033 D033A, Max = . D033 D033A, Units = . D033 D033A, Conditions = HS, HSPLL modes RC, EC modes (1). D033B D034, Symbol = . D033B D034, Characteristic = OSC1. D033B D034, Min = VSS. D033B D034, Max = . D033B D034, Units = . D033B D034, Conditions = XT, LP modes. , Symbol = . , Characteristic = T13CKI Input. , Min = VSS. , Max = . , Units = V. , Conditions = . D040 D040A D041 D041A,",
    "DC CHARACTERISTICS\nSymbol = VIH. D040 D040A D041 D041A, Characteristic = High Voltage I/O ports: with TTL buffer with Schmitt Trigger buffer RC3 and RC4. D040 D040A D041 D041A, Min = 0.25 VDD + 0.8V 2.0 0.8 VDD 0.7 VDD 2.1. D040 D040A D041 D041A, Max = VDD. D040 D040A D041 D041A, Units = V V V V V V. D040 D040A D041 D041A, Conditions = VDD < 4.5V 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V I 2 C\u2122enabled SMBus enabled. D041B D042 D043 D043A D043B, Symbol = . D041B D042 D043 D043A D043B, Characteristic = MCLR OSC1 OSC1. D041B D042 D043 D043A D043B, Min = 0.8",
    "DC CHARACTERISTICS\nVDD 0.7 VDD 0.8 VDD 0.9 VDD. D041B D042 D043 D043A D043B, Max = VDD VDD VDD VDD. D041B D042 D043 D043A D043B, Units = V V V. D041B D042 D043 D043A D043B, Conditions = HS, HSPLL modes EC mode. , Symbol = . , Characteristic = OSC1 OSC1. , Min = 1.6. , Max = VDD. , Units = V V. , Conditions = . D043C D044, Symbol = . D043C D044, Characteristic = T13CKI Input Leakage Current. D043C D044, Min = 1.6. D043C D044, Max = VDD. D043C D044, Units = . D043C D044, Conditions = RC mode (1) XT, LP modes. D060, Symbol = I IL. D060, Characteristic = (2,3) I/O ports.",
    "DC CHARACTERISTICS\nD060, Min = -. D060, Max = \uf0b1 1. D060, Units = \uf06d A. D060, Conditions = VSS \uf0a3\uf020 VPIN \uf0a3\uf020 VDD, Pin at high-impedance Vss \uf0a3\uf020 VPIN \uf0a3\uf020 VDD. D061, Symbol = . D061, Characteristic = MCLR. D061, Min = -. D061, Max = \uf0b1 5. D061, Units = \uf06d A. D061, Conditions = . D063, Symbol = I PU. D063, Characteristic = Weak Pull-up Current. D063, Min = -. D063, Max = \uf0b1 5. D063, Units = \uf06d A. D063, Conditions = Vss \uf0a3\uf020 VPIN \uf0a3\uf020 VDD. , Symbol = . , Characteristic = OSC1. , Min = . , Max = . , Units = . , Conditions = . , Symbol = I PURB. , Characteristic = . , Min = 50. , Max = . , Units = . , Conditions = VDD = 5V, VPIN = VSS. D070, Symbol = . D070, Characteristic = PORTB weak pull-up current.",
    "DC CHARACTERISTICS\nD070, Min = . D070, Max = 400. D070, Units = \uf06d A. D070, Conditions = \nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the\nPIC \u00ae  device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.",
    "27.3 DC Characteristics: PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nD080, DC CHARACTERISTICS.Symbol = VOL. D080, DC CHARACTERISTICS.Characteristic = Output Low Voltage I/O ports. D080, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Min = -. D080, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Max = 0.6. D080, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Units = V. D080, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Conditions = I OL = 8.5 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D083, DC CHARACTERISTICS.Symbol = . D083, DC CHARACTERISTICS.Characteristic = OSC2/CLKO (RC, RCIO, EC, ECIO",
    "27.3 DC Characteristics: PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nmodes). D083, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Min = -. D083, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Max = 0.6. D083, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Units = V. D083, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Conditions = I OL = 1.6 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D090, DC CHARACTERISTICS.Symbol = VOH. D090, DC CHARACTERISTICS.Characteristic = Output High Voltage (3) I/O ports. D090, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for",
    "27.3 DC Characteristics: PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nindustrial.Min = VDD - 0.7. D090, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Max = -. D090, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Units = V. D090, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Conditions = I OH = -3.0 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D092, DC CHARACTERISTICS.Symbol = . D092, DC CHARACTERISTICS.Characteristic = OSC2/CLKO (RC, RCIO, EC, ECIO modes). D092, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Min = VDD - 0.7. D092, Standard Operating Conditions",
    "27.3 DC Characteristics: PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Max = -. D092, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Units = V. D092, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Conditions = I OH = -1.3 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D100 (4), DC CHARACTERISTICS.Symbol = COSC2. D100 (4), DC CHARACTERISTICS.Characteristic = on Output Pins OSC2 pin. D100 (4), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Min = -. D100 (4), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Max = 15. D100",
    "27.3 DC Characteristics: PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\n(4), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Units = pF. D100 (4), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Conditions = In XT, HS and LP modes when external clock is used to drive OSC1. D101, DC CHARACTERISTICS.Symbol = CIO. D101, DC CHARACTERISTICS.Characteristic = All I/O pins and OSC2 (in RC mode). D101, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Min = -. D101, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Max = 50. D101, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Units = pF.",
    "27.3 DC Characteristics: PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nD101, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Conditions = To meet the AC Timing Specifications. D102, DC CHARACTERISTICS.Symbol = CB. D102, DC CHARACTERISTICS.Characteristic = SCL, SDA. D102, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Min = -. D102, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Max = 400. D102, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Units = pF. D102, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 T A \uf0a3 +85\u00b0C for industrial.Conditions = I 2 C\u2122Specification",
    "27.3 DC Characteristics: PIC18F2585/2680/4585/4680 (Industrial) PIC18LF2585/2680/4585/4680 (Industrial) (Continued)\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PIC \u00ae  device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.",
    "TABLE 27-1: MEMORY PROGRAMMING REQUIREMENTS\nDC Characteristics",
    "TABLE 27-1: MEMORY PROGRAMMING REQUIREMENTS\nD110, Sym = VPP. D110, Characteristic = Internal Program Memory Programming Specifications (1) Voltage on MCLR/VPP/RE3 pin. D110, Min = 9.00. D110, Typ\u2020 = -. D110, Max = 13.25. D110, Units = V. D110, Conditions = (Note 3). D113, Sym = I DDP. D113, Characteristic = Supply Current during Programming. D113, Min = -. D113, Typ\u2020 = -. D113, Max = 10. D113, Units = mA. D113, Conditions = . D120, Sym = ED. D120, Characteristic = Data EEPROM Memory Byte Endurance. D120, Min = 100K. D120, Typ\u2020 = 1M. D120, Max = -. D120, Units = E/W. D120, Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D121, Sym = VDRW. D121, Characteristic = VDD for Read/Write.",
    "TABLE 27-1: MEMORY PROGRAMMING REQUIREMENTS\nD121, Min = VMIN. D121, Typ\u2020 = -. D121, Max = 5.5. D121, Units = V. D121, Conditions = Using EECON to read/write VMIN = Minimum operating voltage. D122, Sym = TDEW. D122, Characteristic = Erase/Write Cycle Time. D122, Min = -. D122, Typ\u2020 = 4. D122, Max = -. D122, Units = ms. D122, Conditions = . D123, Sym = TRETD. D123, Characteristic = Characteristic Retention. D123, Min = 40. D123, Typ\u2020 = -. D123, Max = -. D123, Units = Year. D123, Conditions = Provided no other specifications are violated. D124, Sym = TREF. D124, Characteristic = Number of Total Erase/Write Cycles before Refresh (2). D124, Min = 1M. D124, Typ\u2020 = 10M. D124, Max = -.",
    "TABLE 27-1: MEMORY PROGRAMMING REQUIREMENTS\nD124, Units = E/W. D124, Conditions = -40\u00b0C to +85\u00b0C. D130, Sym = EP. D130, Characteristic = Program Flash Memory Cell Endurance. D130, Min = 10K. D130, Typ\u2020 = 100K. D130, Max = -. D130, Units = E/W. D130, Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D131, Sym = VPR. D131, Characteristic = VDD for Read. D131, Min = VMIN. D131, Typ\u2020 = -. D131, Max = 5.5. D131, Units = V. D131, Conditions = VMIN = Minimum operating voltage. D132, Sym = VIE. D132, Characteristic = VDD for Block Erase. D132, Min = 4.5. D132, Typ\u2020 = -. D132, Max = 5.5. D132, Units = V. D132, Conditions = Using ICSP\u2122 port. D132A, Sym",
    "TABLE 27-1: MEMORY PROGRAMMING REQUIREMENTS\n= VIW. D132A, Characteristic = VDD for Externally Timed Erase or Write. D132A, Min = 4.5. D132A, Typ\u2020 = -. D132A, Max = 5.5. D132A, Units = V. D132A, Conditions = Using ICSP port. D132B, Sym = VPEW. D132B, Characteristic = VDD for Self-timed Write. D132B, Min = VMIN. D132B, Typ\u2020 = -. D132B, Max = 5.5. D132B, Units = V. D132B, Conditions = VMIN = Minimum operating voltage. D133, Sym = TIE. D133, Characteristic = ICSP Block Erase Cycle Time. D133, Min = -. D133, Typ\u2020 = 4. D133, Max = -. D133, Units = ms. D133, Conditions = VDD > 4.5V. D133A, Sym = TIW. D133A, Characteristic = ICSP Erase or Write",
    "TABLE 27-1: MEMORY PROGRAMMING REQUIREMENTS\nCycle Time (externally timed). D133A, Min = 1. D133A, Typ\u2020 = -. D133A, Max = -. D133A, Units = ms. D133A, Conditions = VDD > 4.5V. D133A, Sym = TIW. D133A, Characteristic = Self-timed Write Cycle Time. D133A, Min = -. D133A, Typ\u2020 = 2. D133A, Max = -. D133A, Units = ms. D133A, Conditions = . D134, Sym = TRETD. D134, Characteristic = Characteristic Retention. D134, Min = 40. D134, Typ\u2020 = 100. D134, Max = -. D134, Units = Year. D134, Conditions = Provided no other specifications are violated\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial",
    "TABLE 27-1: MEMORY PROGRAMMING REQUIREMENTS\n\u2020 Data in 'Typ' column is at 5.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: These specifications are for programming the on-chip program memory through the use of table write instructions.\n2: Refer to Section 7.8 'Using the Data EEPROM' for a more detailed discussion on data EEPROM endurance.\n3: Required only if Single-Supply Programming is disabled.",
    "TABLE 27-2: COMPARATOR SPECIFICATIONS\nOperating Conditions: 3.0V < VDD < 5.5V, -40\u00b0C < TA < +85\u00b0C (unless otherwise stated).",
    "TABLE 27-2: COMPARATOR SPECIFICATIONS\nD300, Sym = VIOFF. D300, Characteristics = Input Offset Voltage. D300, Min = -. D300, Typ = \u00b1 5.0. D300, Max = \u00b1 10. D300, Units = mV. D300, Comments = . D301, Sym = VICM. D301, Characteristics = Input Common Mode Voltage*. D301, Min = 0. D301, Typ = -. D301, Max = VDD - 1.5. D301, Units = V. D301, Comments = . D302, Sym = CMRR. D302, Characteristics = Common Mode Rejection Ratio*. D302, Min = 55. D302, Typ = -. D302, Max = -. D302, Units = dB. D302, Comments = . 300, Sym = TRESP. 300, Characteristics = Response Time (1)*. 300, Min = -. 300, Typ = 150. 300, Max = 400. 300, Units = ns. 300, Comments = PIC18 F XXXX.",
    "TABLE 27-2: COMPARATOR SPECIFICATIONS\n300A, Sym = . 300A, Characteristics = . 300A, Min = -. 300A, Typ = 150. 300A, Max = 600. 300A, Units = ns. 300A, Comments = PIC18L F XXXX, VDD = 2.0V. 301, Sym = TMC2OV. 301, Characteristics = Comparator Mode Change to Output Valid*. 301, Min = -. 301, Typ = -. 301, Max = 10. 301, Units = \uf06d s. 301, Comments = \n* These parameters are characterized but not tested.\nNote 1: Response time measured with one comparator input at (VDD - 1.5)/2 while the other input transitions from VSS to VDD.",
    "TABLE 27-3: VOLTAGE REFERENCE SPECIFICATIONS\nOperating Conditions: 3.0V < VDD < 5.5V, -40\u00b0C < TA < +85\u00b0C (unless otherwise stated).",
    "TABLE 27-3: VOLTAGE REFERENCE SPECIFICATIONS\nD310, Sym = VRES. D310, Characteristics = Resolution. D310, Min = VDD/24. D310, Typ = -. D310, Max = VDD/32. D310, Units = LSb. D310, Comments = . D311, Sym = VRAA. D311, Characteristics = Absolute Accuracy. D311, Min = - -. D311, Typ = - -. D311, Max = 1/4 1/2. D311, Units = LSb LSb. D311, Comments = Low Range (CVRR = 1 ) High Range (CVRR = 0 ). D312, Sym = VRUR. D312, Characteristics = Unit Resistor Value (R)*. D312, Min = -. D312, Typ = 2k. D312, Max = -. D312, Units = \uf057. D312, Comments = . 310, Sym = T SET. 310, Characteristics = Settling Time (1) *. 310, Min = -. 310, Typ = -.",
    "TABLE 27-3: VOLTAGE REFERENCE SPECIFICATIONS\n310, Max = 10. 310, Units = \uf06d s. 310, Comments = \n* These parameters are characterized but not tested.\nNote 1: Settling time measured while CVRR = 1 and CVR3:CVR0 transitions from ' 0000 ' to ' 1111 '.",
    "TABLE 27-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial",
    "TABLE 27-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 0000. D420, Min = 2.12. D420, Typ\u2020 = 2.17. D420, Max = 2.22. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 0001. D420, Min = 2.18. D420, Typ\u2020 = 2.23. D420, Max = 2.28. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 0010. D420, Min = 2.31. D420, Typ\u2020 = 2.36. D420, Max = 2.42. D420,",
    "TABLE 27-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nUnits = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 0011. D420, Min = 2.38. D420, Typ\u2020 = 2.44. D420, Max = 2.49. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 0100. D420, Min = 2.54. D420, Typ\u2020 = 2.60. D420, Max = 2.66. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 0101. D420, Min = 2.72. D420, Typ\u2020 = 2.79.",
    "TABLE 27-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Max = 2.85. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 0110. D420, Min = 2.82. D420, Typ\u2020 = 2.89. D420, Max = 2.95. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 0111. D420, Min = 3.05. D420, Typ\u2020 = 3.12. D420, Max = 3.19. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 1000. D420, Min = 3.31.",
    "TABLE 27-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Typ\u2020 = 3.39. D420, Max = 3.47. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 1001. D420, Min = 3.46. D420, Typ\u2020 = 3.55. D420, Max = 3.63. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 1010. D420, Min = 3.63. D420, Typ\u2020 = 3.71. D420, Max = 3.80. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV =",
    "TABLE 27-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\n1011. D420, Min = 3.81. D420, Typ\u2020 = 3.90. D420, Max = 3.99. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 1100. D420, Min = 4.01. D420, Typ\u2020 = 4.11. D420, Max = 4.20. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 1101. D420, Min = 4.23. D420, Typ\u2020 = 4.33. D420, Max = 4.43. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low.",
    "TABLE 27-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Characteristic = LVV = 1110. D420, Min = 4.48. D420, Typ\u2020 = 4.59. D420, Max = 4.69. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = HLVD Voltage on VDD Transition High to Low. D420, Characteristic = LVV = 1111. D420, Min = 1.14. D420, Typ\u2020 = 1.20. D420, Max = 1.26. D420, Units = V. D420, Conditions = \n- \u2020 Production tested at TAMB = 25\u00b0C. Specifications over temperature limits ensured by characterization.",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nThe  timing  parameter  symbols  have  been  created using one of the following formats:",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nT, 1. TppS2ppS 2. TppS = T. T, 3. T CC: ST 4. Ts = T. T, (I C specifications only) (I 2 C specifications only) = T. F, 1. TppS2ppS 2. TppS = Frequency. F, 3. T CC: ST 4. Ts = T. F, (I C specifications only) (I 2 C specifications only) = Time. Lowercase letters (pp) and their meanings:, 1. TppS2ppS 2. TppS = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, 3. T CC: ST 4. Ts = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, (I C specifications only) (I 2 C specifications only) = Lowercase letters (pp) and their meanings:. pp, 1. TppS2ppS 2. TppS = pp. pp, 3. T CC: ST 4. Ts = . pp, (I C specifications only) (I 2 C specifications only) = . cc, 1.",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nTppS2ppS 2. TppS = CCP1. cc, 3. T CC: ST 4. Ts = osc. cc, (I C specifications only) (I 2 C specifications only) = OSC1. ck, 1. TppS2ppS 2. TppS = CLKO. ck, 3. T CC: ST 4. Ts = rd. ck, (I C specifications only) (I 2 C specifications only) = RD. cs, 1. TppS2ppS 2. TppS = CS. cs, 3. T CC: ST 4. Ts = rw. cs, (I C specifications only) (I 2 C specifications only) = RD or WR. di, 1. TppS2ppS 2. TppS = SDI. di, 3. T CC: ST 4. Ts = sc. di, (I C specifications only) (I 2 C specifications only) = SCK. do, 1. TppS2ppS 2. TppS = SDO. do, 3. T CC: ST 4. Ts = ss. do, (I C specifications only) (I 2 C specifications only) = SS. dt, 1.",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nTppS2ppS 2. TppS = Data in. dt, 3. T CC: ST 4. Ts = t0. dt, (I C specifications only) (I 2 C specifications only) = T0CKI. io, 1. TppS2ppS 2. TppS = I/O port. io, 3. T CC: ST 4. Ts = t1. io, (I C specifications only) (I 2 C specifications only) = T13CKI. mc, 1. TppS2ppS 2. TppS = MCLR. mc, 3. T CC: ST 4. Ts = wr. mc, (I C specifications only) (I 2 C specifications only) = WR. Uppercase letters and their meanings:, 1. TppS2ppS 2. TppS = Uppercase letters and their meanings:. Uppercase letters and their meanings:, 3. T CC: ST 4. Ts = . Uppercase letters and their meanings:, (I C specifications only) (I 2 C specifications only) = . S, 1. TppS2ppS 2. TppS = S. S, 3. T CC: ST 4. Ts = . S,",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\n(I C specifications only) (I 2 C specifications only) = . F, 1. TppS2ppS 2. TppS = Fall. F, 3. T CC: ST 4. Ts = P. F, (I C specifications only) (I 2 C specifications only) = Period. H, 1. TppS2ppS 2. TppS = High. H, 3. T CC: ST 4. Ts = R. H, (I C specifications only) (I 2 C specifications only) = Rise. I, 1. TppS2ppS 2. TppS = Invalid (High-impedance). I, 3. T CC: ST 4. Ts = V. I, (I C specifications only) (I 2 C specifications only) = Valid. L, 1. TppS2ppS 2. TppS = Low. L, 3. T CC: ST 4. Ts = Z. L, (I C specifications only) (I 2 C specifications only) = High-impedance. I 2 C only, 1. TppS2ppS 2. TppS = I 2 C only. I 2 C only, 3. T CC: ST 4. Ts",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\n= . I 2 C only, (I C specifications only) (I 2 C specifications only) = . AA, 1. TppS2ppS 2. TppS = output access. AA, 3. T CC: ST 4. Ts = High. AA, (I C specifications only) (I 2 C specifications only) = High. BUF, 1. TppS2ppS 2. TppS = Bus free. BUF, 3. T CC: ST 4. Ts = Low. BUF, (I C specifications only) (I 2 C specifications only) = Low. T CC: ST (I 2 C specifications only), 1. TppS2ppS 2. TppS = T CC: ST (I 2 C specifications only). T CC: ST (I 2 C specifications only), 3. T CC: ST 4. Ts = . T CC: ST (I 2 C specifications only), (I C specifications only) (I 2 C specifications only) = . CC, 1. TppS2ppS 2. TppS = CC. CC, 3. T CC: ST 4. Ts = . CC, (I C specifications only) (I 2 C specifications",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nonly) = . HD, 1. TppS2ppS 2. TppS = Hold. HD, 3. T CC: ST 4. Ts = SU. HD, (I C specifications only) (I 2 C specifications only) = Setup. ST, 1. TppS2ppS 2. TppS = ST. ST, 3. T CC: ST 4. Ts = ST. ST, (I C specifications only) (I 2 C specifications only) = ST. DAT, 1. TppS2ppS 2. TppS = DATA input hold. DAT, 3. T CC: ST 4. Ts = STO. DAT, (I C specifications only) (I 2 C specifications only) = Stop condition. STA, 1. TppS2ppS 2. TppS = Start condition. STA, 3. T CC: ST 4. Ts = . STA, (I C specifications only) (I 2 C specifications only) = ",
    "27.4.2 TIMING CONDITIONS\nNote:\nThe temperature and voltages specified in Table 27-5 apply  to  all  timing  specifications  unless  otherwise noted. Figure 27-4 specifies the load conditions for the timing specifications.\nBecause of space limitations, the generic terms 'PIC18FXXXX' and 'PIC18LFXXXX' are used throughout this section to refer to the PIC18F2585/2680/4585/4680 and PIC18LF2585/2680/4585/4680  families  of devices specifically and only those devices.",
    "TABLE 27-5: TEMPERATURE AND VOLTAGE SPECIFICATIONS - AC\nAC CHARACTERISTICS, 1 = Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3\uf020 +85\u00b0C for industrial Operating voltage VDD range as described in DC spec Section 27.1 and Section 27.3 . LF parts operate for industrial temperatures only.",
    "FIGURE 27-4: LOAD CONDITIONS FOR DEVICE TIMING SPECIFICATIONS\nVDD /2 CL RL Pin VSS RL = 464 CL = 50 pF, Load Condition 2 = VSS CL",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\n1A, Symbol = FOSC. 1A, Characteristic = External CLKI Frequency (1). 1A, Min = DC DC DC DC DC 0.1 4 4 5. 1A, Max = 1 25 31.25 40 4 4 25 10 200. 1A, Units = MHz MHz kHz MHz MHz MHz MHz MHz kHz. 1A, Conditions = XT, RC Oscillator modes HS Oscillator mode LP Oscillator mode EC Oscillator mode RC Oscillator mode XT Oscillator mode HS Oscillator mode HSPLL Oscillator mode LP Oscillator mode. 1, Symbol = T OSC. 1, Characteristic = External CLKI Period (1). 1, Min = 1000 40 32 25 250 250 40 100 5. 1, Max = - - - - - 1 250 250. 1, Units = ns ns \uf06d s ns ns \uf06d s ns ns \uf06d s. 1, Conditions = XT, RC Oscillator modes HS Oscillator mode LP Oscillator mode EC Oscillator mode RC Oscillator mode XT Oscillator mode HS Oscillator mode HSPLL",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\nOscillator mode. 2, Symbol = T CY. 2, Characteristic = Instruction Cycle Time (1). 2, Min = 100. 2, Max = -. 2, Units = ns. 2, Conditions = T CY = 4/F OSC. 3, Symbol = T OSL, T OSH. 3, Characteristic = External Clock in (OSC1) High or Low Time. 3, Min = 30 2.5 10. 3, Max = - - -. 3, Units = ns \uf06d s ns. 3, Conditions = XT Oscillator mode LP Oscillator mode HS Oscillator mode. 4, Symbol = T OSR, T OSF. 4, Characteristic = External Clock in (OSC1) Rise or Fall Time. 4, Min = - - -. 4, Max = 20 50 7.5. 4, Units = ns ns ns. 4, Conditions = XT Oscillator mode LP Oscillator mode HS Oscillator mode",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\nNote 1: Instruction cycle period (TCY) equals four times the input oscillator time base period for all configurations except PLL. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min.' values with an external clock applied to the OSC1/CLKI pin. When an external clock input is used, the 'max.' cycle time limit is 'DC' (no clock) for all devices.",
    "TABLE 27-7: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2V TO 5.5V)\nF10, Sym = FOSC. F10, Characteristic = Oscillator Frequency Range. F10, Min = 4. F10, Typ\u2020 = -. F10, Max = 10. F10, Units = MHz. F10, Conditions = HS mode only. F11, Sym = FSYS. F11, Characteristic = On-Chip VCO System Frequency. F11, Min = 16. F11, Typ\u2020 = -. F11, Max = 40. F11, Units = MHz. F11, Conditions = HS mode only. F12, Sym = t rc. F12, Characteristic = PLL Start-up Time (Lock Time). F12, Min = -. F12, Typ\u2020 = -. F12, Max = 2. F12, Units = ms. F12, Conditions = . F13, Sym = \uf044 CLK. F13, Characteristic = CLKO Stability (Jitter). F13, Min = -2. F13, Typ\u2020 = -. F13, Max = +2.",
    "TABLE 27-7: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2V TO 5.5V)\nF13, Units = %. F13, Conditions = \n- \u2020 Data in 'Typ' column is at 5V, 25 C unless otherwise stated. These parameters are for design guidance \uf0b0 only and are not tested.",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n, PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = PIC18LFX585/X680. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -2. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nindustrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +/-1. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 2. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. , Standard Operating",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nConditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +25\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V. , PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n(Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = PIC18LFX585/X680. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -5. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n(1) = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 5. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nA \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -10\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V. , PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nkHz (1) = PIC18LFX585/X680. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -10. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +/-1. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nindustrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 10. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nMHz, 500 kHz, 250 kHz, 125 kHz (1) = -40\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V. , PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = PIC18FX585/X680. , Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -2. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +/-1. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Max.INTOSC",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nAccuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 2. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +25\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\ntemperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 4.5-5.5V. , PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = PIC18FX585/X680. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nindustrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -5. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 5. , Standard Operating Conditions",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n(unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -10\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n+85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 4.5-5.5V. , PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = PIC18FX585/X680. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nkHz (1) = -10. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +/-1. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 10. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\ntemperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -40\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nkHz, 250 kHz, 125 kHz (1) = VDD = 4.5-5.5V. , PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nstated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n(unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nindustrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = PIC18LFX585/X680. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n(1) = 26.562. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 35.938. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated)",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nOperating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = kHz. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -40\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz,",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V. , PIC18LF2585/2680/4585/4680 (Industrial).PIC18F2585/2680/4585/4680 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = PIC18FX585/X680. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 26.562. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n+85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 35.938. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Units.INTOSC Accuracy @Freq = 8",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nMHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = kHz. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -40\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 4.5-5.5V\n- Legend:",
    "TABLE 27-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nShading of rows is to assist in readability of the table.\nNote 1: Frequency calibrated at 25\u00b0C. OSCTUNE register can be used to compensate for temperature drift.\n2: INTRC frequency after calibration.",
    "TABLE 27-9: CLKO AND I/O TIMING REQUIREMENTS\n10, Symbol = T OSH2CKL. 10, Characteristic = OSC1 \uf0ad to CLKO \uf0af. 10, Characteristic = OSC1 \uf0ad to CLKO \uf0af. 10, Min = -. 10, Typ = 75. 10, Max = 200. 10, Units = ns. 10, Conditions = (Note 1). 11, Symbol = T OSH2CKH. 11, Characteristic = OSC1 \uf0ad to CLKO \uf0ad. 11, Characteristic = OSC1 \uf0ad to CLKO \uf0ad. 11, Min = -. 11, Typ = 75. 11, Max = 200. 11, Units = ns. 11, Conditions = (Note 1). 12, Symbol = T CKR. 12, Characteristic = CLKO Rise Time. 12, Characteristic = CLKO Rise Time. 12, Min = -. 12, Typ = 35. 12, Max = 100. 12, Units = ns. 12, Conditions = (Note 1). 13, Symbol = T CKF. 13, Characteristic = CLKO Fall Time. 13, Characteristic = CLKO Fall Time. 13, Min = -. 13, Typ = 35. 13, Max = 100. 13, Units =",
    "TABLE 27-9: CLKO AND I/O TIMING REQUIREMENTS\nns. 13, Conditions = (Note 1). 14, Symbol = T CKL2 IO V. 14, Characteristic = CLKO \uf0af to Port Out Valid. 14, Characteristic = CLKO \uf0af to Port Out Valid. 14, Min = -. 14, Typ = -. 14, Max = 0.5 T CY + 20. 14, Units = ns. 14, Conditions = (Note 1). 15, Symbol = TIO V2CKH. 15, Characteristic = Port In Valid before CLKO \uf0ad. 15, Characteristic = Port In Valid before CLKO \uf0ad. 15, Min = 0.25 T CY + 25. 15, Typ = -. 15, Max = -. 15, Units = ns. 15, Conditions = (Note 1). 16, Symbol = T CKH2IO I. 16, Characteristic = Port In Hold after CLKO \uf0ad. 16, Characteristic = Port In Hold after CLKO \uf0ad. 16, Min = 0. 16, Typ = -. 16, Max = -. 16, Units = ns. 16, Conditions = (Note 1). 17, Symbol = T OSH2IO V. 17, Characteristic = OSC1 \uf0ad",
    "TABLE 27-9: CLKO AND I/O TIMING REQUIREMENTS\n(Q1 cycle) to Port Out Valid. 17, Characteristic = OSC1 \uf0ad (Q1 cycle) to Port Out Valid. 17, Min = -. 17, Typ = 50. 17, Max = 150. 17, Units = ns. 17, Conditions = . 18 18A, Symbol = T OSH2IO I. 18 18A, Characteristic = OSC1 \uf0ad (Q2 cycle) to Port Input Invalid (I/O in hold time). 18 18A, Characteristic = PIC18 F XXXX. 18 18A, Min = 100. 18 18A, Typ = -. 18 18A, Max = -. 18 18A, Units = ns. 18 18A, Conditions = . , Symbol = T OSH2IO I. , Characteristic = OSC1 \uf0ad (Q2 cycle) to Port Input Invalid (I/O in hold time). , Characteristic = PIC18 LF XXXX. , Min = 200. , Typ = -. , Max = -. , Units = ns. , Conditions = VDD = 2.0V. 19, Symbol = TIO V2OSH. 19, Characteristic = Port Input Valid to",
    "TABLE 27-9: CLKO AND I/O TIMING REQUIREMENTS\nOSC1 \uf0ad\uf020 (I/O in setup time). 19, Characteristic = Port Input Valid to OSC1 \uf0ad\uf020 (I/O in setup time). 19, Min = 0. 19, Typ = -. 19, Max = -. 19, Units = ns. 19, Conditions = . 20 20A, Symbol = TIO R. 20 20A, Characteristic = Port Output Rise Time. 20 20A, Characteristic = PIC18 F XXXX. 20 20A, Min = -. 20 20A, Typ = 10. 20 20A, Max = 25. 20 20A, Units = ns. 20 20A, Conditions = . 20 20A, Symbol = TIO R. 20 20A, Characteristic = Port Output Rise Time. 20 20A, Characteristic = PIC18 LF XXXX. 20 20A, Min = -. 20 20A, Typ = -. 20 20A, Max = 60. 20 20A, Units = ns. 20 20A, Conditions = VDD = 2.0V. 21, Symbol = TIO F. 21, Characteristic = Port Output Fall Time. 21, Characteristic = PIC18 F XXXX.",
    "TABLE 27-9: CLKO AND I/O TIMING REQUIREMENTS\n21, Min = -. 21, Typ = 10. 21, Max = 25. 21, Units = ns. 21, Conditions = . 21A, Symbol = TIO F. 21A, Characteristic = Port Output Fall Time. 21A, Characteristic = PIC18 LF XXXX. 21A, Min = -. 21A, Typ = -. 21A, Max = 60. 21A, Units = ns. 21A, Conditions = VDD = 2.0V. 22\u2020, Symbol = TINP. 22\u2020, Characteristic = INT pin High or Low Time. 22\u2020, Characteristic = INT pin High or Low Time. 22\u2020, Min = T CY. 22\u2020, Typ = -. 22\u2020, Max = -. 22\u2020, Units = ns. 22\u2020, Conditions = . 23\u2020, Symbol = TRBP. 23\u2020, Characteristic = RB7:RB4 Change INT High or Low Time. 23\u2020, Characteristic = RB7:RB4 Change INT High or Low Time. 23\u2020, Min = T CY. 23\u2020, Typ = -. 23\u2020, Max = -. 23\u2020, Units =",
    "TABLE 27-9: CLKO AND I/O TIMING REQUIREMENTS\nns. 23\u2020, Conditions = . 24\u2020, Symbol = TRCP. 24\u2020, Characteristic = RC7:RC4 Change INT High or Low Time. 24\u2020, Characteristic = RC7:RC4 Change INT High or Low Time. 24\u2020, Min = 20. 24\u2020, Typ = . 24\u2020, Max = . 24\u2020, Units = ns. 24\u2020, Conditions = \n\u2020 These parameters are asynchronous events not related to any internal clock edges.\nNote 1: Measurements are taken in RC mode, where CLKO output is 4 x TOSC.",
    "TABLE 27-10: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\n30, Sym = TMCL. 30, Characteristic = MCLR Pulse Width (low). 30, Min = 2. 30, Typ = -. 30, Max = -. 30, Units = \uf06d s. 30, Conditions = . 31, Sym = TWDT. 31, Characteristic = Watchdog Timer Time-out Period (no postscaler). 31, Min = 3.4. 31, Typ = 4.00. 31, Max = 4.6. 31, Units = ms. 31, Conditions = . 32, Sym = T OST. 32, Characteristic = Oscillation Start-up Timer Period. 32, Min = 1024 T OSC. 32, Typ = -. 32, Max = 1024 T OSC. 32, Units = -. 32, Conditions = T OSC = OSC1 period. 33, Sym = TPWRT. 33, Characteristic = Power-up Timer Period. 33, Min = 55.6. 33, Typ = 65.5. 33, Max = 75. 33,",
    "TABLE 27-10: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\nUnits = ms. 33, Conditions = . 34, Sym = TIOZ. 34, Characteristic = I/O High-Impedance from MCLR Low or Watchdog Timer Reset. 34, Min = -. 34, Typ = 2. 34, Max = -. 34, Units = \uf06d s. 34, Conditions = . 35, Sym = TBOR. 35, Characteristic = Brown-out Reset Pulse Width. 35, Min = 200. 35, Typ = -. 35, Max = -. 35, Units = \uf06d s. 35, Conditions = VDD \uf0a3 BVDD (see D005). 36, Sym = TIRVST. 36, Characteristic = Time for Internal Reference Voltage to become stable. 36, Min = -. 36, Typ = 20. 36, Max = 50. 36, Units = \uf06d s. 36, Conditions = . 37, Sym = TLVD. 37, Characteristic = High/Low-Voltage Detect Pulse Width. 37, Min = 200. 37, Typ = -. 37, Max = -. 37, Units = \uf06d",
    "TABLE 27-10: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\ns. 37, Conditions = VDD \uf0a3 VLVD. 38, Sym = T CSD. 38, Characteristic = CPU Start-up Time. 38, Min = -. 38, Typ = 10. 38, Max = -. 38, Units = \uf06d s. 38, Conditions = . 39, Sym = TIOBST. 39, Characteristic = Time for INTOSC to stabilize. 39, Min = -. 39, Typ = 1. 39, Max = -. 39, Units = \uf06d s. 39, Conditions = ",
    "TABLE 27-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n40, Sym = TT 0H. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = No prescaler. 40, Min = 0.5 T CY + 20. 40, Max = -. 40, Units = ns. 40, Conditions = . 40, Sym = TT 0H. 40, Characteristic = . 40, Characteristic = . 40, Characteristic = With prescaler. 40, Min = 10. 40, Max = -. 40, Units = ns. 40, Conditions = . 41, Sym = TT 0L. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = No prescaler. 41, Min = 0.5 T CY + 20. 41, Max = -. 41, Units = ns. 41, Conditions = . 41, Sym = TT 0L. 41, Characteristic = . 41, Characteristic = . 41, Characteristic = With prescaler. 41, Min = 10. 41, Max = -. 41, Units = ns. 41, Conditions = . 42,",
    "TABLE 27-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nSym = TT 0P. 42, Characteristic = T0CKI Period. 42, Characteristic = T0CKI Period. 42, Characteristic = No prescaler. 42, Min = T CY + 10. 42, Max = -. 42, Units = ns. 42, Conditions = . 42, Sym = TT 0P. 42, Characteristic = . 42, Characteristic = . 42, Characteristic = With prescaler. 42, Min = Greater of: 20 ns or (T CY + 40)/N. 42, Max = -. 42, Units = ns. 42, Conditions = N=prescalevalue (1, 2, 4,..., 256). 45, Sym = TT 1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Synchronous, no prescaler. 45, Characteristic = Synchronous, no prescaler. 45, Min = 0.5 T CY + 20. 45, Max = -. 45, Units = ns. 45, Conditions = VDD = 2.0V. 45, Sym = TT 1H. 45, Characteristic = T13CKI",
    "TABLE 27-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nHigh Time. 45, Characteristic = Synchronous, with prescaler. 45, Characteristic = PIC18 F XXXX. 45, Min = 10. 45, Max = -. 45, Units = ns. 45, Conditions = VDD = 2.0V. 45, Sym = TT 1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Synchronous, with prescaler. 45, Characteristic = PIC18 LF XXXX. 45, Min = 25. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Sym = TT 1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18 F XXXX. 45, Min = 30. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Sym = TT 1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18 LF XXXX. 45, Min = 50. 45, Max = -. 45, Units =",
    "TABLE 27-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nns. 45, Conditions = VDD = 2.0V. 46, Sym = TT 1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Synchronous, no prescaler. 46, Characteristic = Synchronous, no prescaler. 46, Min = 0.5 T CY + 5. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Sym = TT 1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18 F XXXX. 46, Min = 10. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Sym = TT 1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18 LF XXXX. 46, Min = 25. 46, Max = -. 46, Units = ns. 46, Conditions = VDD = 2.0V. 46, Sym = TT 1L. 46, Characteristic =",
    "TABLE 27-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nT13CKI Low Time. 46, Characteristic = Asynchronous. 46, Characteristic = PIC18 F XXXX. 46, Min = 30. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Sym = TT 1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Asynchronous. 46, Characteristic = PIC18 LF XXXX. 46, Min = 50. 46, Max = -. 46, Units = ns. 46, Conditions = VDD = 2.0V. 47, Sym = TT 1P. 47, Characteristic = T13CKI Input Period. 47, Characteristic = Synchronous. 47, Characteristic = Synchronous. 47, Min = Greater of: 20 ns or (T CY + 40)/N. 47, Max = -. 47, Units = ns. 47, Conditions = N=prescalevalue (1, 2, 4, 8). 47, Sym = TT 1P. 47, Characteristic = T13CKI Input Period. 47, Characteristic = Asynchronous. 47, Characteristic =",
    "TABLE 27-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nAsynchronous. 47, Min = 60. 47, Max = -. 47, Units = ns. 47, Conditions = . , Sym = FT 1. , Characteristic = T13CKI Oscillator Input Frequency Range. , Characteristic = T13CKI Oscillator Input Frequency Range. , Characteristic = T13CKI Oscillator Input Frequency Range. , Min = DC. , Max = 50. , Units = kHz. , Conditions = . 48, Sym = T CKE 2TMRI. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Min = 2 T OSC. 48, Max = 7 T OSC. 48, Units = -. 48, Conditions = ",
    "TABLE 27-12: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\n50, Sym = T CCL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = No prescaler. 50, Characteristic = No prescaler. 50, Min = 0.5 T CY + 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Sym = T CCL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = With prescaler. 50, Characteristic = PIC18 F XXXX. 50, Min = 10. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Sym = T CCL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = With prescaler. 50, Characteristic = PIC18 LF XXXX. 50, Min = 20. 50, Max = -. 50, Units = ns. 50, Conditions = VDD = 2.0V. 51, Sym = T CCH. 51, Characteristic = CCPxInputHigh Time. 51, Characteristic = No prescaler. 51, Characteristic = No",
    "TABLE 27-12: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\nprescaler. 51, Min = 0.5 T CY + 20. 51, Max = -. 51, Units = ns. 51, Conditions = . 51, Sym = T CCH. 51, Characteristic = CCPxInputHigh Time. 51, Characteristic = With prescaler. 51, Characteristic = PIC18 F XXXX. 51, Min = 10. 51, Max = -. 51, Units = ns. 51, Conditions = . 51, Sym = T CCH. 51, Characteristic = CCPxInputHigh Time. 51, Characteristic = With prescaler. 51, Characteristic = PIC18 LF XXXX. 51, Min = 20. 51, Max = -. 51, Units = ns. 51, Conditions = VDD = 2.0V. 52, Sym = T CCP. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Min = 3 T CY + 40 N. 52, Max = -. 52, Units = ns. 52, Conditions = N =",
    "TABLE 27-12: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\nprescale value (1,4 or 16). 53, Sym = T CCR. 53, Characteristic = CCPx Output Fall Time. 53, Characteristic = CCPx Output Fall Time. 53, Characteristic = PIC18 F XXXX. 53, Min = -. 53, Max = 25. 53, Units = ns. 53, Conditions = . 53, Sym = T CCR. 53, Characteristic = . 53, Characteristic = . 53, Characteristic = PIC18 LF XXXX. 53, Min = -. 53, Max = 45. 53, Units = ns. 53, Conditions = VDD = 2.0V. 54, Sym = T CCF. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = PIC18 F XXXX. 54, Min = -. 54, Max = 25. 54, Units = ns. 54, Conditions = . 54, Sym = T CCF. 54, Characteristic = . 54, Characteristic = . 54, Characteristic = PIC18 LF XXXX. 54, Min = -.",
    "TABLE 27-12: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\n54, Max = 45. 54, Units = ns. 54, Conditions = VDD = 2.0V",
    "TABLE 27-13: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F4585/4680)\n62, Symbol = TDT V2WRH. 62, Characteristic = Data In Valid before WR \uf0ad or CS \uf0ad (setup time). 62, Characteristic = Data In Valid before WR \uf0ad or CS \uf0ad (setup time). 62, Min = 20. 62, Max = -. 62, Units = ns. 62, Conditions = . 63, Symbol = TWRH2DTI. 63, Characteristic = WR \uf0ad or CS \uf0ad to Data-In Invalid. 63, Characteristic = PIC18 F XXXX. 63, Min = 20. 63, Max = -. 63, Units = ns. 63, Conditions = . , Symbol = . , Characteristic = (hold time). , Characteristic = PIC18 LF XXXX. , Min = 35. , Max = -. , Units = ns. , Conditions = VDD = 2.0V. 64, Symbol = TRDL2 DT V. 64, Characteristic = RD \uf0af and CS \uf0af to Data-Out Valid. 64, Characteristic = RD \uf0af and CS \uf0af to Data-Out Valid. 64, Min = -. 64, Max = 80. 64, Units = ns. 64, Conditions = . 65, Symbol =",
    "TABLE 27-13: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F4585/4680)\nTRDH2DTI. 65, Characteristic = RD \uf0ad or CS \uf0af to Data-Out Invalid. 65, Characteristic = RD \uf0ad or CS \uf0af to Data-Out Invalid. 65, Min = 10. 65, Max = 30. 65, Units = ns. 65, Conditions = . 66, Symbol = TIBF INH. 66, Characteristic = Inhibit of the IBF Flag bit being Cleared from WR \uf0ad or CS \uf0ad. 66, Characteristic = Inhibit of the IBF Flag bit being Cleared from WR \uf0ad or CS \uf0ad. 66, Min = -. 66, Max = 3 T CY. 66, Units = . 66, Conditions = ",
    "FIGURE 27-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\n)\nNote: Refer to Figure 27-4 for load conditions.\nTABLE 27-14: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0\n)",
    "FIGURE 27-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\n73, Symbol = TDI V2SCH, TDI V2SCL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 74, Symbol = T SCH2DI L, T SCL2DI L. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XXXX. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXXX. , Min = -. , Max = 45. , Units = ns. , Conditions = VDD = 2.0V.",
    "FIGURE 27-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\n76, Symbol = TDOF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = T SCR. 78, Characteristic = SCK Output Rise Time. 78, Characteristic = PIC18 F XXXX. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXXX. , Min = -. , Max = 45. , Units = ns. , Conditions = VDD = 2.0V. 79, Symbol = T SCF. 79, Characteristic = SCK Output Fall Time. 79, Characteristic = SCK Output Fall Time. 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = T SCH2DOV,. 80, Characteristic = SDO Data Output Valid after. 80, Characteristic = PIC18 F XXXX. 80, Min = -. 80, Max",
    "FIGURE 27-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\n= 50. 80, Units = ns. 80, Conditions = . , Symbol = T SCL2DOV. , Characteristic = SCK Edge. , Characteristic = PIC18 LF XXXX. , Min = -. , Max = 100. , Units = ns. , Conditions = VDD = 2.0V",
    "FIGURE 27-13: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\n)\nNote: Refer to Figure 27-4 for load conditions.",
    "TABLE 27-15: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1\n)",
    "TABLE 27-15: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1\n73, Symbol = TDI V2SCH, TDI V2SCL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 74, Symbol = T SCH2DI L, T SCL2DI L. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XXXX. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 LF XXXX. 75, Min = . 75, Max = 45. 75,",
    "TABLE 27-15: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1\nUnits = ns. 75, Conditions = VDD = 2.0V. 76, Symbol = TDOF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = T SCR. 78, Characteristic = SCK Output Rise Time. 78, Characteristic = PIC18 F XXXX. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = T SCR. 78, Characteristic = SCK Output Rise Time. 78, Characteristic = PIC18 LF XXXX. 78, Min = . 78, Max = 45. 78, Units = ns. 78, Conditions = VDD = 2.0V. 79, Symbol = T SCF. 79, Characteristic = SCK Output Fall Time. 79, Characteristic = SCK Output Fall Time. 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = T",
    "TABLE 27-15: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1\nSCH2DOV, T SCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 F XXXX. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = T SCH2DOV, T SCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 LF XXXX. 80, Min = . 80, Max = 100. 80, Units = ns. 80, Conditions = VDD = 2.0V. 81, Symbol = TDOV2SCH, TDOV2SCL. 81, Characteristic = SDO Data Output Setup to SCK Edge. 81, Characteristic = SDO Data Output Setup to SCK Edge. 81, Min = T CY. 81, Max = -. 81, Units = ns. 81, Conditions = ",
    "FIGURE 27-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0\n)",
    "TABLE 27-16: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n)",
    "TABLE 27-16: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n70, Symbol = T SS L2SCH, T SS L2SCL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = T SCH. 71, Characteristic = SCK Input High Time. 71, Characteristic = Continuous. 71, Min = 1.25 T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = T SCH. 71A, Characteristic = SCK Input High Time. 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = T SCL. 72, Characteristic = SCK Input Low Time. 72, Characteristic = Continuous. 72, Min = 1.25 T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol =",
    "TABLE 27-16: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nT SCL. 72A, Characteristic = SCK Input Low Time. 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TDI V2SCH, TDI V2SCL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte1 to the First Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte1 to the First Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = T SCH2DI L, T SCL2DI L. 74, Characteristic = Hold Time of",
    "TABLE 27-16: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nSDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XXXX. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 LF XXXX. 75, Min = . 75, Max = 45. 75, Units = ns. 75, Conditions = VDD = 2.0V. 76, Symbol = TDOF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = T SS H2DOZ. 77, Characteristic = SS \uf0ad to SDO Output High-Impedance. 77, Characteristic",
    "TABLE 27-16: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n= SS \uf0ad to SDO Output High-Impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 80, Symbol = T SC H2DOV,. 80, Characteristic = SDO Data Output Valid after SCK Edge PIC18 F XXXX. 80, Characteristic = SDO Data Output Valid after SCK Edge PIC18 F XXXX. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = T SC H2DOV,. 80, Characteristic = T SC L2 DOV. 80, Characteristic = PIC18 LF XXXX. 80, Min = . 80, Max = 100. 80, Units = ns. 80, Conditions = VDD = 2.0V. 83, Symbol = TscH2ssH, TscL2ssH. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Min = 1.5 T CY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = ",
    "TABLE 27-16: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nNote 1:\nRequires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "FIGURE 27-15: EXAMPLE SPI SLAVE MODE TIMING (CKE = 1\n)",
    "TABLE 27-17: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n)",
    "TABLE 27-17: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n70, Symbol = T SS L2SCH, T SS L2SCL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71 71A, Symbol = T SCH. 71 71A, Characteristic = SCK Input High Time. 71 71A, Characteristic = Continuous. 71 71A, Min = 1.25 T CY + 30. 71 71A, Max = -. 71 71A, Units = ns. 71 71A, Conditions = . 71 71A, Symbol = T SCH. 71 71A, Characteristic = SCK Input High Time. 71 71A, Characteristic = Single Byte. 71 71A, Min = 40. 71 71A, Max = -. 71 71A, Units = ns. 71 71A, Conditions = (Note 1). 72 72A, Symbol = T SCL. 72 72A, Characteristic = SCK Input Low Time. 72 72A, Characteristic = Continuous. 72 72A, Min = 1.25 T",
    "TABLE 27-17: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\nCY + 30. 72 72A, Max = -. 72 72A, Units = ns. 72 72A, Conditions = . 72 72A, Symbol = T SCL. 72 72A, Characteristic = SCK Input Low Time. 72 72A, Characteristic = Single Byte. 72 72A, Min = 40. 72 72A, Max = -. 72 72A, Units = ns. 72 72A, Conditions = (Note 1). 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the fIrst Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the fIrst Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = T SCH2DI L, T SCL2DI L. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max =",
    "TABLE 27-17: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n-. 74, Units = ns. 74, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XXXX. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 LF XXXX. 75, Min = . 75, Max = 45. 75, Units = ns. 75, Conditions = VDD = 2.0V. 76, Symbol = TDOF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = T SS H2DOZ. 77, Characteristic = SS \uf0ad to SDO Output High-Impedance. 77, Characteristic = SS \uf0ad to SDO Output High-Impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 80, Symbol =",
    "TABLE 27-17: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\nT SC H2DOV, T SC L2 DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 F XXXX. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = T SC H2DOV, T SC L2 DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 LF XXXX. 80, Min = -. 80, Max = 100. 80, Units = ns. 80, Conditions = VDD = 2.0V. 82, Symbol = T SS L2 DOV. 82, Characteristic = SDO Data Output Valid after SS \uf0af Edge. 82, Characteristic = PIC18 F XXXX. 82, Min = -. 82, Max = 50. 82, Units = ns. 82, Conditions = . 82, Symbol = T SS L2 DOV. 82, Characteristic = SDO Data Output Valid after SS \uf0af Edge. 82, Characteristic = PIC18 LF XXXX. 82, Min = -. 82, Max = 100. 82,",
    "TABLE 27-17: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\nUnits = ns. 82, Conditions = VDD = 2.0V. 83, Symbol = T SC H2SSH, T SC L2 SS H. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Min = 1.5 T CY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = \nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "TABLE 27-18: I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 4700. 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. , Symbol = . , Characteristic = . , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = . 91, Symbol = THD: STA. 91, Characteristic = Start Condition. 91, Characteristic = 100 kHz mode. 91, Min = 4000. 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first. , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = clock pulse is generated. 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition. 92, Characteristic = 100 kHz mode. 92, Min = 4700. 92, Max = -. 92, Units = ns. 92, Conditions = . , Symbol = . ,",
    "TABLE 27-18: I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\nCharacteristic = Setup Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = . 93, Symbol = THD: STO. 93, Characteristic = Stop Condition. 93, Characteristic = 100 kHz mode. 93, Min = 4000. 93, Max = -. 93, Units = ns. 93, Conditions = . , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = ",
    "TABLE 27-19: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 4.0. 100, Max = -. 100, Units = \uf06d s. 100, Conditions = PIC18FXXXX must operate at a minimum of 1.5 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 0.6. 100, Max = -. 100, Units = \uf06d s. 100, Conditions = PIC18FXXXX must operate at a minimum of 10 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = SSP module. 100, Min = 1.5 T CY. 100, Max = -. 100, Units = . 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 4.7. 101, Max = -. 101, Units = \uf06d s. 101, Conditions = PIC18FXXXX must operate at a minimum of 1.5 MHz. 101, Symbol = TLOW.",
    "TABLE 27-19: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n101, Characteristic = Clock Low Time. 101, Characteristic = 400 kHz mode. 101, Min = 1.3. 101, Max = -. 101, Units = \uf06d s. 101, Conditions = PIC18FXXXX must operate at a minimum of 10 MHz. 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = SSP module. 101, Min = 1.5 T CY. 101, Max = -. 101, Units = . 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic =",
    "TABLE 27-19: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = . 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 4.7. 90, Max = -. 90, Units = \uf06d s. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 0.6. 90, Max = -. 90, Units = \uf06d s. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min =",
    "TABLE 27-19: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n4.0. 91, Max = -. 91, Units = \uf06d s. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 0.6. 91, Max = -. 91, Units = \uf06d s. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = \uf06d s. 106, Conditions = . 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107, Units = ns. 107, Conditions",
    "TABLE 27-19: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n= (Note 2). 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 4.7. 92, Max = -. 92, Units = \uf06d s. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 0.6. 92, Max = -. 92, Units = \uf06d s. 92, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109, Units = ns. 109, Conditions = (Note 1). 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 400 kHz mode.",
    "TABLE 27-19: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = (Note 1). 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = \uf06d s. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = \uf06d s. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus Capacitive Loading. D102, Characteristic = Bus Capacitive Loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = ",
    "TABLE 27-19: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\nNote 1: As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2: A Fast mode I 2 C\u2122 bus device can be used in a Standard mode I 2 C bus system but the requirement,\nTSU:DAT \uf0b3 250 ns, must then be met. This will automatically be the case if the device does not stretch the LOW period of the SCL signal. If such a device does stretch the LOW period of the SCL signal, it must output the next data bit to the SDA line,\nTR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification), before the SCL line is released.",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n\nNote 1: Maximum pin capacitance = 10 pF for all I 2 C pins.",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n90, Symbol = T SU: STA. 90, Characteristic = Start condition. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = . 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD: STA. 91, Characteristic = Start Condition. 91, Characteristic = 100 kHz mode. 91, Min = 2(T OSC)(BRG + 1).",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = . 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ns. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n= Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ns. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = . 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ns. 92, Conditions = . 93, Symbol = THD: STO. 93, Characteristic = Stop Condition. 93, Characteristic = 100 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = . 93, Symbol = THD: STO. 93, Characteristic = Hold Time. 93, Characteristic = 400 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = . 93, Symbol = THD: STO. 93, Characteristic =",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n. 93, Characteristic = 1 MHz mode (1). 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = ",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 1 MHz mode (1). 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nTime. 101, Characteristic = 400 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 1 MHz mode (1). 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nand SCL Rise Time. 102, Characteristic = 1 MHz mode (1). 102, Min = -. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 1 MHz mode (1). 103, Min = -. 103, Max = 100. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\npF. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min = 2(T",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nOSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD: DAT.",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n106, Characteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = ms. 106, Conditions = . 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min =",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109, Units = ns. 109, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 400 kHz mode. 109, Min = -. 109, Max = 1000. 109, Units = ns. 109, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 1 MHz mode (1). 109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = . 110,",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nSymbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus Capacitive Loading. D102, Characteristic = Bus Capacitive Loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = ",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nNote 1: Maximum pin capacitance = 10 pF for all I 2 C pins.\n2: A Fast mode I 2 C\u2122 bus device can be used in a Standard mode I 2 C bus system, but parameter #107 \uf0b3 250 ns must then be met. This will automatically be the case if the device does not stretch the LOW period of the SCL signal. If such a device does stretch the LOW period of the SCL signal, it must output the next data bit to the SDA line, parameter #102 + parameter #107 = 1000 + 250 = 1250 ns (for 100 kHz mode), before the SCL line is released.",
    "TABLE 27-22: EUSART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n120, Symbol = T CK H2DTV. 120, Characteristic = SYNC XMIT (MASTER & SLAVE) Clock High to Data Out Valid. 120, Characteristic = PIC18 F XXXX. 120, Min = -. 120, Max = 40. 120, Units = ns. 120, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXXX. , Min = -. , Max = 100. , Units = ns. , Conditions = VDD = 2.0V. 121, Symbol = T CKRF. 121, Characteristic = Clock Out Rise Time and Fall Time. 121, Characteristic = PIC18 F XXXX. 121, Min = -. 121, Max = 20. 121, Units = ns. 121, Conditions = . , Symbol = . , Characteristic = (Master mode). , Characteristic = PIC18 LF XXXX. , Min = -. , Max = 50. , Units = ns. , Conditions = VDD = 2.0V. 122, Symbol = TDTRF. 122, Characteristic = Data Out Rise Time and Fall Time. 122, Characteristic = PIC18 F XXXX. 122, Min =",
    "TABLE 27-22: EUSART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n-. 122, Max = 20. 122, Units = ns. 122, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXXX. , Min = -. , Max = 50. , Units = ns. , Conditions = VDD = 2.0V",
    "TABLE 27-23: EUSART SYNCHRONOUS RECEIVE REQUIREMENTS\n125, Symbol = TDTV2CKL. 125, Characteristic = SYNC RCV (MASTER & SLAVE) Data Hold before CK \uf0af (DT hold time). 125, Min = 10. 125, Max = -. 125, Units = ns. 125, Conditions = . 126, Symbol = T CKL2DTL. 126, Characteristic = Data Hold after CK \uf0af (DT hold time). 126, Min = 15. 126, Max = -. 126, Units = ns. 126, Conditions = ",
    "TABLE 27-24: A/D CONVERTER CHARACTERISTICS: PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nA01, Sym = NR. A01, Characteristic = Resolution. A01, Characteristic = Resolution. A01, Min = -. A01, Typ = -. A01, Max = 10. A01, Units = bit. A01, Conditions = \uf044 VREF \uf0b3 3.0V. A03, Sym = EIL. A03, Characteristic = Integral Linearity Error. A03, Characteristic = Integral Linearity Error. A03, Min = -. A03, Typ = -. A03, Max = <\u00b11. A03, Units = LSb. A03, Conditions = \uf044 VREF \uf0b3 3.0V. A04, Sym = EDL. A04, Characteristic = Differential Linearity Error. A04, Characteristic = Differential Linearity Error. A04, Min = -. A04, Typ = -. A04, Max = <\u00b11. A04, Units =",
    "TABLE 27-24: A/D CONVERTER CHARACTERISTICS: PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nLSb. A04, Conditions = \uf044 VREF \uf0b3 3.0V. A06, Sym = EOFF. A06, Characteristic = Offset Error. A06, Characteristic = Offset Error. A06, Min = -. A06, Typ = -. A06, Max = <\u00b12. A06, Units = LSb. A06, Conditions = VREF = VSS and VDD. A07, Sym = EGN. A07, Characteristic = Gain Error. A07, Characteristic = Gain Error. A07, Min = -. A07, Typ = -. A07, Max = <\u00b11. A07, Units = LSb. A07, Conditions = \uf044 VREF \uf0b3 3.0V. A10, Sym = -. A10, Characteristic = Monotonicity. A10, Characteristic = Monotonicity. A10, Min = Guaranteed (1).",
    "TABLE 27-24: A/D CONVERTER CHARACTERISTICS: PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nA10, Typ = Guaranteed (1). A10, Max = Guaranteed (1). A10, Units = -. A10, Conditions = . A20, Sym = \uf044 VREF. A20, Characteristic = Reference Voltage Range (V REFH - VREFL ). A20, Characteristic = Reference Voltage Range (V REFH - VREFL ). A20, Min = 3. A20, Typ = -. A20, Max = AVDD - AVSS. A20, Units = V. A20, Conditions = For 10-bit resolution. A21, Sym = VREFH. A21, Characteristic = Reference Voltage High. A21, Characteristic = Reference Voltage High. A21, Min = AVSS + 3.0V. A21, Typ = -. A21, Max = AVDD + 0.3V. A21, Units = V. A21, Conditions = For 10-bit resolution. A22, Sym =",
    "TABLE 27-24: A/D CONVERTER CHARACTERISTICS: PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nVREFL. A22, Characteristic = Reference Voltage Low. A22, Characteristic = Reference Voltage Low. A22, Min = AVSS - 0.3V. A22, Typ = -. A22, Max = AVDD - 3.0V. A22, Units = V. A22, Conditions = For 10-bit resolution. A25, Sym = VAIN. A25, Characteristic = Analog Input Voltage. A25, Characteristic = Analog Input Voltage. A25, Min = VREFL. A25, Typ = -. A25, Max = VREFH. A25, Units = V. A25, Conditions = . A28, Sym = AVDD. A28, Characteristic = Analog Supply Voltage. A28, Characteristic = Analog Supply Voltage. A28, Min = VDD - 0.3. A28, Typ = -. A28, Max = VDD + 0.3. A28, Units = V. A28, Conditions =",
    "TABLE 27-24: A/D CONVERTER CHARACTERISTICS: PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n. A29, Sym = AVSS. A29, Characteristic = Analog Supply Voltage. A29, Characteristic = Analog Supply Voltage. A29, Min = VSS - 0.3. A29, Typ = -. A29, Max = VSS + 0.3. A29, Units = V. A29, Conditions = . A30, Sym = ZAIN. A30, Characteristic = Recommended Impedance of Analog Voltage Source. A30, Characteristic = Recommended Impedance of Analog Voltage Source. A30, Min = -. A30, Typ = -. A30, Max = 2.5. A30, Units = k \uf057. A30, Conditions = . A40, Sym = I AD. A40, Characteristic = A/D Conversion Current (V DD). A40, Characteristic = PIC18 F XXXX. A40, Min = -. A40, Typ = 180. A40, Max = -. A40, Units = \uf06d A.",
    "TABLE 27-24: A/D CONVERTER CHARACTERISTICS: PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\nA40, Conditions = Average current consumption when A/D is on (Note 2). , Sym = . , Characteristic = . , Characteristic = PIC18 LF XXXX. , Min = -. , Typ = 90. , Max = -. , Units = \uf06d A. , Conditions = VDD = 2.0V; average current consumption when A/D is on (Note 2). A50, Sym = I REF. A50, Characteristic = VREF Input Current (Note 3). A50, Characteristic = VREF Input Current (Note 3). A50, Min = - -. A50, Typ = - -. A50, Max = \u00b15 \u00b1150. A50, Units = \uf06d A \uf06d A. A50, Conditions = During VAIN acquisition. During A/D conversion cycle.\nNote 1: The A/D conversion result never decreases with an increase in the input voltage and has no missing codes.",
    "TABLE 27-24: A/D CONVERTER CHARACTERISTICS: PIC18F2585/2680/4585/4680 (INDUSTRIAL) PIC18LF2585/2680/4585/4680 (INDUSTRIAL)\n2: When A/D is off, it will not consume any current other than minor leakage current. The power-down current spec includes any such leakage from the A/D module.\n3: VREFH current is from RA3/AN3/VREF+ pin or AVDD, whichever is selected as the VREFH source. VREFL current is from RA2/AN2/VREF- pin or AVSS, whichever is selected as the VREFL source.",
    "FIGURE 27-22: A/D CONVERSION TIMING\nNote 1: If the A/D clock source is selected as RC, a time of TCY is added before the A/D clock starts.\nThis allows the SLEEP instruction to be executed.\n2: This is a minimal RC delay (typically 100 ns), which also disconnects the holding capacitor from the analog input.",
    "TABLE 27-25: A/D CONVERSION REQUIREMENTS\n130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18 F XXXX. 130, Min = 0.7. 130, Max = 25.0 (1). 130, Units = \uf06d s. 130, Conditions = T OSC based, VREF \uf0b3 3.0V. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18 LF XXXX. 130, Min = 1.4. 130, Max = 25.0 (1). 130, Units = \uf06d s. 130, Conditions = VDD = 2.0V; T OSC based, VREF full range. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18 F XXXX. 130, Min = -. 130, Max = 1. 130, Units = \uf06d s. 130, Conditions = A/D RC mode. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18 LF XXXX. 130, Min = -. 130, Max = 3. 130, Units = \uf06d s. 130,",
    "TABLE 27-25: A/D CONVERSION REQUIREMENTS\nConditions = VDD = 2.0V; A/D RC mode. 131, Symbol = T CNV. 131, Characteristic = Conversion Time (not including acquisition time) (Note 2). 131, Characteristic = Conversion Time (not including acquisition time) (Note 2). 131, Min = 11. 131, Max = 12. 131, Units = T AD. 131, Conditions = . 132, Symbol = T ACQ. 132, Characteristic = Acquisition Time (Note 3). 132, Characteristic = Acquisition Time (Note 3). 132, Min = 1.4. 132, Max = -. 132, Units = \uf06d s. 132, Conditions = -40 \uf0b0 C to +85 \uf0b0 C. 135, Symbol = T SWC. 135, Characteristic = Switching Time from Convert \uf0ae Sample. 135, Characteristic = Switching Time from Convert \uf0ae Sample. 135, Min = -. 135, Max = (Note 4). 135, Units = . 135, Conditions = . 136, Symbol = T AMP. 136, Characteristic = Amplifier Settling Time (Note 5). 136, Characteristic = Amplifier Settling Time (Note 5). 136, Min = 1. 136, Max = -. 136, Units = \uf06d s.",
    "TABLE 27-25: A/D CONVERSION REQUIREMENTS\n136, Conditions = This maybeusedif the 'new' input voltage has not changed by more than 1 LSb (i.e., 5 mV@5.12V) from the last sampled voltage (as stated on CHOLD).\nNote\n1: The time of the A/D clock period is dependent on the device frequency and the TAD clock divider.\n2: ADRES register may be read on the following TCY cycle.\n3: The time for the holding capacitor to acquire the 'New' input voltage when the voltage changes full scale after the conversion (AVDD to AVSS or AVSS to AVDD). The source impedance ( RS ) on the input channels is 50 \uf057 .\n4: On the following cycle of the device clock.\n5: See Section 19.0 '10-Bit Analog-to-Digital Converter (A/D) Module' for minimum conditions when input voltage has changed more than 1 LSb.",
    "Legend:\nXX...X\nCustomer-specific information\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\nPb-free JEDEC designator for Matte Tin (Sn)\n*\nThis package is Pb-free. The Pb-free JEDEC designator (     ) can be found on the outer packaging for this package. 3 e\n3\ne",
    "Note :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.",
    "28.2 Package Details\nThe following sections give the technical details of the packages.",
    "28-Lead Skinny Plastic Dual In-Line (SP) - 300 mil Body [SPDIP]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "28-Lead Skinny Plastic Dual In-Line (SP) - 300 mil Body [SPDIP]\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, INCHES.MIN = 28. Number of Pins, INCHES.NOM = 28. Number of Pins, INCHES.MAX = 28. Pitch, Units.Dimension Limits = e. Pitch, INCHES.MIN = .100 BSC. Pitch, INCHES.NOM = .100 BSC. Pitch, INCHES.MAX = .100 BSC. Top to Seating Plane, Units.Dimension Limits = A. Top to Seating Plane, INCHES.MIN = -. Top to Seating Plane, INCHES.NOM = -. Top to Seating Plane, INCHES.MAX = .200. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, INCHES.MIN = .120. Molded Package Thickness, INCHES.NOM = .135. Molded Package Thickness, INCHES.MAX = .150. Base to Seating Plane, Units.Dimension Limits = A1. Base to Seating Plane, INCHES.MIN = .015. Base to Seating Plane, INCHES.NOM = -. Base to Seating Plane, INCHES.MAX = -. Shoulder to Shoulder Width, Units.Dimension Limits = E. Shoulder to",
    "28-Lead Skinny Plastic Dual In-Line (SP) - 300 mil Body [SPDIP]\nShoulder Width, INCHES.MIN = .290. Shoulder to Shoulder Width, INCHES.NOM = .310. Shoulder to Shoulder Width, INCHES.MAX = .335. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, INCHES.MIN = .240. Molded Package Width, INCHES.NOM = .285. Molded Package Width, INCHES.MAX = .295. Overall Length, Units.Dimension Limits = D. Overall Length, INCHES.MIN = 1.345. Overall Length, INCHES.NOM = 1.365. Overall Length, INCHES.MAX = 1.400. Tip to Seating Plane, Units.Dimension Limits = L. Tip to Seating Plane, INCHES.MIN = .110. Tip to Seating Plane, INCHES.NOM = .130. Tip to Seating Plane, INCHES.MAX = .150. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, INCHES.MIN = .008. Lead Thickness, INCHES.NOM = .010. Lead Thickness, INCHES.MAX = .015. Upper Lead Width, Units.Dimension Limits = b1. Upper Lead Width, INCHES.MIN",
    "28-Lead Skinny Plastic Dual In-Line (SP) - 300 mil Body [SPDIP]\n= .040. Upper Lead Width, INCHES.NOM = .050. Upper Lead Width, INCHES.MAX = .070. Lower Lead Width, Units.Dimension Limits = b. Lower Lead Width, INCHES.MIN = .014. Lower Lead Width, INCHES.NOM = .018. Lower Lead Width, INCHES.MAX = .022. Overall Row Spacing \u00a7, Units.Dimension Limits = eB. Overall Row Spacing \u00a7, INCHES.MIN = -. Overall Row Spacing \u00a7, INCHES.NOM = -. Overall Row Spacing \u00a7, INCHES.MAX = .430",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010\" per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nMicrochip Technology Drawing C04-070B",
    "28-Lead Plastic Small Outline (SO) - Wide, 7.50 mm Body [SOIC]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "28-Lead Plastic Small Outline (SO) - Wide, 7.50 mm Body [SOIC]\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, MILLMETERS.MIN = 28. Number of Pins, MILLMETERS.NOM = 28. Number of Pins, MILLMETERS.MAX = 28. Pitch, Units.Dimension Limits = e. Pitch, MILLMETERS.MIN = 1.27 BSC. Pitch, MILLMETERS.NOM = 1.27 BSC. Pitch, MILLMETERS.MAX = 1.27 BSC. Overall Height, Units.Dimension Limits = A. Overall Height, MILLMETERS.MIN = -. Overall Height, MILLMETERS.NOM = -. Overall Height, MILLMETERS.MAX = 2.65. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, MILLMETERS.MIN = 2.05. Molded Package Thickness, MILLMETERS.NOM = -. Molded Package Thickness, MILLMETERS.MAX = -. Standoff \u00a7, Units.Dimension Limits = A1. Standoff \u00a7, MILLMETERS.MIN = 0.10. Standoff \u00a7, MILLMETERS.NOM = -. Standoff \u00a7,",
    "28-Lead Plastic Small Outline (SO) - Wide, 7.50 mm Body [SOIC]\nMILLMETERS.MAX = 0.30. Overall Width, Units.Dimension Limits = E. Overall Width, MILLMETERS.MIN = 10.30 BSC. Overall Width, MILLMETERS.NOM = 10.30 BSC. Overall Width, MILLMETERS.MAX = 10.30 BSC. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, MILLMETERS.MIN = 7.50 BSC. Molded Package Width, MILLMETERS.NOM = 7.50 BSC. Molded Package Width, MILLMETERS.MAX = 7.50 BSC. Overall Length, Units.Dimension Limits = D. Overall Length, MILLMETERS.MIN = 17.90 BSC. Overall Length, MILLMETERS.NOM = 17.90 BSC. Overall Length, MILLMETERS.MAX = 17.90 BSC. Chamfer (optional), Units.Dimension Limits = h. Chamfer (optional), MILLMETERS.MIN = 0.25. Chamfer (optional), MILLMETERS.NOM = -. Chamfer (optional), MILLMETERS.MAX =",
    "28-Lead Plastic Small Outline (SO) - Wide, 7.50 mm Body [SOIC]\n0.75. Foot Length, Units.Dimension Limits = L. Foot Length, MILLMETERS.MIN = 0.40. Foot Length, MILLMETERS.NOM = -. Foot Length, MILLMETERS.MAX = 1.27. Footprint, Units.Dimension Limits = L1. Footprint, MILLMETERS.MIN = 1.40 REF. Footprint, MILLMETERS.NOM = 1.40 REF. Footprint, MILLMETERS.MAX = 1.40 REF. Foot Angle Top, Units.Dimension Limits = \u03c6. Foot Angle Top, MILLMETERS.MIN = 0\u00b0. Foot Angle Top, MILLMETERS.NOM = -. Foot Angle Top, MILLMETERS.MAX = 8\u00b0. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, MILLMETERS.MIN = 0.18. Lead Thickness, MILLMETERS.NOM = -. Lead Thickness, MILLMETERS.MAX = 0.33. Lead Width, Units.Dimension Limits = b. Lead Width, MILLMETERS.MIN = 0.31. Lead Width, MILLMETERS.NOM = -.",
    "28-Lead Plastic Small Outline (SO) - Wide, 7.50 mm Body [SOIC]\nLead Width, MILLMETERS.MAX = 0.51. Mold Draft Angle Top, Units.Dimension Limits = \u03b1. Mold Draft Angle Top, MILLMETERS.MIN = 5\u00b0. Mold Draft Angle Top, MILLMETERS.NOM = -. Mold Draft Angle Top, MILLMETERS.MAX = 15\u00b0. Mold Draft Angle Bottom, Units.Dimension Limits = \u03b2. Mold Draft Angle Bottom, MILLMETERS.MIN = 5\u00b0. Mold Draft Angle Bottom, MILLMETERS.NOM = -. Mold Draft Angle Bottom, MILLMETERS.MAX = 15\u00b0",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed 0.15 mm per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing C04-052B",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nNote:, 1 = For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nNumber of Pins, Units.Limits = N. Number of Pins, INCHES.MIN = 40. Number of Pins, INCHES.NOM = 40. Number of Pins, INCHES.MAX = 40. Pitch, Units.Limits = e. Pitch, INCHES.MIN = .100 BSC. Pitch, INCHES.NOM = .100 BSC. Pitch, INCHES.MAX = .100 BSC. Top to Seating Plane, Units.Limits = A. Top to Seating Plane, INCHES.MIN = -. Top to Seating Plane, INCHES.NOM = -. Top to Seating Plane, INCHES.MAX = .250. Molded Package Thickness, Units.Limits = A2. Molded Package Thickness, INCHES.MIN = .125. Molded Package Thickness, INCHES.NOM = -. Molded Package Thickness, INCHES.MAX = .195. Base to Seating Plane, Units.Limits = A1. Base to Seating Plane, INCHES.MIN = .015. Base to Seating Plane, INCHES.NOM = -. Base to Seating Plane, INCHES.MAX = -. Shoulder to Shoulder Width, Units.Limits = E. Shoulder to Shoulder Width, INCHES.MIN =",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\n.590. Shoulder to Shoulder Width, INCHES.NOM = -. Shoulder to Shoulder Width, INCHES.MAX = .625. Molded Package Width, Units.Limits = E1. Molded Package Width, INCHES.MIN = .485. Molded Package Width, INCHES.NOM = -. Molded Package Width, INCHES.MAX = .580. Overall Length, Units.Limits = D. Overall Length, INCHES.MIN = 1.980. Overall Length, INCHES.NOM = -. Overall Length, INCHES.MAX = 2.095. Tip to Seating Plane, Units.Limits = L. Tip to Seating Plane, INCHES.MIN = .115. Tip to Seating Plane, INCHES.NOM = -. Tip to Seating Plane, INCHES.MAX = .200. Lead Thickness, Units.Limits = c. Lead Thickness, INCHES.MIN = .008. Lead Thickness, INCHES.NOM = -. Lead Thickness, INCHES.MAX = .015. Upper Lead Width, Units.Limits = b1. Upper Lead Width, INCHES.MIN = .030. Upper Lead Width, INCHES.NOM = -. Upper Lead",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nWidth, INCHES.MAX = .070. Lower Lead Width, Units.Limits = b. Lower Lead Width, INCHES.MIN = .014. Lower Lead Width, INCHES.NOM = -. Lower Lead Width, INCHES.MAX = .023. Overall Row Spacing, Units.Limits = eB. Overall Row Spacing, INCHES.MIN = -. Overall Row Spacing, INCHES.NOM = -. Overall Row Spacing, INCHES.MAX = .700",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010\" per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nMicrochip Technology Drawing C04-016B",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1 mm Body, 2.00 mm Footprint [TQFP]\nFor the most current package drawings, please see the Microchip Packaging Specification located at\nNote: http://www.microchip.com/packaging\nc",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1 mm Body, 2.00 mm Footprint [TQFP]\nNumber of Leads, Units.Dimension Limits = N. Number of Leads, MILLIMETERS.MIN = 44. Number of Leads, MILLIMETERS.NOM = 44. Number of Leads, MILLIMETERS.MAX = 44. Lead Pitch, Units.Dimension Limits = e. Lead Pitch, MILLIMETERS.MIN = 0.80 BSC. Lead Pitch, MILLIMETERS.NOM = 0.80 BSC. Lead Pitch, MILLIMETERS.MAX = 0.80 BSC. Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = -. Overall Height, MILLIMETERS.NOM = -. Overall Height, MILLIMETERS.MAX = 1.20. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, MILLIMETERS.MIN = 0.95. Molded Package Thickness, MILLIMETERS.NOM = 1.00. Molded Package Thickness, MILLIMETERS.MAX = 1.05. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.05. Standoff, MILLIMETERS.NOM = -. Standoff,",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1 mm Body, 2.00 mm Footprint [TQFP]\nMILLIMETERS.MAX = 0.15. Foot Length, Units.Dimension Limits = L. Foot Length, MILLIMETERS.MIN = 0.45. Foot Length, MILLIMETERS.NOM = 0.60. Foot Length, MILLIMETERS.MAX = 0.75. Footprint, Units.Dimension Limits = L1. Footprint, MILLIMETERS.MIN = 1.00 REF. Footprint, MILLIMETERS.NOM = 1.00 REF. Footprint, MILLIMETERS.MAX = 1.00 REF. Foot Angle, Units.Dimension Limits = \u03c6. Foot Angle, MILLIMETERS.MIN = 0\u00b0. Foot Angle, MILLIMETERS.NOM = 3.5\u00b0. Foot Angle, MILLIMETERS.MAX = 7\u00b0. Overall Width, Units.Dimension Limits = E. Overall Width, MILLIMETERS.MIN = 12.00 BSC. Overall Width, MILLIMETERS.NOM = 12.00 BSC. Overall Width, MILLIMETERS.MAX = 12.00 BSC. Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = 12.00 BSC. Overall Length,",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1 mm Body, 2.00 mm Footprint [TQFP]\nMILLIMETERS.NOM = 12.00 BSC. Overall Length, MILLIMETERS.MAX = 12.00 BSC. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, MILLIMETERS.MIN = 10.00 BSC. Molded Package Width, MILLIMETERS.NOM = 10.00 BSC. Molded Package Width, MILLIMETERS.MAX = 10.00 BSC. Molded Package Length, Units.Dimension Limits = D1. Molded Package Length, MILLIMETERS.MIN = 10.00 BSC. Molded Package Length, MILLIMETERS.NOM = 10.00 BSC. Molded Package Length, MILLIMETERS.MAX = 10.00 BSC. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, MILLIMETERS.MIN = 0.09. Lead Thickness, MILLIMETERS.NOM = -. Lead Thickness, MILLIMETERS.MAX = 0.20. Lead Width, Units.Dimension Limits = b. Lead Width, MILLIMETERS.MIN = 0.30. Lead Width, MILLIMETERS.NOM = 0.37. Lead Width, MILLIMETERS.MAX = 0.45. Mold",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1 mm Body, 2.00 mm Footprint [TQFP]\nDraft Angle Top, Units.Dimension Limits = \u03b1. Mold Draft Angle Top, MILLIMETERS.MIN = 11\u00b0. Mold Draft Angle Top, MILLIMETERS.NOM = 12\u00b0. Mold Draft Angle Top, MILLIMETERS.MAX = 13\u00b0. Mold Draft Angle Bottom, Units.Dimension Limits = \u03b2. Mold Draft Angle Bottom, MILLIMETERS.MIN = 11\u00b0. Mold Draft Angle Bottom, MILLIMETERS.NOM = 12\u00b0. Mold Draft Angle Bottom, MILLIMETERS.MAX = 13\u00b0",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Chamfers at corners are optional; size may vary.\n3. Dimensions D1 and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed 0.25 mm per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing C04-076B",
    "44-Lead Plastic Quad Flat, No Lead Package (ML) - 8x8 mm Body [QFN]\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "44-Lead Plastic Quad Flat, No Lead Package (ML) - 8x8 mm Body [QFN]\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, MILLIMETERS.MIN = 44. Number of Pins, MILLIMETERS.NOM = 44. Number of Pins, MILLIMETERS.MAX = 44. Pitch, Units.Dimension Limits = e. Pitch, MILLIMETERS.MIN = 0.65 BSC. Pitch, MILLIMETERS.NOM = 0.65 BSC. Pitch, MILLIMETERS.MAX = 0.65 BSC. Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = 0.80. Overall Height, MILLIMETERS.NOM = 0.90. Overall Height, MILLIMETERS.MAX = 1.00. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.00. Standoff, MILLIMETERS.NOM = 0.02. Standoff, MILLIMETERS.MAX = 0.05. Contact Thickness, Units.Dimension Limits = A3. Contact Thickness, MILLIMETERS.MIN = 0.20 REF. Contact Thickness, MILLIMETERS.NOM = 0.20 REF. Contact Thickness, MILLIMETERS.MAX =",
    "44-Lead Plastic Quad Flat, No Lead Package (ML) - 8x8 mm Body [QFN]\n0.20 REF. Overall Width, Units.Dimension Limits = E. Overall Width, MILLIMETERS.MIN = 8.00 BSC. Overall Width, MILLIMETERS.NOM = 8.00 BSC. Overall Width, MILLIMETERS.MAX = 8.00 BSC. Exposed Pad Width, Units.Dimension Limits = E2. Exposed Pad Width, MILLIMETERS.MIN = 6.30. Exposed Pad Width, MILLIMETERS.NOM = 6.45. Exposed Pad Width, MILLIMETERS.MAX = 6.80. Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = 8.00 BSC. Overall Length, MILLIMETERS.NOM = 8.00 BSC. Overall Length, MILLIMETERS.MAX = 8.00 BSC. Exposed Pad Length, Units.Dimension Limits = D2. Exposed Pad Length, MILLIMETERS.MIN = 6.30. Exposed Pad Length, MILLIMETERS.NOM = 6.45. Exposed Pad Length, MILLIMETERS.MAX = 6.80. Contact Width, Units.Dimension Limits = b. Contact Width, MILLIMETERS.MIN = 0.25. Contact",
    "44-Lead Plastic Quad Flat, No Lead Package (ML) - 8x8 mm Body [QFN]\nWidth, MILLIMETERS.NOM = 0.30. Contact Width, MILLIMETERS.MAX = 0.38. Contact Length, Units.Dimension Limits = L. Contact Length, MILLIMETERS.MIN = 0.30. Contact Length, MILLIMETERS.NOM = 0.40. Contact Length, MILLIMETERS.MAX = 0.50. Contact-to-Exposed Pad, Units.Dimension Limits = K. Contact-to-Exposed Pad, MILLIMETERS.MIN = 0.20. Contact-to-Exposed Pad, MILLIMETERS.NOM = -. Contact-to-Exposed Pad, MILLIMETERS.MAX = -",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated.\n3. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing C04-103B",
    "29.0 DC AND AC CHARACTERISTICS GRAPHS AND TABLES\nGraphs and tables are not available at this time.",
    "Revision A (December 2003)\nAPPENDIX B:\nDEVICE DIFFERENCES\nOriginal  data  sheet  for  PIC18F2585/2680/4585/4680 devices.",
    "Revision B (July 2004)\nThis update includes updates to the Electrical Specifications in Section 27.0 and includes minor corrections to the data sheet text.",
    "Revision C (January 2007)\nMajor edits to Section 27.0 'Electrical Characteristics' .  Packaging  diagrams  have  been  updated  and minor edits to text have  been  made  throughout document.",
    "Revision D (Oct 2018)\nUpdated Sections 16.4.6, 17.3.3, 23.6.1, and 27.2; and Table 27-24. Removed Preliminary watermark.",
    "TABLE B-1: DEVICE DIFFERENCES\nProgram Memory (Bytes), PIC18F2585 = 49152. Program Memory (Bytes), PIC18F2680 = 65536. Program Memory (Bytes), PIC18F4585 = 49152. Program Memory (Bytes), PIC18F4680 = 65536. Program Memory (Instructions), PIC18F2585 = 24576. Program Memory (Instructions), PIC18F2680 = 32768. Program Memory (Instructions), PIC18F4585 = 24576. Program Memory (Instructions), PIC18F4680 = 32768. Interrupt Sources, PIC18F2585 = 27. Interrupt Sources, PIC18F2680 = 27. Interrupt Sources, PIC18F4585 = 28. Interrupt Sources, PIC18F4680 = 28. I/O Ports, PIC18F2585 = Ports A, B, C, (E). I/O Ports, PIC18F2680 = Ports A, B, C, (E). I/O Ports, PIC18F4585 = Ports A, B, C, D, E. I/O Ports, PIC18F4680 =",
    "TABLE B-1: DEVICE DIFFERENCES\nPorts A, B, C, D, E. Capture/Compare/PWM Modules, PIC18F2585 = 1. Capture/Compare/PWM Modules, PIC18F2680 = 1. Capture/Compare/PWM Modules, PIC18F4585 = 1. Capture/Compare/PWM Modules, PIC18F4680 = 1. Enhanced Capture/Compare/ PWM Modules, PIC18F2585 = 0. Enhanced Capture/Compare/ PWM Modules, PIC18F2680 = 0. Enhanced Capture/Compare/ PWM Modules, PIC18F4585 = 1. Enhanced Capture/Compare/ PWM Modules, PIC18F4680 = 1. Parallel Communications (PSP), PIC18F2585 = No. Parallel Communications (PSP), PIC18F2680 = No. Parallel Communications (PSP), PIC18F4585 = Yes. Parallel Communications (PSP), PIC18F4680 = Yes. 10-bit Analog-to-Digital Module, PIC18F2585 = 8 input channels. 10-bit Analog-to-Digital Module, PIC18F2680 = 8 input",
    "TABLE B-1: DEVICE DIFFERENCES\nchannels. 10-bit Analog-to-Digital Module, PIC18F4585 = 11 input channels. 10-bit Analog-to-Digital Module, PIC18F4680 = 11 input channels. Packages, PIC18F2585 = 28-pin PDIP 28-pin SOIC. Packages, PIC18F2680 = 28-pin PDIP 28-pin SOIC. Packages, PIC18F4585 = 40-pin PDIP 44-pin TQFP 44-pin QFN. Packages, PIC18F4680 = 40-pin PDIP 44-pin TQFP 44-pin QFN\nThe differences between the devices listed in this data sheet are shown in Table B-1.",
    "APPENDIX C: CONVERSION CONSIDERATIONS\nThis appendix discusses the considerations for converting  from  previous  versions  of  a  device  to  the ones listed in this data sheet. Typically, these changes are due to the differences in the process technology used. An example of this type of conversion is from a PIC16C74A to a PIC16C74B.\nNot Applicable\nAPPENDIX D:\nMIGRATION FROM BASELINE TO ENHANCED DEVICES\nThis section discusses how to migrate from a Baseline device (i.e., PIC16C5X) to an Enhanced MCU device (i.e., PIC18FXXX).\nThe  following  are  the  list  of  modifications  over  the PIC16C5X microcontroller family:\nNot Currently Available",
    "PIC18F2585/2680/4585/4680\nAPPENDIX E:",
    "MIGRATION FROM MID-RANGE TO ENHANCED DEVICES\nAPPENDIX F:",
    "MIGRATION FROM HIGH-END TO ENHANCED DEVICES\nA detailed discussion of the differences between the mid-range  MCU  devices  (i.e.,  PIC16CXXX)  and  the enhanced  devices  (i.e.,  PIC18FXXX)  is  provided  in AN716,  'Migrating  Designs  from  PIC16C74A/74B  to PIC18C442 .'  The  changes  discussed,  while  device specific,  are  generally  applicable  to  all  mid-range  to enhanced device migrations.\nThis Application Note is available as Literature Number DS00716.\nA  detailed  discussion  of  the  migration  pathway  and differences between the high-end MCU devices (i.e., PIC17CXXX) and the enhanced devices (i.e., PIC18FXXX)  is  provided  in AN726,  'PIC17CXXX  to PIC18CXXX  Migration .' This Application Note is available as Literature Number DS00726.",
    "CUSTOMER SUPPORT\nMicrochip provides online support via our WWW site at www.microchip.com. This website is used as a means to make  files and  information  easily available to customers. Accessible by using your favorite Internet browser, the website contains the following information:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQ), technical support requests, online discussion groups, Microchip consultant program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "CUSTOMER CHANGE NOTIFICATION SERVICE\nMicrochip's  customer  notification  service  helps  keep customers current on Microchip products. Subscribers will receive  e-mail  notification  whenever  there  are changes, updates, revisions or errata related to a specified product family or development tool of interest.\nTo register, access the Microchip website at www.microchip.com. Under 'Support', click on 'Customer Change Notification' and follow the registration instructions.\nUsers  of  Microchip  products  can  receive  assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Field Application Engineer (FAE)\n\u00b7 Technical Support\nCustomers should contact their distributor, representative  or  Field  Application  Engineer  (FAE)  for  support. Local sales offices are also available to help customers. A listing of sales offices and locations is included in the back of this document.\nTechnical support is available through the website at: http://microchip.com/support",
    "PRODUCT IDENTIFICATION SYSTEM\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.",
    "PRODUCT IDENTIFICATION SYSTEM\nDevice:, [X] (1) Tape and Reel Option = PIC18F2585/2680 (1) , PIC18F4585/4680 (1) , PIC18F2585/2680T (2) , PIC18F4585/4680T (2) ; VDD range 4.2V to 5.5V PIC18LF2585/2680 (1) , PIC18LF4585/4680 (1) , PIC18LF2585/2680T (2) , PIC18LF4585/4680T (2) ;. Device:, X Temperature Range = PIC18F2585/2680 (1) , PIC18F4585/4680 (1) , PIC18F2585/2680T (2) , PIC18F4585/4680T (2) ; VDD range 4.2V to 5.5V PIC18LF2585/2680 (1) , PIC18LF4585/4680 (1) , PIC18LF2585/2680T (2) , PIC18LF4585/4680T (2) ;. Device:, /XX Package",
    "PRODUCT IDENTIFICATION SYSTEM\n= PIC18F2585/2680 (1) , PIC18F4585/4680 (1) , PIC18F2585/2680T (2) , PIC18F4585/4680T (2) ; VDD range 4.2V to 5.5V PIC18LF2585/2680 (1) , PIC18LF4585/4680 (1) , PIC18LF2585/2680T (2) , PIC18LF4585/4680T (2) ;. Device:, XXX Pattern = PIC18F2585/2680 (1) , PIC18F4585/4680 (1) , PIC18F2585/2680T (2) , PIC18F4585/4680T (2) ; VDD range 4.2V to 5.5V PIC18LF2585/2680 (1) , PIC18LF4585/4680 (1) , PIC18LF2585/2680T (2) , PIC18LF4585/4680T (2) ;. Tape and Reel Option:, [X] (1) Tape and Reel Option = Blank =",
    "PRODUCT IDENTIFICATION SYSTEM\nStandard packaging (tube or tray) T = Tape and Reel (1). Tape and Reel Option:, X Temperature Range = Blank = Standard packaging (tube or tray) T = Tape and Reel (1). Tape and Reel Option:, /XX Package = Blank = Standard packaging (tube or tray) T = Tape and Reel (1). Tape and Reel Option:, XXX Pattern = Blank = Standard packaging (tube or tray) T = Tape and Reel (1). Temperature Range:, [X] (1) Tape and Reel Option = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range:, X Temperature Range = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range:, /XX Package = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range:, XXX Pattern = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Package:, [X] (1) Tape and Reel Option =",
    "PRODUCT IDENTIFICATION SYSTEM\nPT = TQFP (Thin Quad Flatpack) SO = SOIC SP = Skinny Plastic DIP P = PDIP ML = QFN. Package:, X Temperature Range = PT = TQFP (Thin Quad Flatpack) SO = SOIC SP = Skinny Plastic DIP P = PDIP ML = QFN. Package:, /XX Package = PT = TQFP (Thin Quad Flatpack) SO = SOIC SP = Skinny Plastic DIP P = PDIP ML = QFN. Package:, XXX Pattern = PT = TQFP (Thin Quad Flatpack) SO = SOIC SP = Skinny Plastic DIP P = PDIP ML = QFN. Pattern:, [X] (1) Tape and Reel Option = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern:, X Temperature Range = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern:, /XX Package = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern:, XXX Pattern = QTP, SQTP, Code or Special Requirements (blank otherwise)",
    "Examples:\na) PIC18LF4680-I/P 301 = Industrial temp., PDIP package, Extended VDD limits, QTP pattern #301.\nb) PIC18LF2585-I/SO = Industrial temp., SOIC package, Extended VDD limits.\nc) PIC18F4585-I/P = Industrial temp., PDIP package, normal VDD limits.\nNote 1:\nF\n=\nStandard Voltage Range\nLF =\nWide Voltage Range\n2:\nT\n=\nin tape and reel PLCC and TQFP packages only.",
    "Note the following details of the code protection feature on Microchip devices:\n\u00b7 Microchip products meet the specification contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is one of the most secure families of its kind on the market today, when used in the intended manner and under normal conditions.\n\u00b7 There are dishonest and possibly illegal methods used to breach the code protection feature. All of these methods, to our knowledge, require using the Microchip products in a manner outside the operating specifications contained in Microchip's Data Sheets. Most likely, the person doing so is engaged in theft of intellectual property.\n\u00b7 Microchip is willing to work with the customer who is concerned about the integrity of their code.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of their code. Code protection does not mean that we are guaranteeing the product as 'unbreakable.'",
    "Note the following details of the code protection feature on Microchip devices:\nCode protection is constantly evolving. We at Microchip are committed to continuously improving the code protection features of our products. Attempts to break Microchip's code protection feature may be a violation of the Digital Millennium Copyright Act. If such acts allow unauthorized access to your software or other copyrighted work, you may have a right to sue for relief under that Act.",
    "Note the following details of the code protection feature on Microchip devices:\nInformation  contained  in  this  publication  regarding  device applications and the like is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure  that  your  application  meets  with  your  specifications. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES  OF  ANY  KIND  WHETHER  EXPRESS  OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION, INCLUDING  BUT  NOT  LIMITED  TO  ITS CONDITION, QUALITY, PERFORMANCE, MERCHANTABILITY OR FITNESS  FOR  PURPOSE . Microchip  disclaims  all  liability arising  from  this  information  and  its  use.  Use  of  Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold  harmless  Microchip  from  any  and  all  damages,  claims, suits,  or  expenses  resulting  from  such  use.  No  licenses  are conveyed, implicitly or otherwise, under any Microchip intellectual property rights unless otherwise stated.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, AnyRate, AVR, AVR logo, AVR Freaks, BitCloud, chipKIT, chipKIT logo, CryptoMemory, CryptoRF, dsPIC, FlashFlex, flexPWR, Heldo, JukeBlox, KeeLoq, Kleer, LANCheck, LINK MD, maXStylus, maXTouch, MediaLB, megaAVR, MOST, MOST logo, MPLAB, OptoLyzer, PIC, picoPower, PICSTART, PIC32 logo, Prochip Designer, QTouch, SAM-BA, SpyNIC, SST, SST Logo, SuperFlash, tinyAVR, UNI/O, and XMEGA are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nClockWorks, The Embedded Control Solutions Company,",
    "Trademarks\nEtherSynch, Hyper Speed Control, HyperLight Load, IntelliMOS, mTouch, Precision Edge, and Quiet-Wire are registered trademarks of Microchip Technology Incorporated in the U.S.A. Adjacent Key Suppression, AKS, Analog-for-the-Digital Age, Any Capacitor, AnyIn, AnyOut, BodyCom, CodeGuard, CryptoAuthentication, CryptoAutomotive, CryptoCompanion, CryptoController, dsPICDEM, dsPICDEM.net, Dynamic Average Matching, DAM, ECAN, EtherGREEN, In-Circuit Serial Programming, ICSP, INICnet, Inter-Chip Connectivity, JitterBlocker, KleerNet, KleerNet logo, memBrain, Mindi, MiWi, motorBench, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, MultiTRAK, NetDetach, Omniscient Code Generation, PICDEM, PICDEM.net, PICkit, PICtail, PowerSmart, PureSilicon, QMatrix, REAL ICE, Ripple Blocker, SAM-ICE, Serial Quad I/O,",
    "Trademarks\nSMART-I.S., SQI, SuperSwitcher, SuperSwitcher II, Total Endurance, TSHARC, USBCheck, VariSense, ViewSpan, WiperLock, Wireless DNA, and ZENA are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nSilicon Storage Technology is a registered trademark of Microchip Technology Inc. in other countries.\nGestIC is a registered trademark of Microchip Technology Germany II GmbH & Co. KG, a subsidiary of Microchip Technology Inc., in other countries.\nAll other trademarks mentioned herein are property of their respective companies.\n\u00a9 2018, Microchip Technology Incorporated, All Rights Reserved.\nISBN: 978-1-5224-3598-3",
    "Trademarks\nMicrochip received ISO/TS-16949:2009 certification for its worldwide headquarters, design and wafer fabrication facilities in Chandler and Tempe, Arizona; Gresham, Oregon and design centers in California and India. The Company's quality system processes and procedures are for its PIC \u00ae MCUs and dsPIC \u00ae  DSCs, KEELOQ \u00ae  code hopping devices, Serial EEPROMs, microperipherals, nonvolatile memory and analog products. In addition, Microchip's quality system for the design and manufacture of development systems is ISO 9001:2000 certified.\nQUALITY MANAGEMENT  SYSTEM CERTIFIED BY DNV == ISO/TS 16949 ==",
    "AMERICAS\nCorporate Office 2355 West Chandler Blvd. Chandler, AZ 85224-6199 Tel: 480-792-7200 Fax: 480-792-7277 Technical Support: http://www.microchip.com/ support\nWeb Address:\nwww.microchip.com\nAtlanta Duluth, GA Tel: 678-957-9614 Fax: 678-957-1455\nAustin, TX Tel: 512-257-3370\nBoston Westborough, MA Tel: 774-760-0087 Fax: 774-760-0088\nChicago Itasca, IL Tel: 630-285-0071 Fax: 630-285-0075\nDallas Addison, TX Tel: 972-818-7423 Fax: 972-818-2924\nDetroit Novi, MI Tel: 248-848-4000\nHouston, TX Tel: 281-894-5983\nIndianapolis Noblesville, IN Tel: 317-773-8323 Fax: 317-773-5453 Tel: 317-536-2380",
    "AMERICAS\nLos Angeles Mission Viejo, CA Tel: 949-462-9523 Fax: 949-462-9608 Tel: 951-273-7800\nRaleigh, NC Tel: 919-844-7510\nNew York, NY Tel: 631-435-6000\nSan Jose, CA Tel: 408-735-9110 Tel: 408-436-4270\nCanada - Toronto Tel: 905-695-1980 Fax: 905-695-2078",
    "ASIA/PACIFIC\nAustralia - Sydney Tel: 61-2-9868-6733\nChina - Beijing Tel: 86-10-8569-7000\nChina - Chengdu Tel: 86-28-8665-5511\nChina - Chongqing Tel: 86-23-8980-9588\nChina - Dongguan Tel: 86-769-8702-9880\nChina - Guangzhou Tel: 86-20-8755-8029\nChina - Hangzhou Tel: 86-571-8792-8115\nChina - Hong Kong SAR Tel: 852-2943-5100\nChina - Nanjing Tel: 86-25-8473-2460\nChina - Qingdao Tel: 86-532-8502-7355\nChina - Shanghai Tel: 86-21-3326-8000\nChina - Shenyang Tel: 86-24-2334-2829\nChina - Shenzhen Tel: 86-755-8864-2200\nChina - Suzhou Tel: 86-186-6233-1526\nChina - Wuhan Tel: 86-27-5980-5300\nChina - Xian Tel: 86-29-8833-7252\nChina - Xiamen",
    "ASIA/PACIFIC\nTel: 86-592-2388138\nChina - Zhuhai\nTel: 86-756-3210040\nIndia - Bangalore Tel: 91-80-3090-4444\nIndia - New Delhi Tel: 91-11-4160-8631\nIndia - Pune Tel: 91-20-4121-0141\nJapan - Osaka Tel: 81-6-6152-7160\nJapan - Tokyo Tel: 81-3-6880- 3770\nKorea - Daegu Tel: 82-53-744-4301\nKorea - Seoul Tel: 82-2-554-7200\nMalaysia - Kuala Lumpur Tel: 60-3-7651-7906\nMalaysia - Penang Tel: 60-4-227-8870\nPhilippines - Manila Tel: 63-2-634-9065\nSingapore Tel: 65-6334-8870\nTaiwan - Hsin Chu Tel: 886-3-577-8366\nTaiwan - Kaohsiung Tel: 886-7-213-7830\nTaiwan - Taipei Tel: 886-2-2508-8600\nThailand - Bangkok Tel: 66-2-694-1351\nVietnam - Ho Chi Minh",
    "ASIA/PACIFIC\nTel: 84-28-5448-2100",
    "EUROPE\nAustria - Wels Tel: 43-7242-2244-39 Fax: 43-7242-2244-393\nDenmark - Copenhagen Tel: 45-4450-2828 Fax: 45-4485-2829\nFinland - Espoo Tel: 358-9-4520-820\nFrance - Paris Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79\nGermany - Garching Tel: 49-8931-9700\nGermany - Haan Tel: 49-2129-3766400\nGermany - Heilbronn Tel: 49-7131-67-3636\nGermany - Karlsruhe Tel: 49-721-625370\nGermany - Munich Tel: 49-89-627-144-0 Fax: 49-89-627-144-44\nGermany - Rosenheim Tel: 49-8031-354-560\nIsrael - Ra'anana Tel: 972-9-744-7705\nItaly - Milan Tel: 39-0331-742611 Fax: 39-0331-466781\nItaly - Padova Tel: 39-049-7625286",
    "EUROPE\nNetherlands - Drunen Tel: 31-416-690399 Fax: 31-416-690340\nNorway - Trondheim Tel: 47-7288-4388\nPoland - Warsaw Tel: 48-22-3325737\nRomania - Bucharest Tel: 40-21-407-87-50\nSpain - Madrid Tel: 34-91-708-08-90 Fax: 34-91-708-08-91\nSweden - Gothenberg Tel: 46-31-704-60-40\nSweden - Stockholm Tel: 46-8-5090-4654\nUK - Wokingham Tel: 44-118-921-5800 Fax: 44-118-921-5820",
    "Mouser Electronics\nAuthorized Distributor\nClick to View Pricing, Inventory, Delivery & Lifecycle Information:",
    "Microchip:\nPIC18F4585-E/ML\u00a0 PIC18LF4585-I/PT\u00a0 PIC18F2680T-I/SO\u00a0 PIC18F4680-I/P\u00a0 PIC18F4680-E/P\u00a0 PIC18F4585-E/PT PIC18F2585-E/SO\u00a0 PIC18LF4585-I/P\u00a0 PIC18F2585T-I/SO\u00a0 PIC18F4680-E/PT\u00a0 PIC18LF2680-I/SO\u00a0 PIC18LF2680-I/SP PIC18F4680-E/ML\u00a0 PIC18LF4680-I/ML\u00a0 PIC18F2680-E/SP\u00a0 PIC18LF4680-I/PT\u00a0 PIC18F2680-E/SO\u00a0 PIC18F4585-I/PT PIC18F4585-I/ML\u00a0 PIC18F4680-I/PT\u00a0 PIC18F4585T-I/PT\u00a0 PIC18LF4680T-I/PT\u00a0 PIC18F4585-I/P\u00a0 PIC18F2585-I/SP PIC18F2585-I/SO\u00a0 PIC18F4680T-I/ML\u00a0 PIC18F4680T-I/PT",
    "Microchip:\nPIC18F4680-I/ML\u00a0 PIC18LF2585-I/SO\u00a0 PIC18LF2585-I/SP PIC18LF4680-I/P\u00a0 PIC18LF4585T-I/PT\u00a0 PIC18F4585-E/P\u00a0 PIC18LF2680T-I/SO\u00a0 PIC18F2680-I/SP\u00a0 PIC18F2680-I/SO PIC18LF4585-I/ML\u00a0 PIC18F4585-H/ML\u00a0 PIC18F4585-H/PT\u00a0 PIC18F4680-H/PT"
]
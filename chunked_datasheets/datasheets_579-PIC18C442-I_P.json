[
    "Pin Diagrams\n\u00b7 C compiler optimized architecture/instruction set\n-Source code compatible with the PIC16CXX instruction set\n\u00b7 Linear program memory addressing to 2 Mbytes\n\u00b7 Linear data memory addressing to 4 Kbytes\n\u00b7 Up to 10 MIPs operation:\n-DC - 40 MHz osc./clock input\n-4 MHz - 10 MHz osc./clock input with PLL active\n\u00b7 16-bit wide instructions, 8-bit wide data path\n\u00b7 Priority levels for interrupts\n\u00b7 8 x 8 Single Cycle Hardware Multiplier",
    "Pin Diagrams\nPIC18C242, On-Chip Program Memory.EPROM (bytes) = 16K. PIC18C242, On-Chip Program Memory.# Single Word Instructions = 8192. PIC18C242, On-Chip RAM (bytes). = 512. PIC18C252, On-Chip Program Memory.EPROM (bytes) = 32K. PIC18C252, On-Chip Program Memory.# Single Word Instructions = 16384. PIC18C252, On-Chip RAM (bytes). = 1536. PIC18C442, On-Chip Program Memory.EPROM (bytes) = 16K. PIC18C442, On-Chip Program Memory.# Single Word Instructions = 8192. PIC18C442, On-Chip RAM (bytes). = 512. PIC18C452, On-Chip Program Memory.EPROM (bytes) = 32K. PIC18C452, On-Chip Program Memory.# Single Word Instructions = 16384. PIC18C452, On-Chip RAM (bytes). = 1536",
    "Peripheral Features:\n\u00b7 High current sink/source 25 mA/25 mA\n\u00b7 Three external interrupt pins\n\u00b7 Timer0 module: 8-bit/16-bit timer/counter with 8-bit programmable prescaler\n\u00b7 Timer1 module: 16-bit timer/counter\n\u00b7 Timer2 module: 8-bit timer/counter with 8-bit period register (time-base for PWM)\n\u00b7 Timer3 module: 16-bit timer/counter\n\u00b7 Secondary oscillator clock option - Timer1/Timer3\n\u00b7 Two Capture/Compare/PWM (CCP) modules. CCP pins that can be configured as:\n-Capture input: capture is 16-bit, max. resolution 6.25 ns (TCY/16)\n-Compare is 16-bit, max. resolution 100 ns (TCY)\n-PWM output: PWM resolution is 1- to 10-bit. Max. PWM freq. @: 8-bit resolution = 156 kHz 10-bit resolution =   39 kHz\n\u00b7 Master Synchronous Serial Port (MSSP) module. Two modes of operation:\n-3-wire SPI (supports all 4 SPI modes)\n-I 2 C\u2122 master and slave mode",
    "Peripheral Features:\n\u00b7 Addressable USART module:\n-Supports interrupt on Address bit\n\u00b7 Parallel Slave Port (PSP) module\nDIP, Windowed CERDIP, 1 = . MCLR/VPP RA0/AN 0 RA1/AN1 RA2/AN2/V REF - RA3/AN3/V REF + RA4/T0CKI RA5/AN4/SS/LVDIN RE0/RD/AN5 RE1/WR/AN6 RE2/CS/AN7 VDD VSS OSC1/CLKI OSC2/CLKO/RA6 RC0/T1OSO/T1CKI RC1/T1OSI/CCP2* RC2/CCP1 RC3/SCK/SCL RD0/PSP0 RD1/PSP1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20, 1 = RB7 RB6 RB5 RB4 RB3/CCP2* RB2/INT2 RB1/INT1 RB0/INT0 VDD VSS RD7/PSP7 40 39 38 37 36 35 34 33 32 31 30 PIC18C4X2",
    "Peripheral Features:\n* RB3 is the alternate pin for the CCP2 pin multiplexing. Note: Pin compatible with 40-pin PIC16C7X devices.",
    "Analog Features:\n\u00b7 Compatible 10-bit Analog-to-Digital Converter module (A/D) with:\n-Fast sampling rate\n-Conversion available during SLEEP\n-DNL = \u00b11 LSb, INL = \u00b11 LSb\n\u00b7 Programmable Low Voltage Detection (LVD) module\n-Supports interrupt-on-low voltage detection\n\u00b7 Programmable Brown-out Reset (BOR)",
    "Special Microcontroller Features:\n\u00b7 Power-on Reset (POR), Power-up Timer (PWRT) and Oscillator Start-up Timer (OST)\n\u00b7 Watchdog Timer (WDT) with its own on-chip RC oscillator for reliable operation\n\u00b7 Programmable code protection\n\u00b7 Power saving SLEEP mode\n\u00b7 Selectable oscillator options including:\n-4X Phase Lock Loop (of primary oscillator)\n-Secondary Oscillator (32 kHz) clock input\n\u00b7 In-Circuit Serial Programming (ICSP\u2122) via two pins",
    "CMOS Technology:\n\u00b7 Low power, high speed EPROM technology\n\u00b7 Fully static design\n\u00b7 Wide operating voltage range (2.5V to 5.5V)\n\u00b7 Industrial and Extended temperature ranges\n\u00b7 Low power consumption",
    "Table of Contents\n1.0, 1 = Device Overview......................................................................................................................................................................... 7. 1.0, 2 = Device",
    "Table of Contents\nOverview......................................................................................................................................................................... 7. 1.0, 3 = Device",
    "Table of Contents\nOverview......................................................................................................................................................................... 7. 2.0, 1 = Oscillator",
    "Table of Contents\nConfigurations............................................................................................................................................................ 2.0, 2 = Oscillator",
    "Table of Contents\nConfigurations............................................................................................................................................................ 2.0, 3 = 17. 3.0, 1 =",
    "Table of Contents\nReset.......................................................................................................................................................................................... 3.0, 2 =",
    "Table of Contents\nReset.......................................................................................................................................................................................... 3.0, 3 = 25. 4.0, 1 = Memory",
    "Table of Contents\nOrganization................................................................................................................................................................. 4.0, 2 = Memory",
    "Table of Contents\nOrganization................................................................................................................................................................. 4.0, 3 = 35. 5.0, 1 = Table Reads/Table Writes",
    "Table of Contents\n......................................................................................................................................................... 5.0, 2 = Table Reads/Table Writes",
    "Table of Contents\n......................................................................................................................................................... 5.0, 3 = 55. 6.0, 1 = 8 X 8 Hardware",
    "Table of Contents\nMultiplier........................................................................................................................................................... 6.0, 2 = 8 X 8 Hardware",
    "Table of Contents\nMultiplier........................................................................................................................................................... 6.0, 3 = 61. 7.0, 1 =",
    "Table of Contents\nInterrupts.................................................................................................................................................................................... 7.0, 2 =",
    "Table of Contents\nInterrupts.................................................................................................................................................................................... 7.0, 3 = 63. 8.0, 1 = I/O",
    "Table of Contents\nPorts..................................................................................................................................................................................... 8.0, 2 = I/O",
    "Table of Contents\nPorts..................................................................................................................................................................................... 8.0, 3 = 77. 9.0, 1 = Timer0",
    "Table of Contents\nModule........................................................................................................................................................................... 9.0, 2 = Timer0",
    "Table of Contents\nModule........................................................................................................................................................................... 9.0, 3 = 93. 10.0, 1 = Timer1",
    "Table of Contents\nModule........................................................................................................................................................................... 10.0, 2 = Timer1",
    "Table of Contents\nModule........................................................................................................................................................................... 10.0, 3 = 97. 11.0, 1 = Timer2",
    "Table of Contents\nModule......................................................................................................................................................................... 11.0, 2 = Timer2",
    "Table of Contents\nModule......................................................................................................................................................................... 11.0, 3 = 101. 12.0, 1 = Timer3",
    "Table of Contents\nModule......................................................................................................................................................................... 12.0, 2 = Timer3",
    "Table of Contents\nModule......................................................................................................................................................................... 12.0, 3 = 103. 13.0, 1 = Capture/Compare/PWM (CCP)",
    "Table of Contents\nModules................................................................................................................................. 13.0, 2 = Capture/Compare/PWM (CCP)",
    "Table of Contents\nModules................................................................................................................................. 13.0, 3 = 107. 14.0, 1 = Master Synchronous Serial Port (MSSP)",
    "Table of Contents\nModule.................................................................................................................... 14.0, 2 = Master Synchronous Serial Port (MSSP) Module....................................................................................................................",
    "Table of Contents\n14.0, 3 = 115. 15.0, 1 = Addressable Universal Synchronous Asynchronous Receiver Transmitter (USART)............................................................. 15.0, 2 = Addressable Universal Synchronous Asynchronous Receiver Transmitter (USART)............................................................. 15.0, 3 = 149. 16.0, 1 = Compatible 10-bit Analog-to-Digital Converter (A/D)",
    "Table of Contents\nModule.................................................................................................. 16.0, 2 = Compatible 10-bit Analog-to-Digital Converter (A/D) Module.................................................................................................. 16.0, 3 = 165. 17.0, 1 = Low Voltage",
    "Table of Contents\nDetect.................................................................................................................................................................. 17.0, 2 = Low Voltage",
    "Table of Contents\nDetect.................................................................................................................................................................. 17.0, 3 = 173. 18.0, 1 = Special Features of the",
    "Table of Contents\nCPU................................................................................................................................................... 18.0, 2 = Special Features of the",
    "Table of Contents\nCPU................................................................................................................................................... 18.0, 3 = 179. 19.0, 1 = Instruction Set",
    "Table of Contents\nSummary.......................................................................................................................................................... 19.0, 2 = Instruction Set",
    "Table of Contents\nSummary.......................................................................................................................................................... 19.0, 3 = 187. 20.0, 1 = Development Support",
    "Table of Contents\n.............................................................................................................................................................. 20.0, 2 = Development Support",
    "Table of Contents\n.............................................................................................................................................................. 20.0, 3 = 229. 21.0, 1 = Electrical",
    "Table of Contents\nCharacteristics.......................................................................................................................................................... 21.0, 2 = Electrical",
    "Table of Contents\nCharacteristics.......................................................................................................................................................... 21.0, 3 = 235. 22.0, 1 = DC and AC Characteristics Graphs and Tables",
    "Table of Contents\n...................................................................................................................... 22.0, 2 = DC and AC Characteristics Graphs and Tables ...................................................................................................................... 22.0,",
    "Table of Contents\n3 = 263. 23.0, 1 = Packaging Information ............................................................................................................................................................. 23.0, 2 = Packaging Information",
    "Table of Contents\n............................................................................................................................................................. 23.0, 3 = 277. Appendix A:, 1 = Appendix A:. Appendix A:, 2 = Revision",
    "Table of Contents\nHistory.......................................................................................................................................................... Appendix A:, 3 = 287. Appendix B:, 1 = Appendix B:. Appendix B:, 2 = Device",
    "Table of Contents\nDifferences...................................................................................................................................................... Appendix B:, 3 = 287. Appendix C:, 1 = Appendix C:. Appendix C:, 2 = Conversion",
    "Table of Contents\nConsiderations......................................................................................................................................... Appendix C:, 3 = 288. Appendix D:, 1 = Appendix D:. Appendix D:, 2 = Migration from Baseline to Enhanced",
    "Table of Contents\nDevices........................................................................................................... Appendix D:, 3 = 288. Appendix E:, 1 = Appendix E:. Appendix E:, 2 = Migration from Mid-Range to Enhanced Devices ....................................................................................................... Appendix E:, 3 = 289. Appendix",
    "Table of Contents\nF:, 1 = Appendix F:. Appendix F:, 2 = Migration from High-End to Enhanced Devices.......................................................................................................... Appendix F:, 3 = 289. Index, 1 = Index. Index, 2 =",
    "Table of Contents\n.................................................................................................................................................................................................. Index, 3 = 291. , 1 = . , 2 = . , 3 = 299. On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................ Reader",
    "Table of Contents\nResponse............................................................................................................................................................................., 1 = On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................ Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................. On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................ Reader",
    "Table of Contents\nResponse............................................................................................................................................................................., 2 = On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................ Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................. On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................ Reader",
    "Table of Contents\nResponse............................................................................................................................................................................., 3 = 300. PIC18CXX2 Product Identification System",
    "Table of Contents\n......................................................................................................................................., 1 = PIC18CXX2 Product Identification System",
    "Table of Contents\n........................................................................................................................................ PIC18CXX2 Product Identification System",
    "Table of Contents\n......................................................................................................................................., 2 = PIC18CXX2 Product Identification System",
    "Table of Contents\n........................................................................................................................................ PIC18CXX2 Product Identification System",
    "Table of Contents\n......................................................................................................................................., 3 = 301",
    "TO OUR VALUED CUSTOMERS\nIt is our intention to provide our valued customers with the best documentation possible to ensure successful use of your Microchip products. To this end, we will continue to improve our publications to better suit your needs. Our publications will be refined and enhanced as new volumes and updates are introduced.\nIf you have any questions or comments regarding this publication, please contact the Marketing Communications Department via E-mail at docerrors@mail.microchip.com or fax the Reader Response Form in the back of this data sheet to (480) 792-4150. We welcome your feedback.",
    "Most Current Data Sheet\nTo obtain the most up-to-date version of this data sheet, please register at our Worldwide Web site at:\nhttp://www.microchip.com\nYou can determine the version of a data sheet by examining its literature number found on the bottom outside corner of any page. The last character of the literature number is the version number, (e.g., DS30000A is version A of document DS30000).",
    "Errata\nAn errata sheet, describing minor operational differences from the data sheet and recommended workarounds, may exist for current devices. As device/documentation issues become known to us, we will publish an errata sheet. The errata will specify the revision of silicon and revision of document to which it applies.\nTo determine if an errata sheet exists for a particular device, please check with one of the following:\n\u00b7 Microchip's Worldwide Web site; http://www.microchip.com\n\u00b7 Your local Microchip sales office (see last page)\n\u00b7 The Microchip Corporate Literature Center; U.S. FAX: (480) 792-7277\nWhen contacting a sales office or the literature center, please specify which device, revision of silicon and data sheet (include literature number) you are using.",
    "Customer Notification System\nRegister on our web site at www.microchip.com/cn to receive the most current information on all of our products.",
    "PIC18CXX2\nNOTES:",
    "1.0 DEVICE OVERVIEW\nThis document contains device specific information for the following four devices:\n1. PIC18C242\n2. PIC18C252\n3. PIC18C442\n4. PIC18C452\nThese devices come in 28-pin and 40-pin packages. The 28-pin devices do not have a Parallel Slave Port (PSP)  implemented  and  the  number  of  Analog-toDigital (A/D) converter input channels is reduced to 5. An overview of features is shown in Table 1-1.",
    "TABLE 1-1: DEVICE FEATURES\nOperating Frequency, PIC18C242 = DC - 40 MHz. Operating Frequency, PIC18C252 = DC - 40 MHz. Operating Frequency, PIC18C442 = DC - 40 MHz. Operating Frequency, PIC18C452 = DC - 40 MHz. Program Memory (Bytes), PIC18C242 = 16K. Program Memory (Bytes), PIC18C252 = 32K. Program Memory (Bytes), PIC18C442 = 16K. Program Memory (Bytes), PIC18C452 = 32K. Program Memory (Instructions), PIC18C242 = 8192. Program Memory (Instructions), PIC18C252 = 16384. Program Memory (Instructions), PIC18C442 = 8192. Program Memory (Instructions), PIC18C452 = 16384. Data Memory (Bytes), PIC18C242 = 512. Data Memory (Bytes), PIC18C252 = 1536. Data Memory (Bytes), PIC18C442 = 512. Data Memory (Bytes), PIC18C452 = 1536. Interrupt Sources, PIC18C242 = 16. Interrupt",
    "TABLE 1-1: DEVICE FEATURES\nSources, PIC18C252 = 16. Interrupt Sources, PIC18C442 = 17. Interrupt Sources, PIC18C452 = 17. I/O Ports, PIC18C242 = Ports A, B, C. I/O Ports, PIC18C252 = Ports A, B, C. I/O Ports, PIC18C442 = Ports A, B, C, D, E. I/O Ports, PIC18C452 = Ports A, B, C, D, E. Timers, PIC18C242 = 4. Timers, PIC18C252 = 4. Timers, PIC18C442 = 4. Timers, PIC18C452 = 4. Capture/Compare/PWM Modules, PIC18C242 = 2. Capture/Compare/PWM Modules, PIC18C252 = 2. Capture/Compare/PWM Modules, PIC18C442 = 2. Capture/Compare/PWM Modules, PIC18C452 = 2. Serial Communications, PIC18C242 = MSSP, Addressable USART. Serial Communications, PIC18C252",
    "TABLE 1-1: DEVICE FEATURES\n= MSSP, Addressable USART. Serial Communications, PIC18C442 = MSSP, Addressable USART. Serial Communications, PIC18C452 = MSSP, Addressable USART. Parallel Communications, PIC18C242 = -. Parallel Communications, PIC18C252 = -. Parallel Communications, PIC18C442 = PSP. Parallel Communications, PIC18C452 = PSP. 10-bit Analog-to-Digital Module, PIC18C242 = 5 input channels. 10-bit Analog-to-Digital Module, PIC18C252 = 5 input channels. 10-bit Analog-to-Digital Module, PIC18C442 = 8 input channels. 10-bit Analog-to-Digital Module, PIC18C452 = 8 input channels. RESETS (and Delays), PIC18C242 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). RESETS (and Delays), PIC18C252 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). RESETS (and Delays),",
    "TABLE 1-1: DEVICE FEATURES\nPIC18C442 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). RESETS (and Delays), PIC18C452 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Programmable Low Voltage Detect, PIC18C242 = Yes. Programmable Low Voltage Detect, PIC18C252 = Yes. Programmable Low Voltage Detect, PIC18C442 = Yes. Programmable Low Voltage Detect, PIC18C452 = Yes. Programmable Brown-out Reset, PIC18C242 = Yes. Programmable Brown-out Reset, PIC18C252 = Yes. Programmable Brown-out Reset, PIC18C442 = Yes. Programmable Brown-out Reset, PIC18C452 = Yes. Instruction Set, PIC18C242 = 75 Instructions. Instruction Set, PIC18C252 = 75 Instructions. Instruction Set, PIC18C442 = 75 Instructions. Instruction Set, PIC18C452 = 75 Instructions. Packages, PIC18C242 = 28-pin DIP 28-pin SOIC 28-pin",
    "TABLE 1-1: DEVICE FEATURES\nJW. Packages, PIC18C252 = 28-pin DIP 28-pin SOIC 28-pin JW. Packages, PIC18C442 = 40-pin DIP 44-pin PLCC 44-pin TQFP 40-pin JW. Packages, PIC18C452 = 40-pin DIP 44-pin PLCC 44-pin TQFP 40-pin JW\nThe following  two  figures  are  device  block  diagrams sorted by pin count: 28-pin for Figure 1-1 and 40-pin for Figure 1-2. The 28-pin and 40-pin pinouts are listed in Table 1-2 and Table 1-3, respectively.",
    "FIGURE 1-1: PIC18C2X2 BLOCK DIAGRAM\nNote 1: Optional multiplexing of CCP2 input/output with RB3 is enabled by selection of configuration bit.\n2: The high order bits of the Direct Address for the RAM are from the BSR register (except for the MOVFF instruction).\n3: Many of the general purpose I/O pins are multiplexed with one or more peripheral module functions. The multiplexing combinations are device dependent.",
    "FIGURE 1-2: PIC18C4X2 BLOCK DIAGRAM\nNote\n1: Optional multiplexing of CCP2 input/output with RB3 is enabled by selection of configuration bit.\n2: The high order bits of the Direct Address for the RAM are from the BSR register (except for the MOVFF instruction).\n3: Many of the general purpose I/O pins are multiplexed with one or more peripheral module functions. The multiplexing combinations are device dependent.",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS\nMCLR/VPP MCLR, Pin Number.DIP = 1. MCLR/VPP MCLR, Pin Number.SOIC = 1. MCLR/VPP MCLR, Pin.Type = I. MCLR/VPP MCLR, Buffer.Type = ST. MCLR/VPP MCLR,  = Master clear (input) or programming voltage (input). Master Clear (Reset) input. This pin is an active low RESET to the device.. VPP, Pin Number.DIP = . VPP, Pin Number.SOIC = . VPP, Pin.Type = . VPP, Buffer.Type = . VPP,  = . , Pin Number.DIP = . , Pin Number.SOIC = . , Pin.Type = P. , Buffer.Type = . ,  = Programming voltage input.. NC, Pin Number.DIP = -. NC, Pin Number.SOIC = -. NC, Pin.Type = -. NC, Buffer.Type = -. NC,",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS\n= These pins should be left unconnected.. OSC1/CLKI OSC1, Pin Number.DIP = 9. OSC1/CLKI OSC1, Pin Number.SOIC = 9. OSC1/CLKI OSC1, Pin.Type = I. OSC1/CLKI OSC1, Buffer.Type = ST. OSC1/CLKI OSC1,  = Oscillator crystal or external clock input. Oscillator crystal input or external clock source input. ST buffer when configured in RC mode. CMOS otherwise. External clock source input. Always associated with. CLKI, Pin Number.DIP = . CLKI, Pin Number.SOIC = . CLKI, Pin.Type = I. CLKI, Buffer.Type = CMOS. CLKI,",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS\n= pin function OSC1. (See related OSC1/CLKIN, OSC2/CLKOUT pins.). OSC2/CLKO/RA6, Pin Number.DIP = 10. OSC2/CLKO/RA6, Pin Number.SOIC = 10. OSC2/CLKO/RA6, Pin.Type = . OSC2/CLKO/RA6, Buffer.Type = . OSC2/CLKO/RA6,  = Oscillator crystal or clock output.. OSC2, Pin Number.DIP = . OSC2, Pin Number.SOIC = . OSC2, Pin.Type = O. OSC2, Buffer.Type = -. OSC2,  = Oscillator crystal output. Connects to crystal or resonator in Crystal Oscillator mode.. CLKO, Pin Number.DIP = . CLKO, Pin Number.SOIC = . CLKO, Pin.Type = O. CLKO, Buffer.Type = -. CLKO,",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS\n= In RC mode, OSC2 pin outputs CLKOUT which has 1/4 the frequency of OSC1, and denotes the instruction cycle rate.. RA6, Pin Number.DIP = . RA6, Pin Number.SOIC = . RA6, Pin.Type = I/O. RA6, Buffer.Type = TTL. RA6,  = General Purpose I/O pin.. , Pin Number.DIP = . , Pin Number.SOIC = . , Pin.Type = . , Buffer.Type = . ,  = PORTA is a bi-directional I/O port.. RA0/AN0, Pin Number.DIP = 2. RA0/AN0, Pin Number.SOIC = 2. RA0/AN0, Pin.Type = . RA0/AN0, Buffer.Type = . RA0/AN0,  = . RA0, Pin Number.DIP = . RA0, Pin Number.SOIC = . RA0, Pin.Type = I/O. RA0, Buffer.Type = TTL. RA0,",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS\n= Digital I/O.. AN0, Pin Number.DIP = . AN0, Pin Number.SOIC = . AN0, Pin.Type = I. AN0, Buffer.Type = Analog. AN0,  = Analog input 0.. RA1/AN1 RA1, Pin Number.DIP = 3. RA1/AN1 RA1, Pin Number.SOIC = 3. RA1/AN1 RA1, Pin.Type = I/O. RA1/AN1 RA1, Buffer.Type = TTL. RA1/AN1 RA1,  = Digital I/O.. AN1, Pin Number.DIP = . AN1, Pin Number.SOIC = . AN1, Pin.Type = I. AN1, Buffer.Type = Analog. AN1,",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS\n= Analog input 1.. RA2/AN2/VREF-, Pin Number.DIP = 4. RA2/AN2/VREF-, Pin Number.SOIC = 4. RA2/AN2/VREF-, Pin.Type = . RA2/AN2/VREF-, Buffer.Type = . RA2/AN2/VREF-,  = . RA2, Pin Number.DIP = . RA2, Pin Number.SOIC = . RA2, Pin.Type = I/O. RA2, Buffer.Type = TTL. RA2,  = Digital I/O.. AN2, Pin Number.DIP = . AN2, Pin Number.SOIC = . AN2, Pin.Type = I. AN2, Buffer.Type = Analog. AN2,  = Analog input 2.. VREF-, Pin Number.DIP = . VREF-, Pin Number.SOIC = . VREF-, Pin.Type = I. VREF-, Buffer.Type = Analog. VREF-,",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS\n= A/D Reference Voltage (Low) input.. RA3/AN3/VREF+, Pin Number.DIP = 5. RA3/AN3/VREF+, Pin Number.SOIC = 5. RA3/AN3/VREF+, Pin.Type = . RA3/AN3/VREF+, Buffer.Type = . RA3/AN3/VREF+,  = . RA3, Pin Number.DIP = . RA3, Pin Number.SOIC = . RA3, Pin.Type = I/O. RA3, Buffer.Type = TTL. RA3,  = Digital I/O.. AN3, Pin Number.DIP = . AN3, Pin Number.SOIC = . AN3, Pin.Type = I. AN3, Buffer.Type = Analog. AN3,  = Analog input 3.. VREF+, Pin Number.DIP = . VREF+, Pin Number.SOIC = . VREF+, Pin.Type = I. VREF+, Buffer.Type = Analog. VREF+,",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS\n= A/D Reference Voltage (High) input.. RA4/T0CKI, Pin Number.DIP = 6. RA4/T0CKI, Pin Number.SOIC = 6. RA4/T0CKI, Pin.Type = . RA4/T0CKI, Buffer.Type = . RA4/T0CKI,  = . RA4, Pin Number.DIP = . RA4, Pin Number.SOIC = . RA4, Pin.Type = I/O. RA4, Buffer.Type = ST/OD. RA4,  = Digital I/O. Open drain when configured as output.. T0CKI, Pin Number.DIP = . T0CKI, Pin Number.SOIC = . T0CKI, Pin.Type = I. T0CKI, Buffer.Type = ST. T0CKI,",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS\n= Timer0 external clock input.. RA5/AN4/SS/LVDIN, Pin Number.DIP = 7. RA5/AN4/SS/LVDIN, Pin Number.SOIC = 7. RA5/AN4/SS/LVDIN, Pin.Type = . RA5/AN4/SS/LVDIN, Buffer.Type = . RA5/AN4/SS/LVDIN,  = . RA5, Pin Number.DIP = . RA5, Pin Number.SOIC = . RA5, Pin.Type = I/O. RA5, Buffer.Type = TTL. RA5,  = Digital I/O.. AN4, Pin Number.DIP = . AN4, Pin Number.SOIC = . AN4, Pin.Type = I. AN4, Buffer.Type = Analog. AN4,  = Analog input 4.. SS, Pin Number.DIP = . SS, Pin Number.SOIC = . SS, Pin.Type = I. SS, Buffer.Type = ST. SS,",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS\n= SPI Slave Select input.. LVDIN, Pin Number.DIP = . LVDIN, Pin Number.SOIC = . LVDIN, Pin.Type = I. LVDIN, Buffer.Type = Analog. LVDIN,  = Low Voltage Detect Input.. RA6, Pin Number.DIP = . RA6, Pin Number.SOIC = . RA6, Pin.Type = . RA6, Buffer.Type = . RA6,  = See the OSC2/CLKO/RA6 pin.\nLegend:\nTTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels O = Output OD = Open Drain (no P diode to VDD)\nCMOS = CMOS compatible input or output\nI = Input\nP = Power",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRB0/INT0 RB0 INT0 RB1 INT1 RB2 INT2 RB3 CCP2 RB4 RB5 RB6, Pin Number.DIP = 21. RB0/INT0 RB0 INT0 RB1 INT1 RB2 INT2 RB3 CCP2 RB4 RB5 RB6, Pin Number.SOIC = 21. RB0/INT0 RB0 INT0 RB1 INT1 RB2 INT2 RB3 CCP2 RB4 RB5 RB6, Pin Type. = I/O I I/O I I/O I I/O I/O I/O I/O I/O I. RB0/INT0 RB0 INT0 RB1 INT1 RB2 INT2 RB3 CCP2 RB4 RB5 RB6, Buffer Type. = TTL ST TTL ST TTL ST TTL ST TTL TTL TTL ST TTL. RB0/INT0 RB0 INT0 RB1 INT1 RB2 INT2 RB3 CCP2 RB4 RB5 RB6, Description. = PORTB is a bi-directional I/O port. PORTB",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\ncan be software programmed for internal weak pull-ups on all inputs. Digital I/O. External Interrupt 0. External Interrupt 1. Digital I/O.. RB1/INT1, Pin Number.DIP = 22. RB1/INT1, Pin Number.SOIC = 22. RB1/INT1, Pin Type. = . RB1/INT1, Buffer Type. = . RB1/INT1, Description. = . RB2/INT2, Pin Number.DIP = 23. RB2/INT2, Pin Number.SOIC = 23. RB2/INT2, Pin Type. = . RB2/INT2, Buffer Type. = . RB2/INT2, Description. = External Interrupt 2.. RB3/CCP2, Pin Number.DIP = 24. RB3/CCP2, Pin Number.SOIC = 24. RB3/CCP2, Pin Type. = . RB3/CCP2, Buffer Type. = . RB3/CCP2, Description. = Digital I/O. Capture2 input, Compare2 output, PWM2",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\noutput.. , Pin Number.DIP = 25. , Pin Number.SOIC = 25. , Pin Type. = . , Buffer Type. = . , Description. = Digital I/O. Interrupt-on-change pin.. , Pin Number.DIP = 26. , Pin Number.SOIC = 26. , Pin Type. = . , Buffer Type. = . , Description. = Digital I/O. Interrupt-on-change pin.. , Pin Number.DIP = 27. , Pin Number.SOIC = 27. , Pin Type. = . , Buffer Type. = . , Description. = Digital I/O. Interrupt-on-change pin. ICSP programming clock.. RB7, Pin Number.DIP = 28. RB7, Pin Number.SOIC = 28. RB7, Pin Type. = I/O. RB7, Buffer Type. = . RB7, Description. = Digital I/O. Interrupt-on-change pin. ICSP programming data.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nST = Schmitt Trigger input with CMOS levels O = Output OD = Open Drain (no P diode to VDD)\nI = Input\nP = Power",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC0/T1OSO/T1CKI, Pin Number.DIP = 11. RC0/T1OSO/T1CKI, Pin Number.SOIC = 11. RC0/T1OSO/T1CKI, Pin.Type = I/O. RC0/T1OSO/T1CKI, Buffer.Type = ST. RC0/T1OSO/T1CKI, Description = Digital I/O.. RC0 T1OSO, Pin Number.DIP = . RC0 T1OSO, Pin Number.SOIC = . RC0 T1OSO, Pin.Type = O. RC0 T1OSO, Buffer.Type = -. RC0 T1OSO, Description = Timer1 oscillator output.. T1CKI, Pin Number.DIP = . T1CKI, Pin Number.SOIC = . T1CKI, Pin.Type = I. T1CKI, Buffer.Type = ST. T1CKI, Description = Timer1/Timer3 external clock input.. RC1/T1OSI/CCP2, Pin Number.DIP = 12.",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC1/T1OSI/CCP2, Pin Number.SOIC = 12. RC1/T1OSI/CCP2, Pin.Type = . RC1/T1OSI/CCP2, Buffer.Type = . RC1/T1OSI/CCP2, Description = . RC1, Pin Number.DIP = . RC1, Pin Number.SOIC = . RC1, Pin.Type = I/O. RC1, Buffer.Type = ST. RC1, Description = Digital I/O.. T1OSI, Pin Number.DIP = . T1OSI, Pin Number.SOIC = . T1OSI, Pin.Type = I. T1OSI, Buffer.Type = CMOS. T1OSI, Description = Timer1 oscillator input.. CCP2, Pin Number.DIP = . CCP2, Pin Number.SOIC = . CCP2, Pin.Type = I/O. CCP2, Buffer.Type = ST. CCP2, Description = Capture2 input, Compare2 output, PWM2 output..",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC2/CCP1, Pin Number.DIP = 13. RC2/CCP1, Pin Number.SOIC = 13. RC2/CCP1, Pin.Type = . RC2/CCP1, Buffer.Type = . RC2/CCP1, Description = . RC2, Pin Number.DIP = . RC2, Pin Number.SOIC = . RC2, Pin.Type = I/O. RC2, Buffer.Type = ST. RC2, Description = Digital I/O.. CCP1, Pin Number.DIP = . CCP1, Pin Number.SOIC = . CCP1, Pin.Type = I/O. CCP1, Buffer.Type = ST. CCP1, Description = Capture1 input/Compare1 output/PWM1 output.. RC3/SCK/SCL, Pin Number.DIP = 14. RC3/SCK/SCL, Pin Number.SOIC = 14. RC3/SCK/SCL, Pin.Type = . RC3/SCK/SCL, Buffer.Type",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= . RC3/SCK/SCL, Description = . RC3, Pin Number.DIP = . RC3, Pin Number.SOIC = . RC3, Pin.Type = I/O. RC3, Buffer.Type = ST. RC3, Description = Digital I/O.. SCK, Pin Number.DIP = . SCK, Pin Number.SOIC = . SCK, Pin.Type = I/O. SCK, Buffer.Type = ST. SCK, Description = Synchronous serial clock input/output for SPI mode.. SCL, Pin Number.DIP = . SCL, Pin Number.SOIC = . SCL, Pin.Type = I/O. SCL, Buffer.Type = ST. SCL, Description = Synchronous serial clock input/output for I 2 C mode.. RC4/SDI/SDA, Pin Number.DIP = 15. RC4/SDI/SDA, Pin Number.SOIC = 15. RC4/SDI/SDA, Pin.Type = .",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC4/SDI/SDA, Buffer.Type = . RC4/SDI/SDA, Description = . RC4, Pin Number.DIP = . RC4, Pin Number.SOIC = . RC4, Pin.Type = I/O. RC4, Buffer.Type = ST. RC4, Description = Digital I/O.. SDI, Pin Number.DIP = . SDI, Pin Number.SOIC = . SDI, Pin.Type = I. SDI, Buffer.Type = ST. SDI, Description = SPI Data In.. SDA, Pin Number.DIP = . SDA, Pin Number.SOIC = . SDA, Pin.Type = I/O. SDA, Buffer.Type = ST. SDA, Description = I 2 C Data I/O.. RC5/SDO, Pin Number.DIP = 16. RC5/SDO, Pin Number.SOIC = 16. RC5/SDO, Pin.Type = . RC5/SDO, Buffer.Type = . RC5/SDO, Description = .",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC5, Pin Number.DIP = . RC5, Pin Number.SOIC = . RC5, Pin.Type = I/O. RC5, Buffer.Type = ST. RC5, Description = Digital I/O.. SDO, Pin Number.DIP = . SDO, Pin Number.SOIC = . SDO, Pin.Type = O. SDO, Buffer.Type = -. SDO, Description = SPI Data Out.. RC6/TX/CK, Pin Number.DIP = 17. RC6/TX/CK, Pin Number.SOIC = 17. RC6/TX/CK, Pin.Type = . RC6/TX/CK, Buffer.Type = . RC6/TX/CK, Description = . RC6, Pin Number.DIP = . RC6, Pin Number.SOIC = . RC6, Pin.Type = I/O. RC6, Buffer.Type = ST. RC6, Description = Digital I/O.. TX, Pin Number.DIP = . TX, Pin Number.SOIC = . TX, Pin.Type = O.",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nTX, Buffer.Type = -. TX, Description = USART Asynchronous Transmit.. CK, Pin Number.DIP = . CK, Pin Number.SOIC = . CK, Pin.Type = I/O. CK, Buffer.Type = ST. CK, Description = USART Synchronous Clock (see related RX/DT).. RC7/RX/DT, Pin Number.DIP = 18. RC7/RX/DT, Pin Number.SOIC = 18. RC7/RX/DT, Pin.Type = . RC7/RX/DT, Buffer.Type = . RC7/RX/DT, Description = . RC7, Pin Number.DIP = . RC7, Pin Number.SOIC = . RC7, Pin.Type = I/O. RC7, Buffer.Type = ST. RC7, Description = Digital I/O.. RX, Pin Number.DIP = . RX, Pin Number.SOIC = . RX, Pin.Type = I. RX, Buffer.Type = ST. RX,",
    "TABLE 1-2: PIC18C2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nDescription = USART Asynchronous Receive.. DT, Pin Number.DIP = . DT, Pin Number.SOIC = . DT, Pin.Type = I/O. DT, Buffer.Type = ST. DT, Description = USART Synchronous Data (see related TX/CK).. VSS, Pin Number.DIP = 8, 19. VSS, Pin Number.SOIC = 8, 19. VSS, Pin.Type = P. VSS, Buffer.Type = -. VSS, Description = Ground reference for logic and I/O pins.. VDD, Pin Number.DIP = 20. VDD, Pin Number.SOIC = 20. VDD, Pin.Type = P. VDD, Buffer.Type = -. VDD, Description = Positive supply for logic and I/O pins.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI = Input\nO = Output\nP = Power\nOD = Open Drain (no P diode to VDD)",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS\nMCLR/VPP MCLR VPP, Pin Number.DIP = 1. MCLR/VPP MCLR VPP, Pin Number.PLCC = 2. MCLR/VPP MCLR VPP, Pin Number.TQFP = 18. MCLR/VPP MCLR VPP, Pin Type.Pin Type = I. MCLR/VPP MCLR VPP, Buffer Type.Buffer Type = ST. MCLR/VPP MCLR VPP, Description.Description = Master clear (input) or programming voltage (input). Master Clear (Reset) input. This pin is an active low RESET to the device. Programming voltage input.. NC, Pin Number.DIP = -. NC, Pin Number.PLCC = . NC, Pin Number.TQFP = . NC, Pin Type.Pin Type = -. NC, Buffer Type.Buffer Type = -. NC, Description.Description = These pins should be left unconnected.. OSC1/CLKI OSC1, Pin Number.DIP = 13. OSC1/CLKI OSC1, Pin Number.PLCC = 14.",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS\nOSC1/CLKI OSC1, Pin Number.TQFP = 30. OSC1/CLKI OSC1, Pin Type.Pin Type = I. OSC1/CLKI OSC1, Buffer Type.Buffer Type = ST. OSC1/CLKI OSC1, Description.Description = Oscillator crystal or external clock input. Oscillator crystal input or external clock source input. ST buffer when configured in RCmode, CMOSotherwise. External clock source input. Always associated with pin function OSC1. (See related OSC1/CLKIN, OSC2/CLKOUT pins.). OSC2/CLKO/RA6 OSC2 CLKO, Pin Number.DIP = 14. OSC2/CLKO/RA6 OSC2 CLKO, Pin Number.PLCC = 15. OSC2/CLKO/RA6 OSC2 CLKO, Pin Number.TQFP = 31. OSC2/CLKO/RA6 OSC2 CLKO, Pin Type.Pin Type = O O.",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS\nOSC2/CLKO/RA6 OSC2 CLKO, Buffer Type.Buffer Type = - -. OSC2/CLKO/RA6 OSC2 CLKO, Description.Description = Oscillator crystal output. Oscillator crystal output. Connects to crystal or resonator in Crystal Oscillator mode. In RC mode, OSC2 pin outputs CLKOUT, which has 1/4 the frequency of OSC1 and denotes the instruction cycle rate.. RA0/AN0 RA0, Pin Number.DIP = 2. RA0/AN0 RA0, Pin Number.PLCC = 3. RA0/AN0 RA0, Pin Number.TQFP = 19. RA0/AN0 RA0, Pin Type.Pin Type = I/O I. RA0/AN0 RA0, Buffer Type.Buffer Type = TTL Analog. RA0/AN0 RA0, Description.Description = Digital I/O. Analog input 0.. RA1/AN1 RA1 AN1 RA2/AN2/VREF-, Pin Number.DIP = 3.",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS\nRA1/AN1 RA1 AN1 RA2/AN2/VREF-, Pin Number.PLCC = 4. RA1/AN1 RA1 AN1 RA2/AN2/VREF-, Pin Number.TQFP = 20. RA1/AN1 RA1 AN1 RA2/AN2/VREF-, Pin Type.Pin Type = I/O I. RA1/AN1 RA1 AN1 RA2/AN2/VREF-, Buffer Type.Buffer Type = TTL Analog. RA1/AN1 RA1 AN1 RA2/AN2/VREF-, Description.Description = Digital I/O. Analog input 1.. VREF- RA3/AN3/VREF+ RA3 AN3 VREF+, Pin Number.DIP = 5. VREF- RA3/AN3/VREF+ RA3 AN3 VREF+, Pin Number.PLCC = 6. VREF- RA3/AN3/VREF+ RA3 AN3 VREF+, Pin Number.TQFP = 22. VREF-",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS\nRA3/AN3/VREF+ RA3 AN3 VREF+, Pin Type.Pin Type = I I/O I I. VREF- RA3/AN3/VREF+ RA3 AN3 VREF+, Buffer Type.Buffer Type = Analog TTL Analog Analog. VREF- RA3/AN3/VREF+ RA3 AN3 VREF+, Description.Description = A/D Reference Digital I/O. Analog A/D Reference Voltage (High) input. Digital I/O. Open drain when configured as output.. RA4/T0CKI RA4 T0CKI, Pin Number.DIP = 6. RA4/T0CKI RA4 T0CKI, Pin Number.PLCC = 7. RA4/T0CKI RA4 T0CKI, Pin Number.TQFP = 23. RA4/T0CKI RA4 T0CKI, Pin Type.Pin Type = I/O I. RA4/T0CKI RA4 T0CKI, Buffer Type.Buffer Type = ST/OD ST. RA4/T0CKI RA4 T0CKI,",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS\nDescription.Description = Timer0 external clock input.. RA5/AN4/SS/LVDIN RA5 AN4 SS, Pin Number.DIP = 7. RA5/AN4/SS/LVDIN RA5 AN4 SS, Pin Number.PLCC = 8. RA5/AN4/SS/LVDIN RA5 AN4 SS, Pin Number.TQFP = 24. RA5/AN4/SS/LVDIN RA5 AN4 SS, Pin Type.Pin Type = I/O I I. RA5/AN4/SS/LVDIN RA5 AN4 SS, Buffer Type.Buffer Type = TTL ST. RA5/AN4/SS/LVDIN RA5 AN4 SS, Description.Description = Digital I/O. Analog input 4. SPI Slave Select input.. LVDIN, Pin Number.DIP = . LVDIN, Pin Number.PLCC = . LVDIN, Pin Number.TQFP = . LVDIN, Pin Type.Pin Type = I. LVDIN, Buffer Type.Buffer Type = Analog Analog. LVDIN,",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS\nDescription.Description = Low Voltage Detect Input. See the OSC2/CLKO/RA6 pin.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels O = Output OD = Open Drain (no P diode to VDD)\nI = Input\nP = Power",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRB0/INT0 RB0 INT0 RB1 INT1 RB2 INT2 RB3 CCP2 RB4 RB5, Pin Number.DIP = 33. RB0/INT0 RB0 INT0 RB1 INT1 RB2 INT2 RB3 CCP2 RB4 RB5, Pin Number.PLCC = 36. RB0/INT0 RB0 INT0 RB1 INT1 RB2 INT2 RB3 CCP2 RB4 RB5, Pin Number.TQFP = 8. RB0/INT0 RB0 INT0 RB1 INT1 RB2 INT2 RB3 CCP2 RB4 RB5, Pin.Type = I/O I. RB0/INT0 RB0 INT0 RB1 INT1 RB2 INT2 RB3 CCP2 RB4 RB5, Buffer.Type = TTL ST. RB0/INT0 RB0 INT0 RB1 INT1 RB2 INT2 RB3 CCP2 RB4 RB5, Description = Digital I/O. External Interrupt 0.. RB1/INT1, Pin Number.DIP = 34. RB1/INT1, Pin",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PLCC = 37. RB1/INT1, Pin Number.TQFP = 9. RB1/INT1, Pin.Type = I/O I. RB1/INT1, Buffer.Type = TTL ST. RB1/INT1, Description = External Interrupt 1.. RB2/INT2, Pin Number.DIP = 35. RB2/INT2, Pin Number.PLCC = 38. RB2/INT2, Pin Number.TQFP = 10. RB2/INT2, Pin.Type = I/O I. RB2/INT2, Buffer.Type = TTL ST. RB2/INT2, Description = Digital I/O. External Interrupt 2.. RB3/CCP2, Pin Number.DIP = 36. RB3/CCP2, Pin Number.PLCC = 39. RB3/CCP2, Pin Number.TQFP = 11. RB3/CCP2, Pin.Type = I/O I/O. RB3/CCP2, Buffer.Type = TTL ST. RB3/CCP2, Description",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= Digital I/O. Capture2 input, Compare2 output, PWM2 output.. , Pin Number.DIP = 37. , Pin Number.PLCC = 41. , Pin Number.TQFP = 14. , Pin.Type = I/O. , Buffer.Type = TTL. , Description = Digital I/O. Interrupt-on-change pin.. , Pin Number.DIP = 38. , Pin Number.PLCC = 42. , Pin Number.TQFP = 15. , Pin.Type = I/O. , Buffer.Type = TTL. , Description = Digital I/O. Interrupt-on-change pin.. RB6, Pin Number.DIP = 39. RB6, Pin Number.PLCC = 43. RB6, Pin Number.TQFP = 16. RB6, Pin.Type = I/O I. RB6, Buffer.Type = TTL ST. RB6, Description = Digital I/O. Interrupt-on-change pin. ICSP programming clock.. RB7, Pin Number.DIP = 40. RB7, Pin Number.PLCC =",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n44. RB7, Pin Number.TQFP = 17. RB7, Pin.Type = I/O I/O. RB7, Buffer.Type = TTL ST. RB7, Description = Digital I/O. Interrupt-on-change pin. ICSP programming data.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI = Input\nO = Output\nP = Power\nOD = Open Drain (no P diode to VDD)",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC0/T1OSO/T1CKI, Pin Number.DIP = 15. RC0/T1OSO/T1CKI, Pin Number.PLCC = 16. RC0/T1OSO/T1CKI, Pin Number.TQFP = 32. RC0/T1OSO/T1CKI, Pin Type.Pin Type = I/O. RC0/T1OSO/T1CKI, Buffer Type.Buffer Type = ST. RC0/T1OSO/T1CKI, Description.Description = Digital I/O.. RC0 T1OSO, Pin Number.DIP = . RC0 T1OSO, Pin Number.PLCC = . RC0 T1OSO, Pin Number.TQFP = . RC0 T1OSO, Pin Type.Pin Type = O. RC0 T1OSO, Buffer Type.Buffer Type = -. RC0 T1OSO, Description.Description = Timer1 oscillator output.. T1CKI, Pin Number.DIP = . T1CKI, Pin Number.PLCC = . T1CKI, Pin Number.TQFP = .",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nT1CKI, Pin Type.Pin Type = I. T1CKI, Buffer Type.Buffer Type = ST. T1CKI, Description.Description = Timer1/Timer3 external clock input.. RC1/T1OSI/CCP2, Pin Number.DIP = 16. RC1/T1OSI/CCP2, Pin Number.PLCC = 18. RC1/T1OSI/CCP2, Pin Number.TQFP = 35. RC1/T1OSI/CCP2, Pin Type.Pin Type = . RC1/T1OSI/CCP2, Buffer Type.Buffer Type = . RC1/T1OSI/CCP2, Description.Description = . RC1, Pin Number.DIP = . RC1, Pin Number.PLCC = . RC1, Pin Number.TQFP = . RC1, Pin Type.Pin Type = I/O. RC1, Buffer Type.Buffer Type = ST. RC1, Description.Description = Digital I/O.. T1OSI, Pin Number.DIP = . T1OSI, Pin Number.PLCC =",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n. T1OSI, Pin Number.TQFP = . T1OSI, Pin Type.Pin Type = I. T1OSI, Buffer Type.Buffer Type = CMOS. T1OSI, Description.Description = Timer1 oscillator input.. CCP2, Pin Number.DIP = . CCP2, Pin Number.PLCC = . CCP2, Pin Number.TQFP = . CCP2, Pin Type.Pin Type = I/O. CCP2, Buffer Type.Buffer Type = ST. CCP2, Description.Description = Capture2 input, Compare2 output, PWM2 output.. RC2/CCP1, Pin Number.DIP = 17. RC2/CCP1, Pin Number.PLCC = 19. RC2/CCP1, Pin Number.TQFP = 36. RC2/CCP1, Pin Type.Pin Type = . RC2/CCP1, Buffer Type.Buffer Type = . RC2/CCP1, Description.Description = . RC2 CCP1, Pin Number.DIP = . RC2",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nCCP1, Pin Number.PLCC = . RC2 CCP1, Pin Number.TQFP = . RC2 CCP1, Pin Type.Pin Type = I/O. RC2 CCP1, Buffer Type.Buffer Type = ST. RC2 CCP1, Description.Description = Digital I/O.. RC3/SCK/SCL, Pin Number.DIP = 18. RC3/SCK/SCL, Pin Number.PLCC = 20. RC3/SCK/SCL, Pin Number.TQFP = 37. RC3/SCK/SCL, Pin Type.Pin Type = . RC3/SCK/SCL, Buffer Type.Buffer Type = . RC3/SCK/SCL, Description.Description = . RC3, Pin Number.DIP = . RC3, Pin Number.PLCC = . RC3, Pin Number.TQFP = . RC3, Pin Type.Pin Type = I/O. RC3, Buffer Type.Buffer Type = ST. RC3, Description.Description = Digital I/O.. SCK, Pin",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.DIP = . SCK, Pin Number.PLCC = . SCK, Pin Number.TQFP = . SCK, Pin Type.Pin Type = I/O. SCK, Buffer Type.Buffer Type = ST. SCK, Description.Description = Synchronous serial clock input/output for SPI mode.. SCL, Pin Number.DIP = . SCL, Pin Number.PLCC = . SCL, Pin Number.TQFP = . SCL, Pin Type.Pin Type = I/O. SCL, Buffer Type.Buffer Type = ST. SCL, Description.Description = Synchronous serial clock input/output for I 2 C mode.. RC4/SDI/SDA, Pin Number.DIP = 23. RC4/SDI/SDA, Pin Number.PLCC = 25. RC4/SDI/SDA, Pin Number.TQFP = 42. RC4/SDI/SDA, Pin Type.Pin Type = . RC4/SDI/SDA, Buffer Type.Buffer Type = .",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC4/SDI/SDA, Description.Description = . RC4, Pin Number.DIP = . RC4, Pin Number.PLCC = . RC4, Pin Number.TQFP = . RC4, Pin Type.Pin Type = I/O. RC4, Buffer Type.Buffer Type = ST. RC4, Description.Description = Digital I/O. SPI Data In.. SDI, Pin Number.DIP = . SDI, Pin Number.PLCC = . SDI, Pin Number.TQFP = . SDI, Pin Type.Pin Type = I. SDI, Buffer Type.Buffer Type = ST. SDI, Description.Description = . SDA, Pin Number.DIP = . SDA, Pin Number.PLCC = . SDA, Pin Number.TQFP = . SDA, Pin Type.Pin Type = I/O. SDA, Buffer Type.Buffer Type = ST. SDA, Description.Description = I 2 C Data I/O.. RC5/SDO, Pin Number.DIP = 24. RC5/SDO, Pin",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PLCC = 26. RC5/SDO, Pin Number.TQFP = 43. RC5/SDO, Pin Type.Pin Type = I/O. RC5/SDO, Buffer Type.Buffer Type = ST. RC5/SDO, Description.Description = Digital I/O.. RC5, Pin Number.DIP = . RC5, Pin Number.PLCC = . RC5, Pin Number.TQFP = . RC5, Pin Type.Pin Type = . RC5, Buffer Type.Buffer Type = . RC5, Description.Description = . SDO, Pin Number.DIP = . SDO, Pin Number.PLCC = . SDO, Pin Number.TQFP = . SDO, Pin Type.Pin Type = O. SDO, Buffer Type.Buffer Type = -. SDO, Description.Description = SPI Data Out.. RC6/TX/CK, Pin Number.DIP = 25. RC6/TX/CK, Pin Number.PLCC = 27. RC6/TX/CK, Pin Number.TQFP = 44.",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC6/TX/CK, Pin Type.Pin Type = I/O. RC6/TX/CK, Buffer Type.Buffer Type = . RC6/TX/CK, Description.Description = Digital I/O.. RC6, Pin Number.DIP = . RC6, Pin Number.PLCC = . RC6, Pin Number.TQFP = . RC6, Pin Type.Pin Type = O. RC6, Buffer Type.Buffer Type = ST -. RC6, Description.Description = USART Asynchronous Transmit.. TX, Pin Number.DIP = . TX, Pin Number.PLCC = . TX, Pin Number.TQFP = . TX, Pin Type.Pin Type = . TX, Buffer Type.Buffer Type = . TX, Description.Description = . CK, Pin Number.DIP = . CK, Pin Number.PLCC = . CK, Pin Number.TQFP = . CK, Pin Type.Pin Type = I/O. CK, Buffer Type.Buffer Type = ST. CK, Description.Description = USART Synchronous Clock (see related",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRX/DT).. RC7/RX/DT, Pin Number.DIP = 26. RC7/RX/DT, Pin Number.PLCC = 29. RC7/RX/DT, Pin Number.TQFP = 1. RC7/RX/DT, Pin Type.Pin Type = . RC7/RX/DT, Buffer Type.Buffer Type = . RC7/RX/DT, Description.Description = . RC7, Pin Number.DIP = . RC7, Pin Number.PLCC = . RC7, Pin Number.TQFP = . RC7, Pin Type.Pin Type = I/O. RC7, Buffer Type.Buffer Type = ST. RC7, Description.Description = Digital I/O.. RX, Pin Number.DIP = . RX, Pin Number.PLCC = . RX, Pin Number.TQFP = . RX, Pin Type.Pin Type = I. RX, Buffer Type.Buffer Type = ST. RX, Description.Description = USART Asynchronous Receive.. DT, Pin",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.DIP = . DT, Pin Number.PLCC = . DT, Pin Number.TQFP = . DT, Pin Type.Pin Type = I/O. DT, Buffer Type.Buffer Type = ST. DT, Description.Description = USART Synchronous Data (see related TX/CK).\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI = Input\nO = Output\nP = Power\nOD = Open Drain (no P diode to VDD)",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD0/PSP0, Pin Number.DIP = 19. RD0/PSP0, Pin Number.PLCC = 21. RD0/PSP0, Pin Number.TQFP = 38. RD0/PSP0, Pin.Type = I/O. RD0/PSP0, Buffer.Type = ST TTL. RD0/PSP0, Description = (PSP) for interfacing to a microprocessor port. These pins have TTL input buffers when PSP module is enabled. Digital I/O. Parallel Slave Port Data.. RD1/PSP1, Pin Number.DIP = 20. RD1/PSP1, Pin Number.PLCC = 22. RD1/PSP1, Pin Number.TQFP = 39. RD1/PSP1, Pin.Type = I/O. RD1/PSP1, Buffer.Type = ST TTL. RD1/PSP1, Description = Digital I/O. Parallel Slave Port Data.. RD2/PSP2, Pin Number.DIP = 21.",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD2/PSP2, Pin Number.PLCC = 23. RD2/PSP2, Pin Number.TQFP = 40. RD2/PSP2, Pin.Type = I/O. RD2/PSP2, Buffer.Type = ST TTL. RD2/PSP2, Description = Digital I/O. Parallel Slave Port Data.. RD3/PSP3, Pin Number.DIP = 22. RD3/PSP3, Pin Number.PLCC = 24. RD3/PSP3, Pin Number.TQFP = 41. RD3/PSP3, Pin.Type = I/O. RD3/PSP3, Buffer.Type = ST TTL. RD3/PSP3, Description = Digital I/O. Parallel Slave Port. RD4/PSP4, Pin Number.DIP = 27. RD4/PSP4, Pin Number.PLCC = 30. RD4/PSP4, Pin Number.TQFP = 2. RD4/PSP4, Pin.Type = I/O.",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD4/PSP4, Buffer.Type = ST TTL. RD4/PSP4, Description = Digital I/O. Parallel Slave Port Data.. RD5/PSP5, Pin Number.DIP = 28. RD5/PSP5, Pin Number.PLCC = 31. RD5/PSP5, Pin Number.TQFP = 3. RD5/PSP5, Pin.Type = I/O. RD5/PSP5, Buffer.Type = ST TTL. RD5/PSP5, Description = Digital I/O. Parallel Slave Port Data.. RD6/PSP6, Pin Number.DIP = 29. RD6/PSP6, Pin Number.PLCC = 32. RD6/PSP6, Pin Number.TQFP = 4. RD6/PSP6, Pin.Type = I/O. RD6/PSP6, Buffer.Type = ST TTL. RD6/PSP6, Description = Digital I/O. Parallel Slave Port. RD7/PSP7, Pin Number.DIP = 30.",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD7/PSP7, Pin Number.PLCC = 33. RD7/PSP7, Pin Number.TQFP = 5. RD7/PSP7, Pin.Type = I/O. RD7/PSP7, Buffer.Type = ST TTL. RD7/PSP7, Description = Digital I/O. Parallel Slave Port Data.. RE0/RD/AN5 RE0 RD, Pin Number.DIP = 8. RE0/RD/AN5 RE0 RD, Pin Number.PLCC = 9. RE0/RD/AN5 RE0 RD, Pin Number.TQFP = 25. RE0/RD/AN5 RE0 RD, Pin.Type = I/O. RE0/RD/AN5 RE0 RD, Buffer.Type = ST TTL. RE0/RD/AN5 RE0 RD, Description = PORTE is a bi-directional I/O port. Digital I/O. Read control for parallel slave port (see also WR. AN5 RE1/WR/AN6 RE1, Pin Number.DIP = 9. AN5",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRE1/WR/AN6 RE1, Pin Number.PLCC = 10. AN5 RE1/WR/AN6 RE1, Pin Number.TQFP = 26. AN5 RE1/WR/AN6 RE1, Pin.Type = I/O. AN5 RE1/WR/AN6 RE1, Buffer.Type = Analog ST. AN5 RE1/WR/AN6 RE1, Description = Analog input 5. Digital I/O.. AN6 RE2/CS/AN7 RE2 CS, Pin Number.DIP = 10. AN6 RE2/CS/AN7 RE2 CS, Pin Number.PLCC = 11. AN6 RE2/CS/AN7 RE2 CS, Pin Number.TQFP = 27. AN6 RE2/CS/AN7 RE2 CS, Pin.Type = I/O. AN6 RE2/CS/AN7 RE2 CS, Buffer.Type = Analog. AN6 RE2/CS/AN7 RE2 CS, Description = Analog input 6.. AN7, Pin Number.DIP = 12, 31.",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nAN7, Pin Number.PLCC = 13, 34. AN7, Pin Number.TQFP = 6, 29. AN7, Pin.Type = . AN7, Buffer.Type = Analog -. AN7, Description = Analog input 7. Ground reference for logic and I/O pins.. VSS, Pin Number.DIP = . VSS, Pin Number.PLCC = . VSS, Pin Number.TQFP = . VSS, Pin.Type = P. VSS, Buffer.Type = . VSS, Description = . VDD, Pin Number.DIP = 11, 32. VDD, Pin Number.PLCC = 12, 35. VDD, Pin Number.TQFP = 7, 28. VDD, Pin.Type = P. VDD, Buffer.Type = -. VDD, Description = Positive supply for logic and I/O pins.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI = Input\nO = Output\nP = Power",
    "TABLE 1-3: PIC18C4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nOD = Open Drain (no P diode to VDD)",
    "2.1 Oscillator Types\nThe  PIC18CXX2  can  be  operated  in  eight  different oscillator modes. The user can program three configuration bits (FOSC2, FOSC1, and FOSC0) to select one of these eight modes:\n1. LP\nLow Power Crystal\n2. XT\nCrystal/Resonator\n3. HS\nHigh Speed Crystal/Resonator\n4. HS + PLL\nHigh Speed Crystal/Resonator\nwith x 4 PLL enabled\n5. RC\nExternal Resistor/Capacitor\n6. RCIO\nExternal Resistor/Capacitor with\nRA6 I/O pin enabled\n7. EC\nExternal Clock\n8. ECIO\nExternal Clock with RA6 I/O pin enabled",
    "2.2 Crystal Oscillator/Ceramic Resonators\nIn XT, LP, HS or HS-PLL oscillator modes, a crystal or ceramic  resonator  is  connected  to  the  OSC1  and OSC2 pins to establish  oscillation.  Figure 2-1  shows the pin connections.\nThe PIC18CXX2 oscillator design requires the use of a parallel cut crystal.",
    "Note:\nUse of a series cut crystal may give a fre- quency  out  of  the  crystal  manufacturers specifications.",
    "FIGURE 2-1:\nCRYSTAL/CERAMIC RESONATOR OPERATION (HS, XT OR LP OSC CONFIGURATION)\nNote 1: See  Table 2-1  and  Table 2-2  for  recommended values of C1 and C2.\n2: A series resistor (RS) may be required for AT strip cut crystals.\n3: RF varies with the osc mode chosen.",
    "Ranges Tested:\nXT, Freq = 455 kHz 2.0 MHz 4.0 MHz. XT, C1 = 68 - 100 pF 15 - 68 pF 15 - 68 pF. XT, C2 = 68 - 100 pF 15 - 68 pF 15 - 68 pF. HS, Freq = 8.0 MHz 16.0 MHz. HS, C1 = 10 - 68 pF 10 - 22 pF. HS, C2 = 10 - 68 pF 10 - 22 pF\nThese values are for design guidance only. See notes following this table.",
    "Ranges Tested:\n455 kHz, Resonators Used: = Panasonic EFO-A455K04B. 455 kHz, Resonators Used: = \uf0b1 0.3%. 2.0 MHz, Resonators Used: = Murata Erie CSA2.00MG. 2.0 MHz, Resonators Used: = \uf0b1 0.5%. 4.0 MHz, Resonators Used: = Murata Erie CSA4.00MG. 4.0 MHz, Resonators Used: = \uf0b1 0.5%. 8.0 MHz, Resonators Used: = Murata Erie CSA8.00MT. 8.0 MHz, Resonators Used: = \uf0b1 0.5%. 16.0 MHz, Resonators Used: = Murata Erie CSA16.00MX. 16.0 MHz, Resonators Used: = \uf0b1 0.5%. All resonators used did not have built-in capacitors., Resonators Used: = All resonators used did not have built-in capacitors.. All resonators used did not have built-in capacitors., Resonators Used: = All resonators used did not have",
    "Ranges Tested:\nbuilt-in capacitors.\nNote 1: Higher capacitance increases the stability of  the  oscillator,  but  also  increases  the start-up time.\n2: When operating below 3V VDD, it may be necessary to use high gain HS mode on lower frequency ceramic resonators.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer for appropriate  values  of  external  components or verify oscillator performance.",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATORS\nLP, Ranges Tested:.Freq = 32.0 kHz. LP, Ranges Tested:.C1 = 33 pF. LP, Ranges Tested:.C2 = 33 pF. LP, Ranges Tested:.Freq = 200 kHz. LP, Ranges Tested:.C1 = 15 pF. LP, Ranges Tested:.C2 = 15 pF. XT, Ranges Tested:.Freq = 200 kHz. XT, Ranges Tested:.C1 = 47-68 pF. XT, Ranges Tested:.C2 = 47-68 pF. XT, Ranges Tested:.Freq = 1.0 MHz. XT, Ranges Tested:.C1 = 15 pF. XT, Ranges Tested:.C2 = 15 pF. XT, Ranges Tested:.Freq = 4.0 MHz. XT, Ranges Tested:.C1 = 15 pF. XT, Ranges Tested:.C2 = 15 pF. HS, Ranges Tested:.Freq = 4.0 MHz. HS, Ranges Tested:.C1 = 15 pF. HS, Ranges Tested:.C2 = 15",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATORS\npF. HS, Ranges Tested:.Freq = 8.0 MHz. HS, Ranges Tested:.C1 = 15-33 pF. HS, Ranges Tested:.C2 = 15-33 pF. HS, Ranges Tested:.Freq = 20.0 MHz. HS, Ranges Tested:.C1 = 15-33 pF. HS, Ranges Tested:.C2 = 15-33 pF. HS, Ranges Tested:.Freq = 25.0 MHz. HS, Ranges Tested:.C1 = 15-33 pF. HS, Ranges Tested:.C2 = 15-33 pF\nThese values are for design guidance only. See notes following this table.",
    "Crystals Used\n32.0 kHz, 1 = Epson C-001R32.768K-A. 32.0 kHz, 2 = \u00b1 20 PPM. 200 kHz, 1 = STD XTL 200.000kHz. 200 kHz, 2 = \u00b1 20 PPM. 1.0 MHz, 1 = ECS ECS-10-13-1. 1.0 MHz, 2 = \u00b1 50 PPM. 4.0 MHz, 1 = ECS ECS-40-20-1. 4.0 MHz, 2 = \u00b1 50 PPM. 8.0 MHz, 1 = Epson CA-301 8.000M-C. 8.0 MHz, 2 = \u00b1 30 PPM. 20.0 MHz, 1 = Epson CA-301 20.000M-C. 20.0 MHz, 2 = \u00b1 30 PPM",
    "Crystals Used\nNote 1: Higher capacitance increases the stability of  the  oscillator,  but  also  increases  the start-up time.\n2: Rs may be required in HS mode, as well as XT mode, to avoid overdriving crystals with low drive level specification.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer for appropriate  values  of  external  components or verify oscillator performance.\nAn external clock source may also be connected to the OSC1 pin in these modes, as shown in Figure 2-2.",
    "FIGURE 2-2: EXTERNAL CLOCK INPUT\nOPERATION (HS, XT OR LP CONFIGURATION)",
    "2.3 RC Oscillator\nFor timing insensitive applications, the 'RC'  and \"RCIO\"  device  options  offer  additional  cost  savings. The RC oscillator frequency is a function of the supply voltage, the resistor (REXT) and capacitor (CEXT) values and the operating temperature. In addition to this, the oscillator frequency will vary from unit to unit due to normal process parameter variation. Furthermore, the difference in lead frame capacitance between package types  will  also  affect  the  oscillation  frequency,  especially for low CEXT values. The user also needs to take into  account  variation  due  to  tolerance  of  external  R and  C  components  used.  Figure 2-3  shows  how  the R/C combination is connected.\nIn  the  RC  oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic.",
    "FIGURE 2-3: RC OSCILLATOR MODE\nThe RCIO oscillator mode functions like the RC mode, except that the OSC2 pin becomes an additional general  purpose  I/O  pin.  The  I/O  pin  becomes  bit  6  of PORTA (RA6).",
    "2.4 External Clock Input\nThe EC and ECIO oscillator modes require an external clock  source  to  be  connected  to  the  OSC1  pin.  The feedback device between OSC1 and OSC2 is turned off in these modes to save current. There is no oscillator  start-up  time  required  after  a  Power-on  Reset  or after a recovery from SLEEP mode.\nIn  the  EC  oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic. Figure 2-4 shows the pin connections for the EC oscillator mode.",
    "OPERATION (EC OSC CONFIGURATION)\nThe ECIO oscillator mode functions like the EC mode, except that the OSC2 pin becomes an additional general  purpose  I/O  pin.  The  I/O  pin  becomes  bit  6  of PORTA (RA6). Figure 2-5 shows the pin connections for the ECIO oscillator mode.",
    "2.5 HS/PLL\nA Phase Locked Loop circuit is provided as a programmable  option  for  users  that  want  to  multiply  the  frequency of the incoming crystal oscillator signal by 4. For an input clock frequency of 10 MHz, the internal clock  frequency will be multiplied to  40 MHz. This is useful for customers who are concerned with EMI due to high frequency crystals.\nThe PLL can only be enabled when the oscillator configuration bits are programmed for HS mode. If they are programmed  for  any  other  mode,  the  PLL  is  not enabled and the system clock will come directly from OSC1.\nThe PLL is one of the modes of the FOSC<2:0> configuration  bits.  The  oscillator  mode  is  specified  during device programming.\nA PLL lock timer is used to ensure that the PLL has locked  before  device  execution  starts.  The  PLL  lock timer has a time-out that is called TPLL.",
    "2.6 Oscillator Switching Feature\nThe PIC18CXX2 devices include a feature that allows the system clock source to be switched from the main oscillator to an alternate low frequency clock source. For the PIC18CXX2  devices,  this  alternate  clock source is the Timer1 oscillator. If a low frequency crystal  (32  kHz,  for  example)  has  been  attached  to  the Timer1  oscillator  pins  and  the  Timer1  oscillator  has been enabled, the device can switch to a low power execution mode. Figure 2-7 shows a block diagram of the system clock sources. The clock switching feature is  enabled  by  programming  the  Oscillator  Switching Enable (OSCSEN) bit in Configuration Register1H to a '0'.  Clock  switching  is  disabled  in  an  erased  device. See Section 9.0 for further details of the Timer1 oscillator. See Section 18.0 for Configuration Register details.",
    "2.6.1 SYSTEM CLOCK SWITCH BIT\nThe system clock source switching is performed under software  control.  The  system  clock  switch  bit,  SCS (OSCCON<0>) controls the clock switching. When the SCS bit is'0', the system clock source comes from the main oscillator that is selected by the FOSC configuration bits in Configuration Register1H. When the SCS bit is  set,  the  system  clock  source  will  come  from  the Timer1 oscillator. The SCS bit is cleared on all forms of RESET.\nNote:\nThe Timer1 oscillator must be enabled and operating to switch the system clock source. The Timer1 oscillator is enabled by setting  the  T1OSCEN  bit  in  the  Timer1 control  register  (T1CON).  If  the  Timer1 oscillator is not enabled, then any write to the SCS bit will be ignored (SCS bit forced cleared)  and  the  main  oscillator  will  continue to be the system clock source.",
    "REGISTER 2-1: OSCCON REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = SCS\nbit 7\nbit 0\nbit 7-1 Unimplemented: Read as '0'\nbit 0\nSCS: System Clock Switch bit\nWhen OSCSEN configuration bit = '0' and T1OSCEN bit is set:\n1 =  Switch to Timer1 oscillator/clock pin\n0 =  Use primary oscillator/clock input pin\nWhen OSCSEN and T1OSCEN are in other states:\nbit is forced clear\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set",
    "REGISTER 2-1: OSCCON REGISTER\n'0' = Bit is cleared\nx = Bit is unknown",
    "2.6.2 OSCILLATOR TRANSITIONS\nThe  PIC18CXX2  devices  contain  circuitry  to  prevent \"glitches\" when switching between oscillator sources. Essentially, the circuitry waits for eight rising edges of the clock source that the processor is switching to. This ensures that the new clock source is stable and that it's pulse  width  will  not  be  less  than  the  shortest  pulse width of the two clock sources.\nA timing diagram indicating the transition from the main oscillator to the Timer1 oscillator is shown in Figure 2-8. The Timer1 oscillator is assumed to be running all the time. After the SCS bit is set, the processor is frozen at the next occurring Q1 cycle. After eight synchronization cycles are counted from the Timer1 oscillator,  operation  resumes.  No  additional  delays  are required after the synchronization cycles.",
    "FIGURE 2-8: TIMING DIAGRAM FOR TRANSITION FROM OSC1 TO TIMER1 OSCILLATOR\nThe sequence of events that takes place when switching from the Timer1 oscillator to the main oscillator will depend on the mode of the main oscillator. In addition to  eight clock cycles of the main oscillator, additional delays may take place.\nIf the main oscillator is configured for an external crystal (HS, XT, LP), then the transition will take place after an oscillator start-up time (TOST) has occurred. A timing diagram indicating the transition from the Timer1 oscillator to the main oscillator for HS, XT and LP modes is shown in Figure 2-9.",
    "TIMING FOR TRANSITION BETWEEN TIMER1 AND OSC1 (HS, XT, LP)\nNote 1: TOST = 1024TOSC (drawing not to scale).",
    "PIC18CXX2\nIf the main oscillator is configured for HS-PLL mode, an oscillator  start-up  time  (TOST)  plus  an  additional  PLL time-out (TPLL) will occur. The PLL time-out is typically 2 ms and allows the PLL to lock to the main oscillator frequency.  A timing  diagram,  indicating  the  transition from  the  Timer1  oscillator  to  the  main  oscillator  for HS-PLL mode, is shown in Figure 2-10.",
    "FIGURE 2-10: TIMING FOR TRANSITION BETWEEN TIMER1 AND OSC1 (HS WITH PLL)\nIf the main oscillator is configured in the RC, RCIO, EC or ECIO modes, there is no oscillator start-up time-out. Operation  will  resume  after  eight  cycles  of  the  main oscillator have been counted. A timing diagram, indi- cating the transition from the Timer1 oscillator to the main oscillator for RC, RCIO, EC and ECIO modes, is shown in Figure 2-11.",
    "2.7 Effects of SLEEP Mode on the On-chip Oscillator\nWhen  the  device  executes  a SLEEP instruction,  the on-chip  clocks  and  oscillator  are  turned  off  and  the device is held at the beginning of an instruction cycle (Q1 state). With the oscillator off, the OSC1 and OSC2 signals  will  stop  oscillating.  Since  all  the  transistor switching currents have been removed, SLEEP mode achieves the lowest current consumption of the device (only leakage currents). Enabling any on-chip feature that will operate during SLEEP will increase the current consumed  during  SLEEP.  The  user  can  wake  from SLEEP  through  external  RESET,  Watchdog  Timer Reset, or through an interrupt.",
    "2.7 Effects of SLEEP Mode on the On-chip Oscillator\nTABLE 2-3: OSC1 AND OSC2 PIN STATES IN SLEEP MODE\n\nRC, OSC1 Pin = Floating, external resistor should pull high. RC, OSC2 Pin = At logic low. RCIO, OSC1 Pin = Floating, external resistor should pull high. RCIO, OSC2 Pin = Configured as PORTA, bit 6. ECIO, OSC1 Pin = Floating. ECIO, OSC2 Pin = Configured as PORTA, bit 6. EC, OSC1 Pin = Floating. EC, OSC2 Pin = At logic low. LP, XT, and HS, OSC1 Pin = Feedback inverter disabled, at quiescent voltage level. LP, XT, and HS, OSC2 Pin = Feedback inverter disabled, at quiescent voltage level\nNote: See Table 3-1, in Section 3.0 RESET, for time-outs due to SLEEP and MCLR Reset.",
    "2.8 Power-up Delays\nPower up delays are controlled by two timers, so that no external RESET circuitry is required for most applications. The delays ensure that the device is kept in RESET until the device power supply and clock are stable.  For  additional  information  on  RESET  operation, see the 'RESET' section.\nThe first timer is the Power-up Timer (PWRT), which optionally provides a fixed delay of 72 ms (nominal) on power-up only (POR and BOR). The second timer is the Oscillator Start-up Timer, OST, intended to keep the chip in RESET until the crystal oscillator is stable.",
    "2.8 Power-up Delays\nWith  the  PLL  enabled  (HS/PLL  oscillator  mode),  the time-out sequence following a Power-on Reset is different from other oscillator modes. The time-out sequence is as follows: First, the PWRT time-out is invoked after a  POR  time  delay  has  expired.  Then,  the  Oscillator Start-up Timer (OST) is invoked. However, this is still not a sufficient amount of time to allow the PLL to lock at high frequencies. The PWRT timer is used to provide an additional fixed 2ms (nominal) time-out to allow the PLL ample time to lock to the incoming clock frequency.",
    "PIC18CXX2\nNOTES:",
    "3.0 RESET\nThe PIC18CXX2 differentiates between various kinds of RESET:\na) Power-on Reset (POR)\nb) MCLR Reset during normal operation\nc) MCLR Reset during SLEEP\nd) Watchdog  Timer  (WDT)  Reset  (during  normal operation)\ne) Programmable Brown-out Reset (BOR)\nf) RESET Instruction\ng) Stack Full Reset\nh) Stack Underflow Reset\nMost  registers  are  not  affected  by  a  WDT  wake-up, since this is viewed as the resumption of normal operation. Status bits from the RCON register, RI, TO, PD, POR and BOR, are set or cleared differently in different RESET situations, as indicated in Table 3-2. These bits are  used  in  software  to  determine  the  nature  of  the RESET.  See  Table 3-3  for  a  full  description  of  the RESET states of all registers.\nA simplified block diagram of the On-Chip Reset Circuit is shown in Figure 3-1.\nThe Enhanced MCU devices have a MCLR noise filter in  the  MCLR  Reset  path.  The  filter  will  detect  and ignore small pulses.",
    "3.0 RESET\nMost registers are unaffected by a RESET. Their status is unknown  on  POR  and  unchanged  by  all  other RESETS. The other registers are forced to a 'RESET state' on Power-on Reset, MCLR, WDT Reset, Brownout  Reset,  MCLR  Reset  during  SLEEP,  and  by  the RESET instruction.\nMCLR pin is not driven low by any internal RESETS, including WDT.",
    "FIGURE 3-1: SIMPLIFIED BLOCK DIAGRAM OF ON-CHIP RESET CIRCUIT\nNote 1: This is a separate oscillator from the RC oscillator of the CLKIN pin.\n- 2: See Table 3-1 for time-out situations.",
    "3.1 Power-on Reset (POR)\nA  Power-on  Reset  pulse  is  generated  on-chip  when VDD rise is detected. To take advantage of the POR circuitry, just tie the MCLR pin directly (or through a resistor) to VDD. This will eliminate external RC components usually needed to create a Power-on Reset delay. A minimum  rise  rate  for  VDD  is  specified  (parameter D004). For a slow rise time, see Figure 3-2.\nWhen the device starts normal operation (i.e., exits the RESET condition), device operating parameters (voltage,  frequency,  temperature,  etc.)  must  be  met  to ensure operation. If these conditions are not met, the device must be held in reset until the operating conditions are met.",
    "EXTERNAL POWER-ON RESET CIRCUIT (FOR SLOW VDD POWER-UP)\nNote 1: External  Power-on  Reset  circuit  is  required only  if  the  VDD  power-up  slope  is  too  slow. The  diode  D  helps  discharge  the  capacitor quickly when VDD powers down.\n2: R < 40 k \uf057 is recommended to make sure that the  voltage  drop  across  R  does  not  violate the device's electrical specification.\n3: R1 = 100 \uf057 to 1 k \uf057 will limit any current flowing  into  MCLR from external capacitor C in the event of MCLR/VPP pin breakdown, due to Electrostatic Discharge (ESD) or Electrical Overstress (EOS).",
    "3.2 Power-up Timer (PWRT)\nThe Power-up Timer provides a fixed nominal time-out (parameter #33) only on power-up from the POR. The Power-up Timer operates on an internal RC oscillator. The chip is kept in reset as long as the PWRT is active. The PWRT's time delay allows VDD to rise to an acceptable  level.  A  configuration  bit  is  provided  to  enable/ disable the PWRT.\nThe power-up time delay will vary from chip-to-chip due to  VDD,  temperature  and  process  variation.  See  DC parameter #33 for details.",
    "3.3 Oscillator Start-up Timer (OST)\nThe Oscillator Start-up Timer (OST) provides a 1024 oscillator  cycle  (from  OSC1  input)  delay  after  the PWRT delay is over (parameter #32). This ensures that the  crystal  oscillator  or  resonator  has  started  and stabilized.\nThe OST time-out is invoked only for XT, LP and HS modes and only on Power-on Reset or wake-up from SLEEP.",
    "3.4 PLL Lock Time-out\nWith the PLL enabled, the time-out sequence following a  Power-on  Reset  is  different  from  other  oscillator modes. A portion of the Power-up Timer is used to provide a fixed time-out that is sufficient for the PLL to lock to the main oscillator frequency. This PLL lock time-out (TPLL) is typically 2 ms and follows the oscillator startup time-out (OST).",
    "3.5 Brown-out Reset (BOR)\nA  configuration  bit,  BOREN,  can  disable  (if  clear/ programmed), or enable (if set) the Brown-out Reset circuitry. If VDD falls below parameter D005 for greater than parameter #35, the brown-out situation will reset the chip. A RESET may not occur if VDD falls below parameter D005 for less than parameter #35. The chip will remain in Brown-out Reset until VDD rises above BVDD. The Power-up Timer will then be invoked and will keep the chip in RESET an additional time delay (parameter #33). If VDD drops below BVDD while the Power-up Timer is running, the chip will go back into a Brown-out Reset and the Power-up Timer will be initialized. Once VDD rises above BVDD, the Power-up Timer will execute the additional time delay.",
    "3.6 Time-out Sequence\nOn  power-up,  the  time-out  sequence  is  as  follows: First,  PWRT  time-out  is  invoked  after  the  POR  time delay has expired. Then, OST is activated. The total time-out will vary based on oscillator configuration and the status of the PWRT. For example, in RC mode with the  PWRT  disabled,  there  will  be  no  time-out  at  all. Figure 3-3, Figure 3-4, Figure 3-5, Figure 3-6 and Figure 3-7 depict time-out sequences on power-up.\nSince the time-outs occur from the POR pulse, if MCLR is  kept  low  long  enough,  the  time-outs  will  expire. Bringing MCLR high will begin execution immediately (Figure 3-5). This is useful for testing purposes or to synchronize more than one PIC18CXXX device operating in parallel.\nTable 3-2  shows  the  RESET  conditions  for  some Special Function Registers, while Table 3-3 shows the RESET conditions for all the registers.",
    "TABLE 3-1: TIME-OUT IN VARIOUS SITUATIONS\nHS with PLL enabled (1), Power-up (2).PWRTE = 0 = 72 ms + 1024T OSC + 2ms. HS with PLL enabled (1), Power-up (2).PWRTE = 1 = 1024T OSC + 2 ms. HS with PLL enabled (1), Brown-out (2).Brown-out (2) = 72 ms + 1024T OSC + 2ms. HS with PLL enabled (1), Wake-up from SLEEP or Oscillator Switch.Wake-up from SLEEP or Oscillator Switch = 1024T OSC + 2 ms. HS, XT, LP, Power-up (2).PWRTE = 0 = 72 ms + 1024T OSC. HS, XT, LP, Power-up (2).PWRTE = 1 = 1024T OSC. HS, XT, LP, Brown-out (2).Brown-out (2) = 72 ms + 1024T OSC. HS, XT, LP, Wake-up from SLEEP or Oscillator",
    "TABLE 3-1: TIME-OUT IN VARIOUS SITUATIONS\nSwitch.Wake-up from SLEEP or Oscillator Switch = 1024T OSC. EC, Power-up (2).PWRTE = 0 = 72 ms. EC, Power-up (2).PWRTE = 1 = -. EC, Brown-out (2).Brown-out (2) = 72 ms. EC, Wake-up from SLEEP or Oscillator Switch.Wake-up from SLEEP or Oscillator Switch = -. External RC, Power-up (2).PWRTE = 0 = 72 ms. External RC, Power-up (2).PWRTE = 1 = -. External RC, Brown-out (2).Brown-out (2) = 72 ms. External RC, Wake-up from SLEEP or Oscillator Switch.Wake-up from SLEEP or Oscillator Switch = -\nNote 1: 2 ms is the nominal time required for the 4x PLL to lock.\n- 2: 72 ms is the nominal Power-up Timer delay.",
    "REGISTER 3-1: RCON REGISTER BITS AND POSITIONS\nR/W-0, 1 = R/W-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R/W-1. R/W-0, 5 = R/W-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = LWRT. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0\nNote: See Register 4-3 on page 53 for bit definitions.",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nPower-on Reset, Program Counter = 0000h. Power-on Reset, RCON Register = 00-1 1100. Power-on Reset, RI = 1. Power-on Reset, TO = 1. Power-on Reset, PD = 1. Power-on Reset, POR = 0. Power-on Reset, BOR = 0. Power-on Reset, STKFUL = u. Power-on Reset, STKUNF = u. MCLR Reset during normal operation, Program Counter = 0000h. MCLR Reset during normal operation, RCON Register = 00-u uuuu. MCLR Reset during normal operation, RI = u. MCLR Reset during normal operation, TO = u. MCLR Reset during normal operation, PD = u. MCLR Reset during normal operation, POR = u. MCLR Reset during normal operation, BOR = u. MCLR Reset during normal operation, STKFUL = u. MCLR Reset during normal operation, STKUNF = u. Software Reset during normal operation, Program Counter = 0000h. Software Reset during normal operation, RCON Register =",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n0u-0 uuuu. Software Reset during normal operation, RI = 0. Software Reset during normal operation, TO = u. Software Reset during normal operation, PD = u. Software Reset during normal operation, POR = u. Software Reset during normal operation, BOR = u. Software Reset during normal operation, STKFUL = u. Software Reset during normal operation, STKUNF = u. Stack Full Reset during normal operation, Program Counter = 0000h. Stack Full Reset during normal operation, RCON Register = 0u-u uu11. Stack Full Reset during normal operation, RI = u. Stack Full Reset during normal operation, TO = u. Stack Full Reset during normal operation, PD = u. Stack Full Reset during normal operation, POR = u. Stack Full Reset during normal operation, BOR = u. Stack Full Reset during normal operation, STKFUL = u. Stack Full Reset during normal operation, STKUNF = 1. Stack Underflow Reset during normal operation, Program Counter = 0000h. Stack Underflow Reset during normal operation, RCON Register = 0u-u uu11. Stack",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nUnderflow Reset during normal operation, RI = u. Stack Underflow Reset during normal operation, TO = u. Stack Underflow Reset during normal operation, PD = u. Stack Underflow Reset during normal operation, POR = u. Stack Underflow Reset during normal operation, BOR = u. Stack Underflow Reset during normal operation, STKFUL = 1. Stack Underflow Reset during normal operation, STKUNF = u. MCLR Reset during SLEEP, Program Counter = 0000h. MCLR Reset during SLEEP, RCON Register = 00-u 10uu. MCLR Reset during SLEEP, RI = u. MCLR Reset during SLEEP, TO = 1. MCLR Reset during SLEEP, PD = 0. MCLR Reset during SLEEP, POR = u. MCLR Reset during SLEEP, BOR = u. MCLR Reset during SLEEP, STKFUL = u. MCLR Reset during SLEEP, STKUNF = u. WDT Reset, Program Counter = 0000h. WDT Reset, RCON Register = 0u-u 01uu. WDT Reset, RI = 1. WDT Reset, TO =",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n0. WDT Reset, PD = 1. WDT Reset, POR = u. WDT Reset, BOR = u. WDT Reset, STKFUL = u. WDT Reset, STKUNF = u. WDT Wake-up, Program Counter = PC + 2. WDT Wake-up, RCON Register = uu-u 00uu. WDT Wake-up, RI = u. WDT Wake-up, TO = 0. WDT Wake-up, PD = 0. WDT Wake-up, POR = u. WDT Wake-up, BOR = u. WDT Wake-up, STKFUL = u. WDT Wake-up, STKUNF = u. Brown-out Reset, Program Counter = 0000h. Brown-out Reset, RCON Register = 0u-1 11u0. Brown-out Reset, RI = 1. Brown-out Reset, TO = 1. Brown-out Reset, PD = 1. Brown-out Reset, POR = 1. Brown-out Reset, BOR = 0. Brown-out Reset,",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nSTKFUL = u. Brown-out Reset, STKUNF = u. Interrupt wake-up from SLEEP, Program Counter = PC + 2 (1). Interrupt wake-up from SLEEP, RCON Register = uu-u 00uu. Interrupt wake-up from SLEEP, RI = u. Interrupt wake-up from SLEEP, TO = 1. Interrupt wake-up from SLEEP, PD = 0. Interrupt wake-up from SLEEP, POR = u. Interrupt wake-up from SLEEP, BOR = u. Interrupt wake-up from SLEEP, STKFUL = u. Interrupt wake-up from SLEEP, STKUNF = u\nLegend: u = unchanged, x = unknown, - = unimplemented bit, read as '0'.\nNote 1: When the wake-up is due to an interrupt and the GIEH or GIEL bits are set, the PC is loaded with the interrupt vector ( 0x000008h or 0x000018h ).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTOSU, Applicable Devices = 242. TOSU, Applicable Devices = 442. TOSU, Applicable Devices = 252. TOSU, Applicable Devices = 452. TOSU, Power-on Reset, Brown-out Reset = ---0 0000. TOSU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. TOSU, Wake-up via WDT or Interrupt = ---0 uuuu (3). TOSH, Applicable Devices = 242. TOSH, Applicable Devices = 442. TOSH, Applicable Devices = 252. TOSH, Applicable Devices = 452. TOSH, Power-on Reset, Brown-out Reset = 0000 0000. TOSH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSH, Wake-up via WDT or Interrupt = uuuu uuuu (3). TOSL, Applicable Devices = 242. TOSL, Applicable Devices = 442. TOSL, Applicable Devices = 252. TOSL, Applicable Devices = 452. TOSL, Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n0000 0000. TOSL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSL, Wake-up via WDT or Interrupt = uuuu uuuu (3). STKPTR, Applicable Devices = 242. STKPTR, Applicable Devices = 442. STKPTR, Applicable Devices = 252. STKPTR, Applicable Devices = 452. STKPTR, Power-on Reset, Brown-out Reset = 00-0 0000. STKPTR, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-0 0000. STKPTR, Wake-up via WDT or Interrupt = uu-u uuuu (3). PCLATU, Applicable Devices = 242. PCLATU, Applicable Devices = 442. PCLATU, Applicable Devices = 252. PCLATU, Applicable Devices = 452. PCLATU, Power-on Reset, Brown-out Reset = ---0 0000. PCLATU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n0000. PCLATU, Wake-up via WDT or Interrupt = ---u uuuu. PCLATH, Applicable Devices = 242. PCLATH, Applicable Devices = 442. PCLATH, Applicable Devices = 252. PCLATH, Applicable Devices = 452. PCLATH, Power-on Reset, Brown-out Reset = 0000 0000. PCLATH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCLATH, Wake-up via WDT or Interrupt = uuuu uuuu. PCL, Applicable Devices = 242. PCL, Applicable Devices = 442. PCL, Applicable Devices = 252. PCL, Applicable Devices = 452. PCL, Power-on Reset, Brown-out Reset = 0000 0000. PCL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCL, Wake-up via WDT or Interrupt = PC + 2 (2). TBLPTRU, Applicable Devices = 242. TBLPTRU, Applicable Devices = 442. TBLPTRU, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nDevices = 252. TBLPTRU, Applicable Devices = 452. TBLPTRU, Power-on Reset, Brown-out Reset = --00 0000. TBLPTRU, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. TBLPTRU, Wake-up via WDT or Interrupt = --uu uuuu. TBLPTRH, Applicable Devices = 242. TBLPTRH, Applicable Devices = 442. TBLPTRH, Applicable Devices = 252. TBLPTRH, Applicable Devices = 452. TBLPTRH, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRH, Wake-up via WDT or Interrupt = uuuu uuuu. TBLPTRL, Applicable Devices = 242. TBLPTRL, Applicable Devices = 442. TBLPTRL, Applicable Devices = 252. TBLPTRL, Applicable Devices = 452. TBLPTRL, Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nBrown-out Reset = 0000 0000. TBLPTRL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRL, Wake-up via WDT or Interrupt = uuuu uuuu. TABLAT, Applicable Devices = 242. TABLAT, Applicable Devices = 442. TABLAT, Applicable Devices = 252. TABLAT, Applicable Devices = 452. TABLAT, Power-on Reset, Brown-out Reset = 0000 0000. TABLAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TABLAT, Wake-up via WDT or Interrupt = uuuu uuuu. PRODH, Applicable Devices = 242. PRODH, Applicable Devices = 442. PRODH, Applicable Devices = 252. PRODH, Applicable Devices = 452. PRODH, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODH, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nuuuu. PRODL, Applicable Devices = 242. PRODL, Applicable Devices = 442. PRODL, Applicable Devices = 252. PRODL, Applicable Devices = 452. PRODL, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODL, Wake-up via WDT or Interrupt = uuuu uuuu. INTCON, Applicable Devices = 242. INTCON, Applicable Devices = 442. INTCON, Applicable Devices = 252. INTCON, Applicable Devices = 452. INTCON, Power-on Reset, Brown-out Reset = 0000 000x. INTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000u. INTCON, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON2, Applicable Devices = 242. INTCON2, Applicable Devices = 442. INTCON2, Applicable Devices = 252. INTCON2, Applicable Devices = 452. INTCON2, Power-on",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nReset, Brown-out Reset = 1111 -1-1. INTCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 -1-1. INTCON2, Wake-up via WDT or Interrupt = uuuu -u-u (1). INTCON3, Applicable Devices = 242. INTCON3, Applicable Devices = 442. INTCON3, Applicable Devices = 252. INTCON3, Applicable Devices = 452. INTCON3, Power-on Reset, Brown-out Reset = 11-0 0-00. INTCON3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 11-0 0-00. INTCON3, Wake-up via WDT or Interrupt = uu-u u-uu (1). INDF0, Applicable Devices = 242. INDF0, Applicable Devices = 442. INDF0, Applicable Devices = 252. INDF0, Applicable Devices = 452. INDF0, Power-on Reset, Brown-out Reset = N/A. INDF0, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nN/A. INDF0, Wake-up via WDT or Interrupt = N/A. POSTINC0, Applicable Devices = 242. POSTINC0, Applicable Devices = 442. POSTINC0, Applicable Devices = 252. POSTINC0, Applicable Devices = 452. POSTINC0, Power-on Reset, Brown-out Reset = N/A. POSTINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC0, Wake-up via WDT or Interrupt = N/A. POSTDEC0, Applicable Devices = 242. POSTDEC0, Applicable Devices = 442. POSTDEC0, Applicable Devices = 252. POSTDEC0, Applicable Devices = 452. POSTDEC0, Power-on Reset, Brown-out Reset = N/A. POSTDEC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC0, Wake-up via WDT or Interrupt = N/A. PREINC0, Applicable Devices = 242. PREINC0, Applicable Devices = 442.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPREINC0, Applicable Devices = 252. PREINC0, Applicable Devices = 452. PREINC0, Power-on Reset, Brown-out Reset = N/A. PREINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC0, Wake-up via WDT or Interrupt = N/A. PLUSW0, Applicable Devices = 242. PLUSW0, Applicable Devices = 442. PLUSW0, Applicable Devices = 252. PLUSW0, Applicable Devices = 452. PLUSW0, Power-on Reset, Brown-out Reset = N/A. PLUSW0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW0, Wake-up via WDT or Interrupt = N/A. FSR0H, Applicable Devices = 242. FSR0H, Applicable Devices = 442. FSR0H, Applicable Devices = 252. FSR0H, Applicable Devices = 452. FSR0H, Power-on Reset, Brown-out Reset = ---- 0000. FSR0H, MCLR",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nResets WDT Reset RESET Instruction Stack Resets = ---- 0000. FSR0H, Wake-up via WDT or Interrupt = ---- uuuu. FSR0L, Applicable Devices = 242. FSR0L, Applicable Devices = 442. FSR0L, Applicable Devices = 252. FSR0L, Applicable Devices = 452. FSR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR0L, Wake-up via WDT or Interrupt = uuuu uuuu. WREG, Applicable Devices = 242. WREG, Applicable Devices = 442. WREG, Applicable Devices = 252. WREG, Applicable Devices = 452. WREG, Power-on Reset, Brown-out Reset = xxxx xxxx. WREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. WREG, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nuuuu uuuu. INDF1, Applicable Devices = 242. INDF1, Applicable Devices = 442. INDF1, Applicable Devices = 252. INDF1, Applicable Devices = 452. INDF1, Power-on Reset, Brown-out Reset = N/A. INDF1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF1, Wake-up via WDT or Interrupt = N/A. POSTINC1, Applicable Devices = 242. POSTINC1, Applicable Devices = 442. POSTINC1, Applicable Devices = 252. POSTINC1, Applicable Devices = 452. POSTINC1, Power-on Reset, Brown-out Reset = N/A. POSTINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC1, Wake-up via WDT or Interrupt = N/A. POSTDEC1, Applicable Devices = 242. POSTDEC1, Applicable Devices = 442. POSTDEC1, Applicable Devices = 252. POSTDEC1, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n452. POSTDEC1, Power-on Reset, Brown-out Reset = N/A. POSTDEC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC1, Wake-up via WDT or Interrupt = N/A. PREINC1, Applicable Devices = 242. PREINC1, Applicable Devices = 442. PREINC1, Applicable Devices = 252. PREINC1, Applicable Devices = 452. PREINC1, Power-on Reset, Brown-out Reset = N/A. PREINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC1, Wake-up via WDT or Interrupt = N/A. PLUSW1, Applicable Devices = 242. PLUSW1, Applicable Devices = 442. PLUSW1, Applicable Devices = 252. PLUSW1, Applicable Devices = 452. PLUSW1, Power-on Reset, Brown-out Reset = N/A. PLUSW1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW1,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nWake-up via WDT or Interrupt = N/A\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as '0', q = value depends on condition\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector ( 0008h or 0018h ).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for RESET value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO oscillator modes only. In all other oscillator modes, they are disabled and read '0'.\n6: The long write enable is only reset on a POR or MCLR Reset.\n7: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read as '0'.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFSR1H, Applicable Devices = 242. FSR1H, Applicable Devices = 442. FSR1H, Applicable Devices = 252. FSR1H, Applicable Devices = 452. FSR1H, Power-on Reset, Brown-out Reset = ---- 0000. FSR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. FSR1H, Wake-up via WDT or Interrupt = ---- uuuu. FSR1L, Applicable Devices = 242. FSR1L, Applicable Devices = 442. FSR1L, Applicable Devices = 252. FSR1L, Applicable Devices = 452. FSR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR1L, Wake-up via WDT or Interrupt = uuuu uuuu. BSR, Applicable Devices = 242. BSR, Applicable Devices = 442.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBSR, Applicable Devices = 252. BSR, Applicable Devices = 452. BSR, Power-on Reset, Brown-out Reset = ---- 0000. BSR, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. BSR, Wake-up via WDT or Interrupt = ---- uuuu. INDF2, Applicable Devices = 242. INDF2, Applicable Devices = 442. INDF2, Applicable Devices = 252. INDF2, Applicable Devices = 452. INDF2, Power-on Reset, Brown-out Reset = N/A. INDF2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF2, Wake-up via WDT or Interrupt = N/A. POSTINC2, Applicable Devices = 242. POSTINC2, Applicable Devices = 442. POSTINC2, Applicable Devices = 252. POSTINC2, Applicable Devices = 452. POSTINC2, Power-on Reset, Brown-out Reset = N/A. POSTINC2,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC2, Wake-up via WDT or Interrupt = N/A. POSTDEC2, Applicable Devices = 242. POSTDEC2, Applicable Devices = 442. POSTDEC2, Applicable Devices = 252. POSTDEC2, Applicable Devices = 452. POSTDEC2, Power-on Reset, Brown-out Reset = N/A. POSTDEC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC2, Wake-up via WDT or Interrupt = N/A. PREINC2, Applicable Devices = 242. PREINC2, Applicable Devices = 442. PREINC2, Applicable Devices = 252. PREINC2, Applicable Devices = 452. PREINC2, Power-on Reset, Brown-out Reset = N/A. PREINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC2, Wake-up via WDT or Interrupt = N/A. PLUSW2, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = 242. PLUSW2, Applicable Devices = 442. PLUSW2, Applicable Devices = 252. PLUSW2, Applicable Devices = 452. PLUSW2, Power-on Reset, Brown-out Reset = N/A. PLUSW2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW2, Wake-up via WDT or Interrupt = N/A. FSR2H, Applicable Devices = 242. FSR2H, Applicable Devices = 442. FSR2H, Applicable Devices = 252. FSR2H, Applicable Devices = 452. FSR2H, Power-on Reset, Brown-out Reset = ---- 0000. FSR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. FSR2H, Wake-up via WDT or Interrupt = ---- uuuu. FSR2L, Applicable Devices = 242. FSR2L, Applicable Devices = 442. FSR2L, Applicable Devices = 252. FSR2L, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n452. FSR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR2L, Wake-up via WDT or Interrupt = uuuu uuuu. STATUS, Applicable Devices = 242. STATUS, Applicable Devices = 442. STATUS, Applicable Devices = 252. STATUS, Applicable Devices = 452. STATUS, Power-on Reset, Brown-out Reset = ---x xxxx. STATUS, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---u uuuu. STATUS, Wake-up via WDT or Interrupt = ---u uuuu. TMR0H, Applicable Devices = 242. TMR0H, Applicable Devices = 442. TMR0H, Applicable Devices = 252. TMR0H, Applicable Devices = 452. TMR0H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR0H, MCLR",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR0L, Applicable Devices = 242. TMR0L, Applicable Devices = 442. TMR0L, Applicable Devices = 252. TMR0L, Applicable Devices = 452. TMR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0L, Wake-up via WDT or Interrupt = uuuu uuuu. T0CON, Applicable Devices = 242. T0CON, Applicable Devices = 442. T0CON, Applicable Devices = 252. T0CON, Applicable Devices = 452. T0CON, Power-on Reset, Brown-out Reset = 1111 1111. T0CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nT0CON, Wake-up via WDT or Interrupt = uuuu uuuu. OSCCON, Applicable Devices = 242. OSCCON, Applicable Devices = 442. OSCCON, Applicable Devices = 252. OSCCON, Applicable Devices = 452. OSCCON, Power-on Reset, Brown-out Reset = ---- ---0. OSCCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- ---0. OSCCON, Wake-up via WDT or Interrupt = ---- ---u. LVDCON, Applicable Devices = 242. LVDCON, Applicable Devices = 442. LVDCON, Applicable Devices = 252. LVDCON, Applicable Devices = 452. LVDCON, Power-on Reset, Brown-out Reset = --00 0101. LVDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0101. LVDCON, Wake-up via WDT or Interrupt = --uu uuuu. WDTCON, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n242. WDTCON, Applicable Devices = 442. WDTCON, Applicable Devices = 252. WDTCON, Applicable Devices = 452. WDTCON, Power-on Reset, Brown-out Reset = ---- ---0. WDTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- ---0. WDTCON, Wake-up via WDT or Interrupt = ---- ---u. RCON (4, 6), Applicable Devices = 242. RCON (4, 6), Applicable Devices = 442. RCON (4, 6), Applicable Devices = 252. RCON (4, 6), Applicable Devices = 452. RCON (4, 6), Power-on Reset, Brown-out Reset = 00-1 11q0. RCON (4, 6), MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-1 qquu. RCON (4, 6), Wake-up via WDT or Interrupt = uu-u qquu. TMR1H, Applicable Devices",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 242. TMR1H, Applicable Devices = 442. TMR1H, Applicable Devices = 252. TMR1H, Applicable Devices = 452. TMR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR1L, Applicable Devices = 242. TMR1L, Applicable Devices = 442. TMR1L, Applicable Devices = 252. TMR1L, Applicable Devices = 452. TMR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1L, Wake-up via WDT or Interrupt = uuuu uuuu. T1CON, Applicable Devices = 242.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nT1CON, Applicable Devices = 442. T1CON, Applicable Devices = 252. T1CON, Applicable Devices = 452. T1CON, Power-on Reset, Brown-out Reset = 0-00 0000. T1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = u-uu uuuu. T1CON, Wake-up via WDT or Interrupt = u-uu uuuu. TMR2, Applicable Devices = 242. TMR2, Applicable Devices = 442. TMR2, Applicable Devices = 252. TMR2, Applicable Devices = 452. TMR2, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR2, Wake-up via WDT or Interrupt = uuuu uuuu. PR2, Applicable Devices = 242. PR2, Applicable Devices = 442. PR2, Applicable Devices = 252. PR2, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n452. PR2, Power-on Reset, Brown-out Reset = 1111 1111. PR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. PR2, Wake-up via WDT or Interrupt = 1111 1111. T2CON, Applicable Devices = 242. T2CON, Applicable Devices = 442. T2CON, Applicable Devices = 252. T2CON, Applicable Devices = 452. T2CON, Power-on Reset, Brown-out Reset = -000 0000. T2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. T2CON, Wake-up via WDT or Interrupt = -uuu uuuu. SSPBUF, Applicable Devices = 242. SSPBUF, Applicable Devices = 442. SSPBUF, Applicable Devices = 252. SSPBUF, Applicable Devices = 452. SSPBUF, Power-on Reset, Brown-out Reset = xxxx xxxx. SSPBUF, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. SSPBUF, Wake-up via WDT or Interrupt = uuuu uuuu. SSPADD, Applicable Devices = 242. SSPADD, Applicable Devices = 442. SSPADD, Applicable Devices = 252. SSPADD, Applicable Devices = 452. SSPADD, Power-on Reset, Brown-out Reset = 0000 0000. SSPADD, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPADD, Wake-up via WDT or Interrupt = uuuu uuuu. SSPSTAT, Applicable Devices = 242. SSPSTAT, Applicable Devices = 442. SSPSTAT, Applicable Devices = 252. SSPSTAT, Applicable Devices = 452. SSPSTAT, Power-on Reset, Brown-out Reset = 0000 0000. SSPSTAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPSTAT, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON1, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n242. SSPCON1, Applicable Devices = 442. SSPCON1, Applicable Devices = 252. SSPCON1, Applicable Devices = 452. SSPCON1, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON1, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON2, Applicable Devices = 242. SSPCON2, Applicable Devices = 442. SSPCON2, Applicable Devices = 252. SSPCON2, Applicable Devices = 452. SSPCON2, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON2, Wake-up via WDT or Interrupt = uuuu uuuu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as '0', q = value depends on condition",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector ( 0008h or 0018h ).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for RESET value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO oscillator modes only. In all other oscillator modes, they are disabled and read '0'.\n6: The long write enable is only reset on a POR or MCLR Reset.\n7: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read as '0'.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADRESH, Applicable Devices = 242. ADRESH, Applicable Devices = 442. ADRESH, Applicable Devices = 252. ADRESH, Applicable Devices = 452. ADRESH, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. ADRESH, Wake-up via WDT or Interrupt = uuuu uuuu. ADRESL, Applicable Devices = 242. ADRESL, Applicable Devices = 442. ADRESL, Applicable Devices = 252. ADRESL, Applicable Devices = 452. ADRESL, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. ADRESL, Wake-up via WDT or Interrupt = uuuu uuuu. ADCON0, Applicable Devices = 242. ADCON0, Applicable Devices = 442. ADCON0, Applicable Devices = 252. ADCON0, Applicable Devices = 452.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADCON0, Power-on Reset, Brown-out Reset = 0000 0000. ADCON0, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. ADCON0, Wake-up via WDT or Interrupt = uuuu uuuu. ADCON1, Applicable Devices = 242. ADCON1, Applicable Devices = 442. ADCON1, Applicable Devices = 252. ADCON1, Applicable Devices = 452. ADCON1, Power-on Reset, Brown-out Reset = --0- 0000. ADCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = --0- 0000. ADCON1, Wake-up via WDT or Interrupt = --u- uuuu. CCPR1H, Applicable Devices = 242. CCPR1H, Applicable Devices = 442. CCPR1H, Applicable Devices = 252. CCPR1H, Applicable Devices = 452. CCPR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1H, MCLR Resets WDT Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRESET Instruction Stack Resets = uuuu uuuu. CCPR1H, Wake-up via WDT or Interrupt = uuuu uuuu. CCPR1L, Applicable Devices = 242. CCPR1L, Applicable Devices = 442. CCPR1L, Applicable Devices = 252. CCPR1L, Applicable Devices = 452. CCPR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR1L, Wake-up via WDT or Interrupt = uuuu uuuu. CCP1CON, Applicable Devices = 242. CCP1CON, Applicable Devices = 442. CCP1CON, Applicable Devices = 252. CCP1CON, Applicable Devices = 452. CCP1CON, Power-on Reset, Brown-out Reset = --00 0000. CCP1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. CCP1CON,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = --uu uuuu. CCPR2H, Applicable Devices = 242. CCPR2H, Applicable Devices = 442. CCPR2H, Applicable Devices = 252. CCPR2H, Applicable Devices = 452. CCPR2H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR2H, Wake-up via WDT or Interrupt = uuuu uuuu. CCPR2L, Applicable Devices = 242. CCPR2L, Applicable Devices = 442. CCPR2L, Applicable Devices = 252. CCPR2L, Applicable Devices = 452. CCPR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR2L, Wake-up via WDT or Interrupt = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCCP2CON, Applicable Devices = 242. CCP2CON, Applicable Devices = 442. CCP2CON, Applicable Devices = 252. CCP2CON, Applicable Devices = 452. CCP2CON, Power-on Reset, Brown-out Reset = --00 0000. CCP2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. CCP2CON, Wake-up via WDT or Interrupt = --uu uuuu. TMR3H, Applicable Devices = 242. TMR3H, Applicable Devices = 442. TMR3H, Applicable Devices = 252. TMR3H, Applicable Devices = 452. TMR3H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR3H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR3L, Applicable Devices = 242.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR3L, Applicable Devices = 442. TMR3L, Applicable Devices = 252. TMR3L, Applicable Devices = 452. TMR3L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR3L, Wake-up via WDT or Interrupt = uuuu uuuu. T3CON, Applicable Devices = 242. T3CON, Applicable Devices = 442. T3CON, Applicable Devices = 252. T3CON, Applicable Devices = 452. T3CON, Power-on Reset, Brown-out Reset = 0000 0000. T3CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. T3CON, Wake-up via WDT or Interrupt = uuuu uuuu. SPBRG, Applicable Devices = 242. SPBRG, Applicable Devices = 442. SPBRG, Applicable Devices = 252.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nSPBRG, Applicable Devices = 452. SPBRG, Power-on Reset, Brown-out Reset = xxxx xxxx. SPBRG, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. SPBRG, Wake-up via WDT or Interrupt = uuuu uuuu. RCREG, Applicable Devices = 242. RCREG, Applicable Devices = 442. RCREG, Applicable Devices = 252. RCREG, Applicable Devices = 452. RCREG, Power-on Reset, Brown-out Reset = xxxx xxxx. RCREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RCREG, Wake-up via WDT or Interrupt = uuuu uuuu. TXREG, Applicable Devices = 242. TXREG, Applicable Devices = 442. TXREG, Applicable Devices = 252. TXREG, Applicable Devices = 452. TXREG, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXREG, Wake-up via WDT or Interrupt = uuuu uuuu. TXSTA, Applicable Devices = 242. TXSTA, Applicable Devices = 442. TXSTA, Applicable Devices = 252. TXSTA, Applicable Devices = 452. TXSTA, Power-on Reset, Brown-out Reset = 0000 -01x. TXSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 -01u. TXSTA, Wake-up via WDT or Interrupt = uuuu -uuu. RCSTA, Applicable Devices = 242. RCSTA, Applicable Devices = 442. RCSTA, Applicable Devices = 252. RCSTA, Applicable Devices = 452. RCSTA, Power-on Reset, Brown-out Reset = 0000 000x. RCSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000u. RCSTA, Wake-up via WDT or Interrupt = uuuu uuuu. IPR2,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = 242. IPR2, Applicable Devices = 442. IPR2, Applicable Devices = 252. IPR2, Applicable Devices = 452. IPR2, Power-on Reset, Brown-out Reset = ---- 1111. IPR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 1111. IPR2, Wake-up via WDT or Interrupt = ---- uuuu. PIR2, Applicable Devices = 242. PIR2, Applicable Devices = 442. PIR2, Applicable Devices = 252. PIR2, Applicable Devices = 452. PIR2, Power-on Reset, Brown-out Reset = ---- 0000. PIR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. PIR2, Wake-up via WDT or Interrupt = ---- uuuu (1). PIE2, Applicable Devices = 242. PIE2, Applicable Devices = 442. PIE2, Applicable Devices = 252. PIE2, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n452. PIE2, Power-on Reset, Brown-out Reset = ---- 0000. PIE2, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. PIE2, Wake-up via WDT or Interrupt = ---- uuuu. IPR1, Applicable Devices = 242. IPR1, Applicable Devices = 442. IPR1, Applicable Devices = 252. IPR1, Applicable Devices = 452. IPR1, Power-on Reset, Brown-out Reset = 1111 1111. IPR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. IPR1, Wake-up via WDT or Interrupt = uuuu uuuu. , Applicable Devices = 242. , Applicable Devices = 442. , Applicable Devices = 252. , Applicable Devices = 452. , Power-on Reset, Brown-out Reset = -111 1111. , MCLR Resets WDT Reset RESET Instruction Stack Resets = -111 1111. , Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-uuu uuuu. PIR1, Applicable Devices = 242. PIR1, Applicable Devices = 442. PIR1, Applicable Devices = 252. PIR1, Applicable Devices = 452. PIR1, Power-on Reset, Brown-out Reset = 0000 0000. PIR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PIR1, Wake-up via WDT or Interrupt = uuuu uuuu (1). PIR1, Applicable Devices = 242. PIR1, Applicable Devices = 442. PIR1, Applicable Devices = 252. PIR1, Applicable Devices = 452. PIR1, Power-on Reset, Brown-out Reset = -000 0000. PIR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. PIR1, Wake-up via WDT or Interrupt = -uuu uuuu (1). PIE1, Applicable Devices = 242. PIE1, Applicable Devices = 442. PIE1, Applicable Devices = 252.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIE1, Applicable Devices = 452. PIE1, Power-on Reset, Brown-out Reset = 0000 0000. PIE1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PIE1, Wake-up via WDT or Interrupt = uuuu uuuu. PIE1, Applicable Devices = 242. PIE1, Applicable Devices = 442. PIE1, Applicable Devices = 252. PIE1, Applicable Devices = 452. PIE1, Power-on Reset, Brown-out Reset = -000 0000. PIE1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. PIE1, Wake-up via WDT or Interrupt = -uuu uuuu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as '0', q = value depends on condition\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector ( 0008h or 0018h ).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for RESET value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO oscillator modes only. In all other oscillator modes, they are disabled and read '0'.\n6: The long write enable is only reset on a POR or MCLR Reset.\n7: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read as '0'.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTRISE, Applicable Devices = 242. TRISE, Applicable Devices = 442. TRISE, Applicable Devices = 252. TRISE, Applicable Devices = 452. TRISE, Power-on Reset, Brown-out Reset = 0000. TRISE, Power-on Reset, Brown-out Reset = -111. TRISE, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = 0000. TRISE, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = -111. TRISE, WDT = uuuu. TRISE, WDT = -uuu. TRISD, Applicable Devices = 242. TRISD, Applicable Devices = 442. TRISD, Applicable Devices = 252. TRISD, Applicable Devices = 452. TRISD, Power-on Reset, Brown-out Reset = 1111. TRISD, Power-on Reset, Brown-out Reset = 1111. TRISD, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = 1111. TRISD, MCLR Resets WDT Reset RESET Instruction Stack",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets Wake-up via or Interrupt = 1111. TRISD, WDT = uuuu. TRISD, WDT = uuuu. TRISC, Applicable Devices = 242. TRISC, Applicable Devices = 442. TRISC, Applicable Devices = 252. TRISC, Applicable Devices = 452. TRISC, Power-on Reset, Brown-out Reset = 1111. TRISC, Power-on Reset, Brown-out Reset = 1111. TRISC, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = 1111. TRISC, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = 1111. TRISC, WDT = uuuu. TRISC, WDT = uuuu. TRISB, Applicable Devices = 242. TRISB, Applicable Devices = 442. TRISB, Applicable Devices = 252. TRISB, Applicable Devices = 452. TRISB, Power-on Reset, Brown-out Reset = 1111. TRISB, Power-on Reset, Brown-out Reset = 1111. TRISB,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = 1111. TRISB, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = 1111. TRISB, WDT = uuuu. TRISB, WDT = uuuu. TRISA (5, 7), Applicable Devices = 242. TRISA (5, 7), Applicable Devices = 442. TRISA (5, 7), Applicable Devices = 252. TRISA (5, 7), Applicable Devices = 452. TRISA (5, 7), Power-on Reset, Brown-out Reset = -111. TRISA (5, 7), Power-on Reset, Brown-out Reset = 1111 (5). TRISA (5, 7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = -111. TRISA (5, 7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = 1111 (5). TRISA (5, 7), WDT =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-uuu. TRISA (5, 7), WDT = uuuu (5). LATE, Applicable Devices = 242. LATE, Applicable Devices = 442. LATE, Applicable Devices = 252. LATE, Applicable Devices = 452. LATE, Power-on Reset, Brown-out Reset = ----. LATE, Power-on Reset, Brown-out Reset = -xxx. LATE, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = ----. LATE, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = -uuu. LATE, WDT = ----. LATE, WDT = -uuu. LATD, Applicable Devices = 242. LATD, Applicable Devices = 442. LATD, Applicable Devices = 252. LATD, Applicable Devices = 452. LATD, Power-on Reset, Brown-out Reset = xxxx. LATD, Power-on Reset, Brown-out Reset = xxxx. LATD, MCLR Resets WDT Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. LATD, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. LATD, WDT = uuuu. LATD, WDT = uuuu. LATC, Applicable Devices = 242. LATC, Applicable Devices = 442. LATC, Applicable Devices = 252. LATC, Applicable Devices = 452. LATC, Power-on Reset, Brown-out Reset = xxxx. LATC, Power-on Reset, Brown-out Reset = xxxx. LATC, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. LATC, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. LATC, WDT = uuuu. LATC, WDT = uuuu. LATB, Applicable Devices = 242. LATB, Applicable Devices = 442. LATB, Applicable Devices = 252.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLATB, Applicable Devices = 452. LATB, Power-on Reset, Brown-out Reset = xxxx. LATB, Power-on Reset, Brown-out Reset = xxxx. LATB, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. LATB, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. LATB, WDT = uuuu. LATB, WDT = uuuu. LATA (5, 7), Applicable Devices = 242. LATA (5, 7), Applicable Devices = 442. LATA (5, 7), Applicable Devices = 252. LATA (5, 7), Applicable Devices = 452. LATA (5, 7), Power-on Reset, Brown-out Reset = -xxx. LATA (5, 7), Power-on Reset, Brown-out Reset = xxxx (5). LATA (5, 7), MCLR Resets WDT Reset RESET Instruction Stack",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets Wake-up via or Interrupt = -uuu. LATA (5, 7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu (5). LATA (5, 7), WDT = -uuu. LATA (5, 7), WDT = uuuu (5). PORTE, Applicable Devices = 242. PORTE, Applicable Devices = 442. PORTE, Applicable Devices = 252. PORTE, Applicable Devices = 452. PORTE, Power-on Reset, Brown-out Reset = ----. PORTE, Power-on Reset, Brown-out Reset = -000. PORTE, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = ----. PORTE, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = -000. PORTE, WDT = ----. PORTE, WDT = -uuu. PORTD, Applicable Devices = 242. PORTD, Applicable Devices = 442. PORTD, Applicable Devices = 252.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPORTD, Applicable Devices = 452. PORTD, Power-on Reset, Brown-out Reset = xxxx. PORTD, Power-on Reset, Brown-out Reset = xxxx. PORTD, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. PORTD, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. PORTD, WDT = uuuu. PORTD, WDT = uuuu. PORTC, Applicable Devices = 242. PORTC, Applicable Devices = 442. PORTC, Applicable Devices = 252. PORTC, Applicable Devices = 452. PORTC, Power-on Reset, Brown-out Reset = xxxx. PORTC, Power-on Reset, Brown-out Reset = xxxx. PORTC, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. PORTC, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. PORTC, WDT",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= uuuu. PORTC, WDT = uuuu. PORTB, Applicable Devices = 242. PORTB, Applicable Devices = 442. PORTB, Applicable Devices = 252. PORTB, Applicable Devices = 452. PORTB, Power-on Reset, Brown-out Reset = xxxx. PORTB, Power-on Reset, Brown-out Reset = xxxx. PORTB, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. PORTB, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = uuuu. PORTB, WDT = uuuu. PORTB, WDT = uuuu. PORTA (5, 7), Applicable Devices = 242. PORTA (5, 7), Applicable Devices = 442. PORTA (5, 7), Applicable Devices = 252. PORTA (5, 7), Applicable Devices = 452. PORTA (5, 7), Power-on Reset, Brown-out Reset = -x0x. PORTA (5,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7), Power-on Reset, Brown-out Reset = 0000 (5). PORTA (5, 7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = -u0u. PORTA (5, 7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via or Interrupt = 0000 (5). PORTA (5, 7), WDT = -uuu. PORTA (5, 7), WDT = uuuu (5)\n- Legend: u = unchanged, x = unknown, -= unimplemented bit, read as '0', q = value depends on condition\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector ( 0008h or 0018h ).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for RESET value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO oscillator modes only. In all other oscillator modes, they are disabled and read '0'.\n6: The long write enable is only reset on a POR or MCLR Reset.\n7: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read as '0'.",
    "FIGURE 3-3: TIME-OUT SEQUENCE ON POWER-UP (MCLR TIED TO VDD)\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET",
    "FIGURE 3-7: TIME-OUT SEQUENCE ON POR W/ PLL ENABLED (MCLR TIED TO VDD)\nNote:\nTOST = 1024 clock cycles.\nTPLL \uf0bb 2 ms max. First three stages of the PWRT timer.",
    "PIC18CXX2\nNOTES:",
    "4.0 MEMORY ORGANIZATION\nThere  are  two  memory  blocks  in  Enhanced  MCU devices. These memory blocks are:\n\u00b7 Program Memory\n\u00b7 Data Memory\nProgram and data memory use separate buses so that concurrent access can occur.",
    "4.1 Program Memory Organization\nA 21-bit program counter is capable of addressing the 2-Mbyte program memory space. Accessing a location between the physically implemented memory and the 2-Mbyte address will cause a read of all '0's (a NOP instruction).\nPIC18C252 and PIC18C452 have 32 Kbytes of EPROM,  while  PIC18C242  and  PIC18C442  have 16 Kbytes  of  EPROM.  This  means  that  PIC18CX52 devices can store up to 16K of single word instructions, and PIC18CX42 devices can store up to 8K of single word instructions.\nThe RESET vector address is at 0000h and the interrupt vector addresses are at 0008h and 0018h.\nFigure 4-1 shows  the Program  Memory  Map  for PIC18C242/442  devices  and  Figure 4-2  shows  the Program Memory Map for PIC18C252/452 devices.",
    "PROGRAM MEMORY MAP AND STACK FOR PIC18C442/242\nFIGURE 4-2:",
    "4.2 Return Address Stack\nThe return address stack allows any combination of up to  31  program  calls  and  interrupts  to  occur.  The  PC (Program Counter) is pushed onto the stack when a CALL or RCALL instruction is executed, or an interrupt is acknowledged. The PC value is pulled off the stack on  a RETURN, RETLW or  a RETFIE instruction. PCLATU and PCLATH are not affected by any of the call or return instructions.\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit stack pointer, with the stack pointer initialized to 00000b after all RESETS. There is no RAM associated with stack pointer 00000b. This is only a RESET value. During a CALL type instruction causing a push onto the stack,  the  stack  pointer  is  first  incremented  and  the RAM location pointed to by the stack pointer is written with  the  contents  of  the  PC.  During  a RETURN type instruction causing a pop from the stack, the contents of the RAM location pointed to by the STKPTR is transferred to the PC  and  then  the  stack pointer is decremented.",
    "4.2 Return Address Stack\nThe stack space is not part of either program or data space. The stack pointer is readable and writable, and the address on the top of the stack is readable and writable through SFR registers. Data can also be pushed to,  or  popped  from,  the  stack,  using  the  top-of-stack SFRs. Status bits indicate if the stack pointer is at, or beyond the 31 levels provided.",
    "4.2.1 TOP-OF-STACK ACCESS\nThe top of the stack is  readable  and writable. Three register  locations,  TOSU,  TOSH  and  TOSL  hold  the contents  of  the stack  location pointed  to by  the STKPTR  register.  This  allows  users  to  implement  a software stack, if necessary. After a CALL, RCALL or interrupt, the software can read the pushed value by reading the TOSU, TOSH and TOSL registers. These values can be placed on a user defined software stack. At  return  time,  the  software  can  replace  the  TOSU, TOSH and TOSL and do a return.\nThe user must disable the global interrupt enable bits during  this  time  to  prevent  inadvertent  stack  operations..",
    "4.2.2 RETURN STACK POINTER (STKPTR)\nThe STKPTR register contains the stack pointer value, the  STKFUL (stack  full)  status  bit,  and  the  STKUNF (stack  underflow)  status  bits.  Register 4-1  shows  the STKPTR register. The value of the stack pointer can be 0 through 31. The stack pointer increments when values are pushed onto the stack and decrements when values are popped off the stack. At RESET, the stack pointer value will be 0. The user may read and write the stack pointer value. This feature can be used by a Real Time Operating System for return stack maintenance.\nAfter the PC is pushed onto the stack 31 times (without popping any values off the stack), the STKFUL bit is set. The STKFUL bit can only be cleared in software or by a POR.",
    "4.2.2 RETURN STACK POINTER (STKPTR)\nThe action that takes place when the stack becomes full, depends on the state of the STVREN (Stack Overflow Reset Enable) configuration bit. Refer to Section 18.0 for a description of the device configuration bits. If STVREN is set (default), the 31st push will push the (PC + 2) value onto the stack, set the STKFUL bit, and reset the device. The STKFUL bit will remain set and the stack pointer will be set to 0.\nIf STVREN is cleared, the STKFUL bit will be set on the 31st push and the stack pointer will increment to 31. Any additional pushes will not overwrite the 31st push and STKPTR will remain at 31.\nWhen  the  stack  has  been  popped  enough  times  to unload the stack, the next pop will return a value of zero to  the  PC  and  sets  the  STKUNF  bit,  while  the  stack pointer remains at 0. The STKUNF bit will remain set until cleared in software or a POR occurs.\nNote:",
    "4.2.2 RETURN STACK POINTER (STKPTR)\nReturning a value of zero to the PC on an underflow, has the effect of vectoring the program to the RESET vector, where the stack conditions can be verified and appropriate actions can be taken.",
    "PIC18CXX2\nREGISTER 4-1:",
    "STKPTR REGISTER\nR/C-0, 1 = R/C-0. R/C-0, 2 = U-0. R/C-0, 3 = R/W-0. R/C-0, 4 = R/W-0. R/C-0, 5 = R/W-0. R/C-0, 6 = R/W-0. R/C-0, 7 = R/W-0. STKFUL, 1 = STKUNF. STKFUL, 2 = -. STKFUL, 3 = SP4. STKFUL, 4 = SP3. STKFUL, 5 = SP2. STKFUL, 6 = SP1. STKFUL, 7 = SP0\nbit 7\nbit 0\nbit 7 (1)\nSTKFUL : Stack Full Flag bit\n1 = Stack became full or overflowed\n0 = Stack has not become full or overflowed\nbit 6 (1)\nSTKUNF : Stack Underflow Flag bit\n1 = Stack underflow occurred\n0 = Stack underflow did not occur\nbit 5\nUnimplemented : Read as '0'\nbit 4-0 SP4:SP0",
    "STKPTR REGISTER\n: Stack Pointer Location bits\nNote 1: Bit 7 and bit 6 can only be cleared in user software or by a POR.\n\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "4.2.4 STACK FULL/UNDERFLOW RESETS\nSince the Top-of-Stack (TOS) is readable and writable, the ability to push values onto the stack and pull values off the stack, without disturbing normal program execution, is a desirable option. To push the current PC value onto  the  stack,  a PUSH instruction  can  be  executed. This will increment the stack pointer and load the current PC value onto the stack. TOSU, TOSH and TOSL can then be modified to place a return address on the stack.\nThe ability to pull the TOS value off of the stack and replace  it  with  the  value  that  was  previously  pushed onto the stack, without disturbing normal execution, is achieved by using the POP instruction. The POP instruction  discards  the  current  TOS  by  decrementing  the stack  pointer.  The  previous  value  pushed  onto  the stack then becomes the TOS value.",
    "4.2.4 STACK FULL/UNDERFLOW RESETS\nThese resets are enabled by programming the STVREN configuration bit.  When  the  STVREN  bit  is disabled, a full or underflow condition will set the appropriate STKFUL or STKUNF bit, but not cause a device RESET.  When  the  STVREN  bit  is  enabled,  a  full  or underflow will set the appropriate STKFUL or STKUNF bit and then cause a device RESET. The STKFUL or STKUNF bits are only cleared by the user software or a POR Reset.",
    "4.3 Fast Register Stack\nA \"fast interrupt return\" option is available for interrupts. A  Fast  Register  Stack  is  provided  for  the  STATUS, WREG and BSR registers and are only one in depth. The stack is not readable or writable and is loaded with the current value of the corresponding register when the processor vectors for an interrupt. The values in the registers are then loaded back into the working registers, if the FAST RETURN instruction is used to return from the interrupt.\nA low or high priority interrupt source will push values into  the  stack  registers.  If  both  low  and  high  priority interrupts  are  enabled,  the  stack  registers  cannot  be used reliably for low priority interrupts. If a high priority interrupt occurs while servicing a low priority interrupt, the stack register values stored by the low priority interrupt will be overwritten.\nIf high priority interrupts are not disabled during low priority  interrupts,  users  must  save  the  key  registers  in software during a low priority interrupt.\nIf no interrupts are used, the fast register stack can be used to restore the STATUS, WREG and BSR registers at the end of a subroutine call. To use the fast register stack for a subroutine call, a FAST  CALL instruction must be executed.",
    "4.3 Fast Register Stack\nExample 4-1 shows a source code example that uses the fast register stack.",
    "4.4 PCL, PCLATH and PCLATU\nThe program counter (PC) specifies the address of the instruction  to  fetch  for  execution.  The  PC  is  21-bits wide. The low byte is called the PCL register. This register is readable and writable. The high byte is called the PCH register. This register contains the PC<15:8> bits and is not directly readable or writable. Updates to the  PCH  register  may  be  performed  through  the PCLATH register. The upper byte is called PCU. This register contains the PC<20:16> bits and is not directly readable or writable. Updates to the PCU register may be performed through the PCLATU register.\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the LSB of PCL is fixed to a value of '0'. The PC increments by 2 to address sequential instructions in the program memory.\nThe CALL, RCALL, GOTO and  program  branch instructions write to the program counter directly. For these instructions, the contents of PCLATH  and PCLATU are not transferred to the program counter.",
    "4.4 PCL, PCLATH and PCLATU\nThe contents of PCLATH and PCLATU will be transferred  to  the  program  counter  by  an  operation  that writes PCL. Similarly, the upper two bytes of the program  counter  will  be  transferred  to  PCLATH  and PCLATU by an operation that reads PCL. This is useful for computed offsets to the PC (see Section 4.8.1).",
    "4.5 Clocking Scheme/Instruction Cycle\nThe clock  input  (from  OSC1)  is  internally  divided  by four to generate four non-overlapping quadrature clocks, namely Q1, Q2, Q3 and Q4. Internally, the program  counter  (PC)  is  incremented  every  Q1,  the instruction  is  fetched  from  the  program  memory  and latched into the instruction register in Q4. The instruction is decoded and executed during the following Q1 through Q4. The clocks and instruction execution flow is shown in Figure 4-4.\nCALL, 1 = FAST ;STATUS, WREG, BSR ;SAVED IN FAST REGISTER ;STACK. SUB1 RETURN, 1 = FAST ;RESTORE VALUES SAVED ;IN FAST REGISTER STACK",
    "4.6 Instruction Flow/Pipelining\nAn 'Instruction  Cycle'  consists  of  four  Q  cycles  (Q1, Q2, Q3 and Q4). The instruction fetch and execute are pipelined such that  fetch takes  one  instruction cycle, while  decode  and  execute  takes  another  instruction cycle. However, due to the pipelining, each instruction effectively  executes  in  one  cycle.  If  an  instruction causes  the  program  counter  to  change  (e.g. GOTO ), then two cycles are required to complete the instruction (Example 4-2).\nA  fetch  cycle  begins  with  the  program  counter  (PC) incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched into  the  'Instruction  Register\"  (IR)  in  cycle  Q1.  This instruction  is  then  decoded  and  executed  during  the Q2, Q3, and Q4 cycles. Data memory is read during Q2 (operand  read)  and  written  during  Q4  (destination write).",
    "EXAMPLE 4-2: INSTRUCTION PIPELINE FLOW\nAll instructions are single cycle, except for any program branches. These take two cycles since the fetch instruction is 'flushed' from the pipeline, while the new instruction is being fetched and then executed.",
    "4.7 Instructions in Program Memory\nThe program memory is addressed in bytes. Instructions are stored as two bytes or four bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSB ='0'). Figure 4-5 shows an example of how instruction words are stored in the program memory. To maintain alignment with instruction boundaries, the PC increments in steps of 2 and the LSB will always read '0' (see Section 4.4).\nThe CALL and GOTO instructions have an absolute program memory address embedded into the instruction. Since instructions are always stored on word boundaries,  the  data  contained  in  the  instruction  is  a  word address.  The  word  address  is  written  to  PC<20:1>, which accesses the desired byte address in program memory. Instruction  #2  in  Figure 4-5  shows  how  the instruction ' GOTO 000006h ' is encoded in the program memory. Program branch instructions, which encode a relative  address offset,  operate  in  the  same  manner. The offset value stored in a branch instruction represents the number of single word instructions that the PC  will  be  offset  by.  Section  19.0  provides  further details of the instruction set.",
    "FIGURE 4-5: INSTRUCTIONS IN PROGRAM MEMORY\nProgram Memory\nByte Locations\n\uf0ae\uf020\nInstruction 1:\nInstruction 2:\nInstruction 3:\nMOVLW\n055h\nGOTO\nMOVFF\n000006h\n123h, 456h\n, LSB = 0 = . , Word Address \uf0af = 000000h. , LSB = 0 = . , Word Address \uf0af = 000002h. , LSB = 0 = . , Word Address \uf0af = 000004h. , LSB = 0 = . , Word Address \uf0af = 000006h. 0Fh, LSB = 0 = 55h. 0Fh, Word Address \uf0af = 000008h. EFh, LSB = 0 = 03h. EFh, Word Address \uf0af = 00000Ah. F0h, LSB = 0 = 00h. F0h, Word Address \uf0af = 00000Ch. C1h, LSB = 0 = 23h. C1h, Word Address \uf0af = 00000Eh. F4h, LSB = 0 = 56h. F4h, Word Address \uf0af = 000010h. , LSB = 0 = . , Word Address \uf0af = 000012h. , LSB = 0 = . , Word Address \uf0af = 000014h",
    "4.7.1 TWO-WORD INSTRUCTIONS\nThe PIC18CXX2 devices have four two-word instructions: MOVFF, CALL, GOTO and LFSR . The second word of these instructions has the 4 MSBs set to 1's and is a special kind of NOP instruction. The lower 12bits of the second word contain data to be used by the instruction.  If  the  first  word  of  the  instruction  is  executed, the data in the second word is accessed. If the second word of the instruction is executed by itself (first word was skipped), it will execute as a NOP . This action is necessary when the two-word instruction is preceded by a conditional instruction that changes the PC. A program example that demonstrates this concept is shown in Example 4-3. Refer to Section 19.0 for further details of the instruction set.",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\n0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1 ; is. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1, REG2 ; No, execute 2-word instruction. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; 2nd operand holds address of REG2. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code =",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\n0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3 ; continue code. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. 0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1 ; is RAM location 0?. 1100,",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\nCASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1, REG2 ;. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; 2nd operand becomes NOP. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3 ; continue code",
    "4.8.2 TABLE READS/TABLE WRITES\nLookup tables are implemented two ways. These are:\n\u00b7 Computed GOTO\n\u00b7 Table Reads",
    "4.8.1 COMPUTED GOTO\nA computed GOTO is accomplished by adding an offset to the program counter ( ADDWF PCL ).\nA  lookup  table  can  be  formed  with  an ADDWF  PCL instruction and a group of RETLW  0xnn instructions. WREG is loaded with an offset into the table, before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction executed will be one of the RETLW  0xnn instructions that returns the value 0xnn to the calling function.\nThe offset value (value in WREG) specifies the number of bytes that the program counter should advance.\nIn  this  method,  only  one  data  byte  may  be  stored  in each  instruction  location  and  room  on  the  return address stack is required.\nA  better  method  of  storing  data  in  program  memory allows 2 bytes of data to be stored in each instruction location.\nLookup table data may be stored 2 bytes per program word by using table reads and writes. The table pointer (TBLPTR)  specifies  the  byte  address  and  the  table latch (TABLAT) contains the data that is read from, or written to program memory. Data is transferred to/from program memory one byte at a time.",
    "4.8.1 COMPUTED GOTO\nA description of the Table Read/Table Write operation is shown in Section 5.0.",
    "4.9 Data Memory Organization\nThe data memory is implemented as static RAM. Each register  in  the  data  memory  has  a  12-bit  address, allowing up to 4096 bytes of data memory. Figure 4-6 and Figure 4-7 show the data memory organization for the PIC18CXX2 devices.\nThe data memory map is divided into as many as 16 banks that contain 256 bytes each. The lower 4 bits of the  Bank  Select  Register  (BSR<3:0>)  select  which bank will be accessed. The upper 4 bits for the BSR are not implemented.\nThe data memory contains Special Function Registers (SFR)  and  General  Purpose  Registers  (GPR).  The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratch pad operations in the user's application. The SFRs start at the last location of Bank 15 (0xFFF) and extend downwards. Any remaining space beyond the SFRs in the Bank may be implemented as GPRs. GPRs start at the first location of Bank 0 and grow upwards. Any read of an unimplemented location will read as '0's.",
    "4.9 Data Memory Organization\nThe entire data memory may be accessed directly, or indirectly. Direct addressing may require the use of the BSR register. Indirect addressing requires the use of a File Select Register (FSRn) and corresponding Indirect File Operand  (INDFn).  Each  FSR  holds  a  12-bit address value that can be used to access any location in the Data Memory map without banking.\nThe instruction  set  and  architecture  allow  operations across all banks. This may be accomplished by indirect addressing or by the use of the MOVFF instruction. The MOVFF instruction  is  a  two-word/two-cycle  instruction that moves a value from one register to another.\nTo  ensure  that  commonly  used  registers  (SFRs  and select  GPRs)  can  be  accessed  in  a  single  cycle, regardless of the current BSR values, an Access Bank is implemented. A segment of Bank 0 and a segment of Bank 15 comprise the Access RAM. Section 4.10 provides a detailed description of the Access RAM.",
    "4.9.1 GENERAL PURPOSE REGISTER FILE\nThe register file can be accessed either directly, or indirectly. Indirect  addressing  operates  using  the  File Select  Registers  (FSRn)  and  corresponding  Indirect File Operand (INDFn). The operation of indirect addressing is shown in Section 4.12.\nEnhanced MCU devices may have banked memory in the GPR area. GPRs are not initialized by a Power-on Reset and are unchanged on all other RESETS.\nData RAM is available for use as GPR registers by all instructions. The top half of bank 15 (0xF80 to 0xFFF) contains SFRs. All other banks of data memory contain GPR registers, starting with bank 0.",
    "4.9.2 SPECIAL FUNCTION REGISTERS\nThe Special Function  Registers (SFRs) are registers used by the CPU and Peripheral Modules for controlling the desired operation of the device. These registers  are  implemented  as  static  RAM.  A  list  of  these registers is given in Table 4-1 and Table 4-2.\nThe SFRs can be classified into two sets; those associated with the 'core' function and those related to the peripheral  functions.  Those  registers  related  to  the 'core' are described in this section, while those related to the operation of the peripheral features are described in the section of that peripheral feature.\nThe SFRs are typically distributed among the peripherals whose functions they control.\nThe unused SFR locations will be unimplemented and read as '0's. See Table 4-1 for addresses for the SFRs.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFFEh, TOSU = TOSH. FFEh, FDFh = FDEh. FFEh, INDF2 (3) = POSTINC2 (3). FFEh, FBFh = FBEh. FFEh, CCPR1H = CCPR1L. FFEh, F9Fh = F9Eh. FFEh, IPR1 = PIR1. FFDh, TOSU = TOSL. FFDh, FDFh = FDDh. FFDh, INDF2 (3) = POSTDEC2 (3). FFDh, FBFh = FBDh. FFDh, CCPR1H = CCP1CON. FFDh, F9Fh = F9Dh. FFDh, IPR1 = PIE1. FFCh, TOSU = STKPTR. FFCh, FDFh = FDCh. FFCh, INDF2 (3) = PREINC2 (3). FFCh, FBFh = FBCh. FFCh, CCPR1H = CCPR2H. FFCh, F9Fh = F9Ch. FFCh,",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nIPR1 = -. FFBh, TOSU = PCLATU. FFBh, FDFh = FDBh. FFBh, INDF2 (3) = PLUSW2 (3). FFBh, FBFh = FBBh. FFBh, CCPR1H = CCPR2L. FFBh, F9Fh = F9Bh. FFBh, IPR1 = -. FFAh, TOSU = PCLATH. FFAh, FDFh = FDAh. FFAh, INDF2 (3) = FSR2H. FFAh, FBFh = FBAh. FFAh, CCPR1H = CCP2CON. FFAh, F9Fh = F9Ah. FFAh, IPR1 = -. FF9h, TOSU = PCL. FF9h, FDFh = FD9h. FF9h, INDF2 (3) = FSR2L. FF9h, FBFh = FB9h. FF9h, CCPR1H = -. FF9h, F9Fh = F99h.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFF9h, IPR1 = -. FF8h, TOSU = TBLPTRU. FF8h, FDFh = FD8h. FF8h, INDF2 (3) = STATUS. FF8h, FBFh = FB8h. FF8h, CCPR1H = -. FF8h, F9Fh = F98h. FF8h, IPR1 = -. FF7h, TOSU = TBLPTRH. FF7h, FDFh = FD7h. FF7h, INDF2 (3) = TMR0H. FF7h, FBFh = FB7h. FF7h, CCPR1H = -. FF7h, F9Fh = F97h. FF7h, IPR1 = -. FF6h, TOSU = TBLPTRL. FF6h, FDFh = FD6h. FF6h, INDF2 (3) = TMR0L. FF6h, FBFh = FB6h. FF6h,",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nCCPR1H = -. FF6h, F9Fh = F96h. FF6h, IPR1 = TRISE (2). FF5h, TOSU = TABLAT. FF5h, FDFh = FD5h. FF5h, INDF2 (3) = T0CON. FF5h, FBFh = FB5h. FF5h, CCPR1H = -. FF5h, F9Fh = F95h. FF5h, IPR1 = TRISD (2). FF4h, TOSU = PRODH. FF4h, FDFh = FD4h. FF4h, INDF2 (3) = -. FF4h, FBFh = FB4h. FF4h, CCPR1H = -. FF4h, F9Fh = F94h. FF4h, IPR1 = TRISC. FF3h, TOSU = PRODL. FF3h, FDFh = FD3h. FF3h, INDF2 (3) =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nOSCCON. FF3h, FBFh = FB3h. FF3h, CCPR1H = TMR3H. FF3h, F9Fh = F93h. FF3h, IPR1 = TRISB. FF2h, TOSU = INTCON. FF2h, FDFh = FD2h. FF2h, INDF2 (3) = LVDCON. FF2h, FBFh = FB2h. FF2h, CCPR1H = TMR3L. FF2h, F9Fh = F92h. FF2h, IPR1 = TRISA. FF1h, TOSU = INTCON2. FF1h, FDFh = FD1h. FF1h, INDF2 (3) = WDTCON. FF1h, FBFh = FB1h. FF1h, CCPR1H = T3CON. FF1h, F9Fh = F91h. FF1h, IPR1 = -. FF0h, TOSU =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nINTCON3. FF0h, FDFh = FD0h. FF0h, INDF2 (3) = RCON. FF0h, FBFh = FB0h. FF0h, CCPR1H = -. FF0h, F9Fh = F90h. FF0h, IPR1 = -. FEFh, TOSU = INDF0 (3). FEFh, FDFh = FCFh. FEFh, INDF2 (3) = TMR1H. FEFh, FBFh = FAFh. FEFh, CCPR1H = SPBRG. FEFh, F9Fh = F8Fh. FEFh, IPR1 = -. FEEh, TOSU = POSTINC0 (3). FEEh, FDFh = FCEh. FEEh, INDF2 (3) = TMR1L. FEEh, FBFh = FAEh. FEEh, CCPR1H = RCREG. FEEh, F9Fh = F8Eh. FEEh,",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nIPR1 = -. FEDh, TOSU = POSTDEC0 (3). FEDh, FDFh = FCDh. FEDh, INDF2 (3) = T1CON. FEDh, FBFh = FADh. FEDh, CCPR1H = TXREG. FEDh, F9Fh = F8Dh. FEDh, IPR1 = LATE (2). FECh, TOSU = PREINC0 (3). FECh, FDFh = FCCh. FECh, INDF2 (3) = TMR2. FECh, FBFh = FACh. FECh, CCPR1H = TXSTA. FECh, F9Fh = F8Ch. FECh, IPR1 = LATD (2). FEBh, TOSU = PLUSW0 (3). FEBh, FDFh = FCBh. FEBh, INDF2 (3) = PR2. FEBh, FBFh = FABh. FEBh, CCPR1H = RCSTA. FEBh, F9Fh = F8Bh.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFEBh, IPR1 = LATC. FEAh, TOSU = FSR0H. FEAh, FDFh = FCAh. FEAh, INDF2 (3) = T2CON. FEAh, FBFh = FAAh. FEAh, CCPR1H = -. FEAh, F9Fh = F8Ah. FEAh, IPR1 = LATB. FE9h, TOSU = FSR0L. FE9h, FDFh = FC9h. FE9h, INDF2 (3) = SSPBUF. FE9h, FBFh = FA9h. FE9h, CCPR1H = -. FE9h, F9Fh = F89h. FE9h, IPR1 = LATA. FE8h, TOSU = WREG. FE8h, FDFh = FC8h. FE8h, INDF2 (3) = SSPADD. FE8h, FBFh = FA8h. FE8h, CCPR1H = -. FE8h, F9Fh =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nF88h. FE8h, IPR1 = -. FE7h, TOSU = INDF1 (3). FE7h, FDFh = FC7h. FE7h, INDF2 (3) = SSPSTAT. FE7h, FBFh = FA7h. FE7h, CCPR1H = -. FE7h, F9Fh = F87h. FE7h, IPR1 = -. FE6h, TOSU = POSTINC1 (3). FE6h, FDFh = FC6h. FE6h, INDF2 (3) = SSPCON1. FE6h, FBFh = FA6h. FE6h, CCPR1H = -. FE6h, F9Fh = F86h. FE6h, IPR1 = -. FE5h, TOSU = POSTDEC1 (3). FE5h, FDFh = FC5h. FE5h, INDF2 (3) = SSPCON2. FE5h, FBFh = FA5h.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFE5h, CCPR1H = -. FE5h, F9Fh = F85h. FE5h, IPR1 = -. FE4h, TOSU = PREINC1 (3). FE4h, FDFh = FC4h. FE4h, INDF2 (3) = ADRESH. FE4h, FBFh = FA4h. FE4h, CCPR1H = -. FE4h, F9Fh = F84h. FE4h, IPR1 = PORTE (2). FE3h, TOSU = PLUSW1 (3). FE3h, FDFh = FC3h. FE3h, INDF2 (3) = ADRESL. FE3h, FBFh = FA3h. FE3h, CCPR1H = -. FE3h, F9Fh = F83h. FE3h, IPR1 = PORTD (2). FE2h, TOSU = FSR1H. FE2h, FDFh = FC2h. FE2h,",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nINDF2 (3) = ADCON0. FE2h, FBFh = FA2h. FE2h, CCPR1H = IPR2. FE2h, F9Fh = F82h. FE2h, IPR1 = PORTC. FE1h, TOSU = FSR1L. FE1h, FDFh = FC1h. FE1h, INDF2 (3) = ADCON1. FE1h, FBFh = FA1h. FE1h, CCPR1H = PIR2. FE1h, F9Fh = F81h. FE1h, IPR1 = PORTB. FE0h, TOSU = BSR. FE0h, FDFh = FC0h. FE0h, INDF2 (3) = -. FE0h, FBFh = FA0h. FE0h, CCPR1H = PIE2. FE0h, F9Fh = F80h. FE0h, IPR1 = PORTA\nNote",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\n1: Unimplemented registers are read as '0'.\n2: This register is not available on PIC18C2X2 devices.\n3: This is not a physical register.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nTOSU, Bit 7 = -. TOSU, Bit 6 = -. TOSU, Bit 5 = -. TOSU, Bit 4 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 3 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 2 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 1 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 0 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Value on POR, BOR = ---0 0000. TOSU, Details on page: = 37. TOSH, Bit 7 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 6 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 5 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 4 = Top-of-Stack High Byte",
    "TABLE 4-2: REGISTER FILE SUMMARY\n(TOS<15:8>). TOSH, Bit 3 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 2 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 1 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 0 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Value on POR, BOR = 0000 0000. TOSH, Details on page: = 37. TOSL, Bit 7 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 6 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 5 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 4 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 3 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 2 =",
    "TABLE 4-2: REGISTER FILE SUMMARY\nTop-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 1 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 0 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Value on POR, BOR = 0000 0000. TOSL, Details on page: = 37. STKPTR, Bit 7 = STKFUL. STKPTR, Bit 6 = STKUNF. STKPTR, Bit 5 = -. STKPTR, Bit 4 = Return Stack Pointer. STKPTR, Bit 3 = Return Stack Pointer. STKPTR, Bit 2 = Return Stack Pointer. STKPTR, Bit 1 = Return Stack Pointer. STKPTR, Bit 0 = Return Stack Pointer. STKPTR, Value on POR, BOR = 00-0 0000. STKPTR, Details on page: = 38. PCLATU, Bit 7 = -. PCLATU, Bit 6 = -. PCLATU, Bit 5 = -. PCLATU, Bit 4 = Holding",
    "TABLE 4-2: REGISTER FILE SUMMARY\nRegister for PC<20:16>. PCLATU, Bit 3 = Holding Register for PC<20:16>. PCLATU, Bit 2 = Holding Register for PC<20:16>. PCLATU, Bit 1 = Holding Register for PC<20:16>. PCLATU, Bit 0 = Holding Register for PC<20:16>. PCLATU, Value on POR, BOR = ---0 0000. PCLATU, Details on page: = 39. PCLATH, Bit 7 = Holding Register for PC<15:8>. PCLATH, Bit 6 = Holding Register for PC<15:8>. PCLATH, Bit 5 = Holding Register for PC<15:8>. PCLATH, Bit 4 = Holding Register for PC<15:8>. PCLATH, Bit 3 = Holding Register for PC<15:8>. PCLATH, Bit 2 = Holding Register for PC<15:8>. PCLATH, Bit 1 = Holding Register for PC<15:8>. PCLATH, Bit 0 = Holding Register for PC<15:8>. PCLATH, Value on",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPOR, BOR = 0000 0000. PCLATH, Details on page: = 39. PCL, Bit 7 = PC Low Byte (PC<7:0>). PCL, Bit 6 = PC Low Byte (PC<7:0>). PCL, Bit 5 = PC Low Byte (PC<7:0>). PCL, Bit 4 = PC Low Byte (PC<7:0>). PCL, Bit 3 = PC Low Byte (PC<7:0>). PCL, Bit 2 = PC Low Byte (PC<7:0>). PCL, Bit 1 = PC Low Byte (PC<7:0>). PCL, Bit 0 = PC Low Byte (PC<7:0>). PCL, Value on POR, BOR = 0000 0000. PCL, Details on page: = 39. TBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit21 (2). TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte",
    "TABLE 4-2: REGISTER FILE SUMMARY\n(TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on POR, BOR = ---0 0000. TBLPTRU, Details on page: = 57. TBLPTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit",
    "TABLE 4-2: REGISTER FILE SUMMARY\n3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Value on POR, BOR = 0000 0000. TBLPTRH, Details on page: = 57. TBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>).",
    "TABLE 4-2: REGISTER FILE SUMMARY\nTBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Value on POR, BOR = 0000 0000. TBLPTRL, Details on page: = 57. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on POR, BOR = 0000 0000. TABLAT, Details on page: = 57. PRODH, Bit 7 = Product Register High Byte. PRODH, Bit 6 = Product Register High Byte. PRODH, Bit 5 = Product Register High",
    "TABLE 4-2: REGISTER FILE SUMMARY\nByte. PRODH, Bit 4 = Product Register High Byte. PRODH, Bit 3 = Product Register High Byte. PRODH, Bit 2 = Product Register High Byte. PRODH, Bit 1 = Product Register High Byte. PRODH, Bit 0 = Product Register High Byte. PRODH, Value on POR, BOR = xxxx xxxx. PRODH, Details on page: = 61. PRODL, Bit 7 = Product Register Low Byte. PRODL, Bit 6 = Product Register Low Byte. PRODL, Bit 5 = Product Register Low Byte. PRODL, Bit 4 = Product Register Low Byte. PRODL, Bit 3 = Product Register Low Byte. PRODL, Bit 2 = Product Register Low Byte. PRODL, Bit 1 = Product Register Low Byte. PRODL, Bit 0 = Product Register Low Byte. PRODL, Value on POR, BOR = xxxx xxxx. PRODL, Details on page: = 61. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 =",
    "TABLE 4-2: REGISTER FILE SUMMARY\nRBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Details on page: = 65. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111 -1-1. INTCON2, Details on page: = 66. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nINTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 11-0 0-00. INTCON3, Details on page: = 67. INDF0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 1 = Uses contents of FSR0 to address data",
    "TABLE 4-2: REGISTER FILE SUMMARY\nmemory - value of FSR0 not changed (not a physical register). INDF0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Value on POR, BOR = N/A. INDF0, Details on page: = 50. POSTINC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented",
    "TABLE 4-2: REGISTER FILE SUMMARY\n(not a physical register). POSTINC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Value on POR, BOR = N/A. POSTINC0, Details on page: = 50. POSTDEC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical",
    "TABLE 4-2: REGISTER FILE SUMMARY\nregister). POSTDEC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Value on POR, BOR = N/A. POSTDEC0, Details on page: = 50. PREINC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register).",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPREINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a",
    "TABLE 4-2: REGISTER FILE SUMMARY\nphysical register). PREINC0, Value on POR, BOR = N/A. PREINC0, Details on page: = 50. PLUSW0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0. PLUSW0, Bit 6 = offset by. PLUSW0, Bit 5 = value in WREG. PLUSW0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0. PLUSW0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0. PLUSW0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0. PLUSW0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not",
    "TABLE 4-2: REGISTER FILE SUMMARY\na physical register) - value of FSR0. PLUSW0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0. PLUSW0, Value on POR, BOR = N/A. PLUSW0, Details on page: = 50. FSR0H, Bit 7 = -. FSR0H, Bit 6 = -. FSR0H, Bit 5 = -. FSR0H, Bit 4 = -. FSR0H, Bit 3 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 2 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 1 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 0 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Value on POR, BOR = ---- 0000. FSR0H, Details on page: = 50. FSR0L, Bit 7 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 6 = Indirect Data Memory Address Pointer 0",
    "TABLE 4-2: REGISTER FILE SUMMARY\nLow Byte. FSR0L, Bit 5 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 4 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 3 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 2 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 1 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 0 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Value on POR, BOR = xxxx xxxx. FSR0L, Details on page: = 50. WREG, Bit 7 = Working Register. WREG, Bit 6 = Working Register. WREG, Bit 5 = Working Register. WREG, Bit 4 = Working Register. WREG, Bit 3 = Working Register. WREG, Bit 2 = Working Register. WREG, Bit 1 = Working Register. WREG, Bit 0 = Working Register. WREG, Value on POR, BOR = xxxx xxxx. WREG, Details on page: = xxxx xxxx. INDF1, Bit 7 = Uses contents of FSR1 to",
    "TABLE 4-2: REGISTER FILE SUMMARY\naddress data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Value on",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPOR, BOR = N/A. INDF1, Details on page: = 50. POSTINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 1 = Uses contents of",
    "TABLE 4-2: REGISTER FILE SUMMARY\nFSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Value on POR, BOR = N/A. POSTINC1, Details on page: = 50. POSTDEC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 3 = Uses contents of FSR1 to",
    "TABLE 4-2: REGISTER FILE SUMMARY\naddress data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Value on POR, BOR = N/A. POSTDEC1, Details on page: = 50. PREINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 5 = Uses contents of FSR1 to address data memory -",
    "TABLE 4-2: REGISTER FILE SUMMARY\nvalue of FSR1 pre-incremented (not a physical register). PREINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Value on POR, BOR = N/A. PREINC1, Details on page: = 50. PLUSW1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1",
    "TABLE 4-2: REGISTER FILE SUMMARY\npre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value",
    "TABLE 4-2: REGISTER FILE SUMMARY\nof FSR1 offset by value in WREG. PLUSW1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Value on POR, BOR = N/A. PLUSW1, Details on page: = 50. FSR1H, Bit 7 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 6 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 5 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 4 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 3 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 2 = - - - -",
    "TABLE 4-2: REGISTER FILE SUMMARY\nIndirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 1 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 0 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Value on POR, BOR = ---- 0000. FSR1H, Details on page: = 50. FSR1L, Bit 7 = Indirect Data. FSR1L, Bit 6 = Memory Address. FSR1L, Bit 5 = Pointer. FSR1L, Bit 4 = Low Byte. FSR1L, Bit 3 = xxxx. FSR1L, Bit 2 = xxxx. FSR1L, Bit 1 = xxxx. FSR1L, Bit 0 = xxxx. FSR1L, Value on POR, BOR = xxxx. FSR1L, Details on page: = 50. BSR, Bit 7 = -. BSR, Bit 6 = -. BSR, Bit 5 = -. BSR, Bit 4 = -. BSR, Bit 3 = Bank Select Register. BSR, Bit 2 = Bank Select Register.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nBSR, Bit 1 = Bank Select Register. BSR, Bit 0 = Bank Select Register. BSR, Value on POR, BOR = ---- 0000. BSR, Details on page: = 49. INDF2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 1 = Uses contents",
    "TABLE 4-2: REGISTER FILE SUMMARY\nof FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Value on POR, BOR = N/A. INDF2, Details on page: = 50. POSTINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of",
    "TABLE 4-2: REGISTER FILE SUMMARY\nFSR2 post-incremented (not a physical register). POSTINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Value on POR, BOR = N/A. POSTINC2, Details on page: = 50. POSTDEC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2",
    "TABLE 4-2: REGISTER FILE SUMMARY\npost-decremented (not a physical register). POSTDEC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Value on POR, BOR = N/A. POSTDEC2, Details on page: = 50. PREINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2",
    "TABLE 4-2: REGISTER FILE SUMMARY\npre-incremented (not a physical register). PREINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 0 = Uses contents of FSR2 to address data memory - value",
    "TABLE 4-2: REGISTER FILE SUMMARY\nof FSR2 pre-incremented (not a physical register). PREINC2, Value on POR, BOR = N/A. PREINC2, Details on page: = 50. PLUSW2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 3 = Uses contents of FSR2 to address data",
    "TABLE 4-2: REGISTER FILE SUMMARY\nmemory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Value on POR, BOR = N/A. PLUSW2, Details on page: = 50. FSR2H, Bit 7 = -. FSR2H, Bit 6 = -. FSR2H, Bit 5 = -. FSR2H, Bit 4 = -. FSR2H, Bit 3 = Indirect Data",
    "TABLE 4-2: REGISTER FILE SUMMARY\nMemory Address Pointer 2 High Byte. FSR2H, Bit 2 = Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 1 = Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 0 = Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Value on POR, BOR = ---- 0000. FSR2H, Details on page: = 50. FSR2L, Bit 7 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 6 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 5 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 4 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 3 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 2 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 1 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 0 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Value on POR, BOR = xxxx xxxx. FSR2L, Details",
    "TABLE 4-2: REGISTER FILE SUMMARY\non page: = 50. STATUS, Bit 7 = - - - N OV Z DC C Timer0 Register High Byte. STATUS, Bit 6 = - - - N OV Z DC C Timer0 Register High Byte. STATUS, Bit 5 = - - - N OV Z DC C Timer0 Register High Byte. STATUS, Bit 4 = - - - N OV Z DC C Timer0 Register High Byte. STATUS, Bit 3 = - - - N OV Z DC C Timer0 Register High Byte. STATUS, Bit 2 = - - - N OV Z DC C Timer0 Register High Byte. STATUS, Bit 1 = - - - N OV Z DC C Timer0 Register High Byte. STATUS, Bit 0 = - - - N OV Z DC C Timer0 Register High Byte. STATUS, Value on POR, BOR = ---x xxxx xxxx xxxx. STATUS, Details on page: = 52. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3",
    "TABLE 4-2: REGISTER FILE SUMMARY\n= . T0CON, Bit 2 = . T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = . T0CON, Value on POR, BOR = 1111 1111. T0CON, Details on page: = . TMR0H, Bit 7 = . TMR0H, Bit 6 = . TMR0H, Bit 5 = . TMR0H, Bit 4 = . TMR0H, Bit 3 = . TMR0H, Bit 2 = . TMR0H, Bit 1 = . TMR0H, Bit 0 = . TMR0H, Value on POR, BOR = 0000 0000. TMR0H, Details on page: = 95. TMR0L, Bit 7 = Timer0 Register Low Byte. TMR0L, Bit 6 = Timer0 Register Low Byte. TMR0L, Bit 5 = Timer0 Register Low Byte. TMR0L, Bit 4 = Timer0 Register Low Byte. TMR0L, Bit 3 = Timer0 Register Low Byte. TMR0L,",
    "TABLE 4-2: REGISTER FILE SUMMARY\nBit 2 = Timer0 Register Low Byte. TMR0L, Bit 1 = Timer0 Register Low Byte. TMR0L, Bit 0 = Timer0 Register Low Byte. TMR0L, Value on POR, BOR = . TMR0L, Details on page: = 95. , Bit 7 = . , Bit 6 = . , Bit 5 = . , Bit 4 = . , Bit 3 = PSA. , Bit 2 = T0PS2. , Bit 1 = . , Bit 0 = T0PS0. , Value on POR, BOR = . , Details on page: = 93. OSCCON, Bit 7 = -. OSCCON, Bit 6 = -. OSCCON, Bit 5 = -. OSCCON, Bit 4 = -. OSCCON, Bit 3 = -. OSCCON, Bit 2 = -. OSCCON, Bit 1 = -. OSCCON, Bit 0 = SCS. OSCCON, Value on POR, BOR = ---- ---0. OSCCON, Details on page: = 20. LVDCON, Bit 7 = -.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nLVDCON, Bit 6 = -. LVDCON, Bit 5 = IRVST. LVDCON, Bit 4 = LVDEN. LVDCON, Bit 3 = LVDL3. LVDCON, Bit 2 = LVDL2. LVDCON, Bit 1 = LVDL1. LVDCON, Bit 0 = LVDL0. LVDCON, Value on POR, BOR = --00 0101. LVDCON, Details on page: = 175\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1:\nRA6 and associated bits are configured as port pins in RCIO and ECIO oscillator mode only, and read '0' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nWDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTE. WDTCON, Value on POR, BOR = ---- ---0. WDTCON, Details on page: = 183. RCON, Bit 7 = IPEN. RCON, Bit 6 = LWRT. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0q-1 11qq. RCON, Details on page: = 53, 56, 74. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nTimer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Value on POR, BOR = xxxx xxxx. TMR1H, Details on page: = 97. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Value on POR, BOR =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nxxxx xxxx. TMR1L, Details on page: = 97. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00 0000. T1CON, Details on page: = 97. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Value on",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nPOR, BOR = 0000 0000. TMR2, Details on page: = 101. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111 1111. PR2, Details on page: = 102. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n0000. T2CON, Details on page: = 101. SSPBUF, Bit 7 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 0 = SSP Receive Buffer/Transmit Register. SSPBUF, Value on POR, BOR = xxxx xxxx. SSPBUF, Details on page: = 121. SSPADD, Bit 7 = SSP Address Register in I 2 C Slave Mode. SSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 6 = SSP Address Register in I 2 C Slave Mode. SSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 5",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n= SSP Address Register in I 2 C Slave Mode. SSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 4 = SSP Address Register in I 2 C Slave Mode. SSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 3 = SSP Address Register in I 2 C Slave Mode. SSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 2 = SSP Address Register in I 2 C Slave Mode. SSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 1 = SSP Address Register in I 2 C Slave Mode. SSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 0 = SSP Address Register in I 2 C Slave Mode. SSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Value on POR, BOR = 0000 0000. SSPADD, Details on page: = 128. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nSSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR, BOR = 0000 0000. SSPSTAT, Details on page: = 116. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 = SSPM1. SSPCON1, Bit 0 = SSPM0. SSPCON1, Value on POR, BOR = 0000 0000. SSPCON1, Details on page: = 118. SSPCON2, Bit 7 = GCEN. SSPCON2, Bit 6 = ACKSTAT. SSPCON2, Bit 5 = ACKDT.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nSSPCON2, Bit 4 = ACKEN. SSPCON2, Bit 3 = RCEN. SSPCON2, Bit 2 = PEN. SSPCON2, Bit 1 = RSEN. SSPCON2, Bit 0 = SEN. SSPCON2, Value on POR, BOR = 0000 0000. SSPCON2, Details on page: = 120. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Value on POR, BOR = xxxx xxxx. ADRESH, Details on page: = 171,172. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nA/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Value on POR, BOR = xxxx xxxx. ADRESL, Details on page: = 171,172. ADCON0, Bit 7 = ADCS1. ADCON0, Bit 6 = ADCS0. ADCON0, Bit 5 = CHS2. ADCON0, Bit 4 = CHS1. ADCON0, Bit 3 = CHS0. ADCON0, Bit 2 = GO/DONE. ADCON0, Bit 1 = -. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = 0000 00-0. ADCON0, Details on page: = 165. ADCON1, Bit",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = 00-- 0000. ADCON1, Details on page: = 166. CCPR1H, Bit 7 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 6 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 5 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 4 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 3 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 2 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 1 = Capture/Compare/PWM",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nRegister1 High Byte. CCPR1H, Bit 0 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Value on POR, BOR = xxxx xxxx. CCPR1H, Details on page: = 111, 113. CCPR1L, Bit 7 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 6 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 5 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 4 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 3 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 2 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 1 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 0 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Value on POR, BOR = xxxx xxxx. CCPR1L, Details on page: = 111,",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n113. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = --00 0000. CCP1CON, Details on page: = 107. CCPR2H, Bit 7 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 6 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 5 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 4 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 3 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 2 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nCapture/Compare/PWM Register2 High Byte. CCPR2H, Bit 1 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 0 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Value on POR, BOR = xxxx xxxx. CCPR2H, Details on page: = 111, 113. CCPR2L, Bit 7 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 6 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 5 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 4 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 3 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 2 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 1 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 0 = Capture/Compare/PWM Register2 Low Byte.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nCCPR2L, Value on POR, BOR = xxxx xxxx. CCPR2L, Details on page: = 111, 113. CCP2CON, Bit 7 = -. CCP2CON, Bit 6 = -. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Value on POR, BOR = --00 0000. CCP2CON, Details on page: = 107. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = Timer3 Register High Byte. TMR3H, Value on POR, BOR = xxxx xxxx. TMR3H, Details on page: = 103. TMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = Timer3 Register Low Byte. TMR3L, Value on POR, BOR = xxxx xxxx. TMR3L, Details on page: = 103. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nT3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000 0000. T3CON, Details on page: = 103. SPBRG, Bit 7 = USART1 Baud Rate Generator. SPBRG, Bit 6 = USART1 Baud Rate Generator. SPBRG, Bit 5 = USART1 Baud Rate Generator. SPBRG, Bit 4 = USART1 Baud Rate Generator. SPBRG, Bit 3 = USART1 Baud Rate Generator. SPBRG, Bit 2 = USART1 Baud Rate Generator. SPBRG, Bit 1 = USART1 Baud Rate Generator. SPBRG, Bit 0 = USART1 Baud Rate Generator. SPBRG, Value on POR, BOR = 0000 0000. SPBRG, Details",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\non page: = 151. RCREG, Bit 7 = USART1 Receive Register. RCREG, Bit 6 = USART1 Receive Register. RCREG, Bit 5 = USART1 Receive Register. RCREG, Bit 4 = USART1 Receive Register. RCREG, Bit 3 = USART1 Receive Register. RCREG, Bit 2 = USART1 Receive Register. RCREG, Bit 1 = USART1 Receive Register. RCREG, Bit 0 = USART1 Receive Register. RCREG, Value on POR, BOR = 0000 0000. RCREG, Details on page: = 158,161, 163. TXREG, Bit 7 = USART1 Transmit Register. TXREG, Bit 6 = USART1 Transmit Register. TXREG, Bit 5 = USART1 Transmit Register. TXREG, Bit 4 = USART1 Transmit Register. TXREG, Bit 3 = USART1 Transmit Register. TXREG, Bit 2 = USART1 Transmit Register. TXREG, Bit 1 = USART1 Transmit Register. TXREG, Bit 0 = USART1 Transmit Register.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nTXREG, Value on POR, BOR = 0000 0000. TXREG, Details on page: = 156,159, 162. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000 -010. TXSTA, Details on page: = 149. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000 000x. RCSTA, Details on page: = 150",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: RA6 and associated bits are configured as port pins in RCIO and ECIO oscillator mode only, and read '0' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nIPR2, Bit 7 = -. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = -. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = ---- 1111. IPR2, Details on page: = 73. PIR2, Bit 7 = -. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = -. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = ---- 0000. PIR2, Details on page: = 69. PIE2, Bit 7 = -. PIE2, Bit 6 = -. PIE2, Bit 5 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n-. PIE2, Bit 4 = -. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = ---- 0000. PIE2, Details on page: = 71. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111 1111. IPR1, Details on page: = 72. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nSSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000 0000. PIR1, Details on page: = 68. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000. PIE1, Details on page: = 70. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE, Bit 3 = -. TRISE, Bit 2 = Data Direction bits for PORTE. TRISE, Bit 1 = Data Direction bits for PORTE.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nTRISE, Bit 0 = Data Direction bits for PORTE. TRISE, Value on POR, BOR = 0000 -111. TRISE, Details on page: = 88. TRISD, Bit 7 = Data Direction Control Register for PORTD. TRISD, Bit 6 = Data Direction Control Register for PORTD. TRISD, Bit 5 = Data Direction Control Register for PORTD. TRISD, Bit 4 = Data Direction Control Register for PORTD. TRISD, Bit 3 = Data Direction Control Register for PORTD. TRISD, Bit 2 = Data Direction Control Register for PORTD. TRISD, Bit 1 = Data Direction Control Register for PORTD. TRISD, Bit 0 = Data Direction Control Register for PORTD. TRISD, Value on POR, BOR = 1111 1111. TRISD, Details on page: = 85. TRISC, Bit 7 = Data Direction Control Register for PORTC. TRISC, Bit 6 = Data Direction Control Register for PORTC. TRISC, Bit 5 = Data Direction Control Register for PORTC. TRISC, Bit 4 = Data Direction Control Register for PORTC. TRISC, Bit 3 = Data Direction Control Register for PORTC.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nTRISC, Bit 2 = Data Direction Control Register for PORTC. TRISC, Bit 1 = Data Direction Control Register for PORTC. TRISC, Bit 0 = Data Direction Control Register for PORTC. TRISC, Value on POR, BOR = 1111 1111. TRISC, Details on page: = 83. TRISB, Bit 7 = Data Direction Control Register for PORTB. TRISB, Bit 6 = Data Direction Control Register for PORTB. TRISB, Bit 5 = Data Direction Control Register for PORTB. TRISB, Bit 4 = Data Direction Control Register for PORTB. TRISB, Bit 3 = Data Direction Control Register for PORTB. TRISB, Bit 2 = Data Direction Control Register for PORTB. TRISB, Bit 1 = Data Direction Control Register for PORTB. TRISB, Bit 0 = Data Direction Control Register for PORTB. TRISB, Value on POR, BOR = 1111 1111. TRISB, Details on page: = 80. TRISA, Bit 7 = -. TRISA, Bit 6 = TRISA6 (1). TRISA, Bit 5 = Data Direction Control Register for PORTA. TRISA, Bit 4 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nData Direction Control Register for PORTA. TRISA, Bit 3 = Data Direction Control Register for PORTA. TRISA, Bit 2 = Data Direction Control Register for PORTA. TRISA, Bit 1 = Data Direction Control Register for PORTA. TRISA, Bit 0 = Data Direction Control Register for PORTA. TRISA, Value on POR, BOR = -111 1111. TRISA, Details on page: = 77. LATE, Bit 7 = -. LATE, Bit 6 = -. LATE, Bit 5 = -. LATE, Bit 4 = -. LATE, Bit 3 = -. LATE, Bit 2 = Read PORTE Data Latch,. LATE, Bit 1 = Read PORTE Data Latch,. LATE, Bit 0 = Read PORTE Data Latch,. LATE, Value on POR, BOR = ---- -xxx. LATE, Details on page: = 87. LATD, Bit 7 = Read PORTD Data Latch, Write PORTD Data Latch. LATD, Bit 6 = Read PORTD Data Latch, Write PORTD Data Latch. LATD, Bit 5 = Read PORTD Data Latch, Write PORTD Data Latch. LATD, Bit",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n4 = Read PORTD Data Latch, Write PORTD Data Latch. LATD, Bit 3 = Read PORTD Data Latch, Write PORTD Data Latch. LATD, Bit 2 = Read PORTD Data Latch, Write PORTD Data Latch. LATD, Bit 1 = Read PORTD Data Latch, Write PORTD Data Latch. LATD, Bit 0 = Read PORTD Data Latch, Write PORTD Data Latch. LATD, Value on POR, BOR = xxxx xxxx. LATD, Details on page: = 85. LATC, Bit 7 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 6 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 5 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 4 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 3 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 2 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 1 = Read PORTC Data Latch, Write PORTC Data Latch.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nLATC, Bit 0 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Value on POR, BOR = xxxx xxxx. LATC, Details on page: = 83. LATB, Bit 7 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 6 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 5 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 4 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 3 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 2 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 1 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 0 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Value on POR, BOR = xxxx xxxx. LATB, Details on page: = 80. LATA, Bit 7 = -. LATA, Bit 6 = LATA6 (1).",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nLATA, Bit 5 = Read PORTA Data Latch, Write PORTA Data Latch (1). LATA, Bit 4 = Read PORTA Data Latch, Write PORTA Data Latch (1). LATA, Bit 3 = Read PORTA Data Latch, Write PORTA Data Latch (1). LATA, Bit 2 = Read PORTA Data Latch, Write PORTA Data Latch (1). LATA, Bit 1 = Read PORTA Data Latch, Write PORTA Data Latch (1). LATA, Bit 0 = Read PORTA Data Latch, Write PORTA Data Latch (1). LATA, Value on POR, BOR = -xxx xxxx. LATA, Details on page: = 77. PORTE, Bit 7 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 6 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 5 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 4 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 3 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 2 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 1 = Read PORTE pins,",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nWrite PORTE Data Latch. PORTE, Bit 0 = Read PORTE pins, Write PORTE Data Latch. PORTE, Value on POR, BOR = ---- -000. PORTE, Details on page: = 87. PORTD, Bit 7 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 6 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 5 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 4 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 3 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 2 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 1 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 0 = Read PORTD pins, Write PORTD Data Latch. PORTD, Value on POR, BOR = xxxx xxxx. PORTD, Details on page: = 85. PORTC, Bit 7 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 6 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 5 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nRead PORTC pins, Write PORTC Data Latch. PORTC, Bit 4 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 3 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 2 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 1 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 0 = Read PORTC pins, Write PORTC Data Latch. PORTC, Value on POR, BOR = xxxx xxxx. PORTC, Details on page: = 83. PORTB, Bit 7 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 6 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 5 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 4 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 3 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 2 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 1 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 0",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n= Read PORTB pins, Write PORTB Data Latch. PORTB, Value on POR, BOR = xxxx xxxx. PORTB, Details on page: = 80. PORTA, Bit 7 = -. PORTA, Bit 6 = RA6 (1). PORTA, Bit 5 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 4 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 3 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 2 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 1 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 0 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Value on POR, BOR = -x0x 0000. PORTA, Details on page: = 77\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1:",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nRA6 and associated bits are configured as port pins in RCIO and ECIO oscillator mode only, and read '0' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.",
    "4.10 Access Bank\nThe  Access  Bank  is  an  architectural  enhancement, which is very useful for C compiler code optimization. The techniques used by the C compiler may also be useful for programs written in assembly.\nThis data memory region can be used for:\n\u00b7 Intermediate computational values\n\u00b7 Local variables of subroutines\n\u00b7 Faster context saving/switching of variables\n\u00b7 Common variables\n\u00b7 Faster evaluation/control of SFRs (no banking)\nThe Access Bank is comprised of the upper 128 bytes in Bank 15 (SFRs) and the lower 128 bytes in Bank 0. These two sections will be referred to as Access RAM High  and  Access  RAM  Low,  respectively.  Figure 4-6 and Figure 4-7 indicate the Access RAM areas.\nA bit in the instruction word specifies if the operation is to occur in the bank specified by the BSR register or in the Access Bank. This bit is denoted by the 'a' bit (for access bit).\nWhen  forced  in  the  Access  Bank  (a  =  '0'),  the  last address  in  Access  RAM  Low  is  followed  by  the  first address in Access RAM High. Access RAM High maps the Special Function registers, so that these registers can be accessed without any software overhead. This is useful for testing status flags and modifying control bits.",
    "4.11 Bank Select Register (BSR)\nThe need for a large general purpose memory space dictates a RAM banking scheme. The data memory is partitioned into sixteen  banks.  When  using  direct addressing,  the  BSR  should  be  configured  for  the desired bank.\nBSR<3:0> holds  the  upper  4  bits  of  the  12-bit  RAM address. The BSR<7:4> bits will always read '0's, and writes will have no effect.\nA MOVLB instruction has been provided in the instruction set to assist in selecting banks.\nIf the currently selected bank is not implemented, any read will return all '0's and all writes are ignored. The STATUS register bits will be set/cleared as appropriate for the instruction performed.\nEach  Bank  extends  up  to  FFh  (256  bytes).  All  data memory is implemented as static RAM.\nA MOVFF instruction ignores the BSR, since the 12-bit addresses are embedded into the instruction word.\nSection 4.12 provides a description of indirect addressing, which allows linear addressing of the entire RAM space.\nFIGURE 4-8:\nDIRECT ADDRESSING\nNote 1: For register file map detail, see Table 4-1.",
    "4.11 Bank Select Register (BSR)\n2: The access bit of the instruction can be used to force an override of the selected bank (BSR<3:0>) to the registers of the Access Bank.\n3: The MOVFF instruction embeds the entire 12-bit address in the instruction.",
    "4.12 Indirect Addressing, INDF and FSR Registers\nIndirect addressing is a mode of addressing data memory, where the data memory address in the instruction is not fixed. An FSR register is used as a pointer to the data memory location that is to be read or written. Since this pointer is in RAM, the contents can be modified by the program. This can be useful for data tables in the data  memory  and  for  software  stacks.  Figure 4-9 shows the operation of indirect addressing. This shows the moving of the value to the data memory address, specified by the value of the FSR register.\nIndirect  addressing  is  possible  by  using  one  of  the INDF registers. Any instruction using the INDF register actually  accesses  the  register  pointed  to  by  the  File Select Register, FSR. Reading the INDF register itself, indirectly (FSR = '0'), will read 00h. Writing to the INDF register indirectly, results in a no operation. The FSR register contains a 12-bit address, which is shown in Figure 4-10.",
    "4.12 Indirect Addressing, INDF and FSR Registers\nThe INDFn register is not a physical register. Addressing INDFn  actually  addresses  the  register  whose address is contained in the FSRn register (FSRn is a pointer). This is indirect addressing.\nExample 4-4 shows a simple use of indirect addressing to clear the RAM in Bank1 (locations 100h-1FFh) in a minimum number of instructions.",
    "EXAMPLE 4-4: HOW TO CLEAR RAM (BANK1) USING INDIRECT ADDRESSING\nLFSR FSR0, 0x100 NEXT CLRF POSTINC0 BTFSS FSR0H, 1 GOTO NEXT CONTINUE, 1 = ; ; Clear INDF register ; & inc pointer ; All done w/ Bank1? ; NO, clear next ; YES, continue\nThere  are  three indirect addressing  registers. To address the entire data memory space (4096 bytes), these registers are 12-bit wide. To store the 12-bits of addressing information, two 8-bit registers are required. These indirect addressing registers are:\n1. FSR0: composed of FSR0H:FSR0L\n2. FSR1: composed of FSR1H:FSR1L\n3. FSR2: composed of FSR2H:FSR2L\nIn  addition,  there  are  registers  INDF0,  INDF1  and INDF2, which are not physically implemented. Reading or writing to these registers activates indirect addressing, with the value in the corresponding FSR register being the address of the data.",
    "EXAMPLE 4-4: HOW TO CLEAR RAM (BANK1) USING INDIRECT ADDRESSING\nIf an instruction writes a value to INDF0, the value will be written to the address pointed to by FSR0H:FSR0L. A read from INDF1 reads the data from the address pointed  to  by  FSR1H:FSR1L. INDFn can be used in code anywhere an operand can be used.\nIf  INDF0,  INDF1  or  INDF2  are  read  indirectly  via  an FSR,  all  '0's  are  read  (zero  bit  is  set).  Similarly,  if INDF0, INDF1 or INDF2 are written to indirectly, the operation will be equivalent to a NOP instruction and the STATUS bits are not affected.",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nEach  FSR  register  has  an  INDF  register  associated with it, plus four additional register addresses. Performing an operation on one of these five registers determines  how  the  FSR  will  be  modified  during  indirect addressing.\nWhen data access is done to one of the five INDFn locations, the address selected will configure the FSRn register to:\n\u00b7 Do nothing to FSRn after an indirect access (no change) - INDFn\n\u00b7 Auto-decrement FSRn after an indirect access (post-decrement) - POSTDECn\n\u00b7 Auto-increment FSRn after an indirect access (post-increment) - POSTINCn\n\u00b7 Auto-increment FSRn before an indirect access (pre-increment) - PREINCn\n\u00b7 Use the value in the WREG register as an offset to FSRn. Do not modify the value of the WREG or the FSRn register after an indirect access (no change) - PLUSWn",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nWhen using the auto-increment or auto-decrement features,  the  effect  on  the  FSR  is  not  reflected  in  the STATUS register. For example, if the indirect address causes the FSR to equal '0', the Z bit will not be set.\nIncrementing  or  decrementing  an  FSR  affects  all  12 bits. That is, when FSRnL overflows from an increment, FSRnH will be incremented automatically.\nAdding these features allows the FSRn to be used as a stack pointer, in addition to its uses for table operations in data memory.\nEach FSR has an address associated with it that performs an indexed indirect access. When a data access to this INDFn location (PLUSWn) occurs, the FSRn is configured to add the signed value in the WREG register and the value in FSR to form the address before an indirect access. The FSR value is not changed.\nIf an FSR register contains a value that points to one of the INDFn, an indirect read will read 00h (zero bit is set), while an indirect write will be equivalent to a NOP (STATUS bits are not affected).",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nIf  an indirect addressing operation is done where the target  address  is  an  FSRnH  or  FSRnL  register,  the write  operation  will  dominate  over  the  pre-  or  postincrement/decrement functions.",
    "4.13 STATUS Register\nThe STATUS register, shown in Register 4-2, contains the arithmetic status of the ALU. The STATUS register can be the destination for any instruction, as with any other register. If the STATUS register is the destination for an instruction that affects the Z, DC, C, OV or N bits, then the write to these five bits is disabled. These bits are set or cleared according to the device logic. Therefore, the result of an instruction with the STATUS register as destination may be different than intended.\nFor example, CLRF STATUS will clear the upper three bits and set the Z bit.   This leaves the STATUS register as 000u u1uu (where u = unchanged).\nIt  is  recommended,  therefore,  that  only BCF,  BSF, SWAPF,  MOVFF and MOVWF instructions are used to alter the STATUS register, because these instructions do  not  affect  the  Z,  C,  DC,  OV  or  N  bits  from  the STATUS register.  For  other  instructions  not  affecting any status bits, see Table 19-2.\nNote:\nThe C and DC bits operate as a borrow and digit borrow bit respectively, in subtraction.",
    "REGISTER 4-2: STATUS REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-x. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = -. -, 2 = -. -, 3 = N. -, 4 = OV. -, 5 = Z. -, 6 = DC. -, 7 = C\nbit 7\nbit 0",
    "bit 4 N: Negative bit\nThis bit is used for signed arithmetic (2's complement). It indicates whether the result was negative, (ALU MSB = 1).\n1 = Result was negative\n0 = Result was positive",
    "bit 3 OV: Overflow bit\nThis bit is used for signed arithmetic (2's complement). It indicates an overflow of the 7-bit magnitude, which causes the sign bit (bit7) to change state.\n1 = Overflow occurred for signed arithmetic (in this arithmetic operation)\n0 = No overflow occurred",
    "bit 2 Z: Zero bit\n1 = The result of an arithmetic or logic operation is zero\n0 = The result of an arithmetic or logic operation is not zero",
    "bit 1 DC: Digit carry/borrow bit\nFor ADDWF, ADDLW, SUBLW , and SUBWF instructions\n1 = A carry-out from the 4th low order bit of the result occurred\n0 = No carry-out from the 4th low order bit of the result\nNote:\nFor borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either the bit 4 or bit 3 of the source register.",
    "bit 0 C: Carry/borrow bit\nFor ADDWF, ADDLW, SUBLW , and SUBWF instructions\n1 = A carry-out from the Most Significant bit of the result occurred\n0 = No carry-out from the Most Significant bit of the result occurred\nNote:\nFor borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either the high or low order bit of the source register.\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "4.13.1 RCON REGISTER\nThe Reset Control (RCON) register contains flag bits that  allow  differentiation  between  the  sources  of  a device RESET. These flags include the TO, PD, POR, BOR and RI bits. This register is readable and writable.\n.\nNote 1: If the  BOREN  configuration  bit  is  set (Brown-out Reset enabled), the BOR bit is\n'1'  on a Power-on Reset. After a Brownout Reset has occurred, the BOR bit will be clear and must be set by firmware to indicate the occurrence of the next Brownout Reset.\nIf  the  BOREN  configuration  bit  is  clear (Brown-out Reset disabled), BOR is unknown after Power-on Reset and Brown-out Reset conditions.\n- 2: It is recommended that the POR bit be set after a Power-on Reset has been detected,  so  that  subsequent  Power-on Resets may be detected.",
    "REGISTER 4-3: RCON REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R/W-1. R/W-0, 5 = R/W-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = LWRT. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0\nbit 7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (16CXXX compatibility mode)",
    "bit 6 LWRT: Long Write Enable bit\n1 = Enable TBLWT to internal program memory\nOnce this bit is set, it can only be cleared by a POR or MCLR Reset.\n0 = Disable TBLWT to internal program memory; TBLWT only to external program memory",
    "bit 5 Unimplemented: Read as '0'\nbit 4 RI: RESET Instruction Flag bit\n1 = The RESET instruction was not executed\n0 = The RESET instruction was executed causing a device RESET (must be set in software after a Brown-out Reset occurs)",
    "bit 3 TO: Watchdog Time-out Flag bit\n1 = After power-up, CLRWDT instruction, or SLEEP instruction\n0 = A WDT time-out occurred",
    "bit 2 PD: Power-down Detection Flag bit\n1 = After power-up or by the CLRWDT instruction\n0 = By execution of the SLEEP instruction\nbit 1 POR: Power-on Reset Status bit\n1 = A Power-on Reset has not occurred\n0 = A Power-on Reset occurred\n(must be set in software after a Power-on Reset occurs)",
    "bit 0 BOR: Brown-out Reset Status bit\n1 = A Brown-out Reset has not occurred\n0 =\nA Brown-out Reset occurred (must be set in software after a Brown-out Reset occurs)\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "PIC18CXX2\nNOTES:",
    "5.0 TABLE READS/TABLE WRITES\nEnhanced devices have two memory spaces: the program memory space and the data memory space. The program memory space is 16-bits wide, while the data memory space is 8 bits wide. Table Reads and Table Writes  have  been  provided  to  move  data  between these  two  memory  spaces  through  an  8-bit  register (TABLAT).\nThe operations that allow the processor to move data between the data and program memory spaces are:\n\u00b7 Table Read ( TBLRD )\n\u00b7 Table Write ( TBLWT )\nTable  Read  operations  retrieve  data  from  program memory  and  place  it  into  the  data  memory  space. Figure 5-1 shows the operation of a Table Read with program and data memory.\nTable Write operations store data from the data memory space into program memory. Figure 5-2 shows the operation  of  a  Table  Write  with  program  and  data memory.\nTable operations work with byte entities. A table block containing data is not required to be word aligned, so a table block can start and end at any byte address. If a Table Write is being used to write an executable program  to  program  memory,  program  instructions  will need to be word aligned.",
    "5.1 Control Registers\nSeveral control registers are used in conjunction with the TBLRD and TBLWT instructions. These include the:\n\u00b7 TBLPTR registers\n\u00b7 TABLAT register\n\u00b7 RCON register",
    "5.1.1 RCON REGISTER\nThe LWRT bit specifies the operation of Table Writes to internal memory when the VPP voltage is applied to the MCLR pin. When the LWRT bit is set, the controller continues to execute user code, but long Table Writes are allowed (for programming internal program memory) from user mode. The LWRT bit can be cleared only by performing either a POR or MCLR Reset.",
    "REGISTER 5-1: RCON REGISTER (ADDRESS: FD0h)\nR/W-0, 1 = R/W-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R/W-1. R/W-0, 5 = R/W-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = LWRT. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7",
    "bit 7\nbit 0\nIPEN: Interrupt Priority Enable bit\n- 1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (16CXXX compatibility mode)",
    "bit 6 LWRT: Long Write Enable bit\n- 1 = Enable TBLWT to internal program memory\n0 = Disable TBLWT to internal program memory.\nNote:\nOnly cleared on a POR or MCLR  Reset.\nThis bit has no effect on TBLWTs to external program memory.",
    "bit 5 Unimplemented : Read as '0'\nbit 4 RI: RESET Instruction Flag bit\n1 = No RESET instruction occurred\n0 = A RESET instruction occurred",
    "bit 3 TO:\nTime-out bit\n1 = After power-up, CLRWDT instruction, or SLEEP instruction\n0 = A WDT time-out occurred",
    "bit 2 PD: Power-down bit\n1 = After power-up or by the CLRWDT instruction\n0 = By execution of the SLEEP instruction\nPOR: Power-on Reset Status bit\n1 =  No Power-on Reset occurred\n0 =  A Power-on Reset occurred (must be set in software after a Power-on Reset occurs)\nBOR: Brown-out Reset Status bit\n1 = No Brown-out Reset or POR Reset occurred\n= A Brown-out Reset or POR Reset occurred\n0 (must be set in software after a Brown-out Reset occurs)\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "5.1.2 TABLAT - TABLE LATCH REGISTER\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch is used to hold 8-bit data  during  data  transfers  between  program memory and data memory.",
    "5.1.3 TBLPTR - TABLE POINTER REGISTER\nThe Table Pointer (TBLPTR) addresses a byte within the  program  memory.  The  TBLPTR  is  comprised  of three SFR registers (Table Pointer Upper Byte, High Byte and Low Byte). These three registers (TBLPTRU:TBLPTRH:TBLPTRL) join to form a 22-bit wide  pointer.  The  lower  21-bits  allow  the  device  to address up to 2 Mbytes of program memory space. The 22nd bit allows access to the Device ID, the User ID and the Configuration bits.\nThe Table Pointer, TBLPTR, is used by the TBLRD and TBLWT instructions.  These  instructions  can  update  the TBLPTR in one of four ways, based on the table operation. These operations are shown in Table 5-1. These operations on the TBLPTR only affect the lower 21-bits.",
    "TABLE 5-1: TABLE POINTER OPERATIONS WITH TBLRD AND TBLWT INSTRUCTIONS\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "5.2.1 TABLE READ OVERVIEW ( TBLRD )\nThe TBLRD instructions  are  used  to  read  data  from program memory to data memory.\nWhen a Table Write occurs to an even program memory address (TBLPTR<0> = 0), the contents of TABLAT are transferred to an internal holding register. This is performed as a short write and the program memory block is not actually programmed at this time. The holding register is not accessible by the user.\nTBLPTR points to a byte address in program space. Executing TBLRD places the byte pointed to into TABLAT.  In  addition,  TBLPTR  can  be  modified  automatically for the next Table Read operation.\nTable Reads from program memory are performed one byte at a time. The instruction will load TABLAT with the one byte from program memory pointed to by TBLPTR.",
    "5.2.2 INTERNAL PROGRAM MEMORY WRITE BLOCK SIZE\nThe internal program memory of PIC18CXXX devices is written in blocks. For PIC18CXX2 devices, the write block size is 2 bytes. Consequently, Table Write operations  to  internal  program  memory  are  performed  in pairs, one byte at a time.\nWhen a Table Write occurs to an odd program memory address (TBLPTR<0>=1), a long write is started. During the long write, the contents of TABLAT are written to the high byte of the program memory block and the contents of the holding register are transferred to the low byte of the program memory block.\nFigure 5-3 shows the holding register and the program memory write blocks.",
    "5.2.2 INTERNAL PROGRAM MEMORY WRITE BLOCK SIZE\nIf  a  single  byte  is  to  be  programmed, the  low  (even) byte of the destination program word should be read using TBLRD *,  modified  or  changed,  if  required,  and written back to the same address using TBLWT*+ . The high (odd) byte should be read using TBLRD* , modified or changed if required, and written back to the same address using TBLWT .  A write to the odd address will cause a long write to begin. This process ensures that existing data in either byte will not be changed unless desired.",
    "5.2.2.2 Sequence of Events\nThe long write is what actually programs words of data into the internal memory. When a TBLWT to the MSB of the write block occurs, instruction execution is halted. During  this  time,  programming  voltage  and  the  data stored in internal latches is applied to program memory.\nFor a long write to occur:\n1. MCLR/VPP  pin  must  be  at  the  programming voltage\n2. LWRT bit must be set\n3. TBLWT to the address of the MSB of the write block\nIf the LWRT bit is clear, a short write will occur and program memory will not be changed. If the TBLWT is not to the MSB of the write block, then the programming phase is not initiated.\nSetting  the  LWRT  bit  enables  long  writes  when  the MCLR pin is taken to VPP voltage. Once the LWRT bit is set, it can be cleared only by performing a POR or MCLR Reset.",
    "5.2.2.2 Sequence of Events\nTo ensure that the memory location has been well programmed, a minimum programming time is required. The long  write  can  be  terminated  after  the  programming  time  has  expired  by  a  RESET  or  an  interrupt. Having only one interrupt source enabled to terminate the long write ensures that no unintended interrupts will prematurely terminate the long write.\nThe sequence of events for programming an internal program memory location should be:",
    "5.2.2.2 Sequence of Events\n1. Enable  the  interrupt  that  terminates  the  long write. Disable all other interrupts.\n2. Clear the source interrupt flag.\n3. If Interrupt Service Routine execution is desired when the device wakes, enable global interrupts.\n4. Set LWRT bit in the RCON register.\n5. Raise MCLR/VPP  pin to the programming voltage, VPP.\n6. Clear the WDT (if enabled).\n7. Set  the  interrupt  source  to  interrupt  at  the required time.\n8. Execute  the  Table  Write  for  the  lower  (even) byte. This will be a short write.\n9. Execute the Table Write for the upper (odd) byte. This will be a long write. The microcontroller will then  halt  internal  operations.  (This  is  not  the same  as  SLEEP  mode,  as  the  clocks  and peripherals  will  continue  to  run.)  The  interrupt will cause the microcontroller to resume operation.\n10. If GIE was set, service the interrupt request.\n11. Lower MCLR/VPP pin to VDD.\n12. Verify the memory location (Table Read).",
    "5.2.3 INTERRUPTS\nThe long write must be terminated by a RESET or any interrupt.\nThe interrupt source must have its interrupt enable bit set. When the source sets its interrupt flag, programming will terminate. This will occur, regardless of the settings of interrupt priority bits, the GIE/GIEH bit, or the PIE/GIEL bit.\nDepending on the states of interrupt priority bits, the GIE/GIEH bit or the PIE/GIEL bit, program execution can either be vectored to the high or low priority Interrupt Service Routine (ISR), or continue execution from where programming commenced.\nIn  either  case,  the  interrupt  flag  will  not  be  cleared when programming is terminated and will need to be cleared by the software.",
    "TABLE 5-2: LONG WRITE EXECUTION, INTERRUPT ENABLE BITS AND INTERRUPT RESULTS\nX, PIE/ GIEL = X. X, Priority = X. X, Interrupt Enable = 0 (default). X, Interrupt Flag = X. X, Action = Long write continues even if interrupt flag becomes set.. X, PIE/ GIEL = X. X, Priority = X. X, Interrupt Enable = 1. X, Interrupt Flag = 0. X, Action = Long write continues, will resume operations when the interrupt flag is set.. 0 (default), PIE/ GIEL = 0 (default). 0 (default), Priority = X. 0 (default), Interrupt Enable = 1. 0 (default), Interrupt Flag = 1. 0 (default), Action = Terminates long write, executes next instruction. Interrupt flag not cleared.. 0 (default), PIE/ GIEL = 1. 0 (default), Priority = 1 high priority (default). 0 (default), Interrupt Enable = 1. 0 (default), Interrupt Flag = 1. 0 (default), Action = Terminates long write, executes next instruction. Interrupt flag not cleared.. 1, PIE/ GIEL = 0 (default).",
    "TABLE 5-2: LONG WRITE EXECUTION, INTERRUPT ENABLE BITS AND INTERRUPT RESULTS\n1, Priority = 0 low. 1, Interrupt Enable = 1. 1, Interrupt Flag = 1. 1, Action = Terminates long write, executes next instruction. Interrupt flag not cleared.. 0 (default), PIE/ GIEL = 1. 0 (default), Priority = 0 low. 0 (default), Interrupt Enable = 1. 0 (default), Interrupt Flag = 1. 0 (default), Action = Terminates long write, branches to low priority interrupt vector. Interrupt flag can be cleared by ISR.. 1, PIE/ GIEL = 0 (default). 1, Priority = 1 high priority (default). 1, Interrupt Enable = 1. 1, Interrupt Flag = 1. 1, Action = Terminates long write, branches to high priority interrupt vector. Interrupt flag can be cleared by ISR.",
    "5.2.4 UNEXPECTED TERMINATION OF WRITE OPERATIONS\nIf a write is terminated by an unplanned event such as loss of power, an unexpected RESET, or an interrupt that  was  not  disabled,  the  memory  location  just  programmed  should  be  verified  and  reprogrammed  if needed.",
    "PIC18CXX2\nNOTES:",
    "6.1 Introduction\nAn 8 x 8 hardware multiplier is included in the ALU of the  PIC18CXX2  devices.  By  making  the  multiply  a hardware operation, it completes in a single instruction cycle. This is an unsigned multiply that gives a 16-bit result. The result is stored into the 16-bit product register  pair  (PRODH:PRODL).  The  multiplier  does  not affect any flags in the ALUSTA register.\nMaking the 8 x 8 multiplier execute in a single cycle gives the following advantages:\n\u00b7 Higher computational throughput\n\u00b7 Reduces code size requirements for multiply algorithms\nThe performance increase allows the device to be used in  applications  previously  reserved  for  Digital  Signal Processors.\nTable 6-1 shows a performance comparison between enhanced devices using the single cycle hardware multiply,  and  performing  the  same  function  without  the hardware multiply.",
    "TABLE 6-1: PERFORMANCE COMPARISON\n8 x 8 unsigned, Multiply Method = Without hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 13. 8 x 8 unsigned, Cycles (Max). = 69. 8 x 8 unsigned, Time.@40 MHz = 6.9 \uf06d s. 8 x 8 unsigned, Time.@10 MHz = 27.6 \uf06d s. 8 x 8 unsigned, Time.@4MHz = 69 \uf06d s. 8 x 8 unsigned, Multiply Method = Hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 1. 8 x 8 unsigned, Cycles (Max). = 1. 8 x 8 unsigned, Time.@40 MHz = 100 ns. 8 x 8 unsigned, Time.@10 MHz = 400 ns. 8 x 8 unsigned, Time.@4MHz = 1 \uf06d s. 8 x 8 signed, Multiply Method = Without hardware multiply. 8 x 8 signed, Program Memory (Words). = 33. 8 x 8 signed, Cycles (Max). = 91. 8 x 8 signed, Time.@40 MHz = 9.1 \uf06d s. 8 x 8 signed, Time.@10 MHz = 36.4 \uf06d s. 8 x 8",
    "TABLE 6-1: PERFORMANCE COMPARISON\nsigned, Time.@4MHz = 91 \uf06d s. 8 x 8 signed, Multiply Method = Hardware multiply. 8 x 8 signed, Program Memory (Words). = 6. 8 x 8 signed, Cycles (Max). = 6. 8 x 8 signed, Time.@40 MHz = 600 ns. 8 x 8 signed, Time.@10 MHz = 2.4 \uf06d s. 8 x 8 signed, Time.@4MHz = 6 \uf06d s. 16 x 16 unsigned, Multiply Method = Without hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 21. 16 x 16 unsigned, Cycles (Max). = 242. 16 x 16 unsigned, Time.@40 MHz = 24.2 \uf06d s. 16 x 16 unsigned, Time.@10 MHz = 96.8 \uf06d s. 16 x 16 unsigned, Time.@4MHz = 242 \uf06d s. 16 x 16 unsigned, Multiply Method = Hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 24. 16 x 16 unsigned, Cycles (Max). = 24. 16 x 16 unsigned, Time.@40 MHz = 2.4 \uf06d s. 16 x 16 unsigned,",
    "TABLE 6-1: PERFORMANCE COMPARISON\nTime.@10 MHz = 9.6 \uf06d s. 16 x 16 unsigned, Time.@4MHz = 24 \uf06d s. 16 x 16 signed, Multiply Method = Without hardware multiply. 16 x 16 signed, Program Memory (Words). = 52. 16 x 16 signed, Cycles (Max). = 254. 16 x 16 signed, Time.@40 MHz = 25.4 \uf06d s. 16 x 16 signed, Time.@10 MHz = 102.6 \uf06d s. 16 x 16 signed, Time.@4MHz = 254 \uf06d s. 16 x 16 signed, Multiply Method = Hardware multiply. 16 x 16 signed, Program Memory (Words). = 36. 16 x 16 signed, Cycles (Max). = 36. 16 x 16 signed, Time.@40 MHz = 3.6 \uf06d s. 16 x 16 signed, Time.@10 MHz = 14.4 \uf06d s. 16 x 16 signed, Time.@4MHz = 36 \uf06d s",
    "6.2 Operation\nExample 6-1  shows  the  sequence  to  do  an  8  x  8 unsigned  multiply.  Only  one  instruction  is  required when one argument of the multiply is already loaded in the WREG register.",
    "EXAMPLE 6-2: 8 x 8 SIGNED MULTIPLY ROUTINE\nExample 6-2 shows the sequence to do an 8 x 8 signed multiply. To account for the sign bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "EXAMPLE 6-1: 8 x 8 UNSIGNED MULTIPLY ROUTINE\nMOVF     ARG1, W     ;\nMULWF    ARG2        ; ARG1 * ARG2 ->\n;   PRODH:PRODL\nMOVF MULWF, 1 = ARG1, ARG2. MOVF MULWF, 2 = W. MOVF MULWF, 3 = ; ARG1 * ARG2 -> ; PRODH:PRODL. BTFSC SUBWF, 1 = ARG2, PRODH,. BTFSC SUBWF, 2 = SB F. BTFSC SUBWF, 3 = ; Test Sign Bit ; PRODH = PRODH. MOVF BTFSC SUBWF, 1 = ARG2, ARG1, PRODH,. MOVF BTFSC SUBWF, 2 = W SB F. MOVF BTFSC SUBWF, 3 = ; Test Sign Bit ; PRODH = PRODH ; - ARG2",
    "EXAMPLE 6-1: 8 x 8 UNSIGNED MULTIPLY ROUTINE\nExample 6-3  shows  the  sequence  to  do  a  16  x  16 unsigned  multiply.  Equation 6-1  shows  the  algorithm that is used. The 32-bit result is stored in four registers, RES3:RES0.\nEQUATION 6-1:\n16 x 16 UNSIGNED MULTIPLICATION ALGORITHM\nARG1H:ARG1L   ARG2H:ARG2L \uf0b7\nRES3:RES0\n=\n=\n(ARG1H   ARG2H   2 16 )+\n\uf0b7\n\uf0b7\n(ARG1H   ARG2L   2 8 )+ \uf0b7 \uf0b7\n(ARG1L   ARG2H   2 8 )+ \uf0b7 \uf0b7\n(ARG1L   ARG2L) \uf0b7",
    "EXAMPLE 6-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1L * ARG2L -> PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES1. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES0. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1H * ARG2H -> PRODH:PRODL.",
    "EXAMPLE 6-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVFF, 1 = PRODH,. MOVFF, 2 = RES3. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES2. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1L * ARG2H -> PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1 = RES1,. ADDWF, 2 = F. ADDWF, 3 = ;. ADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W.",
    "EXAMPLE 6-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF, 3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG,. CLRF, 2 = F. CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1H * ARG2L -> PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1 = RES1,.",
    "EXAMPLE 6-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nADDWF, 2 = F. ADDWF, 3 = ;. ADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG,. CLRF, 2 = F. CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = \nExample 6-4  shows  the  sequence  to  do  a  16  x  16 signed  multiply.  Equation 6-2  shows  the  algorithm used.  The  32-bit  result  is  stored  in  four  registers, RES3:RES0. To account for the sign bits of the arguments, each argument pairs' Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "EQUATION 6-2:\n16 x 16 SIGNED MULTIPLICATION ALGORITHM",
    "RES3:RES0\n- = ARG1H:ARG1L   ARG2H:ARG2L \uf0b7\n= (ARG1H   ARG2H   2 16 )+ \uf0b7 \uf0b7\n(ARG1H   ARG2L   2 8 )+\n\uf0b7\n\uf0b7\n(ARG1L   ARG2H   2 8 )+\n\uf0b7\n\uf0b7\n(ARG1L   ARG2L)+\n\uf0b7\n(-1   ARG2H<7>   ARG1H:ARG1L   2 16 )+\n\uf0b7\n\uf0b7\n\uf0b7\n(-1   ARG1H<7>   ARG2H:ARG2L   2 16 )\n\uf0b7\n\uf0b7\n\uf0b7\nEXAMPLE 6-4:\n16 x 16 SIGNED MULTIPLY ROUTINE",
    "RES3:RES0\nMULWF, ARG1L, = ARG2L. MULWF, W = . MULWF,  = ; ;. MULWF,  = ARG1L * ARG2L -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES1. MOVFF,  = ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES0. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1H * ARG2H -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES3. MOVFF,",
    "RES3:RES0\n= ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES2. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1L,. MOVF, W = W. MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ; ;. MULWF,  = ARG1L * ARG2H -> PRODH:PRODL. MOVF, ARG1L, = PRODL,. MOVF, W = W. MOVF,  = ;. MOVF,  = . ADDWF, ARG1L, = RES1,. ADDWF, W = F. ADDWF,  = ;. ADDWF,  = Add cross. MOVF, ARG1L, = PRODH,. MOVF, W = W. MOVF,  = ;. MOVF,",
    "RES3:RES0\n= products. ADDWFC, ARG1L, = RES2,. ADDWFC, W = F. ADDWFC,  = ;. ADDWFC,  = . CLRF, ARG1L, = WREG,. CLRF, W = F. CLRF,  = ;. CLRF,  = . ADDWFC, ARG1L, = RES3,. ADDWFC, W = F. ADDWFC,  = ;. ADDWFC,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = ;. MOVF,  = . MULWF, ARG1L, = ARG2L. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1H * ARG2L -> PRODH:PRODL. MOVF ADDWF, ARG1L, = PRODL,. MOVF ADDWF, W = W. MOVF ADDWF,  = ;. MOVF ADDWF,",
    "RES3:RES0\n= . MOVF, ARG1L, = RES1, PRODH,. MOVF, W = F. MOVF,  = ;. MOVF,  = Add cross products. ADDWFC, ARG1L, = . ADDWFC, W = W. ADDWFC,  = ;. ADDWFC,  = . , ARG1L, = RES2,. , W = F. ,  = ;. ,  = . CLRF ADDWFC, ARG1L, = WREG, RES3,. CLRF ADDWFC, W = F. CLRF ADDWFC,  = ;. CLRF ADDWFC,  = . , ARG1L, = . , W = F. ,  = ;. ,  = . BTFSS, ARG1L, = ARG2H,. BTFSS, W = 7. BTFSS,  = ;. BTFSS,  = ARG2H:ARG2L neg?. BRA, ARG1L, = SIGN_ARG1. BRA, W = . BRA,  = ;. BRA,",
    "RES3:RES0\n= no, check ARG1. MOVF SUBWF, ARG1L, = ARG1L, RES2. MOVF SUBWF, W = W. MOVF SUBWF,  = ;. MOVF SUBWF,  = . , ARG1L, = . , W = . ,  = ;. ,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWFB, ARG1L, = RES3. SUBWFB, W = . SUBWFB,  = . SUBWFB,  = . BTFSS BRA, ARG1L, = ARG1H, RES2. BTFSS BRA, W = 7 W. BTFSS BRA,  = ; ;. BTFSS BRA,  = ARG1H:ARG1L no, done. MOVF SUBWF, ARG1L, = ARG2L,. MOVF SUBWF, W = CONT_CODE. MOVF SUBWF,",
    "RES3:RES0\n= ; ;. MOVF SUBWF,  = . , ARG1L, = ARG2H,. , W = W. ,  = ;. ,  = . MOVF SUBWFB, ARG1L, = . MOVF SUBWFB, W = . MOVF SUBWFB,  = . MOVF SUBWFB,  = . ;, ARG1L, = RES3. ;, W = . ;,  = . ;,  = . CONT_CODE :, ARG1L, = . CONT_CODE :, W = . CONT_CODE :,  = . CONT_CODE :,  = ",
    "7.0 INTERRUPTS\nThe PIC18CXX2 devices have multiple interrupt sources  and  an  interrupt  priority  feature  that  allows each  interrupt  source  to  be  assigned  a  high  priority level, or a low priority level. The high priority interrupt vector is at 000008h and the low priority interrupt vector is at 000018h. High priority interrupt events will override any low priority interrupts that may be in progress.\nThere are ten registers which are used to control interrupt operation. These registers are:\n\u00b7 RCON\n\u00b7 INTCON\n\u00b7 INTCON2\n\u00b7 INTCON3\n\u00b7 PIR1, PIR2\n\u00b7 PIE1, PIE2\n\u00b7 IPR1, IPR2\nIt is recommended that the Microchip header files supplied  with  MPLAB \u00ae   IDE  be  used  for  the  symbolic  bit names in these registers. This allows the assembler/ compiler to automatically take care of the placement of these bits within the specified register.\nEach interrupt source has three bits to control its operation. The functions of these bits are:\n\u00b7 Flag bit to indicate that an interrupt event occurred\n\u00b7 Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\n\u00b7 Priority bit to select high priority or low priority",
    "7.0 INTERRUPTS\nThe interrupt priority feature is enabled by setting the IPEN bit (RCON<7>). When  interrupt priority is enabled, there are two bits which enable interrupts globally.  Setting  the  GIEH  bit  (INTCON<7>)  enables  all interrupts that have the priority bit set. Setting the GIEL bit  (INTCON<6>) enables all interrupts that have the priority bit cleared. When the interrupt flag, enable bit and appropriate global interrupt enable bit are set, the interrupt will vector immediately to address 000008h or 000018h,  depending  on  the  priority  level.  Individual interrupts can be disabled through their corresponding enable bits.\nWhen the IPEN bit is cleared (default state), the interrupt priority feature is disabled and interrupts are compatible  with PIC \u00ae mid-range devices. In Compatibility mode, the interrupt priority bits for each source have no effect. INTCON<6> is the PEIE bit, which enables/disables all peripheral interrupt sources. INTCON<7> is the GIE bit, which enables/disables all interrupt sources. All interrupts branch to address 000008h in Compatibility mode.",
    "7.0 INTERRUPTS\nWhen an interrupt is responded to, the Global Interrupt Enable bit is cleared to disable further interrupts. If the IPEN bit is cleared, this is the GIE bit. If interrupt priority levels are used, this will be either the GIEH, or GIEL bit. High priority interrupt sources can interrupt a low priority interrupt.\nThe return address is pushed onto the stack and the PC  is loaded with the interrupt vector address (000008h or 000018h). Once in the Interrupt Service Routine,  the  source(s)  of  the  interrupt  can  be  determined by polling the  interrupt  flag  bits.  The  interrupt flag bits must be cleared in software before re-enabling interrupts to avoid recursive interrupts.\nThe 'return  from  interrupt'  instruction, RETFIE ,  exits the interrupt routine and sets the GIE bit (GIEH or GIEL if priority levels are used), which re-enables interrupts.",
    "7.0 INTERRUPTS\nFor external interrupt events, such as the INT pins or the PORTB input change interrupt, the interrupt latency will be  three  to  four  instruction  cycles.  The  exact latency is the same for one or two-cycle instructions. Individual interrupt flag bits are set, regardless of the status of their corresponding enable bit or the GIE bit.",
    "7.1 INTCON Registers\nThe INTCON Registers are readable and writable registers, which contains various enable, priority, and flag bits.",
    "REGISTER 7-1: INTCON REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-x. GIE/GIEH, 1 = PEIE/GIEL. GIE/GIEH, 2 = TMR0IE. GIE/GIEH, 3 = INT0IE. GIE/GIEH, 4 = RBIE. GIE/GIEH, 5 = TMR0IF. GIE/GIEH, 6 = INT0IF. GIE/GIEH, 7 = RBIF\nbit 7\nbit 0",
    "bit 7 GIE/GIEH: Global Interrupt Enable bit\nWhen IPEN = 0:\n1 = Enables all unmasked interrupts\n0 = Disables all interrupts",
    "When IPEN = 1:\n1 = Enables all high priority interrupts\n0 = Disables all high priority interrupts",
    "When IPEN = 0:\n1 = Enables all unmasked peripheral interrupts\n0 = Disables all peripheral interrupts",
    "When IPEN = 1:\n1 = Enables all low priority peripheral interrupts\n0 = Disables all low priority peripheral interrupts\nTMR0IE:\nTMR0 Overflow Interrupt Enable bit\n1 = Enables the TMR0 overflow interrupt\n0 = Disables the TMR0 overflow interrupt",
    "bit 4 INT0IE: INT0 External Interrupt Enable bit\n1 = Enables the INT0 external interrupt\n0 = Disables the INT0 external interrupt\nRBIE: RB Port Change Interrupt Enable bit\n1 = Enables the RB port change interrupt\n0 = Disables the RB port change interrupt\nTMR0IF: TMR0 Overflow Interrupt Flag bit\n1 = TMR0 register has overflowed (must be cleared in software)\n0 = TMR0 register did not overflow\nbit 1 INT0IF: INT0 External Interrupt Flag bit\n1 = The INT0 external interrupt occurred (must be cleared in software)\n0 = The INT0 external interrupt did not occur",
    "bit 0 RBIF:\nRB Port Change Interrupt Flag bit\n1 = At least one of the RB7:RB4 pins changed state (must be cleared in software)\n0 = None of the RB7:RB4 pins have changed state",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.\nbit 5",
    "REGISTER 7-2: INTCON2 REGISTER\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nU-0\nR/W-1\nU-0\nR/W-1\nRBPU\nINTEDG0\nINTEDG1\nINTEDG2\n-\nTMR0IP\n-\nRBIP\nbit 7\nbit 0\nbit 7 RBPU : PORTB Pull-up Enable bit\n1 = All PORTB pull-ups are disabled\n0 = PORTB pull-ups are enabled by individual port latch values\nbit 6 INTEDG0 :External Interrupt0 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 5 INTEDG1 : External Interrupt1 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge",
    "bit 4 INTEDG2 : External Interrupt2 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 3 Unimplemented: Read as '0'\nbit 2 TMR0IP : TMR0 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1 Unimplemented: Read as '0'\nbit 0 RBIP : RB Port Change Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "REGISTER 7-3: INTCON3 REGISTER\nR/W-1, 1 = R/W-1. R/W-1, 2 = U-0. R/W-1, 3 = R/W-0. R/W-1, 4 = R/W-0. R/W-1, 5 = U-0. R/W-1, 6 = R/W-0. R/W-1, 7 = R/W-0. INT2IP, 1 = INT1IP. INT2IP, 2 = -. INT2IP, 3 = INT2IE. INT2IP, 4 = INT1IE. INT2IP, 5 = -. INT2IP, 6 = INT2IF. INT2IP, 7 = INT1IF\nbit 7\nbit 0\nbit 7 INT2IP: INT2 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nINT1IP: INT1 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5 Unimplemented: Read as '0'\nbit 4 INT2IE: INT2 External Interrupt Enable bit\n1 = Enables the INT2 external interrupt\n0 = Disables the INT2 external interrupt",
    "REGISTER 7-3: INTCON3 REGISTER\nINT1IE: INT1 External Interrupt Enable bit\n1 = Enables the INT1 external interrupt\n0 = Disables the INT1 external interrupt",
    "bit 2 Unimplemented: Read as '0'\nbit 1 INT2IF: INT2 External Interrupt Flag bit\n1 = The INT2 external interrupt occurred (must be cleared in software)\n0 = The INT2 external interrupt did not occur\nbit 0 INT1IF: INT1 External Interrupt Flag bit\n1 = The INT1 external interrupt occurred (must be cleared in software)\n0 = The INT1 external interrupt did not occur",
    "Legend:\nR = Readable bit\n- - n = Value at POR reset\nW = Writable bit\nU = Unimplemented bit, read as '0'\n'1' = Bit is set\n- '0' = Bit is cleared\nx = Bit is unknown\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.\nbit 6\nbit 3",
    "7.2 PIR Registers\nThe PIR registers contain the individual flag bits for the peripheral interrupts. Due to the number of peripheral interrupt  sources,  there  are  two  Peripheral  Interrupt Flag Registers (PIR1, PIR2).\nNote 1: Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit, GIE (INTCON<7>).\n2: User software should ensure the appropriate interrupt flag bits are cleared prior to enabling an interrupt, and after servicing that interrupt.",
    "REGISTER 7-4: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1 (PIR1)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIF, 1 = ADIF. PSPIF, 2 = RCIF. PSPIF, 3 = TXIF. PSPIF, 4 = SSPIF. PSPIF, 5 = CCP1IF. PSPIF, 6 = TMR2IF. PSPIF, 7 = TMR1IF\nbit 7\nbit 0\nbit 7 PSPIF: Parallel Slave Port Read/Write Interrupt Flag bit\n1 = A read or a write operation has taken place (must be cleared in software)\n0 = No read or write has occurred",
    "bit 6 ADIF : A/D Converter Interrupt Flag bit\n1 = An A/D conversion completed (must be cleared in software)\n0 = The A/D conversion is not complete",
    "bit 5 RCIF : USART Receive Interrupt Flag bit\n1 = The USART receive buffer, RCREG, is full (cleared when RCREG is read)\n0 = The USART receive buffer is empty\nbit 4 TXIF : USART Transmit Interrupt Flag bit\n1 = The USART transmit buffer, TXREG, is empty (cleared when TXREG is written)\n0 = The USART transmit buffer is full\nbit 3 SSPIF : Master Synchronous Serial Port Interrupt Flag bit\n1 = The transmission/reception is complete (must be cleared in software)\n0 = Waiting to transmit/receive",
    "bit 2 CCP1IF : CCP1 Interrupt Flag bit\nCapture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n0 = No TMR1 register capture occurred\nCompare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n0 = No TMR1 register compare match occurred\nPWM mode:\nUnused in this mode",
    "bit 1 TMR2IF: TMR2 to PR2 Match Interrupt Flag bit\n1 = TMR2 to PR2 match occurred (must be cleared in software)\n0 = No TMR2 to PR2 match occurred",
    "bit 0 TMR1IF: TMR1 Overflow Interrupt Flag bit\n1 = TMR1 register overflowed (must be cleared in software)\n0 =  MR1 register did not overflow\nLegend:\nR = Readable bit\n- n = Value at POR reset\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 2 (PIR2)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = BCLIF. -, 5 = LVDIF. -, 6 = TMR3IF. -, 7 = CCP2IF\nbit 7\nbit 0",
    "bit 3\nBCLIF : Bus Collision Interrupt Flag bit\n- 1 = A bus collision occurred (must be cleared in software)\n0 = No bus collision occurred",
    "bit 2 LVDIF : Low Voltage Detect Interrupt Flag bit\n1 = A low voltage condition occurred (must be cleared in software)\n0 = The device voltage is above the Low Voltage Detect trip point\nTMR3IF : TMR3 Overflow Interrupt Flag bit\n1 = TMR3 register overflowed (must be cleared in software)\n0 = TMR3 register did not overflow",
    "bit 0 CCP2IF : CCPx Interrupt Flag bit\nCapture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n- 0 = No TMR1 register capture occurred",
    "Compare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n- 0 = No TMR1 register compare match occurred\nPWM mode:\nUnused in this mode",
    "Legend:\nR = Readable bit\n- n = Value at POR reset",
    "bit 1\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "7.3 PIE Registers\nThe PIE registers contain the individual enable bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are two Peripheral Interrupt Enable Registers (PIE1, PIE2). When IPEN = 0, the PEIE bit must be set to enable any of these peripheral interrupts.",
    "REGISTER 7-6: PERIPHERAL INTERRUPT ENABLE REGISTER 1 (PIE1)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIE, 1 = ADIE. PSPIE, 2 = RCIE. PSPIE, 3 = TXIE. PSPIE, 4 = SSPIE. PSPIE, 5 = CCP1IE. PSPIE, 6 = TMR2IE. PSPIE, 7 = TMR1IE\nbit 7\nbit 0\nbit 7 PSPIE: Parallel Slave Port Read/Write Interrupt Enable bit\n1 = Enables the PSP read/write interrupt\n0 = Disables the PSP read/write interrupt\nADIE : A/D Converter Interrupt Enable bit\n1 = Enables the A/D interrupt\n0 = Disables the A/D interrupt\nRCIE : USART Receive Interrupt Enable bit",
    "REGISTER 7-6: PERIPHERAL INTERRUPT ENABLE REGISTER 1 (PIE1)\n- 1 = Enables the USART receive interrupt\n0 = Disables the USART receive interrupt\nTXIE : USART Transmit Interrupt Enable bit\n1 = Enables the USART transmit interrupt\n0 = Disables the USART transmit interrupt\nSSPIE : Master Synchronous Serial Port Interrupt Enable bit\n- 1 = Enables the MSSP interrupt\n0 = Disables the MSSP interrupt\nCCP1IE : CCP1 Interrupt Enable bit\n- 1 = Enables the CCP1 interrupt\n0 = Disables the CCP1 interrupt\nbit 1 TMR2IE : TMR2 to PR2 Match Interrupt Enable bit\n1 = Enables the TMR2 to PR2 match interrupt\n0 = Disables the TMR2 to PR2 match interrupt\nTMR1IE : TMR1 Overflow Interrupt Enable bit\n1 = Enables the TMR1 overflow interrupt\n0 = Disables the TMR1 overflow interrupt",
    "Legend:\nR = Readable bit\n- n = Value at POR\nW = Writable bit\n'1' = Bit is set",
    "bit 0\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "PERIPHERAL INTERRUPT ENABLE REGISTER 2 (PIE2)\nU-0\nU-0\nU-0\nU-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\n-\n-\n-\n-\nBCLIE\nLVDIE\nTMR3IE\nCCP2IE\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as '0'\nbit 3\nBCLIE : Bus Collision Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 2\nLVDIE : Low Voltage Detect Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 1 TMR3IE : TMR3 Overflow Interrupt Enable bit\n1 = Enables the TMR3 overflow interrupt\n0 = Disables the TMR3 overflow interrupt",
    "bit 0\nCCP2IE : CCP2 Interrupt Enable bit\n1 = Enables the CCP2 interrupt\n0 = Disables the CCP2 interrupt",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "7.4 IPR Registers\nThe IPR registers contain the individual priority bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are two Peripheral Interrupt Priority Registers (IPR1, IPR2). The operation of the  priority  bits requires  that  the  Interrupt  Priority Enable (IPEN) bit be set.",
    "REGISTER 7-8: PERIPHERAL INTERRUPT PRIORITY REGISTER 1 (IPR1)\n, R/W-1 = PSPIP. , R/W-1 = ADIP. , R/W-1 = RCIP. , R/W-1 = TXIP. , R/W-1 = SSPIP. , R/W-1 = CCP1IP. , R/W-1 = TMR2IP. , R/W-1 = TMR1IP. , R/W-1 = bit 7. , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = bit 0. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority",
    "REGISTER 7-8: PERIPHERAL INTERRUPT PRIORITY REGISTER 1 (IPR1)\nbit 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt",
    "REGISTER 7-8: PERIPHERAL INTERRUPT PRIORITY REGISTER 1 (IPR1)\nPriority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5,",
    "REGISTER 7-8: PERIPHERAL INTERRUPT PRIORITY REGISTER 1 (IPR1)\nR/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4,",
    "REGISTER 7-8: PERIPHERAL INTERRUPT PRIORITY REGISTER 1 (IPR1)\nR/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP",
    "REGISTER 7-8: PERIPHERAL INTERRUPT PRIORITY REGISTER 1 (IPR1)\n: Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority.",
    "REGISTER 7-8: PERIPHERAL INTERRUPT PRIORITY REGISTER 1 (IPR1)\nbit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority. , R/W-1 = 0 = Low priority TMR2IP : TMR2 to PR2 Match Interrupt Priority bit. , R/W-1 = 0 = Low priority TMR2IP : TMR2 to PR2 Match Interrupt Priority bit. , R/W-1 = 0 = Low priority TMR2IP : TMR2 to PR2 Match Interrupt Priority bit. , R/W-1 = 0 = Low priority TMR2IP : TMR2 to PR2 Match Interrupt Priority bit. , R/W-1 = 0 = Low priority TMR2IP : TMR2 to PR2 Match Interrupt Priority bit. , R/W-1 = 0 = Low priority TMR2IP : TMR2",
    "REGISTER 7-8: PERIPHERAL INTERRUPT PRIORITY REGISTER 1 (IPR1)\nto PR2 Match Interrupt Priority bit. , R/W-1 = 0 = Low priority TMR2IP : TMR2 to PR2 Match Interrupt Priority bit. , R/W-1 = 0 = Low priority TMR2IP : TMR2 to PR2 Match Interrupt Priority bit. bit 1, R/W-1 = 1 = High priority 0 = Low priority. bit 1, R/W-1 = 1 = High priority 0 = Low priority. bit 1, R/W-1 = 1 = High priority 0 = Low priority. bit 1, R/W-1 = 1 = High priority 0 = Low priority. bit 1, R/W-1 = 1 = High priority 0 = Low priority. bit 1, R/W-1 = 1 = High priority 0 = Low priority. bit 1, R/W-1 = 1 = High priority 0 = Low priority. bit 1, R/W-1 = 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority = Low",
    "REGISTER 7-8: PERIPHERAL INTERRUPT PRIORITY REGISTER 1 (IPR1)\npriority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority = Low priority. , R/W-1 = Legend: R = Readable bit -",
    "REGISTER 7-8: PERIPHERAL INTERRUPT PRIORITY REGISTER 1 (IPR1)\nn = Value at POR. , R/W-1 = Legend: R = Readable bit - n = Value at POR. , R/W-1 = W=Writable bit. , R/W-1 = W=Writable bit. , R/W-1 = U = Unimplemented bit, read as '0'. , R/W-1 = U = Unimplemented bit, read as '0'. , R/W-1 = U = Unimplemented bit, read as '0'. , R/W-1 = U = Unimplemented bit, read as '0'",
    "PERIPHERAL INTERRUPT PRIORITY REGISTER 2 (IPR2)\nU-0\nU-0\nU-0\nU-0\nR/W-1\nR/W-1\nR/W-1\nR/W-1\n-\n-\n-\n-\nBCLIP\nLVDIP\nTMR3IP\nCCP2IP\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as '0'\nbit 3\nBCLIP : Bus Collision Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nLVDIP : Low Voltage Detect Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 1\nTMR3IP : TMR3 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nCCP2IP : CCP2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "7.5 RCON Register\nThe RCON register contains the bit which is used to enable prioritized interrupts (IPEN).",
    "REGISTER 7-10:\nRCON REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R-1. R/W-0, 5 = R-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = LWRT. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0",
    "bit 7\nIPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (16CXXX compatibility mode)",
    "bit 6 LWRT:\nLong Write Enable bit\nFor details of bit operation, see Register 4-3\nbit 5 Unimplemented: Read as '0'\nbit 4\nRI:\nRESET Instruction Flag bit\nFor details of bit operation, see Register 4-3\nbit 3\nTO:\nWatchdog Time-out Flag bit\nFor details of bit operation, see Register 4-3\nbit 2\nPD: Power-down Detection Flag bit\nFor details of bit operation, see Register 4-3\nbit 1 POR:\nPower-on Reset Status bit\nFor details of bit operation, see Register 4-3\nbit 0 BOR: Brown-out Reset Status bit\nFor details of bit operation, see Register 4-3\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "7.6 INT0 Interrupt\nExternal  interrupts  on  the  RB0/INT0,  RB1/INT1  and RB2/INT2 pins are edge triggered: either rising, if the corresponding INTEDGx bit is set in the INTCON2 register, or falling, if the INTEDGx bit is clear. When a valid edge appears on the RBx/INTx pin, the corresponding flag bit INTxF is set. This interrupt can be disabled by clearing the corresponding enable bit INTxE. Flag bit INTxF must be cleared in software in the Interrupt Service Routine before re-enabling the interrupt. All external interrupts (INT0, INT1 and INT2) can wake-up the processor  from  SLEEP,  if  bit  INTxE  was  set  prior  to going into SLEEP. If the global interrupt enable bit GIE set,  the  processor  will  branch  to  the  interrupt  vector following wake-up.\nInterrupt priority for INT1 and INT2 is determined by the value  contained  in  the  interrupt  priority  bits,  INT1IP (INTCON3<6>) and INT2IP (INTCON3<7>). There is no priority bit associated with INT0. It is always a high priority interrupt source.",
    "7.7 TMR0 Interrupt\nIn 8-bit mode (which is the default), an overflow (FFh \uf0ae 00h) in the TMR0 register will set flag bit TMR0IF. In 16-bit  mode,  an  overflow  (FFFFh \uf0ae\uf020 0000h)  in  the TMR0H:TMR0L registers will set flag bit TMR0IF. The interrupt  can  be  enabled/disabled  by  setting/clearing enable  bit  T0IE  (INTCON<5>).  Interrupt  priority  for Timer0  is  determined  by  the  value  contained  in  the interrupt priority bit TMR0IP (INTCON2<2>). See Section 8.0 for further details on the Timer0 module.",
    "7.8 PORTB Interrupt-on-Change\nAn input change  on  PORTB<7:4> sets  flag bit RBIF (INTCON<0>). The interrupt can be enabled/disabled by  setting/clearing  enable  bit,  RBIE  (INTCON<3>). Interrupt  priority  for  PORTB  Interrupt-on-change  is determined by the value contained in the interrupt priority bit, RBIP (INTCON2<0>).",
    "7.9 Context Saving During Interrupts\nDuring an interrupt, the return PC value is saved on the stack. Additionally, the WREG, STATUS and BSR registers are saved on the fast return stack. If a fast return from  interrupt  is  not  used  (see  Section 4.3),  the  user may need to save the WREG, STATUS and BSR registers  in  software.  Depending  on  the  user's  application, other registers may also need to be saved. Example 7-1 saves and restores the WREG, STATUS and BSR registers during an Interrupt Service Routine.",
    "EXAMPLE 7-1: SAVING STATUS, WREG AND BSR REGISTERS IN RAM\nMOVWF MOVFF MOVFF ; ; USER ; MOVFF, 1 = W_TEMP STATUS, STATUS_TEMP BSR, BSR_TEMP ISR CODE. MOVWF MOVFF MOVFF ; ; USER ; MOVFF, 2 = ; W_TEMP is in virtual bank ; STATUS_TEMP located anywhere ; BSR located anywhere",
    "PIC18CXX2\nNOTES:",
    "8.0 I/O PORTS\nDepending on the device selected, there are either five ports,  or  three  ports  available.  Some  pins  of  the  I/O ports  are  multiplexed  with  an  alternate  function  from the peripheral features on the device. In general, when a peripheral is enabled, that pin may not be used as a general purpose I/O pin.\nEach port has three registers for its operation. These registers are:\n\u00b7 TRIS register (data direction register)\n\u00b7 PORT register (reads the levels on the pins of the device)\n\u00b7 LAT register (output latch)\nThe data latch (LAT register) is useful for read-modifywrite  operations  on  the  value  that  the  I/O  pins  are driving.",
    "8.1 PORTA, TRISA and LATA Registers\nPORTA is a 6-bit wide, bi-directional port. The corresponding  data  direction  register  is  TRISA.  Setting  a TRISA bit (= 1) will make the corresponding PORTA pin an input (i.e., put the corresponding output driver in a Hi-Impedance mode). Clearing a TRISA bit (= 0) will make the corresponding PORTA pin an output (i.e., put the contents of the output latch on the selected pin).\nNote: On a Power-on Reset, these pins are configured as digital inputs.\nReading the  PORTA register reads the  status  of  the pins, whereas writing to it will write to the port latch.\nThe  Data  Latch register (LATA)  is also memory mapped.  Read-modify-write  operations  on  the  LATA register reads and writes the latched output value for PORTA.\nThe  RA4  pin  is  multiplexed  with  the  Timer0  module clock input to become the RA4/T0CKI pin. The RA4/ T0CKI pin is a Schmitt Trigger input and an open drain output. All other RA port pins have TTL input levels and full CMOS output drivers.",
    "8.1 PORTA, TRISA and LATA Registers\nThe  other  PORTA  pins  are  multiplexed  with  analog inputs  and  the  analog  VREF+  and  VREF-  inputs.  The operation of each pin is selected by clearing/setting the control  bits  in  the  ADCON1  register  (A/D  Control Register1).",
    "Note:\nOn a Power-on Reset, these pins are configured as analog inputs and read as '0'.\nThe  TRISA  register  controls  the  direction  of  the  RA pins, even when they are being used as analog inputs. The user must ensure the bits in the TRISA register are maintained set when using them as analog inputs.",
    "EXAMPLE 8-1:\nINITIALIZING PORTA\nCLRF PORTA, 1 = ; Initialize PORTA by ; clearing output ; data latches. CLRF LATA, 1 = ; Alternate method ; to clear output ; data latches. MOVLW 0x07 MOVWF ADCON1 MOVLW 0xCF, 1 = ; Configure A/D ; for digital inputs ; Value used to ; initialize data ; direction. MOVWF TRISA, 1 = ; Set RA<3:0> as inputs ; RA<5:4> as outputs",
    "FIGURE 8-1: BLOCK DIAGRAM OF RA3:RA0 AND RA5 PINS\nNote 1: I/O pins have protection diodes to VDD and VSS.",
    "TABLE 8-1: PORTA FUNCTIONS\nRA0/AN0, Bit# = bit0. RA0/AN0, Buffer = TTL. RA0/AN0, Function = Input/output or analog input.. RA1/AN1, Bit# = bit1. RA1/AN1, Buffer = TTL. RA1/AN1, Function = Input/output or analog input.. RA2/AN2/VREF-, Bit# = bit2. RA2/AN2/VREF-, Buffer = TTL. RA2/AN2/VREF-, Function = Input/output or analog input or VREF-.. RA3/AN3/VREF+, Bit# = bit3. RA3/AN3/VREF+, Buffer = TTL. RA3/AN3/VREF+, Function = Input/output or analog input or VREF+.. RA4/T0CKI, Bit# = bit4. RA4/T0CKI, Buffer = ST. RA4/T0CKI, Function = Input/output or external clock input for Timer0. Output is open drain type..",
    "TABLE 8-1: PORTA FUNCTIONS\nRA5/SS/AN4/LVDIN, Bit# = bit5. RA5/SS/AN4/LVDIN, Buffer = TTL. RA5/SS/AN4/LVDIN, Function = Input/output or slave select input for synchronous serial port or analog input, or low voltage detect input.. OSC2/CLKO/RA6, Bit# = bit6. OSC2/CLKO/RA6, Buffer = TTL. OSC2/CLKO/RA6, Function = OSC2 or clock output or I/O pin.\nLegend: TTL = TTL input, ST = Schmitt Trigger input",
    "TABLE 8-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nPORTA, Bit 7 = -. PORTA, Bit 6 = RA6. PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = --0x 0000. PORTA, Valueonall other RESETS = --0u 0000. LATA, Bit 7 = -. LATA, Bit 6 = Latch A Data Output Register. LATA, Bit 5 = Latch A Data Output Register. LATA, Bit 4 = Latch A Data Output Register. LATA, Bit 3 = Latch A Data Output Register. LATA, Bit 2 = Latch A Data Output Register. LATA, Bit 1 = Latch A Data Output Register. LATA, Bit 0 = . LATA, Value on POR, BOR = --xx xxxx. LATA, Valueonall other RESETS = --uu uuuu. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data",
    "TABLE 8-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nDirection Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = . TRISA, Value on POR, BOR = --11 1111. TRISA, Valueonall other RESETS = --11 1111. ADCON1, Bit 7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = --0- 0000. ADCON1, Valueonall other RESETS = --0- 0000",
    "TABLE 8-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nLegend: x = unknown, u = unchanged, - = unimplemented locations read as '0'.\nShaded cells are not used by PORTA.",
    "8.2 PORTB, TRISB and LATB Registers\nPORTB is an 8-bit wide, bi-directional port. The corresponding  data  direction  register  is  TRISB.  Setting  a TRISB bit (= 1) will make the corresponding PORTB pin an input (i.e., put the corresponding output driver in a Hi-Impedance mode). Clearing a TRISB bit (= 0) will make the corresponding PORTB pin an output (i.e., put the contents of the output latch on the selected pin).\nNote: On a Power-on Reset, these pins are configured as digital inputs.\nThe  Data  Latch  register (LATB)  is also memory mapped.  Read-modify-write  operations  on  the  LATB register reads and writes the latched output value for PORTB.",
    "EXAMPLE 8-2: INITIALIZING PORTB\nCLRF, 1 = PORTB ; Initialize. CLRF, 1 = LATB ; Alternate method ; to clear output ; data latches. MOVLW 0xCF, 1 = ; Value used to ; initialize data ; direction. MOVWF TRISB, 1 = ; Set RB<3:0> as inputs ; RB<5:4> as outputs ; RB<7:6> as inputs\nEach of the PORTB pins has a weak internal pull-up. A single control bit can turn on all the pull-ups. This is performed  by  clearing  bit  RBPU  (INTCON2<7>).  The weak pull-up is automatically turned off when the port pin  is  configured  as  an  output.  The  pull-ups  are  disabled on a Power-on Reset.",
    "EXAMPLE 8-2: INITIALIZING PORTB\nFour of the PORTB pins, RB7:RB4, have an interrupton-change feature. Only pins configured as inputs can cause  this  interrupt  to  occur  (i.e.,  any  RB7:RB4  pin configured as an output is excluded from the interrupton-change comparison). The input pins (of RB7:RB4) are  compared  with  the  old  value  latched  on  the  last read of PORTB. The 'mismatch' outputs of RB7:RB4 are OR'ed together to generate the RB Port Change Interrupt with flag bit RBIF (INTCON<0>).\nThis interrupt can wake the device from SLEEP. The user,  in  the  Interrupt  Service  Routine,  can  clear  the interrupt in the following manner:\na) Any  read  or  write  of  PORTB  (except  with  the MOVFF instruction). This will end the mismatch condition.\nb) Clear flag bit RBIF.\nA mismatch condition will continue to set flag bit RBIF. Reading PORTB will end the mismatch condition and allow flag bit RBIF to be cleared.",
    "EXAMPLE 8-2: INITIALIZING PORTB\nThe interrupt-on-change  feature  is  recommended  for wake-up on key depression operation and operations where PORTB is only used for the interrupt-on-change feature. Polling of PORTB is not recommended while using the interrupt-on-change feature.\nRB3  can  be  configured by the configuration bit CCP2MX as the alternate peripheral pin for the CCP2 module (CCP2MX = '0').",
    "FIGURE 8-4: BLOCK DIAGRAM OF RB7:RB4 PINS\nNote 1: I/O pins have diode protection to VDD and VSS.\n- 2: To  enable  weak  pull-ups,  set  the  appropriate  TRIS bit(s) and clear the RBPU bit (INTCON2<7>).",
    "TABLE 8-3: PORTB FUNCTIONS\nRB0/INT0, Bit# = bit0. RB0/INT0, Buffer = TTL/ST (1). RB0/INT0, Function = Input/output pin or external interrupt input1. Internal software programmable weak pull-up.. RB1/INT1, Bit# = bit1. RB1/INT1, Buffer = TTL/ST (1). RB1/INT1, Function = Input/output pin or external interrupt input2. Internal software programmable weak pull-up.. RB2/INT2, Bit# = bit2. RB2/INT2, Buffer = TTL/ST (1). RB2/INT2, Function = Input/output pin or external interrupt input3. Internal software programmable weak pull-up.. RB3/CCP2 (3), Bit# = bit3. RB3/CCP2 (3), Buffer = TTL/ST (4). RB3/CCP2 (3), Function = Input/output pin. Capture2 input/Compare2 output/PWM output when CCP2MX configuration bit is enabled. Internal software programmable weak",
    "TABLE 8-3: PORTB FUNCTIONS\npull-up.. RB4, Bit# = bit4. RB4, Buffer = TTL. RB4, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up.. RB5, Bit# = bit5. RB5, Buffer = TTL. RB5, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up.. RB6, Bit# = bit6. RB6, Buffer = TTL/ST (2). RB6, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Serial programming clock.. RB7, Bit# = bit7. RB7, Buffer = TTL/ST (2). RB7, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Serial programming data.\nLegend:  TTL = TTL input, ST = Schmitt Trigger input",
    "TABLE 8-3: PORTB FUNCTIONS\nNote 1: This buffer is a Schmitt Trigger input when configured as the external interrupt.\n2: This buffer is a Schmitt Trigger input when used in Serial Programming mode.\n3: A device configuration bit selects which I/O pin the CCP2 pin is multiplexed on.\n4: This buffer is a Schmitt Trigger input when configured as the CCP2 input.",
    "TABLE 8-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nPORTB, Bit 7 = RB7. PORTB, Bit 6 = RB6. PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 = RB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTB, Value on POR, BOR = xxxx xxxx. PORTB, Value on all other RESETS = uuuu uuuu. LATB, Bit 7 = LATB Data Output Register. LATB, Bit 6 = LATB Data Output Register. LATB, Bit 5 = LATB Data Output Register. LATB, Bit 4 = LATB Data Output Register. LATB, Bit 3 = LATB Data Output Register. LATB, Bit 2 = LATB Data Output Register. LATB, Bit 1 = LATB Data Output Register. LATB, Bit 0 = LATB Data Output Register. LATB, Value on POR, BOR = . LATB, Value on all other RESETS = .",
    "TABLE 8-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nTRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111 1111. TRISB, Value on all other RESETS = 1111 1111. INTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on all other RESETS = 0000 000u.",
    "TABLE 8-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nINTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111 -1-1. INTCON2, Value on all other RESETS = 1111 -1-1. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 11-0 0-00. INTCON3, Value on all other RESETS = 11-0 0-00",
    "TABLE 8-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nLegend: x = unknown, u = unchanged. Shaded cells are not used by PORTB.",
    "8.3 PORTC, TRISC and LATC Registers\nPORTC is an 8-bit wide, bi-directional port. The corresponding Data Direction Register is TRISC. Setting a TRISC bit (= 1) will make the corresponding PORTC pin an input (i.e., put the corresponding output driver in a Hi-Impedance mode). Clearing a TRISC bit (= 0) will make the corresponding PORTC pin an output (i.e., put the contents of the output latch on the selected pin).\nNote: On a Power-on Reset, these pins are configured as digital inputs.\nThe  Data  Latch  register (LATC)  is  also memory mapped.  Read-modify-write  operations  on  the  LATC register reads and writes the latched output value for PORTC.\nPORTC is multiplexed with several peripheral functions (Table 8-5).  PORTC  pins  have  Schmitt  Trigger  input buffers.",
    "8.3 PORTC, TRISC and LATC Registers\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTC pin. Some peripherals override the TRIS bit to make a pin an output, while other peripherals override the TRIS bit to make a pin an input. The user should refer to the corresponding peripheral section for the correct TRIS bit settings.\nThe pin override value is not loaded into the TRIS register. This allows read-modify-write of the TRIS register, without concern due to peripheral overrides.\nRC1  is  normally  configured  by  the  configuration  bit CCP2MX as the default peripheral pin for the CCP2 module (default/erased state, CCP2MX = '1').",
    "8.3 PORTC, TRISC and LATC Registers\nCLRF PORTC, INITIALIZING PORTC = ; Initialize PORTC by ; clearing output ; data latches. CLRF LATC, INITIALIZING PORTC = ; Alternate method ; to clear output ; data latches. MOVLW 0xCF, INITIALIZING PORTC = ; Value used to ; initialize data ; direction. MOVWF TRISC, INITIALIZING PORTC = ; Set RC<3:0> as inputs ; RC<5:4> as outputs ; RC<7:6> as inputs",
    "TABLE 8-5: PORTC FUNCTIONS\nRC0/T1OSO/T1CKI, Bit# = bit0. RC0/T1OSO/T1CKI, Buffer Type = ST. RC0/T1OSO/T1CKI, Function = Input/output port pin or Timer1 oscillator output/Timer1 clock input.. RC1/T1OSI/CCP2, Bit# = bit1. RC1/T1OSI/CCP2, Buffer Type = ST. RC1/T1OSI/CCP2, Function = Input/output port pin, Timer1 oscillator input, or Capture2 input/ Compare2 output/PWM output when CCP2MX configuration bit is disabled.. RC2/CCP1, Bit# = bit2. RC2/CCP1, Buffer Type = ST. RC2/CCP1, Function = Input/output port pin or Capture1 input/Compare1 output/ PWM1 output.. RC3/SCK/SCL, Bit# = bit3. RC3/SCK/SCL, Buffer Type = ST. RC3/SCK/SCL, Function = RC3 can",
    "TABLE 8-5: PORTC FUNCTIONS\nalso be the synchronous serial clock for both SPI and I 2 C modes.. RC4/SDI/SDA, Bit# = bit4. RC4/SDI/SDA, Buffer Type = ST. RC4/SDI/SDA, Function = RC4 can also be the SPI Data In (SPI mode) or Data I/O (I 2 C mode).. RC5/SDO, Bit# = bit5. RC5/SDO, Buffer Type = ST. RC5/SDO, Function = Input/output port pin or Synchronous Serial Port Data output.. RC6/TX/CK, Bit# = bit6. RC6/TX/CK, Buffer Type = ST. RC6/TX/CK, Function = Input/output port pin, Addressable USART Asynchronous Transmit, or Addressable USART Synchronous Clock.. RC7/RX/DT, Bit# = bit7. RC7/RX/DT, Buffer Type = ST. RC7/RX/DT, Function = Input/output port pin, Addressable USART",
    "TABLE 8-5: PORTC FUNCTIONS\nAsynchronous Receive, or Addressable USART Synchronous Data.\nLegend: ST = Schmitt Trigger input",
    "TABLE 8-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nPORTC, Bit 7 = RC7. PORTC, Bit 6 = RC6. PORTC, Bit 5 = RC5. PORTC, Bit 4 = RC4. PORTC, Bit 3 = RC3. PORTC, Bit 2 = RC2. PORTC, Bit 1 = RC1. PORTC, Bit 0 = RC0. PORTC, Value on POR, BOR = xxxx xxxx. PORTC, Value on all other RESETS = uuuu. PORTC, Value on all other RESETS = uuuu. LATC, Bit 7 = LATC Data Output Register. LATC, Bit 6 = LATC Data Output Register. LATC, Bit 5 = LATC Data Output Register. LATC, Bit 4 = LATC Data Output Register. LATC, Bit 3 = LATC Data Output Register. LATC, Bit 2 = LATC Data Output Register. LATC, Bit 1 = LATC Data Output Register. LATC, Bit 0 = LATC Data Output Register. LATC, Value on POR, BOR = xxxx. LATC, Value on all other RESETS = xxxx uuuu.",
    "TABLE 8-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nLATC, Value on all other RESETS = uuuu. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other RESETS = 1111. TRISC, Value on all other RESETS = 1111 1111\nLegend: x = unknown, u = unchanged",
    "8.4 PORTD, TRISD and LATD Registers\nThis  section  is  only  applicable  to  the  PIC18C4X2 devices.\nPORTD is an 8-bit wide, bi-directional port. The corresponding Data Direction register is  TRISD.  Setting a TRISD bit (= 1) will make the corresponding PORTD pin an input (i.e., put the corresponding output driver in a Hi-Impedance mode). Clearing a TRISD bit (= 0) will make the corresponding PORTD pin an output (i.e., put the contents of the output latch on the selected pin).\nNote: On a Power-on Reset, these pins are configured as digital inputs.\nThe  Data  Latch  register (LATD)  is  also memory mapped.  Read-modify-write  operations  on  the  LATD register reads and writes the latched output value for PORTD.\nPORTD is an 8-bit port with Schmitt Trigger input buffers. Each pin is individually configurable as an input or output.",
    "8.4 PORTD, TRISD and LATD Registers\nPORTD can be configured as an 8-bit wide microprocessor port  (parallel  slave  port)  by  setting  control  bit PSPMODE (TRISE<4>). In this mode, the input buffers are TTL. See Section 8.6 for additional information on the Parallel Slave Port (PSP).\nCLRF PORTD, INITIALIZING PORTD = ; Initialize PORTD by ; clearing output ; data latches. CLRF LATD, INITIALIZING PORTD = ; Alternate method ; to clear output ; data latches. MOVLW 0xCF, INITIALIZING PORTD = ; Value used to ; initialize data ; direction. MOVWF TRISD, INITIALIZING PORTD = ; Set RD<3:0> as inputs ; RD<5:4> as outputs ; RD<7:6> as inputs",
    "TABLE 8-7: PORTD FUNCTIONS\nRD0/PSP0, Bit# = bit0. RD0/PSP0, Buffer Type = ST/TTL (1). RD0/PSP0, Function = Input/output port pin or parallel slave port bit0.. RD1/PSP1, Bit# = bit1. RD1/PSP1, Buffer Type = ST/TTL (1). RD1/PSP1, Function = Input/output port pin or parallel slave port bit1.. RD2/PSP2, Bit# = bit2. RD2/PSP2, Buffer Type = ST/TTL (1). RD2/PSP2, Function = Input/output port pin or parallel slave port bit2.. RD3/PSP3, Bit# = bit3. RD3/PSP3, Buffer Type = ST/TTL (1). RD3/PSP3, Function = Input/output port pin or parallel slave port bit3.. RD4/PSP4, Bit# = bit4. RD4/PSP4, Buffer Type = ST/TTL (1).",
    "TABLE 8-7: PORTD FUNCTIONS\nRD4/PSP4, Function = Input/output port pin or parallel slave port bit4.. RD5/PSP5, Bit# = bit5. RD5/PSP5, Buffer Type = ST/TTL (1). RD5/PSP5, Function = Input/output port pin or parallel slave port bit5.. RD6/PSP6, Bit# = bit6. RD6/PSP6, Buffer Type = ST/TTL (1). RD6/PSP6, Function = Input/output port pin or parallel slave port bit6.. RD7/PSP7, Bit# = bit7. RD7/PSP7, Buffer Type = ST/TTL (1). RD7/PSP7, Function = Input/output port pin or parallel slave port bit7.\nLegend:  ST = Schmitt Trigger input,  TTL = TTL input\nNote 1: Input buffers are Schmitt Triggers when in I/O mode and TTL buffers when in Parallel Slave Port mode.",
    "TABLE 8-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nPORTD, Bit 7 = RD7. PORTD, Bit 6 = RD6. PORTD, Bit 5 = RD5. PORTD, Bit 4 = RD4. PORTD, Bit 3 = RD3. PORTD, Bit 2 = RD2. PORTD, Bit 1 = RD1. PORTD, Bit 0 = RD0 xxxx. PORTD, Value on POR, BOR = xxxx uuuu. PORTD, Value on all other RESETS = uuuu. LATD, Bit 7 = LATD Data Output Register. LATD, Bit 6 = LATD Data Output Register. LATD, Bit 5 = LATD Data Output Register. LATD, Bit 4 = LATD Data Output Register. LATD, Bit 3 = LATD Data Output Register. LATD, Bit 2 = LATD Data Output Register. LATD, Bit 1 = LATD Data Output Register. LATD, Bit 0 = xxxx. LATD, Value on POR, BOR = xxxx. LATD, Value on all other RESETS = uuuu",
    "TABLE 8-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nuuuu. TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = 1111. TRISD, Value on POR, BOR = 1111. TRISD, Value on all other RESETS = 1111 1111. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE, Bit 3 = -. TRISE, Bit 2 = PORTE Data Direction bits. TRISE, Bit 1 = PORTE Data Direction bits. TRISE, Bit 0 = 0000. TRISE, Value on POR, BOR = -111. TRISE, Value on all other RESETS = 0000 -111",
    "TABLE 8-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by PORTD. -",
    "8.5 PORTE, TRISE and LATE Registers\nThis  section  is  only  applicable  to  the  PIC18C4X2 devices.\nPORTE is a 3-bit wide, bi-directional port. The corresponding Data Direction register is  TRISE.  Setting  a TRISE bit (= 1) will make the corresponding PORTE pin an input (i.e., put the corresponding output driver in a Hi-Impedance mode). Clearing a TRISE bit (= 0) will make the corresponding PORTE pin an output (i.e., put the contents of the output latch on the selected pin).\nNote: On a Power-on Reset, these pins are configured as digital inputs.\nThe  Data  Latch  register (LATE)  is also memory mapped.  Read-modify-write  operations  on  the  LATE register reads and writes the latched output value for PORTE.\nPORTE has three  pins  (RE0/RD/AN5,  RE1/WR/AN6 and RE2/CS/AN7), which are individually configurable as inputs or outputs. These pins have Schmitt Trigger input buffers.\nRegister 8-1 shows the TRISE register, which also controls the parallel slave port operation.",
    "8.5 PORTE, TRISE and LATE Registers\nPORTE pins are multiplexed with analog inputs. When selected as an analog input, these pins will read as '0's.\nTRISE controls the direction of the RE pins, even when they are being used as analog inputs. The user must make sure to keep the pins configured as inputs when using them as analog inputs.\nNote: On a Power-on Reset, these pins are con- figured as analog inputs.",
    "EXAMPLE 8-5: INITIALIZING PORTE\nCLRF, 1 = PORTE. CLRF, 2 = ; Initialize PORTE by ; clearing output ; data latches. CLRF, 1 = LATE. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF MOVLW, 1 = 0x07 ADCON1. MOVLW MOVWF MOVLW, 2 = ; Configure A/D ; for digital inputs ; Value used to. MOVWF, 1 = TRISC. MOVWF, 2 = ; direction ; Set RE<0> as inputs ; RE<1> as outputs ; RE<2> as inputs",
    "FIGURE 8-9: PORTE BLOCK DIAGRAM IN I/O PORT MODE\nNote 1: I/O pins have diode protection to VDD and VSS.",
    "REGISTER 8-1: TRISE REGISTER\n, R-0.IBF = bit 7. , R-0.OBF = . , R/W-0.IBOV = . , R/W-0.PSPMODE = . , U-0.- = . , R/W-1.TRISE2 = . , R/W-1.TRISE1 = . , R/W-1.TRISE0 = bit 0. bit 7, R-0.IBF = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, R-0.OBF = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, R/W-0.IBOV = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, R/W-0.PSPMODE = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by",
    "REGISTER 8-1: TRISE REGISTER\nthe CPU 0 = No word has been received. bit 7, U-0.- = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, R/W-1.TRISE2 = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, R/W-1.TRISE1 = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, R/W-1.TRISE0 = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 6, R-0.IBF = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, R-0.OBF = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written",
    "REGISTER 8-1: TRISE REGISTER\nword 0 = The output buffer has been read. bit 6, R/W-0.IBOV = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, R/W-0.PSPMODE = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, U-0.- = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, R/W-1.TRISE2 = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, R/W-1.TRISE1 = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, R/W-1.TRISE0 = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has",
    "REGISTER 8-1: TRISE REGISTER\nbeen read. bit 5, R-0.IBF = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read. bit 5, R-0.OBF = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read. bit 5, R/W-0.IBOV = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read. bit 5, R/W-0.PSPMODE = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read. bit 5, U-0.- = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read. bit 5, R/W-1.TRISE2 = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1",
    "REGISTER 8-1: TRISE REGISTER\n= A write occurred when a previously input word has not been read. bit 5, R/W-1.TRISE1 = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read. bit 5, R/W-1.TRISE0 = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read. bit 4, R-0.IBF = 0 = No overflow occurred PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, R-0.OBF = 0 = No overflow occurred PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, R/W-0.IBOV = 0 = No overflow occurred PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, R/W-0.PSPMODE = 0 = No overflow occurred",
    "REGISTER 8-1: TRISE REGISTER\nPSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, U-0.- = 0 = No overflow occurred PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, R/W-1.TRISE2 = 0 = No overflow occurred PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, R/W-1.TRISE1 = 0 = No overflow occurred PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, R/W-1.TRISE0 = 0 = No overflow occurred PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 3, R-0.IBF = Unimplemented: Read as '0'. bit 3, R-0.OBF = Unimplemented: Read as '0'. bit 3,",
    "REGISTER 8-1: TRISE REGISTER\nR/W-0.IBOV = Unimplemented: Read as '0'. bit 3, R/W-0.PSPMODE = Unimplemented: Read as '0'. bit 3, U-0.- = Unimplemented: Read as '0'. bit 3, R/W-1.TRISE2 = Unimplemented: Read as '0'. bit 3, R/W-1.TRISE1 = Unimplemented: Read as '0'. bit 3, R/W-1.TRISE0 = Unimplemented: Read as '0'. bit 2, R-0.IBF = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, R-0.OBF = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, R/W-0.IBOV = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, R/W-0.PSPMODE = TRISE2 : RE2 Direction Control bit 1 = Input 0",
    "REGISTER 8-1: TRISE REGISTER\n= Output. bit 2, U-0.- = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, R/W-1.TRISE2 = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, R/W-1.TRISE1 = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, R/W-1.TRISE0 = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 1, R-0.IBF = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, R-0.OBF = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, R/W-0.IBOV = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, R/W-0.PSPMODE = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, U-0.- = TRISE1 : RE1 Direction Control bit 1 = Input 0 =",
    "REGISTER 8-1: TRISE REGISTER\nOutput. bit 1, R/W-1.TRISE2 = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, R/W-1.TRISE1 = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, R/W-1.TRISE0 = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. , R-0.IBF = 1 = Input. , R-0.OBF = 1 = Input. , R/W-0.IBOV = 1 = Input. , R/W-0.PSPMODE = 1 = Input. , U-0.- = 1 = Input. , R/W-1.TRISE2 = 1 = Input. , R/W-1.TRISE1 = 1 = Input. , R/W-1.TRISE0 = 1 = Input. , R-0.IBF = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. , R-0.OBF = Legend: R = Readable bit",
    "REGISTER 8-1: TRISE REGISTER\nW=Writable bit U = Unimplemented bit, read as '0'. , R/W-0.IBOV = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. , R/W-0.PSPMODE = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. , U-0.- = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. , R/W-1.TRISE2 = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. , R/W-1.TRISE1 = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. , R/W-1.TRISE0 = Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'",
    "TABLE 8-9: PORTE FUNCTIONS\nRE0/RD/AN5, Bit# = bit0. RE0/RD/AN5, Buffer Type = ST/TTL (1). RE0/RD/AN5, Function = Input/output port pin or read control input in Parallel Slave Port mode or analog input: RD 1 = Not a read operation 0 = Read operation. Reads PORTD register (if chip selected).. RE1/WR/AN6, Bit# = bit1. RE1/WR/AN6, Buffer Type = ST/TTL (1). RE1/WR/AN6, Function = Input/output port pin or write control input in Parallel Slave Port mode or analog input: WR 1 = Not a write operation 0 = Write operation. Writes PORTD register (if chip selected).. RE2/CS/AN7, Bit# = bit2. RE2/CS/AN7, Buffer Type = ST/TTL (1). RE2/CS/AN7, Function = Input/output port pin or chip select control input in Parallel Slave Port mode or analog input: CS 1 = Device is not selected 0 = Device is selected",
    "TABLE 8-9: PORTE FUNCTIONS\nLegend:  ST = Schmitt Trigger input,  TTL = TTL input\nNote 1: Input buffers are Schmitt Triggers when in I/O mode and TTL buffers when in Parallel Slave Port mode.",
    "TABLE 8-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nPORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = -. PORTE, Bit 2 = RE2. PORTE, Bit 1 = RE1. PORTE, Bit 0 = RE0. PORTE, Value on POR, BOR = ---- -000. PORTE, Value on all other RESETS = ---- -000. LATE, Bit 7 = -. LATE, Bit 6 = -. LATE, Bit 5 = -. LATE, Bit 4 = -. LATE, Bit 3 = -. LATE, Bit 2 = LATE Data Output Register. LATE, Bit 1 = LATE Data Output Register. LATE, Bit 0 = LATE Data Output Register. LATE, Value on POR, BOR = ---- -xxx. LATE, Value on all other RESETS = ---- -uuu. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE, Bit 3 = -. TRISE, Bit 2 = PORTE Data Direction",
    "TABLE 8-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nbits. TRISE, Bit 1 = PORTE Data Direction bits. TRISE, Bit 0 = PORTE Data Direction bits. TRISE, Value on POR, BOR = 0000 -111. TRISE, Value on all other RESETS = 0000 -111. ADCON1, Bit 7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = --0- -000. ADCON1, Value on all other RESETS = --0- -000\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by PORTE. -",
    "8.6 Parallel Slave Port\nThe Parallel Slave Port is implemented on the 40-pin devices only (PIC18C4X2).\nPORTD operates as an 8-bit wide, parallel slave port, or  microprocessor  port,  when  control  bit  PSPMODE (TRISE<4>) is set. It is asynchronously readable and writable by the external world through RD control input pin RE0/RD and WR control input pin RE1/WR.",
    "8.6 Parallel Slave Port\nIt can directly interface to an 8-bit microprocessor data bus. The external microprocessor can read or write the PORTD latch as an 8-bit latch. Setting bit PSPMODE enables port pin RE0/RD to be the RD input, RE1/WR to  be  the  WR  input  and  RE2/CS  to  be  the  CS  (chip select) input. For this functionality, the corresponding data direction bits of the TRISE register (TRISE<2:0>) must be configured as inputs (set). The A/D port configuration bits PCFG2:PCFG0 (ADCON1<2:0>) must be set, which will configure pins RE2:RE0 as digital I/O.\nA write to the PSP occurs when both the CS and WR lines are first detected low. A read from the PSP occurs when both the CS and RD lines are first detected low.",
    "8.6 Parallel Slave Port\nThe  PORTE  I/O  pins  become  control  inputs  for  the microprocessor port when bit PSPMODE (TRISE<4>) is set. In this mode, the user must make sure that the TRISE<2:0> bits are set (pins are configured as digital inputs), and the ADCON1 is configured for digital I/O. In this mode, the input buffers are TTL.",
    "FIGURE 8-10:\nPORTD AND PORTE BLOCK DIAGRAM (PARALLEL SLAVE PORT)",
    "TABLE 8-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nPORTD, Bit 7 = Port Data Latch when written; Port pins when read. PORTD, Bit 6 = Port Data Latch when written; Port pins when read. PORTD, Bit 5 = Port Data Latch when written; Port pins when read. PORTD, Bit 4 = Port Data Latch when written; Port pins when read. PORTD, Bit 3 = Port Data Latch when written; Port pins when read. PORTD, Bit 2 = Port Data Latch when written; Port pins when read. PORTD, Bit 1 = Port Data Latch when written; Port pins when read. PORTD, Bit 0 = Port Data Latch when written; Port pins when read. PORTD, Value on POR, BOR = xxxx. PORTD, Value on POR, BOR = xxxx. PORTD, Value on all other RESETS = uuuu. PORTD, Value on all other RESETS = uuuu. LATD, Bit 7 = LATD Data Output bits. LATD, Bit 6 = LATD Data Output bits. LATD, Bit 5 = LATD Data Output bits. LATD, Bit 4 = LATD Data",
    "TABLE 8-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nOutput bits. LATD, Bit 3 = LATD Data Output bits. LATD, Bit 2 = LATD Data Output bits. LATD, Bit 1 = LATD Data Output bits. LATD, Bit 0 = LATD Data Output bits. LATD, Value on POR, BOR = xxxx. LATD, Value on POR, BOR = xxxx. LATD, Value on all other RESETS = uuuu. LATD, Value on all other RESETS = uuuu. TRISD, Bit 7 = PORTD Data Direction bits. TRISD, Bit 6 = PORTD Data Direction bits. TRISD, Bit 5 = PORTD Data Direction bits. TRISD, Bit 4 = PORTD Data Direction bits. TRISD, Bit 3 = PORTD Data Direction bits. TRISD, Bit 2 = PORTD Data Direction bits. TRISD, Bit 1 = PORTD Data Direction bits. TRISD, Bit 0 = PORTD Data Direction bits. TRISD, Value on POR, BOR = 1111. TRISD, Value on POR, BOR = 1111. TRISD, Value",
    "TABLE 8-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\non all other RESETS = 1111. TRISD, Value on all other RESETS = 1111. PORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = -. PORTE, Bit 2 = RE2. PORTE, Bit 1 = RE1. PORTE, Bit 0 = RE0. PORTE, Value on POR, BOR = ----. PORTE, Value on POR, BOR = -000. PORTE, Value on all other RESETS = ----. PORTE, Value on all other RESETS = -000. LATE, Bit 7 = -. LATE, Bit 6 = -. LATE, Bit 5 = -. LATE, Bit 4 = -. LATE, Bit 3 = -. LATE, Bit 2 = LATE Data Output bits. LATE, Bit 1 = LATE Data Output bits. LATE, Bit 0 = LATE Data Output bits. LATE, Value on POR, BOR = ----. LATE, Value on POR, BOR = -xxx. LATE, Value on all other RESETS = ----. LATE, Value on all other",
    "TABLE 8-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nRESETS = -uuu. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE, Bit 3 = -. TRISE, Bit 2 = PORTE Data Direction bits. TRISE, Bit 1 = PORTE Data Direction bits. TRISE, Bit 0 = PORTE Data Direction bits. TRISE, Value on POR, BOR = 0000. TRISE, Value on POR, BOR = -111. TRISE, Value on all other RESETS = 0000. TRISE, Value on all other RESETS = -111. INTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IF. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR,",
    "TABLE 8-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nBOR = 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other RESETS = 0000. PIR1, Value on all other RESETS = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 =",
    "TABLE 8-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nTMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other RESETS = 0000. PIE1, Value on all other RESETS = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on all other RESETS = 0000. IPR1, Value on all other RESETS = 0000. ADCON1, Bit 7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 =",
    "TABLE 8-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n-. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = --0-. ADCON1, Value on POR, BOR = -000. ADCON1, Value on all other RESETS = --0-. ADCON1, Value on all other RESETS = -000\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by the Parallel Slave Port. -",
    "PIC18CXX2\nNOTES:",
    "9.0 TIMER0 MODULE\nThe Timer0 module has the following features:\n\u00b7 Software selectable as an 8-bit or 16-bit timer/ counter\n\u00b7 Readable and writable\n\u00b7 Dedicated 8-bit software programmable prescaler\n\u00b7 Clock source selectable to be external or internal\n\u00b7 Interrupt-on-overflow from FFh to 00h in 8-bit mode and FFFFh to 0000h in 16-bit mode\n\u00b7 Edge select for external clock",
    "REGISTER 9-1: T0CON: TIMER0 CONTROL REGISTER\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = R/W-1. R/W-1, 4 = R/W-1. R/W-1, 5 = R/W-1. R/W-1, 6 = R/W-1. R/W-1, 7 = R/W-1. TMR0ON, 1 = T08BIT. TMR0ON, 2 = T0CS. TMR0ON, 3 = T0SE. TMR0ON, 4 = PSA. TMR0ON, 5 = T0PS2. TMR0ON, 6 = T0PS1. TMR0ON, 7 = T0PS0\nbit 7\nbit 0\nbit 7\nTMR0ON: Timer0 On/Off Control bit\n1 = Enables Timer0\n0 = Stops Timer0",
    "bit 6\nT08BIT : Timer0 8-bit/16-bit Control bit\n1 = Timer0 is configured as an 8-bit timer/counter\n0 = Timer0 is configured as a 16-bit timer/counter",
    "bit 5\nT0CS : Timer0 Clock Source Select bit\n1 = Transition on T0CKI pin\n0 = Internal instruction cycle clock (CLKOUT)\nbit 4\nT0SE : Timer0 Source Edge Select bit\n1 = Increment on high-to-low transition on T0CKI pin\n0 = Increment on low-to-high transition on T0CKI pin\nbit 3\nPSA : Timer0 Prescaler Assignment bit\n1 = TImer0 prescaler is NOT assigned. Timer0 clock input bypasses prescaler.\n0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.",
    "bit 2:0 T0PS2:T0PS0 : Timer0 Prescaler Select bits\n111 = 1:256 prescale value\n110 = 1:128 prescale value\n101 = 1:64 prescale value\n100 = 1:32 prescale value\n011 = 1:16 prescale value\n010 = 1:8   prescale value\n001 = 1:4   prescale value\n000 = 1:2   prescale value",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nFigure 9-1  shows  a  simplified  block  diagram  of  the Timer0 module in 8-bit mode and Figure 9-2 shows a simplified block diagram of the Timer0 module in 16-bit mode.\nThe T0CON register (Register 9-1) is a readable and writable register that controls all the aspects of Timer0, including the prescale selection.",
    "9.1 Timer0 Operation\nTimer0 can operate as a timer or as a counter.\nTimer  mode  is  selected  by  clearing  the  T0CS  bit.  In Timer mode, the Timer0 module will increment every instruction cycle (without prescaler). If the TMR0 register is written, the increment is inhibited for the following two instruction cycles. The user can work around this by writing an adjusted value to the TMR0 register.\nCounter mode is selected by setting the T0CS bit. In Counter mode, Timer0 will increment either on every rising, or falling edge of pin RA4/T0CKI. The incrementing  edge  is  determined  by  the  Timer0  Source  Edge Select bit (T0SE). Clearing the T0SE bit selects the rising edge. Restrictions on the external clock input are discussed below.\nWhen an external clock input is used for Timer0, it must meet certain requirements. The requirements ensure the external clock can be synchronized with the internal phase clock (TOSC). Also, there is a delay in the actual incrementing of Timer0 after synchronization.",
    "9.2 Prescaler\nAn  8-bit  counter  is  available  as  a  prescaler  for  the Timer0  module.  The  prescaler  is  not  readable  or writable.\nThe PSA and T0PS2:T0PS0 bits determine the prescaler assignment and prescale ratio.\nClearing bit PSA will assign the prescaler to the Timer0 module. When the prescaler is assigned to the Timer0 module,  prescale  values  of  1:2,  1:4,...,  1:256  are selectable.\nWhen assigned to the Timer0 module, all instructions writing to the TMR0 register (e.g. CLRF TMR0, MOVWF TMR0, BSF TMR0, x ....etc.) will clear the prescaler count.",
    "9.2.1 SWITCHING PRESCALER ASSIGNMENT\nThe prescaler assignment is fully under software control (i.e., it can be changed 'on-the-fly' during program execution).",
    "9.3 Timer0 Interrupt\nThe TMR0 interrupt is generated when the TMR0 register overflows from FFh to 00h in 8-bit mode, or FFFFh to 0000h in 16-bit mode. This overflow sets the TMR0IF bit. The  interrupt  can  be  masked  by  clearing  the TMR0IE bit. The TMR0IE bit must be cleared in software by the Timer0 module Interrupt Service Routine before  re-enabling  this  interrupt.  The  TMR0  interrupt cannot awaken the processor from SLEEP, since the timer is shut-off during SLEEP.",
    "9.4 16-Bit Mode Timer Reads and Writes\nTMR0H  is  not  the  high  byte  of  the  timer/counter  in 16-bit mode, but is actually a buffered version of the high byte of Timer0 (refer to Figure 9-2). The high byte of the Timer0 counter/timer is not directly readable nor writable.  TMR0H is  updated  with  the  contents  of  the high byte of Timer0 during a read of TMR0L. This provides  the  ability  to  read  all  16-bits  of  Timer0  without having to verify that the read of the high and low byte were valid due to a rollover between successive reads of the high and low byte.\nA write to the high byte of Timer0 must also take place through the TMR0H buffer register. Timer0 high byte is updated  with  the  contents  of  TMR0H  when  a  write occurs to TMR0L. This allows all 16-bits of Timer0 to be updated at once.\nNote:\nWriting  to  TMR0  when  the  prescaler  is assigned to Timer0 will clear the prescaler count,  but  will  not  change  the  prescaler assignment.",
    "TABLE 9-1: REGISTERS ASSOCIATED WITH TIMER0\n\nLegend: x = unknown, u = unchanged,   = unimplemented locations read as '0'. Shaded cells are not used by Timer0. -",
    "TABLE 9-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0L, Bit 7 = Timer0 Module's Low Byte Register. TMR0L, Bit 6 = Timer0 Module's Low Byte Register. TMR0L, Bit 5 = Timer0 Module's Low Byte Register. TMR0L, Bit 4 = Timer0 Module's Low Byte Register. TMR0L, Bit 3 = Timer0 Module's Low Byte Register. TMR0L, Bit 2 = Timer0 Module's Low Byte Register. TMR0L, Bit 1 = Timer0 Module's Low Byte Register. TMR0L, Bit 0 = Timer0 Module's Low Byte Register. TMR0L, Value on POR, BOR = xxxx xxxx. TMR0L, Value on all other RESETS = uuuu uuuu. TMR0H, Bit 7 = Timer0 Module's High Byte Register. TMR0H, Bit 6 = Timer0 Module's High Byte Register. TMR0H, Bit 5 = Timer0 Module's High Byte Register. TMR0H, Bit 4",
    "TABLE 9-1: REGISTERS ASSOCIATED WITH TIMER0\n= Timer0 Module's High Byte Register. TMR0H, Bit 3 = Timer0 Module's High Byte Register. TMR0H, Bit 2 = Timer0 Module's High Byte Register. TMR0H, Bit 1 = Timer0 Module's High Byte Register. TMR0H, Bit 0 = Timer0 Module's High Byte Register. TMR0H, Value on POR, BOR = 0000 0000. TMR0H, Value on all other RESETS = 0000 0000. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on all other RESETS = 0000 000u. T0CON, Bit 7 =",
    "TABLE 9-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111 1111. T0CON, Value on all other RESETS = 1111 1111. TRISA, Bit 7 = -. TRISA, Bit 6 = -. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = --11 1111. TRISA, Value on all other RESETS = --11 1111",
    "PIC18CXX2\nNOTES:",
    "10.0 TIMER1 MODULE\nThe  Timer1  module  timer/counter  has  the  following features:\n- \u00b7 16-bit timer/counter\n(two 8-bit registers: TMR1H and TMR1L)\n\u00b7 Readable and writable (both registers)\n\u00b7 Internal or external clock select\n\u00b7 Interrupt-on-overflow from FFFFh to 0000h\n\u00b7 Reset from CCP module special event trigger",
    "REGISTER 10-1: T1CON: TIMER1 CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. RD16, 1 = -. RD16, 2 = T1CKPS1. RD16, 3 = T1CKPS0. RD16, 4 = T1OSCEN. RD16, 5 = T1SYNC. RD16, 6 = TMR1CS. RD16, 7 = TMR1ON\nbit 7\nbit 0",
    "bit 7 RD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register Read/Write of TImer1 in one 16-bit operation\n0 = Enables register Read/Write of Timer1 in two 8-bit operations",
    "bit 5-4 T1CKPS1:T1CKPS0 : Timer1 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value",
    "bit 3 T1OSCEN: Timer1 Oscillator Enable bit\n1 = Timer1 Oscillator is enabled\n0 = Timer1 Oscillator is shut-off\nThe oscillator inverter and feedback resistor are turned off to eliminate power drain.",
    "When TMR1CS = 1:\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR1CS = 0:\nThis bit is ignored. Timer1 uses the internal clock when TMR1CS = 0.",
    "bit 1 TMR1CS: Timer1 Clock Source Select bit\n1 = External clock from pin RC0/T1OSO/T13CKI (on the rising edge)\n0 = Internal clock (FOSC/4)",
    "bit 0 TMR1ON: Timer1 On bit\n1 = Enables Timer1\n0 = Stops Timer1\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nFigure 10-1 is a simplified block diagram of the Timer1 module.\nRegister 10-1 details the Timer1 control register. This register  controls  the  operating  mode  of  the  Timer1 module, and contains the Timer1 oscillator enable bit (T1OSCEN). Timer1 can be enabled or disabled by setting or clearing control bit TMR1ON (T1CON<0>).",
    "10.1 Timer1 Operation\nTimer1 can operate in one of these modes:\n\u00b7 As a timer\n\u00b7 As a synchronous counter\n\u00b7 As an asynchronous counter\nThe operating mode is determined by the clock select bit, TMR1CS (T1CON<1>).\nWhen TMR1CS = 0, Timer1 increments every instruction cycle. When TMR1CS = 1, Timer1 increments on every  rising  edge  of  the  external  clock  input  or  the Timer1 oscillator, if enabled.\nWhen the Timer1 oscillator is enabled (T1OSCEN is set),  the  RC1/T1OSI  and  RC0/T1OSO/T1CKI  pins become  inputs.  That  is,  the  TRISC<1:0>  value  is ignored.\nTimer1  also  has  an  internal  'RESET  input'.  This RESET  can  be generated by the CCP  module (Section 13.0).",
    "10.2 Timer1 Oscillator\nA crystal oscillator circuit is built-in between pins T1OSI (input) and T1OSO (amplifier output). It is enabled by setting control bit T1OSCEN (T1CON<3>). The oscillator is a low power oscillator rated up to 200 kHz. It will continue to run during SLEEP. It is primarily intended for  a  32  kHz  crystal.  Table 10-1  shows  the  capacitor selection for the Timer1 oscillator.\nThe user must provide a software time delay to ensure proper start-up of the Timer1 oscillator.",
    "TABLE 10-1: CAPACITOR SELECTION FOR THE ALTERNATE OSCILLATOR\nOsc Type, 1 = Freq.. Osc Type, 2 = C1. Osc Type, 3 = C2. LP, 1 = 32 kHz. LP, 2 = TBD (1). LP, 3 = TBD (1)",
    "Crystal to be Tested:\n32.768 kHz, 1 = Epson C-001R32.768K-A. 32.768 kHz, 2 = \uf0b1 20 PPM\nNote 1: Microchip suggests 33 pF as a starting point in validating the oscillator circuit.\n2: Higher capacitance increases the stability of the oscillator, but also increases the start-up time.\n3: Since each resonator/crystal has its own characteristics, the user should consult the resonator/crystal manufacturer for appropriate values of external components.\n4: Capacitor values are for design guidance only.",
    "10.3 Timer1 Interrupt\nThe TMR1 Register pair (TMR1H:TMR1L) increments from  0000h  to  FFFFh  and  rolls  over  to  0000h.  The TMR1 Interrupt, if enabled, is generated on overflow, which is latched in interrupt flag bit TMR1IF (PIR1<0>). This interrupt can be enabled/disabled by setting/clearing TMR1 interrupt enable bit TMR1IE (PIE1<0>).",
    "10.4 Resetting Timer1 using a CCP Trigger Output\nIf the CCP module is configured in compare mode to generate a 'special event trigger' (CCP1M3:CCP1M0 = 1011), this signal will reset Timer1 and start an A/D conversion (if the A/D module is enabled).\nNote:, 1 = The special event triggers from the CCP1 module will not set interrupt flag bit TMR1IF (PIR1<0>).\nTimer1 must be configured for either timer or synchronized counter mode to take advantage of this feature. If Timer1 is running in asynchronous counter mode, this reset operation may not work.\nIn the event that a write to Timer1 coincides with a special event trigger from CCP1, the write will take precedence.\nIn this mode of operation, the CCPR1H:CCPR1L registers  pair  effectively  becomes  the  period  register  for Timer1.",
    "10.5 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured for 16-bit reads and writes (see Figure 10-2). When the RD16 control bit (T1CON<7>) is set, the address for TMR1H is mapped to a buffer register for the high byte of Timer1. A read from TMR1L will load the contents of the high byte of Timer1 into the Timer1 high byte buffer. This provides the user with the ability to accurately read all 16-bits of Timer1, without having to determine whether a read of the  high  byte,  followed  by  a  read  of  the  low  byte,  is valid, due to a rollover between reads.\nA write to the high byte of Timer1 must also take place through the TMR1H buffer register. Timer1 high byte is updated  with  the  contents  of  TMR1H  when  a  write occurs to TMR1L. This allows a user to write all 16 bits to  both  the  high  and  low  bytes  of  Timer1  at  once. TMR1H is updated from the high byte when TMR1L is read.",
    "10.5 Timer1 16-Bit Read/Write Mode\nThe high byte of Timer1 is not directly readable or writable in this mode. All reads and writes must take place through the Timer1 high byte buffer register. Writes to TMR1H do not clear the Timer1 prescaler. The prescaler is only cleared on writes to TMR1L.",
    "TABLE 10-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR",
    "TABLE 10-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\n= 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other RESETS = 0000. PIR1, Value on all other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other RESETS = 0000. PIE1, Value on all other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit",
    "TABLE 10-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\n2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on all other RESETS = 0000. IPR1, Value on all other RESETS = 0000. TMR1L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of",
    "TABLE 10-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nthe 16-bit TMR1 Register. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on all other RESETS = uuuu. TMR1L, Value on all other RESETS = uuuu. TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register.",
    "TABLE 10-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nTMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on all other RESETS = uuuu. TMR1H, Value on all other RESETS = uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 =",
    "TABLE 10-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nT1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = --00. T1CON, Value on POR, BOR = 0000. T1CON, Value on all other RESETS = --uu. T1CON, Value on all other RESETS = uuuu\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by the Timer1 module. -\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices. Always maintain these bits clear.",
    "11.0 TIMER2 MODULE\nThe Timer2 module timer has the following features:\n\u00b7 8-bit timer (TMR2 register)\n\u00b7 8-bit period register (PR2)\n\u00b7 Readable and writable (both registers)\n\u00b7 Software programmable prescaler (1:1, 1:4, 1:16)\n\u00b7 Software programmable postscaler (1:1 to 1:16)\n\u00b7 Interrupt on TMR2 match of PR2\n\u00b7 SSP module optional use of TMR2 output to generate clock shift",
    "11.1 Timer2 Operation\nTimer2  can  be  used  as  the  PWM  time-base  for  the PWM mode of the CCP module. The TMR2 register is readable  and  writable,  and  is  cleared  on  any  device RESET. The input clock (FOSC/4) has a prescale option of 1:1, 1:4, or 1:16, selected by control bits T2CKPS1:T2CKPS0 (T2CON<1:0>). The match output  of  TMR2  goes  through  a  4-bit  postscaler  (which gives  a  1:1  to  1:16  scaling  inclusive)  to  generate  a TMR2 interrupt (latched in flag bit TMR2IF, (PIR1<1>)).\nTimer2 has a control register shown in Register 11-1. Timer2 can be shut-off by clearing control bit TMR2ON (T2CON<2>) to minimize power consumption. Figure 11-1 is a simplified block diagram of the Timer2 module. Register 11-1 shows the Timer2 control register. The prescaler and postscaler selection of Timer2 are controlled by this register.",
    "11.1 Timer2 Operation\nThe  prescaler  and  postscaler  counters  are  cleared when any of the following occurs:\n\u00b7 a write to the TMR2 register\n\u00b7 a write to the T2CON register\n\u00b7 any device RESET (Power-on Reset, MCLR Reset, Watchdog Timer Reset, or Brown-out Reset)\nTMR2 is not cleared when T2CON is written.",
    "REGISTER 11-1: T2CON: TIMER2 CONTROL REGISTER\nbit 7\n\nU-0, 1 = R/W-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = TOUTPS3. -, 2 = TOUTPS2. -, 3 = TOUTPS1. -, 4 = TOUTPS0. -, 5 = TMR2ON. -, 6 = T2CKPS1. -, 7 = T2CKPS0\nbit 0\nbit 7 Unimplemented: Read as '0'\nbit 6-3 TOUTPS3:TOUTPS0 : Timer2 Output Postscale Select bits\n0000 = 1:1 Postscale\n0001 = 1:2 Postscale\n\u2022\n\u2022\n\u2022\n1111 = 1:16 Postscale\nTMR2ON : Timer2 On bit\n1 = Timer2 is on\n0 = Timer2 is off",
    "REGISTER 11-1: T2CON: TIMER2 CONTROL REGISTER\nT2CKPS1:T2CKPS0 : Timer2 Clock Prescale Select bits\n00 = Prescaler is 1\n01 = Prescaler is 4\n1x = Prescaler is 16\nLegend:\nR = Readable bit\n- n = Value at POR reset",
    "bit 2\nbit 1-0\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "11.2 Timer2 Interrupt\nThe Timer2 module has an 8-bit period register, PR2. Timer2 increments from 00h until it matches PR2 and then resets to 00h on the next increment cycle. PR2 is a readable and writable register. The PR2 register is initialized to FFh upon RESET.",
    "11.3 Output of TMR2\nThe output of TMR2 (before the postscaler) is fed to the Synchronous Serial Port module, which optionally uses it to generate the shift clock.",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n= 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other RESETS = 0000. PIR1, Value on all other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other RESETS = 0000. PIE1, Value on all other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on all other RESETS = 0000. IPR1, Value on all other RESETS = 0000. TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Value on all other RESETS = 0000.",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nTMR2, Value on all other RESETS = 0000. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Value on all other RESETS = -000. T2CON, Value on all other RESETS = 0000. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nPeriod Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. PR2, Value on all other RESETS = 1111. PR2, Value on all other RESETS = 1111\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'.  Shaded cells are not used by the Timer2 module. -\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices.  Always maintain these bits clear.",
    "12.0 TIMER3 MODULE\nThe  Timer3  module  timer/counter  has  the  following features:\n\u2022\n16-bit timer/counter\n(two 8-bit registers: TMR3H and TMR3L)\n\u00b7 Readable and writable (both registers)\n\u00b7 Internal or external clock select\n\u00b7 Interrupt-on-overflow from FFFFh to 0000h\n\u00b7 Reset from CCP module trigger\nFigure 12-1 is a simplified block diagram of the Timer3 module.\nRegister 12-1 shows the Timer3 control register. This register  controls  the  operating  mode  of  the  Timer3 module and sets the CCP clock source.\nRegister 10-1 shows the Timer1 control register. This register  controls  the  operating  mode  of  the  Timer1 module,  as  well  as  contains  the  Timer1  oscillator enable bit (T1OSCEN), which can be a clock source for Timer3.",
    "REGISTER 12-1: T3CON: TIMER3 CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. RD16, 1 = T3CCP2. RD16, 2 = T3CKPS1. RD16, 3 = T3CKPS0. RD16, 4 = T3CCP1. RD16, 5 = T3SYNC. RD16, 6 = TMR3CS. RD16, 7 = TMR3ON\nRD16\nT3CCP2\nT3CKPS1\nT3CKPS0\nT3CCP1\nT3SYNC\nTMR3CS\nTMR3ON\nbit 7\nbit 0",
    "bit 7\nRD16: 16-bit Read/Write Mode Enable\n1 = Enables register Read/Write of Timer3 in one 16-bit operation 0 = Enables register Read/Write of Timer3 in two 8-bit operations",
    "bit 6-3 T3CCP2:T3CCP1: Timer3 and Timer1 to CCPx Enable bits\n1x = Timer3 is the clock source for compare/capture CCP modules\n01 = Timer3 is the clock source for compare/capture of CCP2,\nTimer1 is the clock source for compare/capture of CCP1\n00 = Timer1 is the clock source for compare/capture CCP modules",
    "bit 5-4 T3CKPS1:T3CKPS0 : Timer3 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value\nbit 2 T3SYNC: Timer3 External Clock Input Synchronization Control bit (Not usable if the system clock comes from Timer1/Timer3.)\nWhen TMR3CS = 1:\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR3CS = 0:\nThis bit is ignored. Timer3 uses the internal clock when TMR3CS = 0.",
    "bit 1 TMR3CS: Timer3 Clock Source Select bit\n1 = External clock input from Timer1 oscillator or T1CKI (on the rising edge after the first falling edge)\n0 = Internal clock (FOSC/4)",
    "bit 0 TMR3ON: Timer3 On bit\n1 = Enables Timer3\n0 = Stops Timer3\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "12.1 Timer3 Operation\nTimer3 can operate in one of these modes:\n\u00b7 As a timer\n\u00b7 As a synchronous counter\n\u00b7 As an asynchronous counter\nThe operating mode is determined by the clock select bit, TMR3CS (T3CON<1>).\nWhen TMR3CS = 0, Timer3 increments every instruction cycle. When TMR3CS = 1, Timer3 increments on every rising edge of the Timer1 external clock input or the Timer1 oscillator, if enabled.\nWhen the Timer1 oscillator is enabled (T1OSCEN is set),  the  RC1/T1OSI  and  RC0/T1OSO/T1CKI  pins become  inputs.  That  is,  the  TRISC<1:0>  value  is ignored.\nTimer3  also  has  an  internal  'RESET  input'.  This RESET  can  be generated by the CCP  module (Section 12.0).",
    "12.2 Timer1 Oscillator\nThe Timer1 oscillator may be used as the clock source for Timer3. The Timer1 oscillator is enabled by setting the T1OSCEN (T1CON<3>) bit. The oscillator is a low power oscillator rated up to 200 KHz. See Section 10.0 for further details.",
    "12.3 Timer3 Interrupt\nThe TMR3 Register pair (TMR3H:TMR3L) increments from  0000h  to  FFFFh  and  rolls  over  to  0000h.  The TMR3 interrupt, if  enabled,  is  generated  on  overflow which is latched in interrupt flag bit TMR3IF (PIR2<1>). This interrupt can be enabled/disabled by setting/clearing TMR3 interrupt enable bit, TMR3IE (PIE2<1>).",
    "12.4 Resetting Timer3 Using a CCP Trigger Output\nIf the CCP module is configured in Compare mode to generate a 'special event trigger' (CCP1M3:CCP1M0 = 1011 ), this signal will reset Timer3.\nNote:\nThe special event triggers  from  the  CCP module will not set interrupt flag bit TMR3IF (PIR1<0>).\nTimer3 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If  Timer3  is  running  in  Asynchronous  Counter mode, this RESET operation may not work. In the event that a write to Timer3 coincides with a special event trigger from CCP1, the write will take precedence. In this mode of operation, the CCPR1H:CCPR1L  registers  pair effectively becomes the period register for Timer3.",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR2, Bit 7 = -. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = -. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = 0000. PIR2, Value on",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nPOR, BOR = 0000. PIR2, Value on all other RESETS = 0000. PIR2, Value on all other RESETS = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = -. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = 0000. PIE2, Value on POR, BOR = 0000. PIE2, Value on all other RESETS = 0000. PIE2, Value on all other RESETS = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = -. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 =",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nCCP2IP. IPR2, Value on POR, BOR = 0000. IPR2, Value on POR, BOR = 0000. IPR2, Value on all other RESETS = 0000. IPR2, Value on all other RESETS = 0000. TMR3L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 1 = Holding Register for the Least Significant Byte of the",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\n16-bit TMR3 Register. TMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on all other RESETS = uuuu. TMR3L, Value on all other RESETS = uuuu. TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register.",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nTMR3H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on all other RESETS = uuuu. TMR3H, Value on all other RESETS = uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 =",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nTMR1ON. T1CON, Value on POR, BOR = --00. T1CON, Value on POR, BOR = 0000. T1CON, Value on all other RESETS = --uu. T1CON, Value on all other RESETS = uuuu. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = -000. T3CON, Value on POR, BOR = 0000. T3CON, Value on all other RESETS = -uuu. T3CON, Value on all other RESETS = uuuu",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'.  Shaded cells are not used by the Timer1 module. -",
    "PIC18CXX2\nNOTES:",
    "13.0 CAPTURE/COMPARE/PWM (CCP) MODULES\nEach CCP (Capture/Compare/PWM) module contains a 16-bit register which can operate as a 16-bit capture register,  as  a  16-bit  compare  register,  or  as  a  PWM master/slave Duty Cycle register. Table 13-1 shows the timer resources of the CCP module modes.\nThe operation of CCP1 is identical to that of CCP2, with the exception of the special event trigger. Therefore, operation of a CCP module in the following sections is described with respect to CCP1.\nTable 13-2 shows the interaction of the CCP modules.",
    "REGISTER 13-1: CCP1CON REGISTER/CCP2CON REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = DCxB1. -, 3 = DCxB0. -, 4 = CCPxM3. -, 5 = CCPxM2. -, 6 = CCPxM1. -, 7 = CCPxM0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as '0'\nbit 5-4\nDCxB1:DCxB0 : PWM Duty Cycle bit1 and bit0\nCapture mode:\nUnused\nCompare mode:\nUnused PWM mode:",
    "REGISTER 13-1: CCP1CON REGISTER/CCP2CON REGISTER\nThese bits are the two LSbs (bit1 and bit0) of the 10-bit PWM duty cycle. The upper eight bits (DCx9:DCx2) of the duty cycle are found in CCPRxL.",
    "bit 3-0\nCCPxM3:CCPxM0 : CCPx Mode Select bits\n0000 = Capture/Compare/PWM off (resets CCPx module)\n0001 = Reserved\n0010 = Compare mode, toggle output on match (CCPxIF bit is set)\n0011 = Reserved\n0100 = Capture mode, every falling edge\n0101 = Capture mode, every rising edge\n0110 = Capture mode, every 4th rising edge\n0111 = Capture mode, every 16th rising edge\n1000 = Compare mode,\nInitialize CCP pin Low, on compare match force CCP pin High (CCPIF bit is set) = Compare mode,\n1001\nInitialize CCP pin High, on compare match force CCP pin Low (CCPIF bit is set) = Compare mode,\n1010\nGenerate software interrupt on compare match (CCPIF bit is set, CCP pin is unaffected)\n1011 = Compare mode,\nTrigger special event (CCPIF bit is set)\n11xx = PWM mode\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set",
    "bit 3-0\n'0' = Bit is cleared\nx = Bit is unknown",
    "13.1 CCP1 Module\nCapture/Compare/PWM Register 1 (CCPR1) is comprised of two 8-bit registers: CCPR1L (low byte) and CCPR1H (high byte). The CCP1CON register controls the operation of CCP1. All are readable and writable.\nTABLE 13-1: CCP MODE - TIMER RESOURCE\n\nCapture Compare PWM, Timer Resource = Timer1 or Timer3 Timer1 or Timer3 Timer2",
    "TABLE 13-2: INTERACTION OF TWO CCP MODULES\nCapture, CCPy Mode = Capture. Capture, Interaction = TMR1 or TMR3 time-base. Time-base can be different for each CCP.. Capture, CCPy Mode = Compare. Capture, Interaction = The compare could be configured for the special event trigger, which clears either TMR1, or TMR3, depending upon which time-base is used.. Compare, CCPy Mode = Compare. Compare, Interaction = The compare(s) could be configured for the special event trigger, which clears TMR1, or TMR3, depending upon which time-base is used.. PWM, CCPy Mode = PWM. PWM, Interaction = The PWMs will have the same frequency and update rate (TMR2 interrupt).. PWM, CCPy Mode = Capture. PWM, Interaction = None.. PWM, CCPy Mode = Compare. PWM, Interaction = None.",
    "13.2 CCP2 Module\nCapture/Compare/PWM  Register2  (CCPR2)  is  comprised of two 8-bit registers: CCPR2L (low byte) and CCPR2H (high byte). The CCP2CON register controls the operation of CCP2. All are readable and writable.",
    "13.3 Capture Mode\nIn Capture  mode,  CCPR1H:CCPR1L  captures  the 16-bit value of the TMR1 or TMR3 registers when an event occurs on pin RC2/CCP1. An event is defined as:\n\u00b7 every falling edge\n\u00b7 every rising edge\n\u00b7 every 4th rising edge\n\u00b7 every 16th rising edge\nAn event is selected by control bits CCP1M3:CCP1M0 (CCP1CON<3:0>). When a capture is made, the interrupt request flag bit CCP1IF (PIR1<2>) is set. It must be cleared in software. If another capture occurs before the value in register CCPR1 is read, the old captured value will be lost.",
    "13.3.1 CCP PIN CONFIGURATION\nIn Capture mode, the RC2/CCP1 pin should be configured as an input by setting the TRISC<2> bit.\nNote:, 1 = If the RC2/CCP1 is configured as an out- put, a write to the port can cause a capture condition.",
    "13.3.2 TIMER1/TIMER3 MODE SELECTION\nThe timers that are to be used with the capture feature (either Timer1 and/or Timer3) must be running in Timer mode  or  Synchronized  Counter  mode.  In  Asynchronous  Counter  mode,  the  capture  operation  may  not work. The timer to be used with each CCP module is selected in the T3CON register.",
    "13.3.3 SOFTWARE INTERRUPT\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep bit CCP1IE (PIE1<2>) clear to avoid false interrupts and should clear the flag bit, CCP1IF, following any such change in operating mode.",
    "13.3.4 CCP PRESCALER\nThere  are  four  prescaler  settings,  specified  by  bits CCP1M3:CCP1M0.  Whenever  the  CCP  module  is turned off, or the CCP module is not in Capture mode, the prescaler counter is cleared. This means that any RESET will clear the prescaler counter.\nSwitching from one capture prescaler to another may generate an interrupt. Also, the prescaler counter will not be cleared, therefore, the first capture may be from a non-zero prescaler. Example 13-1 shows the recommended method for switching between capture prescalers. This example also clears the prescaler counter and will not generate the 'false' interrupt.",
    "EXAMPLE 13-1: CHANGING BETWEEN CAPTURE PRESCALERS\nCLRF\nCCP1CON, F\n; Turn CCP module off\nMOVLW  NEW_CAPT_PS ; Load WREG with the\n; new prescaler mode\n; value and CCP ON\nMOVWF  CCP1CON\n; Load CCP1CON with\n; this value",
    "13.4 Compare Mode\nIn Compare mode, the 16-bit CCPR1 (CCPR2) register value is constantly compared against either the TMR1 register  pair  value  or  the  TMR3  register  pair  value. When a match occurs, the RC2/CCP1 (RC1/CCP2) pin is:\n\u00b7 driven High\n\u00b7 driven Low\n\u00b7 toggle output (High to Low or Low to High)\n\u00b7 remains unchanged\nThe action on the pin is based on the value of control bits  CCP1M3:CCP1M0  (CCP2M3:CCP2M0).  At  the same time, interrupt flag bit, CCP1IF (CCP2IF) is set.",
    "13.4.1 CCP PIN CONFIGURATION\nThe user must configure the CCPx pin as an output by clearing the appropriate TRISC bit.\nNote:, 1 = Clearing the CCP1CON register will force the RC2/CCP1 compare output latch to the default low level. This is not the data latch.",
    "13.4.2 TIMER1/TIMER3 MODE SELECTION\nTimer1 and/or Timer3 must be running in Timer mode, or Synchronized Counter mode, if the CCP module is using the compare feature. In Asynchronous Counter mode, the compare operation may not work.",
    "13.4.3 SOFTWARE INTERRUPT MODE\nWhen generate software interrupt is chosen, the CCP1 pin is not affected. Only a CCP interrupt is generated (if enabled).",
    "13.4.4 SPECIAL EVENT TRIGGER\nIn this mode, an internal hardware trigger is generated, which may be used to initiate an action.\nThe special  event  trigger  output  of  CCP1  resets  the TMR1 register pair. This allows the CCPR1 register to effectively be a 16-bit programmable period register for Timer1.\nThe special  trigger  output  of  CCPx  resets  either  the TMR1 or TMR3 register pair.  Additionally,  the  CCP2 Special Event Trigger will start an A/D conversion if the A/D module is enabled.",
    "Note:\nThe special event trigger from the CCP2 module will not set the Timer1 or Timer3 interrupt flag bits.",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR1, Bit 7 = PSPIF ( 1 ). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR,",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nBOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other RESETS = 0000. PIR1, Value on all other RESETS = 0000. PIE1, Bit 7 = PSPIE ( 1 ). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other RESETS = 0000. PIE1, Value on all other RESETS = 0000. IPR1, Bit 7 = PSPIP ( 1 ). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP.",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nIPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on all other RESETS = 0000. IPR1, Value on all other RESETS = 0000. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other RESETS = 1111. TRISC, Value on all other RESETS =",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n1111. TMR1L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Value on POR, BOR = xxxx.",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR1L, Value on POR, BOR = xxxx. TMR1L, Value on all other RESETS = uuuu. TMR1L, Value on all other RESETS = uuuu. TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nRegister. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on all other RESETS = uuuu. TMR1H, Value on all other RESETS = uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = --00. T1CON, Value on POR, BOR = 0000. T1CON, Value on all other RESETS = --uu.",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nT1CON, Value on all other RESETS = uuuu. CCPR1L, Bit 7 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 6 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 5 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 4 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 3 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 2 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 1 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 0 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other RESETS = uuuu.",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCPR1L, Value on all other RESETS = uuuu. CCPR1H, Bit 7 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 6 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 5 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 4 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 3 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 2 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 1 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 0 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other RESETS =",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nuuuu. CCPR1H, Value on all other RESETS = uuuu. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = --00. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on all other RESETS = --00. CCP1CON, Value on all other RESETS = 0000. CCPR2L, Bit 7 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 6 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 5 =",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCapture/Compare/PWM Register2 (LSB). CCPR2L, Bit 4 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 3 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 2 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 1 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 0 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on all other RESETS = uuuu. CCPR2L, Value on all other RESETS = uuuu. CCPR2H, Bit 7 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 6 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 5",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 4 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 3 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 2 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 1 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 0 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on all other RESETS = uuuu. CCPR2H, Value on all other RESETS = uuuu. CCP2CON, Bit 7 = -. CCP2CON, Bit 6 = -. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0.",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Value on POR, BOR = --00. CCP2CON, Value on POR, BOR = 0000. CCP2CON, Value on all other RESETS = --00. CCP2CON, Value on all other RESETS = 0000. PIR2, Bit 7 = -. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = -. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = 0000. PIR2, Value on POR, BOR = 0000. PIR2, Value on all other RESETS",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= 0000. PIR2, Value on all other RESETS = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = -. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = 0000. PIE2, Value on POR, BOR = 0000. PIE2, Value on all other RESETS = 0000. PIE2, Value on all other RESETS = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = -. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR =",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n0000. IPR2, Value on POR, BOR = 0000. IPR2, Value on all other RESETS = 0000. IPR2, Value on all other RESETS = 0000. TMR3L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register.",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on all other RESETS = uuuu. TMR3L, Value on all other RESETS = uuuu. TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 2 =",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nHolding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on all other RESETS = uuuu. TMR3H, Value on all other RESETS = uuuu. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 =",
    "TABLE 13-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3ON. T3CON, Value on POR, BOR = -000. T3CON, Value on POR, BOR = 0000. T3CON, Value on all other RESETS = -uuu. T3CON, Value on all other RESETS = uuuu\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by Capture and Timer1. -\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices. Always maintain these bits clear.",
    "13.5 PWM Mode\nIn Pulse Width Modulation (PWM) mode, the CCP1 pin produces up to a 10-bit resolution PWM output. Since the CCP1 pin is multiplexed with the PORTC data latch, the TRISC<2> bit must be cleared to make the CCP1 pin an output.\nNote:, 1 = Clearing the CCP1CON register will force the CCP1 PWM output latch to the default low level. This is not the PORTC I/O data latch.\nFigure 13-3  shows  a  simplified  block  diagram  of  the CCP module in PWM mode.\nFor a step-by-step procedure on how to set up the CCP module for PWM operation, see Section 13.5.3.",
    "FIGURE 13-3: SIMPLIFIED PWM BLOCK DIAGRAM\nA PWM output (Figure 13-4) has a time-base (period) and a time that the output stays high (duty cycle). The frequency  of  the  PWM  is  the  inverse  of  the  period (1/period).",
    "13.5.1 PWM PERIOD\nThe PWM period is specified by writing to the PR2 register. The PWM period can be calculated using the following formula:\n<!-- formula-not-decoded -->\nPWM frequency is defined as 1 / [PWM period].\nWhen TMR2 is equal to PR2, the following three events occur on the next increment cycle:\n\u00b7 TMR2 is cleared\n\u00b7 The CCP1 pin is set (exception: if PWM duty cycle = 0%, the CCP1 pin will not be set)\n\u00b7 The PWM duty cycle is latched from CCPR1L into CCPR1H\nNote:\nThe Timer2 postscaler (see Section 11.0) is  not  used  in  the  determination  of  the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "13.5.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the CCPR1L register and to the CCP1CON<5:4> bits. Up to 10-bit resolution is available. The CCPR1L contains the eight MSbs and the CCP1CON<5:4> contains the two LSbs. This 10-bit value is represented by CCPR1L:CCP1CON<5:4>.  The  following  equation  is used to calculate the PWM duty cycle in time:\nPWM duty cycle    = (CCPR1L:CCP1CON<5:4>) \u00b7 TOSC \u00b7 (TMR2 prescale value)\nCCPR1L and CCP1CON<5:4> can be written to at any time,  but  the  duty  cycle  value  is  not  latched  into CCPR1H until after a match between PR2 and TMR2 occurs  (i.e.,  the  period  is  complete).  In  PWM  mode, CCPR1H is a read only register.",
    "13.5.2 PWM DUTY CYCLE\nThe  CCPR1H  register  and  a  2-bit  internal  latch  are used to double buffer the PWM duty cycle. This double buffering is essential for glitchless PWM operation.\nWhen the CCPR1H and 2-bit latch match TMR2 concatenated with an internal 2-bit Q clock or 2 bits of the TMR2 prescaler, the CCP1 pin is cleared.\nThe maximum PWM resolution (bits) for a given PWM frequency is given by the equation:\n<!-- formula-not-decoded -->\nNote:\nIf the PWM duty cycle value is longer than the PWM period, the CCP1 pin will not be cleared.",
    "13.5.3 SETUP FOR PWM OPERATION\nThe following steps should be taken when configuring the CCP module for PWM operation:\n1. Set  the  PWM  period  by  writing  to  the  PR2 register.\n3. Make the CCP1 pin an output by clearing the TRISC<2> bit.\n4. Set the TMR2 prescale value and enable Timer2 by writing to T2CON.\n5. Configure the CCP1 module for PWM operation.\n2. Set  the  PWM  duty  cycle  by  writing  to  the CCPR1L register and CCP1CON<5:4> bits.",
    "TABLE 13-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.77 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.25 kHz = 1. Timer Prescaler (1, 4, 16), 312.50 kHz = 1. Timer Prescaler (1, 4, 16), 416.67 kHz = 1. PR2 Value, 2.44 kHz = 0xFF. PR2 Value, 9.77 kHz = 0xFF. PR2 Value, 39.06 kHz = 0xFF. PR2 Value, 156.25 kHz = 0x3F. PR2 Value, 312.50 kHz = 0x1F. PR2 Value, 416.67 kHz = 0x17. Maximum Resolution (bits), 2.44 kHz = 14. Maximum Resolution (bits), 9.77 kHz = 12. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits),",
    "TABLE 13-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\n156.25 kHz = 8. Maximum Resolution (bits), 312.50 kHz = 7. Maximum Resolution (bits), 416.67 kHz = 6.58",
    "TABLE 13-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR1, Bit 7 = PSPIF ( 1 ). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 13-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other RESETS = 0000. PIR1, Value on all other RESETS = 0000. PIE1, Bit 7 = PSPIE ( 1 ). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other RESETS = 0000. PIE1, Value on all other RESETS = 0000. IPR1, Bit 7 = PSPIP ( 1 ). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 13-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on all other RESETS = 0000. IPR1, Value on all other RESETS = 0000. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other RESETS = 1111. TRISC, Value on all other RESETS = 1111. TMR2, Bit 7",
    "TABLE 13-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Value on all other RESETS = 0000. TMR2, Value on all other RESETS = 0000. PR2, Bit 7 = Timer2 Module Period Register. PR2, Bit 6 = Timer2 Module Period Register. PR2, Bit 5 = Timer2 Module Period Register. PR2, Bit 4 = Timer2 Module Period Register. PR2, Bit 3 = Timer2 Module Period Register. PR2, Bit 2 = Timer2 Module Period Register. PR2, Bit 1 = Timer2 Module Period Register.",
    "TABLE 13-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nPR2, Bit 0 = Timer2 Module Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. PR2, Value on all other RESETS = 1111. PR2, Value on all other RESETS = 1111. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Value on all other RESETS = -000. T2CON, Value on all other RESETS = 0000. CCPR1L, Bit 7 = Capture/Compare/PWM Register1 (LSB).",
    "TABLE 13-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCPR1L, Bit 6 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 5 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 4 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 3 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 2 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 1 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 0 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other RESETS = uuuu. CCPR1L, Value on all other RESETS = uuuu. CCPR1H, Bit 7 = Capture/Compare/PWM Register1 (MSB).",
    "TABLE 13-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCPR1H, Bit 6 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 5 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 4 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 3 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 2 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 1 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 0 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other RESETS = uuuu. CCPR1H, Value on all other RESETS = uuuu. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -.",
    "TABLE 13-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = --00. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on all other RESETS = --00. CCP1CON, Value on all other RESETS = 0000. CCPR2L, Bit 7 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 6 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 5 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 4 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 3 =",
    "TABLE 13-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCapture/Compare/PWM Register2 (LSB). CCPR2L, Bit 2 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 1 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 0 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on all other RESETS = uuuu. CCPR2L, Value on all other RESETS = uuuu. CCPR2H, Bit 7 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 6 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 5 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 4 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 3 =",
    "TABLE 13-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCapture/Compare/PWM Register2 (MSB). CCPR2H, Bit 2 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 1 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 0 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on all other RESETS = uuuu. CCPR2H, Value on all other RESETS = uuuu. CCP2CON, Bit 7 = -. CCP2CON, Bit 6 = -. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 =",
    "TABLE 13-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCP2M0. CCP2CON, Value on POR, BOR = --00. CCP2CON, Value on POR, BOR = 0000. CCP2CON, Value on all other RESETS = --00. CCP2CON, Value on all other RESETS = 0000\nLegend: x = unknown, u = unchanged, - = unimplemented, read as '0'. Shaded cells are not used by PWM and Timer2.\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices. Always maintain these bits clear.",
    "PIC18CXX2\nNOTES:",
    "14.1 Master SSP (MSSP) Module Overview\nThe Master Synchronous Serial Port (MSSP) module is a serial interface useful for communicating with other peripheral or microcontroller devices. These peripheral devices may be Serial EEPROMs, shift registers, display drivers, A/D converters, etc. The MSSP module can operate in one of two modes:\n\u00b7 Serial Peripheral Interface (SPI TM )\n\u00b7 Inter-Integrated Circuit (I C TM ) 2\n-Full Master mode\n-Slave mode (with general address call)\nThe  I 2 C  interface  supports  the  following  modes  in hardware:\n\u00b7 Master mode\n\u00b7 Multi-Master mode\n\u00b7 Slave mode",
    "14.2 Control Registers\nThe  MSSP  module  has  three  associated  registers.\nThese  include  a  status  register  (SSPSTAT)  and  two control registers (SSPCON1 and SSPCON2).",
    "REGISTER 14-1: SSPSTAT: MSSP STATUS REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "bit 7 SMP: Sample bit\nSPI Master mode:\n1 = Input data sampled at end of data output time\n0 = Input data sampled at middle of data output time\nSPI Slave mode:\nSMP must be cleared when SPI is used in Slave mode\nIn I  C 2 Master or Slave mode:\n1 = Slew rate control disabled for standard speed mode (100 kHz and 1 MHz)\n0 = Slew rate control enabled for high speed mode (400 kHz)",
    "bit 6 CKE: SPI Clock Edge Select bit\nCKP = 0:\n1 = Data transmitted on rising edge of SCK\n0 = Data transmitted on falling edge of SCK",
    "CKP = 1:\n1 = Data transmitted on falling edge of SCK\n0 = Data transmitted on rising edge of SCK\nD/A: Data/Address bit (I 2 C mode only)\n1 = Indicates that the last byte received or transmitted was data\n0 = Indicates that the last byte received or transmitted was address",
    "bit 4 P: STOP bit\n(I 2 C mode only. This bit is cleared when the MSSP module is disabled, SSPEN is cleared.)\n1 = Indicates that a STOP bit has been detected last (this bit is '0' on RESET)\n0 = STOP bit was not detected last\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 14-1: SSPSTAT: MSSP STATUS REGISTER  (CONTINUED)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "bit 3 S: START bit\n(I 2 C mode only. This bit is cleared when the MSSP module is disabled, SSPEN is cleared.)\n1 = Indicates that a START bit has been detected last (this bit is '0' on RESET)\n0 = START bit was not detected last",
    "bit 2 R/W: Read/Write bit information (I 2 C mode only)\nThis bit holds the R/W bit information following the last address match. This bit is only valid from the address match to the next START bit, STOP bit, or not ACK bit.\nIn I  C 2 Slave mode:\n1 = Read\n0 = Write",
    "In I  C 2 Master mode:\n1 = Transmit is in progress\n0 = Transmit is not in progress\nOR-ing this bit with SEN, RSEN, PEN, RCEN, or ACKEN will indicate if the MSSP is in\nIDLE mode.",
    "bit 1 UA: Update Address bit (10-bit I 2 C mode only)\n1 = Indicates that the user needs to update the address in the SSPADD register\n0 = Address does not need to be updated",
    "bit 0 BF: Buffer Full Status bit\nReceive (SPI and I  C 2 modes):\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty",
    "Transmit ( I  C 2 mode only):\n1 = Data transmit in progress (does not include the ACK and STOP bits), SSPBUF is full\n0 = Data transmit complete (does not include the ACK and STOP bits), SSPBUF is empty\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 14-2: SSPCON1: MSSP CONTROL REGISTER1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0",
    "Master mode:\n1 = A write to the SSPBUF register was attempted while the I C conditions were not valid for a 2 transmission to be started\n0 = No collision",
    "Slave mode:\n1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision",
    "In SPI mode:\n1 = A new byte is received while the SSPBUF register is still holding the previous data. In case of overflow, the data in SSPSR is lost. Overflow can only occur in Slave mode.\nIn Slave mode, the user must read the SSPBUF, even if only transmitting data to avoid setting overflow.\nIn Master mode, the overflow bit is not set, since each new reception (and transmission) is initiated by writing to the SSPBUF register (must be cleared in software).\n0 = No overflow",
    "In I  C 2 mode:\n1 = A byte is received while the SSPBUF register is still holding the previous byte. SSPOV is a 'don't care' in Transmit mode (must be cleared in software).\n0 = No overflow\nSSPEN: Synchronous Serial Port Enable bit\nIn both modes when enabled, these pins must be properly configured as input or output.",
    "In SPI mode:\n1 = Enables serial port and configures SCK, SDO, SDI, and SS as the source of the serial port pins\n0 = Disables serial port and configures these pins as I/O port pins",
    "In I  C 2 mode:\n1 = Enables the serial port and configures the SDA and SCL pins as the source of the serial port pins\n0 = Disables serial port and configures these pins as I/O port pins",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 5",
    "REGISTER 14-2: SSPCON1: MSSP CONTROL REGISTER1   (CONTINUED)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0",
    "bit 4 CKP: Clock Polarity Select bit\nIn SPI mode:\n1 = Idle state for clock is a high level\n0 = Idle state for clock is a low level\nIn I  C 2 Slave mode:\nSCK release control\n1 = Enable clock\n0 = Holds clock low (clock stretch). (Used to ensure data setup time.)\nIn I  C 2 Master mode:\nUnused in this mode\nSSPM3:SSPM0:\nSynchronous Serial Port Mode Select bits\n0000 = SPI Master mode, clock = FOSC/4\n0001 = SPI Master mode, clock = FOSC/16\n0010 = SPI Master mode, clock = FOSC/64\n0011 = SPI Master mode, clock = TMR2 output/2\n0100 = SPI Slave mode, clock = SCK pin. SS pin control enabled.\n0101 = SPI Slave mode, clock = SCK pin. SS pin control disabled. SS can be used as I/O pin.\n0110 = I 2 C Slave mode, 7-bit address\n0111 = I 2 C Slave mode, 10-bit address",
    "bit 4 CKP: Clock Polarity Select bit\n1000 = I 2 C Master mode, clock = FOSC / (4 * (SSPADD+1))\n1001 = Reserved\n1010 = Reserved\n1011 = I 2 C firmware controlled Master mode (Slave idle)\n1100 = Reserved\n1101 = Reserved\n1110 = I 2 C Slave mode, 7-bit address with START and STOP bit interrupts enabled\n1111 = I 2 C Slave mode, 10-bit address with START and STOP bit interrupts enabled",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 3-0",
    "REGISTER 14-3: SSPCON2: MSSP CONTROL REGISTER2\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. GCEN, 1 = ACKSTAT. GCEN, 2 = ACKDT. GCEN, 3 = ACKEN. GCEN, 4 = RCEN. GCEN, 5 = PEN. GCEN, 6 = RSEN. GCEN, 7 = SEN\nbit 7\nbit 0\nbit 7 GCEN: General Call Enable bit (In I 2 C Slave mode only)\n1 = Enable interrupt when a general call address (0000h) is received in the SSPSR\n0 = General call address disabled",
    "bit 6 ACKSTAT: Acknowledge Status bit (In I 2 C Master mode only)\nIn Master Transmit mode:\n1 = Acknowledge was not received from slave\n0 = Acknowledge was received from slave",
    "bit 5 ACKDT: Acknowledge Data bit (In I 2 C Master mode only)\nIn Master Receive mode:\nValue that will be transmitted when the user initiates an Acknowledge sequence at the end of a receive.\n1 = Not Acknowledge\n0 = Acknowledge\nbit 4 ACKEN: Acknowledge Sequence Enable bit (In I 2 C Master mode only)\nIn Master Receive mode:\n1 = Initiate Acknowledge sequence on SDA and SCL pins, and transmit ACKDT data bit. Automatically cleared by hardware.\n0 = Acknowledge sequence idle",
    "bit 3 RCEN: Receive Enable bit (In I 2 C Master mode only)\n1 = Enables Receive mode for I 2 C\n0 = Receive idle\nbit 2 PEN: STOP Condition Enable bit (In I 2 C Master mode only)\nSCK Release Control:\n1 = Initiate STOP condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = STOP condition idle\nbit 1 RSEN: Repeated START Condition Enabled bit (In I 2 C Master mode only)\n1 = Initiate Repeated START condition on SDA and SCL pins.\nAutomatically cleared by hardware.\n0 = Repeated START condition idle\nbit 0 SEN: START Condition Enabled bit (In I 2 C Master mode only)\n1 = Initiate START condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = START condition idle\nNote: For bits ACKEN, RCEN, PEN, RSEN, SEN:  If the I 2 C module is not in the Idle mode, this bit may not be set (no spooling) and the SSPBUF may not be written (or writes to the SSPBUF are disabled).",
    "bit 3 RCEN: Receive Enable bit (In I 2 C Master mode only)\n- n = Value at POR reset, W=Writable bit = '1' = Bit is set. - n = Value at POR reset, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR reset, read as '0' = x = Bit is unknown",
    "14.3 SPI Mode\nThe SPI mode allows 8-bits of data to be synchronously transmitted and received simultaneously. All four modes of SPI are supported. To accomplish communication, typically three pins are used:\n\u00b7 Serial Data Out (SDO) - RC5/SDO\n\u00b7 Serial Data In (SDI) - RC4/SDI/SDA\n\u00b7 Serial Clock (SCK) - RC3/SCK/SCL/LVOIN\nAdditionally, a fourth pin may be used when in a Slave mode of operation:\n- \u00b7 Slave Select (SS) - RA5/SS/AN4",
    "14.3.1 OPERATION\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control  bits  (SSPCON1<5:0>)  and  SSPSTAT<7:6>. These control bits allow the following to be specified:\n\u00b7 Master mode (SCK is the clock output)\n\u00b7 Slave mode (SCK is the clock input)\n\u00b7 Clock Polarity (Idle state of SCK)\n\u00b7 Data input sample phase (middle or end of data output time)\n\u00b7 Clock edge (output data on rising/falling edge of SCK)\n\u00b7 Clock Rate (Master mode only)\n\u00b7 Slave Select mode (Slave mode only)\nFigure 14-1  shows  the  block  diagram  of  the  MSSP module, when in SPI mode.",
    "(SPI MODE)\nThe MSSP consists of a transmit/receive shift register (SSPSR) and a buffer register (SSPBUF). The SSPSR shifts the data in and out of the device, MSb first. The SSPBUF holds the data that was written to the SSPSR, until the received data is ready. Once the 8-bits of data have been received, that byte is moved to the SSPBUF register. Then the buffer full detect bit, BF (SSPSTAT<0>), and the interrupt flag bit, SSPIF, are set. This double buffering of the received data (SSPBUF) allows the next byte to start reception before reading the data that was just received. Any write to the SSPBUF register during transmission/reception of data will be ignored, and the write collision detect bit, WCOL (SSPCON1<7>), will be set. User software must clear the WCOL bit so that it can be determined if the following write(s) to the SSPBUF  register completed successfully.",
    "PIC18CXX2\nWhen the application software is expecting to receive valid data, the SSPBUF should be read before the next byte of data to transfer is written to the SSPBUF. Buffer full  bit,  BF  (SSPSTAT<0>),  indicates  when  SSPBUF has been loaded with the received data (transmission is complete). When the SSPBUF is read, the BF bit is cleared. This data may be irrelevant if the SPI is only a transmitter.  Generally  the  MSSP  Interrupt  is  used  to determine when the transmission/reception has completed. The SSPBUF must be read and/or written. If the interrupt method is not going to be used, then software polling can be done to ensure that a write collision does not  occur.  Example 14-1  shows  the  loading  of  the SSPBUF (SSPSR) for data transmission.",
    "EXAMPLE 14-1: LOADING THE SSPBUF (SSPSR) REGISTER\nLOOP, 1 = BTFSS GOTO SSPBUF,. LOOP, 2 = SSPSTAT, BF. LOOP, 3 = ;Has data been received(transmit. MOVF, 1 = LOOP. MOVF, 2 = W. MOVF, 3 = ;No ;WREG reg = contents of SSPBUF. MOVWF, 1 = RXDATA. MOVWF, 2 = . MOVWF, 3 = ;Save in user RAM, if data is meaningful. MOVF, 1 = TXDATA,. MOVF, 2 = W. MOVF, 3 = ;W reg = contents of TXDATA. MOVWF, 1 = . MOVWF, 2 = . MOVWF, 3 = ;New data to xmit. , 1 = SSPBUF. , 2 = . , 3 = \nThe SSPSR is not directly readable or writable,  and can only be accessed by addressing the SSPBUF register. Additionally, the MSSP status register (SSPSTAT) indicates the various status conditions.",
    "14.3.2 ENABLING SPI I/O\nTo  enable  the  serial  port,  SSP  enable  bit,  SSPEN (SSPCON1<5>), must be set. To reset or reconfigure SPI  mode,  clear the SSPEN  bit,  re-initialize the SSPCON registers, and then set the SSPEN bit. This configures the SDI, SDO, SCK, and SS pins as serial port pins. For the pins to behave as the serial port function,  some must have their data direction bits (in the TRIS register) appropriately programmed. That is:\n\u00b7 SDI is automatically controlled by the SPI module\n\u00b7 SDO must have TRISC<5> bit cleared\n\u00b7 SCK (Master mode) must have TRISC<3> bit cleared\n\u00b7 SCK (Slave mode) must have TRISC<3> bit set\n\u00b7 SS must have TRISC<4> bit set\nAny serial port function that is not desired may be overridden by programming the corresponding data direction (TRIS) register to the opposite value.",
    "14.3.3 TYPICAL CONNECTION\nFigure 14-2 shows a typical connection between two microcontrollers. The  master controller (Processor 1) initiates the data transfer by sending the SCK signal. Data is shifted out of both shift registers on their programmed  clock  edge,  and  latched  on  the  opposite edge  of  the  clock.  Both  processors  should  be  programmed to same Clock Polarity (CKP), then both con- trollers would send and receive data at the same time. Whether  the  data  is  meaningful  (or  dummy  data) depends  on  the  application  software.  This  leads  to three scenarios for data transmission:\n\u00b7 Master sends data - Slave sends dummy data \uf020 \uf020\n\u00b7 Master sends data - Slave sends data \uf020 \uf020\n\u00b7 Master sends dummy data - Slave sends data \uf020 \uf020",
    "14.3.4 MASTER MODE\nThe master can initiate the data transfer at any time because it controls the SCK. The master determines when the slave (Processor 2, Figure 14-2) is to broadcast data by the software protocol.\nIn  Master  mode,  the  data  is  transmitted/received  as soon as the SSPBUF register is written to. If the SPI is only  going  to  receive,  the  SDO  output  could  be  disabled (programmed as an input). The SSPSR register will continue to shift in the signal present on the SDI pin at the programmed  clock  rate.  As  each  byte is received, it will be loaded into the SSPBUF register as if  a  normal  received  byte  (interrupts  and  status  bits appropriately  set).  This  could  be  useful  in  receiver applications as a 'Line Activity Monitor' mode.\nFigure 14-3, Figure 14-5, and Figure 14-6, where the MSB is transmitted first. In Master mode, the SPI clock rate (bit rate) is user programmable to be one of the following:",
    "14.3.4 MASTER MODE\n\u00b7 FOSC/4 (or TCY)\n\u00b7 FOSC/16 (or 4 \u00b7 TCY)\n\u00b7 FOSC/64 (or 16 \u00b7 TCY)\n\u00b7 Timer2 output/2\nThis allows a maximum data rate (at 40 MHz) of 10.00 Mbps.\nThe clock polarity is selected by appropriately programming  the  CKP  bit  (SSPCON1<4>).  This  then,  would give  waveforms  for  SPI  communication  as  shown  in\nFigure 14-3  shows  the  waveforms  for  Master  mode. When the CKE bit is set, the SDO data is valid before there is a clock edge on SCK. The change of the input sample is shown based on the state of the SMP bit. The time  when  the  SSPBUF  is  loaded  with  the  received data is shown.\nFIGURE 14-3: SPI MODE WAVEFORM (MASTER MODE)",
    "14.3.5 SLAVE MODE\nIn Slave mode, the data is transmitted and received as the external clock pulses appear on SCK. When the last bit is latched, the SSPIF interrupt flag bit is set.\nWhile in Slave mode, the external clock is supplied by the external clock source on the SCK pin. This external clock must meet the minimum high and low times as specified in the electrical specifications.\nWhile in SLEEP mode, the slave can transmit/receive data. When a byte is received, the device will wake-up from SLEEP.",
    "14.3.6 SLAVE SELECT SYNCHRONIZATION\nthe SDO pin is no longer driven, even if in the middle  of  a  transmitted  byte,  and  becomes  a  floating output.  External  pull-up/pull-down  resistors  may  be desirable, depending on the application.\nNote 1: When the SPI is in Slave mode with SS pin control enabled  (SSPCON<3:0>  = 0100 ), the SPI module will reset if the SS pin is set to VDD.\n2: If the SPI is used in Slave mode with CKE set,  then  the  SS  pin  control  must  be enabled.\nWhen the SPI module resets, the bit counter is forced to 0. This can be done by either forcing the SS pin to a high level, or clearing the SSPEN bit.\nThe SS pin allows a Synchronous Slave mode. The SPI  must  be  in  Slave  mode  with  SS  pin  control enabled (SSPCON1<3:0> = 04h). The pin must not be driven low for the SS pin to function as an input. The Data Latch must be high. When the SS pin is low,  transmission  and  reception  are  enabled  and the SDO pin is driven. When the SS pin goes high,",
    "14.3.6 SLAVE SELECT SYNCHRONIZATION\nTo emulate two-wire communication, the SDO pin can be connected to the SDI pin. When the SPI needs to operate as a receiver, the SDO pin can be configured as an input. This disables transmissions from the SDO. The SDI can always be left as an input (SDI function), since it cannot create a bus conflict.\nFIGURE 14-4: SLAVE SYNCHRONIZATION WAVEFORM",
    "PIC18CXX2\nFIGURE 14-5:",
    "SPI MODE WAVEFORM (SLAVE MODE WITH CKE = 0)\nFIGURE 14-6:\nSPI MODE WAVEFORM (SLAVE MODE WITH CKE = 1)",
    "14.3.7 SLEEP OPERATION\nIn Master mode, all module clocks are halted, and the transmission/reception will remain in that state until the device wakes from SLEEP. After the device returns to normal  mode,  the  module  will  continue  to  transmit/ receive data.\nIn Slave mode, the SPI transmit/receive shift register operates asynchronously to the device. This allows the device to be placed in SLEEP mode, and data to be shifted into the  SPI  transmit/receive  shift  register. When all 8-bits have been received, the MSSP interrupt  flag  bit  will  be  set  and  if  enabled,  will  wake  the device from SLEEP.",
    "14.3.9 BUS MODE COMPATIBILITY\nTable 14-1 shows the compatibility between the standard SPI modes and the states of the CKP and CKE control bits.",
    "TABLE 14-1: SPI BUS MODES\n0, 0, Control Bits State.CKP = 0. 0, 0, Control Bits State.CKE = 1. 0, 1, Control Bits State.CKP = 0. 0, 1, Control Bits State.CKE = 0. 1, 0, Control Bits State.CKP = 1. 1, 0, Control Bits State.CKE = 1. 1, 1, Control Bits State.CKP = 1. 1, 1, Control Bits State.CKE = 0\nA RESET disables the MSSP module and terminates the current transfer.\nThere is also a SMP bit which controls when the data is sampled.",
    "TABLE 14-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR1, Bit 7 = PSPIF ( 1 ). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000 0000. PIR1, Value on all other",
    "TABLE 14-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nRESETS = 0000. PIR1, Value on all other RESETS = 0000. PIE1, Bit 7 = PSPIE ( 1 ). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000. PIE1, Value on all other RESETS = 0000. PIE1, Value on all other RESETS = 0000. IPR1, Bit 7 = PSPIP ( 1 ). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR,",
    "TABLE 14-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nBOR = 0000 0000. IPR1, Value on all other RESETS = 0000. IPR1, Value on all other RESETS = 0000. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111 1111. TRISC, Value on all other RESETS = 1111. TRISC, Value on all other RESETS = 1111. SSPBUF, Bit 7 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 6 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 5 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 4 = Synchronous",
    "TABLE 14-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nSerial Port Receive Buffer/Transmit Register. SSPBUF, Bit 3 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 2 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 1 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 0 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Value on POR, BOR = xxxx xxxx. SSPBUF, Value on all other RESETS = uuuu. SSPBUF, Value on all other RESETS = uuuu. SSPCON, Bit 7 = WCOL. SSPCON, Bit 6 = SSPOV. SSPCON, Bit 5 = SSPEN. SSPCON, Bit 4 = CKP. SSPCON, Bit 3 = SSPM3. SSPCON, Bit 2 = SSPM2. SSPCON, Bit 1 = SSPM1. SSPCON, Bit 0 = SSPM0. SSPCON, Value on POR, BOR = 0000 0000. SSPCON, Value",
    "TABLE 14-2: REGISTERS ASSOCIATED WITH SPI OPERATION\non all other RESETS = 0000. SSPCON, Value on all other RESETS = 0000. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data Direction Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = --11 1111. TRISA, Value on all other RESETS = --11. TRISA, Value on all other RESETS = 1111. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR,",
    "TABLE 14-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nBOR = 0000 0000. SSPSTAT, Value on all other RESETS = 0000. SSPSTAT, Value on all other RESETS = 0000\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by the MSSP in SPI mode. -\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices. Always maintain these bits clear.",
    "14.4 MSSP I 2 C Operation\nThe MSSP module in I 2 C mode, fully implements all master and slave functions (including general call support) and provides interrupts on START and STOP bits in hardware to determine a free bus (multi-master function).  The  MSSP  module  implements  the  standard mode  specifications, as well as 7-bit and  10-bit addressing.\nTwo pins are used for data transfer. These are the RC3/ SCK/SCL pin, which is the clock (SCL), and the RC4/ SDI/SDA pin, which is the data (SDA). The user must configure these pins as inputs or outputs through the TRISC<4:3> bits.\nThe  MSSP  module  functions  are  enabled  by  setting MSSP enable bit SSPEN (SSPCON<5>).",
    "FIGURE 14-7: MSSP BLOCK DIAGRAM (I 2 C MODE)\nThe MSSP module has six registers for I 2 C operation. These are the:\n\u00b7 MSSP Control Register1 (SSPCON1)\n\u00b7 MSSP Control Register2 (SSPCON2)\n\u00b7 MSSP Status Register (SSPSTAT)\n\u00b7 Serial Receive/Transmit Buffer (SSPBUF)\n\u00b7 MSSP Shift Register (SSPSR) - Not directly accessible\n\u00b7 MSSP Address Register (SSPADD)\nThe SSPCON1 register allows control of the I 2 C operation. Four mode selection bits (SSPCON<3:0>) allow one of the following I 2 C modes to be selected:\n\u00b7 I 2 C Master mode, clock = OSC/4 (SSPADD +1)\n\u00b7 I 2 C Slave mode (7-bit address)\n\u00b7 I 2 C Slave mode (10-bit address)\n\u00b7 I 2 C Slave mode (7-bit address), with START and STOP bit interrupts enabled\n\u00b7 I 2 C Slave mode (10-bit address), with START and STOP bit interrupts enabled\n\u00b7 I 2 C Firmware controlled master operation, slave is idle",
    "FIGURE 14-7: MSSP BLOCK DIAGRAM (I 2 C MODE)\nSelection  of  any  I 2 C  mode  with  the  SSPEN  bit  set, forces the SCL and SDA pins to be open drain, provided these pins are programmed to be inputs by setting the appropriate TRISC bits.",
    "14.4.1 SLAVE MODE\nIn Slave mode, the SCL and SDA pins must be configured as inputs (TRISC<4:3> set). The MSSP module will override the input state with the output data when required (slave-transmitter).\nWhen an address is matched or the data transfer after an address match is received, the hardware automatically will generate the Acknowledge (ACK) pulse and load the SSPBUF register with the received value currently in the SSPSR register.\nThere are certain conditions that will cause the MSSP module not to give this ACK pulse. These are if either (or both):\na) The  buffer  full  bit  BF  (SSPSTAT<0>)  was  set before the transfer was received.\nb) The overflow bit SSPOV (SSPCON<6>) was set before the transfer was received.\nIn  this  case,  the  SSPSR register value is not loaded into the SSPBUF, but bit SSPIF (PIR1<3>) is set. The BF bit is cleared by reading the SSPBUF register, while bit SSPOV is cleared through software.",
    "14.4.1 SLAVE MODE\nThe SCL clock input must have a minimum high and low for proper operation. The high and low times of the I 2 C  specification,  as  well  as  the  requirement  of  the MSSP module, are shown in timing parameter #100 and parameter #101.",
    "14.4.1.1 Addressing\nOnce the MSSP module has been enabled, it waits for a START condition to occur. Following the START condition, the 8-bits are shifted into the SSPSR register. All incoming bits are sampled with the rising edge of the clock (SCL) line. The value of register SSPSR<7:1> is compared to the value of the SSPADD register. The address is compared on the falling edge of the eighth clock (SCL) pulse. If the addresses match, and the BF and SSPOV bits are clear, the following events occur:\na) The  SSPSR  register  value  is  loaded  into  the SSPBUF register.\nb) The buffer full bit BF is set.\nc) An ACK pulse is generated.\nd) MSSP interrupt flag bit SSPIF (PIR1<3>) is set (interrupt is generated if enabled) on the falling edge of the ninth SCL pulse.",
    "14.4.1.1 Addressing\nIn 10-bit address mode, two address bytes need to be received  by  the  slave.  The  five  Most  Significant  bits (MSbs) of the first address byte specify if this is a 10-bit address. Bit R/W (SSPSTAT<2>) must specify a write so the slave device will receive the second address byte. For a 10-bit address, the first byte would equal ' 1111 0 A9 A8 0 ', where A9 and A8 are the two MSbs of the address. The sequence of events for 10-bit address is as follows, with steps 7-9 for slave-transmitter:",
    "14.4.1.1 Addressing\n1. Receive first (high) byte of Address (bits SSPIF, BF and bit UA (SSPSTAT<1>) are set).\n2. Update the SSPADD register with second (low) byte of Address (clears bit UA and releases the SCL line).\n3. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n4. Receive  second  (low)  byte  of  Address  (bits SSPIF, BF, and UA are set).\n5. Update the SSPADD register with the first (high) byte of Address. If match releases SCL line, this will clear bit UA.\n6. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n7. Receive Repeated START condition.\n8. Receive first (high) byte of Address (bits SSPIF and BF are set).\n9. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.",
    "14.4.1.2 Reception\nWhen the R/W bit of the address byte is clear and an address  match  occurs,  the  R/W  bit  of  the  SSPSTAT register is cleared. The received address is loaded into the SSPBUF register.\nWhen the address byte overflow condition exists, then no  Acknowledge  (ACK)  pulse  is  given.  An  overflow condition is defined as either bit BF (SSPSTAT<0>) is set, or bit SSPOV (SSPCON<6>) is set.\nAn MSSP interrupt is generated for each data transfer byte. Flag bit SSPIF (PIR1<3>) must be cleared in software. The SSPSTAT register is used to determine the status of the byte.",
    "14.4.1.3 Transmission\nWhen the R/W bit of the incoming address byte is set and  an  address  match  occurs,  the  R/W  bit  of  the SSPSTAT  register  is  set.  The  received  address  is loaded into the SSPBUF register. The ACK pulse will be sent on the ninth bit and pin RC3/SCK/SCL is held low. The  transmit data must  be  loaded  into the SSPBUF register, which also loads the SSPSR register. Then pin RC3/SCK/SCL should be enabled by setting bit CKP (SSPCON<4>). The master must monitor the SCL pin prior to asserting another clock pulse. The slave devices may be holding off the master by stretching the clock. The eight data bits are shifted out on the falling  edge  of  the  SCL  input.  This  ensures  that  the SDA  signal is valid during the SCL  high time (Figure 14-9).\nAn MSSP interrupt is generated for each data transfer byte. The SSPIF bit must be cleared in software and the SSPSTAT register is used to determine the status of the byte. The SSPIF bit is set on the falling edge of the ninth clock pulse.",
    "14.4.1.3 Transmission\nAs a slave-transmitter, the ACK  pulse  from the master-receiver  is  latched  on  the  rising  edge  of  the ninth SCL input pulse. If the SDA line is high (not ACK), then the data transfer is complete. When the ACK is latched  by  the  slave,  the  slave  logic  is  reset  (resets SSPSTAT register) and the slave monitors for another occurrence of the START bit. If the SDA line was low (ACK),  the  transmit  data  must  be  loaded  into  the SSPBUF register, which also loads the SSPSR register. Pin RC3/SCK/SCL should be enabled by setting bit CKP.",
    "FIGURE 14-10: I 2 C SLAVE MODE WAVEFORM (TRANSMISSION 10-BIT ADDRESS)\nFIGURE 14-11: I 2 C SLAVE MODE WAVEFORM (RECEPTION 10-BIT ADDRESS)",
    "14.4.2 GENERAL CALL ADDRESS SUPPORT\nThe addressing procedure for the I 2 C bus is such that the first byte after the START condition usually determines which device will be the slave addressed by the master. The exception is the general call address which can address all devices. When this address is used, all devices  should,  in  theory,  respond  with  an  acknowledge.\nThe  general  call  address  is  one  of  eight  addresses reserved for specific purposes by the I 2 C protocol. It consists of all 0's with R/W = 0.\nThe general call address is recognized when the General Call Enable bit (GCEN) is enabled (SSPCON2<7> is set). Following a START bit detect, 8-bits are shifted into the SSPSR and the address is compared against the SSPADD. It is also compared to the general call address and fixed in hardware.\nIf  the  general  call  address  matches,  the  SSPSR  is transferred to the SSPBUF, the BF flag bit is set (eighth bit), and on the falling edge of the ninth bit (ACK bit), the SSPIF interrupt flag bit is set.",
    "14.4.2 GENERAL CALL ADDRESS SUPPORT\nWhen the interrupt is serviced, the source for the interrupt  can  be  checked  by  reading  the  contents  of  the SSPBUF. The value can be used to determine if the address was device specific or a general call address.\nIn 10-bit mode, the SSPADD is required to be updated for the second half of the address to match, and the UA bit is set (SSPSTAT<1>). If the general call address is sampled when the GCEN bit is set, while the slave is configured  in  10-bit  address  mode,  then  the  second half of the address is not necessary, the UA bit will not be set, and the slave will begin receiving data after the Acknowledge (Figure 14-12).",
    "14.4.3 MASTER MODE\nThe following events will cause SSP Interrupt Flag bit, SSPIF, to be set (SSP interrupt, if enabled):\nMaster  mode  of  operation  is  supported  by  interrupt generation on the detection of the START and STOP conditions.  The  STOP  (P)  and  START  (S)  bits  are cleared from a RESET or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set, or the bus is idle, with both the S and P bits clear.\nIn Master mode, the SCL and SDA lines are manipulated by the MSSP hardware.\n\u00b7 START condition\n\u00b7 STOP condition\n\u00b7 Data transfer byte transmitted/received\n\u00b7 Acknowledge Transmit\n\u00b7 Repeated START",
    "14.4.4 I 2 C MASTER MODE SUPPORT\nMaster  mode  is  enabled  by  setting  and  clearing  the appropriate SSPM bits in SSPCON1 and by setting the SSPEN bit. Once Master mode is enabled, the user has six options.\n1. Assert a START condition on SDA and SCL.\n2. Assert  a  Repeated  START  condition  on  SDA and SCL.\n3. Write to the SSPBUF register initiating transmission of data/address.\n4. Generate a STOP condition on SDA and SCL.\n5. Configure the I 2 C port to receive data.\n6. Generate an Acknowledge condition at the end of a received byte of data.",
    "Note:\nThe MSSP module, when configured in I 2 C Master mode, does not allow queueing of events. For instance, the user is not allowed to initiate a START condition and immediately write the SSPBUF register to imitate  transmission,  before  the  START condition  is  complete.  In  this  case,  the SSPBUF  will  not  be  written  to  and  the WCOL bit will be set, indicating that a write to the SSPBUF did not occur.",
    "14.4.4.1 I 2 C Master Mode Operation\nThe  master  device  generates  all  of  the  serial  clock pulses and the START and STOP conditions.   A transfer is ended with a STOP condition or with a Repeated START condition. Since the Repeated START condition is also the beginning of the next serial transfer, the I 2 C bus will not be released.\nIn Master  Transmitter  mode,  serial  data  is  output through SDA, while SCL outputs the serial clock. The first byte transmitted contains the slave address of the receiving device (7 bits) and the Read/Write (R/W) bit. In this case, the R/W bit will be logic '0'. Serial data is transmitted 8 bits at a time. After each byte is transmitted, an Acknowledge bit is received. START and STOP conditions are output to indicate the beginning and the end of a serial transfer.",
    "14.4.4.1 I 2 C Master Mode Operation\nIn Master Receive mode, the first byte transmitted contains  the  slave  address  of  the  transmitting  device (7 bits) and the R/W bit. In this case, the R/W bit will be logic '1'. Thus, the first byte transmitted is a 7-bit slave address followed by a '1' to indicate receive bit. Serial data is received via SDA, while SCL outputs the serial clock. Serial data is received 8 bits at a time. After each byte  is  received,  an  Acknowledge  bit  is  transmitted. START and  STOP  conditions  indicate  the  beginning and end of transmission.\nThe baud rate generator used for the SPI mode operation  is  now  used  to  set  the  SCL  clock  frequency  for either 100 kHz, 400 kHz, or 1 MHz I 2 C operation. The baud rate  generator  reload  value  is  contained  in  the lower  7  bits  of  the  SSPADD  register.  The  baud  rate generator will automatically begin counting on a write to the  SSPBUF.  Once  the  given  operation  is  complete, (i.e.,  transmission  of  the  last  data  bit  is  followed  by ACK), the internal clock will automatically stop counting and the SCL pin will remain in its last state.",
    "14.4.4.1 I 2 C Master Mode Operation\nA typical transmit sequence would go as follows:",
    "14.4.4.1 I 2 C Master Mode Operation\na) The user generates a START condition by setting the START enable bit, SEN (SSPCON2<0>).\nb) SSPIF is set. The MSSP module will wait the required  start  time  before  any  other  operation takes place.\nc) The user loads the SSPBUF with the address to transmit.\nd) Address is shifted out the SDA pin until all 8 bits are transmitted.\ne) The MSSP module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).\nf) The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.\ng) The user loads the SSPBUF with eight bits of data.\nh) Data is shifted out the SDA pin until all 8 bits are transmitted.\ni) The MSSP module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).\nj) The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.",
    "14.4.4.1 I 2 C Master Mode Operation\nk) The user generates a STOP condition by setting the STOP enable bit, PEN (SSPCON2<2>).\nl) Interrupt is generated once the STOP condition is complete.",
    "14.4.5 BAUD RATE GENERATOR\nIn  I 2 C Master mode, the reload value for the BRG is located  in  the  lower  7  bits  of  the  SSPADD  register (Figure 14-14).  When  the  BRG  is  loaded  with  this value,  the  BRG  counts  down  to  0  and  stops  until another reload has taken place. The BRG count is dec- remented twice per instruction cycle (TCY) on the Q2 and  Q4  clocks.  In  I 2 C  Master  mode,  the  BRG  is reloaded  automatically.  If  Clock  Arbitration  is  taking place, for instance, the BRG will be reloaded when the SCL pin is sampled high (Figure 14-15).",
    "14.4.6 I 2 C MASTER MODE START CONDITION TIMING\nTo initiate a START condition, the user sets the START condition enable bit, SEN (SSPCON2<0>). If the SDA and SCL pins are sampled high, the baud rate generator is reloaded with the contents of SSPADD<6:0> and starts its count. If SCL and SDA are both sampled high when the  baud  rate  generator  times  out  (TBRG),  the SDA pin is  driven  low.  The  action  of  the  SDA  being driven low, while SCL is high, is the START condition and causes the S bit (SSPSTAT<3>) to be set. Following this, the baud rate generator is reloaded with the contents  of  SSPADD<6:0>  and  resumes  its  count. When the baud rate generator times out (TBRG), the SEN bit (SSPCON2<0>) will be automatically cleared by  hardware,  the  baud  rate  generator  is  suspended leaving the SDA line held low and the START condition is complete.",
    "Note:\nIf, at the beginning of the START condition, the  SDA and SCL pins are already sampled low, or if during the START condition, the  SCL  line  is  sampled  low  before  the SDA  line  is  driven  low,  a  bus  collision occurs,  the  Bus  Collision  Interrupt  Flag, BCLIF  is  set, the START  condition  is aborted, and the I 2 C module is reset into its IDLE state.",
    "14.4.6.1 WCOL Status Flag\nIf the user writes the SSPBUF  when  a  START sequence is in progress, the WCOL is set and the contents  of  the  buffer  are  unchanged  (the  write  doesn't occur).",
    "Note:\nBecause queueing of events is not allowed,  writing  to  the  lower  5  bits  of SSPCON2  is  disabled  until  the  START condition is complete.",
    "14.4.7 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nA Repeated START condition occurs when the RSEN bit  (SSPCON2<1>) is programmed high and the I 2 C logic module is in the idle state. When the RSEN bit is set, the SCL pin is asserted low. When the SCL pin is sampled low, the baud rate generator is loaded with the contents of SSPADD<5:0> and begins counting. The SDA pin is released (brought high) for one baud rate generator count (T BRG ). When the baud rate generator times out, if SDA is sampled high, the SCL pin will be de-asserted  (brought  high).  When  SCL  is  sampled high, the baud rate generator is reloaded with the contents of SSPADD<6:0> and begins counting. SDA and SCL must be sampled high for one TBRG. This action is then followed by assertion of the SDA pin (SDA = 0) for one TBRG, while SCL is high. Following this, the RSEN bit",
    "14.4.7 I 2 C MASTER MODE REPEATED START CONDITION TIMING\n(SSPCON2<1>) will be automatically cleared and the baud rate generator will not be reloaded, leaving the SDA pin held low. As soon as a START condition is detected on the SDA  and  SCL  pins,  the  S bit (SSPSTAT<3>) will be set. The SSPIF bit will not be set until the baud rate generator has timed out.\nNote 1: If  RSEN is programmed while any other event is in progress, it will not take effect.\n2: A bus collision during the Repeated START condition occurs if:\n\u00b7  SDA is sampled low when SCL goes from low to high.\n\u00b7  SCL goes low before SDA is asserted low. This may indicate that another master is attempting to transmit a data \"1\".",
    "FIGURE 14-17: REPEAT START CONDITION WAVEFORM\nImmediately  following  the  SSPIF  bit  getting  set,  the user may write the SSPBUF with the 7-bit address in 7-bit mode, or the default first address in 10-bit mode. After the first eight bits are transmitted and an ACK is received, the user may then transmit an additional eight bits of address (10-bit mode), or eight bits of data (7-bit mode).",
    "14.4.7.1 WCOL Status Flag\nIf the  user  writes  the  SSPBUF  when  a  Repeated START sequence is in progress, the WCOL is set and the  contents  of  the  buffer  are  unchanged  (the  write doesn't occur).",
    "Note:\nBecause queueing of events is not allowed,  writing  of  the  lower  5  bits  of SSPCON2 is disabled until the Repeated START condition is complete.",
    "14.4.8 I 2 C MASTER MODE TRANSMISSION\nTransmission  of  a  data  byte,  a  7-bit  address,  or  the other half of a 10-bit address, is accomplished by simply writing a value to the SSPBUF register. This action will set the buffer full flag bit, BF, and allow the baud rate  generator  to  begin  counting  and  start  the  next transmission. Each bit of address/data will be shifted out onto the SDA pin after the falling edge of SCL is asserted (see data hold time specification  parameter 106). SCL is held low for one baud rate generator rollover count (TBRG). Data should be valid before SCL is released  high (see Data  setup  time specification parameter 107). When the SCL pin is released high, it is  held  that  way  for  TBRG.  The  data  on  the  SDA  pin must  remain  stable  for  that  duration  and  some",
    "14.4.8 I 2 C MASTER MODE TRANSMISSION\nhold time after the next falling edge of SCL. After the eighth bit is shifted out (the falling edge of the eighth clock), the BF flag is cleared and the master releases SDA. allowing the slave device being addressed to respond with an ACK bit during the ninth bit time, if an address match occurs, or if data was received properly. The status of ACK is written into the ACKDT bit on the falling edge  of  the  ninth  clock.  If  the  master  receives  an Acknowledge, the Acknowledge status bit, ACKSTAT, is cleared. If not, the bit is set. After the ninth clock, the SSPIF bit is set and the master clock (baud rate generator) is suspended until the next data byte is loaded into the  SSPBUF,  leaving  SCL  low  and  SDA  unchanged (Figure 14-18).",
    "14.4.8 I 2 C MASTER MODE TRANSMISSION\nAfter the write to the SSPBUF, each bit of address will be shifted out on the falling edge of SCL until all seven address bits and the R/W bit are completed. On the falling edge of the eighth clock, the master will de-assert the  SDA  pin,  allowing  the  slave  to  respond  with  an Acknowledge. On the falling edge of the ninth clock, the master will sample the SDA pin to see if the address was recognized by a slave. The status of the ACK bit is loaded into the ACKSTAT status bit (SSPCON2<6>). Following the falling edge of the ninth clock transmission of the address, the SSPIF is set, the BF flag is cleared and the baud rate generator is turned off until another write to the SSPBUF takes place, holding SCL low and allowing SDA to float.",
    "14.4.8.1 BF Status Flag\nIn  Transmit  mode,  the  BF  bit  (SSPSTAT<0>)  is  set when the CPU writes to SSPBUF and is cleared, when all 8 bits are shifted out.",
    "14.4.8.2 WCOL Status Flag\nIf  the  user  writes  the  SSPBUF  when  a  transmit  is already in progress, (i.e., SSPSR is still shifting out a data byte), the WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).\nWCOL must be cleared in software.",
    "14.4.8.3 ACKSTAT Status Flag\nIn Transmit mode, the ACKSTAT bit (SSPCON2<6>) is cleared  when  the  slave  has  sent  an  Acknowledge (ACK = 0), and is set when the slave does not Acknowledge (ACK = 1). A slave sends an Acknowledge when it has recognized its address (including a general call), or when the slave has properly received its data.",
    "14.4.9 I 2 C MASTER MODE RECEPTION\nMaster mode reception is enabled by programming the receive enable bit, RCEN (SSPCON2<3>).\nNote:\nThe  MSSP  module  must  be  in  an  IDLE state  before  the  RCEN  bit  is  set,  or  the RCEN bit will be disregarded.\nThe baud rate generator begins counting, and on each rollover, the state of the SCL pin changes (high to low/ low to high) and data is shifted into the SSPSR. After the falling edge of the eighth clock, the receive enable flag is automatically  cleared,  the  contents  of  the SSPSR are loaded into the SSPBUF, the BF flag bit is set, the SSPIF flag bit is set and the baud rate generator is suspended from counting, holding SCL low. The MSSP is now in IDLE state, awaiting  the  next  command. When the buffer is read by the CPU, the BF flag bit is automatically cleared. The user can then send an Acknowledge bit at the end of reception, by setting the Acknowledge sequence enable bit, ACKEN (SSPCON2<4>).",
    "14.4.9.1 BF Status Flag\nIn receive operation, the BF bit is set when an address or data byte is loaded into SSPBUF from SSPSR. It is cleared when the SSPBUF register is read.",
    "14.4.9.2 SSPOV Status Flag\nIn receive operation, the SSPOV bit is set when 8 bits are  received  into  the  SSPSR  and  the  BF  flag  bit  is already set from a previous reception.",
    "14.4.9.3 WCOL Status Flag\nIf the  user  writes  the  SSPBUF  when  a  receive  is already in progress (i.e., SSPSR is still shifting in a data byte), the WCOL bit is set and the contents of the buffer are unchanged (the write doesn't occur).\nFIGURE 14-18: I 2 C MASTER MODE WAVEFORM (TRANSMISSION, 7 OR 10-BIT ADDRESS)",
    "14.4.10 ACKNOWLEDGE SEQUENCE TIMING\nAn  Acknowledge  sequence  is  enabled  by  setting  the Acknowledge sequence enable bit, ACKEN (SSPCON2<4>). When this  bit  is  set,  the  SCL  pin  is pulled low and the contents of the Acknowledge data bit is presented on the SDA pin. If the user wishes to generate an Acknowledge, then the ACKDT bit should be cleared. If not, the user should set the ACKDT bit before starting an Acknowledge sequence. The baud rate generator then counts for one rollover period (TBRG) and the SCL pin is de-asserted (pulled high). When the SCL pin is sampled high (clock arbitration), the baud rate generator counts for TBRG. The SCL pin is then pulled low. Following this, the ACKEN bit is automatically cleared, the baud rate generator is turned off and the MSSP module then goes into IDLE mode (Figure 14-20).",
    "14.4.10.1 WCOL Status Flag\nIf the user writes the SSPBUF when an Acknowledge sequence is  in  progress,  then  WCOL  is  set  and  the contents of the buffer are unchanged (the write doesn't occur).",
    "14.4.11 STOP CONDITION TIMING\nA STOP bit is asserted on the SDA pin at the end of a receive/transmit by setting the STOP sequence enable bit, PEN (SSPCON2<2>). At the end of a receive/transmit, the SCL line is held low after the falling edge of the ninth clock. When the PEN bit is set, the master will assert the SDA line low. When the SDA line is sampled low,  the  baud  rate  generator  is  reloaded  and  counts down to 0. When the baud rate generator times out, the SCL pin will be brought high, and one TBRG (baud rate generator  rollover  count)  later,  the  SDA  pin  will  be de-asserted. When the SDA pin is sampled high while SCL is high, the P bit (SSPSTAT<4>) is set. A TBRG later,  the PEN bit is cleared and the SSPIF bit is set (Figure 14-21).",
    "14.4.11.1 WCOL Status Flag\nIf the user writes the SSPBUF when a STOP sequence is in progress, then the WCOL bit is set and the contents  of  the  buffer  are  unchanged  (the  write  doesn't occur).",
    "14.4.13 SLEEP OPERATION\nClock arbitration occurs when the master, during any receive,  transmit,  or  Repeated  START/STOP  condition, de-asserts the SCL pin (SCL allowed to float high). When the SCL pin is allowed to float high, the baud rate generator (BRG) is suspended from counting until the SCL pin is actually sampled high. When the SCL pin is sampled high, the baud rate generator is reloaded with the  contents  of  SSPADD<6:0>  and  begins  counting. This ensures that the SCL high time will always be at least one BRG rollover count, in the event that the clock is held low by an external device (Figure 14-22).\nWhile  in  SLEEP  mode,  the  I 2 C  module  can  receive addresses  or  data,  and  when  an  address  match  or complete  byte  transfer  occurs,  wake  the  processor from SLEEP (if the MSSP interrupt is enabled).",
    "14.4.14 EFFECT OF A RESET\nA RESET disables the MSSP module and terminates the current transfer.",
    "14.4.15 MULTI-MASTER MODE\nIn Multi-Master mode, the interrupt generation on the detection of  the  START  and  STOP conditions allows the determination of when the bus is free. The STOP (P) and START (S) bits are cleared from a RESET, or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit (SSPSTAT<4>) is set, or the bus is idle with both the S and P bits clear. When the bus is busy, enabling the SSP interrupt will generate the interrupt when the STOP condition occurs.\nIn multi-master operation, the SDA line must be monitored,  for  arbitration,  to  see  if  the  signal  level  is  the expected output level. This check is performed in hardware, with the result placed in the BCLIF bit.\nThe states where arbitration can be lost are:\n\u00b7 Address Transfer\n\u00b7 Data Transfer\n\u00b7 A START Condition\n\u00b7 A Repeated START Condition\n\u00b7 An Acknowledge Condition\n14.4.16 MULTI -MASTER COMMUNICATION, BUS\nCOLLISION, AND BUS ARBITRATION",
    "14.4.15 MULTI-MASTER MODE\nSDA is a '1' and the data sampled on the SDA pin = '0', then a bus collision has taken place. The master will set the Bus Collision Interrupt Flag, BCLIF and reset the I 2 C port to its IDLE state (Figure 14-23).\nIf  a  transmit  was  in  progress  when  the  bus  collision occurred,  the  transmission  is  halted,  the  BF  flag  is cleared, the SDA and SCL lines are de-asserted, and the SSPBUF can be written to. When the user services the bus collision Interrupt Service Routine, and if the I 2 C bus is free, the user can resume communication by asserting a START condition.\nIf a START, Repeated START, STOP, or Acknowledge condition  was  in  progress  when  the  bus  collision occurred, the condition is aborted, the SDA and SCL lines are de-asserted, and the respective control bits in the SSPCON2 register are cleared. When the user services the bus collision Interrupt Service Routine, and if the I 2 C bus is free, the user can resume communication by asserting a START condition.",
    "14.4.15 MULTI-MASTER MODE\nThe master will continue to monitor the SDA and SCL pins. If a STOP condition occurs, the SSPIF bit will be set.\nA write  to  the  SSPBUF  will  start  the  transmission  of data at the first data bit, regardless of where the transmitter left off when the bus collision occurred.\nMulti-Master mode support is achieved by bus arbitration. When the master outputs address/data bits onto the SDA pin, arbitration takes place when the master outputs  a  '1'  on  SDA  by  letting  SDA  float  high  and another master asserts a '0'.   When the SCL pin floats high,  data  should  be  stable.  If  the  expected  data  on\nIn Multi-Master mode, the interrupt generation on the detection of  START and STOP conditions allows the determination of when the bus is free. Control of the I 2 C bus can be taken when the P bit is set in the SSPSTAT register,  or  the  bus  is  idle  and  the  S  and  P  bits  are cleared.",
    "14.4.16.1 Bus Collision During a START Condition\nDuring a START condition, a bus collision occurs if:\na) SDA or SCL are sampled low at the beginning of the START condition (Figure 14-24).\nb) SCL is sampled low before SDA is asserted low (Figure 14-25).\nDuring a START condition, both the SDA and the SCL pins are monitored.\nIf the SDA pin is already low, or the SCL pin is already low, then all of the following occur:\n\u00b7 the START condition is aborted,\n\u00b7 the BCLIF flag is set, and\n\u00b7 the MSSP module is reset to its IDLE state (Figure 14-24).\nThe START condition begins with the SDA and SCL pins de-asserted. When the SDA pin is sampled high, the baud rate generator is loaded from SSPADD<6:0> and counts down to 0. If the SCL pin is sampled low while SDA is high, a bus collision occurs, because it is assumed that another master is attempting to drive a data '1' during the START condition.",
    "14.4.16.1 Bus Collision During a START Condition\nIf  the  SDA  pin  is  sampled  low  during  this  count,  the BRG  is  reset  and  the  SDA  line  is  asserted  early (Figure 14-26). If, however, a '1' is sampled on the SDA pin, the SDA pin is asserted low at the end of the BRG count. The baud rate generator is then reloaded and counts down to 0, and during this time, if the SCL pins are sampled as '0', a bus collision does not occur. At the end of the BRG count, the SCL pin is asserted low.\nNote:\nThe reason that bus collision is not a factor during a START condition, is that no two bus masters can assert a START condition at  the  exact  same  time.  Therefore,  one master will always assert SDA before the other. This condition does not cause a bus collision, because the two masters must be allowed to arbitrate the first address following the START condition. If the address is the  same,  arbitration  must  be  allowed  to continue  into  the  data  portion,  Repeated START, or STOP conditions.",
    "14.4.16.2 Bus Collision During a Repeated START Condition\nDuring  a  Repeated  START condition, a  bus  collision occurs if:\na) A low level is sampled on SDA when SCL goes from low level to high level.\nb) SCL goes low before SDA is asserted low, indicating that another master is attempting to transmit a data '1'.\nWhen the user de-asserts SDA and the pin is allowed to  float  high,  the  BRG  is  loaded  with  SSPADD<6:0> and counts down to 0. The SCL pin is then de-asserted, and when sampled high, the SDA pin is sampled.\nIf SDA is low, a bus collision has occurred (i.e., another master is attempting to transmit a data '0', Figure 14-27).  If  SDA  is  sampled  high,  the  BRG  is reloaded and begins counting. If SDA goes from high to low before the BRG times out, no bus collision occurs because no two masters can assert SDA at exactly the same time.",
    "14.4.16.2 Bus Collision During a Repeated START Condition\nIf SCL goes from high to low before the BRG times out and SDA has not already been asserted, a bus collision occurs.  In  this  case,  another  master  is  attempting  to transmit a data '1' during the Repeated START condition, Figure 14-28.\nIf, at the end of the BRG time-out, both SCL and SDA are still high, the SDA pin is driven low and the BRG is reloaded and begins counting. At the end of the count, regardless of the status of the SCL pin, the SCL pin is driven  low  and  the  Repeated  START  condition  is complete.",
    "14.4.16.3 Bus Collision During a STOP Condition\nBus collision occurs during a STOP condition if:\na) After  the  SDA  pin  has  been  de-asserted  and allowed to float high, SDA is sampled low after the BRG has timed out.\nb) After the SCL pin is de-asserted, SCL is sampled low before SDA goes high.\nThe  STOP  condition  begins  with  SDA  asserted  low. When SDA is sampled low, the SCL pin is allowed to float. When the pin is sampled high (clock arbitration), the baud rate generator is loaded with SSPADD<6:0> and counts down to 0. After the BRG times out, SDA is sampled. If  SDA is  sampled low, a bus collision has occurred. This is due to another master attempting to drive a data '0' (Figure 14-29). If the SCL pin is sampled low before SDA is allowed to float high, a bus collision occurs. This is another case of another master attempting to drive a data '0' (Figure 14-30).",
    "FIGURE 14-30: BUS COLLISION DURING A STOP CONDITION (CASE 2)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nAssert SDA\nSCL goes low before SDA goes high Set BCLIF\n'0'\n'0'",
    "15.0 ADDRESSABLE UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (USART)\nThe USART can be configured in the following modes:\n\u00b7 Asynchronous (full duplex)\n\u00b7 Synchronous - Master (half duplex)\n\u00b7 Synchronous - Slave (half duplex)\nThe  Universal  Synchronous  Asynchronous  Receiver Transmitter (USART) module is one of the two serial I/O modules. (USART is also known as a Serial Communications Interface or SCI.) The USART can be configured as a full duplex asynchronous system that can communicate with peripheral devices, such as CRT terminals and personal computers, or it can be configured as a half-duplex synchronous system that can communicate with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs, etc.\nIn order to configure pins RC6/TX/CK and RC7/RX/DT as the Universal Synchronous Asynchronous Receiver Transmitter:",
    "15.0 ADDRESSABLE UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (USART)\n\u00b7 bit SPEN (RCSTA<7>) must be set (= 1), and\n\u00b7 bits TRISC<7:6> must be cleared (= 0).\nRegister 15-1 shows the Transmit Status and Control Register (TXSTA) and Register 15-2 shows the Receive Status and Control Register (RCSTA).",
    "REGISTER 15-1: TXSTA: TRANSMIT STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = U-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R-1. R/W-0, 7 = R/W-0. CSRC, 1 = TX9. CSRC, 2 = TXEN. CSRC, 3 = SYNC. CSRC, 4 = -. CSRC, 5 = BRGH. CSRC, 6 = TRMT. CSRC, 7 = TX9D\nbit 7\nbit 0",
    "bit 7 CSRC: Clock Source Select bit\nAsynchronous mode:\nDon't care\nSynchronous mode:\n1 = Master mode (clock generated internally from BRG)\n0 = Slave mode (clock from external source)",
    "bit 6 TX9 : 9-bit Transmit Enable bit\n1 = Selects 9-bit transmission\n0 = Selects 8-bit transmission",
    "bit 5 TXEN : Transmit Enable bit\n1 = Transmit enabled\n0 = Transmit disabled\nNote: SREN/CREN overrides TXEN in SYNC mode.",
    "bit 4 SYNC : USART Mode Select bit\n1 = Synchronous mode\n0 = Asynchronous mode\nbit 3\nUnimplemented: Read as '0'",
    "bit 2 BRGH : High Baud Rate Select bit\nAsynchronous mode:\n1 = High speed\n0 = Low speed\nSynchronous mode:\nUnused in this mode\nbit 1\nTRMT : Transmit Shift Register Status bit\n1 = TSR empty\n0 = TSR full\nbit 0 TX9D: 9th bit of transmit data. Can be Address/Data bit or a parity bit.\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 15-2: RCSTA: RECEIVE STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-x. SPEN, 1 = RX9. SPEN, 2 = SREN. SPEN, 3 = CREN. SPEN, 4 = ADDEN. SPEN, 5 = FERR. SPEN, 6 = OERR. SPEN, 7 = RX9D\nbit 7\nbit 0",
    "bit 7 SPEN: Serial Port Enable bit\n1 = Serial port enabled (configures RX/DT and TX/CK pins as serial port pins)\n- 0 = Serial port disabled",
    "bit 6 RX9 : 9-bit Receive Enable bit\n1 = Selects 9-bit reception\n0 = Selects 8-bit reception",
    "bit 5 SREN : Single Receive Enable bit\nAsynchronous mode:\nDon't care\nSynchronous mode - master:\n1 = Enables single receive\n0 = Disables single receive\nThis bit is cleared after reception is complete.\nSynchronous mode - slave:\nUnused in this mode",
    "bit 4 CREN : Continuous Receive Enable bit\nAsynchronous mode:\n1 = Enables continuous receive\n0 = Disables continuous receive",
    "Synchronous mode:\n1 = Enables continuous receive until enable bit CREN is cleared (CREN overrides SREN)\n0 = Disables continuous receive",
    "bit 3 ADDEN : Address Detect Enable bit\nAsynchronous mode 9-bit (RX9 = 1):\n1 = Enables address detection, enable interrupt and load of the receive buffer when RSR<8> is set\n0 = Disables address detection, all bytes are received, and ninth bit can be used as parity bit",
    "bit 2 FERR : Framing Error bit\n1 = Framing error (can be updated by reading RCREG register and receive next valid byte)\n0 = No framing error",
    "bit 1 OERR : Overrun Error bit\n1 = Overrun error (can be cleared by clearing bit CREN)\n0 = No overrun error",
    "bit 0 RX9D: 9th bit of received data, can be Address/Data bit or a parity bit.\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "15.1 USART Baud Rate Generator (BRG)\nThe BRG supports both the Asynchronous and Synchronous modes of the USART. It is a dedicated 8-bit baud rate generator. The SPBRG register controls the period of a free running 8-bit timer. In Asynchronous mode, bit BRGH (TXSTA<2>) also controls the baud rate.  In  Synchronous  mode,  bit  BRGH  is  ignored. Table 15-1  shows the formula for computation of the baud rate for different USART modes, which only apply in Master mode (internal clock).\nGiven  the  desired  baud  rate  and  FOSC,  the  nearest integer value for the SPBRG register can be calculated using the formula in Table 15-1. From this, the error in baud rate can be determined.\nExample 15-1 shows the calculation of the baud rate error for the following conditions:\n\u00b7 FOSC = 16 MHz\n\u00b7 Desired Baud Rate = 9600\n\u00b7 BRGH = 0\n\u00b7 SYNC = 0",
    "15.1 USART Baud Rate Generator (BRG)\nIt  may  be  advantageous  to  use  the  high  baud  rate (BRGH  =  1),  even  for  slower  baud  clocks.  This  is because the FOSC/(16(X + 1)) equation can reduce the baud rate error in some cases.\nWriting a new value to the SPBRG register causes the BRG timer to be reset (or cleared). This ensures the BRG does not wait for a timer overflow before outputting the new baud rate.",
    "15.1.1 SAMPLING\nThe data on the RC7/RX/DT pin is sampled three times by a majority detect circuit to determine if a high or a low level is present at the RX pin.",
    "EXAMPLE 15-1: CALCULATING BAUD RATE ERROR\nDesired Baud Rate, 1 = =. Desired Baud Rate, 2 = FOSC / (64 (X + 1)). Solving for X:, 1 = . Solving for X:, 2 = . X, 1 = =. X, 2 = ( (FOSC / Desired Baud rate) / 64 ) - 1. X, 1 = =. X, 2 = ((16000000 / 9600) / 64) - 1. X, 1 = =. X, 2 = [25.042] = 25. Calculated Baud Rate, 1 = =. Calculated Baud Rate, 2 = 16000000 / (64 (25 + 1)) 9615. Error, 1 = = = =. Error, 2 = (Calculated Baud Rate - Desired Baud Rate) Desired Baud Rate (9615 - 9600) / 9600 0.16%",
    "TABLE 15-1: BAUD RATE FORMULA\n0 1, BRGH = 0 (Low Speed) = (Asynchronous) Baud Rate = FOSC/(64(X+1)) (Synchronous) Baud Rate = FOSC/(4(X+1)). 0 1, BRGH = 1 (High Speed) = Baud Rate = FOSC/(16(X+1)) NA\nLegend: X = value in SPBRG (0 to 255)",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nTXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on all other RESETS = -010. TXSTA, Value on all other RESETS = 0000. TXSTA, Value on all other RESETS = -010. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on all other RESETS = -00x. RCSTA, Value on all other RESETS = 0000. RCSTA,",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nValue on all other RESETS = -00x. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other RESETS = 0000. SPBRG, Value on all other RESETS = 0000. SPBRG, Value on all other RESETS = 0000\nLegend: x = unknown, - = unimplemented, read as '0'. Shaded cells are not used by the BRG.",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n0.3, FOSC = 40 MHz.Actual Rate (K) = NA. 0.3, FOSC = 40 MHz.% Error = -. 0.3, FOSC = 40 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 20 MHz.Actua l Rate (K) = NA. 0.3, FOSC = 20 MHz.% Error = -. 0.3, FOSC = 20 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 16 MHz.Actual Rate (K) = NA. 0.3, FOSC = 16 MHz.% Error = -. 0.3, FOSC = 16 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 10 MHz.Actual Rate (K) = NA. 0.3, FOSC = 10 MHz.% Error = -. 0.3, FOSC = 10 MHz.SPBRG value (decimal) = -. 1.2, FOSC = 40 MHz.Actual Rate (K)",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n= NA. 1.2, FOSC = 40 MHz.% Error = -. 1.2, FOSC = 40 MHz.SPBRG value (decimal) = -. 1.2, FOSC = 20 MHz.Actua l Rate (K) = NA. 1.2, FOSC = 20 MHz.% Error = -. 1.2, FOSC = 20 MHz.SPBRG value (decimal) = -. 1.2, FOSC = 16 MHz.Actual Rate (K) = NA. 1.2, FOSC = 16 MHz.% Error = -. 1.2, FOSC = 16 MHz.SPBRG value (decimal) = -. 1.2, FOSC = 10 MHz.Actual Rate (K) = NA. 1.2, FOSC = 10 MHz.% Error = -. 1.2, FOSC = 10 MHz.SPBRG value (decimal) = -. 2.4, FOSC = 40 MHz.Actual Rate (K) = NA. 2.4, FOSC = 40 MHz.% Error",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n= -. 2.4, FOSC = 40 MHz.SPBRG value (decimal) = -. 2.4, FOSC = 20 MHz.Actua l Rate (K) = NA. 2.4, FOSC = 20 MHz.% Error = -. 2.4, FOSC = 20 MHz.SPBRG value (decimal) = -. 2.4, FOSC = 16 MHz.Actual Rate (K) = NA. 2.4, FOSC = 16 MHz.% Error = -. 2.4, FOSC = 16 MHz.SPBRG value (decimal) = -. 2.4, FOSC = 10 MHz.Actual Rate (K) = NA. 2.4, FOSC = 10 MHz.% Error = -. 2.4, FOSC = 10 MHz.SPBRG value (decimal) = -. 9.6, FOSC = 40 MHz.Actual Rate (K) = NA. 9.6, FOSC = 40 MHz.% Error = -. 9.6, FOSC = 40",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\nMHz.SPBRG value (decimal) = -. 9.6, FOSC = 20 MHz.Actua l Rate (K) = NA. 9.6, FOSC = 20 MHz.% Error = -. 9.6, FOSC = 20 MHz.SPBRG value (decimal) = -. 9.6, FOSC = 16 MHz.Actual Rate (K) = NA. 9.6, FOSC = 16 MHz.% Error = -. 9.6, FOSC = 16 MHz.SPBRG value (decimal) = -. 9.6, FOSC = 10 MHz.Actual Rate (K) = 9.766. 9.6, FOSC = 10 MHz.% Error = +1.73. 9.6, FOSC = 10 MHz.SPBRG value (decimal) = 255. 19.2, FOSC = 40 MHz.Actual Rate (K) = NA. 19.2, FOSC = 40 MHz.% Error = -. 19.2, FOSC = 40 MHz.SPBRG value (decimal) =",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n-. 19.2, FOSC = 20 MHz.Actua l Rate (K) = 19.53. 19.2, FOSC = 20 MHz.% Error = +1.73. 19.2, FOSC = 20 MHz.SPBRG value (decimal) = 255. 19.2, FOSC = 16 MHz.Actual Rate (K) = 19.23. 19.2, FOSC = 16 MHz.% Error = +0.16. 19.2, FOSC = 16 MHz.SPBRG value (decimal) = 207. 19.2, FOSC = 10 MHz.Actual Rate (K) = 19.23. 19.2, FOSC = 10 MHz.% Error = +0.16. 19.2, FOSC = 10 MHz.SPBRG value (decimal) = 129. 76.8, FOSC = 40 MHz.Actual Rate (K) = 76.92. 76.8, FOSC = 40 MHz.% Error = 0. 76.8, FOSC = 40 MHz.SPBRG value (decimal)",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n= 129. 76.8, FOSC = 20 MHz.Actua l Rate (K) = 76.92. 76.8, FOSC = 20 MHz.% Error = +0.16. 76.8, FOSC = 20 MHz.SPBRG value (decimal) = 64. 76.8, FOSC = 16 MHz.Actual Rate (K) = 76.92. 76.8, FOSC = 16 MHz.% Error = +0.16. 76.8, FOSC = 16 MHz.SPBRG value (decimal) = 51. 76.8, FOSC = 10 MHz.Actual Rate (K) = 75.76. 76.8, FOSC = 10 MHz.% Error = -1.36. 76.8, FOSC = 10 MHz.SPBRG value (decimal) = 32. 96, FOSC = 40 MHz.Actual Rate (K) = 96.15. 96, FOSC = 40 MHz.% Error = 0. 96, FOSC = 40 MHz.SPBRG value (decimal) = 103. 96,",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\nFOSC = 20 MHz.Actua l Rate (K) = 96.15. 96, FOSC = 20 MHz.% Error = +0.16. 96, FOSC = 20 MHz.SPBRG value (decimal) = 51. 96, FOSC = 16 MHz.Actual Rate (K) = 95.24. 96, FOSC = 16 MHz.% Error = -0.79. 96, FOSC = 16 MHz.SPBRG value (decimal) = 41. 96, FOSC = 10 MHz.Actual Rate (K) = 96.15. 96, FOSC = 10 MHz.% Error = +0.16. 96, FOSC = 10 MHz.SPBRG value (decimal) = 25. 300, FOSC = 40 MHz.Actual Rate (K) = 303.03. 300, FOSC = 40 MHz.% Error = -0.01. 300, FOSC = 40 MHz.SPBRG value (decimal) = 32. 300, FOSC = 20 MHz.Actua l Rate (K) = 294.1.",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n300, FOSC = 20 MHz.% Error = -1.96. 300, FOSC = 20 MHz.SPBRG value (decimal) = 16. 300, FOSC = 16 MHz.Actual Rate (K) = 307.69. 300, FOSC = 16 MHz.% Error = +2.56. 300, FOSC = 16 MHz.SPBRG value (decimal) = 12. 300, FOSC = 10 MHz.Actual Rate (K) = 312.5. 300, FOSC = 10 MHz.% Error = +4.17. 300, FOSC = 10 MHz.SPBRG value (decimal) = 7. 500, FOSC = 40 MHz.Actual Rate (K) = 500.00. 500, FOSC = 40 MHz.% Error = 0. 500, FOSC = 40 MHz.SPBRG value (decimal) = 19. 500, FOSC = 20 MHz.Actua l Rate (K) = 500. 500, FOSC = 20 MHz.% Error = 0. 500, FOSC = 20",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\nMHz.SPBRG value (decimal) = 9. 500, FOSC = 16 MHz.Actual Rate (K) = 500. 500, FOSC = 16 MHz.% Error = 0. 500, FOSC = 16 MHz.SPBRG value (decimal) = 7. 500, FOSC = 10 MHz.Actual Rate (K) = 500. 500, FOSC = 10 MHz.% Error = 0. 500, FOSC = 10 MHz.SPBRG value (decimal) = 4. HIGH, FOSC = 40 MHz.Actual Rate (K) = 39.06. HIGH, FOSC = 40 MHz.% Error = -. HIGH, FOSC = 40 MHz.SPBRG value (decimal) = 255. HIGH, FOSC = 20 MHz.Actua l Rate (K) = 5000. HIGH, FOSC = 20 MHz.% Error = -. HIGH, FOSC = 20 MHz.SPBRG value (decimal) = 0. HIGH, FOSC = 16 MHz.Actual Rate (K) = 4000. HIGH, FOSC = 16",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\nMHz.% Error = -. HIGH, FOSC = 16 MHz.SPBRG value (decimal) = 0. HIGH, FOSC = 10 MHz.Actual Rate (K) = 2500. HIGH, FOSC = 10 MHz.% Error = -. HIGH, FOSC = 10 MHz.SPBRG value (decimal) = 0. LOW, FOSC = 40 MHz.Actual Rate (K) = 10000.00. LOW, FOSC = 40 MHz.% Error = -. LOW, FOSC = 40 MHz.SPBRG value (decimal) = 0. LOW, FOSC = 20 MHz.Actua l Rate (K) = 19.53. LOW, FOSC = 20 MHz.% Error = -. LOW, FOSC = 20 MHz.SPBRG value (decimal) = 255. LOW, FOSC = 16 MHz.Actual Rate (K) = 15.625. LOW, FOSC = 16 MHz.% Error = -. LOW, FOSC = 16 MHz.SPBRG value (decimal) = 255. LOW, FOSC = 10",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\nMHz.Actual Rate (K) = 9.766. LOW, FOSC = 10 MHz.% Error = -. LOW, FOSC = 10 MHz.SPBRG value (decimal) = 255",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n0.3, FOSC = 7.15909 MHz.Actual Rate (K) = NA. 0.3, FOSC = 7.15909 MHz.% Error = -. 0.3, FOSC = 7.15909 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 5.0688 MHz.Actual Rate (K) = NA. 0.3, FOSC = 5.0688 MHz.% Error = -. 0.3, FOSC = 5.0688 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 4 MHz.Actual Rate (K) = NA. 0.3, FOSC = 4 MHz.% Error = -. 0.3, FOSC = 4 MHz.SPBRG value (decimal) = --. 0.3, FOSC = 3.579545 MHz.Actual Rate (K) = NA. 0.3, FOSC = 3.579545 MHz.% Error = -. 0.3,",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\nFOSC = 3.579545 MHz.SPBRG value (decimal) = -. 1.2, FOSC = 7.15909 MHz.Actual Rate (K) = NA. 1.2, FOSC = 7.15909 MHz.% Error = -. 1.2, FOSC = 7.15909 MHz.SPBRG value (decimal) = -. 1.2, FOSC = 5.0688 MHz.Actual Rate (K) = NA. 1.2, FOSC = 5.0688 MHz.% Error = -. 1.2, FOSC = 5.0688 MHz.SPBRG value (decimal) = -. 1.2, FOSC = 4 MHz.Actual Rate (K) = NA. 1.2, FOSC = 4 MHz.% Error = -. 1.2, FOSC = 4 MHz.SPBRG value (decimal) = -. 1.2, FOSC = 3.579545 MHz.Actual Rate (K) = NA. 1.2,",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\nFOSC = 3.579545 MHz.% Error = -. 1.2, FOSC = 3.579545 MHz.SPBRG value (decimal) = -. 2.4, FOSC = 7.15909 MHz.Actual Rate (K) = NA. 2.4, FOSC = 7.15909 MHz.% Error = -. 2.4, FOSC = 7.15909 MHz.SPBRG value (decimal) = -. 2.4, FOSC = 5.0688 MHz.Actual Rate (K) = NA. 2.4, FOSC = 5.0688 MHz.% Error = -. 2.4, FOSC = 5.0688 MHz.SPBRG value (decimal) = -. 2.4, FOSC = 4 MHz.Actual Rate (K) = NA. 2.4, FOSC = 4 MHz.% Error = -. 2.4, FOSC = 4 MHz.SPBRG value (decimal) = -. 2.4, FOSC",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n= 3.579545 MHz.Actual Rate (K) = NA. 2.4, FOSC = 3.579545 MHz.% Error = -. 2.4, FOSC = 3.579545 MHz.SPBRG value (decimal) = -. 9.6, FOSC = 7.15909 MHz.Actual Rate (K) = 9.622. 9.6, FOSC = 7.15909 MHz.% Error = +0.23. 9.6, FOSC = 7.15909 MHz.SPBRG value (decimal) = 185. 9.6, FOSC = 5.0688 MHz.Actual Rate (K) = 9.6. 9.6, FOSC = 5.0688 MHz.% Error = 0. 9.6, FOSC = 5.0688 MHz.SPBRG value (decimal) = 131. 9.6, FOSC = 4 MHz.Actual Rate (K) = 9.615. 9.6, FOSC = 4 MHz.%",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\nError = +0.16. 9.6, FOSC = 4 MHz.SPBRG value (decimal) = 103. 9.6, FOSC = 3.579545 MHz.Actual Rate (K) = 9.622. 9.6, FOSC = 3.579545 MHz.% Error = +0.23. 9.6, FOSC = 3.579545 MHz.SPBRG value (decimal) = 92. 19.2, FOSC = 7.15909 MHz.Actual Rate (K) = 19.24. 19.2, FOSC = 7.15909 MHz.% Error = +0.23. 19.2, FOSC = 7.15909 MHz.SPBRG value (decimal) = 92. 19.2, FOSC = 5.0688 MHz.Actual Rate (K) = 19.2. 19.2, FOSC = 5.0688 MHz.% Error = 0. 19.2, FOSC = 5.0688 MHz.SPBRG value",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n(decimal) = 65. 19.2, FOSC = 4 MHz.Actual Rate (K) = 19.231. 19.2, FOSC = 4 MHz.% Error = +0.16. 19.2, FOSC = 4 MHz.SPBRG value (decimal) = 51. 19.2, FOSC = 3.579545 MHz.Actual Rate (K) = 19.04. 19.2, FOSC = 3.579545 MHz.% Error = -0.83. 19.2, FOSC = 3.579545 MHz.SPBRG value (decimal) = 46. 76.8, FOSC = 7.15909 MHz.Actual Rate (K) = 77.82. 76.8, FOSC = 7.15909 MHz.% Error = +1.32. 76.8, FOSC = 7.15909 MHz.SPBRG value (decimal) = 22. 76.8, FOSC = 5.0688 MHz.Actual Rate (K) = 79.2.",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n76.8, FOSC = 5.0688 MHz.% Error = +3.13. 76.8, FOSC = 5.0688 MHz.SPBRG value (decimal) = 15. 76.8, FOSC = 4 MHz.Actual Rate (K) = 76.923. 76.8, FOSC = 4 MHz.% Error = +0.16. 76.8, FOSC = 4 MHz.SPBRG value (decimal) = 12. 76.8, FOSC = 3.579545 MHz.Actual Rate (K) = 74.57. 76.8, FOSC = 3.579545 MHz.% Error = -2.90. 76.8, FOSC = 3.579545 MHz.SPBRG value (decimal) = 11. 96, FOSC = 7.15909 MHz.Actual Rate (K) = 94.20. 96, FOSC = 7.15909 MHz.% Error = -1.88. 96, FOSC = 7.15909",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\nMHz.SPBRG value (decimal) = 18. 96, FOSC = 5.0688 MHz.Actual Rate (K) = 97.48. 96, FOSC = 5.0688 MHz.% Error = +1.54. 96, FOSC = 5.0688 MHz.SPBRG value (decimal) = 12. 96, FOSC = 4 MHz.Actual Rate (K) = 1000. 96, FOSC = 4 MHz.% Error = +4.17. 96, FOSC = 4 MHz.SPBRG value (decimal) = 9. 96, FOSC = 3.579545 MHz.Actual Rate (K) = 99.43. 96, FOSC = 3.579545 MHz.% Error = +3.57. 96, FOSC = 3.579545 MHz.SPBRG value (decimal) = 8. 300, FOSC = 7.15909 MHz.Actual Rate (K) = 298.3. 300, FOSC = 7.15909 MHz.% Error =",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n-0.57. 300, FOSC = 7.15909 MHz.SPBRG value (decimal) = 5. 300, FOSC = 5.0688 MHz.Actual Rate (K) = 316.8. 300, FOSC = 5.0688 MHz.% Error = +5.60. 300, FOSC = 5.0688 MHz.SPBRG value (decimal) = 3. 300, FOSC = 4 MHz.Actual Rate (K) = NA. 300, FOSC = 4 MHz.% Error = -. 300, FOSC = 4 MHz.SPBRG value (decimal) = -. 300, FOSC = 3.579545 MHz.Actual Rate (K) = 298.3. 300, FOSC = 3.579545 MHz.% Error = -0.57. 300, FOSC = 3.579545 MHz.SPBRG value (decimal) = 2. 500, FOSC = 7.15909 MHz.Actual Rate (K) = NA. 500, FOSC =",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n7.15909 MHz.% Error = -. 500, FOSC = 7.15909 MHz.SPBRG value (decimal) = -. 500, FOSC = 5.0688 MHz.Actual Rate (K) = NA. 500, FOSC = 5.0688 MHz.% Error = -. 500, FOSC = 5.0688 MHz.SPBRG value (decimal) = -. 500, FOSC = 4 MHz.Actual Rate (K) = NA. 500, FOSC = 4 MHz.% Error = -. 500, FOSC = 4 MHz.SPBRG value (decimal) = -. 500, FOSC = 3.579545 MHz.Actual Rate (K) = NA. 500, FOSC = 3.579545 MHz.% Error = -. 500, FOSC = 3.579545 MHz.SPBRG value (decimal) = -. HIGH, FOSC = 7.15909 MHz.Actual Rate (K) = 1789.8. HIGH, FOSC =",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n7.15909 MHz.% Error = -. HIGH, FOSC = 7.15909 MHz.SPBRG value (decimal) = 0. HIGH, FOSC = 5.0688 MHz.Actual Rate (K) = 1267. HIGH, FOSC = 5.0688 MHz.% Error = -. HIGH, FOSC = 5.0688 MHz.SPBRG value (decimal) = 0. HIGH, FOSC = 4 MHz.Actual Rate (K) = 100. HIGH, FOSC = 4 MHz.% Error = -. HIGH, FOSC = 4 MHz.SPBRG value (decimal) = 0. HIGH, FOSC = 3.579545 MHz.Actual Rate (K) = 894.9. HIGH, FOSC = 3.579545 MHz.% Error = -. HIGH, FOSC = 3.579545 MHz.SPBRG value (decimal) = 0. LOW, FOSC = 7.15909 MHz.Actual Rate (K) = 6.991. LOW,",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\nFOSC = 7.15909 MHz.% Error = -. LOW, FOSC = 7.15909 MHz.SPBRG value (decimal) = 255. LOW, FOSC = 5.0688 MHz.Actual Rate (K) = 4.950. LOW, FOSC = 5.0688 MHz.% Error = -. LOW, FOSC = 5.0688 MHz.SPBRG value (decimal) = 255. LOW, FOSC = 4 MHz.Actual Rate (K) = 3.906. LOW, FOSC = 4 MHz.% Error = -. LOW, FOSC = 4 MHz.SPBRG value (decimal) = 255. LOW, FOSC = 3.579545 MHz.Actual Rate (K) = 3.496. LOW, FOSC = 3.579545 MHz.% Error = -. LOW, FOSC = 3.579545 MHz.SPBRG value (decimal) = 255",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n0.3, FOSC = 1 MHz.Actual Rate (K) = NA. 0.3, FOSC = 1 MHz.% Error = -. 0.3, FOSC = 1 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 32.768 kHz.Actual Rate (K) = 0.303. 0.3, FOSC = 32.768 kHz.% Error = +1.14. 0.3, FOSC = 32.768 kHz.SPBRG value (decimal) = 26. 1.2, FOSC = 1 MHz.Actual Rate (K) = 1.202. 1.2, FOSC = 1 MHz.% Error = +0.16. 1.2, FOSC = 1 MHz.SPBRG value (decimal) = 207. 1.2, FOSC = 32.768 kHz.Actual Rate (K) = 1.170. 1.2, FOSC = 32.768 kHz.% Error = -2.48. 1.2, FOSC =",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n32.768 kHz.SPBRG value (decimal) = 6. 2.4, FOSC = 1 MHz.Actual Rate (K) = 2.404. 2.4, FOSC = 1 MHz.% Error = +0.16. 2.4, FOSC = 1 MHz.SPBRG value (decimal) = 103. 2.4, FOSC = 32.768 kHz.Actual Rate (K) = NA. 2.4, FOSC = 32.768 kHz.% Error = -. 2.4, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 9.6, FOSC = 1 MHz.Actual Rate (K) = 9.615. 9.6, FOSC = 1 MHz.% Error = +0.16. 9.6, FOSC = 1 MHz.SPBRG value (decimal) = 25. 9.6, FOSC = 32.768 kHz.Actual Rate (K) = NA. 9.6, FOSC = 32.768 kHz.% Error",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n= -. 9.6, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 19.2, FOSC = 1 MHz.Actual Rate (K) = 19.24. 19.2, FOSC = 1 MHz.% Error = +0.16. 19.2, FOSC = 1 MHz.SPBRG value (decimal) = 12. 19.2, FOSC = 32.768 kHz.Actual Rate (K) = NA. 19.2, FOSC = 32.768 kHz.% Error = -. 19.2, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 76.8, FOSC = 1 MHz.Actual Rate (K) = 83.34. 76.8, FOSC = 1 MHz.% Error = +8.51. 76.8, FOSC = 1 MHz.SPBRG value (decimal) = 2. 76.8, FOSC = 32.768 kHz.Actual Rate (K) = NA. 76.8,",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\nFOSC = 32.768 kHz.% Error = -. 76.8, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 96, FOSC = 1 MHz.Actual Rate (K) = NA. 96, FOSC = 1 MHz.% Error = -. 96, FOSC = 1 MHz.SPBRG value (decimal) = -. 96, FOSC = 32.768 kHz.Actual Rate (K) = NA. 96, FOSC = 32.768 kHz.% Error = -. 96, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 300, FOSC = 1 MHz.Actual Rate (K) = NA. 300, FOSC = 1 MHz.% Error = -. 300, FOSC = 1 MHz.SPBRG value (decimal) = -. 300, FOSC = 32.768 kHz.Actual Rate (K) = NA. 300, FOSC = 32.768 kHz.% Error = -. 300, FOSC =",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n32.768 kHz.SPBRG value (decimal) = -. 500, FOSC = 1 MHz.Actual Rate (K) = NA. 500, FOSC = 1 MHz.% Error = -. 500, FOSC = 1 MHz.SPBRG value (decimal) = -. 500, FOSC = 32.768 kHz.Actual Rate (K) = NA. 500, FOSC = 32.768 kHz.% Error = -. 500, FOSC = 32.768 kHz.SPBRG value (decimal) = -. HIGH, FOSC = 1 MHz.Actual Rate (K) = 250. HIGH, FOSC = 1 MHz.% Error = -. HIGH, FOSC = 1 MHz.SPBRG value (decimal) = 0. HIGH, FOSC = 32.768 kHz.Actual Rate (K) = 8.192. HIGH, FOSC = 32.768 kHz.% Error = -. HIGH, FOSC = 32.768 kHz.SPBRG value (decimal) = 0. LOW, FOSC =",
    "TABLE 15-3: BAUD RATES FOR SYNCHRONOUS MODE\n1 MHz.Actual Rate (K) = 0.9766. LOW, FOSC = 1 MHz.% Error = -. LOW, FOSC = 1 MHz.SPBRG value (decimal) = 255. LOW, FOSC = 32.768 kHz.Actual Rate (K) = 0.032. LOW, FOSC = 32.768 kHz.% Error = -. LOW, FOSC = 32.768 kHz.SPBRG value (decimal) = 255",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n0.3, FOSC = 40 MHz.Actual Rate (K) = NA. 0.3, FOSC = 40 MHz.% Error = -. 0.3, FOSC = 40 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 20 MHz.Actual Rate (K) = NA. 0.3, FOSC = 20 MHz.% Error = -. 0.3, FOSC = 20 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 16 MHz.Actual Rate (K) = NA. 0.3, FOSC = 16 MHz.% Error = -. 0.3, FOSC = 16 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 10 MHz.Actual Rate (K) = NA. 0.3, FOSC = 10 MHz.% Error = -. 0.3, FOSC = 10 MHz.SPBRG value (decimal) = -. 1.2, FOSC = 40",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nMHz.Actual Rate (K) = NA. 1.2, FOSC = 40 MHz.% Error = -. 1.2, FOSC = 40 MHz.SPBRG value (decimal) = -. 1.2, FOSC = 20 MHz.Actual Rate (K) = 1.221. 1.2, FOSC = 20 MHz.% Error = +1.73. 1.2, FOSC = 20 MHz.SPBRG value (decimal) = 255. 1.2, FOSC = 16 MHz.Actual Rate (K) = 1.202. 1.2, FOSC = 16 MHz.% Error = +0.16. 1.2, FOSC = 16 MHz.SPBRG value (decimal) = 207. 1.2, FOSC = 10 MHz.Actual Rate (K) = 1.202. 1.2, FOSC = 10 MHz.% Error = +0.16. 1.2, FOSC = 10 MHz.SPBRG value (decimal) = 129. 2.4,",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nFOSC = 40 MHz.Actual Rate (K) = 2.44. 2.4, FOSC = 40 MHz.% Error = -1.70. 2.4, FOSC = 40 MHz.SPBRG value (decimal) = 255. 2.4, FOSC = 20 MHz.Actual Rate (K) = 2.404. 2.4, FOSC = 20 MHz.% Error = +0.16. 2.4, FOSC = 20 MHz.SPBRG value (decimal) = 129. 2.4, FOSC = 16 MHz.Actual Rate (K) = 2.404. 2.4, FOSC = 16 MHz.% Error = +0.16. 2.4, FOSC = 16 MHz.SPBRG value (decimal) = 103. 2.4, FOSC = 10 MHz.Actual Rate (K) = 2.404. 2.4, FOSC = 10 MHz.% Error = +0.16. 2.4, FOSC = 10 MHz.SPBRG value",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n(decimal) = 64. 9.6, FOSC = 40 MHz.Actual Rate (K) = 9.62. 9.6, FOSC = 40 MHz.% Error = -0.16. 9.6, FOSC = 40 MHz.SPBRG value (decimal) = 64. 9.6, FOSC = 20 MHz.Actual Rate (K) = 9.469. 9.6, FOSC = 20 MHz.% Error = -1.36. 9.6, FOSC = 20 MHz.SPBRG value (decimal) = 32. 9.6, FOSC = 16 MHz.Actual Rate (K) = 9.615. 9.6, FOSC = 16 MHz.% Error = +0.16. 9.6, FOSC = 16 MHz.SPBRG value (decimal) = 25. 9.6, FOSC = 10 MHz.Actual Rate (K) = 9.766. 9.6, FOSC = 10 MHz.% Error = +1.73.",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n9.6, FOSC = 10 MHz.SPBRG value (decimal) = 15. 19.2, FOSC = 40 MHz.Actual Rate (K) = 18.94. 19.2, FOSC = 40 MHz.% Error = +1.38. 19.2, FOSC = 40 MHz.SPBRG value (decimal) = 32. 19.2, FOSC = 20 MHz.Actual Rate (K) = 19.53. 19.2, FOSC = 20 MHz.% Error = +1.73. 19.2, FOSC = 20 MHz.SPBRG value (decimal) = 15. 19.2, FOSC = 16 MHz.Actual Rate (K) = 19.23. 19.2, FOSC = 16 MHz.% Error = +0.16. 19.2, FOSC = 16 MHz.SPBRG value (decimal) = 12. 19.2, FOSC = 10 MHz.Actual Rate (K) = 19.53. 19.2, FOSC = 10",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nMHz.% Error = +1.73. 19.2, FOSC = 10 MHz.SPBRG value (decimal) = 7. 76.8, FOSC = 40 MHz.Actual Rate (K) = 78.13. 76.8, FOSC = 40 MHz.% Error = -1.70. 76.8, FOSC = 40 MHz.SPBRG value (decimal) = 7. 76.8, FOSC = 20 MHz.Actual Rate (K) = 78.13. 76.8, FOSC = 20 MHz.% Error = +1.73. 76.8, FOSC = 20 MHz.SPBRG value (decimal) = 3. 76.8, FOSC = 16 MHz.Actual Rate (K) = 83.33. 76.8, FOSC = 16 MHz.% Error = +8.51. 76.8, FOSC = 16 MHz.SPBRG value (decimal) = 2. 76.8, FOSC = 10 MHz.Actual Rate (K) = 78.13.",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n76.8, FOSC = 10 MHz.% Error = +1.73. 76.8, FOSC = 10 MHz.SPBRG value (decimal) = 1. 96, FOSC = 40 MHz.Actual Rate (K) = 89.29. 96, FOSC = 40 MHz.% Error = +7.52. 96, FOSC = 40 MHz.SPBRG value (decimal) = 6. 96, FOSC = 20 MHz.Actual Rate (K) = 104.2. 96, FOSC = 20 MHz.% Error = +8.51. 96, FOSC = 20 MHz.SPBRG value (decimal) = 2. 96, FOSC = 16 MHz.Actual Rate (K) = NA. 96, FOSC = 16 MHz.% Error = -. 96, FOSC = 16 MHz.SPBRG value (decimal) = -. 96, FOSC = 10 MHz.Actual Rate (K) = NA. 96, FOSC = 10 MHz.% Error = -. 96,",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nFOSC = 10 MHz.SPBRG value (decimal) = -. 300, FOSC = 40 MHz.Actual Rate (K) = 312.50. 300, FOSC = 40 MHz.% Error = -4.00. 300, FOSC = 40 MHz.SPBRG value (decimal) = 1. 300, FOSC = 20 MHz.Actual Rate (K) = 312.5. 300, FOSC = 20 MHz.% Error = +4.17. 300, FOSC = 20 MHz.SPBRG value (decimal) = 0. 300, FOSC = 16 MHz.Actual Rate (K) = NA. 300, FOSC = 16 MHz.% Error = -. 300, FOSC = 16 MHz.SPBRG value (decimal) = -. 300, FOSC = 10 MHz.Actual Rate (K) = NA. 300, FOSC = 10 MHz.% Error = -. 300, FOSC = 10 MHz.SPBRG value (decimal) = -. 500, FOSC = 40",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nMHz.Actual Rate (K) = 625.00. 500, FOSC = 40 MHz.% Error = -20.00. 500, FOSC = 40 MHz.SPBRG value (decimal) = 0. 500, FOSC = 20 MHz.Actual Rate (K) = NA. 500, FOSC = 20 MHz.% Error = -. 500, FOSC = 20 MHz.SPBRG value (decimal) = -. 500, FOSC = 16 MHz.Actual Rate (K) = NA. 500, FOSC = 16 MHz.% Error = -. 500, FOSC = 16 MHz.SPBRG value (decimal) = -. 500, FOSC = 10 MHz.Actual Rate (K) = NA. 500, FOSC = 10 MHz.% Error = -. 500, FOSC = 10 MHz.SPBRG value (decimal) = -. HIGH, FOSC = 40 MHz.Actual Rate (K) = 2.44. HIGH, FOSC = 40 MHz.% Error = -. HIGH,",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nFOSC = 40 MHz.SPBRG value (decimal) = 255. HIGH, FOSC = 20 MHz.Actual Rate (K) = 312.5. HIGH, FOSC = 20 MHz.% Error = -. HIGH, FOSC = 20 MHz.SPBRG value (decimal) = 0. HIGH, FOSC = 16 MHz.Actual Rate (K) = 250. HIGH, FOSC = 16 MHz.% Error = -. HIGH, FOSC = 16 MHz.SPBRG value (decimal) = 0. HIGH, FOSC = 10 MHz.Actual Rate (K) = 156.3. HIGH, FOSC = 10 MHz.% Error = -. HIGH, FOSC = 10 MHz.SPBRG value (decimal) = 0. LOW, FOSC = 40 MHz.Actual Rate (K) = 625.00. LOW, FOSC = 40 MHz.% Error = -. LOW, FOSC = 40 MHz.SPBRG value (decimal) = 0. LOW, FOSC = 20 MHz.Actual Rate",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n(K) = 1.221. LOW, FOSC = 20 MHz.% Error = -. LOW, FOSC = 20 MHz.SPBRG value (decimal) = 255. LOW, FOSC = 16 MHz.Actual Rate (K) = 0.977. LOW, FOSC = 16 MHz.% Error = -. LOW, FOSC = 16 MHz.SPBRG value (decimal) = 255. LOW, FOSC = 10 MHz.Actual Rate (K) = 0.6104. LOW, FOSC = 10 MHz.% Error = -. LOW, FOSC = 10 MHz.SPBRG value (decimal) = 255",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n0.3, FOSC = 7.15909 MHz.Actual Rate (K) = NA. 0.3, FOSC = 7.15909 MHz.% Error = -. 0.3, FOSC = 7.15909 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 5.0688 MHz.Actual Rate (K) = 0.31. 0.3, FOSC = 5.0688 MHz.% Error = +3.13. 0.3, FOSC = 5.0688 MHz.SPBRG value (decimal) = 255. 0.3, FOSC = 4 MHz.Actual Rate (K) = 0.3005. 0.3, FOSC = 4 MHz.% Error = -0.17. 0.3, FOSC = 4 MHz.SPBRG value (decimal) = 207. 0.3, FOSC = 3.579545 MHz.Actual Rate (K) = 0.301. 0.3,",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nFOSC = 3.579545 MHz.% Error = +0.23. 0.3, FOSC = 3.579545 MHz.SPBRG value (decimal) = 185. 1.2, FOSC = 7.15909 MHz.Actual Rate (K) = 1.203. 1.2, FOSC = 7.15909 MHz.% Error = +0.23. 1.2, FOSC = 7.15909 MHz.SPBRG value (decimal) = 92. 1.2, FOSC = 5.0688 MHz.Actual Rate (K) = 1.2. 1.2, FOSC = 5.0688 MHz.% Error = 0. 1.2, FOSC = 5.0688 MHz.SPBRG value (decimal) = 65. 1.2, FOSC = 4 MHz.Actual Rate (K) = 1.202. 1.2, FOSC = 4 MHz.% Error = +1.67. 1.2,",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nFOSC = 4 MHz.SPBRG value (decimal) = 51. 1.2, FOSC = 3.579545 MHz.Actual Rate (K) = 1.190. 1.2, FOSC = 3.579545 MHz.% Error = -0.83. 1.2, FOSC = 3.579545 MHz.SPBRG value (decimal) = 46. 2.4, FOSC = 7.15909 MHz.Actual Rate (K) = 2.380. 2.4, FOSC = 7.15909 MHz.% Error = -0.83. 2.4, FOSC = 7.15909 MHz.SPBRG value (decimal) = 46. 2.4, FOSC = 5.0688 MHz.Actual Rate (K) = 2.4. 2.4, FOSC = 5.0688 MHz.% Error = 0. 2.4, FOSC = 5.0688 MHz.SPBRG value (decimal) =",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n32. 2.4, FOSC = 4 MHz.Actual Rate (K) = 2.404. 2.4, FOSC = 4 MHz.% Error = +1.67. 2.4, FOSC = 4 MHz.SPBRG value (decimal) = 25. 2.4, FOSC = 3.579545 MHz.Actual Rate (K) = 2.432. 2.4, FOSC = 3.579545 MHz.% Error = +1.32. 2.4, FOSC = 3.579545 MHz.SPBRG value (decimal) = 22. 9.6, FOSC = 7.15909 MHz.Actual Rate (K) = 9.322. 9.6, FOSC = 7.15909 MHz.% Error = -2.90. 9.6, FOSC = 7.15909 MHz.SPBRG value (decimal) = 11. 9.6, FOSC = 5.0688 MHz.Actual Rate (K) =",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n9.9. 9.6, FOSC = 5.0688 MHz.% Error = +3.13. 9.6, FOSC = 5.0688 MHz.SPBRG value (decimal) = 7. 9.6, FOSC = 4 MHz.Actual Rate (K) = NA. 9.6, FOSC = 4 MHz.% Error = -. 9.6, FOSC = 4 MHz.SPBRG value (decimal) = -. 9.6, FOSC = 3.579545 MHz.Actual Rate (K) = 9.322. 9.6, FOSC = 3.579545 MHz.% Error = -2.90. 9.6, FOSC = 3.579545 MHz.SPBRG value (decimal) = 5. 19.2, FOSC = 7.15909 MHz.Actual Rate (K) = 18.64. 19.2, FOSC = 7.15909 MHz.% Error = -2.90.",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n19.2, FOSC = 7.15909 MHz.SPBRG value (decimal) = 5. 19.2, FOSC = 5.0688 MHz.Actual Rate (K) = 19.8. 19.2, FOSC = 5.0688 MHz.% Error = +3.13. 19.2, FOSC = 5.0688 MHz.SPBRG value (decimal) = 3. 19.2, FOSC = 4 MHz.Actual Rate (K) = NA. 19.2, FOSC = 4 MHz.% Error = -. 19.2, FOSC = 4 MHz.SPBRG value (decimal) = -. 19.2, FOSC = 3.579545 MHz.Actual Rate (K) = 18.64. 19.2, FOSC = 3.579545 MHz.% Error = -2.90. 19.2, FOSC = 3.579545 MHz.SPBRG value (decimal) = 2. 76.8,",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nFOSC = 7.15909 MHz.Actual Rate (K) = NA. 76.8, FOSC = 7.15909 MHz.% Error = -. 76.8, FOSC = 7.15909 MHz.SPBRG value (decimal) = -. 76.8, FOSC = 5.0688 MHz.Actual Rate (K) = 79.2. 76.8, FOSC = 5.0688 MHz.% Error = +3.13. 76.8, FOSC = 5.0688 MHz.SPBRG value (decimal) = 0. 76.8, FOSC = 4 MHz.Actual Rate (K) = NA. 76.8, FOSC = 4 MHz.% Error = -. 76.8, FOSC = 4 MHz.SPBRG value (decimal) = -. 76.8, FOSC = 3.579545 MHz.Actual Rate (K) = NA. 76.8, FOSC = 3.579545 MHz.% Error",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n= -. 76.8, FOSC = 3.579545 MHz.SPBRG value (decimal) = -. 96, FOSC = 7.15909 MHz.Actual Rate (K) = NA. 96, FOSC = 7.15909 MHz.% Error = -. 96, FOSC = 7.15909 MHz.SPBRG value (decimal) = -. 96, FOSC = 5.0688 MHz.Actual Rate (K) = NA. 96, FOSC = 5.0688 MHz.% Error = -. 96, FOSC = 5.0688 MHz.SPBRG value (decimal) = -. 96, FOSC = 4 MHz.Actual Rate (K) = NA. 96, FOSC = 4 MHz.% Error = -. 96, FOSC = 4 MHz.SPBRG value (decimal) = -. 96, FOSC = 3.579545 MHz.Actual Rate (K) = NA. 96, FOSC =",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n3.579545 MHz.% Error = -. 96, FOSC = 3.579545 MHz.SPBRG value (decimal) = -. 300, FOSC = 7.15909 MHz.Actual Rate (K) = NA. 300, FOSC = 7.15909 MHz.% Error = -. 300, FOSC = 7.15909 MHz.SPBRG value (decimal) = -. 300, FOSC = 5.0688 MHz.Actual Rate (K) = NA. 300, FOSC = 5.0688 MHz.% Error = -. 300, FOSC = 5.0688 MHz.SPBRG value (decimal) = -. 300, FOSC = 4 MHz.Actual Rate (K) = NA. 300, FOSC = 4 MHz.% Error = -. 300, FOSC = 4 MHz.SPBRG value (decimal) = -. 300, FOSC = 3.579545 MHz.Actual Rate (K) = NA. 300,",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nFOSC = 3.579545 MHz.% Error = -. 300, FOSC = 3.579545 MHz.SPBRG value (decimal) = -. 500, FOSC = 7.15909 MHz.Actual Rate (K) = NA. 500, FOSC = 7.15909 MHz.% Error = -. 500, FOSC = 7.15909 MHz.SPBRG value (decimal) = -. 500, FOSC = 5.0688 MHz.Actual Rate (K) = NA. 500, FOSC = 5.0688 MHz.% Error = -. 500, FOSC = 5.0688 MHz.SPBRG value (decimal) = -. 500, FOSC = 4 MHz.Actual Rate (K) = NA. 500, FOSC = 4 MHz.% Error = -. 500, FOSC = 4 MHz.SPBRG value (decimal) = -. 500, FOSC = 3.579545 MHz.Actual Rate (K) =",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nNA. 500, FOSC = 3.579545 MHz.% Error = -. 500, FOSC = 3.579545 MHz.SPBRG value (decimal) = -. HIGH, FOSC = 7.15909 MHz.Actual Rate (K) = 111.9. HIGH, FOSC = 7.15909 MHz.% Error = -. HIGH, FOSC = 7.15909 MHz.SPBRG value (decimal) = 0. HIGH, FOSC = 5.0688 MHz.Actual Rate (K) = 79.2. HIGH, FOSC = 5.0688 MHz.% Error = -. HIGH, FOSC = 5.0688 MHz.SPBRG value (decimal) = 0. HIGH, FOSC = 4 MHz.Actual Rate (K) = 62.500. HIGH, FOSC = 4 MHz.% Error = -. HIGH, FOSC = 4 MHz.SPBRG value (decimal) = 0. HIGH, FOSC =",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n3.579545 MHz.Actual Rate (K) = 55.93. HIGH, FOSC = 3.579545 MHz.% Error = -. HIGH, FOSC = 3.579545 MHz.SPBRG value (decimal) = 0. LOW, FOSC = 7.15909 MHz.Actual Rate (K) = 0.437. LOW, FOSC = 7.15909 MHz.% Error = -. LOW, FOSC = 7.15909 MHz.SPBRG value (decimal) = 255. LOW, FOSC = 5.0688 MHz.Actual Rate (K) = 0.3094. LOW, FOSC = 5.0688 MHz.% Error = -. LOW, FOSC = 5.0688 MHz.SPBRG value (decimal) = 255. LOW, FOSC = 4 MHz.Actual Rate (K) = 3.906. LOW, FOSC = 4 MHz.% Error = -. LOW, FOSC = 4",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nMHz.SPBRG value (decimal) = 255. LOW, FOSC = 3.579545 MHz.Actual Rate (K) = 0.2185. LOW, FOSC = 3.579545 MHz.% Error = -. LOW, FOSC = 3.579545 MHz.SPBRG value (decimal) = 255",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n0.3, FOSC = 1 MHz.Actual Rate (K) = 0.300. 0.3, FOSC = 1 MHz.% Error = +0.16. 0.3, FOSC = 1 MHz.SPBRG value (decimal) = 51. 0.3, FOSC = 32.768 kHz.Actual Rate (K) = 0.256. 0.3, FOSC = 32.768 kHz.% Error = -14.67. 0.3, FOSC = 32.768 kHz.SPBRG value (decimal) = 1. 1.2, FOSC = 1 MHz.Actual Rate (K) = 1.202. 1.2, FOSC = 1 MHz.% Error = +0.16. 1.2, FOSC = 1 MHz.SPBRG value (decimal) = 12. 1.2, FOSC = 32.768 kHz.Actual Rate (K) = NA. 1.2, FOSC = 32.768 kHz.% Error = -.",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n1.2, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 2.4, FOSC = 1 MHz.Actual Rate (K) = 2.232. 2.4, FOSC = 1 MHz.% Error = -6.99. 2.4, FOSC = 1 MHz.SPBRG value (decimal) = 6. 2.4, FOSC = 32.768 kHz.Actual Rate (K) = NA. 2.4, FOSC = 32.768 kHz.% Error = -. 2.4, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 9.6, FOSC = 1 MHz.Actual Rate (K) = NA. 9.6, FOSC = 1 MHz.% Error = -. 9.6, FOSC = 1 MHz.SPBRG value (decimal) = -. 9.6, FOSC = 32.768 kHz.Actual Rate (K) = NA. 9.6, FOSC",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n= 32.768 kHz.% Error = -. 9.6, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 19.2, FOSC = 1 MHz.Actual Rate (K) = NA. 19.2, FOSC = 1 MHz.% Error = -. 19.2, FOSC = 1 MHz.SPBRG value (decimal) = -. 19.2, FOSC = 32.768 kHz.Actual Rate (K) = NA. 19.2, FOSC = 32.768 kHz.% Error = -. 19.2, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 76.8, FOSC = 1 MHz.Actual Rate (K) = NA. 76.8, FOSC = 1 MHz.% Error = -. 76.8, FOSC = 1 MHz.SPBRG value (decimal) = -. 76.8, FOSC = 32.768 kHz.Actual Rate (K) = NA.",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n76.8, FOSC = 32.768 kHz.% Error = -. 76.8, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 96, FOSC = 1 MHz.Actual Rate (K) = NA. 96, FOSC = 1 MHz.% Error = -. 96, FOSC = 1 MHz.SPBRG value (decimal) = -. 96, FOSC = 32.768 kHz.Actual Rate (K) = NA. 96, FOSC = 32.768 kHz.% Error = -. 96, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 300, FOSC = 1 MHz.Actual Rate (K) = NA. 300, FOSC = 1 MHz.% Error = -. 300, FOSC = 1 MHz.SPBRG value (decimal) = -. 300, FOSC = 32.768 kHz.Actual Rate (K) = NA. 300, FOSC = 32.768 kHz.%",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nError = -. 300, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 500, FOSC = 1 MHz.Actual Rate (K) = NA. 500, FOSC = 1 MHz.% Error = -. 500, FOSC = 1 MHz.SPBRG value (decimal) = -. 500, FOSC = 32.768 kHz.Actual Rate (K) = NA. 500, FOSC = 32.768 kHz.% Error = -. 500, FOSC = 32.768 kHz.SPBRG value (decimal) = -. HIGH, FOSC = 1 MHz.Actual Rate (K) = 15.63. HIGH, FOSC = 1 MHz.% Error = -. HIGH, FOSC = 1 MHz.SPBRG value (decimal) = 0. HIGH, FOSC = 32.768 kHz.Actual Rate (K) = 0.512. HIGH, FOSC = 32.768 kHz.% Error = -. HIGH, FOSC =",
    "TABLE 15-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n32.768 kHz.SPBRG value (decimal) = 0. LOW, FOSC = 1 MHz.Actual Rate (K) = 0.0610. LOW, FOSC = 1 MHz.% Error = -. LOW, FOSC = 1 MHz.SPBRG value (decimal) = 255. LOW, FOSC = 32.768 kHz.Actual Rate (K) = 0.0020. LOW, FOSC = 32.768 kHz.% Error = -. LOW, FOSC = 32.768 kHz.SPBRG value (decimal) = 255",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n9.6, FOSC = 40 MHz.Actual Rate (K) = 9.77. 9.6, FOSC = 40 MHz.% Error = -1.70. 9.6, FOSC = 40 MHz.SPBRG value (decimal) = 255. 9.6, FOSC = 20 MHz.Actual Rate (K) = 9.615. 9.6, FOSC = 20 MHz.% Error = +0.16. 9.6, FOSC = 20 MHz.SPBRG value (decimal) = 129. 9.6, FOSC = 16 MHz.Actual Rate (K) = 9.615. 9.6, FOSC = 16 MHz.% Error = +0.16. 9.6, FOSC = 16 MHz.SPBRG value (decimal) = 103. 9.6, FOSC = 10 MHz.Actual Rate (K) = 9.615. 9.6, FOSC = 10 MHz.% Error = +0.16. 9.6, FOSC = 10",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nMHz.SPBRG value (decimal) = 64. 19.2, FOSC = 40 MHz.Actual Rate (K) = 19.23. 19.2, FOSC = 40 MHz.% Error = -0.16. 19.2, FOSC = 40 MHz.SPBRG value (decimal) = 129. 19.2, FOSC = 20 MHz.Actual Rate (K) = 19.230. 19.2, FOSC = 20 MHz.% Error = +0.16. 19.2, FOSC = 20 MHz.SPBRG value (decimal) = 64. 19.2, FOSC = 16 MHz.Actual Rate (K) = 19.230. 19.2, FOSC = 16 MHz.% Error = +0.16. 19.2, FOSC = 16 MHz.SPBRG value (decimal) = 51. 19.2, FOSC = 10 MHz.Actual Rate (K) = 18.939. 19.2, FOSC = 10 MHz.% Error =",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n-1.36. 19.2, FOSC = 10 MHz.SPBRG value (decimal) = 32. 38.4, FOSC = 40 MHz.Actual Rate (K) = 38.46. 38.4, FOSC = 40 MHz.% Error = -0.16. 38.4, FOSC = 40 MHz.SPBRG value (decimal) = 64. 38.4, FOSC = 20 MHz.Actual Rate (K) = 37.878. 38.4, FOSC = 20 MHz.% Error = -1.36. 38.4, FOSC = 20 MHz.SPBRG value (decimal) = 32. 38.4, FOSC = 16 MHz.Actual Rate (K) = 38.461. 38.4, FOSC = 16 MHz.% Error = +0.16. 38.4, FOSC = 16 MHz.SPBRG value (decimal) = 25. 38.4, FOSC = 10 MHz.Actual Rate (K) = 39.062.",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n38.4, FOSC = 10 MHz.% Error = +1.7. 38.4, FOSC = 10 MHz.SPBRG value (decimal) = 15. 57.6, FOSC = 40 MHz.Actual Rate (K) = 58.14. 57.6, FOSC = 40 MHz.% Error = -0.93. 57.6, FOSC = 40 MHz.SPBRG value (decimal) = 42. 57.6, FOSC = 20 MHz.Actual Rate (K) = 56.818. 57.6, FOSC = 20 MHz.% Error = -1.36. 57.6, FOSC = 20 MHz.SPBRG value (decimal) = 21. 57.6, FOSC = 16 MHz.Actual Rate (K) = 58.823. 57.6, FOSC = 16 MHz.% Error = +2.12. 57.6, FOSC = 16 MHz.SPBRG value (decimal) = 16. 57.6, FOSC = 10",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nMHz.Actual Rate (K) = 56.818. 57.6, FOSC = 10 MHz.% Error = -1.36. 57.6, FOSC = 10 MHz.SPBRG value (decimal) = 10. 115.2, FOSC = 40 MHz.Actual Rate (K) = 113.64. 115.2, FOSC = 40 MHz.% Error = +1.38. 115.2, FOSC = 40 MHz.SPBRG value (decimal) = 21. 115.2, FOSC = 20 MHz.Actual Rate (K) = 113.63. 115.2, FOSC = 20 MHz.% Error = -1.36. 115.2, FOSC = 20 MHz.SPBRG value (decimal) = 10. 115.2, FOSC = 16 MHz.Actual Rate (K) = 111.11. 115.2, FOSC = 16 MHz.% Error = -3.55. 115.2, FOSC = 16 MHz.SPBRG value (decimal) =",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n8. 115.2, FOSC = 10 MHz.Actual Rate (K) = 125. 115.2, FOSC = 10 MHz.% Error = +8.51. 115.2, FOSC = 10 MHz.SPBRG value (decimal) = 4. 250, FOSC = 40 MHz.Actual Rate (K) = 250.00. 250, FOSC = 40 MHz.% Error = 0. 250, FOSC = 40 MHz.SPBRG value (decimal) = 9. 250, FOSC = 20 MHz.Actual Rate (K) = 250. 250, FOSC = 20 MHz.% Error = 0. 250, FOSC = 20 MHz.SPBRG value (decimal) = 4. 250, FOSC = 16 MHz.Actual Rate (K) = 250. 250, FOSC = 16 MHz.% Error = 0. 250, FOSC = 16 MHz.SPBRG value (decimal) = 3. 250, FOSC = 10 MHz.Actual Rate (K) = NA. 250, FOSC",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n= 10 MHz.% Error = -. 250, FOSC = 10 MHz.SPBRG value (decimal) = -. 625, FOSC = 40 MHz.Actual Rate (K) = 625.00. 625, FOSC = 40 MHz.% Error = 0. 625, FOSC = 40 MHz.SPBRG value (decimal) = 3. 625, FOSC = 20 MHz.Actual Rate (K) = 625. 625, FOSC = 20 MHz.% Error = 0. 625, FOSC = 20 MHz.SPBRG value (decimal) = 1. 625, FOSC = 16 MHz.Actual Rate (K) = NA. 625, FOSC = 16 MHz.% Error = -. 625, FOSC = 16 MHz.SPBRG value (decimal) = -. 625, FOSC = 10 MHz.Actual Rate (K) = 625. 625, FOSC = 10 MHz.% Error = 0. 625, FOSC = 10 MHz.SPBRG value (decimal) = 0. 1250,",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nFOSC = 40 MHz.Actual Rate (K) = 1250.00. 1250, FOSC = 40 MHz.% Error = 0. 1250, FOSC = 40 MHz.SPBRG value (decimal) = 1. 1250, FOSC = 20 MHz.Actual Rate (K) = 1250. 1250, FOSC = 20 MHz.% Error = 0. 1250, FOSC = 20 MHz.SPBRG value (decimal) = 0. 1250, FOSC = 16 MHz.Actual Rate (K) = NA. 1250, FOSC = 16 MHz.% Error = -. 1250, FOSC = 16 MHz.SPBRG value (decimal) = -. 1250, FOSC = 10 MHz.Actual Rate (K) = NA. 1250, FOSC = 10 MHz.% Error = -. 1250, FOSC = 10 MHz.SPBRG value (decimal) = -",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n9.6, FOSC = 7.16MHz.Actual Rate (K) = 9.520. 9.6, FOSC = 7.16MHz.% Error = -0.83. 9.6, FOSC = 7.16MHz.SPBRG value (decimal) = 46. 9.6, FOSC = 5.068 MHz.Actual Rate (K) = 9.6. 9.6, FOSC = 5.068 MHz.% Error = 0. 9.6, FOSC = 5.068 MHz.SPBRG value (decimal) = 32. 9.6, FOSC = 4 MHz.Actual Rate (K) = NA. 9.6, FOSC = 4 MHz.% Error = -. 9.6, FOSC = 4 MHz.SPBRG value (decimal) = -. 9.6, FOSC = 3.579545 MHz.Actual Rate (K) = 9.727. 9.6, FOSC =",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n3.579545 MHz.% Error = +1.32. 9.6, FOSC = 3.579545 MHz.SPBRG value (decimal) = 22. 19.2, FOSC = 7.16MHz.Actual Rate (K) = 19.454. 19.2, FOSC = 7.16MHz.% Error = +1.32. 19.2, FOSC = 7.16MHz.SPBRG value (decimal) = 22. 19.2, FOSC = 5.068 MHz.Actual Rate (K) = 18.645. 19.2, FOSC = 5.068 MHz.% Error = -2.94. 19.2, FOSC = 5.068 MHz.SPBRG value (decimal) = 16. 19.2, FOSC = 4 MHz.Actual Rate (K) = 1.202. 19.2, FOSC = 4 MHz.% Error = +0.17. 19.2, FOSC =",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n4 MHz.SPBRG value (decimal) = 207. 19.2, FOSC = 3.579545 MHz.Actual Rate (K) = 18.643. 19.2, FOSC = 3.579545 MHz.% Error = -2.90. 19.2, FOSC = 3.579545 MHz.SPBRG value (decimal) = 11. 38.4, FOSC = 7.16MHz.Actual Rate (K) = 37.286. 38.4, FOSC = 7.16MHz.% Error = -2.90. 38.4, FOSC = 7.16MHz.SPBRG value (decimal) = 11. 38.4, FOSC = 5.068 MHz.Actual Rate (K) = 39.6. 38.4, FOSC = 5.068 MHz.% Error = +3.12. 38.4, FOSC = 5.068 MHz.SPBRG value (decimal) = 7.",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n38.4, FOSC = 4 MHz.Actual Rate (K) = 2.403. 38.4, FOSC = 4 MHz.% Error = +0.13. 38.4, FOSC = 4 MHz.SPBRG value (decimal) = 103. 38.4, FOSC = 3.579545 MHz.Actual Rate (K) = 37.286. 38.4, FOSC = 3.579545 MHz.% Error = -2.90. 38.4, FOSC = 3.579545 MHz.SPBRG value (decimal) = 5. 57.6, FOSC = 7.16MHz.Actual Rate (K) = 55.930. 57.6, FOSC = 7.16MHz.% Error = -2.90. 57.6, FOSC = 7.16MHz.SPBRG value (decimal) = 7. 57.6, FOSC = 5.068 MHz.Actual Rate (K) = 52.8.",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n57.6, FOSC = 5.068 MHz.% Error = -8.33. 57.6, FOSC = 5.068 MHz.SPBRG value (decimal) = 5. 57.6, FOSC = 4 MHz.Actual Rate (K) = 9.615. 57.6, FOSC = 4 MHz.% Error = +0.16. 57.6, FOSC = 4 MHz.SPBRG value (decimal) = 25. 57.6, FOSC = 3.579545 MHz.Actual Rate (K) = 55.930. 57.6, FOSC = 3.579545 MHz.% Error = -2.90. 57.6, FOSC = 3.579545 MHz.SPBRG value (decimal) = 3. 115.2, FOSC = 7.16MHz.Actual Rate (K) = 111.860. 115.2, FOSC = 7.16MHz.% Error = -2.90.",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n115.2, FOSC = 7.16MHz.SPBRG value (decimal) = 3. 115.2, FOSC = 5.068 MHz.Actual Rate (K) = 105.6. 115.2, FOSC = 5.068 MHz.% Error = -8.33. 115.2, FOSC = 5.068 MHz.SPBRG value (decimal) = 2. 115.2, FOSC = 4 MHz.Actual Rate (K) = 19.231. 115.2, FOSC = 4 MHz.% Error = +0.16. 115.2, FOSC = 4 MHz.SPBRG value (decimal) = 12. 115.2, FOSC = 3.579545 MHz.Actual Rate (K) = 111.86. 115.2, FOSC = 3.579545 MHz.% Error = -2.90. 115.2, FOSC = 3.579545 MHz.SPBRG value (decimal) = 1. 250,",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nFOSC = 7.16MHz.Actual Rate (K) = NA. 250, FOSC = 7.16MHz.% Error = -. 250, FOSC = 7.16MHz.SPBRG value (decimal) = -. 250, FOSC = 5.068 MHz.Actual Rate (K) = NA. 250, FOSC = 5.068 MHz.% Error = -. 250, FOSC = 5.068 MHz.SPBRG value (decimal) = -. 250, FOSC = 4 MHz.Actual Rate (K) = NA. 250, FOSC = 4 MHz.% Error = -. 250, FOSC = 4 MHz.SPBRG value (decimal) = -. 250, FOSC = 3.579545 MHz.Actual Rate (K) = 223.72. 250, FOSC = 3.579545 MHz.% Error = -10.51. 250, FOSC = 3.579545 MHz.SPBRG value",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n(decimal) = 0. 625, FOSC = 7.16MHz.Actual Rate (K) = NA. 625, FOSC = 7.16MHz.% Error = -. 625, FOSC = 7.16MHz.SPBRG value (decimal) = -. 625, FOSC = 5.068 MHz.Actual Rate (K) = NA. 625, FOSC = 5.068 MHz.% Error = -. 625, FOSC = 5.068 MHz.SPBRG value (decimal) = -. 625, FOSC = 4 MHz.Actual Rate (K) = NA. 625, FOSC = 4 MHz.% Error = -. 625, FOSC = 4 MHz.SPBRG value (decimal) = -. 625, FOSC = 3.579545 MHz.Actual Rate (K) = NA. 625, FOSC = 3.579545 MHz.% Error = -. 625, FOSC = 3.579545 MHz.SPBRG",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nvalue (decimal) = -. 1250, FOSC = 7.16MHz.Actual Rate (K) = NA. 1250, FOSC = 7.16MHz.% Error = -. 1250, FOSC = 7.16MHz.SPBRG value (decimal) = -. 1250, FOSC = 5.068 MHz.Actual Rate (K) = NA. 1250, FOSC = 5.068 MHz.% Error = -. 1250, FOSC = 5.068 MHz.SPBRG value (decimal) = -. 1250, FOSC = 4 MHz.Actual Rate (K) = NA. 1250, FOSC = 4 MHz.% Error = -. 1250, FOSC = 4 MHz.SPBRG value (decimal) = -. 1250, FOSC = 3.579545 MHz.Actual Rate (K) = NA. 1250, FOSC = 3.579545 MHz.% Error = -. 1250,",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nFOSC = 3.579545 MHz.SPBRG value (decimal) = -",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n9.6, FOSC = 1 MHz.Actual Rate (K) = 8.928. 9.6, FOSC = 1 MHz.% Error = -6.99. 9.6, FOSC = 1 MHz.SPBRG value (decimal) = 6. 9.6, FOSC = 32.768 kHz.Actual Rate (K) = NA. 9.6, FOSC = 32.768 kHz.% Error = -. 9.6, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 19.2, FOSC = 1 MHz.Actual Rate (K) = 20.833. 19.2, FOSC = 1 MHz.% Error = +8.51. 19.2, FOSC = 1 MHz.SPBRG value (decimal) = 2. 19.2, FOSC = 32.768 kHz.Actual Rate (K) = NA. 19.2, FOSC = 32.768 kHz.% Error = -. 19.2,",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nFOSC = 32.768 kHz.SPBRG value (decimal) = -. 38.4, FOSC = 1 MHz.Actual Rate (K) = 31.25. 38.4, FOSC = 1 MHz.% Error = -18.61. 38.4, FOSC = 1 MHz.SPBRG value (decimal) = 1. 38.4, FOSC = 32.768 kHz.Actual Rate (K) = NA. 38.4, FOSC = 32.768 kHz.% Error = -. 38.4, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 57.6, FOSC = 1 MHz.Actual Rate (K) = 62.5. 57.6, FOSC = 1 MHz.% Error = +8.51. 57.6, FOSC = 1 MHz.SPBRG value (decimal) = 0. 57.6, FOSC = 32.768 kHz.Actual Rate (K) = NA. 57.6,",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nFOSC = 32.768 kHz.% Error = -. 57.6, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 115.2, FOSC = 1 MHz.Actual Rate (K) = NA. 115.2, FOSC = 1 MHz.% Error = -. 115.2, FOSC = 1 MHz.SPBRG value (decimal) = -. 115.2, FOSC = 32.768 kHz.Actual Rate (K) = NA. 115.2, FOSC = 32.768 kHz.% Error = -. 115.2, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 250, FOSC = 1 MHz.Actual Rate (K) = NA. 250, FOSC = 1 MHz.% Error = -. 250, FOSC = 1 MHz.SPBRG value (decimal) = -. 250, FOSC = 32.768 kHz.Actual Rate (K) = NA. 250, FOSC",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n= 32.768 kHz.% Error = -. 250, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 625, FOSC = 1 MHz.Actual Rate (K) = NA. 625, FOSC = 1 MHz.% Error = -. 625, FOSC = 1 MHz.SPBRG value (decimal) = -. 625, FOSC = 32.768 kHz.Actual Rate (K) = NA. 625, FOSC = 32.768 kHz.% Error = -. 625, FOSC = 32.768 kHz.SPBRG value (decimal) = -. 1250, FOSC = 1 MHz.Actual Rate (K) = NA. 1250, FOSC = 1 MHz.% Error = -. 1250, FOSC = 1 MHz.SPBRG value (decimal) = -. 1250, FOSC = 32.768 kHz.Actual Rate (K) = NA. 1250, FOSC = 32.768 kHz.% Error = -.",
    "TABLE 15-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n1250, FOSC = 32.768 kHz.SPBRG value (decimal) = -",
    "15.2 USART Asynchronous Mode\nIn this mode, the USART uses standard non-return-tozero (NRZ) format (one START bit, eight or nine data bits and one STOP bit). The most common data format is 8-bits. An on-chip dedicated 8-bit baud rate generator can be used to derive standard baud rate frequencies  from  the  oscillator.  The  USART  transmits  and receives  the  LSb  first.  The  USART's  transmitter  and receiver  are  functionally  independent,  but  use  the same data format and baud rate. The baud rate generator produces a clock, either x16 or x64 of the bit shift rate, depending on bit BRGH (TXSTA<2>). Parity is not supported by the hardware, but can be implemented in software (and stored as the ninth data bit). Asynchronous mode is stopped during SLEEP.\nAsynchronous mode is selected by clearing bit SYNC (TXSTA<4>).\nThe USART Asynchronous module consists of the following important elements:\n\u00b7 Baud Rate Generator\n\u00b7 Sampling Circuit\n\u00b7 Asynchronous Transmitter\n\u00b7 Asynchronous Receiver",
    "15.2.1 USART ASYNCHRONOUS TRANSMITTER\ndata from the TXREG register (if available). Once the TXREG register transfers the data to the TSR register (occurs in one TCY), the TXREG register is empty and flag  bit  TXIF  (PIR1<4>)  is  set.  This  interrupt  can  be enabled/disabled by setting/clearing  enable  bit,  TXIE ( PIE1<4>). Flag bit TXIF will be set, regardless of the state of enable bit TXIE and cannot be cleared in software. It will reset only when new data is loaded into the TXREG register. While flag bit TXIF indicated the status of the TXREG  register, another bit TRMT (TXSTA<1>) shows the status of the TSR register. Status bit TRMT is a read only bit, which is set when the TSR register is empty. No interrupt logic is tied to this bit, so the user has to poll this bit in order to determine if the TSR register is empty.",
    "15.2.1 USART ASYNCHRONOUS TRANSMITTER\nNote 1: The TSR register is not mapped in data memory, so it is not available to the user.\n2: Flag bit TXIF is set when enable bit TXEN is set.\nTo set up an asynchronous transmission:\n1. Initialize the SPBRG register for the appropriate baud rate. If a high speed baud rate is desired, set bit BRGH (Section 15.1).\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit TXIE.\nThe  USART  transmitter  block  diagram  is  shown  in Figure 15-1. The heart of the transmitter is the transmit (serial) shift register (TSR). The shift register obtains its data from the read/write transmit buffer, TXREG. The TXREG register is loaded with data in software. The TSR register is not loaded until the STOP bit has been transmitted  from  the  previous  load.  As  soon  as  the STOP bit is transmitted, the TSR is loaded with new",
    "15.2.1 USART ASYNCHRONOUS TRANSMITTER\n4. If  9-bit  transmission is desired, set transmit bit TX9. Can be used as address/data bit.\n5. Enable  the  transmission  by  setting  bit  TXEN, which will also set bit TXIF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Load data to the TXREG register (starts transmission).",
    "TABLE 15-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 15-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other RESETS = 0000. PIR1, Value on all other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other RESETS = 0000. PIE1, Value on all other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 15-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on all other RESETS = 0000. IPR1, Value on all other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on all other RESETS = 0000. RCSTA, Value on all other RESETS = -00x. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register.",
    "TABLE 15-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nTXREG, Bit 5 = USART Transmit Register. TXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other RESETS = 0000. TXREG, Value on all other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other RESETS = 0000. TXSTA,",
    "TABLE 15-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nValue on all other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other RESETS = 0000. SPBRG, Value on all other RESETS = 0000\nLegend: x = unknown, - = unimplemented locations read as '0'. Shaded cells are not used for Asynchronous Transmission.\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices.  Always maintain these bits clear.",
    "15.2.2 USART ASYNCHRONOUS RECEIVER\nThe receiver block diagram is  shown in Figure 15-4. The data is received on the RC7/RX/DT pin and drives the  data  recovery  block.  The  data  recovery  block  is actually a high speed shifter operating at x16 times the baud rate, whereas the main receive serial shifter operates at the bit rate, or at FOSC. This mode would typically be used in RS-232 systems.\nTo set up an Asynchronous Reception:",
    "15.2.2 USART ASYNCHRONOUS RECEIVER\n1. Initialize the SPBRG register for the appropriate baud rate. If a high speed baud rate is desired, set bit BRGH (Section 15.1).\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit RCIE.\n4. If 9-bit reception is desired, set bit RX9.\n5. Enable the reception by setting bit CREN.\n6. Flag bit RCIF will be set when reception is complete and an interrupt will be generated if enable bit RCIE was set.\n7. Read the RCSTA register to get the ninth bit (if enabled)  and  determine  if  any  error  occurred during reception.\n8. Read  the  8-bit  received  data  by  reading  the RCREG register.\n9. If any error occurred, clear the error by clearing enable bit CREN.",
    "15.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\nThis mode would typically be used in RS-485 systems. To  set  up  an  Asynchronous  Reception  with  Address Detect Enable:",
    "15.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize the SPBRG register for the appropriate baud rate. If a high speed baud rate is required, set the BRGH bit.\n2. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n3. If interrupts are required, set the RCEN bit and select the desired priority level with the RCIP bit.\n4. Set the RX9 bit to enable 9-bit reception.\n5. Set the ADDEN bit to enable address detect.\n6. Enable reception by setting the CREN bit.\n7. The RCIF bit will be set when reception is complete. The interrupt will be acknowledged if the RCIE and GIE bits are set.\n8. Read the  RCSTA  register  to  determine  if  any error occurred during reception, as well as read bit 9 of data (if applicable).\n9. Read RCREG to determine if the device is being addressed.\n10. If any error occurred, clear the CREN bit.\n11. If  the  device  has  been  addressed,  clear  the ADDEN bit  to  allow  all  received  data  into  the receive buffer and interrupt the CPU.",
    "FIGURE 15-5: ASYNCHRONOUS RECEPTION\nRX (pin) reg Rcv buffer reg Rcv shift Read Rcv buffer reg RCREG RCIF (interrupt flag) OERR bit CREN, 1 = START bit bit7/8 bit1 bit0 bit7/8 bit0 STOP bit START bit START bit bit7/8 STOP bit STOP bit",
    "TABLE 15-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 15-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other RESETS = 0000. PIR1, Value on all other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other RESETS = 0000. PIE1, Value on all other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 15-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on all other RESETS = 0000. IPR1, Value on all other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on all other RESETS = 0000. RCSTA, Value on all other RESETS = -00x. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register.",
    "TABLE 15-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nRCREG, Bit 5 = USART Receive Register. RCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on all other RESETS = 0000. RCREG, Value on all other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other RESETS = 0000. TXSTA,",
    "TABLE 15-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nValue on all other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other RESETS = 0000. SPBRG, Value on all other RESETS = 0000\nLegend: x = unknown, - = unimplemented locations read as '0'.\nShaded cells are not used for Asynchronous Reception.\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices.  Always maintain these bits clear.",
    "15.3 USART Synchronous Master Mode\nIn Synchronous Master mode, the data is transmitted in a half-duplex manner, (i.e., transmission and reception do not occur at the same time). When transmitting data, the reception is inhibited and vice versa. Synchronous mode is entered by setting bit SYNC (TXSTA<4>). In addition, enable bit SPEN (RCSTA<7>) is set in order to configure the RC6/TX/CK and RC7/RX/DT I/O pins to  CK  (clock)  and  DT  (data)  lines,  respectively.  The Master mode indicates that the processor transmits the master  clock  on  the  CK  line.  The  Master  mode  is entered by setting bit CSRC (TXSTA<7>).",
    "15.3.1 USART SYNCHRONOUS MASTER TRANSMISSION\nrupt  bit  TXIF  (PIR1<4>)  is  set.  The  interrupt  can  be enabled/disabled  by  setting/clearing  enable  bit  TXIE (PIE1<4>). Flag bit TXIF will be set, regardless of the state of enable bit TXIE, and cannot be cleared in software. It will reset only when new data is loaded into the TXREG register. While flag bit TXIF indicates the status of the TXREG register, another bit TRMT (TXSTA<1>) shows the status of the TSR register. TRMT is a read only bit, which is set when the TSR is empty. No interrupt logic is tied to this bit, so the user has to poll this bit in order to determine if the TSR register is empty. The TSR is not mapped in data memory, so it is not available to the user.\nTo set up a Synchronous Master Transmission:\n- 1. Initialize the SPBRG register for the appropriate baud rate (Section 15.1).",
    "15.3.1 USART SYNCHRONOUS MASTER TRANSMISSION\nThe  USART  transmitter  block  diagram  is  shown  in Figure 15-1. The heart of the transmitter is the transmit (serial) shift register (TSR). The shift register obtains its data from the read/write transmit buffer register TXREG.  The  TXREG  register  is  loaded  with  data  in software. The TSR register is not loaded until the last bit  has  been  transmitted  from  the  previous  load.  As soon as the last bit is transmitted, the TSR is loaded with new data from the TXREG (if available). Once the TXREG register transfers the data to the TSR register (occurs in one TCYCLE), the TXREG is empty and inter-\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN, and CSRC.\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable the transmission by setting bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREG register.",
    "TABLE 15-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 15-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other RESETS = 0000. PIR1, Value on all other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other RESETS = 0000. PIE1, Value on all other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 15-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on all other RESETS = 0000. IPR1, Value on all other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on all other RESETS = 0000. RCSTA, Value on all other RESETS = -00x. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register.",
    "TABLE 15-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nTXREG, Bit 5 = USART Transmit Register. TXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other RESETS = 0000. TXREG, Value on all other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other RESETS = 0000. TXSTA,",
    "TABLE 15-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nValue on all other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other RESETS = 0000. SPBRG, Value on all other RESETS = 0000\nLegend: x = unknown, - = unimplemented, read as '0'.\nShaded cells are not used for Synchronous Master Transmission.\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices. Always maintain these bits clear.",
    "15.3.2 USART SYNCHRONOUS MASTER RECEPTION\nOnce  Synchronous  mode  is  selected,  reception  is enabled by setting either enable bit SREN (RCSTA<5>), or enable bit CREN (RCSTA<4>). Data is sampled on the RC7/RX/DT pin on the falling edge of the clock. If enable bit SREN is set, only a single word is received. If enable bit CREN is set, the reception is continuous until CREN is cleared. If both bits are set, then CREN takes precedence.\nTo set up a Synchronous Master Reception:",
    "15.3.2 USART SYNCHRONOUS MASTER RECEPTION\n1. Initialize the SPBRG register for the appropriate baud rate (Section 15.1).\n3. Ensure bits CREN and SREN are clear.\n4. If interrupts are desired, set enable bit RCIE.\n5. If 9-bit reception is desired, set bit RX9.\n6. If  a  single reception is required, set bit SREN. For continuous reception, set bit CREN.\n7. Interrupt flag bit RCIF will be set when reception is complete and an interrupt will be generated if the enable bit RCIE was set.\n8. Read the RCSTA register to get the ninth bit (if enabled)  and  determine  if  any  error  occurred during reception.\n9. Read  the  8-bit  received  data  by  reading  the RCREG register.\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN and CSRC.\n10. If any error occurred, clear the error by clearing bit CREN.",
    "TABLE 15-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value onall other RESETS = 0000. INTCON, Value onall other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 15-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value onall other RESETS = 0000. PIR1, Value onall other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value onall other RESETS = 0000. PIE1, Value onall other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 15-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value onall other RESETS = 0000. IPR1, Value onall other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value onall other RESETS = 0000. RCSTA, Value onall other RESETS = -00x. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register.",
    "TABLE 15-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nRCREG, Bit 5 = USART Receive Register. RCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value onall other RESETS = 0000. RCREG, Value onall other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value onall other RESETS = 0000. TXSTA,",
    "TABLE 15-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nValue onall other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value onall other RESETS = 0000. SPBRG, Value onall other RESETS = 0000\n- Legend: x = unknown, - = unimplemented, read as '0'.\nShaded cells are not used for Synchronous Master Reception.\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices.  Always maintain these bits clear.",
    "15.4 USART Synchronous Slave Mode\nSynchronous Slave mode differs from the Master mode in the fact that the shift clock is supplied externally at the RC6/TX/CK pin (instead of being supplied internally in Master mode). This allows the device to transfer or receive  data  while  in  SLEEP  mode.  Slave  mode  is entered by clearing bit CSRC (TXSTA<7>).",
    "15.4.1 USART SYNCHRONOUS SLAVE TRANSMIT\nThe operation of the Synchronous Master and Slave modes are identical, except in the case of the SLEEP mode.\nIf  two  words  are  written  to  the  TXREG  and  then  the SLEEP instruction is executed, the following will occur:\na) The  first  word  will  immediately  transfer  to  the TSR register and transmit.\nb) The second word will remain in TXREG register.\nc) Flag bit TXIF will not be set.\nd) When the first word has been shifted out of TSR, the TXREG register will transfer the second word to the TSR and flag bit TXIF will now be set.\ne) If enable bit TXIE is set, the interrupt will wake the chip from SLEEP. If the global interrupt is enabled, the program will branch to the interrupt vector.",
    "TABLE 15-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 15-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other RESETS = 0000. PIR1, Value on all other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other RESETS = 0000. PIE1, Value on all other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 15-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on all other RESETS = 0000. IPR1, Value on all other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on all other RESETS = 0000. RCSTA, Value on all other RESETS = -00x. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register.",
    "TABLE 15-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nTXREG, Bit 5 = USART Transmit Register. TXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other RESETS = 0000. TXREG, Value on all other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other RESETS = 0000. TXSTA,",
    "TABLE 15-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nValue on all other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other RESETS = 0000. SPBRG, Value on all other RESETS = 0000\nLegend: x = unknown, - = unimplemented, read as '0'.\nShaded cells are not used for Synchronous Slave Transmission.\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices. Always maintain these bits clear.",
    "TABLE 15-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nTo set up a Synchronous Slave Transmission:\n1. Enable the synchronous slave serial port by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. Clear bits CREN and SREN.\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable  the  transmission  by  setting  enable  bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREG register.",
    "15.4.2 USART SYNCHRONOUS SLAVE RECEPTION\nThe operation of the Synchronous Master and Slave modes is identical, except in the case of the SLEEP mode and bit SREN, which is a 'don't care' in Slave mode.\nIf  receive is enabled by setting bit CREN prior to the SLEEP instruction, then a word may be received during SLEEP.  On  completely  receiving  the  word,  the  RSR register  will  transfer  the  data  to  the  RCREG register, and if enable bit RCIE bit is set, the interrupt generated will wake the chip from SLEEP. If the global interrupt is enabled, the program will branch to the interrupt vector.\nTo set up a Synchronous Slave Reception:",
    "15.4.2 USART SYNCHRONOUS SLAVE RECEPTION\n1. Enable  the  synchronous  master  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. If interrupts are desired, set enable bit RCIE.\n3. If 9-bit reception is desired, set bit RX9.\n4. To enable reception, set enable bit CREN.\n5. Flag bit RCIF will be set when reception is complete. An interrupt will be generated if enable bit RCIE was set.\n6. Read the RCSTA register to get the ninth bit (if enabled)  and  determine  if  any  error  occurred during reception.\n7. Read  the  8-bit  received  data  by  reading  the RCREG register.\n8. If any error occurred, clear the error by clearing bit CREN.",
    "TABLE 15-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other RESETS = 0000. INTCON, Value on all other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 15-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other RESETS = 0000. PIR1, Value on all other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other RESETS = 0000. PIE1, Value on all other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 15-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on all other RESETS = 0000. IPR1, Value on all other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on all other RESETS = 0000. RCSTA, Value on all other RESETS = -00x. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register.",
    "TABLE 15-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nRCREG, Bit 5 = USART Receive Register. RCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on all other RESETS = 0000. RCREG, Value on all other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other RESETS = 0000. TXSTA,",
    "TABLE 15-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nValue on all other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other RESETS = 0000. SPBRG, Value on all other RESETS = 0000\nLegend:\nx = unknown, - = unimplemented, read as '0'. Shaded cells are not used for Synchronous Slave Reception.\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices. Always maintain these bits clear.",
    "PIC18CXX2\nNOTES:",
    "16.0 COMPATIBLE 10-BIT ANALOGTO-DIGITAL CONVERTER (A/D) MODULE\nThe analog-to-digital (A/D) converter module has five inputs  for  the  PIC18C2x2  devices  and  eight  for  the PIC18C4x2  devices.  This  module  has  the  ADCON0 and ADCON1 register definitions that are compatible with the mid-range A/D module.\nThe A/D allows conversion of an analog input signal to a corresponding 10-bit digital number.\nThe  A/D  module  has  four  registers.  These  registers are:\n\u00b7 A/D Result High Register (ADRESH)\n\u00b7 A/D Result Low Register (ADRESL)\n\u00b7 A/D Control Register 0 (ADCON0)\n\u00b7 A/D Control Register 1 (ADCON1)\nThe  ADCON0 register,  shown  in  Register 16-1,  controls  the  operation of  the A/D  module. The ADCON1 register, shown in Register 16-2, configures the functions of the port pins.",
    "REGISTER 16-1: ADCON0 REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = U-0. R/W-0, 7 = R/W-0. ADCS1, 1 = ADCS0. ADCS1, 2 = CHS2. ADCS1, 3 = CHS1. ADCS1, 4 = CHS0. ADCS1, 5 = GO/DONE. ADCS1, 6 = -. ADCS1, 7 = ADON\nbit 7\nbit 0",
    "bit 7-6 ADCS1:ADCS0: A/D Conversion Clock Select bits (ADCON0 bits in bold )\n0, ADCON0 <ADCS1:ADCS0> = 00. 0, Clock Conversion = FOSC/2. 0, ADCON0 <ADCS1:ADCS0> = 01. 0, Clock Conversion = FOSC/8. 0, ADCON0 <ADCS1:ADCS0> = 10. 0, Clock Conversion = FOSC/32. 0, ADCON0 <ADCS1:ADCS0> = 11. 0, Clock Conversion = FRC (clock derived from the internal A/D RC oscillator). 1, ADCON0 <ADCS1:ADCS0> = 00. 1, Clock Conversion = FOSC/4. 1, ADCON0 <ADCS1:ADCS0> = 01. 1, Clock Conversion = FOSC/16. 1, ADCON0 <ADCS1:ADCS0> = 10. 1, Clock Conversion = FOSC/64. 1, ADCON0 <ADCS1:ADCS0> = 11. 1, Clock Conversion",
    "bit 7-6 ADCS1:ADCS0: A/D Conversion Clock Select bits (ADCON0 bits in bold )\n= FRC (clock derived from the internal A/D RC oscillator)",
    "bit 5-3 CHS2:CHS0: Analog Channel Select bits\n000 = channel 0 (AN0)\n001 = channel 1 (AN1)\n010 = channel 2 (AN2)\n011 = channel 3 (AN3)\n100 = channel 4 (AN4)\n101 = channel 5 (AN5)\n110 = channel 6 (AN6)\n111 = channel 7 (AN7)\nNote: The PIC18C2X2 devices do not implement the full 8 A/D channels; the unimplemented selections are reserved. Do not select any unimplemented channel.",
    "bit 2 GO/DONE: A/D Conversion Status bit\nWhen ADON = 1:\n- 1 = A/D conversion in progress (setting this bit starts the A/D conversion which is automatically\ncleared by hardware when the A/D conversion is complete)\n- 0 = A/D conversion not in progress",
    "bit 0 ADON: A/D On bit\n1 = A/D converter module is powered up\n- 0 = A/D converter module is shut-off and consumes no operating current\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 16-2: ADCON1 REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = U-0. R/W-0, 3 = U-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. ADFM, 1 = ADCS2. ADFM, 2 = -. ADFM, 3 = -. ADFM, 4 = PCFG3. ADFM, 5 = PCFG2. ADFM, 6 = PCFG1. ADFM, 7 = PCFG0\nbit 7\nbit 0",
    "bit 7 ADFM: A/D Result Format Select bit\n1 = Right justified. Six (6) Most Significant bits of ADRESH are read as '0'.\n0 = Left justified. Six (6) Least Significant bits of ADRESL are read as '0'.",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\n0, ADCON0 <ADCS1:ADCS0> = 00. 0, Clock Conversion = FOSC/2. 0, ADCON0 <ADCS1:ADCS0> = 01. 0, Clock Conversion = FOSC/8. 0, ADCON0 <ADCS1:ADCS0> = 10. 0, Clock Conversion = FOSC/32. 0, ADCON0 <ADCS1:ADCS0> = 11. 0, Clock Conversion = FRC (clock derived from the internal A/D RC oscillator). 1, ADCON0 <ADCS1:ADCS0> = 00. 1, Clock Conversion = FOSC/4. 1, ADCON0 <ADCS1:ADCS0> = 01. 1, Clock Conversion = FOSC/16. 1, ADCON0 <ADCS1:ADCS0> = 10. 1, Clock Conversion = FOSC/64. 1, ADCON0 <ADCS1:ADCS0> = 11. 1, Clock Conversion = FRC (clock derived",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\nfrom the internal A/D RC oscillator)\nbit 5-4 Unimplemented: Read as '0'\nbit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\n0000, AN7 = A. 0000, AN6 = A. 0000, AN5 = A. 0000, AN4 = A. 0000, AN3 = A. 0000, AN2 = A. 0000, AN1 = A. 0000, AN0 = A. 0000, VREF + = VDD. 0000, VREF - = VSS. 0000, C/ R = 8 / 0. 0001, AN7 = A. 0001, AN6 = A. 0001, AN5 = A. 0001, AN4 = A. 0001, AN3 = VREF +. 0001, AN2 = A. 0001, AN1 = A. 0001, AN0 = A. 0001, VREF + = AN3. 0001, VREF - = VSS. 0001, C/ R = 7 / 1. 0010, AN7 = D. 0010, AN6 = D. 0010, AN5 = D. 0010, AN4 = A. 0010, AN3 = A. 0010,",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\nAN2 = A. 0010, AN1 = A. 0010, AN0 = A. 0010, VREF + = VDD. 0010, VREF - = VSS. 0010, C/ R = 5 / 0. 0011, AN7 = D. 0011, AN6 = D. 0011, AN5 = D. 0011, AN4 = A. 0011, AN3 = VREF +. 0011, AN2 = A. 0011, AN1 = A. 0011, AN0 = A. 0011, VREF + = AN3. 0011, VREF - = VSS. 0011, C/ R = 4 / 1. 0100, AN7 = D. 0100, AN6 = D. 0100, AN5 = D. 0100, AN4 = D. 0100, AN3 = A. 0100, AN2 = D. 0100, AN1 = A. 0100, AN0 = A. 0100, VREF + = VDD. 0100, VREF - = VSS.",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\n0100, C/ R = 3 / 0. 0101, AN7 = D. 0101, AN6 = D. 0101, AN5 = D. 0101, AN4 = D. 0101, AN3 = VREF +. 0101, AN2 = D. 0101, AN1 = A. 0101, AN0 = A. 0101, VREF + = AN3. 0101, VREF - = VSS. 0101, C/ R = 2 / 1. 011x, AN7 = D. 011x, AN6 = D. 011x, AN5 = D. 011x, AN4 = D. 011x, AN3 = D. 011x, AN2 = D. 011x, AN1 = D. 011x, AN0 = D. 011x, VREF + = -. 011x, VREF - = -. 011x, C/ R = 0 / 0. 1000, AN7 = A. 1000, AN6 = A. 1000, AN5 = A. 1000,",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\nAN4 = A. 1000, AN3 = VREF +. 1000, AN2 = VREF -. 1000, AN1 = A. 1000, AN0 = A. 1000, VREF + = AN3. 1000, VREF - = AN2. 1000, C/ R = 6 / 2. 1001, AN7 = D. 1001, AN6 = D. 1001, AN5 = A. 1001, AN4 = A. 1001, AN3 = A. 1001, AN2 = A. 1001, AN1 = A. 1001, AN0 = A. 1001, VREF + = VDD. 1001, VREF - = VSS. 1001, C/ R = 6 / 0. 1010, AN7 = D. 1010, AN6 = D. 1010, AN5 = A. 1010, AN4 = A. 1010, AN3 = VREF +. 1010, AN2 = A. 1010, AN1 = A. 1010, AN0 = A. 1010, VREF + =",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\nAN3. 1010, VREF - = VSS. 1010, C/ R = 5 / 1. 1011, AN7 = D. 1011, AN6 = D. 1011, AN5 = A. 1011, AN4 = A. 1011, AN3 = VREF +. 1011, AN2 = VREF -. 1011, AN1 = A. 1011, AN0 = A. 1011, VREF + = AN3. 1011, VREF - = AN2. 1011, C/ R = 4 / 2. 1100, AN7 = D. 1100, AN6 = D. 1100, AN5 = D. 1100, AN4 = A. 1100, AN3 = VREF +. 1100, AN2 = VREF -. 1100, AN1 = A. 1100, AN0 = A. 1100, VREF + = AN3. 1100, VREF - = AN2. 1100, C/ R = 3 / 2. 1101, AN7 = D. 1101, AN6 = D. 1101, AN5 = D.",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\n1101, AN4 = D. 1101, AN3 = VREF +. 1101, AN2 = VREF -. 1101, AN1 = A. 1101, AN0 = A. 1101, VREF + = AN3. 1101, VREF - = AN2. 1101, C/ R = 2 / 2. 1110, AN7 = D. 1110, AN6 = D. 1110, AN5 = D. 1110, AN4 = D. 1110, AN3 = D. 1110, AN2 = D. 1110, AN1 = D. 1110, AN0 = A. 1110, VREF + = VDD. 1110, VREF - = VSS. 1110, C/ R = 1 / 0. 1111, AN7 = D. 1111, AN6 = D. 1111, AN5 = D. 1111, AN4 = D. 1111, AN3 = VREF +. 1111, AN2 = VREF -. 1111, AN1 = D. 1111, AN0",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\n= A. 1111, VREF + = AN3. 1111, VREF - = AN2. 1111, C/ R = 1 / 2\nA = Analog input   D = Digital I/O\nC/R = # of analog input channels/# of A/D voltage references\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR reset\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:\nOn any device RESET, the port pins that are multiplexed with analog functions (ANx) are forced to be an analog input.\nThe analog reference voltage is software selectable to either the device's positive and negative supply voltage (VDD and VSS) or the voltage level on the RA3/AN3/ VREF+ pin and RA2/AN2/VREF-.",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\nThe A/D converter has a unique feature of being able to operate while the device is in SLEEP mode. To operate  in  SLEEP,  the  A/D  conversion  clock  must  be derived from the A/D's internal RC oscillator.\nThe output of the sample and hold is the input into the converter,  which  generates  the  result  via  successive approximation.\nA device RESET forces all registers  to  their  RESET state. This forces the A/D module to be turned off and any conversion is aborted.",
    "FIGURE 16-1: A/D BLOCK DIAGRAM\nEach port pin associated with the A/D converter can be configured as an analog input (RA3 can also be a voltage reference) or as a digital I/O.\nThe ADRESH and ADRESL registers contain the result of  the  A/D  conversion.  When  the  A/D  conversion  is complete,  the  result  is  loaded  into  the  ADRESH/ ADRESL registers, the GO/DONE bit (ADCON0<2>) is cleared, and A/D interrupt flag bit ADIF is set. The block diagram of the A/D module is shown in Figure 16-1.",
    "PIC18CXX2\nThe value that is in the ADRESH/ADRESL registers is not  modified  for  a  Power-on  Reset.  The  ADRESH/ ADRESL registers will  contain  unknown  data  after  a Power-on Reset.\nAfter the A/D module has been configured as desired, the selected channel must be acquired before the conversion  is  started.  The  analog  input  channels  must have  their  corresponding  TRIS  bits  selected  as  an input. To determine acquisition time, see Section 16.1. After this acquisition time has elapsed, the A/D conversion can be started. The following steps should be followed for doing an A/D conversion:",
    "PIC18CXX2\n1. Configure the A/D module:\n\u00b7 Configure analog pins, voltage reference and digital I/O (ADCON1)\n\u00b7 Select A/D input channel (ADCON0)\n\u00b7 Select A/D conversion clock (ADCON0)\n\u00b7 Turn on A/D module (ADCON0)\n2. Configure A/D interrupt (if desired):\n\u00b7 Clear ADIF bit\n\u00b7 Set ADIE bit\n\u00b7 Set GIE bit\n3. Wait the required acquisition time.\n4. Start conversion:\n\u00b7 Set GO/DONE bit (ADCON0)\n5. Wait for A/D conversion to complete, by either:\n\u00b7 Polling for the GO/DONE bit to be cleared OR\n\u00b7 Waiting for the A/D interrupt\n6. Read A/D Result registers (ADRESH/ADRESL); clear bit ADIF if required.\n7. For next conversion, go to step 1 or step 2, as required.  The  A/D  conversion  time  per  bit  is defined  as  TAD.  A  minimum  wait  of  2TAD  is required before next acquisition starts.",
    "16.1 A/D Acquisition Requirements\nFor the A/D converter to meet its specified accuracy, the charge holding capacitor (CHOLD) must be allowed to fully charge to the input channel voltage level. The analog  input  model  is  shown  in  Figure 16-2.  The source  impedance  (RS)  and  the  internal  sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (VDD). The source impedance affects the offset voltage at the analog input (due to pin leakage current). The maximum  recommended  impedance  for  analog sources is 2.5 k \uf057 .  After  the  analog  input  channel  is selected  (changed),  this  acquisition  must  be  done before the conversion can be started.\nNote:, 1 = When the conversion is started, the hold- ing capacitor is disconnected from the input pin.\nTo calculate the minimum acquisition time, Equation 16-1  may  be  used.  This  equation  assumes that 1/2 LSb error is used (1024 steps for the A/D). The 1/2 LSb error is the maximum error allowed for the A/D to meet its specified resolution.",
    "EQUATION 16-1: A CQUISITION TIME\nTACQ = Amplifier Settling Time + Holding Capacitor Charging Time + Temperature Coefficient = TAMP + TC + TCOFF",
    "EQUATION 16-2: A/D MINIMUM CHARGING TIME\n```\nVHOLD  = (VREF - (VREF/2048)) \u00b7 (1 - e (-Tc/CHOLD(RIC + RSS + RS)) or TC = -(120 pF)(1 k \uf057 + RSS + RS) ln(1/2047)\n```\nExample 16-1 shows the calculation  of  the  minimum required  acquisition  time  TACQ.  This  calculation  is based  on  the  following  application  system  assumptions:\n\u2022 CHOLD = 120 pF\n\u2022 Rs\n= 2.5 k \uf057\uf020\n\u2022 Conversion Error \uf0a3 1/2 LSb\n\u2022 VDD\n= 5V \uf0ae Rss = 7 k \uf057\n\u2022 Temperature = 50 C (system max.) \uf0b0\n\u2022 VHOLD = 0V @ time = 0",
    "EXAMPLE 16-1: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\n```\nTACQ = TAMP + TC + TCOFF Temperature coefficient is only required for temperatures > 25 C. \uf0b0 TACQ = 2 \uf06d s + Tc + [(Temp - 25 C)(0.05 \uf0b0 \uf06d s/ \uf0b0 C)] TC = -CHOLD (RIC + RSS + RS) ln(1/2047) -120 pF (1 k \uf057 + 7 k \uf057 + 2.5 k \uf057 ) ln(0.0004885) -120 pF (10.5 k \uf057 ) ln(0.0004885) -1.26 \uf06d s (-7.6241) 9.61 \uf06d s TACQ = 2 \uf06d s + 9.61 \uf06d s + [(50 C - 25 C)(0.05 \uf0b0 \uf0b0 \uf06d s/ \uf0b0 C)] 11.61 \uf06d s + 1.25 \uf06d s 12.86 \uf06d s\n```\n```\n)\n```",
    "16.2 Selecting the A/D Conversion Clock\nThe A/D conversion time per bit is defined as TAD. The A/D conversion requires 12 TAD per 10-bit conversion. The  source  of  the  A/D  conversion  clock  is  software selectable. The seven possible options for TAD are:\n\u00b7 2TOSC\n\u00b7 4TOSC\n\u00b7 8TOSC\n\u00b7 16TOSC\n\u00b7 32TOSC\n\u00b7 64TOSC\n\u00b7 Internal RC oscillator\nFor correct A/D conversions, the A/D conversion clock (TAD) must be selected to ensure a minimum TAD time of 1.6 \uf06d s.\nTable 16-1 shows the resultant TAD times derived from the  device  operating  frequencies  and  the  A/D  clock source selected.",
    "16.3 Configuring Analog Port Pins\nThe ADCON1, TRISA and TRISE registers control the operation  of  the  A/D  port  pins.  The  port  pins  that  are desired as analog inputs must have their corresponding TRIS bits set (input). If the TRIS bit is cleared (output), the digital output level (VOH or VOL) will be converted.\nThe A/D operation is independent of the state of the CHS2:CHS0 bits and the TRIS bits.\nNote 1: When reading the port register, all pins configured as analog input channels will read as cleared (a low level). Pins configured as digital inputs will convert an analog input. Analog levels on a digitally configured input will not affect the conversion accuracy.\n2: Analog levels on any pin that is defined as a  digital  input  (including  the  AN4:AN0 pins) may cause the input buffer to consume current  that  is  out  of  the  devices specification.",
    "TABLE 16-1: TAD vs. DEVICE OPERATING FREQUENCIES\n2T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 000. 2T OSC, Device Frequency.40 MHz = 50 ns. 2T OSC, Device Frequency.20 MHz = 100 ns (2). 2T OSC, Device Frequency.5 MHz = 400 ns (2). 2T OSC, Device Frequency.1.25 MHz = 1.6 \uf06d s. 2T OSC, Device Frequency.333.33 kHz = 6 \uf06d s. 4T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 100. 4T OSC, Device Frequency.40 MHz = 100 ns. 4T OSC, Device Frequency.20 MHz = 200 ns (2). 4T OSC, Device Frequency.5 MHz = 800 ns (2). 4T OSC, Device Frequency.1.25 MHz = 3.2 \uf06d s. 4T OSC, Device Frequency.333.33 kHz = 12 \uf06d s. 8T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 001. 8T OSC, Device Frequency.40 MHz = 200",
    "TABLE 16-1: TAD vs. DEVICE OPERATING FREQUENCIES\nns. 8T OSC, Device Frequency.20 MHz = 400 ns (2). 8T OSC, Device Frequency.5 MHz = 1.6 \uf06d s. 8T OSC, Device Frequency.1.25 MHz = 6.4 \uf06d s. 8T OSC, Device Frequency.333.33 kHz = 24 \uf06d s (3). 16T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 101. 16T OSC, Device Frequency.40 MHz = 400 ns. 16T OSC, Device Frequency.20 MHz = 800 ns (2). 16T OSC, Device Frequency.5 MHz = 3.2 \uf06d s. 16T OSC, Device Frequency.1.25 MHz = 12.8 \uf06d s. 16T OSC, Device Frequency.333.33 kHz = 48 \uf06d s (3). 32T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 010. 32T OSC, Device Frequency.40 MHz = 800 ns. 32T OSC, Device Frequency.20 MHz = 1.6 \uf06d s. 32T OSC, Device Frequency.5 MHz =",
    "TABLE 16-1: TAD vs. DEVICE OPERATING FREQUENCIES\n6.4 \uf06d s. 32T OSC, Device Frequency.1.25 MHz = 25.6 \uf06d s (3). 32T OSC, Device Frequency.333.33 kHz = 96 \uf06d s (3). 64T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 110. 64T OSC, Device Frequency.40 MHz = 1.6 \uf06d s. 64T OSC, Device Frequency.20 MHz = 3.2 \uf06d s. 64T OSC, Device Frequency.5 MHz = 12.8 \uf06d s. 64T OSC, Device Frequency.1.25 MHz = 51.2 \uf06d s (3). 64T OSC, Device Frequency.333.33 kHz = 192 \uf06d s (3). RC, AD Clock Source (T AD).ADCS2:ADCS0 = 011. RC, Device Frequency.40 MHz = 2 - 6 \uf06d s (1). RC, Device Frequency.20 MHz = 2 - 6 \uf06d s (1). RC, Device Frequency.5 MHz = 2 - 6 \uf06d s (1). RC, Device Frequency.1.25 MHz = 2 - 6 \uf06d s (1). RC,",
    "TABLE 16-1: TAD vs. DEVICE OPERATING FREQUENCIES\nDevice Frequency.333.33 kHz = 2 - 6 \uf06d s (1)\nLegend: Shaded cells are outside of recommended range.\nNote 1: The RC source has a typical TAD time of 4 \uf06d s.\n2: These values violate the minimum required TAD time.\n3: For faster conversion times, the selection of another clock source is recommended.",
    "TABLE 16-2: TAD vs. DEVICE OPERATING FREQUENCIES (FOR EXTENDED, LC, DEVICES)\n2T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 000. 2T OSC, Device Frequency.4 MHz = 500 ns (2). 2T OSC, Device Frequency.2 MHz = 1.0 \uf06d s (2). 2T OSC, Device Frequency.1.25 MHz = 1.6 \uf06d s (2). 2T OSC, Device Frequency.333.33 kHz = 6 \uf06d s. 4T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 100. 4T OSC, Device Frequency.4 MHz = 1.0 \uf06d s (2). 4T OSC, Device Frequency.2 MHz = 2.0 \uf06d s (2). 4T OSC, Device Frequency.1.25 MHz = 3.2 \uf06d s (2). 4T OSC, Device Frequency.333.33 kHz = 12 \uf06d s. 8T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 001. 8T OSC, Device Frequency.4 MHz = 2.0 \uf06d s (2).",
    "TABLE 16-2: TAD vs. DEVICE OPERATING FREQUENCIES (FOR EXTENDED, LC, DEVICES)\n8T OSC, Device Frequency.2 MHz = 4.0 \uf06d s. 8T OSC, Device Frequency.1.25 MHz = 6.4 \uf06d s. 8T OSC, Device Frequency.333.33 kHz = 24 \uf06d s (3). 16T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 101. 16T OSC, Device Frequency.4 MHz = 4.0 \uf06d s (2). 16T OSC, Device Frequency.2 MHz = 8.0 \uf06d s. 16T OSC, Device Frequency.1.25 MHz = 12.8 \uf06d s. 16T OSC, Device Frequency.333.33 kHz = 48 \uf06d s (3). 32T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 010. 32T OSC, Device Frequency.4 MHz = 8.0 \uf06d s. 32T OSC, Device Frequency.2 MHz = 16.0 \uf06d s. 32T OSC, Device Frequency.1.25 MHz = 25.6 \uf06d s (3). 32T OSC, Device Frequency.333.33 kHz",
    "TABLE 16-2: TAD vs. DEVICE OPERATING FREQUENCIES (FOR EXTENDED, LC, DEVICES)\n= 96 \uf06d s (3). 64T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 110. 64T OSC, Device Frequency.4 MHz = 16.0 \uf06d s. 64T OSC, Device Frequency.2 MHz = 32.0 \uf06d s. 64T OSC, Device Frequency.1.25 MHz = 51.2 \uf06d s (3). 64T OSC, Device Frequency.333.33 kHz = 192 \uf06d s (3). RC, AD Clock Source (T AD).ADCS2:ADCS0 = 011. RC, Device Frequency.4 MHz = 3 - 9 \uf06d s (1,4). RC, Device Frequency.2 MHz = 3 - 9 \uf06d s (1,4). RC, Device Frequency.1.25 MHz = 3 - 9 \uf06d s (1,4). RC, Device Frequency.333.33 kHz = 3 - 9 \uf06d s (1,4)\nLegend: Shaded cells are outside of recommended range.\nNote",
    "TABLE 16-2: TAD vs. DEVICE OPERATING FREQUENCIES (FOR EXTENDED, LC, DEVICES)\n1: The RC source has a typical TAD time of 6 \uf06d s.\n2: These values violate the minimum required TAD time.\n3: For faster conversion times, the selection of another clock source is recommended.",
    "16.4 A/D Conversions\nFigure 16-3 shows the operation of the A/D converter after the GO bit has been set. Clearing the GO/DONE bit  during  a  conversion  will  abort  the  current  conversion. The A/D result register pair will NOT be updated with  the  partially  completed  A/D  conversion  sample. That is, the ADRESH:ADRESL registers will continue to contain the value of the last completed conversion (or the last value written to the ADRESH:ADRESL registers). After the A/D conversion is aborted, a 2TAD wait is required before the next acquisition is started. After this 2TAD wait, acquisition on the selected channel is automatically started.\nNote: The GO/DONE bit should NOT be  set  in the same instruction that turns on the A/D.",
    "16.5 Use of the CCP2 Trigger\nAn A/D conversion can be started by the 'special event trigger'  of  the  CCP2  module.  This  requires  that  the CCP2M3:CCP2M0  bits  (CCP2CON<3:0>)  be  programmed as 1011 and that the A/D module is enabled (ADON bit is set).  When the trigger  occurs,  the  GO/ DONE bit will be set, starting the A/D conversion and the  Timer1  (or  Timer3)  counter  will  be  reset  to  zero. Timer1 (or Timer3) is reset to automatically repeat the A/D acquisition period with minimal software overhead (moving  ADRESH/ADRESL  to  the  desired  location). The appropriate analog input channel must be selected and the minimum acquisition done before the 'special event trigger' sets the GO/DONE  bit (starts a conversion).\nIf the A/D module is not enabled (ADON is cleared), the 'special event trigger' will be ignored by the A/D module, but will still reset the Timer1 (or Timer3) counter.",
    "TABLE 16-3: SUMMARY OF A/D REGISTERS\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on all other RESETS = 0000 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000 0000. PIR1, Value on all other RESETS = 0000 0000. PIE1, Bit",
    "TABLE 16-3: SUMMARY OF A/D REGISTERS\n7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000. PIE1, Value on all other RESETS = 0000 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000 0000. IPR1, Value on all other RESETS = 0000 0000. PIR2, Bit 7 = -.",
    "TABLE 16-3: SUMMARY OF A/D REGISTERS\nPIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = -. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = ---- 0000. PIR2, Value on all other RESETS = ---- 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = -. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = ---- 0000. PIE2, Value on all other RESETS = ---- 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = -. IPR2, Bit 5 = -.",
    "TABLE 16-3: SUMMARY OF A/D REGISTERS\nIPR2, Bit 4 = -. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = ---- 0000. IPR2, Value on all other RESETS = ---- 0000. ADRESH, Bit 7 = A/D Result Register. ADRESH, Bit 6 = A/D Result Register. ADRESH, Bit 5 = A/D Result Register. ADRESH, Bit 4 = A/D Result Register. ADRESH, Bit 3 = A/D Result Register. ADRESH, Bit 2 = A/D Result Register. ADRESH, Bit 1 = A/D Result Register. ADRESH, Bit 0 = A/D Result Register. ADRESH, Value on POR, BOR = xxxx xxxx. ADRESH, Value on all other RESETS = uuuu uuuu. ADRESL, Bit 7 = A/D Result Register. ADRESL, Bit 6 = A/D Result",
    "TABLE 16-3: SUMMARY OF A/D REGISTERS\nRegister. ADRESL, Bit 5 = A/D Result Register. ADRESL, Bit 4 = A/D Result Register. ADRESL, Bit 3 = A/D Result Register. ADRESL, Bit 2 = A/D Result Register. ADRESL, Bit 1 = A/D Result Register. ADRESL, Bit 0 = A/D Result Register. ADRESL, Value on POR, BOR = xxxx xxxx. ADRESL, Value on all other RESETS = uuuu uuuu. ADCON0, Bit 7 = ADCS1. ADCON0, Bit 6 = ADCS0. ADCON0, Bit 5 = CHS2. ADCON0, Bit 4 = CHS1. ADCON0, Bit 3 = CHS0. ADCON0, Bit 2 = GO/ DONE. ADCON0, Bit 1 = -. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = 0000 00-0. ADCON0, Value on all other RESETS = 0000 00-0. ADCON1, Bit 7 = ADFM.",
    "TABLE 16-3: SUMMARY OF A/D REGISTERS\nADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = ---- -000. ADCON1, Value on all other RESETS = ---- -000. PORTA, Bit 7 = -. PORTA, Bit 6 = RA6. PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = --0x 0000. PORTA, Value on all other RESETS = --0u 0000. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data Direction Register. TRISA, Bit 5 =",
    "TABLE 16-3: SUMMARY OF A/D REGISTERS\nPORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = --11 1111. TRISA, Value on all other RESETS = --11 1111. PORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = -. PORTE, Bit 2 = RE2. PORTE, Bit 1 = RE1. PORTE, Bit 0 = RE0. PORTE, Value on POR, BOR = ---- -000. PORTE, Value on all other RESETS = ---- -000. LATE, Bit 7 = -. LATE, Bit 6 = -. LATE, Bit 5 = -. LATE, Bit 4 = -. LATE, Bit 3 = -. LATE, Bit 2 = LATE2. LATE, Bit 1 = LATE1. LATE, Bit 0 =",
    "TABLE 16-3: SUMMARY OF A/D REGISTERS\nLATE0. LATE, Value on POR, BOR = ---- -xxx. LATE, Value on all other RESETS = ---- -uuu. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE, Bit 3 = -. TRISE, Bit 2 = PORTE Data Direction bits. TRISE, Bit 1 = PORTE Data Direction bits. TRISE, Bit 0 = PORTE Data Direction bits. TRISE, Value on POR, BOR = 0000 -111. TRISE, Value on all other RESETS = 0000 -111\nLegend: x = unknown, u = unchanged, - = unimplemented, read as '0'.  Shaded cells are not used for A/D conversion.\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices. Always maintain these bits clear.",
    "17.0 LOW VOLTAGE DETECT\nIn  many  applications,  the  ability  to  determine  if  the device voltage (VDD) is below a specified voltage level is  a  desirable  feature.  A  window  of  operation  for  the application can be created, where the application software can do 'housekeeping tasks' before the device voltage  exits  the  valid  operating  range.  This  can  be done using the Low Voltage Detect module.\nThe Low Voltage Detect circuitry is completely under software control. This allows the circuitry to be 'turned off' by the software, which minimizes the current consumption for the device.\nThis  module  is  a  software  programmable  circuitry, where  a  device  voltage  trip  point  can  be  specified. When the voltage of the device becomes lower then the specified point, an interrupt flag is set. If the interrupt is enabled, the program execution will branch to the interrupt vector address and the software can then respond to that interrupt source.",
    "17.0 LOW VOLTAGE DETECT\nFigure 17-1 shows a possible application voltage curve (typically for batteries). Over time, the device voltage decreases. When the device voltage equals voltage VA, the  LVD  logic  generates  an  interrupt.  This  occurs  at time  TA.  The  application  software  then  has  the  time, until the device voltage is no longer in valid operating range, to shut-down the system. Voltage point VB is the minimum  valid  operating  voltage  specification.  This occurs at time TB. The difference TB - TA is the total time for shut-down.",
    "FIGURE 17-1: TYPICAL LOW VOLTAGE DETECT APPLICATION\nThe  block  diagram  for  the  LVD  module  is  shown  in Figure 17-2.  A  comparator  uses  an  internally  generated  reference  voltage  as  the  set  point.  When  the selected tap output of the device voltage crosses the set point (is lower than), the LVDIF bit is set.\nEach  node  in  the  resistor  divider  represents  a  'trip point' voltage. The 'trip point' voltage is the minimum supply voltage level at which the device can operate before the LVD module asserts an interrupt. When the supply  voltage  is  equal  to  the  trip  point,  the  voltage tapped  off  of  the  resistor  array  is  equal  to  the  1.2V internal  reference  voltage  generated  by  the  voltage reference module. The comparator then generates an interrupt  signal  setting  the  LVDIF  bit.  This  voltage  is software programmable to any one of 16 values (see Figure 17-2).  The  trip  point  is  selected  by  programming the LVDL3:LVDL0 bits (LVDCON<3:0>).",
    "FIGURE 17-2: LOW VOLTAGE DETECT (LVD) BLOCK DIAGRAM\nThe LVD module has an additional feature that allows the user to supply the trip voltage to the module from an  external  source.  This  mode  is  enabled  when  bits LVDL3:LVDL0 are set to 1111 . In this state, the comparator input is multiplexed from the external input pin LVDIN (Figure 17-3).\nThis gives flexibility, because it allows a user to configure the  Low Voltage Detect interrupt to occur at any voltage in the valid operating range.",
    "17.1 Control Register\nThe Low Voltage Detect Control register controls the operation of the Low Voltage Detect circuitry.",
    "REGISTER 17-1: LVDCON REGISTER\nU-0, 1 = U-0. U-0, 2 = R-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-1. U-0, 6 = R/W-0. U-0, 7 = R/W-1. -, 1 = -. -, 2 = IRVST. -, 3 = LVDEN. -, 4 = LVDL3. -, 5 = LVDL2. -, 6 = LVDL1. -, 7 = LVDL0\nbit 7\nbit 0",
    "bit 7-6 Unimplemented: Read as '0'\nbit 5\nIRVST: Internal Reference Voltage Stable Flag bit\n1 = Indicates that the Low Voltage Detect logic will generate the interrupt flag at the specified voltage range\n0 = Indicates that the Low Voltage Detect logic will not generate the interrupt flag at the specified voltage range and the LVD interrupt should not be enabled",
    "bit 4 LVDEN:\nLow Voltage Detect Power Enable bit\n1 = Enables LVD, powers up LVD circuit\n0 = Disables LVD, powers down LVD circuit",
    "bit 3-0 LVDL3:LVDL0: Low Voltage Detection Limit bits\n1111 = External analog input is used (input comes from the LVDIN pin)\n1110 = 4.5V min. - 4.77V max.\n1101 = 4.2V min. - 4.45V max.\n1100 = 4.0V min. - 4.24V max.\n1011 = 3.8V min. - 4.03V max.\n1010 = 3.6V min. - 3.82V max.\n1001 = 3.5V min. - 3.71V max.\n1000 = 3.3V min. - 3.50V max.\n0111 = 3.0V min. - 3.18V max.\n0110 = 2.8V min. - 2.97V max.\n0101 = 2.7V min. - 2.86V max.\n0100 = 2.5V min. - 2.65V max.\n0011 = 2.4V min. - 2.54V max.\n0010 = 2.2V min. - 2.33V max.",
    "bit 3-0 LVDL3:LVDL0: Low Voltage Detection Limit bits\n0001 = 2.0V min. - 2.12V max.\n0000 = 1.8V min. - 1.91V max.\nNote: LVDL3:LVDL0 modes which result in a trip point below the valid operating voltage of the device are not tested.\nLegend:, 1 = Legend:. R = Readable bit, 1 = W=Writable bit. U = Unimplemented bit, read as '0', 1 = - n = Value at POR reset",
    "17.2 Operation\nDepending on the power source for the device voltage, the voltage normally decreases relatively slowly. This means that the LVD module does not need to be constantly  operating.  To  decrease  the  current  requirements, the LVD circuitry only needs to be enabled for short  periods,  where  the  voltage  is  checked.  After doing the check, the LVD module may be disabled.\nEach time that the LVD module is enabled, the circuitry requires some time to stabilize. After the circuitry has stabilized, all status flags may be cleared. The module will then indicate the proper state of the system.\nThe following steps are needed to set up the LVD module:",
    "17.2 Operation\n1. Write the value to the LVDL3:LVDL0 bits (LVDCON register),  which  selects  the  desired  LVD Trip Point.\n2. Ensure  that  LVD  interrupts  are  disabled  (the LVDIE bit is cleared, or the GIE bit is cleared).\n3. Enable the LVD module (set the LVDEN bit in the LVDCON register).\n4. Wait for the LVD module to stabilize (the IRVST bit to become set).\n5. Clear  the  LVD  interrupt  flag,  which  may  have falsely  become  set  until  the  LVD  module  has stabilized (clear the LVDIF bit).\n6. Enable the LVD interrupt (set the LVDIE and the GIE bits).\nFigure 17-4  shows  typical  waveforms  that  the  LVD module may be used to detect.",
    "17.2.1 REFERENCE VOLTAGE SET POINT\nThe Internal Reference Voltage of the LVD module may be  used  by  other  internal  circuitry  (the  Programmable Brown-out Reset). If these  circuits  are  disabled  (lower current consumption), the reference voltage circuit requires a time to become stable before a low voltage condition can be reliably detected. This time is invariant of system clock speed. This start-up time is specified in electrical specification parameter #36. The low voltage interrupt flag will not be enabled until a stable reference voltage is reached. Refer to the waveform in Figure 17-4.",
    "17.2.2 CURRENT CONSUMPTION\nWhen the module is enabled, the LVD comparator and voltage divider are enabled and will consume static current. The voltage divider can be tapped from multiple places in the resistor array. Total current consumption, when  enabled,  is  specified  in  electrical  specification parameter #D022B.",
    "17.3 Operation During SLEEP\nWhen enabled, the LVD circuitry continues to operate during  SLEEP.  If  the  device  voltage  crosses  the  trip point, the LVDIF bit will be set and the device will wakeup  from  SLEEP.  Device  execution  will  continue  from the interrupt vector address, if interrupts have been globally enabled.",
    "17.4 Effects of a RESET\nA device RESET forces all registers to their RESET state. This forces the LVD module to be turned off.",
    "PIC18CXX2\nNOTES:",
    "18.0 SPECIAL FEATURES OF THE CPU\nThere are several features intended to maximize system  reliability,  minimize  cost  through  elimination  of external components, provide power saving operating modes and offer code protection. These are:\n\u00b7 OSC Selection\n\u00b7 RESET\n-Power-on Reset (POR)\n-Power-up Timer (PWRT)\n-Oscillator Start-up Timer (OST)\n-Brown-out Reset (BOR)\n\u00b7 Interrupts\n\u00b7 Watchdog Timer (WDT)\n\u00b7 SLEEP\n\u00b7 Code Protection\n\u00b7 ID Locations\n\u00b7 In-circuit Serial Programming\nAll PIC18CXX2 devices have a Watchdog Timer, which is  permanently  enabled  via  the  configuration  bits  or software-controlled. It runs off its own RC oscillator for added reliability. There are two timers that offer necessary delays on power-up. One is the Oscillator Start-up Timer (OST), intended to keep the chip in RESET until the crystal oscillator is stable. The other is the Powerup  Timer  (PWRT),  which  provides  a  fixed  delay  on power-up only,  designed  to  keep  the  part  in  RESET while the power supply stabilizes. With these two timers on-chip, most applications need no external RESET circuitry.",
    "TABLE 18-1: CONFIGURATION BITS AND DEVICE IDS\n300000h, File Name = CONFIG1L. 300000h, Bit 7 = CP. 300000h, Bit 6 = CP. 300000h, Bit 5 = CP. 300000h, Bit 4 = CP. 300000h, Bit 3 = CP. 300000h, Bit 2 = CP. 300000h, Bit 1 = CP. 300000h, Bit 0 = CP. 300000h, Default/ Unprogrammed Value = 1111 1111. 300001h, File Name = CONFIG1H. 300001h, Bit 7 = -. 300001h, Bit 6 = -. 300001h, Bit 5 = OSCSEN. 300001h, Bit 4 = -. 300001h, Bit 3 = -. 300001h, Bit 2 = FOSC2. 300001h, Bit 1 = FOSC1. 300001h, Bit 0 = FOSC0. 300001h, Default/ Unprogrammed Value = 111- -111. 300002h, File Name = CONFIG2L. 300002h, Bit 7 = -. 300002h, Bit",
    "TABLE 18-1: CONFIGURATION BITS AND DEVICE IDS\n6 = -. 300002h, Bit 5 = -. 300002h, Bit 4 = -. 300002h, Bit 3 = BORV1. 300002h, Bit 2 = BORV0. 300002h, Bit 1 = BODEN. 300002h, Bit 0 = PWRTEN. 300002h, Default/ Unprogrammed Value = ---- 1111. 300003h, File Name = CONFIG2H. 300003h, Bit 7 = -. 300003h, Bit 6 = -. 300003h, Bit 5 = -. 300003h, Bit 4 = -. 300003h, Bit 3 = WDTPS2. 300003h, Bit 2 = WDTPS1. 300003h, Bit 1 = WDTPS0. 300003h, Bit 0 = WDTEN. 300003h, Default/ Unprogrammed Value = ---- 1111. 300005h, File Name = CONFIG3H. 300005h, Bit 7 = -.",
    "TABLE 18-1: CONFIGURATION BITS AND DEVICE IDS\n300005h, Bit 6 = -. 300005h, Bit 5 = -. 300005h, Bit 4 = -. 300005h, Bit 3 = -. 300005h, Bit 2 = -. 300005h, Bit 1 = -. 300005h, Bit 0 = CCP2MX. 300005h, Default/ Unprogrammed Value = ---- ---1. 300006h, File Name = CONFIG4L. 300006h, Bit 7 = -. 300006h, Bit 6 = -. 300006h, Bit 5 = -. 300006h, Bit 4 = -. 300006h, Bit 3 = -. 300006h, Bit 2 = -. 300006h, Bit 1 = LVEN. 300006h, Bit 0 = STVREN. 300006h, Default/ Unprogrammed Value = ---- --11. 3FFFFEh, File Name = DEVID1. 3FFFFEh, Bit 7 = DEV2. 3FFFFEh, Bit 6 =",
    "TABLE 18-1: CONFIGURATION BITS AND DEVICE IDS\nDEV1. 3FFFFEh, Bit 5 = DEV0. 3FFFFEh, Bit 4 = REV4. 3FFFFEh, Bit 3 = REV3. 3FFFFEh, Bit 2 = REV2. 3FFFFEh, Bit 1 = REV1. 3FFFFEh, Bit 0 = REV0. 3FFFFEh, Default/ Unprogrammed Value = 0000 0000. 3FFFFFh, File Name = DEVID2. 3FFFFFh, Bit 7 = DEV10. 3FFFFFh, Bit 6 = DEV9. 3FFFFFh, Bit 5 = DEV8. 3FFFFFh, Bit 4 = DEV7. 3FFFFFh, Bit 3 = DEV6. 3FFFFFh, Bit 2 = DEV5. 3FFFFFh, Bit 1 = DEV4. 3FFFFFh, Bit 0 = DEV3. 3FFFFFh, Default/ Unprogrammed Value = 0000 0010\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition.",
    "TABLE 18-1: CONFIGURATION BITS AND DEVICE IDS\nShaded cells are unimplemented, read as '0'\nSLEEP mode is designed to offer a very low current Power-down  mode.  The  user  can  wake-up  from SLEEP  through  external  RESET,  Watchdog  Timer Wake-up  or  through  an  interrupt.  Several  oscillator options are also made available to allow the part to fit the application. The RC oscillator option saves system cost, while the LP crystal option saves power. A set of configuration bits are used to select various options.",
    "18.1 Configuration Bits\nThe configuration bits can be programmed (read as '0'), or  left  unprogrammed  (read  as  '1'),  to  select  various device configurations. These bits are mapped starting at program memory location 300000h.\nThe user will note that address 300000h is beyond the user program memory space. In fact, it belongs to the configuration  memory  space  (300000h  -  3FFFFFh), which  can  only  be  accessed  using  table  reads  and table writes.",
    "REGISTER 18-1: CONFIGURATION REGISTER 1 HIGH (CONFIG1H: BYTE ADDRESS 300001h)\nR/P-1, 1 = R/P-1. R/P-1, 2 = R/P-1. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = R/P-1. R/P-1, 6 = R/P-1. R/P-1, 7 = R/P-1. Reserved, 1 = Reserved. Reserved, 2 = OSCSEN. Reserved, 3 = -. Reserved, 4 = -. Reserved, 5 = FOSC2. Reserved, 6 = FOSC1. Reserved, 7 = FOSC0\nbit 7\nbit 0",
    "bit 7-6 Reserved: Read as '1'\nbit 5\nOSCSEN : Oscillator System Clock Switch Enable bit\n1 = Oscillator system clock switch option is disabled (main oscillator is source)\n0 = Oscillator system clock switch option is enabled (oscillator switching is enabled)\nbit 4-3 Unimplemented: Read as '0'\nbit 2-0 FOSC2:FOSC0 : Oscillator Selection bits\n111 = RC oscillator w/OSC2 configured as RA6\n110 = HS oscillator with PLL enabled/Clock frequency = (4 x FOSC)\n101 = EC oscillator w/OSC2 configured as RA6\n100 = EC oscillator w/OSC2 configured as divide-by-4 clock output\n011 = RC oscillator\n010 = HS oscillator\n001 = XT oscillator\n000 = LP oscillator\nLegend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 18-2: CONFIGURATION REGISTER 1 LOW (CONFIG1L: BYTE ADDRESS 300000h)\nR/P-1, 1 = R/P-1. R/P-1, 2 = R/P-1. R/P-1, 3 = R/P-1. R/P-1, 4 = R/P-1. R/P-1, 5 = R/P-1. R/P-1, 6 = R/P-1. R/P-1, 7 = R/P-1. CP, 1 = CP. CP, 2 = CP. CP, 3 = CP. CP, 4 = CP. CP, 5 = CP. CP, 6 = CP. CP, 7 = CP\nbit 7\nbit 0\nbit 7-0\nCP: Code Protection bits (apply when in Code Protected Microcontroller mode)\n1 = Program memory code protection off\n0 = All of program memory code protected\nLegend:, 1 = Legend:. R = Readable bit P = Programmable, 1 = U = Unimplemented bit, read as '0'. - n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "CONFIGURATION REGISTER 2 HIGH (CONFIG2H: BYTE ADDRESS 300003h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = WDTPS2. -, 5 = WDTPS1. -, 6 = WDTPS0. -, 7 = WDTEN\nbit 7\nbit 0\nbit 7-4 Unimplemented: Read as '0'\nbit 3-1 WDTPS2:WDTPS0: Watchdog Timer Postscale Select bits\n111 = 1:1\n110 = 1:2\n101 = 1:4\n100 = 1:8\n011 = 1:16\n010 = 1:32\n001 = 1:64\n000 = 1:128",
    "bit 0 WDTEN: Watchdog Timer Enable bit\n1 = WDT enabled\n0 = WDT disabled (control is placed on the SWDTEN bit)\nLegend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 18-4: CONFIGURATION REGISTER 2 LOW (CONFIG2L: BYTE ADDRESS 300002h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = BORV1. -, 5 = BORV0. -, 6 = BOREN. -, 7 = PWRTEN\nbit 7\nbit 0\nbit 7-4 Unimplemented: Read as '0'\nbit 3-2 BORV1:BORV0: Brown-out Reset Voltage bits\n11 = VBOR set to 2.5V\n10 = VBOR set to 2.7V\n01 = VBOR set to 4.2V\n00 = VBOR set to 4.5V",
    "bit 1 BOREN: Brown-out Reset Enable bit (1)\n1 = Brown-out Reset enabled\n0 = Brown-out Reset disabled\nNote:\nEnabling  Brown-out  Reset  automatically  enables  the  Power-up  Timer  (PWRT), regardless of the value of bit PWRTEN. Ensure the Power-up Timer is enabled any time Brown-out Reset is enabled.",
    "bit 0 PWRTEN:\nPower-up Timer Enable bit (1)\n1 = PWRT disabled\n0 = PWRT enabled\nNote:\nEnabling  Brown-out  Reset  automatically  enables  the  Power-up  Timer  (PWRT), regardless of the value of bit PWRTE. Ensure the Power-up Timer is enabled any time Brown-out Reset is enabled.\nLegend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 18-5: CONFIGURATION REGISTER 3 HIGH (CONFIG3H: BYTE ADDRESS 300005h)\nU-0\nU-0\nU-0\nU-0\nU-0\nU-0\nU-0\nR/P-1\n-\n-\n-\n-\n-\n-\n-\nCCP2MX\nbit 7\nbit 0",
    "bit 7-1 Unimplemented: Read as '0'\nbit 0\nCCP2MX: CCP2 Mux bit\n1 = CCP2 input/output is multiplexed with RC1\n0 = CCP2 input/output is multiplexed with RB3\nLegend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 18-6: CONFIGURATION REGISTER 4 LOW (CONFIG4L: BYTE ADDRESS 300006h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = Reserved. -, 7 = STVREN\nbit 7\nbit 0\nbit 7-2 Unimplemented:\nRead as '0'\nbit 1 Reserved: Maintain this bit set\nbit 0 STVREN:\nStack Full/Underflow Reset Enable bit\n1 = Stack Full/Underflow will cause RESET\n0 = Stack Full/Underflow will not cause RESET\nLegend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "18.2 Watchdog Timer (WDT)\nThe  Watchdog  Timer  is  a  free  running,  on-chip  RC oscillator, which does not require any external components. This RC oscillator is separate from the RC oscillator of the OSC1/CLKI pin. That means that the WDT will run, even if the clock on the OSC1/CLKI and OSC2/ CLKO/RA6 pins of the device has been stopped, for example, by execution of a SLEEP instruction.\nDuring normal operation, a WDT time-out generates a device RESET (Watchdog Timer Reset). If the device is in SLEEP mode, a WDT time-out causes the device to wake-up and continue with normal operation (Watchdog Timer Wake-up). The TO bit in the RCON register will be cleared upon a WDT time-out.\nThe Watchdog Timer is enabled/disabled by a device configuration bit. If the WDT is enabled, software execution may not disable this function. When the WDTEN configuration bit is cleared, the SWDTEN bit enables/ disables the operation of the WDT.",
    "18.2 Watchdog Timer (WDT)\nThe WDT time-out period values may be found in the Electrical Specifications section under parameter #31. Values for the WDT postscaler may be assigned using the configuration bits.\nNote:\nThe CLRWDT and SLEEP instructions clear the WDT and the postscaler, if assigned to the  WDT,  and  prevent  it  from  timing  out and generating a device RESET condition.\nNote:\nWhen  a CLRWDT instruction  is  executed and the postscaler is assigned to the WDT, the postscaler count will be cleared, but the postscaler assignment is not changed.",
    "18.2.1 CONTROL REGISTER\nRegister 18-7 shows the WDTCON register. This is a readable and writable register, which contains a control bit  that  allows  software  to  override  the  WDT  enable configuration bit,  only  when  the  configuration  bit  has disabled the WDT.",
    "REGISTER 18-7: WDTCON REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = SWDTEN\nbit 7\nbit 0",
    "bit 7-1 Unimplemented : Read as '0'\nbit 0\nSWDTEN: Software Controlled Watchdog Timer Enable bit\n1 = Watchdog Timer is on\n0 = Watchdog Timer is turned off if the WDTEN configuration bit in the configuration register = '0'\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR Reset",
    "18.2.2 WDT POSTSCALER\nThe WDT has a postscaler that can extend the WDT Reset period. The postscaler is selected at the time of device  programming,  by  the  value  written  to  the CONFIG2H configuration register.",
    "TABLE 18-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nCONFIG2H, Bit 7 = -. CONFIG2H, Bit 6 = -. CONFIG2H, Bit 5 = -. CONFIG2H, Bit 4 = -. CONFIG2H, Bit 3 = WDTPS2. CONFIG2H, Bit 2 = WDTPS2. CONFIG2H, Bit 1 = WDTPS0. CONFIG2H, Bit 0 = WDTEN. RCON, Bit 7 = IPEN. RCON, Bit 6 = LWRT. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. WDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN",
    "TABLE 18-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nLegend: Shaded cells are not used by the Watchdog Timer.",
    "18.3 Power-down Mode (SLEEP)\nPower-down mode is entered by executing a SLEEP instruction.\nIf  enabled,  the  Watchdog  Timer  will  be  cleared,  but keeps running, the PD bit (RCON<3>) is cleared, the TO (RCON<4>) bit is set, and the oscillator driver is turned off. The I/O ports maintain the status they had before  the SLEEP instruction  was  executed  (driving high, low, or hi-impedance).\nFor lowest current consumption in this mode, place all I/O pins at either VDD or VSS, ensure no external circuitry is drawing current from the I/O pin, power-down the A/D and disable external clocks. Pull all I/O pins that are hi-impedance inputs, high or low externally, to avoid switching currents caused by floating inputs. The T0CKI input should also be at VDD or VSS for lowest current  consumption.  The  contribution  from  on-chip pull-ups on PORTB should be considered.\nThe MCLR pin must be at a logic high level (VIHMC).",
    "18.3.1 WAKE-UP FROM SLEEP\nThe device can wake up from SLEEP through one of the following events:\n1. External RESET input on MCLR pin.\n2. Watchdog Timer Wake-up (if WDT was enabled).\n3. Interrupt  from  INT  pin,  RB  port  change,  or  a Peripheral Interrupt.\nThe following peripheral interrupts can wake the device from SLEEP:\n1. PSP read or write.\n2. TMR1 interrupt. Timer1 must be operating as an asynchronous counter.\n3. TMR3 interrupt. Timer3 must be operating as an asynchronous counter.\n4. CCP capture mode interrupt.\n5. Special event trigger (Timer1 in Asynchronous mode using an external clock).\n6. MSSP (START/STOP) bit detect interrupt.\n7. MSSP transmit or receive in Slave mode (SPI/I 2 C).\n8. USART RX or TX (Synchronous Slave mode).\n9. A/D conversion (when A/D clock source is RC).\nOther  peripherals  cannot  generate  interrupts,  since during SLEEP, no on-chip clocks are present.",
    "18.3.1 WAKE-UP FROM SLEEP\nExternal MCLR Reset will cause a device RESET. All other events are considered a continuation of program execution and will cause a 'wake-up'. The TO and PD bits in the RCON register can be used to determine the cause of the device RESET. The PD bit, which is set on power-up, is cleared when SLEEP is invoked. The TO bit is cleared, if a WDT time-out occurred (and caused wake-up).\nWhen the SLEEP instruction is being executed, the next instruction (PC + 2) is pre-fetched. For the device to wake-up through an interrupt event, the corresponding interrupt enable bit must be set (enabled). Wake-up is regardless of the state of the GIE bit. If the GIE bit is clear (disabled), the device continues execution at the instruction after the SLEEP instruction. If the GIE bit is set (enabled), the device executes the instruction after the SLEEP instruction and then branches to the interrupt  address.  In  cases  where  the  execution  of  the instruction following SLEEP is not desirable, the user should have a NOP after the SLEEP instruction.",
    "18.3.2 WAKE-UP USING INTERRUPTS\nWhen global interrupts are disabled (GIE cleared) and any interrupt  source  has  both  its  interrupt  enable  bit and interrupt flag bit set, one of the following will occur:\n\u00b7 If an interrupt condition (interrupt flag bit and interrupt enable bits are set) occurs before the execution of a SLEEP instruction, the SLEEP instruction will complete as a NOP . Therefore, the WDT and WDT postscaler will not be cleared, the TO bit will not be set and PD bits will not be cleared.\n\u00b7 If the interrupt condition occurs during or after the execution of a SLEEP instruction, the device will immediately wake up from SLEEP. The SLEEP instruction will be completely executed before the wake-up. Therefore, the WDT and WDT postscaler will be cleared, the TO bit will be set and the PD bit will be cleared.\nEven if the flag bits were checked before executing a SLEEP instruction,  it  may  be  possible  for  flag  bits  to become set before the SLEEP instruction completes. To determine whether a SLEEP instruction executed, test the PD bit. If the PD bit is set, the SLEEP instruction was executed as a NOP .",
    "18.3.2 WAKE-UP USING INTERRUPTS\nTo ensure that the WDT is cleared, a CLRWDT instruction should be executed before a SLEEP instruction.",
    "FIGURE 18-2: WAKE-UP FROM SLEEP THROUGH INTERRUPT (1,2)\nNote 1: XT, HS or LP oscillator mode assumed.\n2: GIE = '1' assumed. In this case, after wake- up, the processor jumps to the interrupt routine. If GIE = '0', execution will continue in-line.\n3: TOST = 1024TOSC (drawing not to scale) This delay will not occur for RC and EC osc modes.\n4: CLKOUT is not available in these osc modes, but shown here for timing reference.",
    "18.6 In-Circuit Serial Programming\nIf the code  protection  bit(s) have  not  been  programmed, the on-chip program memory can be read out for verification purposes.\nNote:, 1 = Microchip Technology does not recom- mend code protecting windowed devices.",
    "18.5 ID Locations\nFive memory locations (200000h - 200004h) are designated as ID locations, where the user can store checksum  or  other  code  identification numbers.  These locations are accessible during normal execution through the TBLRD instruction or during program/verify. The ID locations can be read when the device is code protected.\nPIC18CXXX  microcontrollers can be serially programmed while in the end application circuit. This is simply done with two lines for clock and data, and three other  lines  for  power,  ground  and  the  programming voltage. This allows customers to manufacture boards with  unprogrammed  devices,  and  then  program  the microcontroller just before shipping the product. This also allows the most recent firmware or a custom firmware to be programmed.",
    "19.0 INSTRUCTION SET SUMMARY\nThe PIC18CXXX instruction set adds many enhancements to the previous PIC instruction sets, while maintaining an easy migration from these PIC  MCU instruction sets.\nMost instructions are a single program memory word (16-bits),  but  there  are  three  instructions  that  require two program memory locations.\nEach single word instruction is a 16-bit word divided into an OPCODE, which specifies the instruction type and one or more operands, which further specify the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18CXXX instruction set summary in Table 19-2 lists byte-oriented , bit-oriented , literal and control operations. Table 19-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')\nThe file register designator 'f' specifies which file register is to be used by the instruction.",
    "19.0 INSTRUCTION SET SUMMARY\nThe  destination  designator  'd'  specifies  where  the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result  is  placed  in  the  file  register  specified  in  the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "19.0 INSTRUCTION SET SUMMARY\n\u00b7 A program memory address (specified by 'n')\n\u00b7 The mode of the Call or Return instructions (specified by 's')\n\u00b7 The mode of the Table Read and Table Write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll instructions are a single word, except for three double  word  instructions.  These  three  instructions  were made double word instructions so that all the required information is available in these 32-bits. In the second word, the 4 MSb's are 1's. If this second word is executed as an instruction (by itself), it will execute as a NOP .\nAll  single  word  instructions  are  executed  in  a  single instruction cycle, unless a conditional test is true or the program counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles, with the additional instruction cycle(s) executed as a NOP .\nThe double word instructions execute in two instruction cycles.",
    "19.0 INSTRUCTION SET SUMMARY\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \uf06d s. If a conditional test is true, or the program counter is changed as a result of an instruction, the instruction  execution  time is  2 \uf06d s. Two word branch instructions (if true) would take 3 \uf06d s.\nFigure 19-1 shows the general formats that the instructions can have.\nAll  examples  use  the  format 'nnh' to  represent  a hexadecimal number, where 'h' signifies a hexadecimal digit.\nThe  Instruction  Set  Summary,  shown  in  Table 19-2, lists the instructions recognized  by  the  Microchip assembler (MPASM TM ).\nSection 19.1 provides a description of each instruction.",
    "TABLE 19-1: OPCODE FIELD DESCRIPTIONS\na, Description = RAM access bit a = 0: RAM location in Access RAM (BSR register is ignored) a = 1: RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7). BSR, Description = Bank Select Register. Used to select the current RAM bank.. d, Description = Destination select bit; d = 0: store result in WREG, d = 1: store result in file register f.. dest, Description = Destination either the WREG register or the specified register file location. f, Description = 8-bit Register file address (0x00 to 0xFF). fs, Description = 12-bit Register file address (0x000 to 0xFFF). This is the source address.. fd, Description = 12-bit Register file address (0x000 to 0xFFF). This is the destination address.. k, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value). label, Description = Label name. mm *, Description = The mode",
    "TABLE 19-1: OPCODE FIELD DESCRIPTIONS\nof the TBLPTR register for the Table Read and Table Write instructions Only used with Table Read and Table Write instructions: No Change to register (such as TBLPTR with Table reads and writes) Post-Increment register (such as TBLPTR with Table reads and writes). *+, Description = . *-, Description = Post-Decrement register (such as TBLPTR with Table reads and writes). +*, Description = Pre-Increment register (such as TBLPTR with Table reads and writes). n, Description = The relative address (2's complement number) for relative branch instructions, or the direct address for Call/Branch and Return instructions. PRODH, Description = Product of Multiply high byte. PRODL, Description = Product of Multiply low byte. s, Description = Fast Call/Return mode select bit. s = 0: do not update into/from shadow registers s = 1: certain registers loaded into/from shadow registers (Fast mode). u, Description = Unused or Unchanged. WREG, Description = Working register (accumulator). x, Description = Don't care (0 or 1) The assembler will",
    "TABLE 19-1: OPCODE FIELD DESCRIPTIONS\ngenerate code with x = 0. It is the recommended form of use for compatibility with all Microchip software tools.. TBLPTR, Description = 21-bit Table Pointer (points to a Program Memory location). TABLAT, Description = 8-bit Table Latch. TOS, Description = Top-of-Stack. PC, Description = Program Counter. PCL, Description = Program Counter Low Byte. PCH, Description = Program Counter High Byte. PCLATH, Description = Program Counter High Byte Latch. PCLATU, Description = Program Counter Upper Byte Latch. GIE, Description = Global Interrupt Enable bit. WDT, Description = Watchdog Timer. TO, Description = Time-out bit. PD, Description = Power-down bit. C, DC, Z, OV,, Description = ALU status bits Carry, Digit Carry, Zero, Overflow, Negative. [ ], Description = Optional. ( ), Description = Contents. \uf0ae, Description = Assigned to. < >, Description = Register bit field In the set of. \uf0ce italics, Description = User defined term (font is courier)",
    "GENERAL FORMAT FOR INSTRUCTIONS\nByte-oriented file register operations\n15                  10      9     8   7                               0\nd = 0 for result destination to be WREG register\nOPCODE     d      a              f (FILE #)\nd = 1 for result destination to be file register (f)\na = 0 to force Access Bank\nBit-oriented file register operations\n15          12 11          9  8   7                                0\nOPCODE  b (BIT #)   a        f (FILE #)\nb = 3-bit position of bit in file register (f)\nLiteral operations\n15                              8    7                                 0\nOPCODE                       k  (literal)\nk = 8-bit immediate value\nByte to Byte move operations (2-word)\n15           12  11                                                0\nOPCODE                     f (Source FILE #)\nCALL, GOTO and Branch operations\n15                                    8  7                            0\nOPCODE                   n<7:0> (literal)\nn = 20-bit immediate value\na = 1 for BSR to select bank\nf  = 8-bit file register address\na = 0 to force Access Bank\na = 1 for BSR to select bank\nf  = 8-bit file register address\n15                  12   11                                         0\n1111\nn<19:8> (literal)\n15           12  11                                                0\n1111\nf (Destination FILE #)\nf = 12-bit file register address\nControl operations\nExample Instruction\nADDWF MYREG, W, B",
    "GENERAL FORMAT FOR INSTRUCTIONS\nMOVFF MYREG1, MYREG2\nBSF MYREG, bit, B\nMOVLW 0x7F\nGOTO Label\n15                                    8   7                             0\nOPCODE                   n<7:0> (literal)\n15                  12   11                                           0\nn<19:8> (literal)\nCALL MYFUNC\n15                       11  10                                       0\nOPCODE                   n<10:0> (literal)\nS = Fast bit\nBRA MYFUNC\n15                               8  7                                   0\nOPCODE                      n<7:0> (literal)\nBC MYFUNC\nS",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nBYTE-ORIENTED FILE REGISTER OPERATIONS, Operands = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Description. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Cycles. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-bit Instruction Word.MSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-bit Instruction Word.MSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-bit Instruction Word. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-bit Instruction Word.LSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Notes. = BYTE-ORIENTED FILE REGISTER OPERATIONS. ADDWF, Operands = f, d, a. ADDWF, Description. = Add WREG and f. ADDWF, Cycles. = 1. ADDWF, 16-bit Instruction Word.MSb = 0010. ADDWF, 16-bit Instruction Word.MSb = 01da.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nADDWF, 16-bit Instruction Word. = ffff. ADDWF, 16-bit Instruction Word.LSb = ffff. ADDWF, Status.Affected = C, DC, Z, OV, N. ADDWF, Notes. = 1, 2. ADDWFC, Operands = f, d, a. ADDWFC, Description. = Add WREG and Carry bit to f. ADDWFC, Cycles. = 1. ADDWFC, 16-bit Instruction Word.MSb = 0010. ADDWFC, 16-bit Instruction Word.MSb = 00da. ADDWFC, 16-bit Instruction Word. = ffff. ADDWFC, 16-bit Instruction Word.LSb = ffff. ADDWFC, Status.Affected = C, DC, Z, OV, N. ADDWFC, Notes. = 1, 2. ANDWF, Operands = f, d, a. ANDWF, Description. = AND WREG with f. ANDWF, Cycles. = 1. ANDWF, 16-bit Instruction Word.MSb = 0001.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nANDWF, 16-bit Instruction Word.MSb = 01da. ANDWF, 16-bit Instruction Word. = ffff. ANDWF, 16-bit Instruction Word.LSb = ffff. ANDWF, Status.Affected = Z, N. ANDWF, Notes. = 1,2. CLRF, Operands = f, a. CLRF, Description. = Clear f. CLRF, Cycles. = 1. CLRF, 16-bit Instruction Word.MSb = 0110. CLRF, 16-bit Instruction Word.MSb = 101a. CLRF, 16-bit Instruction Word. = ffff. CLRF, 16-bit Instruction Word.LSb = ffff. CLRF, Status.Affected = Z. CLRF, Notes. = 2. COMF, Operands = f, d, a. COMF, Description. = Complement f. COMF, Cycles. = 1. COMF, 16-bit Instruction Word.MSb = 0001. COMF, 16-bit Instruction Word.MSb = 11da. COMF, 16-bit Instruction Word. = ffff.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nCOMF, 16-bit Instruction Word.LSb = ffff. COMF, Status.Affected = Z, N. COMF, Notes. = 1, 2. CPFSEQ, Operands = f, a. CPFSEQ, Description. = Compare f with WREG, skip = 1. CPFSEQ, Cycles. = (2 or 3). CPFSEQ, 16-bit Instruction Word.MSb = 0110. CPFSEQ, 16-bit Instruction Word.MSb = 001a. CPFSEQ, 16-bit Instruction Word. = ffff. CPFSEQ, 16-bit Instruction Word.LSb = ffff. CPFSEQ, Status.Affected = None. CPFSEQ, Notes. = 4. CPFSGT, Operands = f, a. CPFSGT, Description. = Compare f with WREG, skip > 1. CPFSGT, Cycles. = (2 or 3). CPFSGT, 16-bit Instruction Word.MSb = 0110. CPFSGT, 16-bit Instruction Word.MSb = 010a.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nCPFSGT, 16-bit Instruction Word. = ffff. CPFSGT, 16-bit Instruction Word.LSb = ffff. CPFSGT, Status.Affected = None. CPFSGT, Notes. = 4. CPFSLT, Operands = f, a. CPFSLT, Description. = Compare f with WREG, skip < 1. CPFSLT, Cycles. = (2 or 3). CPFSLT, 16-bit Instruction Word.MSb = 0110. CPFSLT, 16-bit Instruction Word.MSb = 000a. CPFSLT, 16-bit Instruction Word. = ffff. CPFSLT, 16-bit Instruction Word.LSb = ffff. CPFSLT, Status.Affected = None. CPFSLT, Notes. = 1, 2. DECF, Operands = f, d, a. DECF, Description. = Decrement f. DECF, Cycles. = 1. DECF, 16-bit Instruction Word.MSb = 0000. DECF, 16-bit Instruction Word.MSb = 01da. DECF, 16-bit Instruction Word. =",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nffff. DECF, 16-bit Instruction Word.LSb = ffff. DECF, Status.Affected = C, DC, Z, OV, N. DECF, Notes. = 1, 2, 3, 4. DECFSZ, Operands = f, d, a. DECFSZ, Description. = Decrement f, Skip if 0. DECFSZ, Cycles. = 1 (2 or 3). DECFSZ, 16-bit Instruction Word.MSb = 0010. DECFSZ, 16-bit Instruction Word.MSb = 11da. DECFSZ, 16-bit Instruction Word. = ffff. DECFSZ, 16-bit Instruction Word.LSb = ffff. DECFSZ, Status.Affected = None. DECFSZ, Notes. = 1, 2, 3, 4. DCFSNZ, Operands = f, d, a. DCFSNZ, Description. = Decrement f, Skip if Not 0. DCFSNZ, Cycles. = 1 (2 or 3). DCFSNZ, 16-bit Instruction Word.MSb = 0100. DCFSNZ,",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\n16-bit Instruction Word.MSb = 11da. DCFSNZ, 16-bit Instruction Word. = ffff. DCFSNZ, 16-bit Instruction Word.LSb = ffff. DCFSNZ, Status.Affected = None. DCFSNZ, Notes. = 1, 2. INCF, Operands = f, d, a. INCF, Description. = Increment f. INCF, Cycles. = 1. INCF, 16-bit Instruction Word.MSb = 0010. INCF, 16-bit Instruction Word.MSb = 10da. INCF, 16-bit Instruction Word. = ffff. INCF, 16-bit Instruction Word.LSb = ffff. INCF, Status.Affected = C, DC, Z, OV, N. INCF, Notes. = 1, 2, 3,. INCFSZ, Operands = f, d, a. INCFSZ, Description. = Increment f, Skip if 0. INCFSZ, Cycles. = 1 (2 or 3). INCFSZ, 16-bit Instruction Word.MSb = 0011.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nINCFSZ, 16-bit Instruction Word.MSb = 11da. INCFSZ, 16-bit Instruction Word. = ffff. INCFSZ, 16-bit Instruction Word.LSb = ffff. INCFSZ, Status.Affected = None. INCFSZ, Notes. = 4 4. INFSNZ, Operands = f, d, a. INFSNZ, Description. = Increment f, Skip if Not 0. INFSNZ, Cycles. = 1 (2 or 3). INFSNZ, 16-bit Instruction Word.MSb = 0100. INFSNZ, 16-bit Instruction Word.MSb = 10da. INFSNZ, 16-bit Instruction Word. = ffff. INFSNZ, 16-bit Instruction Word.LSb = ffff. INFSNZ, Status.Affected = None. INFSNZ, Notes. = 1, 2. IORWF, Operands = f, d, a. IORWF, Description. = Inclusive OR WREG with f. IORWF, Cycles. = 1. IORWF, 16-bit Instruction",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nWord.MSb = 0001. IORWF, 16-bit Instruction Word.MSb = 00da. IORWF, 16-bit Instruction Word. = ffff. IORWF, 16-bit Instruction Word.LSb = ffff. IORWF, Status.Affected = Z, N. IORWF, Notes. = 1, 2. MOVF, Operands = f, d, a. MOVF, Description. = Move f. MOVF, Cycles. = 1. MOVF, 16-bit Instruction Word.MSb = 0101. MOVF, 16-bit Instruction Word.MSb = 00da. MOVF, 16-bit Instruction Word. = ffff. MOVF, 16-bit Instruction Word.LSb = ffff. MOVF, Status.Affected = Z, N. MOVF, Notes. = 1. MOVFF, Operands = f s , f d. MOVFF, Description. = Move f s (source) to 1st word d (destination)2nd word 2. MOVFF, Cycles. = .",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nMOVFF, 16-bit Instruction Word.MSb = 1100. MOVFF, 16-bit Instruction Word.MSb = ffff. MOVFF, 16-bit Instruction Word. = ffff. MOVFF, 16-bit Instruction Word.LSb = ffff. MOVFF, Status.Affected = None. MOVFF, Notes. = . MOVWF, Operands = f, a. MOVWF, Description. = f. MOVWF, Cycles. = . MOVWF, 16-bit Instruction Word.MSb = 1111. MOVWF, 16-bit Instruction Word.MSb = ffff. MOVWF, 16-bit Instruction Word. = ffff. MOVWF, 16-bit Instruction Word.LSb = ffff. MOVWF, Status.Affected = . MOVWF, Notes. = . , Operands = . , Description. = Move WREG to f. , Cycles. = 1. , 16-bit Instruction Word.MSb = 0110. , 16-bit Instruction Word.MSb = 111a. ,",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\n16-bit Instruction Word. = ffff. , 16-bit Instruction Word.LSb = ffff. , Status.Affected = None. , Notes. = . MULWF, Operands = f, a. MULWF, Description. = Multiply WREG with f. MULWF, Cycles. = 1. MULWF, 16-bit Instruction Word.MSb = 0000. MULWF, 16-bit Instruction Word.MSb = 001a. MULWF, 16-bit Instruction Word. = ffff. MULWF, 16-bit Instruction Word.LSb = ffff. MULWF, Status.Affected = None. MULWF, Notes. = . NEGF, Operands = f, a. NEGF, Description. = Negate f. NEGF, Cycles. = 1. NEGF, 16-bit Instruction Word.MSb = 0110. NEGF, 16-bit Instruction Word.MSb = 110a. NEGF, 16-bit Instruction Word. = ffff. NEGF, 16-bit Instruction Word.LSb = ffff.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nNEGF, Status.Affected = C, DC, Z, OV, N. NEGF, Notes. = 1, 2. RLCF, Operands = f, d, a. RLCF, Description. = Rotate Left f through Carry. RLCF, Cycles. = 1. RLCF, 16-bit Instruction Word.MSb = 0011. RLCF, 16-bit Instruction Word.MSb = 01da. RLCF, 16-bit Instruction Word. = ffff. RLCF, 16-bit Instruction Word.LSb = ffff. RLCF, Status.Affected = C, Z, N. RLCF, Notes. = . RLNCF, Operands = f, d, a. RLNCF, Description. = Rotate Left f (No Carry). RLNCF, Cycles. = 1. RLNCF, 16-bit Instruction Word.MSb = 0100. RLNCF, 16-bit Instruction Word.MSb = 01da. RLNCF, 16-bit Instruction Word. = ffff. RLNCF, 16-bit",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nInstruction Word.LSb = ffff. RLNCF, Status.Affected = Z, N. RLNCF, Notes. = 1, 2. RRCF, Operands = f, d, a. RRCF, Description. = Rotate Right f through Carry. RRCF, Cycles. = 1. RRCF, 16-bit Instruction Word.MSb = 0011. RRCF, 16-bit Instruction Word.MSb = 00da. RRCF, 16-bit Instruction Word. = ffff. RRCF, 16-bit Instruction Word.LSb = ffff. RRCF, Status.Affected = C, Z, N. RRCF, Notes. = . RRNCF, Operands = f, d, a. RRNCF, Description. = Rotate Right f (No Carry). RRNCF, Cycles. = 1. RRNCF, 16-bit Instruction Word.MSb = 0100. RRNCF, 16-bit Instruction Word.MSb = 00da. RRNCF, 16-bit Instruction Word. = ffff. RRNCF, 16-bit Instruction",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nWord.LSb = ffff. RRNCF, Status.Affected = Z, N. RRNCF, Notes. = . SETF, Operands = f, a. SETF, Description. = Set f. SETF, Cycles. = 1. SETF, 16-bit Instruction Word.MSb = 0110. SETF, 16-bit Instruction Word.MSb = 100a. SETF, 16-bit Instruction Word. = ffff. SETF, 16-bit Instruction Word.LSb = ffff. SETF, Status.Affected = None. SETF, Notes. = . SUBFWB, Operands = f, d, a. SUBFWB, Description. = Subtract f from WREG with borrow. SUBFWB, Cycles. = 1. SUBFWB, 16-bit Instruction Word.MSb = 0101. SUBFWB, 16-bit Instruction Word.MSb = 01da. SUBFWB, 16-bit Instruction Word. = ffff. SUBFWB, 16-bit Instruction Word.LSb = ffff. SUBFWB,",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nStatus.Affected = C, DC, Z, OV, N. SUBFWB, Notes. = 1, 2. SUBWF, Operands = f, d, a. SUBWF, Description. = Subtract WREG from f. SUBWF, Cycles. = 1. SUBWF, 16-bit Instruction Word.MSb = 0101. SUBWF, 16-bit Instruction Word.MSb = 11da. SUBWF, 16-bit Instruction Word. = ffff. SUBWF, 16-bit Instruction Word.LSb = ffff. SUBWF, Status.Affected = C, DC, Z, OV, N. SUBWF, Notes. = . SUBWFB, Operands = f, d, a. SUBWFB, Description. = Subtract WREG from f with borrow. SUBWFB, Cycles. = 1. SUBWFB, 16-bit Instruction Word.MSb = 0101. SUBWFB, 16-bit Instruction Word.MSb = 10da. SUBWFB, 16-bit Instruction Word. = ffff. SUBWFB,",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\n16-bit Instruction Word.LSb = ffff. SUBWFB, Status.Affected = C, DC, Z, OV, N. SUBWFB, Notes. = 1, 2. SWAPF, Operands = f, d, a. SWAPF, Description. = Swap nibbles in f. SWAPF, Cycles. = 1. SWAPF, 16-bit Instruction Word.MSb = 0011. SWAPF, 16-bit Instruction Word.MSb = 10da. SWAPF, 16-bit Instruction Word. = ffff. SWAPF, 16-bit Instruction Word.LSb = ffff. SWAPF, Status.Affected = None. SWAPF, Notes. = 4. TSTFSZ, Operands = f, a. TSTFSZ, Description. = Test f, skip if 0. TSTFSZ, Cycles. = 1 (2 or 3). TSTFSZ, 16-bit Instruction Word.MSb = 0110. TSTFSZ, 16-bit Instruction Word.MSb = 011a. TSTFSZ, 16-bit Instruction Word. = ffff. TSTFSZ, 16-bit Instruction",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nWord.LSb = ffff. TSTFSZ, Status.Affected = None. TSTFSZ, Notes. = 1, 2. XORWF, Operands = f, d, a. XORWF, Description. = Exclusive OR WREG with f. XORWF, Cycles. = 1. XORWF, 16-bit Instruction Word.MSb = 0001. XORWF, 16-bit Instruction Word.MSb = 10da. XORWF, 16-bit Instruction Word. = ffff. XORWF, 16-bit Instruction Word.LSb = ffff. XORWF, Status.Affected = Z, N. XORWF, Notes. = . BIT-ORIENTED FILE REGISTER OPERATIONS, Operands = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Description. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Cycles. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-bit Instruction Word.MSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-bit Instruction",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nWord.MSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-bit Instruction Word. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-bit Instruction Word.LSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Notes. = BIT-ORIENTED FILE REGISTER OPERATIONS. BCF, Operands = f, b, a. BCF, Description. = Bit Clear f. BCF, Cycles. = 1. BCF, 16-bit Instruction Word.MSb = 1001. BCF, 16-bit Instruction Word.MSb = bbba. BCF, 16-bit Instruction Word. = ffff. BCF, 16-bit Instruction Word.LSb = ffff. BCF, Status.Affected = None. BCF, Notes. = 1, 2. BSF, Operands = f, b, a. BSF, Description. = Bit Set f. BSF, Cycles. = 1. BSF, 16-bit Instruction Word.MSb = 1000.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nBSF, 16-bit Instruction Word.MSb = bbba. BSF, 16-bit Instruction Word. = ffff. BSF, 16-bit Instruction Word.LSb = ffff. BSF, Status.Affected = None. BSF, Notes. = 1, 2. BTFSC, Operands = f, b, a. BTFSC, Description. = Bit Test f, Skip if Clear. BTFSC, Cycles. = 1 (2 or 3). BTFSC, 16-bit Instruction Word.MSb = 1011. BTFSC, 16-bit Instruction Word.MSb = bbba. BTFSC, 16-bit Instruction Word. = ffff. BTFSC, 16-bit Instruction Word.LSb = ffff. BTFSC, Status.Affected = None. BTFSC, Notes. = 3, 4. BTFSS, Operands = f, b, a. BTFSS, Description. = Bit Test f, Skip if Set. BTFSS, Cycles. = 1 (2 or 3). BTFSS, 16-bit Instruction Word.MSb =",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\n1010. BTFSS, 16-bit Instruction Word.MSb = bbba. BTFSS, 16-bit Instruction Word. = ffff. BTFSS, 16-bit Instruction Word.LSb = ffff. BTFSS, Status.Affected = None. BTFSS, Notes. = 3, 4. BTG, Operands = f, d, a. BTG, Description. = Bit Toggle f. BTG, Cycles. = 1. BTG, 16-bit Instruction Word.MSb = 0111. BTG, 16-bit Instruction Word.MSb = bbba. BTG, 16-bit Instruction Word. = ffff. BTG, 16-bit Instruction Word.LSb = ffff. BTG, Status.Affected = None. BTG, Notes. = 1, 2",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET\nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is '1' for a pin configured as input and is driven low by an external device, the data will be written back with a '0'.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2 word instructions. The second word of these instructions will be executed as a NOP , unless the first word of the instruction retrieves the information embedded in these 16-bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nCONTROL OPERATIONS, Mnemonic,.Operands = CONTROL OPERATIONS. CONTROL OPERATIONS, Description.Description = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles.Cycles = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-bit Instruction Word. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-bit Instruction Word.LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected.Status Affected = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes.Notes = CONTROL OPERATIONS. BC, Mnemonic,.Operands = n. BC, Description.Description = Branch if Carry. BC, Cycles.Cycles = 1 (2). BC, 16-bit Instruction Word.MSb = 1110. BC, 16-bit Instruction Word.MSb = 0010. BC, 16-bit Instruction Word. = nnnn. BC, 16-bit Instruction Word.LSb = nnnn. BC, Status Affected.Status Affected = None. BC, Notes.Notes = . BN, Mnemonic,.Operands = n. BN, Description.Description = Branch if",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nNegative. BN, Cycles.Cycles = 1 (2). BN, 16-bit Instruction Word.MSb = 1110. BN, 16-bit Instruction Word.MSb = 0110. BN, 16-bit Instruction Word. = nnnn. BN, 16-bit Instruction Word.LSb = nnnn. BN, Status Affected.Status Affected = None. BN, Notes.Notes = . BNC, Mnemonic,.Operands = n. BNC, Description.Description = Branch if Not Carry. BNC, Cycles.Cycles = 1 (2). BNC, 16-bit Instruction Word.MSb = 1110. BNC, 16-bit Instruction Word.MSb = 0011. BNC, 16-bit Instruction Word. = nnnn. BNC, 16-bit Instruction Word.LSb = nnnn. BNC, Status Affected.Status Affected = None. BNC, Notes.Notes = . BNN, Mnemonic,.Operands = n. BNN, Description.Description = Branch if Not Negative. BNN, Cycles.Cycles = 1 (2).",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nBNN, 16-bit Instruction Word.MSb = 1110. BNN, 16-bit Instruction Word.MSb = 0111. BNN, 16-bit Instruction Word. = nnnn. BNN, 16-bit Instruction Word.LSb = nnnn. BNN, Status Affected.Status Affected = None. BNN, Notes.Notes = . BNOV, Mnemonic,.Operands = n. BNOV, Description.Description = Branch if Not Overflow. BNOV, Cycles.Cycles = 1 (2). BNOV, 16-bit Instruction Word.MSb = 1110. BNOV, 16-bit Instruction Word.MSb = 0101. BNOV, 16-bit Instruction Word. = nnnn. BNOV, 16-bit Instruction Word.LSb = nnnn. BNOV, Status Affected.Status Affected = None. BNOV, Notes.Notes = . BNZ, Mnemonic,.Operands = n. BNZ, Description.Description = Branch if Not Zero. BNZ, Cycles.Cycles = 2. BNZ, 16-bit Instruction Word.MSb",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\n= 1110. BNZ, 16-bit Instruction Word.MSb = 0001. BNZ, 16-bit Instruction Word. = nnnn. BNZ, 16-bit Instruction Word.LSb = nnnn. BNZ, Status Affected.Status Affected = None. BNZ, Notes.Notes = . BOV, Mnemonic,.Operands = n. BOV, Description.Description = Branch if Overflow. BOV, Cycles.Cycles = 1 (2). BOV, 16-bit Instruction Word.MSb = 1110. BOV, 16-bit Instruction Word.MSb = 0100. BOV, 16-bit Instruction Word. = nnnn. BOV, 16-bit Instruction Word.LSb = nnnn. BOV, Status Affected.Status Affected = None. BOV, Notes.Notes = . BRA, Mnemonic,.Operands = n. BRA, Description.Description = Branch Unconditionally. BRA, Cycles.Cycles = 1 (2). BRA, 16-bit Instruction Word.MSb = 1101. BRA, 16-bit Instruction",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nWord.MSb = 0nnn. BRA, 16-bit Instruction Word. = nnnn. BRA, 16-bit Instruction Word.LSb = nnnn. BRA, Status Affected.Status Affected = None. BRA, Notes.Notes = . BZ, Mnemonic,.Operands = n. BZ, Description.Description = Branch if Zero. BZ, Cycles.Cycles = 1 (2). BZ, 16-bit Instruction Word.MSb = 1110. BZ, 16-bit Instruction Word.MSb = 0000. BZ, 16-bit Instruction Word. = nnnn. BZ, 16-bit Instruction Word.LSb = nnnn. BZ, Status Affected.Status Affected = None. BZ, Notes.Notes = . CALL, Mnemonic,.Operands = n, s. CALL, Description.Description = Call subroutine1st word 2nd word. CALL, Cycles.Cycles = 2. CALL, 16-bit Instruction Word.MSb = 1110 1111. CALL, 16-bit Instruction Word.MSb = 110s kkkk.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nCALL, 16-bit Instruction Word. = kkkk kkkk. CALL, 16-bit Instruction Word.LSb = kkkk kkkk. CALL, Status Affected.Status Affected = None. CALL, Notes.Notes = . CLRWDT, Mnemonic,.Operands = -. CLRWDT, Description.Description = Clear Watchdog Timer. CLRWDT, Cycles.Cycles = 1. CLRWDT, 16-bit Instruction Word.MSb = 0000. CLRWDT, 16-bit Instruction Word.MSb = 0000. CLRWDT, 16-bit Instruction Word. = 0000. CLRWDT, 16-bit Instruction Word.LSb = 0100. CLRWDT, Status Affected.Status Affected = TO, PD. CLRWDT, Notes.Notes = . DAW, Mnemonic,.Operands = -. DAW, Description.Description = Decimal Adjust WREG. DAW, Cycles.Cycles = 1. DAW, 16-bit Instruction Word.MSb = 0000. DAW, 16-bit Instruction",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nWord.MSb = 0000. DAW, 16-bit Instruction Word. = 0000. DAW, 16-bit Instruction Word.LSb = 0111. DAW, Status Affected.Status Affected = C. DAW, Notes.Notes = . GOTO, Mnemonic,.Operands = n. GOTO, Description.Description = Go to address1st word 2nd word. GOTO, Cycles.Cycles = 2. GOTO, 16-bit Instruction Word.MSb = 1110 1111. GOTO, 16-bit Instruction Word.MSb = 1111 kkkk. GOTO, 16-bit Instruction Word. = kkkk kkkk. GOTO, 16-bit Instruction Word.LSb = kkkk kkkk. GOTO, Status Affected.Status Affected = None. GOTO, Notes.Notes = . NOP, Mnemonic,.Operands = -. NOP, Description.Description = No Operation. NOP, Cycles.Cycles = 1. NOP, 16-bit Instruction Word.MSb = 0000. NOP, 16-bit Instruction Word.MSb",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\n= 0000. NOP, 16-bit Instruction Word. = 0000. NOP, 16-bit Instruction Word.LSb = 0000. NOP, Status Affected.Status Affected = None. NOP, Notes.Notes = . NOP, Mnemonic,.Operands = -. NOP, Description.Description = No Operation (Note 4). NOP, Cycles.Cycles = . NOP, 16-bit Instruction Word.MSb = 1111. NOP, 16-bit Instruction Word.MSb = xxxx. NOP, 16-bit Instruction Word. = xxxx. NOP, 16-bit Instruction Word.LSb = xxxx. NOP, Status Affected.Status Affected = None. NOP, Notes.Notes = . POP, Mnemonic,.Operands = -. POP, Description.Description = Pop top of return stack (TOS) 1 1. POP, Cycles.Cycles = . POP, 16-bit Instruction Word.MSb = 0000. POP, 16-bit Instruction Word.MSb = 0000. POP, 16-bit Instruction Word. = 0000.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nPOP, 16-bit Instruction Word.LSb = 0110. POP, Status Affected.Status Affected = None. POP, Notes.Notes = . PUSH, Mnemonic,.Operands = -. PUSH, Description.Description = Push top of return stack (TOS) 1. PUSH, Cycles.Cycles = . PUSH, 16-bit Instruction Word.MSb = 0000. PUSH, 16-bit Instruction Word.MSb = 0000. PUSH, 16-bit Instruction Word. = 0000. PUSH, 16-bit Instruction Word.LSb = 0101. PUSH, Status Affected.Status Affected = None. PUSH, Notes.Notes = . RCALL, Mnemonic,.Operands = n. RCALL, Description.Description = Relative Call. RCALL, Cycles.Cycles = 2. RCALL, 16-bit Instruction Word.MSb = 1101. RCALL, 16-bit Instruction Word.MSb = 1nnn. RCALL, 16-bit Instruction Word. = nnnn. RCALL, 16-bit Instruction Word.LSb = nnnn. RCALL, Status Affected.Status Affected =",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nNone. RCALL, Notes.Notes = . RESET, Mnemonic,.Operands = . RESET, Description.Description = Software device RESET. RESET, Cycles.Cycles = 1. RESET, 16-bit Instruction Word.MSb = 0000. RESET, 16-bit Instruction Word.MSb = 0000. RESET, 16-bit Instruction Word. = 1111. RESET, 16-bit Instruction Word.LSb = 1111. RESET, Status Affected.Status Affected = All. RESET, Notes.Notes = . RETFIE, Mnemonic,.Operands = s. RETFIE, Description.Description = Return from interrupt enable. RETFIE, Cycles.Cycles = 2. RETFIE, 16-bit Instruction Word.MSb = 0000. RETFIE, 16-bit Instruction Word.MSb = 0000. RETFIE, 16-bit Instruction Word. = 0001. RETFIE, 16-bit Instruction Word.LSb = 000s. RETFIE, Status Affected.Status Affected = GIE/GIEH, PEIE/GIEL. RETFIE, Notes.Notes = .",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nRETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-bit Instruction Word.MSb = 0000. RETLW, 16-bit Instruction Word.MSb = 1100. RETLW, 16-bit Instruction Word. = kkkk. RETLW, 16-bit Instruction Word.LSb = kkkk. RETLW, Status Affected.Status Affected = None. RETLW, Notes.Notes = . RETURN, Mnemonic,.Operands = s. RETURN, Description.Description = Return from Subroutine. RETURN, Cycles.Cycles = 2. RETURN, 16-bit Instruction Word.MSb = 0000. RETURN, 16-bit Instruction Word.MSb = 0000. RETURN, 16-bit Instruction Word. = 0001. RETURN, 16-bit Instruction Word.LSb = 001s. RETURN, Status Affected.Status Affected = None. RETURN, Notes.Notes = . SLEEP, Mnemonic,.Operands = -. SLEEP,",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nDescription.Description = Go into standby mode. SLEEP, Cycles.Cycles = 1. SLEEP, 16-bit Instruction Word.MSb = 0000. SLEEP, 16-bit Instruction Word.MSb = 0000. SLEEP, 16-bit Instruction Word. = 0000. SLEEP, 16-bit Instruction Word.LSb = 0011. SLEEP, Status Affected.Status Affected = TO, PD. SLEEP, Notes.Notes = ",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is '1' for a pin configured as input and is driven low by an external device, the data will be written back with a '0'.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2 word instructions. The second word of these instructions will be executed as a NOP , unless the first word of the instruction retrieves the information embedded in these 16-bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nLITERAL OPERATIONS, Mnemonic,.Operands = LITERAL OPERATIONS. LITERAL OPERATIONS, Description.Description = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles.Cycles = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-bit Instruction Word. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-bit Instruction Word. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-bit Instruction Word.LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected.Status Affected = LITERAL OPERATIONS. LITERAL OPERATIONS, Notes.Notes = LITERAL OPERATIONS. ADDLW ANDLW IORLW, Mnemonic,.Operands = k. ADDLW ANDLW IORLW, Description.Description = Add literal and WREG. ADDLW ANDLW IORLW, Cycles.Cycles = 1 1 1 2 1. ADDLW ANDLW IORLW, 16-bit Instruction Word.MSb = 0000 0000 0000. ADDLW ANDLW IORLW, 16-bit Instruction Word. = 1111 1011. ADDLW ANDLW IORLW, 16-bit Instruction Word. = kkkk",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nkkkk kkkk. ADDLW ANDLW IORLW, 16-bit Instruction Word.LSb = kkkk kkkk kkkk. ADDLW ANDLW IORLW, Status Affected.Status Affected = C, DC, Z, OV, N Z, N Z, N None. ADDLW ANDLW IORLW, Notes.Notes = . , Mnemonic,.Operands = k. , Description.Description = AND literal with WREG. , Cycles.Cycles = . , 16-bit Instruction Word.MSb = . , 16-bit Instruction Word. = . , 16-bit Instruction Word. = . , 16-bit Instruction Word.LSb = . , Status Affected.Status Affected = . , Notes.Notes = . , Mnemonic,.Operands = k. , Description.Description = Inclusive OR literal with WREG. , Cycles.Cycles = . , 16-bit Instruction Word.MSb = . , 16-bit Instruction Word. = 1001. , 16-bit Instruction Word. = . , 16-bit Instruction Word.LSb = . , Status",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nAffected.Status Affected = . , Notes.Notes = . LFSR, Mnemonic,.Operands = f, k. LFSR, Description.Description = Move literal (12-bit) 2nd word to FSRx 1st word. LFSR, Cycles.Cycles = . LFSR, 16-bit Instruction Word.MSb = 1110. LFSR, 16-bit Instruction Word. = 1110. LFSR, 16-bit Instruction Word. = 00ff. LFSR, 16-bit Instruction Word.LSb = kkkk. LFSR, Status Affected.Status Affected = . LFSR, Notes.Notes = . MOVLB, Mnemonic,.Operands = k. MOVLB, Description.Description = Move literal to BSR<3:0>. MOVLB, Cycles.Cycles = . MOVLB, 16-bit Instruction Word.MSb = 0000. MOVLB, 16-bit Instruction Word. = 0001. MOVLB, 16-bit Instruction Word. = 0000. MOVLB, 16-bit Instruction Word.LSb =",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nkkkk. MOVLB, Status Affected.Status Affected = None. MOVLB, Notes.Notes = . MOVLW, Mnemonic,.Operands = k. MOVLW, Description.Description = Move literal to WREG. MOVLW, Cycles.Cycles = 1. MOVLW, 16-bit Instruction Word.MSb = 0000. MOVLW, 16-bit Instruction Word. = 1110. MOVLW, 16-bit Instruction Word. = kkkk. MOVLW, 16-bit Instruction Word.LSb = kkkk. MOVLW, Status Affected.Status Affected = None. MOVLW, Notes.Notes = . MULLW, Mnemonic,.Operands = k. MULLW, Description.Description = Multiply literal with WREG. MULLW, Cycles.Cycles = 1. MULLW, 16-bit Instruction Word.MSb = 0000. MULLW, 16-bit Instruction Word. = 1101. MULLW, 16-bit Instruction Word. = kkkk.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nMULLW, 16-bit Instruction Word.LSb = kkkk. MULLW, Status Affected.Status Affected = None. MULLW, Notes.Notes = . RETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-bit Instruction Word.MSb = 0000. RETLW, 16-bit Instruction Word. = 1100. RETLW, 16-bit Instruction Word. = kkkk. RETLW, 16-bit Instruction Word.LSb = kkkk. RETLW, Status Affected.Status Affected = None. RETLW, Notes.Notes = . SUBLW, Mnemonic,.Operands = k. SUBLW, Description.Description = Subtract WREG from literal. SUBLW, Cycles.Cycles = 1. SUBLW, 16-bit Instruction Word.MSb = 0000. SUBLW, 16-bit Instruction Word. = 1000. SUBLW, 16-bit Instruction Word. =",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nkkkk. SUBLW, 16-bit Instruction Word.LSb = kkkk. SUBLW, Status Affected.Status Affected = C, DC, Z, OV, N. SUBLW, Notes.Notes = . XORLW, Mnemonic,.Operands = k. XORLW, Description.Description = Exclusive OR literal with WREG. XORLW, Cycles.Cycles = 1. XORLW, 16-bit Instruction Word.MSb = 0000. XORLW, 16-bit Instruction Word. = 1010. XORLW, 16-bit Instruction Word. = kkkk. XORLW, 16-bit Instruction Word.LSb = kkkk. XORLW, Status Affected.Status Affected = Z, N. XORLW, Notes.Notes = . DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Mnemonic,.Operands = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Description.Description = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Cycles.Cycles = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nOPERATIONS, 16-bit Instruction Word.MSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-bit Instruction Word. = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-bit Instruction Word. = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-bit Instruction Word.LSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Status Affected.Status Affected = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Notes.Notes = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. TBLRD*, Mnemonic,.Operands = TBLRD*. TBLRD*, Description.Description = Table Read. TBLRD*, Cycles.Cycles = 2. TBLRD*, 16-bit Instruction Word.MSb = 0000. TBLRD*, 16-bit Instruction Word. = 0000. TBLRD*, 16-bit Instruction Word. = 0000. TBLRD*, 16-bit Instruction Word.LSb = 1000. TBLRD*, Status Affected.Status Affected = None. TBLRD*, Notes.Notes = .",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nTBLRD*+, Mnemonic,.Operands = TBLRD*+. TBLRD*+, Description.Description = Table Read with post-increment. TBLRD*+, Cycles.Cycles = . TBLRD*+, 16-bit Instruction Word.MSb = 0000. TBLRD*+, 16-bit Instruction Word. = 0000. TBLRD*+, 16-bit Instruction Word. = 0000. TBLRD*+, 16-bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected.Status Affected = None. TBLRD*+, Notes.Notes = . TBLRD*-, Mnemonic,.Operands = TBLRD*-. TBLRD*-, Description.Description = Table Read with post-decrement. TBLRD*-, Cycles.Cycles = . TBLRD*-, 16-bit Instruction Word.MSb = 0000. TBLRD*-, 16-bit Instruction Word. = 0000. TBLRD*-, 16-bit Instruction Word. =",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\n0000. TBLRD*-, 16-bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected.Status Affected = None. TBLRD*-, Notes.Notes = . TBLRD+*, Mnemonic,.Operands = TBLRD+*. TBLRD+*, Description.Description = Table Read with pre-increment. TBLRD+*, Cycles.Cycles = . TBLRD+*, 16-bit Instruction Word.MSb = 0000. TBLRD+*, 16-bit Instruction Word. = 0000. TBLRD+*, 16-bit Instruction Word. = 0000. TBLRD+*, 16-bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected.Status Affected = None. TBLRD+*, Notes.Notes = . TBLWT*, Mnemonic,.Operands = TBLWT*. TBLWT*, Description.Description = Table Write. TBLWT*, Cycles.Cycles = 2 (5). TBLWT*, 16-bit",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nInstruction Word.MSb = 0000. TBLWT*, 16-bit Instruction Word. = 0000. TBLWT*, 16-bit Instruction Word. = 0000. TBLWT*, 16-bit Instruction Word.LSb = 1100. TBLWT*, Status Affected.Status Affected = None. TBLWT*, Notes.Notes = . TBLWT*+, Mnemonic,.Operands = TBLWT*+. TBLWT*+, Description.Description = Table Write with post-increment. TBLWT*+, Cycles.Cycles = . TBLWT*+, 16-bit Instruction Word.MSb = 0000. TBLWT*+, 16-bit Instruction Word. = 0000. TBLWT*+, 16-bit Instruction Word. = 0000. TBLWT*+, 16-bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected.Status Affected = None. TBLWT*+, Notes.Notes = . TBLWT*-, Mnemonic,.Operands = TBLWT*-.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nTBLWT*-, Description.Description = Table Write with post-decrement. TBLWT*-, Cycles.Cycles = . TBLWT*-, 16-bit Instruction Word.MSb = 0000. TBLWT*-, 16-bit Instruction Word. = 0000. TBLWT*-, 16-bit Instruction Word. = 0000. TBLWT*-, 16-bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected.Status Affected = None. TBLWT*-, Notes.Notes = . TBLWT+*, Mnemonic,.Operands = TBLWT+*. TBLWT+*, Description.Description = Table Write with pre-increment. TBLWT+*, Cycles.Cycles = . TBLWT+*, 16-bit Instruction Word.MSb = 0000. TBLWT+*, 16-bit Instruction Word. = 0000. TBLWT+*, 16-bit Instruction Word. = 0000. TBLWT+*, 16-bit Instruction Word.LSb = 1111.",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nTBLWT+*, Status Affected.Status Affected = None. TBLWT+*, Notes.Notes = ",
    "TABLE 19-2: PIC18CXXX INSTRUCTION SET  (CONTINUED)\nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is '1' for a pin configured as input and is driven low by an external device, the data will be written back with a '0'.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2 word instructions. The second word of these instructions will be executed as a NOP , unless the first word of the instruction retrieves the information embedded in these 16-bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "19.1 Instruction Set\nSyntax:, ADD literal to WREG = [ label ] ADDLW. Syntax:, ADD literal to WREG = [ label ] ADDLW. Syntax:, ADD literal to WREG = k. Syntax:, ADD literal to WREG = . Operands:, ADD literal to WREG = 0 \uf0a3 k \uf0a3 255. Operands:, ADD literal to WREG = 0 \uf0a3 k \uf0a3 255. Operands:, ADD literal to WREG = . Operands:, ADD literal to WREG = . Operation:, ADD literal to WREG = (WREG) + k \uf0ae WREG. Operation:, ADD literal to WREG = (WREG) + k \uf0ae WREG. Operation:, ADD literal to WREG = (WREG) + k \uf0ae WREG. Operation:, ADD literal to WREG = (WREG) + k \uf0ae WREG. Status Affected:, ADD literal to WREG = N,OV, C, DC, Z. Status Affected:, ADD literal to WREG = N,OV, C, DC, Z. Status Affected:, ADD literal to WREG = N,OV, C, DC, Z. Status Affected:, ADD literal to WREG =",
    "19.1 Instruction Set\nN,OV, C, DC, Z. Encoding:, ADD literal to WREG = 0000. Encoding:, ADD literal to WREG = 1111. Encoding:, ADD literal to WREG = kkkk. Encoding:, ADD literal to WREG = kkkk. Description:, ADD literal to WREG = The contents of WREG are added to the 8-bit literal 'k' and the result is placed in WREG.. Description:, ADD literal to WREG = The contents of WREG are added to the 8-bit literal 'k' and the result is placed in WREG.. Description:, ADD literal to WREG = The contents of WREG are added to the 8-bit literal 'k' and the result is placed in WREG.. Description:, ADD literal to WREG = The contents of WREG are added to the 8-bit literal 'k' and the result is placed in WREG.. Words:, ADD literal to WREG = 1. Words:, ADD literal to WREG = . Words:, ADD literal to WREG = . Words:, ADD literal to WREG = . Cycles:, ADD literal to WREG =",
    "19.1 Instruction Set\n1. Cycles:, ADD literal to WREG = . Cycles:, ADD literal to WREG = . Cycles:, ADD literal to WREG = . Q Cycle Activity: Q1, ADD literal to WREG = Q2. Q Cycle Activity: Q1, ADD literal to WREG = Q3. Q Cycle Activity: Q1, ADD literal to WREG = . Q Cycle Activity: Q1, ADD literal to WREG = Q4. Decode, ADD literal to WREG = Read literal 'k'. Decode, ADD literal to WREG = Process Data. Decode, ADD literal to WREG = . Decode, ADD literal to WREG = Write to WREG",
    "Example:\nADDLW\n0x15\nBefore Instruction\nWREG = 0x10\nAfter Instruction\nWREG =  0x25",
    "Example:\nADDWF, 1 = ADDWF. ADDWF, 2 = ADD WREG to f. ADDWF, 3 = ADD WREG to f. ADDWF, 4 = ADD WREG to f. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] ADDWF. Syntax:, 3 = [ label ] ADDWF. Syntax:, 4 = f [,d [,a] f [,d [,a]. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 3 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 4 = . Operation:, 1 = Operation:. Operation:, 2 = (WREG) + (f) \uf0ae dest. Operation:, 3 = (WREG) + (f) \uf0ae dest. Operation:, 4 = (WREG) + (f) \uf0ae dest. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = N,OV, C, DC, Z. Status Affected:, 3 =",
    "Example:\nN,OV, C, DC, Z. Status Affected:, 4 = N,OV, C, DC, Z. Encoding:, 1 = Encoding:. Encoding:, 2 = 0010. Encoding:, 3 = 01da. Encoding:, 4 = ffff. Description:, 1 = Description:. Description:, 2 = Add WREG to register 'f'. If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored back in reg- ister 'f' (default). If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR is used.. Description:, 3 = Add WREG to register 'f'. If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored back in reg- ister 'f' (default). If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR is used.. Description:, 4 = Add WREG to register 'f'. If 'd' is 0, the result is",
    "Example:\nstored in WREG. If 'd' is 1, the result is stored back in reg- ister 'f' (default). If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR is used.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read register 'f'. , 3 = Process Data. , 4 = \nADDWF\nREG, 0, 0",
    "Before Instruction\nWREG\n=\n0x17\nREG\n=\n0xC2\nAfter Instruction\nWREG\n=\n0xD9\nREG\n=\n0xC2",
    "ADD WREG and Carry bit to f\nSyntax:\n[ label ] ADDWFC      f [,d [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce\uf020 [0,1]\na \uf0ce\uf020 [0,1]\nOperation:\n(WREG) + (f) + (C) \uf0ae dest\nStatus Affected:\nN,OV, C, DC, Z\nEncoding:\n0010\n00da\nffff\nffff\nDescription:\nAdd WREG, the Carry Flag and data memory location 'f'. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed in data memory location 'f'. If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR will not be overridden.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite to\ndestination",
    "Example:\nADDWFC\nREG, 0, 1",
    "Before Instruction\nCarry bit=\n1\nREG\n=\n0x02\nWREG\n=\n0x4D",
    "After Instruction\nCarry bit=\n0\nREG\n=\n0x02\nWREG\n=\n0x50",
    "AND literal with WREG\nSyntax:\n[ label ]  ANDLW     k\nOperands:\n0 \uf0a3 k \uf0a3 255\nOperation:\n(WREG) .AND. k \uf0ae WREG\nStatus Affected:\nN,Z\nEncoding:\n0000\n1011\nkkkk\nkkkk\nDescription:\nThe contents of WREG are ANDed with the 8-bit literal 'k'. The result is placed in WREG.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal\n'k'\nProcess Data\nWrite to WREG\nExample:\nANDLW\n0x5F\nBefore Instruction\nWREG\n=\n0xA3\nAfter Instruction\nWREG\n=\n0x03\nANDWF\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "AND WREG with f\n[\nlabel\n]  ANDWF      f [,d [,a]\n0 \uf0a3 f \uf0a3 255\nd \uf0ce\uf020 [0,1]\na \uf0ce\uf020 [0,1]\n(WREG) .AND. (f) \uf0ae dest\nN,Z\n0001\n01da ffff\nffff\nThe contents of WREG are AND'ed with register 'f'. If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR will not be overridden (default).\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nANDWF\nREG, 0, 0",
    "Before Instruction\nWREG\n=\n0x17\nREG\n=\n0xC2\nAfter Instruction\nWREG\n=\n0x02\nREG\n=\n0xC2",
    "Branch if Carry\nSyntax:\n[ label ]  BC    n\nOperands:\n-128 \uf0a3 n \uf0a3 127\nOperation:\nif carry bit is '1' (PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1110\n0010\nnnnn\nnnnn\nDescription:\nIf the Carry bit is '1', then the pro- gram will branch.\nThe 2's complement number '2n' is added to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is then a two-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation",
    "Example:\nHERE\nBC 5\nAfter Instruction, = = . After Instruction, address = . After Instruction, (HERE) = . If Carry PC, = = = =. If Carry PC, address = 1; address. If Carry PC, (HERE) = (HERE+12). If Carry PC, = = \uf03d =. If Carry PC, address = 0; address. If Carry PC, (HERE) = (HERE+2)",
    "PIC18CXX2\nSyntax:, BCF = Syntax:. Syntax:, Bit Clear f = [ label ] BCF. Syntax:, Bit Clear f = [ label ] BCF. Syntax:, Bit Clear f = f,b[,a]. Operands:, BCF = Operands:. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = . Operation:, BCF = Operation:. Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = . Status Affected:, BCF = Status Affected:. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = . Encoding:, BCF = Encoding:. Encoding:, Bit Clear f = 1001. Encoding:, Bit Clear f = bbba. Encoding:, Bit Clear f = ffff. Description:, BCF = Description:. Description:, Bit Clear f = Bit",
    "PIC18CXX2\n'b' in register 'f' is cleared. If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, BCF = Words:. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Words:, Bit Clear f = . Cycles:, BCF = Cycles:. Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Cycles:, Bit Clear",
    "PIC18CXX2\nf = . Q Cycle Activity:, BCF = Q Cycle Activity:. Q Cycle Activity:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = . , BCF = Q1. , Bit Clear f = Q2. , Bit Clear f = Q3. , Bit Clear f = . , BCF = Decode. , Bit Clear f = Read register 'f'. , Bit Clear f = Process Data. , Bit Clear f = \nExample:\nBCF\nFLAG_REG,  7, 0\nBefore Instruction\nFLAG_REG = 0xC7\nAfter Instruction\nFLAG_REG = 0x47",
    "Branch if Negative\nSyntax:\n[ label ]  BN    n\nOperands:\n-128 \uf0a3 n \uf0a3 127\nOperation:\nif negative bit is '1' (PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1110\n0110\nnnnn\nnnnn\nDescription:\nIf the Negative bit is '1', then the program will branch.\nThe 2's complement number '2n' is added to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is then a two-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nQ1\nDecode\nQ2\nRead literal\nQ4\nNo\n'n'\nQ3\nProcess Data operation",
    "Branch if Negative\nIf, HERE. = Negative= PC =. If, BN. = 1; address. If, Jump. = (Jump). If, HERE. = Negative \uf03d PC =. If, BN. = 0; address. If, Jump. = (HERE+2)",
    "BNC\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "Branch if Not Carry\n[\nlabel\n]  BNC    n\n-128 \uf0a3 n \uf0a3 127\nif carry bit is '0' (PC) + 2 + 2n \uf0ae PC\nNone\n1110\n0011\nnnnn nnnn\nIf the Carry bit is '0', then the program will branch.\nThe 2's complement number '2n' is added to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is then a two-cycle instruction.\n1\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation",
    "Example:\nHERE\nBNC Jump\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Carry\n=\n0;\nPC\n=\naddress (Jump)\nIf Carry\n\uf03d\n1;\nPC\n=\naddress (HERE+2)",
    "Branch if Not Negative\nSyntax:\n[\nlabel\n]  BNN    n\nOperands:\n-128 \uf0a3 n \uf0a3 127\nOperation:\nif negative bit is '0' (PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1110\n0111\nnnnn\nnnnn\nDescription:\nIf the Negative bit is '0', then the program will branch.\nThe 2's complement number '2n' is added to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is then a two-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation",
    "Example:\nHERE\nBNN Jump\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Negative\n\uf03d\n0;\nPC\n=\naddress (Jump)\nIf Negative=\n1;\nPC\n=\naddress (HERE+2)",
    "Branch if Not Overflow\nSyntax:\n[ label ]  BNOV    n\nOperands:\n-128 \uf0a3 n \uf0a3 127\nOperation:\nif overflow bit is '0' (PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1110\n0101\nnnnn\nnnnn\nDescription:\nIf the Overflow bit is '0', then the program will branch.\nThe 2's complement number '2n' is added to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is then a two-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation",
    "Example:\nIf Overflow= PC =, HERE.address = 0; address. If Overflow= PC =, BNOV Jump. = (Jump). If Overflow \uf03d PC =, HERE.address = 1; address. If Overflow \uf03d PC =, BNOV Jump. = (HERE+2)",
    "Example:\nSyntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Zero = if zero bit is '0' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if zero bit is '0' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if zero bit is '0' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if zero bit is '0' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if",
    "Example:\nzero bit is '0' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Encoding:, Branch if Not Zero = 1110. Encoding:, Branch if Not Zero = 0001. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Description:, Branch if Not Zero = If the Zero bit is '0', then the pro- gram will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is '0', then the pro- gram will branch. The 2's complement number '2n' is added to the PC. Since the PC will have",
    "Example:\nincremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is '0', then the pro- gram will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is '0', then the pro- gram will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is '0', then the pro- gram will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be",
    "Example:\nPC+2+2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q1, Branch if Not Zero = Q2. Q1, Branch if",
    "Example:\nNot Zero = Q2. Q1, Branch if Not Zero = Q3. Q1, Branch if Not Zero = Q4. Q1, Branch if Not Zero = Q4. Decode, Branch if Not Zero = Read literal 'n'. Decode, Branch if Not Zero = Read literal 'n'. Decode, Branch if Not Zero = Process Data. Decode, Branch if Not Zero = Write to PC. Decode, Branch if Not Zero = Write to PC. No operation, Branch if Not Zero = No operation. No operation, Branch if Not Zero = No operation. No operation, Branch if Not Zero = No operation. No operation, Branch if Not Zero = No operation. No operation, Branch if Not Zero = No operation. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. Q1, Branch if Not Zero = Q2. Q1, Branch if Not Zero = Q2.",
    "Example:\nQ1, Branch if Not Zero = Q3. Q1, Branch if Not Zero = Q4. Q1, Branch if Not Zero = Q4. Decode, Branch if Not Zero = Read literal 'n'. Decode, Branch if Not Zero = Read literal 'n'. Decode, Branch if Not Zero = Process Data. Decode, Branch if Not Zero = No operation. Decode, Branch if Not Zero = No operation. Example:, Branch if Not Zero = HERE. Example:, Branch if Not Zero = BNZ. Example:, Branch if Not Zero = Jump. Example:, Branch if Not Zero = . Example:, Branch if Not Zero = . Before Instruction, Branch if Not Zero = Before Instruction. Before Instruction, Branch if Not Zero = . Before Instruction, Branch if Not Zero = . Before Instruction, Branch if Not Zero = . Before Instruction, Branch if Not Zero = . PC, Branch if Not Zero = =. PC, Branch if Not Zero = address. PC, Branch if Not Zero = (HERE). PC, Branch if Not Zero = . PC, Branch if Not Zero = . After Instruction If Zero PC, Branch if Not Zero = = = \uf03d. After Instruction If Zero",
    "Example:\nPC, Branch if Not Zero = 0; address 1;. After Instruction If Zero PC, Branch if Not Zero = (Jump). After Instruction If Zero PC, Branch if Not Zero = . After Instruction If Zero PC, Branch if Not Zero = . If Zero PC, Branch if Not Zero = =. If Zero PC, Branch if Not Zero = address. If Zero PC, Branch if Not Zero = (HERE+2). If Zero PC, Branch if Not Zero = . If Zero PC, Branch if Not Zero = ",
    "Unconditional Branch\nSyntax:\n[\nlabel\n]  BRA    n\nOperands:\n-1024 \uf0a3 n \uf0a3 1023\nOperation:\n(PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1101\n0nnn\nnnnn\nnnnn\nDescription:\nAdd the 2's complement number '2n' to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is a two- cycle instruction.\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal\n'n'\nProcess\nData\nWrite to PC\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nBefore Instruction PC, HERE = =. Before Instruction PC, BRA = address. Before Instruction PC, Jump = (HERE). After Instruction PC, HERE = =. After Instruction PC, BRA = address. After Instruction PC, Jump = (Jump)",
    "Unconditional Branch\nSyntax:, Bit Set f = [ label ] BSF. Syntax:, Bit Set f = [ label ] BSF. Syntax:, Bit Set f = f,b[,a]. Syntax:, Bit Set f = f,b[,a]. Syntax:, Bit Set f = f,b[,a]. Operands:, Bit Set f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Set f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Set f = . Operands:, Bit Set f = . Operands:, Bit Set f = . Operation:, Bit Set f = 1 \uf0ae f<b>. Operation:, Bit Set f = 1 \uf0ae f<b>. Operation:, Bit Set f = . Operation:, Bit Set f = . Operation:, Bit Set f = . Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = . Status Affected:, Bit Set f = . Status Affected:, Bit Set f = . Encoding:, Bit Set f = 1000. Encoding:, Bit Set f",
    "Unconditional Branch\n= bbba. Encoding:, Bit Set f = . Encoding:, Bit Set f = ffff. Encoding:, Bit Set f = ffff. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is 0 Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is 0 Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is 0 Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is 0 Access Bank will be selected, over- riding the BSR value. If",
    "Unconditional Branch\n'a' = 1, then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is 0 Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value.. Words:, Bit Set f = 1. Words:, Bit Set f = 1. Words:, Bit Set f = . Words:, Bit Set f = . Words:, Bit Set f = . Cycles:, Bit Set f = 1. Cycles:, Bit Set f = 1. Cycles:, Bit Set f = . Cycles:, Bit Set f = . Cycles:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q1, Bit Set f = Q2. Q1, Bit Set f = Q2. Q1, Bit Set f = Q3. Q1, Bit Set f =",
    "Unconditional Branch\nQ3. Q1, Bit Set f = Q4. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Process Data. Decode, Bit Set f = Process Data. Decode, Bit Set f = Write register 'f'. Example: BSF, Bit Set f = Example: BSF. Example: BSF, Bit Set f = FLAG_REG,. Example: BSF, Bit Set f = FLAG_REG,. Example: BSF, Bit Set f = 7, 1. Example: BSF, Bit Set f = 7, 1. Before Instruction FLAG_REG=, Bit Set f = Before Instruction FLAG_REG=. Before Instruction FLAG_REG=, Bit Set f = . Before Instruction FLAG_REG=, Bit Set f = . Before Instruction FLAG_REG=, Bit Set f = . Before Instruction FLAG_REG=, Bit Set f = ",
    "PIC18CXX2\nBTFSC",
    "Bit Test File, Skip if Clear\nSyntax:\n[ label ]  BTFSC   f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b \uf0a3 7\na \uf0ce\uf020 [0,1]\nOperation:\nskip if (f<b>) = 0\nStatus Affected:\nNone\nEncoding:\n1011\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is 0, then the next instruction is skipped.\nIf bit 'b' is 0, then the next instruction fetched during the current instruction execution is discarded, and a NOP is executed instead, making this a two- cycle instruction. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nIf skip:\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE\nFALSE\nTRUE\nBTFSC FLAG, 1, 0\n:\n:\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf FLAG<1> =\n0;\nPC\n=\naddress (TRUE)\nIf FLAG<1>\n=\n1;\nPC\n=\naddress (FALSE)",
    "Bit Test File, Skip if Set\nSyntax:\n[ label ]  BTFSS  f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b < 7\na \uf0ce\uf020 [0,1]\nOperation:\nskip if (f<b>) = 1\nStatus Affected:\nNone\nEncoding:\n1010\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is 1 then the next instruction is skipped.\nIf bit 'b' is 1, then the next instruction fetched during the current instruc- tion execution, is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nIf skip:\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE\nFALSE\nTRUE\nBTFSS FLAG, 1, 0\n:\n:\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf FLAG<1>\n=\n0;\nPC\n=\naddress (FALSE)\nIf FLAG<1>\n=\n1;\nPC\n=\naddress (TRUE)\nBTG",
    "Bit Toggle f\nSyntax:\n[ label ]  BTG  f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b < 7\na\n\uf0ce\uf020\n[0,1]\nOperation:\n(f<b>) \uf0ae f<b>\nStatus Affected:\nNone\nEncoding:\n0111\nbbba\nffff\nffff\nDescription:\nBit 'b' in data memory location 'f' is inverted. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite\nregister 'f'\nExample:\nBTG\nPORTC,\n4, 0\nBefore Instruction:\nPORTC\n=\n0111 0101 [0x75]\nAfter Instruction:\nPORTC\n=\n0110 0101 [0x65]",
    "Branch if Overflow\nSyntax:\n[ label ]  BOV    n\nOperands:\n-128 \uf0a3 n \uf0a3 127\nOperation:\nif overflow bit is '1' (PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1110\n0100\nnnnn\nnnnn\nDescription:\nIf the Overflow bit is '1', then the program will branch.\nThe 2's complement number '2n' is added to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is then a two-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity:\nIf Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation",
    "Example:\nHERE\nBOV Jump\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Overflow=\n1;\nPC\n=\naddress (Jump)\nIf Overflow \uf03d\n0;\nPC\n=\naddress (HERE+2)",
    "PIC18CXX2\nBZ",
    "Branch if Zero\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\n[\nlabel\n]  BZ    n\n-128 \uf0a3 n \uf0a3 127\nif Zero bit is '1' (PC) + 2 + 2n \uf0ae PC\nNone\n1110\n0000\nnnnn nnnn\nIf the Zero bit is '1', then the program will branch.\nThe 2's complement number '2n' is added to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is then a two-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation",
    "Example:\nAfter Instruction If, HERE.= = = =. After Instruction If, BZ.address = 1; address. After Instruction If, Jump. = (Jump). If, HERE.= = \uf03d =. If, BZ.address = 0; address. If, Jump. = (HERE+2)",
    "Example:\nSyntax:, Subroutine Call = [ label ] CALL k. Syntax:, Subroutine Call = [ label ] CALL k. Syntax:, Subroutine Call = [,s]. Syntax:, Subroutine Call = . Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (WREG) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (WREG) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>,",
    "Example:\nif s = 1 (WREG) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (WREG) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = 110s k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = kkkk 0",
    "Example:\nkkkk 8\nDescription:\nSubroutine call of entire 2M byte memory range.  First, return address (PC+ 4) is pushed onto the return stack.  If 's' = 1, the W, STATUS and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS.  If 's' = 0, no update occurs (default). Then the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.\nWords:\n2\nCycles:\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'k'<7:0>,. Decode, Q3 = Push PC to stack. Decode, Q4 = Read literal 'k'<19:8>, Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nHERE\nCALL   THERE,1",
    "Before Instruction\nPC = Address(HERE)\nAfter Instruction\nPC =\nAddress(THERE)\nTOS =\nAddress (HERE + 4)\nWS\n=\nWREG\nBSRS=\nBSR\nSTATUSS = STATUS",
    "Before Instruction\nSyntax:, Clear f = [ label ] CLRF. Syntax:, Clear f = [ label ] CLRF. Syntax:, Clear f = f [,a]. Syntax:, Clear f = f [,a]. Syntax:, Clear f = f [,a]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 255. Operands:, Clear f = 255. Operands:, Clear f = 255. Operation:, Clear f = 000h \uf0ae f 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f 1 \uf0ae Z. Operation:, Clear f = . Operation:, Clear f = . Operation:, Clear f = . Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = . Status Affected:, Clear f = . Status Affected:, Clear f = . Encoding:, Clear f = 0110. Encoding:, Clear f = 101a. Encoding:, Clear f = 101a. Encoding:, Clear f = ffff. Encoding:, Clear f = ffff. Description:,",
    "Before Instruction\nClear f = Clears the contents of the specified register. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is 0,",
    "Before Instruction\nthe Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = . Words:, Clear f = . Words:, Clear f = . Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = . Cycles:, Clear f = . Cycles:, Clear f = . Q, Clear f = Q. Q, Clear f = Cycle Activity:. Q, Clear f = Cycle Activity:. Q, Clear f = Cycle Activity:. Q, Clear f = Cycle Activity:. Q1, Clear f = Q2. Q1, Clear f = . Q1, Clear f = Q3. Q1, Clear f = Q4. Q1, Clear f = Q4. Decode, Clear f = Read register. Decode, Clear f = . Decode, Clear f = Process Data. Decode, Clear f = Write register 'f'. Decode, Clear f = Write register 'f'. , Clear f = . , Clear",
    "Before Instruction\nf = . , Clear f = . , Clear f = 'f'. , Clear f = 'f'. Example:, Clear f = . Example:, Clear f = CLRF. Example:, Clear f = FLAG_REG,1. Example:, Clear f = . Example:, Clear f = . After, Clear f = =. After, Clear f = . After, Clear f = . After, Clear f = . After, Clear f = . FLAG_REG, Clear f = . FLAG_REG, Clear f = . FLAG_REG, Clear f = . FLAG_REG, Clear f = . FLAG_REG, Clear f = . , Clear f = . , Clear f = . , Clear f = 0x5A. , Clear f = . , Clear f = . , Clear f = . , Clear f = . , Clear f = . , Clear f = =. , Clear f = =. Before Instruction, Clear f = . Before Instruction, Clear f = . Before Instruction, Clear f = . Before Instruction, Clear f = . Before Instruction, Clear f = . FLAG_REG, Clear f = . FLAG_REG, Clear f = . FLAG_REG, Clear f = .",
    "Before Instruction\nFLAG_REG, Clear f = . FLAG_REG, Clear f = . , Clear f = . , Clear f = . , Clear f = . , Clear f = . , Clear f = Instruction. , Clear f = . , Clear f = . , Clear f = . , Clear f = . , Clear f = 0x00",
    "PIC18CXX2\nSyntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:,",
    "PIC18CXX2\nClear Watchdog Timer = TO, PD. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = . Encoding:, Clear Watchdog Timer = 0000. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1.",
    "PIC18CXX2\nWords:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = Q3. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = Process Data. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Before",
    "PIC18CXX2\nInstruction WDT, Clear Watchdog Timer = counter. Before Instruction WDT, Clear Watchdog Timer = = ?. Before Instruction WDT, Clear Watchdog Timer = . Before Instruction WDT, Clear Watchdog Timer = . After Instruction WDT, Clear Watchdog Timer = counter. After Instruction WDT, Clear Watchdog Timer = =. After Instruction WDT, Clear Watchdog Timer = 0x00. After Instruction WDT, Clear Watchdog Timer = 0x00. WDT Postscaler TO, Clear Watchdog Timer = WDT Postscaler TO. WDT Postscaler TO, Clear Watchdog Timer = =. WDT Postscaler TO, Clear Watchdog Timer = 0 1. WDT Postscaler TO, Clear Watchdog Timer = 0 1. PD, Clear Watchdog Timer = PD. PD, Clear Watchdog Timer = =. PD, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = 1",
    "Complement f\nSyntax:\n[\nlabel\n]   COMF     f [,d [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n\uf0ae dest ( f )\nStatus Affected:\nN,Z\nEncoding:\n0001\n11da\nffff\nffff\nDescription:\nThe contents of register 'f' are com- plemented. If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite to\ndestination",
    "Example:\nCOMF\nREG,\n0, 0",
    "Before Instruction\nREG\n=\n0x13\nAfter Instruction\nREG\n=\n0x13\nWREG\n=\n0xEC",
    "CPFSEQ\nCompare f with WREG, skip if f = WREG\nSyntax:\n[ label ]   CPFSEQ    f [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce [0,1]\nOperation:\n(f) - (WREG), skip if (f) = (WREG) (unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n001a\nffff\nffff\nDescription:\nCompares the contents of data memory location 'f' to the contents of WREG by performing an unsigned subtraction.\nIf 'f' = WREG  then the fetched , instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote: 3 cycles if skip and followed by a 2-word instruction.\nQ2\nQ3\nQ4\nRead register 'f'\nQ2\nNo",
    "Q Cycle Activity:\nQ1\nDecode\nIf skip:\nQ1\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation\nNo\nNo operation\nNo\nNo operation\nNo\nNo operation\nQ4\nNo operation\nQ4\nNo operation\nNo operation\noperation operation\noperation\nExample:\nHERE     CPFSEQ REG, 0\nNEQUAL   :\nEQUAL    :",
    "Before Instruction\nPC Address\n=\nHERE\nWREG\n=\n?\nREG\n=\n?\nAfter Instruction\nIf REG\n= WREG;\nPC\n=\nAddress (EQUAL)\nIf REG\n\uf0b9\uf020\nWREG;\nPC\n=\nAddress (NEQUAL)\nCPFSGT\nCompare f with WREG, skip if f > WREG\nSyntax:\n[ label ]   CPFSGT    f [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce [0,1]\nOperation:\n(f) \uf02d\uf020\uf028 WREG), skip if (f) > (WREG) (unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n010a\nffff\nffff\nDescription:\nCompares the contents of data memory location 'f' to the contents of the WREG by performing an unsigned subtraction.\nIf the contents of 'f' are greater than the contents of WREG  then the , fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nskip:, Q2.Read register 'f' = skip:. skip:, Q3 Process.Data = skip:. skip:, Q4 No.operation = skip:. Q1, Q2.Read register 'f' = Q2. Q1, Q3 Process.Data = Q3. Q1, Q4 No.operation = Q4. No operation, Q2.Read register 'f' = No operation. No operation, Q3 Process.Data = No operation. No operation, Q4 No.operation = No operation. skip and followed by 2-word instruction:, Q2.Read register 'f' = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 Process.Data = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 No.operation = skip and followed by 2-word instruction:. Q1, Q2.Read register 'f' = Q2. Q1, Q3 Process.Data = Q3. Q1, Q4 No.operation = Q4. No operation, Q2.Read register 'f' = No operation.",
    "Q Cycle Activity:\nNo operation, Q3 Process.Data = No operation. No operation, Q4 No.operation = No operation. No operation, Q2.Read register 'f' = No operation. No operation, Q3 Process.Data = No operation. No operation, Q4 No.operation = No operation. Example:, Q2.Read register 'f' = HERE NGREATER. Example:, Q3 Process.Data = CPFSGT REG, :. Example:, Q4 No.operation = 0. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3 Process.Data = Before Instruction. Before Instruction, Q4 No.operation = Before Instruction. PC, Q2.Read register 'f' = =. PC, Q3 Process.Data = Address (HERE). PC, Q4 No.operation = . WREG, Q2.Read register 'f' = =. WREG, Q3 Process.Data = ?. WREG, Q4 No.operation = . After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3 Process.Data = After Instruction. After Instruction, Q4 No.operation =",
    "Q Cycle Activity:\nAfter Instruction. If REG, Q2.Read register 'f' = >. If REG, Q3 Process.Data = WREG; (GREATER). If REG, Q4 No.operation = . PC, Q2.Read register 'f' = =. PC, Q3 Process.Data = Address. PC, Q4 No.operation = . If REG, Q2.Read register 'f' = \uf0a3. If REG, Q3 Process.Data = WREG;. If REG, Q4 No.operation = . PC, Q2.Read register 'f' = =. PC, Q3 Process.Data = Address. PC, Q4 No.operation = (NGREATER)\nCPFSLT\nCompare f with WREG, skip if f < WREG\nSyntax:\n[ label ]   CPFSLT    f [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce [0,1]\nOperation:\n(f) - \uf020\uf028 WREG),\nskip if (f) < (WREG)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n000a\nffff\nffff\nDescription:\nCompares the contents of data memory location 'f' to the contents of WREG by performing an unsigned subtraction.",
    "Q Cycle Activity:\nIf the contents of 'f' are less than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR will not be overridden (default).\nWords:\n1\nCycles:\n1(2)\nNote: 3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nIf skip:, Q2.Read register 'f' = . If skip:, Q3.Process Data = . If skip:, Q4.No operation = . Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.No operation = Q4. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.No operation = No operation. skip and followed by 2-word instruction:, Q2.Read register 'f' = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3.Process Data = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4.No operation = skip and followed by 2-word instruction:. Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.No operation = Q4. No operation, Q2.Read register 'f' = No operation. No operation,",
    "Q Cycle Activity:\nQ3.Process Data = No operation. No operation, Q4.No operation = No operation. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.No operation = No operation. Example:, Q2.Read register 'f' = HERE NLESS LESS. Example:, Q3.Process Data = CPFSLT REG, :. Example:, Q4.No operation = 1. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3.Process Data = . Before Instruction, Q4.No operation = . PC W, Q2.Read register 'f' = =. PC W, Q3.Process Data = Address. PC W, Q4.No operation = (HERE). After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3.Process Data = . After Instruction, Q4.No operation = . If REG PC, Q2.Read register 'f' = < =. If REG PC, Q3.Process Data = WREG; Address. If REG PC, Q4.No operation",
    "Q Cycle Activity:\n= (LESS). If REG, Q2.Read register 'f' = \uf0b3. If REG, Q3.Process Data = WREG;. If REG, Q4.No operation = . PC, Q2.Read register 'f' = =. PC, Q3.Process Data = Address. PC, Q4.No operation = (NLESS)",
    "Decimal Adjust WREG Register\nSyntax:\n[ label\n]   DAW\nOperands:\nNone\nOperation:\nIf [WREG<3:0> >9] or [DC = 1] then (WREG<3:0>) + 6 \uf0ae WREG<3:0>; else\n( WREG<3:0>) \uf0ae WREG<3:0>;\nIf [WREG<7:4> >9] or [C = 1] then ( WREG<7:4>) + 6 \uf0ae WREG<7:4>; else\n(WREG<7:4>) \uf0ae WREG<7:4>;\nStatus Affected:\nC\nEncoding:\n0000\n0000\n0000\n0111\nDescription:\nDAW adjusts the eight-bit value in WREG, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register WREG\nProcess Data\nWrite WREG",
    "Example1:\nDAW",
    "Before Instruction\nWREG\n=\n0xA5\nC\n=\n0\nDC\n=\n0",
    "After Instruction\nWREG\n=\n0x05\nC\n=\n1\nDC\n=\n0\nExample 2:",
    "Before Instruction\nWREG\n=\n0xCE\nC\n=\n0\nDC\n=\n0",
    "After Instruction\nWREG, 1 = 0x34. C, 1 = 1. DC, 1 = 0",
    "After Instruction\nSyntax:, Decrement f = [ label ] DECF. Syntax:, Decrement f = [ label ] DECF. Syntax:, Decrement f = [ label ] DECF. Syntax:, Decrement f = f [,d [,a]. Syntax:, Decrement f = f [,d [,a]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = . Operands:, Decrement f = . Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = . Operation:, Decrement f = . Status Affected:, Decrement f =",
    "After Instruction\nC,DC,N,OV,Z. Status Affected:, Decrement f = C,DC,N,OV,Z. Status Affected:, Decrement f = C,DC,N,OV,Z. Status Affected:, Decrement f = . Status Affected:, Decrement f = . Encoding:, Decrement f = 0000. Encoding:, Decrement f = 0000. Encoding:, Decrement f = 01da. Encoding:, Decrement f = ffff. Encoding:, Decrement f = ffff. Description:, Decrement f = Decrement register 'f'. If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is 0, the result is stored in WREG.",
    "After Instruction\nIf 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR",
    "After Instruction\nvalue (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = . Words:, Decrement f = . Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = . Cycles:, Decrement f = . Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f =",
    "After Instruction\nQ Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q1, Decrement f = Q2. Q1, Decrement f = Q2. Q1, Decrement f = Q3. Q1, Decrement f = Q3. Q1, Decrement f = Q4. Decode, Decrement f = Read register 'f'. Decode, Decrement f = Read register 'f'. Decode, Decrement f = Process Data. Decode, Decrement f = Process Data. Decode, Decrement f = Write to destination. Example: DECF, Decrement f = Example: DECF. Example: DECF, Decrement f = . Example: DECF, Decrement f = CNT, 1,. Example: DECF, Decrement f = 0. Example: DECF, Decrement f = . Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f =",
    "After Instruction\nBefore Instruction. CNT Z, Decrement f = = =. CNT Z, Decrement f = 0x01 0. CNT Z, Decrement f = . CNT Z, Decrement f = . CNT Z, Decrement f = . After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. CNT Z, Decrement f = = =. CNT Z, Decrement f = 0x00 1. CNT Z, Decrement f = . CNT Z, Decrement f = . CNT Z, Decrement f = \nDECFSZ",
    "Decrement f, skip if 0\nSyntax:\n[\nlabel\n]   DECFSZ   f [,d [,a]]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n(f) - 1 \uf0ae dest,\nskip if result = 0\nStatus Affected:\nNone\nEncoding:\n0010\n11da\nffff\nffff\nDescription:\nThe contents of register 'f' are decremented. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default).\nIf the result is 0, the next instruc- tion, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode\nIf skip:\nQ1\nNo\nQ2\nRead register 'f'\nQ2\nNo\nQ3\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nQ4\nHERE      DECFSZ   CNT, 1, 1\nGOTO     LOOP\nCONTINUE\nBefore Instruction\nPC\n=\nAddress (HERE)\nAfter Instruction\nCNT\n=\nCNT - 1\nIf CNT\n=\n0;\nPC  =\nAddress (CONTINUE)\nIf CNT \uf0b9\n0;\nPC  =\nAddress (HERE+2)\nQ4\nWrite to destination\nQ4\nNo operation",
    "Q Cycle Activity:\nSyntax:, Decrement f, skip if not 0 = [ label ]. Syntax:, Decrement f, skip if not 0 = DCFSNZ. Syntax:, Decrement f, skip if not 0 = f [,d [,a]. Syntax:, Decrement f, skip if not 0 = . Operands:, Decrement f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Decrement f, skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, skip if",
    "Q Cycle Activity:\nnot 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Encoding:, Decrement f, skip if not 0 = 0100. Encoding:, Decrement f, skip if not 0 = 11da. Encoding:, Decrement f, skip if not 0 = ffff. Encoding:, Decrement f, skip if not 0 = ffff. Description:, Decrement f, skip if not 0 = The contents of register 'f' are dec- remented. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If the result is not 0, the next instruction, which is already fetched, is discarded",
    "Q Cycle Activity:\nand a NOP is executed instead, making it a two- cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Decrement f, skip if not 0 = The contents of register 'f' are dec- remented. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If the result is not 0, the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two- cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Decrement f, skip if not 0 = The contents of register 'f' are dec- remented. If 'd' is 0, the result is placed in WREG. If 'd' is",
    "Q Cycle Activity:\n1, the result is placed back in register 'f' (default). If the result is not 0, the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two- cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Decrement f, skip if not 0 = The contents of register 'f' are dec- remented. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If the result is not 0, the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two- cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, Decrement f, skip if not 0 =",
    "Q Cycle Activity:\n1. Words:, Decrement f, skip if not 0 = 1. Words:, Decrement f, skip if not 0 = 1. Words:, Decrement f, skip if not 0 = 1. Cycles:, Decrement f, skip if not 0 = 1(2). Cycles:, Decrement f, skip if not 0 = 1(2). Cycles:, Decrement f, skip if not 0 = 1(2). Cycles:, Decrement f, skip if not 0 = 1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nIf skip:\nQ1\nNo\nQ2\nNo\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE    DCFSNZ  TEMP, 1, 0\nZERO    :\nNZERO   :\nBefore Instruction\nTEMP\n=\n?\nAfter Instruction\nTEMP\n=",
    "Q Cycle Activity:\nTEMP - 1,\nIf TEMP\n=\n0;\nPC\n=\nAddress (ZERO)\nIf TEMP\n\uf0b9\n0;\nPC\n= Address (NZERO)\nQ4\nNo operation",
    "Unconditional Branch\nSyntax:\n[\nlabel\n]    GOTO   k\nOperands:\n0 \uf0a3 k \uf0a3 1048575\nOperation:\nk \uf0ae PC<20:1>\nStatus Affected:\nNone\nEncoding: 1st word (k<7:0>) 2nd word(k<19:8>)\n1110\n1111\n1111\nk 19 kkk\nk 7 kkk\nkkkk\nkkkk 0\nkkkk 8\nDescription:\nGOTO allows an unconditional branch anywhere within entire 2 Mbyte memory range.  The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.\nWords:\n2\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'k'<7:0>,\nNo operation\nRead literal 'k'<19:8>, Write to PC\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nExample:\nGOTO THERE\nAfter Instruction\nPC = Address (THERE)",
    "Unconditional Branch\nINCF, 1 = INCF. INCF, 2 = Increment f. INCF, 3 = Increment f. INCF, 4 = Increment f. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] INCF. Syntax:, 3 = [ label ] INCF. Syntax:, 4 = f [,d [,a]. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 3 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 4 = . Operation:, 1 = Operation:. Operation:, 2 = (f) + 1 \uf0ae dest. Operation:, 3 = (f) + 1 \uf0ae dest. Operation:, 4 = . Status Affected:, 1 = Status Affected:. Status Affected:, 2 = C,DC,N,OV,Z. Status Affected:, 3 = C,DC,N,OV,Z. Status Affected:, 4 = . Encoding:, 1 = Encoding:. Encoding:, 2 = 0010.",
    "Unconditional Branch\nEncoding:, 3 = 10da. Encoding:, 4 = ffff. Description:, 1 = Description:. Description:, 2 = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, 3 = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, 4 = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in WREG.",
    "Unconditional Branch\nIf 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = . Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = . Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read register 'f'. , 3 = Process Data. , 4 = ",
    "Example:\nINCF\nCNT, 1, 0",
    "Before Instruction\nCNT\n=\n0xFF\nZ\n=\n0\nC\n=\n?\nDC\n=\n?",
    "After Instruction\nCNT\n=\n0x00\nZ\n=\n1\nC\n=\n1\nDC\n=\n1\nINCFSZ\nIncrement f, skip if 0\nSyntax:\n[\nlabel\n]    INCFSZ    f [,d [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n(f) + 1 \uf0ae dest,\nskip if result = 0\nStatus Affected:\nNone\nEncoding:\n0011\n11da\nffff\nffff\nDescription:\nThe contents of register 'f' are incremented. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default).\nIf the result is 0, the next instruc- tion, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nWords:\n1\nCycles:\n1(2)\nNote:",
    "After Instruction\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. If skip:, Q2 = . If skip:, Q3 = . If skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE    INCFSZ   CNT, 1, 0\nNZERO   :\nZERO    :",
    "Before Instruction\nPC\n=\nAddress (HERE)\nAfter Instruction\nCNT\n=\nCNT + 1\nIf CNT\n=\n0;\nPC =\nAddress(ZERO)\nIf CNT \uf0b9\n0;\nPC  =\nAddress(NZERO)",
    "Before Instruction\nSyntax:, Increment f, skip if not 0 = [ label ]. Syntax:, Increment f, skip if not 0 = INFSNZ. Syntax:, Increment f, skip if not 0 = f [,d [,a]. Syntax:, Increment f, skip if not 0 = . Operands:, Increment f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Increment f, skip if not 0 = (f) + 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Increment f, skip if not 0 = (f) + 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Increment f, skip if not 0",
    "Before Instruction\n= (f) + 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Increment f, skip if not 0 = (f) + 1 \uf0ae dest, skip if result \uf0b9 0. Status Affected:, Increment f, skip if not 0 = None. Status Affected:, Increment f, skip if not 0 = None. Status Affected:, Increment f, skip if not 0 = None. Status Affected:, Increment f, skip if not 0 = None. Encoding:, Increment f, skip if not 0 = 0100. Encoding:, Increment f, skip if not 0 = 10da. Encoding:, Increment f, skip if not 0 = ffff. Encoding:, Increment f, skip if not 0 = ffff. Description:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If the result is not 0, the next instruction, which is already fetched, is discarded and a NOP is executed",
    "Before Instruction\ninstead, making it a two- cycle instruction. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the. Description:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If the result is not 0, the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two- cycle instruction. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the. Description:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If the result is not 0, the next",
    "Before Instruction\ninstruction, which is already fetched, is discarded and a NOP is executed instead, making it a two- cycle instruction. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the. Description:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If the result is not 0, the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two- cycle instruction. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the. Words:, Increment f, skip if not 0 = 1. Words:, Increment f, skip if not 0 = 1. Words:, Increment f, skip if not 0 = 1. Words:, Increment f, skip",
    "Before Instruction\nif not 0 = 1. Cycles:, Increment f, skip if not 0 = 1(2). Cycles:, Increment f, skip if not 0 = 1(2). Cycles:, Increment f, skip if not 0 = 1(2). Cycles:, Increment f, skip if not 0 = 1(2)\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. skip:, Q2 = . skip:, Q3 = . skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4",
    "Q Cycle Activity:\n= No operation\nExample:\nHERE    INFSNZ  REG, 1, 0\nZERO\nNZERO",
    "Before Instruction\nPC, 1 = =. PC, 2 = Address (HERE). After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. REG If REG, 1 = = \uf0b9. REG If REG, 2 = REG + 1 0; Address (NZERO). PC If REG, 1 = = =. PC If REG, 2 = 0;. PC, 1 = =. PC, 2 = . , 1 = . , 2 = Address (ZERO)",
    "Inclusive OR literal with WREG\nSyntax:\n[ label\n]    IORLW   k\nOperands:\n0 \uf0a3 k \uf0a3 255\nOperation:\n(WREG) .OR. k \uf0ae WREG\nStatus Affected:\nN,Z\nEncoding:\n0000\n1001\nkkkk\nkkkk\nDescription:\nThe contents of WREG are OR'ed with the eight-bit literal 'k'. The result is placed in WREG.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral 'k'\nProcess\nData\nWrite to\nWREG\nExample:\nIORLW\n0x35\nBefore Instruction\nWREG\n=\n0x9A\nAfter Instruction\nWREG\n=\n0xBF",
    "Inclusive OR WREG with f\nSyntax:\n[ label\n]    IORWF     f [,d [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n(WREG) .OR. (f) \uf0ae dest\nStatus Affected:\nN,Z\nEncoding:\n0001\n00da\nffff\nffff\nDescription:\nInclusive OR WREG with register 'f'. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite to\ndestination",
    "Example:\nIORWF  RESULT, 0, 1",
    "Before Instruction\nRESULT\n=\n0x13\nWREG\n=\n0x91",
    "After Instruction\nRESULT\n=\n0x13\nWREG\n=\n0x93",
    "After Instruction\nSyntax:, Load FSR = [ label ]. Syntax:, Load FSR = LFSR f,k. Syntax:, Load FSR = . Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operation:, Load FSR = k \uf0ae FSRf. Operation:, Load FSR = k \uf0ae FSRf. Operation:, Load FSR = k \uf0ae FSRf. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Encoding:, Load FSR = 1110 1111. Encoding:, Load FSR = 1110 0000. Encoding:, Load FSR = 00ff k 11 kkk kkkk. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Description:,",
    "After Instruction\nLoad FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Words:, Load FSR = 2. Words:, Load FSR = 2. Words:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q1, Load FSR = Q2. Q1, Load FSR = Q3. Q1, Load FSR = Q4. Decode, Load FSR = Read literal 'k' MSB. Decode, Load FSR = Process Data. Decode, Load FSR = Write literal 'k' MSB to FSRfH. Decode, Load FSR = Read literal 'k' LSB. Decode, Load FSR = Process Data. Decode, Load FSR = Write literal 'k' to FSRfL\nExample:\nLFSR 2, 0x3AB\nAfter Instruction",
    "After Instruction\nFSR2H\n= 0x03\nFSR2L\n=\n0xAB",
    "After Instruction\nSyntax:, Move f = [ label ]. Syntax:, Move f = MOVF. Syntax:, Move f = f [,d [,a]. Syntax:, Move f = . Operands:, Move f = 0 \uf0a3 f \uf0a3 255. Operands:, Move f = 0 \uf0a3 f \uf0a3 255. Operands:, Move f = 0 \uf0a3 f \uf0a3 255. Operands:, Move f = 0 \uf0a3 f \uf0a3 255. , Move f = d \uf0ce [0,1]. , Move f = d \uf0ce [0,1]. , Move f = d \uf0ce [0,1]. , Move f = d \uf0ce [0,1]. , Move f = a \uf0ce [0,1]. , Move f = a \uf0ce [0,1]. , Move f = a \uf0ce [0,1]. , Move f = a \uf0ce [0,1]. Operation:, Move f = f \uf0ae dest. Operation:, Move f = f \uf0ae dest. Operation:, Move f = f \uf0ae dest. Operation:, Move f = f \uf0ae dest. Status Affected:, Move f = N,Z. Status Affected:, Move f = N,Z. Status Affected:, Move f = N,Z. Status Affected:, Move f =",
    "After Instruction\nN,Z. Encoding:, Move f = 0101. Encoding:, Move f = 00da. Encoding:, Move f = ffff. Encoding:, Move f = ffff\nDescription:\nThe contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256 byte bank. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write WREG",
    "After Instruction\nBefore Instruction, MOVF = Before Instruction. Before Instruction, REG, 0, 0 = . REG, MOVF = =. REG, REG, 0, 0 = 0x22. WREG, MOVF = =. WREG, REG, 0, 0 = 0xFF. After Instruction, MOVF = After Instruction. After Instruction, REG, 0, 0 = . REG, MOVF = =. REG, REG, 0, 0 = 0x22. WREG, MOVF = =. WREG, REG, 0, 0 = 0x22",
    "PIC18CXX2\nSyntax:, Move f to f = [ label ]. Syntax:, Move f to f = MOVFF. Syntax:, Move f to f = f s ,f d. Syntax:, Move f to f = . Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, Move f to f = . Operands:, Move f to f = . Operation:, Move f to f = (f s ) \uf0ae f d. Operation:, Move f to f = (f s ) \uf0ae f d. Operation:, Move f to f = . Operation:, Move f to f = . Status Affected:, Move f to f = None. Status Affected:, Move f to f = None. Status Affected:, Move f to f = . Status Affected:, Move f to f = . Encoding: 1st word (source), Move f to f = 1100. Encoding: 1st word (source), Move f to f = ffff. Encoding: 1st word (source), Move f to f = ffff. Encoding: 1st",
    "PIC18CXX2\nword (source), Move f to f = ffff s. 2nd word (destin.), Move f to f = 1111. 2nd word (destin.), Move f to f = ffff. 2nd word (destin.), Move f to f = ffff. 2nd word (destin.), Move f to f = ffff d\nDescription:\nThe contents of source register 'f ' s are moved to destination register 'f d '.  Location of source 'f s ' can be anywhere in the 4096 byte data space (000h to FFFh), and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be WREG (a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port).\nThe MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.\nWords:\n2\nCycles:\n2 (3)\nQ Cycle Activity:\nQ1\nQ2\nQ3",
    "PIC18CXX2\nDecode, 1 = Read register 'f' (src). Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f' (dest)\nBefore Instruction, MOVFF = Before Instruction. Before Instruction, REG1, REG2 = . REG1, MOVFF = =. REG1, REG1, REG2 = 0x33. REG2, MOVFF = =. REG2, REG1, REG2 = 0x11. After Instruction, MOVFF = After Instruction. After Instruction, REG1, REG2 = . REG1, MOVFF = =. REG1, REG1, REG2 = 0x33,. REG2, MOVFF = =. REG2, REG1, REG2 = 0x33\nQ4",
    "PIC18CXX2\nSyntax:, Move literal to low nibble in BSR = [ label ] MOVLB k. Syntax:, Move literal to low nibble in BSR = [ label ] MOVLB k. Syntax:, Move literal to low nibble in BSR = [ label ] MOVLB k. Syntax:, Move literal to low nibble in BSR = [ label ] MOVLB k. Operands:, Move literal to low nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to low nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to low nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to low nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operation:, Move literal to low nibble in BSR = k \uf0ae BSR. Operation:, Move literal to low nibble in BSR = k \uf0ae BSR. Operation:, Move literal to low nibble in BSR = k \uf0ae BSR. Operation:, Move literal to low nibble in BSR = k \uf0ae BSR. Status Affected:, Move literal to low nibble in BSR = None. Status Affected:, Move literal to low nibble in",
    "PIC18CXX2\nBSR = None. Status Affected:, Move literal to low nibble in BSR = None. Status Affected:, Move literal to low nibble in BSR = None. Encoding:, Move literal to low nibble in BSR = 0000. Encoding:, Move literal to low nibble in BSR = 0001. Encoding:, Move literal to low nibble in BSR = kkkk. Encoding:, Move literal to low nibble in BSR = kkkk. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Words:, Move literal to low nibble in BSR",
    "PIC18CXX2\n= 1. Words:, Move literal to low nibble in BSR = 1. Words:, Move literal to low nibble in BSR = 1. Words:, Move literal to low nibble in BSR = 1. Cycles:, Move literal to low nibble in BSR = 1. Cycles:, Move literal to low nibble in BSR = 1. Cycles:, Move literal to low nibble in BSR = 1. Cycles:, Move literal to low nibble in BSR = 1. Q Cycle Activity:, Move literal to low nibble in BSR = Q Cycle Activity:. Q Cycle Activity:, Move literal to low nibble in BSR = Q Cycle Activity:. Q Cycle Activity:, Move literal to low nibble in BSR = Q Cycle Activity:. Q Cycle Activity:, Move literal to low nibble in BSR = Q Cycle Activity:. Q1, Move literal to low nibble in BSR = Q2. Q1, Move literal to low nibble in BSR = Q3. Q1, Move literal to low nibble in BSR = Q4. Q1, Move literal to low nibble in BSR =",
    "PIC18CXX2\nQ4. Decode, Move literal to low nibble in BSR = Read literal 'k'. Decode, Move literal to low nibble in BSR = Process Data. Decode, Move literal to low nibble in BSR = Write literal 'k' to BSR. Decode, Move literal to low nibble in BSR = Write literal 'k' to BSR. Example:, Move literal to low nibble in BSR = MOVLB 5. Example:, Move literal to low nibble in BSR = MOVLB 5. Example:, Move literal to low nibble in BSR = MOVLB 5. Example:, Move literal to low nibble in BSR = MOVLB 5. Before Instruction, Move literal to low nibble in BSR = Before Instruction. Before Instruction, Move literal to low nibble in BSR = Before Instruction. Before Instruction, Move literal to low nibble in BSR = Before Instruction. Before Instruction, Move literal to low nibble in BSR = Before Instruction. BSR register After Instruction, Move literal to low nibble in BSR = BSR register After Instruction. BSR register After Instruction, Move literal to low",
    "PIC18CXX2\nnibble in BSR = 0x02. BSR register After Instruction, Move literal to low nibble in BSR = . BSR register After Instruction, Move literal to low nibble in BSR = ",
    "PIC18CXX2\nSyntax:, Move literal to WREG = [ label ] MOVLW. Syntax:, Move literal to WREG = [ label ] MOVLW. Syntax:, Move literal to WREG = k. Syntax:, Move literal to WREG = . Operands:, Move literal to WREG = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to WREG = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to WREG = . Operands:, Move literal to WREG = . Operation:, Move literal to WREG = k \uf0ae WREG. Operation:, Move literal to WREG = k \uf0ae WREG. Operation:, Move literal to WREG = . Operation:, Move literal to WREG = . Status Affected:, Move literal to WREG = None. Status Affected:, Move literal to WREG = None. Status Affected:, Move literal to WREG = . Status Affected:, Move literal to WREG = . Encoding:, Move literal to WREG = 0000. Encoding:, Move literal to WREG = 1110. Encoding:, Move literal to WREG = kkkk. Encoding:, Move literal to WREG = kkkk. Description:, Move",
    "PIC18CXX2\nliteral to WREG = The eight-bit literal 'k' is loaded into WREG.. Description:, Move literal to WREG = The eight-bit literal 'k' is loaded into WREG.. Description:, Move literal to WREG = The eight-bit literal 'k' is loaded into WREG.. Description:, Move literal to WREG = The eight-bit literal 'k' is loaded into WREG.. Words:, Move literal to WREG = 1. Words:, Move literal to WREG = . Words:, Move literal to WREG = . Words:, Move literal to WREG = . Cycles:, Move literal to WREG = 1. Cycles:, Move literal to WREG = . Cycles:, Move literal to WREG = . Cycles:, Move literal to WREG = . Q Cycle Activity:, Move literal to WREG = Q Cycle Activity:. Q Cycle Activity:, Move literal to WREG = Q Cycle Activity:. Q Cycle Activity:, Move literal to WREG = . Q Cycle Activity:, Move literal to WREG = . Q1, Move literal to WREG = Q2. Q1, Move literal to WREG =",
    "PIC18CXX2\nQ3. Q1, Move literal to WREG = . Q1, Move literal to WREG = Q4. Decode, Move literal to WREG = Read literal 'k'. Decode, Move literal to WREG = Process Data. Decode, Move literal to WREG = . Decode, Move literal to WREG = Write to WREG. Example:, Move literal to WREG = MOVLW. Example:, Move literal to WREG = 0x5A. Example:, Move literal to WREG = . Example:, Move literal to WREG = . After Instruction, Move literal to WREG = After Instruction. After Instruction, Move literal to WREG = . After Instruction, Move literal to WREG = . After Instruction, Move literal to WREG = . WREG, Move literal to WREG = 0x5A. WREG, Move literal to WREG = . WREG, Move literal to WREG = . WREG, Move literal to WREG = ",
    "PIC18CXX2\nSyntax:, MOVWF = Syntax:. Syntax:, Move WREG to f = [ label ] MOVWF f. Syntax:, Move WREG to f = [ label ] MOVWF f. Syntax:, Move WREG to f = [ label ] MOVWF f. Operands:, MOVWF = Operands:. Operands:, Move WREG to f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Move WREG to f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Move WREG to f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, MOVWF = Operation:. Operation:, Move WREG to f = (WREG) \uf0ae f. Operation:, Move WREG to f = (WREG) \uf0ae f. Operation:, Move WREG to f = (WREG) \uf0ae f. Status Affected:, MOVWF = Status Affected:. Status Affected:, Move WREG to f = None. Status Affected:, Move WREG to f = None. Status Affected:, Move WREG to f = None. Encoding:, MOVWF =",
    "PIC18CXX2\nEncoding:. Encoding:, Move WREG to f = 0110. Encoding:, Move WREG to f = 111a. Encoding:, Move WREG to f = ffff. Description:, MOVWF = Description:. Description:, Move WREG to f = Move data from WREG to register 'f'. Location 'f' can be anywhere in the 256 byte bank. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Move WREG to f = Move data from WREG to register 'f'. Location 'f' can be anywhere in the 256 byte bank. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Move WREG to f = Move data from WREG to register 'f'. Location 'f' can be anywhere in the 256 byte bank. If 'a' is 0, the Access Bank",
    "PIC18CXX2\nwill be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, MOVWF = Words:. Words:, Move WREG to f = 1. Words:, Move WREG to f = 1. Words:, Move WREG to f = 1. Cycles:, MOVWF = Cycles:. Cycles:, Move WREG to f = 1. Cycles:, Move WREG to f = 1. Cycles:, Move WREG to f = 1. Q Cycle Activity:, MOVWF = Q Cycle Activity:. Q Cycle Activity:, Move WREG to f = Q Cycle Activity:. Q Cycle Activity:, Move WREG to f = Q Cycle Activity:. Q Cycle Activity:, Move WREG to f = Q Cycle Activity:. , MOVWF = Q1. , Move WREG to f = Q2. , Move WREG to f = Q3. , Move WREG to f = Q4. , MOVWF = Decode. , Move WREG to f = Read register 'f'. , Move",
    "PIC18CXX2\nWREG to f = Process Data. , Move WREG to f = Write register 'f'",
    "Example:\nMOVWF\nREG, 0\nBefore Instruction\nWREG\n=\n0x4F\nREG\n=\n0xFF\nAfter Instruction\nWREG\n=\n0x4F\nREG\n=\n0x4F",
    "Multiply Literal with WREG\nSyntax:\n[ label\n]    MULLW     k\nOperands:\n0 \uf0a3 k \uf0a3 255\nOperation:\n(WREG) x k \uf0ae PRODH:PRODL\nStatus Affected:\nNone\nEncoding:\n0000\n1101\nkkkk\nkkkk\nDescription:\nAn unsigned multiplication is car- ried out between the contents of WREG and the 8-bit literal 'k'. The 16-bit result is placed in PRODH:PRODL register pair. PRODH contains the high byte. WREG is unchanged. None of the status flags are affected. Note that neither overflow, nor carry is possible in this opera- tion. A zero result is possible but not detected.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral 'k'\nProcess Data\nWrite registers PRODH: PRODL",
    "Example:\nMULLW   0xC4",
    "Before Instruction\nWREG\n=\n0xE2\nPRODH\n=\n?\nPRODL\n=\n?",
    "After Instruction\nWREG\n= 0xE2\nPRODH\n=\n0xAD\nPRODL\n= 0x08",
    "After Instruction\nSyntax:, MULWF = Syntax:. Syntax:, Multiply WREG with f = [ label ]. Syntax:, Multiply WREG with f = MULWF. Syntax:, Multiply WREG with f = f [,a]. Operands:, MULWF = Operands:. Operands:, Multiply WREG with f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Multiply WREG with f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Multiply WREG with f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, MULWF = Operation:. Operation:, Multiply WREG with f = (WREG) x (f) \uf0ae PRODH:PRODL. Operation:, Multiply WREG with f = (WREG) x (f) \uf0ae PRODH:PRODL. Operation:, Multiply WREG with f = (WREG) x (f) \uf0ae PRODH:PRODL. Status Affected:, MULWF = Status Affected:. Status Affected:, Multiply WREG with f = None. Status Affected:, Multiply WREG with f = None.",
    "After Instruction\nStatus Affected:, Multiply WREG with f = None. Encoding:, MULWF = Encoding:. Encoding:, Multiply WREG with f = 0000. Encoding:, Multiply WREG with f = 001a. Encoding:, Multiply WREG with f = ffff. Description:, MULWF = Description:. Description:, Multiply WREG with f = An unsigned multiplication is car- ried out between the contents of WREG and the register file loca- tion 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both WREG and 'f' are unchanged. None of the status flags are affected. Note that neither overflow, nor carry is possible in this opera- tion. A zero result is possible but not detected. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a'=. Description:, Multiply WREG with f = An unsigned multiplication is car- ried out between the contents of WREG and the register file loca- tion 'f'. The 16-bit result is stored in the",
    "After Instruction\nPRODH:PRODL register pair. PRODH contains the high byte. Both WREG and 'f' are unchanged. None of the status flags are affected. Note that neither overflow, nor carry is possible in this opera- tion. A zero result is possible but not detected. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a'=. Description:, Multiply WREG with f = An unsigned multiplication is car- ried out between the contents of WREG and the register file loca- tion 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both WREG and 'f' are unchanged. None of the status flags are affected. Note that neither overflow, nor carry is possible in this opera- tion. A zero result is possible but not detected. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a'=. Words:, MULWF = Words:. Words:, Multiply WREG with f = 1. Words:, Multiply WREG with f = 1.",
    "After Instruction\nWords:, Multiply WREG with f = 1. Cycles:, MULWF = Cycles:. Cycles:, Multiply WREG with f = 1. Cycles:, Multiply WREG with f = 1. Cycles:, Multiply WREG with f = 1. Q Cycle Activity:, MULWF = Q Cycle Activity:. Q Cycle Activity:, Multiply WREG with f = Q Cycle Activity:. Q Cycle Activity:, Multiply WREG with f = Q Cycle Activity:. Q Cycle Activity:, Multiply WREG with f = Q Cycle Activity:. , MULWF = Q1. , Multiply WREG with f = Q2. , Multiply WREG with f = Q3. , Multiply WREG with f = . , MULWF = Decode. , Multiply WREG with f = Read register 'f'. , Multiply WREG with f = Process Data. , Multiply WREG with f = ",
    "Example:\nMULWF   REG, 1",
    "Before Instruction\nWREG\n=\n0xC4\nREG\n=\n0xB5\nPRODH\n=\n?\nPRODL\n=\n?",
    "After Instruction\nREG, = = =. REG, 0xC4 = 0xB5. PRODH, = = =. PRODH, 0xC4 = 0x8A. PRODL, = = =. PRODL, 0xC4 = 0x94",
    "After Instruction\nSyntax:, Negate f = [ label ]. Syntax:, Negate f = NEGF. Syntax:, Negate f = f [,a]. Syntax:, Negate f = . Operands:, Negate f = 0 \uf0a3 f \uf0a3 255. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255. Operands:, Negate f = . Operands:, Negate f = . , Negate f = a \uf0ce [0,1]. , Negate f = a \uf0ce [0,1]. , Negate f = . , Negate f = . Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = . Operation:, Negate f = . Status Affected:, Negate f = N,OV, C, DC, Z. Status Affected:, Negate f = N,OV, C, DC, Z. Status Affected:, Negate f = . Status Affected:, Negate f = . Encoding:, Negate f = 0110. Encoding:, Negate f = 110a. Encoding:, Negate f = ffff. Encoding:,",
    "After Instruction\nNegate f = ffff\nDescription:\nLocation 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value.\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\n1\n1\nQ2\nRead\nQ3\nProcess register 'f'\nData\nExample:\nNEGF\nREG, 1\nBefore Instruction\nREG\n=\n0011 1010 [0x3A]\nAfter Instruction\nREG\n=\n1100 0110 [0xC6]\nQ4\nWrite register 'f'",
    "PIC18CXX2\nSyntax:, No Operation = [ label ]. Syntax:, No Operation = NOP. Syntax:, No Operation = . Syntax:, No Operation = . Operands:, No Operation = None. Operands:, No Operation = . Operands:, No Operation = . Operands:, No Operation = . Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = . Operation:, No Operation = . Status Affected:, No Operation = None. Status Affected:, No Operation = . Status Affected:, No Operation = . Status Affected:, No Operation = . Encoding:, No Operation = 0000. Encoding:, No Operation = 0000. Encoding:, No Operation = 0000. Encoding:, No Operation = 0000 xxxx. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = . Description:, No Operation = . Words:, No Operation = 1. Words:, No Operation = . Words:, No Operation = . Words:, No Operation = . Cycles:, No Operation = 1. Cycles:, No Operation = . Cycles:, No",
    "PIC18CXX2\nOperation = . Cycles:, No Operation = . Q Cycle Activity: Q1, No Operation = Q2. Q Cycle Activity: Q1, No Operation = Q3. Q Cycle Activity: Q1, No Operation = . Q Cycle Activity: Q1, No Operation = Q4. Decode, No Operation = No operation. Decode, No Operation = No operation. Decode, No Operation = . Decode, No Operation = No operation\nExample:\nNone.",
    "Pop Top of Return Stack\nSyntax:, 1 = [ label ] POP. Syntax:, 2 = [ label ] POP. Syntax:, 3 = [ label ] POP. Syntax:, 4 = [ label ] POP. Syntax:, 5 = [ label ] POP. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operands:, 5 = None. Operation:, 1 = (TOS) \uf0ae bit bucket. Operation:, 2 = (TOS) \uf0ae bit bucket. Operation:, 3 = (TOS) \uf0ae bit bucket. Operation:, 4 = (TOS) \uf0ae bit bucket. Operation:, 5 = (TOS) \uf0ae bit bucket. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = 0000. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Encoding:, 4 = . Encoding:, 5 = 0110. Description:, 1 = The TOS value is pulled off the return stack and is discarded. The TOS value",
    "Pop Top of Return Stack\nthen becomes the previ- ous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 2 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previ- ous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 3 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previ- ous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 4 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previ- ous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 5 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previ-",
    "Pop Top of Return Stack\nous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Cycles:, 5 = 1. Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q Cycle Activity:, 5 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 5 = Q4. , 1 = Decode. , 2 = No operation. , 3 = POP TOS value. , 4 = . , 5 = No operation. Example:, 1 = POP. Example:, 2 = POP. Example:, 3 = POP. Example:, 4 = POP. Example:, 5 = POP. , 1 = GOTO Before Instruction. , 2 = . , 3 =",
    "Pop Top of Return Stack\nNEW. , 4 = . , 5 = . TOS, 1 = Stack (1 TOS PC. TOS, 2 = level. TOS, 3 = = down)=. TOS, 4 = 0031A2h 014332h. TOS, 5 = . After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. After Instruction, 3 = After Instruction. After Instruction, 4 = After Instruction. After Instruction, 5 = After Instruction. , 1 = . , 2 = . , 3 = = =. , 4 = 014332h NEW. , 5 = ",
    "Pop Top of Return Stack\nSyntax:, PUSH = Syntax:. Syntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Operands:, PUSH = Operands:. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operation:, PUSH = Operation:. Operation:, Push Top of Return Stack = (PC+2) \uf0ae TOS. Operation:, Push Top of Return Stack = (PC+2) \uf0ae TOS. Operation:, Push Top of Return Stack = (PC+2) \uf0ae TOS. Status Affected:, PUSH = Status Affected:. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Encoding:, PUSH = Encoding:. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0000. Description:, PUSH =",
    "Pop Top of Return Stack\nDescription:. Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS, and then push it onto the return stack.. Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS, and then push it onto the return stack.. Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS, and then push it onto the return stack.. Words:, PUSH = Words:. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Cycles:, PUSH = Cycles:. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:,",
    "Pop Top of Return Stack\nPush Top of Return Stack = 1. Q Cycle Activity:, PUSH = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. , PUSH = Q1. , Push Top of Return Stack = Q2. , Push Top of Return Stack = Q3. , Push Top of Return Stack = . , PUSH = Decode. , Push Top of Return Stack = PUSH PC+2 onto return stack. , Push Top of Return Stack = No operation. , Push Top of Return Stack = No operation. Example:, PUSH = Example:. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. , PUSH = Before Instruction. , Push Top of Return Stack = Before Instruction. , Push Top of Return Stack = Before Instruction. , Push Top of Return Stack = Before Instruction. , PUSH = TOS =. , Push Top of Return Stack = TOS =. , Push Top of Return Stack = TOS =. , Push",
    "Pop Top of Return Stack\nTop of Return Stack = 00345Ah. , PUSH = PC. , Push Top of Return Stack = PC. , Push Top of Return Stack = PC. , Push Top of Return Stack = 000124h. , PUSH = . , Push Top of Return Stack = . , Push Top of Return Stack = . , Push Top of Return Stack = 000126h. , PUSH = PC TOS. , Push Top of Return Stack = PC TOS. , Push Top of Return Stack = PC TOS. , Push Top of Return Stack = 000126h. , PUSH = Stack (1 level down) =. , Push Top of Return Stack = Stack (1 level down) =. , Push Top of Return Stack = Stack (1 level down) =. , Push Top of Return Stack = 00345Ah",
    "Pop Top of Return Stack\nSyntax:, Relative Call = [ label ] RCALL n. Syntax:, Relative Call = [ label ] RCALL n. Syntax:, Relative Call = [ label ] RCALL n. Syntax:, Relative Call = [ label ] RCALL n. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Encoding:, Relative Call = 1101.",
    "Pop Top of Return Stack\nEncoding:, Relative Call = 1nnn. Encoding:, Relative Call = nnnn. Encoding:, Relative Call = nnnn. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC+2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PCwill have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC+2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PCwill have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC+2) is pushed onto the stack. Then,",
    "Pop Top of Return Stack\nadd the 2's complement number '2n' to the PC. Since the PCwill have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC+2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PCwill have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is a two-cycle instruction.. Words:, Relative Call = 1. Words:, Relative Call = 1. Words:, Relative Call = 1. Words:, Relative Call = 1. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Q Cycle Activity: Q1, Relative Call = Q2. Q Cycle Activity: Q1, Relative Call = Q3. Q Cycle Activity: Q1, Relative Call = Q3. Q Cycle Activity:",
    "Pop Top of Return Stack\nQ1, Relative Call = Q4. Decode, Relative Call = Read literal 'n' Push PC to stack. Decode, Relative Call = Process Data. Decode, Relative Call = Process Data. Decode, Relative Call = Write to PC. No operation, Relative Call = No operation. No operation, Relative Call = No operation. No operation, Relative Call = No operation. No operation, Relative Call = No operation",
    "Example:\nHERE\nRCALL Jump\nBefore Instruction\nPC = Address(HERE)\nAfter Instruction\nPC = Address(Jump)\nTOS =\nAddress (HERE+2)",
    "PIC18CXX2\nSyntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operation:, Reset = Reset all registers and flags that are affected by a MCLR reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR reset.. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Encoding:, Reset = 0000. Encoding:, Reset = 0000. Encoding:, Reset = 1111. Encoding:, Reset = 1111. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR",
    "PIC18CXX2\nReset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q1, Reset = Q2. Q1, Reset = Q3. Q1, Reset = . Q1, Reset = Q4. Decode, Reset = Start reset. Decode, Reset = No operation. Decode, Reset = . Decode, Reset = No operation. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset = RESET. After Instruction, Reset = After Instruction. After Instruction, Reset = .",
    "PIC18CXX2\nAfter Instruction, Reset = . After Instruction, Reset = ",
    "Return from Interrupt\nSyntax:\n[\nlabel\n]    RETFIE   [s]\nOperands:\ns \uf0ce [0,1]\nOperation:\n(TOS) \uf0ae PC,\n1 \uf0ae GIE/GIEH or PEIE/GIEL,\nif s = 1\n(WS) \uf0ae WREG,\n(STATUSS) \uf0ae STATUS,\n(BSRS)\n\uf0ae\nBSR,\nPCLATU, PCLATH are unchanged.\nStatus Affected:",
    "GIE/GIEH,PEIE/GIEL.\nEncoding:\n0000\n0000\n0001\n000s\nDescription:\nReturn from Interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, WREG, STATUS and BSR. If 's' = 0, no update of these registers occurs (default).\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nNo operation\nNo operation\npop PC from\nstack\nSet GIEH or GIEL\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation",
    "Example:\nRETFIE  1\nAfter Interrupt\nPC\n=\nTOS\nW\n=\nWS\nBSR\n=\nBSRS\nSTATUS\n=\nSTATUSS\nGIE/GIEH, PEIE/GIEL=\n1",
    "Example:\nSyntax:, Return Literal to WREG = [ label ] RETLW k. Syntax:, Return Literal to WREG = [ label ] RETLW k. Syntax:, Return Literal to WREG = [ label ] RETLW k. Syntax:, Return Literal to WREG = [ label ] RETLW k. Operands:, Return Literal to WREG = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to WREG = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to WREG = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to WREG = 0 \uf0a3 k \uf0a3 255. Operation:, Return Literal to WREG = k \uf0ae WREG, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to WREG = k \uf0ae WREG, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to WREG = k \uf0ae WREG, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to WREG = k \uf0ae WREG, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Status Affected:, Return Literal to WREG = None. Status",
    "Example:\nAffected:, Return Literal to WREG = None. Status Affected:, Return Literal to WREG = None. Status Affected:, Return Literal to WREG = None. Encoding:, Return Literal to WREG = 0000. Encoding:, Return Literal to WREG = 1100. Encoding:, Return Literal to WREG = kkkk. Encoding:, Return Literal to WREG = kkkk. Description:, Return Literal to WREG = WREG is loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to WREG = WREG is loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to WREG = WREG is loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to WREG = WREG",
    "Example:\nis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Words:, Return Literal to WREG = 1. Words:, Return Literal to WREG = 1. Words:, Return Literal to WREG = 1. Words:, Return Literal to WREG = 1. Cycles:, Return Literal to WREG = 2. Cycles:, Return Literal to WREG = 2. Cycles:, Return Literal to WREG = 2. Cycles:, Return Literal to WREG = 2. Q Cycle Activity:, Return Literal to WREG = Q Cycle Activity:. Q Cycle Activity:, Return Literal to WREG = Q Cycle Activity:. Q Cycle Activity:, Return Literal to WREG = Q Cycle Activity:. Q Cycle Activity:, Return Literal to WREG = Q Cycle Activity:. Q1, Return Literal to WREG = Q2. Q1, Return Literal to WREG = Q3. Q1, Return Literal to WREG = . Q1, Return Literal to WREG = Q4. Decode, Return Literal to WREG = Read literal",
    "Example:\n'k'. Decode, Return Literal to WREG = Process Data. Decode, Return Literal to WREG = pop PC from stack, Write to WREG. Decode, Return Literal to WREG = pop PC from stack, Write to WREG. No operation, Return Literal to WREG = No operation. No operation, Return Literal to WREG = No operation. No operation, Return Literal to WREG = No operation. No operation, Return Literal to WREG = No operation\nCALL TABLE\n; WREG contains table\n; offset value\n; WREG now has\n; table value\n:\nTABLE\nADDWF PCL\n; WREG = offset\nRETLW k0\n; Begin table\nRETLW k1\n;\n:\n:\nRETLW kn\n; End of table",
    "Before Instruction\nWREG\n= 0x07\nAfter Instruction\nWREG\n=\nvalue of kn",
    "Before Instruction\nSyntax:, RETURN = Syntax:. Syntax:, Return from Subroutine = [ label ] RETURN [s]. Syntax:, Return from Subroutine = [ label ] RETURN [s]. Operands:, RETURN = Operands:. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operation:, RETURN = Operation:. Operation:, Return from Subroutine = (TOS) \uf0ae PC, if s = 1 (WS) \uf0ae WREG, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Subroutine = (TOS) \uf0ae PC, if s = 1 (WS) \uf0ae WREG, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Status Affected:, RETURN = Status Affected:. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Encoding:, RETURN = Encoding:. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0000. Description:, RETURN = Description:. Description:, Return from",
    "Before Instruction\nSubroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1, the contents of the shadow registers WS, STATUSS and BSRS are loaded into their cor- responding registers, WREG, STATUS and BSR. If 's' = 0, no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1, the contents of the shadow registers WS, STATUSS and BSRS are loaded into their cor- responding registers, WREG, STATUS and BSR. If 's' = 0, no update of these registers occurs (default).. Words:, RETURN = Words:. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Cycles:, RETURN = Cycles:. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Q Cycle Activity:, RETURN = Q Cycle Activity:. Q",
    "Before Instruction\nCycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. , RETURN = Q1. , Return from Subroutine = Q2. , Return from Subroutine = Q3. , RETURN = Decode. , Return from Subroutine = No operation. , Return from Subroutine = Process Data. , RETURN = No operation. , Return from Subroutine = No operation. , Return from Subroutine = No operation\nExample:\nRETURN\nAfter Interrupt\nPC = TOS",
    "PIC18CXX2\nSyntax:, Rotate Left f through Carry = [ label ] RLCF. Syntax:, Rotate Left f through Carry = [ label ] RLCF. Syntax:, Rotate Left f through Carry = f [,d [,a]. Syntax:, Rotate Left f through Carry = f [,d [,a]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae C, (C) \uf0ae",
    "PIC18CXX2\ndest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Status Affected:, Rotate Left f through Carry = C,N,Z. Status Affected:, Rotate Left f through Carry = C,N,Z. Status Affected:, Rotate Left f through Carry = C,N,Z. Status Affected:, Rotate Left f through Carry = C,N,Z. Encoding:, Rotate Left f through Carry = 0011. Encoding:, Rotate Left f through Carry = 01da. Encoding:, Rotate Left f through Carry = ffff. Encoding:, Rotate Left f through Carry = ffff. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry Flag. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is",
    "PIC18CXX2\nstored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default). C register f. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry Flag. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default). C register f. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry Flag. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding",
    "PIC18CXX2\nthe BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default). C register f. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry Flag. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default). C register f. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Q Cycle Activity:, Rotate Left f through Carry = . Q Cycle Activity:, Rotate Left",
    "PIC18CXX2\nf through Carry = . Q Cycle Activity:, Rotate Left f through Carry = . Q Cycle Activity:, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = . Q1, Rotate Left f through Carry = Q2. Q1, Rotate Left f through Carry = Q3. Q1, Rotate Left f through Carry = Q3. Q1, Rotate Left f through Carry = Q4. , Rotate Left f through Carry = Read register 'f'. , Rotate Left f through Carry = Process Data. , Rotate Left f through Carry = Process Data. , Rotate Left f through Carry = Write to destination. Example:, Rotate Left f through Carry = RLCF. Example:, Rotate Left f through Carry = REG,. Example:, Rotate Left f through Carry = 0,. Example:, Rotate Left f through Carry = 0. Before Instruction = 1110 0110, Rotate Left f through Carry = Before Instruction = 1110 0110. Before Instruction = 1110 0110, Rotate Left f through Carry = Before Instruction = 1110",
    "PIC18CXX2\n0110. Before Instruction = 1110 0110, Rotate Left f through Carry = Before Instruction = 1110 0110. Before Instruction = 1110 0110, Rotate Left f through Carry = Before Instruction = 1110 0110. REG C After REG, Rotate Left f through Carry = = 0 Instruction = 1110. REG C After REG, Rotate Left f through Carry = 0110. REG C After REG, Rotate Left f through Carry = . REG C After REG, Rotate Left f through Carry = . WREG C, Rotate Left f through Carry = = 1100 =. WREG C, Rotate Left f through Carry = 1100. WREG C, Rotate Left f through Carry = . WREG C, Rotate Left f through Carry = . , Rotate Left f through Carry = 1. , Rotate Left f through Carry = . , Rotate Left f through Carry = . , Rotate Left f through Carry = ",
    "PIC18CXX2\nSyntax:, Rotate Left f (no carry) = [ label ] RLNCF. Syntax:, Rotate Left f (no carry) = [ label ] RLNCF. Syntax:, Rotate Left f (no carry) = f [,d [,a]. Syntax:, Rotate Left f (no carry) = f [,d [,a]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae",
    "PIC18CXX2\ndest<n+1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae dest<0>. Status Affected:, Rotate Left f (no carry) = N,Z. Status Affected:, Rotate Left f (no carry) = N,Z. Status Affected:, Rotate Left f (no carry) = N,Z. Status Affected:, Rotate Left f (no carry) = N,Z. Encoding:, Rotate Left f (no carry) = 0100. Encoding:, Rotate Left f (no carry) = 01da. Encoding:, Rotate Left f (no carry) = ffff. Encoding:, Rotate Left f (no carry) = ffff\nDescription:",
    "PIC18CXX2\nThe contents of register 'f' are rotated one bit to the left. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\n1\n1\nWords:\nCycles:\nQ Cycle Activity:",
    "Example:\nRLNCF\nREG, 1, 0\nBefore Instruction\nREG\n=\n1010 1011\nAfter Instruction\nREG\n=\n0101 0111",
    "Example:\nSyntax:, Rotate Right f through Carry = [ label ] RRCF. Syntax:, Rotate Right f through Carry = [ label ] RRCF. Syntax:, Rotate Right f through Carry = f [,d [,a]. Syntax:, Rotate Right f through Carry = f [,d [,a]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = . Operands:, Rotate Right f through Carry = . Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = . Operation:, Rotate Right f through Carry = . Status Affected:, Rotate Right f through Carry =",
    "Example:\nC,N,Z. Status Affected:, Rotate Right f through Carry = . Status Affected:, Rotate Right f through Carry = . Status Affected:, Rotate Right f through Carry = . Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff\nDescription:\nThe contents of register 'f' are rotated one bit to the right through the Carry Flag. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\n1\n1\nQ2\nRead register 'f'\nQ3\nProcess Data\nRRCF\nREG, 0, 0",
    "Before Instruction\nREG\n=\n1110 0110\nC\n=\n0\nAfter Instruction\nREG\n=\n1110 0110\nWREG\n=\n0111 0011\nC\n=\n0\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\nQ4\nWrite to destination",
    "Before Instruction\nSyntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae dest<7>.",
    "Before Instruction\nOperation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae dest<7>. Status Affected:, Rotate Right f (no carry) = N,Z. Status Affected:, Rotate Right f (no carry) = N,Z. Status Affected:, Rotate Right f (no carry) = N,Z. Status Affected:, Rotate Right f (no carry) = N,Z. Encoding:, Rotate Right f (no carry) = 0100. Encoding:, Rotate Right f (no carry) = 00da. Encoding:, Rotate Right f (no carry) = ffff. Encoding:, Rotate Right f (no carry) = ffff\nDescription:",
    "Before Instruction\nThe contents of register 'f' are rotated one bit to the right. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\n1\n1\nQ2\nQ3\nQ4\nRead\nProcess register 'f'\nData",
    "Example 1:\nRRNCF   REG, 1, 0\nBefore Instruction\nREG\n=\nAfter Instruction\nREG\n=\n1110 1011",
    "Example 2:\nRRNCF   REG, 0, 0",
    "Before Instruction\nWREG\n=\n?\nREG\n=\n1101 0111\nAfter Instruction\nWREG\n=\n1110 1011\nREG\n=\n1101 0111\nWrite to destination\n1101 0111",
    "Before Instruction\nSyntax:, Set f = [ label ] SETF f [,a]. Syntax:, Set f = [ label ] SETF f [,a]. Syntax:, Set f = [ label ] SETF f [,a]. Syntax:, Set f = [ label ] SETF f [,a]. Operands:, Set f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Set f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Set f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Set f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operation:, Set f = FFh \uf0ae f. Operation:, Set f = FFh \uf0ae f. Operation:, Set f = FFh \uf0ae f. Operation:, Set f = FFh \uf0ae f. Status Affected:, Set f = None. Status Affected:, Set f = None. Status Affected:, Set f = None. Status Affected:, Set f = None. Encoding:, Set f = 0110. Encoding:, Set f = 100a. Encoding:, Set f = ffff. Encoding:, Set f = . Description:, Set f = The contents",
    "Before Instruction\nof the specified regis- ter are set to FFh. If 'a' is 0, the Access Bank will be selected, over- riding the BSRvalue. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified regis- ter are set to FFh. If 'a' is 0, the Access Bank will be selected, over- riding the BSRvalue. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified regis- ter are set to FFh. If 'a' is 0, the Access Bank will be selected, over- riding the BSRvalue. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified regis- ter are set to FFh. If 'a' is 0, the Access Bank will be selected, over- riding the BSRvalue. If 'a' is 1, then the bank will be selected as per the BSR value",
    "Before Instruction\n(default).. Words:, Set f = 1. Words:, Set f = 1. Words:, Set f = 1. Words:, Set f = 1. Cycles:, Set f = 1. Cycles:, Set f = 1. Cycles:, Set f = 1. Cycles:, Set f = 1. Q Cycle Activity:, Set f = . Q Cycle Activity:, Set f = . Q Cycle Activity:, Set f = . Q Cycle Activity:, Set f = . Q1, Set f = Q2. Q1, Set f = Q2. Q1, Set f = Q3. Q1, Set f = Q4. Decode, Set f = Read register 'f'. Decode, Set f = Read register 'f'. Decode, Set f = Process Data. Decode, Set f = Write register 'f'. Example: SETF Before, Set f = Example: SETF Before. Example: SETF Before, Set f = Instruction =. Example: SETF Before, Set f = REG,1. Example: SETF Before, Set f = . After Instruction REG, Set f = After Instruction REG. After Instruction REG, Set f =",
    "Before Instruction\n=. After Instruction REG, Set f = 0xFF. After Instruction REG, Set f = ",
    "Enter SLEEP mode\nSyntax:\n[ label ] SLEEP\nOperands:\nNone\nOperation:\n00h \uf0ae WDT,\n0 \uf0ae WDT postscaler,\n1\n\uf0ae\nTO,\n0\n\uf0ae\nPD\nStatus Affected:\nTO, PD\nEncoding:\n0000\n0000\n0000\n0011\nDescription:\nThe power-down status bit (PD) is cleared. The time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into SLEEP mode with the oscillator stopped.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nNo\noperation\nProcess\nData\nGo to\nsleep",
    "Example:\nSLEEP",
    "Before Instruction\nTO\n=\n?\nPD\n=\n?\nAfter Instruction\nTO\n=\n1 \u2020\nPD\n=\n0\n- \u2020   If WDT causes wake-up, this bit is cleared.",
    "Before Instruction\nSyntax:, Subtract f from WREGwith borrow = [ label ] SUBFWB f [,d [,a]. Syntax:, Subtract f from WREGwith borrow = [ label ] SUBFWB f [,d [,a]. Syntax:, Subtract f from WREGwith borrow = [ label ] SUBFWB f [,d [,a]. Syntax:, Subtract f from WREGwith borrow = [ label ] SUBFWB f [,d [,a]. Syntax:, Subtract f from WREGwith borrow = [ label ] SUBFWB f [,d [,a]. Operands:, Subtract f from WREGwith borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from WREGwith borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from WREGwith borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from WREGwith borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce",
    "Before Instruction\n[0,1] a \uf0ce [0,1]. Operands:, Subtract f from WREGwith borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Subtract f from WREGwith borrow = (WREG) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from WREGwith borrow = (WREG) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from WREGwith borrow = (WREG) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from WREGwith borrow = (WREG) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from WREGwith borrow = (WREG) - (f) - (C) \uf0ae\uf020 dest. Status Affected:, Subtract f from WREGwith borrow = N,OV, C, DC, Z. Status Affected:, Subtract f from WREGwith borrow = N,OV, C, DC, Z. Status Affected:, Subtract f from WREGwith borrow = N,OV, C,",
    "Before Instruction\nDC, Z. Status Affected:, Subtract f from WREGwith borrow = N,OV, C, DC, Z. Status Affected:, Subtract f from WREGwith borrow = N,OV, C, DC, Z. Encoding:, Subtract f from WREGwith borrow = 0101. Encoding:, Subtract f from WREGwith borrow = 01da. Encoding:, Subtract f from WREGwith borrow = . Encoding:, Subtract f from WREGwith borrow = ffff. Encoding:, Subtract f from WREGwith borrow = ffff. Description:, Subtract f from WREGwith borrow = Subtract register 'f' and carry flag (borrow) from WREG(2's comple- ment method). If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default)..",
    "Before Instruction\nDescription:, Subtract f from WREGwith borrow = Subtract register 'f' and carry flag (borrow) from WREG(2's comple- ment method). If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Subtract f from WREGwith borrow = Subtract register 'f' and carry flag (borrow) from WREG(2's comple- ment method). If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Subtract f from WREGwith borrow",
    "Before Instruction\n= Subtract register 'f' and carry flag (borrow) from WREG(2's comple- ment method). If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Subtract f from WREGwith borrow = Subtract register 'f' and carry flag (borrow) from WREG(2's comple- ment method). If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Words:, Subtract f from WREGwith borrow = 1. Words:, Subtract f from",
    "Before Instruction\nWREGwith borrow = 1. Words:, Subtract f from WREGwith borrow = 1. Words:, Subtract f from WREGwith borrow = 1. Words:, Subtract f from WREGwith borrow = 1. Cycles:, Subtract f from WREGwith borrow = 1. Cycles:, Subtract f from WREGwith borrow = 1. Cycles:, Subtract f from WREGwith borrow = 1. Cycles:, Subtract f from WREGwith borrow = 1. Cycles:, Subtract f from WREGwith borrow = 1. Q Cycle Activity: Q1, Subtract f from WREGwith borrow = . Q Cycle Activity: Q1, Subtract f from WREGwith borrow = . Q Cycle Activity: Q1, Subtract f from WREGwith borrow = . Q Cycle Activity: Q1, Subtract f from WREGwith borrow = . Q Cycle Activity: Q1, Subtract f from WREGwith borrow = . , Subtract f from WREGwith borrow = SUBFWB. , Subtract f from WREGwith borrow = SUBFWB. , Subtract f",
    "Before Instruction\nfrom WREGwith borrow = . , Subtract f from WREGwith borrow = . , Subtract f from WREGwith borrow = . 1:, Subtract f from WREGwith borrow = register 'f'. 1:, Subtract f from WREGwith borrow = . 1:, Subtract f from WREGwith borrow = Data. 1:, Subtract f from WREGwith borrow = . 1:, Subtract f from WREGwith borrow = destination. Example, Subtract f from WREGwith borrow = . Example, Subtract f from WREGwith borrow = . Example, Subtract f from WREGwith borrow = REG, 1,. Example, Subtract f from WREGwith borrow = 0. Example, Subtract f from WREGwith borrow = 0. Before Instruction, Subtract f from WREGwith borrow = Before Instruction. Before Instruction, Subtract f from WREGwith borrow = Before Instruction. Before Instruction, Subtract f from WREGwith borrow = . Before Instruction, Subtract f from WREGwith borrow = . Before Instruction, Subtract f from WREGwith borrow = . REG,",
    "Before Instruction\nSubtract f from WREGwith borrow = 3. REG, Subtract f from WREGwith borrow = . REG, Subtract f from WREGwith borrow = . REG, Subtract f from WREGwith borrow = . REG, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = 2. WREG, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = 1. C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . After Instruction, Subtract f from WREGwith borrow = . After Instruction, Subtract f from WREGwith borrow = . After Instruction, Subtract f from WREGwith borrow = . After Instruction, Subtract f from WREGwith",
    "Before Instruction\nborrow = . After Instruction, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = 2 0. WREG, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . Z, Subtract f from WREGwith borrow = 0. Z, Subtract f from WREGwith borrow = . Z, Subtract f from WREGwith borrow = . Z, Subtract f from WREGwith borrow = . Z, Subtract f from WREGwith borrow = . N, Subtract f from WREGwith borrow = 1. N, Subtract f from WREGwith borrow = ; result. N, Subtract",
    "Before Instruction\nf from WREGwith borrow = . N, Subtract f from WREGwith borrow = is negative. N, Subtract f from WREGwith borrow = is negative. Example 2:, Subtract f from WREGwith borrow = SUBFWB. Example 2:, Subtract f from WREGwith borrow = REG,. Example 2:, Subtract f from WREGwith borrow = 0,. Example 2:, Subtract f from WREGwith borrow = 0. Example 2:, Subtract f from WREGwith borrow = 0. Before Instruction, Subtract f from WREGwith borrow = . Before Instruction, Subtract f from WREGwith borrow = . Before Instruction, Subtract f from WREGwith borrow = . Before Instruction, Subtract f from WREGwith borrow = . Before Instruction, Subtract f from WREGwith borrow = . REG, Subtract f from WREGwith borrow = 2. REG, Subtract f from WREGwith borrow = . REG, Subtract f from WREGwith borrow = . REG, Subtract f from WREGwith borrow = . REG, Subtract f from",
    "Before Instruction\nWREGwith borrow = . WREG After Instruction, Subtract f from WREGwith borrow = 5. WREG After Instruction, Subtract f from WREGwith borrow = . WREG After Instruction, Subtract f from WREGwith borrow = . WREG After Instruction, Subtract f from WREGwith borrow = . WREG After Instruction, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = 1. C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = 1. C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . Z, Subtract f from WREGwith borrow = . Z, Subtract f from WREGwith borrow = . Z, Subtract f from",
    "Before Instruction\nWREGwith borrow = . Z, Subtract f from WREGwith borrow = . Z, Subtract f from WREGwith borrow = . N, Subtract f from WREGwith borrow = 0 0. N, Subtract f from WREGwith borrow = ; result. N, Subtract f from WREGwith borrow = . N, Subtract f from WREGwith borrow = is positive. N, Subtract f from WREGwith borrow = is positive. , Subtract f from WREGwith borrow = . , Subtract f from WREGwith borrow = REG,. , Subtract f from WREGwith borrow = 1,. , Subtract f from WREGwith borrow = 0. , Subtract f from WREGwith borrow = 0. Example 3: SUBFWB Before Instruction, Subtract f from WREGwith borrow = Example 3: SUBFWB Before Instruction. Example 3: SUBFWB Before Instruction, Subtract f from WREGwith borrow = Example 3: SUBFWB Before Instruction. Example 3: SUBFWB Before Instruction, Subtract f from WREGwith borrow = . Example",
    "Before Instruction\n3: SUBFWB Before Instruction, Subtract f from WREGwith borrow = . Example 3: SUBFWB Before Instruction, Subtract f from WREGwith borrow = . REG, Subtract f from WREGwith borrow = 1. REG, Subtract f from WREGwith borrow = . REG, Subtract f from WREGwith borrow = . REG, Subtract f from WREGwith borrow = . REG, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = 2. WREG, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = . WREG, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = 0. C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . After Instruction, Subtract f from",
    "Before Instruction\nWREGwith borrow = 0. After Instruction, Subtract f from WREGwith borrow = . After Instruction, Subtract f from WREGwith borrow = . After Instruction, Subtract f from WREGwith borrow = . After Instruction, Subtract f from WREGwith borrow = . REG WREG, Subtract f from WREGwith borrow = 2. REG WREG, Subtract f from WREGwith borrow = . REG WREG, Subtract f from WREGwith borrow = . REG WREG, Subtract f from WREGwith borrow = . REG WREG, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = 1. C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . C, Subtract f from WREGwith borrow = . Z, Subtract f from WREGwith borrow = 1. Z, Subtract f from WREGwith borrow = . Z, Subtract f from WREGwith borrow = . Z, Subtract f from",
    "Before Instruction\nWREGwith borrow = is. Z, Subtract f from WREGwith borrow = . N, Subtract f from WREGwith borrow = 0. N, Subtract f from WREGwith borrow = ;. N, Subtract f from WREGwith borrow = result. N, Subtract f from WREGwith borrow = zero. N, Subtract f from WREGwith borrow = zero",
    "SUBLW\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "Subtract WREG from literal\n[ label ] SUBLW   k\n0 \uf0a3\uf020 k \uf0a3\uf020 255\nk - (WREG) \uf0ae\uf020 WREG\nN,OV, C, DC, Z\n0000\n1000\nkkkk kkkk\nWREG is subtracted from the eight-bit literal 'k'. The result is placed in WREG.\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read literal 'k'. Decode, Q3 = Process Data. Decode, Q4 = Write to WREG",
    "Example 1:\nSUBLW\n0x02",
    "Before Instruction\nWREG\n=\n1\nC\n=\n?",
    "After Instruction\n1      ; result is positive",
    "Example 2:\nSUBLW",
    "Before Instruction\nWREG\n=\nC\n=",
    "After Instruction\nWREG\n=\nC\nZ\nN\n=\n=\n=\n0x02\n2\n?\n0\n1      ; result is zero\n1\n0",
    "Example 3:\nSUBLW",
    "Before Instruction\nWREG\n=\n3\nC\n=\n?",
    "After Instruction\nWREG\n=\nFF   ; (2's complement)\nC\n=\n0    ; result is negative\nZ\n=\n0\nN\n=\n1\n0x02",
    "After Instruction\nSyntax:, Subtract WREG from f = [ label ] SUBWF. Syntax:, Subtract WREG from f = [ label ] SUBWF. Syntax:, Subtract WREG from f = f [,d [,a]. Syntax:, Subtract WREG from f = f [,d [,a]. Operands:, Subtract WREG from f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1]. Operands:, Subtract WREG from f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1]. Operands:, Subtract WREG from f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1]. Operands:, Subtract WREG from f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1]. Operation:, Subtract WREG from f = (f) - (WREG) \uf0ae\uf020 dest. Operation:, Subtract WREG from f = (f) - (WREG) \uf0ae\uf020 dest. Operation:, Subtract WREG from f = (f) - (WREG) \uf0ae\uf020 dest. Operation:, Subtract WREG from f = (f) - (WREG) \uf0ae\uf020 dest. Status",
    "After Instruction\nAffected:, Subtract WREG from f = N,OV, C, DC, Z. Status Affected:, Subtract WREG from f = N,OV, C, DC, Z. Status Affected:, Subtract WREG from f = N,OV, C, DC, Z. Status Affected:, Subtract WREG from f = N,OV, C, DC, Z. Encoding:, Subtract WREG from f = 0101. Encoding:, Subtract WREG from f = 11da. Encoding:, Subtract WREG from f = ffff. Encoding:, Subtract WREG from f = ffff\nDescription:\nSubtract WREG from register 'f' (2's complement method). If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1",
    "After Instruction\nQ Cycle Activity:",
    "After Instruction\nExample 1: SUBWF, Q2.Read register 'f' = Example 1: SUBWF. Example 1: SUBWF, Q3.Process Data = REG, 1, 0. Example 1: SUBWF, Q4 to.Write destination = REG, 1, 0. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3.Process Data = . Before Instruction, Q4 to.Write destination = . REG, Q2.Read register 'f' = = 3. REG, Q3.Process Data = . REG, Q4 to.Write destination = . WREG, Q2.Read register 'f' = = 2. WREG, Q3.Process Data = . WREG, Q4 to.Write destination = . C, Q2.Read register 'f' = = ?. C, Q3.Process Data = . C, Q4 to.Write destination = . After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3.Process Data = . After Instruction, Q4 to.Write destination = . REG, Q2.Read register 'f' = = 1. REG,",
    "After Instruction\nQ3.Process Data = . REG, Q4 to.Write destination = . WREG, Q2.Read register 'f' = = 2. WREG, Q3.Process Data = . WREG, Q4 to.Write destination = . C, Q2.Read register 'f' = = 1. C, Q3.Process Data = ; result is. C, Q4 to.Write destination = positive. Z, Q2.Read register 'f' = = 0. Z, Q3.Process Data = . Z, Q4 to.Write destination = . N, Q2.Read register 'f' = = 0. N, Q3.Process Data = . N, Q4 to.Write destination = . Example 2: SUBWF, Q2.Read register 'f' = Example 2: SUBWF. Example 2: SUBWF, Q3.Process Data = REG, 0, 0. Example 2: SUBWF, Q4 to.Write destination = REG, 0, 0. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3.Process Data = . Before Instruction, Q4 to.Write destination = .",
    "After Instruction\nREG, Q2.Read register 'f' = = 2. REG, Q3.Process Data = . REG, Q4 to.Write destination = . WREG, Q2.Read register 'f' = = 2. WREG, Q3.Process Data = . WREG, Q4 to.Write destination = . C, Q2.Read register 'f' = = ?. C, Q3.Process Data = . C, Q4 to.Write destination = . After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3.Process Data = . After Instruction, Q4 to.Write destination = . REG, Q2.Read register 'f' = = 2. REG, Q3.Process Data = . REG, Q4 to.Write destination = . WREG, Q2.Read register 'f' = = 0. WREG, Q3.Process Data = . WREG, Q4 to.Write destination = . C, Q2.Read register 'f' = = 1. C, Q3.Process Data = ; result is. C, Q4 to.Write destination = zero. Z, Q2.Read register 'f'",
    "After Instruction\n= = 1. Z, Q3.Process Data = . Z, Q4 to.Write destination = . N, Q2.Read register 'f' = = 0. N, Q3.Process Data = . N, Q4 to.Write destination = . Example 3: SUBWF, Q2.Read register 'f' = Example 3: SUBWF. Example 3: SUBWF, Q3.Process Data = REG, 1, 0. Example 3: SUBWF, Q4 to.Write destination = REG, 1, 0. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3.Process Data = . Before Instruction, Q4 to.Write destination = . REG, Q2.Read register 'f' = = 1. REG, Q3.Process Data = . REG, Q4 to.Write destination = . WREG, Q2.Read register 'f' = = 2. WREG, Q3.Process Data = . WREG, Q4 to.Write destination = . C, Q2.Read register 'f' = = ?. C, Q3.Process Data = . C, Q4 to.Write destination",
    "After Instruction\n= . After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3.Process Data = . After Instruction, Q4 to.Write destination = . REG, Q2.Read register 'f' = = FFh. REG, Q3.Process Data = ;(2's. REG, Q4 to.Write destination = complement). WREG, Q2.Read register 'f' = = 2. WREG, Q3.Process Data = . WREG, Q4 to.Write destination = . C, Q2.Read register 'f' = =. C, Q3.Process Data = 0. C, Q4 to.Write destination = ; result is negative. Z N, Q2.Read register 'f' = = 0 =. Z N, Q3.Process Data = . Z N, Q4 to.Write destination = ",
    "Subtract WREG from f with Borrow\nSyntax:\n[ label ] SUBWFB    f [,d [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n(f) - (WREG) - (C) \uf0ae\uf020 dest\nStatus Affected:\nN,OV, C, DC, Z\nEncoding:\n0101\n10da\nffff\nffff\nDescription:\nSubtract WREG and the carry flag (borrow) from register 'f' (2's complement method). If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\n1\n1\nQ2\nRead\nQ3\nProcess register 'f'\nData",
    "Example 1:\nSUBWFB  REG, 1, 0",
    "Before Instruction\nREG\n=\nWREG\n=\nC\n=",
    "After Instruction\nREG\n=\nWREG\nC\nZ\nN\n=\n=\n=\n=\n0x19   (0001 1001)\n0x0D   (0000 1101)\n1\n0x0C   (0000 1011)\n0x0D   (0000 1101)\n1\n0\n0\n; result is positive",
    "Example 2:\nSUBWFB",
    "Before Instruction\nREG\n=\nWREG\n=\nC\n=\nREG, 0, 0\n0x1B    (0001 1011)\n0x1A    (0001 1010)\n0",
    "After Instruction\nREG\n=\n0x1B\n(0001 1011)\nWREG\n=\n0x00\nC\n=\n1\nZ\n=\n1     ; result is zero\nN\n=\n0",
    "Example 3:\nSUBWFB  REG, 1, 0",
    "Before Instruction\nREG\n=\n0x03\n(0000 0011)\nWREG\n=\n0x0E\n(0000 1101)\nC\n=\n1",
    "After Instruction\nREG\n=\nWREG\nC\nZ\nN\n=\n=\n=\n=\n0xF5\n(1111 0100)\n; [2's comp]\n0x0E\n(0000 1101)\n0\n0\n1     ; result is negative\nQ4\nWrite to destination",
    "After Instruction\nSyntax:, Swap f = [ label ] SWAPF. Syntax:, Swap f = [ label ] SWAPF. Syntax:, Swap f = f [,d [,a]. Syntax:, Swap f = f [,d [,a]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae",
    "After Instruction\ndest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Encoding:, Swap f = 0011. Encoding:, Swap f = 10da. Encoding:, Swap f = ffff. Encoding:, Swap f = ffff\nDescription:\nThe upper and lower nibbles of register 'f' are exchanged. If 'd' is 0, the result is placed in WREG. If 'd' is 1, the result is placed in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "Example:\nSWAPF\nREG, 1, 0\nBefore Instruction\nREG\n=\n0x53\nAfter Instruction\nREG\n=\n0x35",
    "Example:\nSyntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) +1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) -1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) +1 \uf0ae TBLPTR; (Prog",
    "Example:\nMem (TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) +1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) -1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) +1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) +1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) -1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) +1 \uf0ae",
    "Example:\nTBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) +1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) -1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) +1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Encoding:, Table Read = 0000. Encoding:, Table Read = 0000. Encoding:, Table Read = 0000. Encoding:, Table Read = . Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer",
    "Example:\n(TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer",
    "Example:\n(TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Cycles:, Table Read",
    "Example:\n= 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q1, Table Read = Q2. Q1, Table Read = Q3. Q1, Table Read = Q4. Q1, Table Read = . Decode, Table Read = No operation. Decode, Table Read = No operation. Decode, Table Read = No operation. Decode, Table Read = . No operation, Table Read = No operation (Read Program Memory). No operation, Table Read = No operation. No operation, Table Read = No operation (Write TABLAT). No operation, Table Read = ",
    "TBLRD Table Read (cont'd)\nExample 1:, 1 = TBLRD. Example 1:, 2 = ;. Example 1:, 3 = . Before Instruction, 1 = . Before Instruction, 2 = . Before Instruction, 3 = . TABLAT, 1 = TABLAT. TABLAT, 2 = =. TABLAT, 3 = 0x55. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 0x00A356. MEMORY(0x00A356), 1 = MEMORY(0x00A356). MEMORY(0x00A356), 2 = =. MEMORY(0x00A356), 3 = 0x34. After Instruction, 1 = . After Instruction, 2 = . After Instruction, 3 = . TABLAT, 1 = TABLAT. TABLAT, 2 = =. TABLAT, 3 = 0x34. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 0x00A357. Example 2:, 1 = TBLRD +*. Example 2:, 2 = ;. Example",
    "TBLRD Table Read (cont'd)\n2:, 3 = . Before Instruction, 1 = . Before Instruction, 2 = . Before Instruction, 3 = . TABLAT, 1 = TABLAT. TABLAT, 2 = =. TABLAT, 3 = 0xAA. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 0x01A357. MEMORY(0x01A357), 1 = MEMORY(0x01A357). MEMORY(0x01A357), 2 = =. MEMORY(0x01A357), 3 = 0x12. MEMORY(0x01A358), 1 = MEMORY(0x01A358). MEMORY(0x01A358), 2 = =. MEMORY(0x01A358), 3 = 0x34. After Instruction, 1 = . After Instruction, 2 = . After Instruction, 3 = . TABLAT, 1 = TABLAT. TABLAT, 2 = =. TABLAT, 3 = 0x34. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =.",
    "TBLRD Table Read (cont'd)\nTBLPTR, 3 = 0x01A358",
    "PIC18CXX2\nSyntax:, Table Write = [ label ] TBLWT ( *; *+; *-; +*). Operands:, Table Write = None. Operation:, Table Write = if TBLWT*, (TABLAT) \uf0ae Prog Mem(TBLPTR) or Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \uf0ae Prog Mem(TBLPTR) or Holding Register; (TBLPTR) +1 \uf0ae TBLPTR; if TBLWT*-, (TABLAT) \uf0ae Prog Mem(TBLPTR) or Holding Register; (TBLPTR) -1 \uf0ae TBLPTR; if TBLWT+*, (TBLPTR) +1 \uf0ae TBLPTR; (TABLAT) \uf0ae Prog Mem(TBLPTR) or Holding Register;\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "None\n0000, 1 = 0000. 0000, 2 = 0000. 0000, 3 = 11nn nn=0 * =1 *+\nThis instruction is used to program the contents of Program Memory (P.M.). The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 Mbyte address range. The LSb of the TBLPTR selects which byte of the program memory location to access.\nTBLPTR[0] = 0:Least Significant Byte of Program Memory Word\nTBLPTR[0] = 1:Most Significant Byte of Program Memory Word\nThe TBLWT instruction can modify the value of TBLPTR as follows:\n\u00b7 no change\n\u00b7 post-increment\n\u00b7 post-decrement\n\u00b7 pre-increment\n1\n2 (many if long write is to on-chip EPROM program memory)",
    "Q Cycle Activity:\nDecode, Q2 = No operation. Decode, Q3 = No operation. Decode, Q4 = No operation. No operation, Q2 = No operation (Read TABLAT). No operation, Q3 = No operation. No operation, Q4 = No operation (Write to Holding Register or Memory)",
    "Q Cycle Activity:\nExample 1:, Table Write = TBLWT. Example 1:, Table Write = *+;. Example 1:, (Continued) = . Before Instruction, Table Write = Before Instruction. Before Instruction, Table Write = . Before Instruction, (Continued) = . TABLAT, Table Write = . TABLAT, Table Write = =. TABLAT, (Continued) = 0x55. TBLPTR, Table Write = . TBLPTR, Table Write = =. TBLPTR, (Continued) = 0x00A356. MEMORY(0x00A356), Table Write = . MEMORY(0x00A356), Table Write = =. MEMORY(0x00A356), (Continued) = 0xFF. After Instructions (table write completion), Table Write = After Instructions (table write completion). After Instructions (table write completion), Table Write = After Instructions (table write completion). After Instructions (table write completion), (Continued) = After Instructions (table write completion). TABLAT, Table Write = . TABLAT, Table Write = =. TABLAT, (Continued) = 0x55. TBLPTR, Table Write = .",
    "Q Cycle Activity:\nTBLPTR, Table Write = =. TBLPTR, (Continued) = 0x00A357. MEMORY(0x00A356), Table Write = . MEMORY(0x00A356), Table Write = =. MEMORY(0x00A356), (Continued) = 0x55. Example 2:, Table Write = TBLWT. Example 2:, Table Write = +*;. Example 2:, (Continued) = . Before Instruction, Table Write = Before Instruction. Before Instruction, Table Write = . Before Instruction, (Continued) = . TABLAT, Table Write = . TABLAT, Table Write = =. TABLAT, (Continued) = 0x34. TBLPTR, Table Write = . TBLPTR, Table Write = =. TBLPTR, (Continued) = 0x01389A. MEMORY(0x01389A), Table Write = . MEMORY(0x01389A), Table Write = =. MEMORY(0x01389A), (Continued) = 0xFF. MEMORY(0x01389B), Table Write = .",
    "Q Cycle Activity:\nMEMORY(0x01389B), Table Write = =. MEMORY(0x01389B), (Continued) = 0xFF. After Instruction (table write completion), Table Write = After Instruction (table write completion). After Instruction (table write completion), Table Write = After Instruction (table write completion). After Instruction (table write completion), (Continued) = After Instruction (table write completion). TABLAT, Table Write = . TABLAT, Table Write = =. TABLAT, (Continued) = 0x34. TBLPTR, Table Write = . TBLPTR, Table Write = =. TBLPTR, (Continued) = 0x01389B. MEMORY(0x01389A), Table Write = . MEMORY(0x01389A), Table Write = =. MEMORY(0x01389A), (Continued) = 0xFF. MEMORY(0x01389B), Table Write = . MEMORY(0x01389B), Table Write = =. MEMORY(0x01389B), (Continued) = 0x34",
    "Q Cycle Activity:\nSyntax:, Test f, skip if 0 = [ label ] TSTFSZ. Syntax:, Test f, skip if 0 = [ label ] TSTFSZ. Syntax:, Test f, skip if 0 = f [,a]. Syntax:, Test f, skip if 0 = f [,a]. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 \uf0ce. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 \uf0ce. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 \uf0ce. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 \uf0ce. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Encoding:, Test f, skip if 0 =",
    "Q Cycle Activity:\n0110. Encoding:, Test f, skip if 0 = 011a. Encoding:, Test f, skip if 0 = ffff. Encoding:, Test f, skip if 0 = ffff\nDescription:\nIf 'f' = 0, the next instruction, fetched during the current instruction execution, is discarded and a NOP is executed, making this a twocycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\nQ1\nDecode\nIf skip:\nQ1\nNo\n1\n1(2)\nNote: 3 cycles if skip and followed by a 2-word instruction.\nQ2\nQ3\nQ4\nRead register 'f'\nQ2\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation\nQ4\nNo operation\nQ4\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:",
    "Q Cycle Activity:\nHERE    TSTFSZ  CNT, 1\nNZERO    :\nZERO   :",
    "Before Instruction\nPC = Address(HERE)\nAfter Instruction\nIf CNT\n= 0x00,\nPC\n= Address (ZERO)\nIf CNT\n\uf0b9\n0x00,\nPC\n=\nAddress (NZERO)",
    "PIC18CXX2\nSyntax:, Exclusive OR literal with WREG = [ label ] XORLW k. Syntax:, Exclusive OR literal with WREG = [ label ] XORLW k. Syntax:, Exclusive OR literal with WREG = [ label ] XORLW k. Syntax:, Exclusive OR literal with WREG = [ label ] XORLW k. Operands:, Exclusive OR literal with WREG = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR literal with WREG = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR literal with WREG = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR literal with WREG = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operation:, Exclusive OR literal with WREG = (WREG) .XOR. k \uf0ae\uf020 WREG. Operation:, Exclusive OR literal with WREG = (WREG) .XOR. k \uf0ae\uf020 WREG. Operation:, Exclusive OR literal with WREG = (WREG) .XOR. k \uf0ae\uf020 WREG. Operation:, Exclusive OR literal with WREG = (WREG) .XOR. k \uf0ae\uf020 WREG. Status Affected:, Exclusive OR literal with WREG = N,Z. Status Affected:, Exclusive OR literal with WREG =",
    "PIC18CXX2\nN,Z. Status Affected:, Exclusive OR literal with WREG = N,Z. Status Affected:, Exclusive OR literal with WREG = N,Z. Encoding:, Exclusive OR literal with WREG = 0000. Encoding:, Exclusive OR literal with WREG = 1010. Encoding:, Exclusive OR literal with WREG = kkkk. Encoding:, Exclusive OR literal with WREG = kkkk. Description:, Exclusive OR literal with WREG = The contents of WREG are XORed with the 8-bit literal 'k'. The result is placed in WREG.. Description:, Exclusive OR literal with WREG = The contents of WREG are XORed with the 8-bit literal 'k'. The result is placed in WREG.. Description:, Exclusive OR literal with WREG = The contents of WREG are XORed with the 8-bit literal 'k'. The result is placed in WREG.. Description:, Exclusive OR literal with WREG = The contents of WREG are XORed with the 8-bit literal 'k'. The result is placed in WREG.. Words:, Exclusive OR literal with WREG = 1. Words:,",
    "PIC18CXX2\nExclusive OR literal with WREG = 1. Words:, Exclusive OR literal with WREG = 1. Words:, Exclusive OR literal with WREG = 1. Cycles:, Exclusive OR literal with WREG = 1. Cycles:, Exclusive OR literal with WREG = 1. Cycles:, Exclusive OR literal with WREG = 1. Cycles:, Exclusive OR literal with WREG = 1. Q Cycle Activity: Q1, Exclusive OR literal with WREG = Q2. Q Cycle Activity: Q1, Exclusive OR literal with WREG = Q3. Q Cycle Activity: Q1, Exclusive OR literal with WREG = . Q Cycle Activity: Q1, Exclusive OR literal with WREG = Q4. Decode, Exclusive OR literal with WREG = Read literal 'k'. Decode, Exclusive OR literal with WREG = Process Data. Decode, Exclusive OR literal with WREG = . Decode, Exclusive OR literal with WREG = Write to WREG",
    "Before Instruction\nWREG\n=\n0xB5\nAfter Instruction\nWREG\n=\n0x1A",
    "PIC18CXX2\nXORWF",
    "Exclusive OR WREG with f\nSyntax:\n[\nlabel\n]\nXORWF     f [,d [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n(WREG) .XOR. (f) \uf0ae\uf020 dest\nStatus Affected:\nN,Z\nEncoding:\n0001\n10da\nffff\nffff\nDescription:\nExclusive OR the contents of WREG with register 'f'. If 'd' is 0, the result is stored in WREG. If 'd' is 1, the result is stored back in the reg- ister 'f' (default).   If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite to\ndestination",
    "Example:\nXORWF   REG, 1, 0",
    "Before Instruction\nREG\n=\n0xAF\nWREG\n=\n0xB5",
    "After Instruction\nREG\n=\n0x1A\nWREG\n=\n0xB5",
    "20.0 DEVELOPMENT SUPPORT\nThe  PIC \u00ae   microcontrollers  are  supported  with  a  full range of hardware and software development tools:\n\u00b7 Integrated Development Environment\n-MPLAB \u00ae  IDE Software\n\u00b7 Assemblers/Compilers/Linkers\n-MPASM TM  Assembler\n-MPLAB C17 and MPLAB C18 C Compilers\n-MPLINK TM  Object Linker/ MPLIB TM  Object Librarian\n\u00b7 Simulators\n-MPLAB SIM Software Simulator\n\u00b7 Emulators\n-MPLAB ICE 2000 In-Circuit Emulator\n-ICEPIC\u2122 In-Circuit Emulator\n\u00b7 In-Circuit Debugger\n-MPLAB ICD for PIC16F87X\n\u00b7 Device Programmers\n-PRO MATE \u00ae  II Universal Device Programmer\n-PICSTART \u00ae  Plus Entry-Level Development Programmer\n\u00b7 Low Cost Demonstration Boards\n-PICDEM TM  1 Demonstration Board\n-PICDEM 2 Demonstration Board\n-PICDEM   3 Demonstration Board\n-PICDEM   17 Demonstration Board\n-KEELOQ \u00ae  Demonstration Board",
    "20.1 MPLAB Integrated Development Environment Software\nThe MPLAB IDE software brings an ease of software development previously unseen in the 8-bit microcontroller market. The MPLAB IDE is a Windows \u00ae -based application that contains:\n\u00b7 An interface to debugging tools\n-simulator\n-programmer (sold separately)\n-emulator (sold separately)\n-in-circuit debugger (sold separately)\n\u00b7 A full-featured editor\n\u00b7 A project manager\n\u00b7 Customizable toolbar and key mapping\n\u00b7 A status bar\n\u00b7 On-line help\nThe MPLAB IDE allows you to:\n\u00b7 Edit your source files (either assembly or 'C')\n\u00b7 One touch assemble (or compile) and download to PIC MCU emulator and simulator tools (automatically updates all project information)\n\u00b7 Debug using:\n-source files\n-absolute listing file\n-machine code\nThe ability to use MPLAB IDE with multiple debugging tools  allows  users  to  easily  switch  from  the  costeffective  simulator  to  a  full-featured  emulator  with minimal retraining.",
    "20.2 MPASM Assembler\nThe  MPASM  assembler  is  a  full-featured  universal macro assembler for all PIC MCUs.\nThe MPASM assembler has a command line interface and a Windows shell. It can be used as a stand-alone application on a Windows 3.x or greater system, or it can be used through MPLAB IDE. The MPASM assembler generates relocatable object files for the MPLINK object  linker,  Intel \u00ae   standard  HEX  files,  MAP  files  to detail memory usage and symbol reference, an absolute LST file that contains source lines and generated machine code, and a COD file for debugging.\nThe MPASM assembler features include:\n\u00b7 Integration into MPLAB IDE projects.\n\u00b7 User-defined macros to streamline assembly code.\n\u00b7 Conditional assembly for multi-purpose source files.\n\u00b7 Directives that allow complete control over the assembly process.",
    "20.3 MPLAB C17 and MPLAB C18 C Compilers\nThe MPLAB C17 and MPLAB C18 Code Development Systems are complete ANSI 'C' compilers for Microchip's  PIC17CXXX  and  PIC18CXXX  family  of microcontrollers, respectively. These compilers provide powerful  integration capabilities  and  ease  of  use  not found with other compilers.\nFor easier source level debugging, the compilers provide  symbol  information  that  is  compatible  with  the MPLAB IDE memory display.",
    "20.4 MPLINK Object Linker/ MPLIB Object Librarian\nThe MPLINK object linker combines relocatable objects  created  by  the  MPASM  assembler  and  the MPLAB C17 and MPLAB C18 C compilers. It can also link  relocatable  objects  from  pre-compiled  libraries, using directives from a linker script.\nThe  MPLIB  object  librarian  is  a  librarian  for  precompiled  code  to  be  used  with  the  MPLINK  object linker.  When  a  routine  from  a  library  is  called  from another source file, only the modules that contain that routine will be linked in with the application. This allows large libraries to  be used efficiently in many different applications. The MPLIB object librarian manages the creation and modification of library files.\nThe MPLINK object linker features include:\n\u00b7 Integration with MPASM assembler and MPLAB C17 and MPLAB C18 C compilers.\n\u00b7 Allows all memory areas to be defined as sections to provide link-time flexibility.\nThe MPLIB object librarian features include:\n\u00b7 Easier linking because single libraries can be included instead of many smaller files.\n\u00b7 Helps keep code maintainable by grouping related modules together.\n\u00b7 Allows libraries to be created and modules to be added, listed, replaced, deleted or extracted.",
    "20.5 MPLAB SIM Software Simulator\nThe MPLAB SIM software simulator allows code development in a PC-hosted environment by simulating the PIC series microcontrollers on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a file, or user-defined key press, to any of the pins. The execution  can  be  performed  in  single  step,  execute  until break, or trace mode.\nThe MPLAB SIM simulator fully supports symbolic debugging using the MPLAB C17 and the MPLAB C18 C compilers and the MPASM assembler. The software simulator offers the flexibility to develop and debug code outside of the laboratory environment, making it an excellent multiproject software development tool.",
    "20.6 MPLAB ICE High Performance Universal In-Circuit Emulator with MPLAB IDE\nThe MPLAB ICE universal in-circuit emulator is intended to  provide  the  product  development  engineer  with  a complete microcontroller design tool set for PIC microcontrollers (MCUs). Software control of the MPLAB ICE in-circuit emulator is provided by the MPLAB Integrated Development Environment (IDE), which allows editing, building,  downloading  and  source  debugging  from  a single environment.\nThe MPLAB ICE 2000 is a full-featured emulator system with enhanced trace, trigger and data monitoring features. Interchangeable processor modules allow the system to be easily reconfigured for emulation of different processors.  The  universal  architecture of the MPLAB  ICE  in-circuit  emulator  allows  expansion  to support new PIC microcontrollers.\nThe MPLAB ICE in-circuit emulator system has been designed as a real-time emulation system, with advanced features that are  generally  found  on  more expensive  development  tools.  The  PC  platform  and Microsoft \u00ae  Windows environment were chosen to best make these features available to you, the end user.",
    "20.7 ICEPIC In-Circuit Emulator\nThe ICEPIC low cost, in-circuit emulator is a solution for  the  Microchip  Technology  PIC16C5X,  PIC16C6X, PIC16C7X  and  PIC16CXXX  families  of  8-bit  OneTime-Programmable (OTP) microcontrollers. The modular system can support different subsets of PIC16C5X or  PIC16CXXX  products  through  the  use  of  interchangeable personality modules, or daughter boards. The  emulator  is  capable  of  emulating  without  target application circuitry being present.",
    "20.8 MPLAB ICD In-Circuit Debugger\nMicrochip's In-Circuit Debugger, MPLAB ICD, is a powerful, low cost, run-time development tool. This tool is based on the FLASH PIC16F87X and can be used to develop for this and other PIC microcontrollers from the PIC16CXXX family. The MPLAB ICD utilizes the in-circuit debugging capability built into the PIC16F87X. This feature, along with Microchip's          In-Circuit Serial Programming TM  protocol, offers cost-effective in-circuit FLASH debugging from the graphical user interface of the MPLAB Integrated Development Environment. This enables a designer to develop and debug source code by  watching  variables,  single-stepping  and  setting break  points.  Running  at  full  speed  enables  testing hardware in real-time.",
    "20.9 PRO MATE II Universal Device Programmer\nThe PRO MATE II universal device programmer is a full-featured programmer,  capable of operating in stand-alone mode, as well as PC-hosted mode. The PRO MATE II device programmer is CE compliant.\nThe PRO MATE II device programmer has programmable VDD and VPP supplies, which allow it to verify programmed memory at VDD min and VDD max for maximum reliability. It has an LCD display for instructions and error messages, keys to enter commands and a modular detachable socket assembly to support various package types. In stand-alone mode, the PRO MATE II device  programmer  can  read,  verify,  or  program  PIC devices. It can also set code protection in this mode.",
    "20.10 PICSTART Plus Entry Level Development Programmer\nThe PICSTART Plus development programmer is an easy-to-use,  low  cost,  prototype  programmer.  It  connects  to  the  PC  via  a  COM  (RS-232)  port.  MPLAB Integrated Development Environment software makes using the programmer simple and efficient.\nThe  PICSTART  Plus  development  programmer  supports  all  PIC  devices  with  up  to  40  pins.  Larger  pin count devices, such as the PIC16C92X and PIC17C76X, may be supported with an adapter socket. The PICSTART Plus development programmer is CE compliant.",
    "20.11 PICDEM 1 Low Cost PIC MCU Demonstration Board\nThe PICDEM 1 demonstration board is a simple board which  demonstrates  the  capabilities  of  several  of Microchip's microcontrollers. The microcontrollers supported  are:  PIC16C5X  (PIC16C54  to  PIC16C58A), PIC16C61, PIC16C62X, PIC16C71, PIC16C8X, PIC17C42,  PIC17C43  and  PIC17C44.  All  necessary hardware and software is included to run basic demo programs. The user can program the sample microcontrollers  provided  with  the  PICDEM  1  demonstration board  on  a  PRO MATE  II  device  programmer,  or  a PICSTART Plus development programmer, and easily test firmware. The user can also connect the PICDEM 1 demonstration board to the MPLAB ICE incircuit emulator and download the firmware to the emulator for testing. A prototype area is available for the user to build some additional hardware and connect it to the microcontroller socket(s). Some of the features include an RS-232 interface, a potentiometer for simulated  analog  input,  push  button  switches  and",
    "20.11 PICDEM 1 Low Cost PIC MCU Demonstration Board\neight LEDs connected to PORTB.",
    "20.12 PICDEM 2 Low Cost PIC16CXX Demonstration Board\nThe PICDEM 2 demonstration board is a simple demonstration board that supports the PIC16C62, PIC16C64, PIC16C65, PIC16C73 and PIC16C74 microcontrollers. All the necessary hardware and software is included to run the basic demonstration programs. The user can program the sample microcontrollers provided with the PICDEM 2 demonstration board on a PRO MATE II device programmer, or  a  PICSTART  Plus  development  programmer,  and easily test firmware. The MPLAB ICE in-circuit emulator may also be used with the PICDEM 2 demonstration board to test firmware. A prototype area has been provided to the user for adding additional hardware and connecting it to the microcontroller socket(s). Some of the features include a RS-232 interface, push button switches, a potentiometer for simulated analog input, a serial EEPROM to demonstrate usage of the I 2 C TM  bus and  separate  headers  for  connection  to  an  LCD module and a keypad.",
    "20.13 PICDEM 3 Low Cost PIC16CXXX Demonstration Board\nThe PICDEM 3 demonstration board is a simple demonstration  board  that  supports  the  PIC16C923  and PIC16C924 in the PLCC package. It will also support future 44-pin PLCC microcontrollers with an LCD Module. All the necessary  hardware  and  software  is included to run the basic demonstration programs. The user  can  program  the  sample  microcontrollers  provided  with  the  PICDEM  3  demonstration  board  on  a PRO MATE II device programmer, or a PICSTART Plus development programmer with an adapter socket, and easily test firmware. The MPLAB ICE in-circuit emulator may also be used with the PICDEM 3 demonstration board to test firmware. A prototype area has been provided to the user for adding hardware and connecting it to the microcontroller socket(s). Some of the features include  a  RS-232  interface,  push  button  switches,  a potentiometer for simulated analog input, a thermistor and  separate  headers  for  connection  to  an  external LCD  module  and  a  keypad.  Also  provided  on  the PICDEM 3 demonstration board is a LCD panel, with 4 commons and 12 segments, that is capable of displaying  time,",
    "20.13 PICDEM 3 Low Cost PIC16CXXX Demonstration Board\ntemperature  and  day  of  the  week.  The PICDEM 3 demonstration board provides an additional RS-232 interface and Windows software for showing the demultiplexed LCD signals on a PC. A simple serial interface  allows  the  user  to  construct  a  hardware demultiplexer for the LCD signals.",
    "20.14 PICDEM 17 Demonstration Board\nThe PICDEM 17 demonstration board is an evaluation board  that  demonstrates  the  capabilities  of  several Microchip microcontrollers, including PIC17C752, PIC17C756A, PIC17C762 and PIC17C766. All necessary hardware is included to run basic demo programs, which are supplied on a 3.5-inch disk. A programmed sample  is  included  and  the  user  may  erase  it  and program it with the other sample programs using the PRO MATE II device programmer, or the PICSTART Plus development programmer, and easily debug and test the sample code. In addition, the PICDEM 17 demonstration board supports downloading of programs to and executing out of external FLASH memory on board. The PICDEM 17 demonstration  board  is  also  usable with the MPLAB  ICE in-circuit emulator, or the PICMASTER emulator and all of the sample programs can be run and modified using either emulator. Additionally,  a  generous  prototype  area  is  available  for  user hardware.",
    "20.15 KEELOQ Evaluation and Programming Tools\nKEELOQ  evaluation  and  programming  tools  support Microchip's HCS Secure Data Products. The HCS evaluation  kit  includes  a  LCD  display  to  show  changing codes, a decoder to decode transmissions and a programming interface to program test transmitters.",
    "PIC18CXX2\nPIC17C7XX \uf0fc, \uf0fc = \uf0fc. PIC17C7XX \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC17C7XX \uf0fc, \uf0fc = \uf0fc. PIC17C7XX \uf0fc, DEVELOPMENT....\uf0fc = . PIC17C7XX \uf0fc, TOOLS.... = . PIC17C7XX \uf0fc, FROM....\uf0fc = \uf0fc. PIC17C7XX \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC17C7XX \uf0fc, MICROCHIP.... = . PIC17C7XX \uf0fc, \uf0fc = . PIC17C7XX \uf0fc,  = . PIC17C7XX \uf0fc,",
    "PIC18CXX2\n= \uf0fc. PIC17C7XX \uf0fc, \uf0fc.. = . PIC17C7XX \uf0fc, \uf0fc.\uf0fc.. = . PIC17C7XX \uf0fc, \uf0fc... = . PIC17C7XX \uf0fc, \uf0fc... = . PIC17C7XX \uf0fc, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = with. PIC17C4X \uf0fc, \uf0fc = \uf0fc. PIC17C4X \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC17C4X \uf0fc, \uf0fc = \uf0fc. PIC17C4X \uf0fc, DEVELOPMENT....\uf0fc = . PIC17C4X \uf0fc, TOOLS.... = . PIC17C4X \uf0fc, FROM....\uf0fc = \uf0fc. PIC17C4X \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC17C4X \uf0fc, MICROCHIP.... = \uf0fc. PIC17C4X \uf0fc, \uf0fc = . PIC17C4X \uf0fc,  = . PIC17C4X \uf0fc,",
    "PIC18CXX2\n= . PIC17C4X \uf0fc, \uf0fc.. = . PIC17C4X \uf0fc, \uf0fc.\uf0fc.. = . PIC17C4X \uf0fc, \uf0fc... = . PIC17C4X \uf0fc, \uf0fc... = . PIC17C4X \uf0fc, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = (DV164001). PIC16C9XX, \uf0fc = \uf0fc. PIC16C9XX, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C9XX, \uf0fc = \uf0fc. PIC16C9XX, DEVELOPMENT....\uf0fc = \uf0fc. PIC16C9XX, TOOLS.... = . PIC16C9XX, FROM....\uf0fc = \uf0fc. PIC16C9XX, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C9XX, MICROCHIP.... = . PIC16C9XX, \uf0fc = . PIC16C9XX,  = \uf0fc. PIC16C9XX,",
    "PIC18CXX2\n= . PIC16C9XX, \uf0fc.. = . PIC16C9XX, \uf0fc.\uf0fc.. = . PIC16C9XX, \uf0fc... = . PIC16C9XX, \uf0fc... = . PIC16C9XX, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = Debugger. PIC16F8XX, \uf0fc = \uf0fc. PIC16F8XX, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16F8XX, \uf0fc = \uf0fc. PIC16F8XX, DEVELOPMENT....\uf0fc = . PIC16F8XX, TOOLS.... = \uf0fc. PIC16F8XX, FROM....\uf0fc = \uf0fc. PIC16F8XX, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16F8XX, MICROCHIP.... = . PIC16F8XX, \uf0fc = . PIC16F8XX,  = . PIC16F8XX,",
    "PIC18CXX2\n= . PIC16F8XX, \uf0fc.. = . PIC16F8XX, \uf0fc.\uf0fc.. = . PIC16F8XX, \uf0fc... = . PIC16F8XX, \uf0fc... = . PIC16F8XX, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = In-Circuit. PIC16C8X, \uf0fc = \uf0fc. PIC16C8X, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C8X, \uf0fc = \uf0fc. PIC16C8X, DEVELOPMENT....\uf0fc = \uf0fc. PIC16C8X, TOOLS.... = . PIC16C8X, FROM....\uf0fc = \uf0fc. PIC16C8X, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C8X, MICROCHIP.... = \uf0fc. PIC16C8X, \uf0fc = . PIC16C8X,  = . PIC16C8X,",
    "PIC18CXX2\n= . PIC16C8X, \uf0fc.. = . PIC16C8X, \uf0fc.\uf0fc.. = . PIC16C8X, \uf0fc... = . PIC16C8X, \uf0fc... = . PIC16C8X, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = \u00ae ICD. PIC16C7XX, \uf0fc = \uf0fc. PIC16C7XX, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C7XX, \uf0fc = \uf0fc. PIC16C7XX, DEVELOPMENT....\uf0fc = \uf0fc. PIC16C7XX, TOOLS.... = . PIC16C7XX, FROM....\uf0fc = \uf0fc. PIC16C7XX, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C7XX, MICROCHIP.... = . PIC16C7XX, \uf0fc = . PIC16C7XX,  = . PIC16C7XX,",
    "PIC18CXX2\n= . PIC16C7XX, \uf0fc.. = . PIC16C7XX, \uf0fc.\uf0fc.. = . PIC16C7XX, \uf0fc... = . PIC16C7XX, \uf0fc... = . PIC16C7XX, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = the MPLAB. PIC16C7X \uf0fc, \uf0fc = . PIC16C7X \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C7X \uf0fc, \uf0fc = \uf0fc. PIC16C7X \uf0fc, DEVELOPMENT....\uf0fc = \uf0fc. PIC16C7X \uf0fc, TOOLS.... = \uf0fc *. PIC16C7X \uf0fc, FROM....\uf0fc = \uf0fc. PIC16C7X \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C7X \uf0fc, MICROCHIP.... = \uf0fc \u2020. PIC16C7X \uf0fc, \uf0fc = \uf0fc \u2020. PIC16C7X \uf0fc,  = . PIC16C7X \uf0fc,",
    "PIC18CXX2\n= . PIC16C7X \uf0fc, \uf0fc.. = . PIC16C7X \uf0fc, \uf0fc.\uf0fc.. = . PIC16C7X \uf0fc, \uf0fc... = . PIC16C7X \uf0fc, \uf0fc... = . PIC16C7X \uf0fc, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = to use. PIC16F62X \uf0fc, \uf0fc = . PIC16F62X \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16F62X \uf0fc, \uf0fc = \uf0fc **. PIC16F62X \uf0fc, DEVELOPMENT....\uf0fc = . PIC16F62X \uf0fc, TOOLS.... = . PIC16F62X \uf0fc, FROM....\uf0fc = \uf0fc **. PIC16F62X \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc **. PIC16F62X \uf0fc, MICROCHIP.... = . PIC16F62X \uf0fc, \uf0fc = . PIC16F62X \uf0fc,  = . PIC16F62X \uf0fc,",
    "PIC18CXX2\n= . PIC16F62X \uf0fc, \uf0fc.. = . PIC16F62X \uf0fc, \uf0fc.\uf0fc.. = . PIC16F62X \uf0fc, \uf0fc... = . PIC16F62X \uf0fc, \uf0fc... = . PIC16F62X \uf0fc, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = on how. PIC16CXXX \uf0fc, \uf0fc = . PIC16CXXX \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16CXXX \uf0fc, \uf0fc = \uf0fc. PIC16CXXX \uf0fc, DEVELOPMENT....\uf0fc = \uf0fc. PIC16CXXX \uf0fc, TOOLS.... = . PIC16CXXX \uf0fc, FROM....\uf0fc = \uf0fc. PIC16CXXX \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16CXXX \uf0fc, MICROCHIP.... = \uf0fc. PIC16CXXX \uf0fc, \uf0fc = . PIC16CXXX \uf0fc,  = . PIC16CXXX \uf0fc,",
    "PIC18CXX2\n= . PIC16CXXX \uf0fc, \uf0fc.. = . PIC16CXXX \uf0fc, \uf0fc.\uf0fc.. = . PIC16CXXX \uf0fc, \uf0fc... = . PIC16CXXX \uf0fc, \uf0fc... = . PIC16CXXX \uf0fc, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = information. PIC16C6X \uf0fc, \uf0fc = . PIC16C6X \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C6X \uf0fc, \uf0fc = \uf0fc. PIC16C6X \uf0fc, DEVELOPMENT....\uf0fc = \uf0fc. PIC16C6X \uf0fc, TOOLS.... = \uf0fc *. PIC16C6X \uf0fc, FROM....\uf0fc = \uf0fc. PIC16C6X \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C6X \uf0fc, MICROCHIP.... = . PIC16C6X \uf0fc, \uf0fc = \uf0fc \u2020. PIC16C6X \uf0fc,  = . PIC16C6X \uf0fc,",
    "PIC18CXX2\n= . PIC16C6X \uf0fc, \uf0fc.. = . PIC16C6X \uf0fc, \uf0fc.\uf0fc.. = . PIC16C6X \uf0fc, \uf0fc... = . PIC16C6X \uf0fc, \uf0fc... = . PIC16C6X \uf0fc, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = for. PIC16C5X \uf0fc, \uf0fc = . PIC16C5X \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C5X \uf0fc, \uf0fc = \uf0fc. PIC16C5X \uf0fc, DEVELOPMENT....\uf0fc = \uf0fc. PIC16C5X \uf0fc, TOOLS.... = . PIC16C5X \uf0fc, FROM....\uf0fc = \uf0fc. PIC16C5X \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC16C5X \uf0fc, MICROCHIP.... = \uf0fc. PIC16C5X \uf0fc, \uf0fc = . PIC16C5X \uf0fc,  = . PIC16C5X \uf0fc,",
    "PIC18CXX2\n= . PIC16C5X \uf0fc, \uf0fc.. = . PIC16C5X \uf0fc, \uf0fc.\uf0fc.. = . PIC16C5X \uf0fc, \uf0fc... = . PIC16C5X \uf0fc, \uf0fc... = . PIC16C5X \uf0fc, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = www.microchip.com date.. PIC14000 \uf0fc, \uf0fc = . PIC14000 \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC14000 \uf0fc, \uf0fc = \uf0fc. PIC14000 \uf0fc, DEVELOPMENT....\uf0fc = . PIC14000 \uf0fc, TOOLS.... = . PIC14000 \uf0fc, FROM....\uf0fc = \uf0fc. PIC14000 \uf0fc, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC14000 \uf0fc, MICROCHIP.... = . PIC14000 \uf0fc, \uf0fc = . PIC14000 \uf0fc,  = . PIC14000 \uf0fc,",
    "PIC18CXX2\n= \uf0fc. PIC14000 \uf0fc, \uf0fc.. = . PIC14000 \uf0fc, \uf0fc.\uf0fc.. = . PIC14000 \uf0fc, \uf0fc... = . PIC14000 \uf0fc, \uf0fc... = . PIC14000 \uf0fc, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = site at. PIC12CXXX, \uf0fc = \uf0fc. PIC12CXXX, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC12CXXX, \uf0fc = \uf0fc. PIC12CXXX, DEVELOPMENT....\uf0fc = \uf0fc. PIC12CXXX, TOOLS.... = . PIC12CXXX, FROM....\uf0fc = \uf0fc. PIC12CXXX, \uf0fc.\uf0fc.\uf0fc = \uf0fc. PIC12CXXX, MICROCHIP.... = . PIC12CXXX, \uf0fc = . PIC12CXXX,  = . PIC12CXXX,",
    "PIC18CXX2\n= . PIC12CXXX, \uf0fc.. = . PIC12CXXX, \uf0fc.\uf0fc.. = . PIC12CXXX, \uf0fc... = . PIC12CXXX, \uf0fc... = . PIC12CXXX, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = web availability select devices.. MPLAB \u00ae Integrated, \uf0fc = Tools Development Environment MPLAB \u00ae C17 C Compiler. MPLAB \u00ae Integrated, \uf0fc.\uf0fc.\uf0fc = Software MPLAB \u00ae C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker. MPLAB \u00ae Integrated, \uf0fc = MPLAB \u00ae ICE In-Circuit Emulator. MPLAB \u00ae Integrated, DEVELOPMENT....\uf0fc = Emulators ICEPIC TM In-Circuit Emulator. MPLAB \u00ae Integrated, TOOLS.... = Debugger MPLAB \u00ae ICD In-Circuit Debugger. MPLAB \u00ae Integrated, FROM....\uf0fc = PICSTART \u00ae Plus Entry Level Development Programmer. MPLAB \u00ae Integrated, \uf0fc.\uf0fc.\uf0fc = Programmers PRO MATE \u00ae II Universal Device Programmer. MPLAB \u00ae Integrated, MICROCHIP.... =",
    "PIC18CXX2\nPICDEM TM 1 Demonstration Board. MPLAB \u00ae Integrated, \uf0fc = PICDEM TM 2 Demonstration Board. MPLAB \u00ae Integrated,\n= PICDEM TM 3 Demonstration Board. MPLAB \u00ae Integrated,  = Eval Kits PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board. MPLAB \u00ae Integrated, \uf0fc.. = Boards and KEELOQ \u00ae Evaluation Kit KEELOQ \u00ae Transponder Kit. MPLAB \u00ae Integrated, \uf0fc.\uf0fc.. = Demo microID TM Programmer's Kit 125 kHz microID TM. MPLAB \u00ae Integrated, \uf0fc... = 125 kHz Anticollision microID TM Developer's Kit 13.56 MHz Anticollision. MPLAB \u00ae Integrated, \uf0fc... = microID TM Developer's Kit MCP2510 CAN Developer's Kit. MPLAB \u00ae Integrated, \uf0fc 76, 77..74,.65, 72, 73,.63, 64,.PIC16C62, = * Contact the Microchip Technology Inc. ** Contact Microchip Technology Inc. for \u2020 Development tool is available on\nNOTES:",
    "21.0 ELECTRICAL CHARACTERISTICS\nAbsolute Maximum Ratings (\u2020)\nAmbient temperature under bias............................................................................................................ .-55\u00b0C, 1 = to +125\u00b0C. Storage temperature",
    "21.0 ELECTRICAL CHARACTERISTICS\n.............................................................................................................................., 1 = -65\u00b0C to +150\u00b0C. Voltage on any pin with respect to VSS (except VDD, MCLR, and RA4) ....................................... -0.3 V DD, 1 = to (V + 0.3 V). Voltage on VDD with respect to VSS",
    "21.0 ELECTRICAL CHARACTERISTICS\n......................................................................................................., 1 = -0.3 V to +7.5 V. Voltage on MCLR with respect to VSS (Note 2) ....................................................................................... 0, 1 = V to +13.25 V. Voltage on RA4 with respect to",
    "21.0 ELECTRICAL CHARACTERISTICS\nVss............................................................................................................. 0, 1 = V to +8.5 V. Total power dissipation (Note 1)",
    "21.0 ELECTRICAL CHARACTERISTICS\n.............................................................................................................................., 1 = 1.0 W. Maximum current out of VSS pin",
    "21.0 ELECTRICAL CHARACTERISTICS\n...........................................................................................................................300, 1 = mA. Maximum current into VDD pin",
    "21.0 ELECTRICAL CHARACTERISTICS\n.............................................................................................................................., 1 = 250 mA. Input clamp current, I IK (V I < 0 or VI > VDD) \uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e, 1 = \uf0b1 20 mA. Output clamp current, I OK (V O < 0 or VO > VDD) \uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e, 1 = \uf0b1 20 mA. Maximum output current sunk by any I/O",
    "21.0 ELECTRICAL CHARACTERISTICS\npin..........................................................................................................25, 1 = mA. Maximum output current sourced by any I/O pin ...................................................................................................., 1 = 25 mA. Maximum current sunk by \uf020 PORTA, PORTB, and PORTE (Note 3)",
    "21.0 ELECTRICAL CHARACTERISTICS\n(combined)...................................................200, 1 = mA. Maximum current sourced by PORTA, PORTB, and PORTE (Note 3) (combined)..............................................200, 1 = mA. Maximum current sunk by PORTC and PORTD (Note 3) (combined)..................................................................200, 1 = mA. Maximum current sourced by PORTC and PORTD (Note 3)",
    "21.0 ELECTRICAL CHARACTERISTICS\n(combined).............................................................200, 1 = mA\nNote 1: Power dissipation is calculated as follows:\nPdis = VDD x {IDD -\uf0e5 IOH} + \uf0e5 {(VDD-VOH) x IOH} + \uf0e5 (VOl x IOL)\n2: Voltage spikes below VSS at the MCLR/VPP pin, inducing currents greater than 80 mA, may cause latch-up. Thus, a series resistor of 50-100 \uf057 should be used when applying a 'low' level to the MCLR/VPP pin, rather than pulling this pin directly to VSS.\n3: PORTD and PORTE not available on the PIC18C2X2 devices.",
    "21.0 ELECTRICAL CHARACTERISTICS\n\u2020 NOTICE: Stresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure to maximum rating conditions for extended periods may affect device reliability.",
    "PIC18CXX2\nFIGURE 21-2: PIC18LCXX2 VOLTAGE-FREQUENCY GRAPH (INDUSTRIAL)",
    "21.1 DC Characteristics\nPIC18LCXX2\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18CXX2\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "21.1 DC Characteristics\nD001, Symbol = VDD. D001, Characteristic = Supply Voltage. D001, Min = Supply Voltage. D001, Typ = Supply Voltage. D001, Max = Supply Voltage. D001, Units = Supply Voltage. D001, Conditions = Supply Voltage. D001, Symbol = VDD. D001, Characteristic = PIC18LCXX2. D001, Min = 2.5. D001, Typ = -. D001, Max = 5.5. D001, Units = V. D001, Conditions = HS, XT, RC and LP osc mode. D001, Symbol = VDD. D001, Characteristic = PIC18CXX2. D001, Min = 4.2. D001, Typ = -. D001, Max = 5.5. D001, Units = V. D001, Conditions = . D002, Symbol = VDR. D002, Characteristic = RAM Data Retention Voltage (1). D002, Min = 1.5. D002, Typ = -. D002,",
    "21.1 DC Characteristics\nMax = -. D002, Units = V. D002, Conditions = . D003, Symbol = VPOR. D003, Characteristic = VDD Start Voltage to ensure internal Power-on Reset signal. D003, Min = -. D003, Typ = -. D003, Max = 0.7. D003, Units = V. D003, Conditions = See section on Power-on Reset for details. D004, Symbol = SVDD. D004, Characteristic = VDD Rise Rate to ensure internal Power-on Reset signal. D004, Min = 0.05. D004, Typ = -. D004, Max = -. D004, Units = V/ms. D004, Conditions = See section on Power-on Reset for details. D005, Symbol = VBOR. D005, Characteristic = Brown-out Reset Voltage. D005, Min = Brown-out Reset Voltage. D005, Typ = Brown-out Reset Voltage. D005, Max = Brown-out Reset Voltage. D005, Units = Brown-out Reset Voltage.",
    "21.1 DC Characteristics\nD005, Conditions = Brown-out Reset Voltage. D005, Symbol = VBOR. D005, Characteristic = PIC18LCXX2. D005, Min = PIC18LCXX2. D005, Typ = . D005, Max = . D005, Units = . D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 11. D005, Min = 2.5. D005, Typ = -. D005, Max = 2.66. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 10. D005, Min = 2.7. D005, Typ = -. D005, Max = 2.86. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 01. D005, Min =",
    "21.1 DC Characteristics\n4.2. D005, Typ = -. D005, Max = 4.46. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 00. D005, Min = 4.5. D005, Typ = -. D005, Max = 4.78. D005, Units = V. D005, Conditions = . D005, Symbol = . D005, Characteristic = PIC18CXX2. D005, Min = PIC18CXX2. D005, Typ = . D005, Max = . D005, Units = . D005, Conditions = . D005, Symbol = . D005, Characteristic = BORV1:BORV0 = 1x. D005, Min = N.A.. D005, Typ = -. D005, Max = N.A.. D005, Units = V. D005, Conditions = Not in operating voltage range of device.",
    "21.1 DC Characteristics\nD005, Symbol = . D005, Characteristic = BORV1:BORV0 = 01. D005, Min = 4.2. D005, Typ = -. D005, Max = 4.46. D005, Units = V. D005, Conditions = . D005, Symbol = . D005, Characteristic = BORV1:BORV0 = 00. D005, Min = 4.5. D005, Typ = -. D005, Max = 4.78. D005, Units = V. D005, Conditions = \nLegend: Shading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in SLEEP mode, or during a device RESET, without losing RAM data.\n2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:",
    "21.1 DC Characteristics\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD\nMCLR = VDD; WDT enabled/disabled as specified.\n3: The power-down current in SLEEP mode does not depend on the oscillator type. Power-down current is measured with the part in SLEEP mode, with all I/O pins in hi-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR,...).\n4: For RC osc configuration, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in kOhm.",
    "21.1 DC Characteristics  (Continued)\nPIC18LCXX2\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18CXX2\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "21.1 DC Characteristics  (Continued)\n, Symbol = I DD. , Characteristic = Supply Current (2,4). , Min = Supply Current (2,4). , Typ = Supply Current (2,4). , Max = Supply Current (2,4). , Units = Supply Current (2,4). , Conditions = Supply Current (2,4). D010, Symbol = . D010, Characteristic = PIC18LCXX2. D010, Min = -. D010, Typ = -. D010, Max = 2. D010, Units = mA. D010, Conditions = XT, RC, RCIO osc configurations FOSC = 4 MHz, VDD = 2.5V. D010, Symbol = . D010, Characteristic = PIC18CXX2. D010, Min = -. D010, Typ = -. D010, Max = 4. D010, Units = mA. D010, Conditions = XT, RC, RCIO osc configurations FOSC = 4 MHz, VDD = 4.2V. D010A, Symbol = .",
    "21.1 DC Characteristics  (Continued)\nD010A, Characteristic = PIC18LCXX2. D010A, Min = -. D010A, Typ = -. D010A, Max = 55. D010A, Units = \uf06d A. D010A, Conditions = LP osc configuration FOSC = 32 kHz, VDD = 2.5V. D010A, Symbol = . D010A, Characteristic = PIC18CXX2. D010A, Min = -. D010A, Typ = -. D010A, Max = 250. D010A, Units = \uf06d A. D010A, Conditions = LP osc configuration FOSC = 32 kHz, VDD = 4.2V. D010C, Symbol = . D010C, Characteristic = PIC18LCXX2. D010C, Min = -. D010C, Typ = -. D010C, Max = 38. D010C, Units = mA. D010C, Conditions = EC, ECIO osc configurations FOSC = 40 MHz, VDD = 5.5V.",
    "21.1 DC Characteristics  (Continued)\nD010C, Symbol = . D010C, Characteristic = PIC18CXX2. D010C, Min = -. D010C, Typ = -. D010C, Max = 38. D010C, Units = mA. D010C, Conditions = EC, ECIO osc configurations FOSC = 40 MHz, VDD = 5.5V. D013, Symbol = . D013, Characteristic = PIC18LCXX2. D013, Min = - -. D013, Typ = - -. D013, Max = 3.5 25. D013, Units = mA mA mA. D013, Conditions = HS osc configuration FOSC = 6 MHz, VDD = 2.5V FOSC = 25 MHz, VDD = 5.5V HS + PLL osc configurations FOSC = 10 MHz, VDD = 5.5V. D013, Symbol = . D013, Characteristic = PIC18CXX2. D013, Min = -. D013, Typ = -. D013, Max =",
    "21.1 DC Characteristics  (Continued)\n25. D013, Units = mA. D013, Conditions = HS osc configuration FOSC = 25 MHz, VDD = 5.5V HS + PLL osc configurations FOSC = 10 MHz, VDD = 5.5V. D014, Symbol = . D014, Characteristic = PIC18LCXX2. D014, Min = -. D014, Typ = -. D014, Max = 55. D014, Units = \uf06d A. D014, Conditions = Timer1 osc configuration FOSC = 32 kHz, VDD = 2.5V. D014, Symbol = . D014, Characteristic = PIC18CXX2. D014, Min = - -. D014, Typ = - -. D014, Max = 200 250. D014, Units = \uf06d A \uf06d A. D014, Conditions = OSCB osc configuration FOSC = 32 kHz, VDD = 4.2V, -40 \uf0b0 C to +85 \uf0b0 C FOSC = 32 kHz, VDD = 4.2V, -40 \uf0b0 C to +125 \uf0b0 C",
    "21.1 DC Characteristics  (Continued)\nLegend: Shading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in SLEEP mode, or during a device RESET, without losing RAM data.\n2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD\nMCLR = VDD; WDT enabled/disabled as specified.",
    "21.1 DC Characteristics  (Continued)\n3: The power-down current in SLEEP mode does not depend on the oscillator type. Power-down current is measured with the part in SLEEP mode, with all I/O pins in hi-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR,...).\n4: For RC osc configuration, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in kOhm.\nPIC18LCXX2\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18CXX2\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "21.1 DC Characteristics  (Continued)\n, Symbol = I PD. , Characteristic = Power-down Current (3). , Min = Power-down Current (3). , Typ = Power-down Current (3). , Max = Power-down Current (3). , Units = Power-down Current (3). , Conditions = Power-down Current (3). D020, Symbol = . D020, Characteristic = PIC18LCXX2. D020, Min = - -. D020, Typ = <.5 -. D020, Max = 2 4. D020, Units = \uf06d A \uf06d A. D020, Conditions = VDD = 2.5V, -40 \uf0b0 C to +85 \uf0b0 C VDD = 5.5V, -40 \uf0b0 C to +85 \uf0b0 C. D020, Symbol = . D020, Characteristic = PIC18CXX2. D020, Min = - -. D020, Typ = <1 -. D020, Max = 3 4. D020, Units = \uf06d A \uf06d A. D020, Conditions = VDD = 4.2V, -40 \uf0b0 C to +85 \uf0b0 C VDD",
    "21.1 DC Characteristics  (Continued)\n= 5.5V, -40 \uf0b0 C to +85 \uf0b0 C VDD = 4.2V, -40 \uf0b0 C to +125 \uf0b0 C. D021B, Symbol = . D021B, Characteristic = . D021B, Min = -. D021B, Typ = -. D021B, Max = 15. D021B, Units = \uf06d A. D021B, Conditions = . , Symbol = . , Characteristic = . , Min = -. , Typ = -. , Max = 20. , Units = \uf06d A. , Conditions = VDD = 5.5V, -40 \uf0b0 C to +125 \uf0b0 C. , Symbol = . , Characteristic = Module Differential Current. , Min = Module Differential Current. , Typ = Module Differential Current. , Max = Module Differential Current. , Units = Module Differential Current. , Conditions = Module Differential Current. D022, Symbol = \uf044 I WDT. D022, Characteristic = Watchdog Timer PIC18LCXX2. D022, Min = - -. D022, Typ = - -. D022, Max = 1 15. D022, Units = \uf06d A \uf06d A.",
    "21.1 DC Characteristics  (Continued)\nD022, Conditions = VDD = 2.5V VDD = 5.5V. D022, Symbol = . D022, Characteristic = Watchdog Timer PIC18CXX2. D022, Min = - -. D022, Typ = - -. D022, Max = 15 20. D022, Units = \uf06d A \uf06d A. D022, Conditions = VDD = 5.5V, -40 \uf0b0 C to +85 \uf0b0 C VDD = 5.5V, -40 \uf0b0 C to +125 \uf0b0 C. D022A, Symbol = \uf044 I BOR. D022A, Characteristic = Brown-out Reset PIC18LCXX2. D022A, Min = -. D022A, Typ = -. D022A, Max = 45. D022A, Units = \uf06d A. D022A, Conditions = VDD = 2.5V. D022A, Symbol = . D022A, Characteristic = Brown-out Reset PIC18CXX2. D022A, Min = - -. D022A, Typ = - -. D022A,",
    "21.1 DC Characteristics  (Continued)\nMax = 50 50. D022A, Units = \uf06d A \uf06d A. D022A, Conditions = VDD = 5.5V, -40 \uf0b0 C to +85 \uf0b0 C VDD = 5.5V, -40 \uf0b0 C to +125 \uf0b0. D022B, Symbol = \uf044 I LVD. D022B, Characteristic = Low Voltage Detect PIC18LCXX2. D022B, Min = -. D022B, Typ = -. D022B, Max = 45. D022B, Units = \uf06d A. D022B, Conditions = VDD = 2.5V. D022B, Symbol = . D022B, Characteristic = Low Voltage Detect PIC18CXX2. D022B, Min = - -. D022B, Typ = - -. D022B, Max = 50 50. D022B, Units = \uf06d A \uf06d A. D022B, Conditions = VDD = 4.2V, -40 \uf0b0 C to +85 \uf0b0 C VDD = 4.2V, -40 \uf0b0 C to +125 \uf0b0 C. D025, Symbol = \uf044 I OSCB. D025,",
    "21.1 DC Characteristics  (Continued)\nCharacteristic = Timer1 Oscillator PIC18LCXX2. D025, Min = -. D025, Typ = -. D025, Max = 15. D025, Units = \uf06d A. D025, Conditions = VDD = 2.5V. D025, Symbol = . D025, Characteristic = Timer1 Oscillator PIC18CXX2. D025, Min = - -. D025, Typ = - -. D025, Max = 100 120. D025, Units = \uf06d A \uf06d A. D025, Conditions = VDD = 4.2V, -40 \uf0b0 C to +85 \uf0b0 C VDD = 4.2V, -40 \uf0b0 C to +125 \uf0b0 C",
    "21.1 DC Characteristics  (Continued)\nLegend: Shading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in SLEEP mode, or during a device RESET, without losing RAM data.\n2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD\nMCLR = VDD; WDT enabled/disabled as specified.",
    "21.1 DC Characteristics  (Continued)\n3: The power-down current in SLEEP mode does not depend on the oscillator type. Power-down current is measured with the part in SLEEP mode, with all I/O pins in hi-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR,...).\n4: For RC osc configuration, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in kOhm.",
    "21.2 DC Characteristics: PIC18CXX2 (Industrial, Extended)\nPIC18LCXX2  (Industrial)",
    "DC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3\uf020 TA \uf0a3 +125\u00b0C for extended",
    "DC CHARACTERISTICS\nD030, Symbol = VIL. D030, Characteristic = Input Low Voltage I/O ports: with TTL buffer. D030, Min = Vss - Vss Vss VSS VSS VSS. D030, Max = 0.15V DD 0.8 0.2V DD 0.3V DD 0.2V DD 0.3V DD 0.2V DD VDD. D030, Units = V V V V V V V. D030, Conditions = VDD < 4.5V 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V. D031 D032 D032A D033 D040, Symbol = VIH. D031 D032 D032A D033 D040, Characteristic = with Schmitt Trigger buffer RC3 and RC4 MCLR OSC1 (in XT, HS and LP modes) and T1OSI OSC1 (in RC and EC mode) (1) Input High Voltage I/O ports: with TTL buffer. D031 D032 D032A D033 D040, Min = 0.25V DD +. D031",
    "DC CHARACTERISTICS\nD032 D032A D033 D040, Max = . D031 D032 D032A D033 D040, Units = V. D031 D032 D032A D033 D040, Conditions = VDD < 4.5V. D040A D041, Symbol = . D040A D041, Characteristic = with Schmitt Trigger buffer. D040A D041, Min = 0.8V 2.0 0.8V DD. D040A D041, Max = VDD VDD. D040A D041, Units = V V V. D040A D041, Conditions = 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V. D042, Symbol = . D042, Characteristic = RC3 and RC4 MCLR, OSC1 (EC mode). D042, Min = 0.7V DD. D042, Max = VDD. D042, Units = V V. D042, Conditions = . D042A D043, Symbol = . D042A D043, Characteristic =",
    "DC CHARACTERISTICS\nOSC1 (in XT, HS and LP modes) and T1OSI OSC1 (RC mode) (1). D042A D043, Min = 0.8V DD 0.7V DD 0.9V DD. D042A D043, Max = VDD VDD VDD. D042A D043, Units = V. D042A D043, Conditions = . D060, Symbol = I IL. D060, Characteristic = Input Leakage Current (2,3) I/O ports. D060, Min = -. D060, Max = \uf0b1 1. D060, Units = \uf06d A. D060, Conditions = VSS \uf0a3\uf020 VPIN \uf0a3\uf020 VDD,. , Symbol = . , Characteristic = . , Min = . , Max = . , Units = . , Conditions = Pin at hi-impedance. D061, Symbol = . D061, Characteristic = MCLR OSC1. D061, Min = -. D061, Max = \uf0b1 5. D061, Units = \uf06d A. D061, Conditions = Vss \uf0a3\uf020 VPIN \uf0a3\uf020 VDD Vss \uf0a3\uf020",
    "DC CHARACTERISTICS\nVPIN \uf0a3\uf020 VDD. D063, Symbol = I PU. D063, Characteristic = Weak Pull-up Current. D063, Min = -. D063, Max = \uf0b1 5. D063, Units = \uf06d A. D063, Conditions = . , Symbol = . , Characteristic = PORTB weak pull-up. , Min = 50. , Max = . , Units = \uf06d A. , Conditions = . D070, Symbol = I PURB. D070, Characteristic = current. D070, Min = . D070, Max = 400. D070, Units = . D070, Conditions = VDD = 5V, VPIN = VSS\nNote 1: In RC oscillator configuration, the OSC1/CLKIN pin is a Schmitt Trigger input. It is not recommended that the PIC MCU be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.",
    "21.2 DC Characteristics: PIC18CXX2 (Industrial, Extended) PIC18LCXX2  (Industrial) (Continued)\nDC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3\uf020 TA \uf0a3 +125\u00b0C for extended",
    "21.2 DC Characteristics: PIC18CXX2 (Industrial, Extended) PIC18LCXX2  (Industrial) (Continued)\nD080, Symbol = VOL. D080, Characteristic = Output Low Voltage I/O ports. D080, Min = -. D080, Max = 0.6. D080, Units = V. D080, Conditions = I OL = 8.5 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D080A, Symbol = . D080A, Characteristic = . D080A, Min = -. D080A, Max = 0.6. D080A, Units = V. D080A, Conditions = I OL = 7.0 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D083, Symbol = . D083, Characteristic = OSC2/CLKOUT (RC mode). D083, Min = -. D083, Max = 0.6. D083, Units = V. D083, Conditions = I OL = 1.6 mA, VDD =",
    "21.2 DC Characteristics: PIC18CXX2 (Industrial, Extended) PIC18LCXX2  (Industrial) (Continued)\n4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D083A, Symbol = . D083A, Characteristic = . D083A, Min = -. D083A, Max = 0.6. D083A, Units = V. D083A, Conditions = I OL = 1.2 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D090, Symbol = VOH. D090, Characteristic = Output High Voltage (3) I/O ports. D090, Min = VDD - 0.7. D090, Max = -. D090, Units = V. D090, Conditions = I OH = -3.0 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D090A, Symbol = . D090A, Characteristic = . D090A, Min = VDD - 0.7. D090A, Max = -. D090A, Units = V.",
    "21.2 DC Characteristics: PIC18CXX2 (Industrial, Extended) PIC18LCXX2  (Industrial) (Continued)\nD090A, Conditions = I OH = -2.5 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D092, Symbol = . D092, Characteristic = OSC2/CLKOUT (RC mode). D092, Min = VDD - 0.7. D092, Max = -. D092, Units = V. D092, Conditions = I OH = -1.3 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D092A, Symbol = . D092A, Characteristic = . D092A, Min = VDD - 0.7. D092A, Max = -. D092A, Units = V. D092A, Conditions = I OH = -1.0 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D150, Symbol = VOD. D150, Characteristic = Open Drain High Voltage.",
    "21.2 DC Characteristics: PIC18CXX2 (Industrial, Extended) PIC18LCXX2  (Industrial) (Continued)\nD150, Min = -. D150, Max = 8.5. D150, Units = V. D150, Conditions = RA4 pin. D101, Symbol = CIO. D101, Characteristic = Capacitive Loading Specs on Output Pins All I/O pins and OSC2 (in RC mode). D101, Min = -. D101, Max = 50. D101, Units = pF. D101, Conditions = To meet the AC Timing Specifications. D102, Symbol = CB. D102, Characteristic = SCL, SDA. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = In I 2 C mode",
    "21.2 DC Characteristics: PIC18CXX2 (Industrial, Extended) PIC18LCXX2  (Industrial) (Continued)\nNote 1: In RC oscillator configuration, the OSC1/CLKIN pin is a Schmitt Trigger input. It is not recommended that the PIC MCU be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.",
    "TABLE 21-1: LOW VOLTAGE DETECT CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature -40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "TABLE 21-1: LOW VOLTAGE DETECT CHARACTERISTICS\nD420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV<3:0> = 0100. D420, Min = 2.5. D420, Max = 2.66. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV<3:0> = 0101. D420, Min = 2.7. D420, Max = 2.86. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV<3:0> = 0110. D420, Min = 2.8. D420, Max = 2.98. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic =",
    "TABLE 21-1: LOW VOLTAGE DETECT CHARACTERISTICS\nLVV<3:0> = 0111. D420, Min = 3.0. D420, Max = 3.2. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV<3:0> = 1000. D420, Min = 3.3. D420, Max = 3.52. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV<3:0> = 1001. D420, Min = 3.5. D420, Max = 3.72. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV<3:0> = 1010. D420, Min = 3.6. D420, Max =",
    "TABLE 21-1: LOW VOLTAGE DETECT CHARACTERISTICS\n3.84. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV<3:0> = 1011. D420, Min = 3.8. D420, Max = 4.04. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV<3:0> = 1100. D420, Min = 4.0. D420, Max = 4.26. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV<3:0> = 1101. D420, Min = 4.2. D420, Max = 4.46. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD.",
    "TABLE 21-1: LOW VOLTAGE DETECT CHARACTERISTICS\nD420, Characteristic = LVD Voltage. D420, Characteristic = LVV<3:0> = 1110. D420, Min = 4.5. D420, Max = 4.78. D420, Units = V. D420, Conditions = ",
    "DC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 TA \uf0a3 +40\u00b0C",
    "DC CHARACTERISTICS\nD110, Sym = VPP. D110, Characteristic = Internal Program Memory Programming Specs (Note 1) Voltage on MCLR/VPP pin. D110, Min = 12.75. D110, Max = 13.25. D110, Units = V. D110, Conditions = (Note 2). D111, Sym = VDDP. D111, Characteristic = Supply voltage during programming. D111, Min = 4.75. D111, Max = 5.25. D111, Units = V. D111, Conditions = . D112, Sym = I PP. D112, Characteristic = Current into MCLR/VPP pin. D112, Min = -. D112, Max = 50. D112, Units = mA. D112, Conditions = . D113, Sym = I DDP. D113, Characteristic = Supply current during programming. D113, Min = -. D113, Max = 30. D113, Units = mA. D113, Conditions = . D114, Sym = TPROG.",
    "DC CHARACTERISTICS\nD114, Characteristic = Programming pulse width. D114, Min = 50. D114, Max = 1000. D114, Units = \uf06d s. D114, Conditions = Terminated via internal/external interrupt or a RESET. D115, Sym = T ERASE. D115, Characteristic = EPROM erase time. D115, Min = . D115, Max = . D115, Units = . D115, Conditions = . , Sym = . , Characteristic = Device operation \uf0a3 3V. , Min = 60. , Max = -. , Units = min.. , Conditions = . , Sym = . , Characteristic = Device operation \uf0b3 3V. , Min = 30. , Max = -. , Units = min.. , Conditions = \nNote 1: These specifications are for the programming of the on-chip program memory EPROM through the use of the table write instructions. The complete programming specifications can be found in the PIC18CXXX Programming Specifications (Literature Number DS39028).\n2: The MCLR/VPP pin may be kept in this range at times other than programming, but is not recommended.",
    "21.3.1 TIMING PARAMETER SYMBOLOGY\nThe  timing  parameter  symbols  have  been  created following one of the following formats:",
    "21.3.1 TIMING PARAMETER SYMBOLOGY\nT, 1. TppS2ppS.2. TppS = T. T, 3. T CC: ST.4. Ts = . T, (I 2 C specifications only) 2.(I C specifications only) = . F, 1. TppS2ppS.2. TppS = Frequency. F, 3. T CC: ST.4. Ts = T. F, (I 2 C specifications only) 2.(I C specifications only) = Time. Lowercase letters (pp) and their meanings:, 1. TppS2ppS.2. TppS = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, 3. T CC: ST.4. Ts = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, (I 2 C specifications only) 2.(I C specifications only) = Lowercase letters (pp) and their meanings:. pp, 1. TppS2ppS.2. TppS = pp. pp, 3. T CC: ST.4. Ts = . pp, (I 2 C specifications only)",
    "21.3.1 TIMING PARAMETER SYMBOLOGY\n2.(I C specifications only) = . cc, 1. TppS2ppS.2. TppS = CCP1. cc, 3. T CC: ST.4. Ts = osc. cc, (I 2 C specifications only) 2.(I C specifications only) = OSC1. ck, 1. TppS2ppS.2. TppS = CLKOUT. ck, 3. T CC: ST.4. Ts = rd. ck, (I 2 C specifications only) 2.(I C specifications only) = RD. cs, 1. TppS2ppS.2. TppS = CS. cs, 3. T CC: ST.4. Ts = rw. cs, (I 2 C specifications only) 2.(I C specifications only) = RD or WR. di, 1. TppS2ppS.2. TppS = SDI. di, 3. T CC: ST.4. Ts = sc. di, (I 2 C specifications only) 2.(I C specifications only) = SCK. do, 1. TppS2ppS.2. TppS = SDO. do, 3.",
    "21.3.1 TIMING PARAMETER SYMBOLOGY\nT CC: ST.4. Ts = ss. do, (I 2 C specifications only) 2.(I C specifications only) = SS. dt, 1. TppS2ppS.2. TppS = Data in. dt, 3. T CC: ST.4. Ts = t0. dt, (I 2 C specifications only) 2.(I C specifications only) = T0CKI. io, 1. TppS2ppS.2. TppS = I/O port. io, 3. T CC: ST.4. Ts = t1. io, (I 2 C specifications only) 2.(I C specifications only) = T1CKI. mc, 1. TppS2ppS.2. TppS = MCLR. mc, 3. T CC: ST.4. Ts = wr. mc, (I 2 C specifications only) 2.(I C specifications only) = WR. Uppercase letters and their meanings:, 1. TppS2ppS.2. TppS = Uppercase letters and their meanings:. Uppercase letters and their meanings:, 3. T CC: ST.4. Ts = Uppercase letters and their",
    "21.3.1 TIMING PARAMETER SYMBOLOGY\nmeanings:. Uppercase letters and their meanings:, (I 2 C specifications only) 2.(I C specifications only) = Uppercase letters and their meanings:. S, 1. TppS2ppS.2. TppS = S. S, 3. T CC: ST.4. Ts = . S, (I 2 C specifications only) 2.(I C specifications only) = . F, 1. TppS2ppS.2. TppS = Fall. F, 3. T CC: ST.4. Ts = P. F, (I 2 C specifications only) 2.(I C specifications only) = Period. H, 1. TppS2ppS.2. TppS = High. H, 3. T CC: ST.4. Ts = R. H, (I 2 C specifications only) 2.(I C specifications only) = Rise. I, 1. TppS2ppS.2. TppS = Invalid (Hi-impedance). I, 3. T CC: ST.4. Ts = V. I, (I 2 C specifications only) 2.(I C specifications only) = Valid. L, 1.",
    "21.3.1 TIMING PARAMETER SYMBOLOGY\nTppS2ppS.2. TppS = Low. L, 3. T CC: ST.4. Ts = Z. L, (I 2 C specifications only) 2.(I C specifications only) = Hi-impedance. I 2 C only, 1. TppS2ppS.2. TppS = I 2 C only. I 2 C only, 3. T CC: ST.4. Ts = . I 2 C only, (I 2 C specifications only) 2.(I C specifications only) = . AA, 1. TppS2ppS.2. TppS = output access. AA, 3. T CC: ST.4. Ts = High. AA, (I 2 C specifications only) 2.(I C specifications only) = High. BUF, 1. TppS2ppS.2. TppS = Bus free. BUF, 3. T CC: ST.4. Ts = Low. BUF, (I 2 C specifications only) 2.(I C specifications only) = Low. T CC: ST (I 2 C specifications only), 1. TppS2ppS.2. TppS = T CC: ST",
    "21.3.1 TIMING PARAMETER SYMBOLOGY\n(I 2 C specifications only). T CC: ST (I 2 C specifications only), 3. T CC: ST.4. Ts = T CC: ST (I 2 C specifications only). T CC: ST (I 2 C specifications only), (I 2 C specifications only) 2.(I C specifications only) = T CC: ST (I 2 C specifications only). CC, 1. TppS2ppS.2. TppS = CC. CC, 3. T CC: ST.4. Ts = . CC, (I 2 C specifications only) 2.(I C specifications only) = . HD, 1. TppS2ppS.2. TppS = Hold. HD, 3. T CC: ST.4. Ts = SU. HD, (I 2 C specifications only) 2.(I C specifications only) = Setup. ST, 1. TppS2ppS.2. TppS = ST. ST, 3. T CC: ST.4. Ts = ST. ST, (I 2 C specifications only) 2.(I C specifications only) = ST. DAT, 1. TppS2ppS.2. TppS",
    "21.3.1 TIMING PARAMETER SYMBOLOGY\n= DATA input hold. DAT, 3. T CC: ST.4. Ts = STO. DAT, (I 2 C specifications only) 2.(I C specifications only) = STOP condition. STA, 1. TppS2ppS.2. TppS = START condition. STA, 3. T CC: ST.4. Ts = . STA, (I 2 C specifications only) 2.(I C specifications only) = ",
    "21.3.2 TIMING CONDITIONS\nThe temperature and voltages specified in Table 21-3 apply  to  all timing  specifications  unless  otherwise noted. Figure 21-4 specifies the load conditions for the timing specifications.",
    "TABLE 21-3: TEMPERATURE AND VOLTAGE SPECIFICATIONS - AC\nAC CHARACTERISTICS, 1 = Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended Operating voltage VDD range as described in DC spec Section 21.1. LC parts operate for industrial temperatures only.",
    "FIGURE 21-4: LOAD CONDITIONS FOR DEVICE TIMING SPECIFICATIONS\n, Load condition 1 = VDD /2 CL RL VSS RL = 464 CL = 50",
    "TABLE 21-4: EXTERNAL CLOCK TIMING REQUIREMENTS\n1A, Symbol = FOSC. 1A, Characteristic = External CLKIN Frequency (1). 1A, Min = DC DC 4 DC DC. 1A, Max = 4 25 10 40 40. 1A, Units = MHz MHz MHz kHz MHz. 1A, Conditions = XT osc HS osc HS + PLL osc LP osc EC, ECIO. 1A, Symbol = FOSC. 1A, Characteristic = Oscillator Frequency (1). 1A, Min = DC 0.1 4 4 5. 1A, Max = 4 4 25 10 200. 1A, Units = MHz MHz MHz MHz kHz. 1A, Conditions = RC osc XT osc HS osc HS + PLL osc LP osc mode. 1, Symbol = T OSC. 1, Characteristic = External CLKIN Period (1). 1, Min = 250 40 100 25 25. 1, Max = - - 250 - -. 1, Units = ns ns ns \uf06d s ns. 1, Conditions = XT and RC osc HS osc HS + PLL osc LP osc EC, ECIO. 1, Symbol = T OSC. 1, Characteristic = Oscillator Period",
    "TABLE 21-4: EXTERNAL CLOCK TIMING REQUIREMENTS\n(1). 1, Min = 250 250 25 100. 1, Max = - 10,000 250 250 -. 1, Units = ns ns ns ns \uf06d s. 1, Conditions = RC osc XT osc HS osc HS + PLL osc LP osc. 2, Symbol = T CY. 2, Characteristic = Instruction Cycle Time (1). 2, Min = 100. 2, Max = -. 2, Units = ns. 2, Conditions = T CY = 4/F OSC. 3, Symbol = TosL, TosH. 3, Characteristic = External Clock in (OSC1) High or Low Time. 3, Min = 30 2.5 10. 3, Max = - - -. 3, Units = ns \uf06d s ns. 3, Conditions = XT osc LP osc HS osc. 4, Symbol = TosR, TosF. 4, Characteristic = External Clock in (OSC1) Rise or Fall Time. 4, Min = - - -. 4, Max = 20 50 7.5. 4, Units = ns ns ns. 4, Conditions = XT osc LP osc",
    "TABLE 21-4: EXTERNAL CLOCK TIMING REQUIREMENTS\nNote 1: Instruction cycle period (TCY) equals four times the input oscillator time-base period for all configurations except PLL. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min.' values with an external clock applied to the OSC1/CLKIN pin. When an external clock input is used, the 'max.' cycle time limit is 'DC' (no clock) for all devices.\nTABLE 21-5: PLL CLOCK TIMING SPECIFICATION (VDD = 4.2V - 5.5V)\n\n, Symbol = TRC. , Characteristic = PLL Start-up Time (Lock Time). , Min = -. , Max = 2. , Units = ms. , Conditions = . , Symbol = \uf044 CLK. , Characteristic = CLKOUT Stability (Jitter) using PLL. , Min = -2. , Max = +2. , Units = %. , Conditions = ",
    "TABLE 21-6: CLKOUT AND I/O TIMING REQUIREMENTS\n10, Symbol = TosH2ckL. 10, Characteristic = OSC1 \uf0ad to CLKOUT \uf0af. 10, Characteristic = OSC1 \uf0ad to CLKOUT \uf0af. 10, Min = -. 10, Typ = 75. 10, Max = 200. 10, Units = ns. 10, Conditions = (1). 11, Symbol = TosH2ckH. 11, Characteristic = OSC1 \uf0ad to CLKOUT \uf0ad. 11, Characteristic = OSC1 \uf0ad to CLKOUT \uf0ad. 11, Min = -. 11, Typ = 75. 11, Max = 200. 11, Units = ns. 11, Conditions = (1). 12, Symbol = TckR. 12, Characteristic = CLKOUT rise time. 12, Characteristic = CLKOUT rise time. 12, Min = -. 12, Typ = 35. 12, Max = 100. 12, Units = ns. 12, Conditions = (1). 13, Symbol = TckF. 13, Characteristic = CLKOUT fall time. 13, Characteristic = CLKOUT fall time. 13, Min = -. 13, Typ = 35. 13, Max = 100.",
    "TABLE 21-6: CLKOUT AND I/O TIMING REQUIREMENTS\n13, Units = ns. 13, Conditions = (1). 14, Symbol = TckL2ioV. 14, Characteristic = CLKOUT \uf0af to Port out valid. 14, Characteristic = CLKOUT \uf0af to Port out valid. 14, Min = -. 14, Typ = -. 14, Max = 0.5T CY + 20. 14, Units = ns. 14, Conditions = (1). 15, Symbol = TioV2ckH. 15, Characteristic = Port in valid before CLKOUT \uf0ad. 15, Characteristic = Port in valid before CLKOUT \uf0ad. 15, Min = 0.25T CY + 25. 15, Typ = -. 15, Max = -. 15, Units = ns. 15, Conditions = (1). 16, Symbol = TckH2ioI. 16, Characteristic = Port in hold after CLKOUT \uf0ad. 16, Characteristic = Port in hold after CLKOUT \uf0ad. 16, Min = 0. 16, Typ = -. 16, Max = -. 16, Units = ns. 16, Conditions = (1). 17, Symbol = TosH2ioV. 17, Characteristic =",
    "TABLE 21-6: CLKOUT AND I/O TIMING REQUIREMENTS\nOSC1 \uf0ad (Q1 cycle) to Port out valid. 17, Characteristic = OSC1 \uf0ad (Q1 cycle) to Port out valid. 17, Min = -. 17, Typ = 50. 17, Max = 150. 17, Units = ns. 17, Conditions = . 18 18A, Symbol = TosH2ioI. 18 18A, Characteristic = OSC1 \uf0ad (Q2 cycle) to Port input invalid (I/O in hold time). 18 18A, Characteristic = PIC18 C XXX. 18 18A, Min = 100. 18 18A, Typ = -. 18 18A, Max = -. 18 18A, Units = ns. 18 18A, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LC XXX. , Min = 200. , Typ = -. , Max = -. , Units = ns. , Conditions = . 19, Symbol = TioV2osH. 19, Characteristic = Port input valid to OSC1 \uf0ad\uf020 (I/O in setup time). 19, Characteristic = Port input valid to OSC1 \uf0ad\uf020 (I/O in setup time).",
    "TABLE 21-6: CLKOUT AND I/O TIMING REQUIREMENTS\n19, Min = 0. 19, Typ = -. 19, Max = -. 19, Units = ns. 19, Conditions = . 20, Symbol = TioR. 20, Characteristic = Port output rise time. 20, Characteristic = PIC18 C XXX. 20, Min = -. 20, Typ = 12. 20, Max = 25. 20, Units = ns. 20, Conditions = . 20A, Symbol = . 20A, Characteristic = . 20A, Characteristic = PIC18 LC XXX. 20A, Min = -. 20A, Typ = -. 20A, Max = 50. 20A, Units = ns. 20A, Conditions = . 21, Symbol = TioF. 21, Characteristic = Port output fall time. 21, Characteristic = PIC18 C XXX. 21, Min = -. 21, Typ = 12. 21, Max = 25. 21, Units = ns. 21, Conditions = . 21A, Symbol = . 21A, Characteristic = . 21A, Characteristic = PIC18 LC XXX. 21A, Min = -. 21A, Typ = -. 21A, Max",
    "TABLE 21-6: CLKOUT AND I/O TIMING REQUIREMENTS\n= 50. 21A, Units = ns. 21A, Conditions = . 22\u2020\u2020, Symbol = TINP. 22\u2020\u2020, Characteristic = INT pin high or low time. 22\u2020\u2020, Characteristic = INT pin high or low time. 22\u2020\u2020, Min = T CY. 22\u2020\u2020, Typ = -. 22\u2020\u2020, Max = -. 22\u2020\u2020, Units = ns. 22\u2020\u2020, Conditions = . 23\u2020\u2020, Symbol = TRBP. 23\u2020\u2020, Characteristic = RB7:RB4 change INT high or low time. 23\u2020\u2020, Characteristic = RB7:RB4 change INT high or low time. 23\u2020\u2020, Min = T CY. 23\u2020\u2020, Typ = -. 23\u2020\u2020, Max = -. 23\u2020\u2020, Units = ns. 23\u2020\u2020, Conditions = . 24\u2020\u2020, Symbol = TRCP. 24\u2020\u2020, Characteristic = RC7:RC4 change INT high or low time. 24\u2020\u2020, Characteristic = RC7:RC4 change INT high or low time. 24\u2020\u2020, Min = 20. 24\u2020\u2020, Typ = .",
    "TABLE 21-6: CLKOUT AND I/O TIMING REQUIREMENTS\n24\u2020\u2020, Max = . 24\u2020\u2020, Units = ns. 24\u2020\u2020, Conditions = \n\u2020\u2020 These parameters are asynchronous events not related to any internal clock edges.\nNote 1: Measurements are taken in RC mode where CLKOUT output is 4 x TOSC.",
    "PIC18CXX2\nFIGURE 21-7: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER AND POWER-UP",
    "FIGURE 21-8: BROWN-OUT RESET TIMING\nTABLE 21-7: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS",
    "FIGURE 21-8: BROWN-OUT RESET TIMING\n30, Symbol = TmcL. 30, Characteristic = MCLR Pulse Width (low). 30, Min = 2. 30, Typ = -. 30, Max = -. 30, Units = \uf06d s. 30, Conditions = . 31, Symbol = TWDT. 31, Characteristic = Watchdog Timer Time-out Period (No Postscaler). 31, Min = 7. 31, Typ = 18. 31, Max = 33. 31, Units = ms. 31, Conditions = . 32, Symbol = T OST. 32, Characteristic = Oscillation Start-up Timer Period. 32, Min = 1024T OSC. 32, Typ = -. 32, Max = 1024T OSC. 32, Units = -. 32, Conditions = T OSC = OSC1 period. 33, Symbol = TPWRT. 33, Characteristic = Power up Timer Period. 33, Min = 28. 33, Typ = 72. 33, Max = 132. 33, Units = ms. 33, Conditions = . 34, Symbol = T IOZ. 34, Characteristic = I/O Hi-impedance from MCLR Low or Watchdog",
    "FIGURE 21-8: BROWN-OUT RESET TIMING\nTimer Reset. 34, Min = -. 34, Typ = 2. 34, Max = -. 34, Units = \uf06d s. 34, Conditions = . 35, Symbol = TBOR. 35, Characteristic = Brown-out Reset Pulse Width. 35, Min = 200. 35, Typ = -. 35, Max = -. 35, Units = \uf06d s. 35, Conditions = VDD \uf0a3 BVDD (See D005). 36, Symbol = Tivrst. 36, Characteristic = Time for Internal Reference Voltage to become stable. 36, Min = -. 36, Typ = 20. 36, Max = 50. 36, Units = \uf06d s. 36, Conditions = ",
    "TABLE 21-8: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n40, Symbol = Tt0H. 40, Characteristic = T0CKI High Pulse Width No Prescaler. 40,  = . 40, Min = 0.5T CY + 20. 40, Max = -. 40, Units = ns. 40, Conditions = . , Symbol = . , Characteristic = With. ,  = . , Min = Prescaler. , Max = 10 -. , Units = ns. , Conditions = . 41, Symbol = Tt0L. 41, Characteristic = T0CKI Low Pulse Width. 41,  = . 41, Min = No Prescaler. 41, Max = 0.5T CY + 20. 41, Units = - ns. 41, Conditions = . , Symbol = . , Characteristic = . ,  = . , Min = With Prescaler. , Max = 10 -. , Units = ns. , Conditions = . 42, Symbol = Tt0P. 42, Characteristic = T0CKI Period. 42,  = . 42, Min = Prescaler T CY +. 42, Max = 10 -. 42, Units = ns. 42, Conditions = . , Symbol = . , Characteristic = No With. ,",
    "TABLE 21-8: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n= . , Min = Prescaler Greater 20 nS or T CY. , Max = of: -. , Units = ns. , Conditions = N = prescale value (1, 2, 4,..., 256). 45, Symbol = Tt1H. 45, Characteristic = T1CKI High Time. 45,  = Synchronous, no prescaler 0.5T. 45, Min = . 45, Max = CY + 20 -. 45, Units = ns. 45, Conditions = . , Symbol = . , Characteristic = . ,  = Synchronous, with prescaler. , Min = PIC18 C XXX 10. , Max = -. , Units = ns. , Conditions = . , Symbol = . , Characteristic = . ,  = . , Min = PIC18 LC XXX 25. , Max = -. , Units = ns. , Conditions = . , Symbol = . , Characteristic = . ,  = Asynchronous. , Min = PIC18 C XXX 30. , Max = -. , Units = ns. , Conditions = . , Symbol = . , Characteristic = . ,",
    "TABLE 21-8: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n= . , Min = PIC18 LC XXX 40. , Max = -. , Units = ns. , Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI Low Synchronous, no prescaler 0.5T CY + 20. 46,  = . 46, Min = . 46, Max = -. 46, Units = ns. 46, Conditions = . , Symbol = . , Characteristic = . ,  = Synchronous, with prescaler. , Min = PIC18 C XXX 15. , Max = -. , Units = ns. , Conditions = . , Symbol = . , Characteristic = Time. ,  = . , Min = PIC18 LC XXX 30. , Max = -. , Units = ns. , Conditions = . , Symbol = . , Characteristic = . ,  = Asynchronous. , Min = PIC18 C XXX 30. , Max = -. , Units = ns. , Conditions = . , Symbol = . , Characteristic = . ,",
    "TABLE 21-8: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n= . , Min = 40. , Max = -. , Units = ns. , Conditions = . 47, Symbol = Tt1P. 47, Characteristic = T1CKI input period. 47,  = PIC18 LC XXX Synchronous 20. 47, Min = . 47, Max = Greater of: nS or T CY + 40 N. 47, Units = - ns. 47, Conditions = N = prescale value (1, 2, 4, 8). , Symbol = . , Characteristic = . ,  = Asynchronous. , Min = . , Max = 60. , Units = - ns. , Conditions = . , Symbol = Ft1. , Characteristic = T1CKI oscillator input frequency range. ,  = . , Min = . , Max = DC. , Units = 50 kHz. , Conditions = . 48, Symbol = Tcke2tmrI. 48, Characteristic = Delay from external T1CKI clock edge to timer increment. 48,  = . 48, Min = . 48, Max = 2T OSC. 48, Units = 7T OSC -. 48, Conditions = ",
    "TABLE 21-9: CAPTURE/COMPARE/PWM REQUIREMENTS (CCP1 AND CCP2)\n50, Symbol = TccL. 50, Characteristic = CCPxinput low time. 50, Characteristic = No Prescaler. 50, Characteristic = No Prescaler. 50, Min = 0.5T CY + 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPxinput low time. 50, Characteristic = With Prescaler. 50, Characteristic = PIC18 C XXX. 50, Min = 10. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPxinput low time. 50, Characteristic = With Prescaler. 50, Characteristic = PIC18 LC XXX. 50, Min = 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx input high time. 51, Characteristic = No Prescaler. 51, Characteristic = No Prescaler. 51, Min = 0.5T CY + 20.",
    "TABLE 21-9: CAPTURE/COMPARE/PWM REQUIREMENTS (CCP1 AND CCP2)\n51, Max = -. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx input high time. 51, Characteristic = With Prescaler. 51, Characteristic = PIC18 C XXX. 51, Min = 10. 51, Max = -. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx input high time. 51, Characteristic = With Prescaler. 51, Characteristic = PIC18 LC XXX. 51, Min = 20. 51, Max = -. 51, Units = ns. 51, Conditions = . 52, Symbol = TccP. 52, Characteristic = CCPx input period. 52, Characteristic = CCPx input period. 52, Characteristic = CCPx input period. 52, Min = 3T CY + 40 N. 52, Max = -. 52, Units = ns. 52, Conditions = N = prescale value (1,4 or 16). 53, Symbol = TccR. 53, Characteristic = CCPx output fall time.",
    "TABLE 21-9: CAPTURE/COMPARE/PWM REQUIREMENTS (CCP1 AND CCP2)\n53, Characteristic = CCPx output fall time. 53, Characteristic = PIC18 C XXX. 53, Min = -. 53, Max = 25. 53, Units = ns. 53, Conditions = . 53, Symbol = TccR. 53, Characteristic = . 53, Characteristic = . 53, Characteristic = PIC18 LC XXX. 53, Min = -. 53, Max = 50. 53, Units = ns. 53, Conditions = . 54, Symbol = TccF. 54, Characteristic = CCPx output fall time. 54, Characteristic = CCPx output fall time. 54, Characteristic = PIC18 C XXX. 54, Min = -. 54, Max = 25. 54, Units = ns. 54, Conditions = . 54, Symbol = TccF. 54, Characteristic = . 54, Characteristic = . 54, Characteristic = PIC18 LC XXX. 54, Min = -. 54, Max = 50. 54, Units = ns. 54, Conditions = ",
    "TABLE 21-10: PARALLEL SLAVE PORT REQUIREMENTS (PIC18C4X2)\n62, Symbol = TdtV2wrH. 62, Characteristic = Data in valid before WR \uf0ad or CS \uf0ad (setup time). 62, Min = 20 25. 62, Max = - -. 62, Units = ns ns. 62, Conditions = Extended Temp. Range. 63, Symbol = TwrH2dtI. 63, Characteristic = WR \uf0ad or CS \uf0ad to data-in invalid (hold time) PIC18 PIC18. 63, Min = 20. 63, Max = -. 63, Units = ns. 63, Conditions = . 64, Symbol = TrdL2dtV. 64, Characteristic = RD \uf0af and CS \uf0af to data-out valid. 64, Min = - -. 64, Max = 80 90. 64, Units = ns ns. 64, Conditions = Extended Temp. Range. 65, Symbol = TrdH2dtI. 65, Characteristic = RD \uf0ad or CS \uf0ad to data-out invalid. 65, Min = 10. 65, Max = 30. 65, Units = ns. 65, Conditions = . 66, Symbol = TibfINH. 66, Characteristic = Inhibit of the IBF flag bit being cleared from WR \uf0ad or CS \uf0ad.",
    "TABLE 21-10: PARALLEL SLAVE PORT REQUIREMENTS (PIC18C4X2)\n66, Min = -. 66, Max = 3T CY. 66, Units = . 66, Conditions = ",
    "TABLE 21-11: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0)\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK input high time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = TscH. 71A, Characteristic = SCK input high time (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK input low time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions",
    "TABLE 21-11: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0)\n= . 72A, Symbol = TscL. 72A, Characteristic = SCK input low time (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup time of SDI data input to SCK edge. 73, Characteristic = Setup time of SDI data input to SCK edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last clock edge of Byte1 to the 1st clock edge of Byte2. 73A, Characteristic = Last clock edge of Byte1 to the 1st clock edge of Byte2. 73A, Min = 1.5T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL.",
    "TABLE 21-11: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0)\n74, Characteristic = Hold time of SDI data input to SCK edge. 74, Characteristic = Hold time of SDI data input to SCK edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75, Characteristic = PIC18 C XXX. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75, Characteristic = PIC18 LC XXX. 75, Min = -. 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO data output fall time. 76, Characteristic = SDO data output fall time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK output rise time (Master mode). 78, Characteristic = PIC18 C",
    "TABLE 21-11: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0)\nXXX. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK output rise time (Master mode). 78, Characteristic = PIC18 LC XXX. 78, Min = -. 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK output fall time (Master mode). 79, Characteristic = SCK output fall time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO data output valid after SCK edge. 80, Characteristic = PIC18 C XXX. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO data output valid after SCK edge. 80, Characteristic =",
    "TABLE 21-11: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0)\nPIC18 LC XXX. 80, Min = -. 80, Max = 100. 80, Units = ns. 80, Conditions = \nNote 1: Requires the use of Parameter # 73A.\n2: Only if Parameter # 71A and # 72A are used.",
    "TABLE 21-12: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1)\n71, Symbol = TscH. 71, Characteristic = SCK input high time. 71, Characteristic = Continuous. 71, Min = 1.25T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = . 71A, Characteristic = (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK input low time. 72, Characteristic = Continuous. 72, Min = 1.25T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = . 72A, Characteristic = (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup time of",
    "TABLE 21-12: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1)\nSDI data input to SCK edge. 73, Characteristic = Setup time of SDI data input to SCK edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last clock edge of Byte1 to the 1st clock edge of Byte2. 73A, Characteristic = Last clock edge of Byte1 to the 1st clock edge of Byte2. 73A, Min = 1.5T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold time of SDI data input to SCK edge. 74, Characteristic = Hold time of SDI data input to SCK edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75, Characteristic = PIC18 C XXX. 75, Min =",
    "TABLE 21-12: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1)\n-. 75, Max = 25. 75, Units = ns. 75, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LC XXX. , Min = . , Max = 45. , Units = ns. , Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO data output fall time. 76, Characteristic = SDO data output fall time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK output rise time. 78, Characteristic = PIC18 C XXX. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . , Symbol = . , Characteristic = (Master mode). , Characteristic = PIC18 LC XXX. , Min = . , Max = 45. , Units = ns. , Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK output fall time (Master mode). 79, Characteristic = SCK output fall time (Master mode). 79, Min = -.",
    "TABLE 21-12: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1)\n79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV,. 80, Characteristic = SDO data output valid after. 80, Characteristic = PIC18 C XXX. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . , Symbol = TscL2doV. , Characteristic = SCK edge. , Characteristic = PIC18 LC XXX. , Min = . , Max = 100. , Units = ns. , Conditions = . 81, Symbol = TdoV2scH, TdoV2scL. 81, Characteristic = SDO data output setup to SCK edge. 81, Characteristic = SDO data output setup to SCK edge. 81, Min = T CY. 81, Max = -. 81, Units = ns. 81, Conditions = \nNote 1: Requires the use of Parameter # 73A.\n2: Only if Parameter # 71A and # 72A are used.",
    "FIGURE 21-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0)\nTABLE 21-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING (CKE = 0))",
    "FIGURE 21-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0)\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK input high time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = TscH. 71A, Characteristic = SCK input high time (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK input low time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = .",
    "FIGURE 21-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0)\n72A, Symbol = TscL. 72A, Characteristic = SCK input low time (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup time of SDI data input to SCK edge. 73, Characteristic = Setup time of SDI data input to SCK edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last clock edge of Byte1 to the first clock edge of Byte2. 73A, Characteristic = Last clock edge of Byte1 to the first clock edge of Byte2. 73A, Min = 1.5T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold",
    "FIGURE 21-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0)\ntime of SDI data input to SCK edge. 74, Characteristic = Hold time of SDI data input to SCK edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75, Characteristic = PIC18 C XXX. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75, Characteristic = PIC18 LC XXX. 75, Min = . 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO data output fall time. 76, Characteristic = SDO data output fall time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = TssH2doZ. 77, Characteristic = SS \uf0ad to SDO output hi-impedance. 77, Characteristic = SS \uf0ad to SDO output",
    "FIGURE 21-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0)\nhi-impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK output rise time (Master mode). 78, Characteristic = PIC18 C XXX. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK output rise time (Master mode). 78, Characteristic = PIC18 LC XXX. 78, Min = . 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK output fall time (Master mode). 79, Characteristic = SCK output fall time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO data output valid after SCK edge. 80, Characteristic = PIC18 C XXX. 80, Min =",
    "FIGURE 21-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0)\n-. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO data output valid after SCK edge. 80, Characteristic = PIC18 LC XXX. 80, Min = . 80, Max = 100. 80, Units = ns. 80, Conditions = . 83, Symbol = TscH2ssH, TscL2ssH. 83, Characteristic = SS \uf0ad after SCK edge. 83, Characteristic = SS \uf0ad after SCK edge. 83, Min = 1.5T CY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = \nNote 1: Requires the use of Parameter # 73A.\n2: Only if Parameter # 71A and # 72A are used.\nFIGURE 21-15: EXAMPLE SPI SLAVE MODE TIMING (CKE = 1)\n\nTABLE 21-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1)",
    "FIGURE 21-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0)\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK input high time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = TscH. 71A, Characteristic = SCK input high time (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK input low time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = .",
    "FIGURE 21-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0)\n72A, Symbol = TscL. 72A, Characteristic = SCK input low time (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73A, Symbol = TB2B. 73A, Characteristic = Last clock edge of Byte1 to the first clock edge of Byte2. 73A, Characteristic = Last clock edge of Byte1 to the first clock edge of Byte2. 73A, Min = 1.5T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold time of SDI data input to SCK edge. 74, Characteristic = Hold time of SDI data input to SCK edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75,",
    "FIGURE 21-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0)\nCharacteristic = PIC18 C XXX. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75, Characteristic = PIC18 LC XXX. 75, Min = . 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO data output fall time. 76, Characteristic = SDO data output fall time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = TssH2doZ. 77, Characteristic = SS \uf0ad to SDO output hi-impedance. 77, Characteristic = SS \uf0ad to SDO output hi-impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK output rise time (Master mode). 78, Characteristic = PIC18 C XXX. 78, Min = -. 78, Max = 25. 78,",
    "FIGURE 21-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0)\nUnits = ns. 78, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK output rise time (Master mode). 78, Characteristic = PIC18 LC XXX. 78, Min = -. 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK output fall time (Master mode). 79, Characteristic = SCK output fall time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO data output valid after SCK edge. 80, Characteristic = PIC18 C XXX. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO data output valid after SCK edge. 80, Characteristic = PIC18 LC XXX. 80, Min = -. 80, Max = 100. 80,",
    "FIGURE 21-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0)\nUnits = ns. 80, Conditions = . 82, Symbol = TssL2doV. 82, Characteristic = SDO data output valid after SS \uf0af edge. 82, Characteristic = PIC18 C XXX. 82, Min = -. 82, Max = 50. 82, Units = ns. 82, Conditions = . 82, Symbol = TssL2doV. 82, Characteristic = SDO data output valid after SS \uf0af edge. 82, Characteristic = PIC18 LC XXX. 82, Min = -. 82, Max = 100. 82, Units = ns. 82, Conditions = . 83, Symbol = TscH2ssH, TscL2ssH. 83, Characteristic = SS \uf0ad after SCK edge. 83, Characteristic = SS \uf0ad after SCK edge. 83, Min = 1.5T CY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = \nNote 1: Requires the use of Parameter # 73A.\n2: Only if Parameter # 71A and # 72A are used.",
    "TABLE 21-15: I 2 C BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n90, Symbol = Tsu:sta. 90, Characteristic = START condition Setup time. 90, Characteristic = 100 kHz mode. 90, Min = 4700. 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated START condition. 90, Symbol = Tsu:sta. 90, Characteristic = START condition Setup time. 90, Characteristic = 400 kHz mode. 90, Min = 600. 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated START condition. 91, Symbol = Thd:sta. 91, Characteristic = START condition Hold time. 91, Characteristic = 100 kHz mode. 91, Min = 4000. 91, Max = -. 91, Units = ns. 91, Conditions = After this period the first clock pulse is generated. 91, Symbol = Thd:sta. 91, Characteristic = START condition Hold time. 91, Characteristic = 400 kHz mode. 91, Min = 600. 91, Max = -. 91, Units = ns. 91, Conditions = After this period the first clock pulse is generated. 92, Symbol =",
    "TABLE 21-15: I 2 C BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\nTsu:sto. 92, Characteristic = STOP condition. 92, Characteristic = 100 kHz mode. 92, Min = 4700. 92, Max = -. 92, Units = ns. 92, Conditions = . 92, Symbol = Tsu:sto. 92, Characteristic = Setup time. 92, Characteristic = 400 kHz mode. 92, Min = 600. 92, Max = -. 92, Units = ns. 92, Conditions = . 93, Symbol = Thd:sto. 93, Characteristic = STOP condition. 93, Characteristic = 100 kHz mode. 93, Min = 4000. 93, Max = -. 93, Units = ns. 93, Conditions = . 93, Symbol = Thd:sto. 93, Characteristic = Hold time. 93, Characteristic = 400 kHz mode. 93, Min = 600. 93, Max = -. 93, Units = ns. 93, Conditions = ",
    "TABLE 21-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = 100 kHz mode. 100, Min = 4.0. 100, Max = -. 100, Units = \uf06d s. 100, Conditions = PIC18CXXX must operate at a minimum of 1.5 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = 400 kHz mode. 100, Min = 0.6. 100, Max = -. 100, Units = \uf06d s. 100, Conditions = PIC18CXXX must operate at a minimum of 10 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = SSP Module. 100, Min = 1.5T CY. 100, Max = -. 100, Units = . 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock low time. 101, Characteristic = 100 kHz mode. 101, Min = 4.7. 101, Max = -. 101, Units = \uf06d s. 101, Conditions = PIC18CXXX must operate at a minimum of 1.5 MHz. 101, Symbol = TLOW.",
    "TABLE 21-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n101, Characteristic = Clock low time. 101, Characteristic = 400 kHz mode. 101, Min = 1.3. 101, Max = -. 101, Units = \uf06d s. 101, Conditions = PIC18CXXX must operate at a minimum of 10 MHz. 101, Symbol = TLOW. 101, Characteristic = Clock low time. 101, Characteristic = SSP Module. 101, Min = 1.5T CY. 101, Max = -. 101, Units = . 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL rise time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL rise time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1C B. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL fall time. 103, Characteristic =",
    "TABLE 21-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = . 103, Symbol = TF. 103, Characteristic = SDA and SCL fall time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1C B. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 90, Symbol = T SU: STA. 90, Characteristic = START condition setup time. 90, Characteristic = 100 kHz mode. 90, Min = 4.7. 90, Max = -. 90, Units = \uf06d s. 90, Conditions = Only relevant for Repeated START condition. 90, Symbol = T SU: STA. 90, Characteristic = START condition setup time. 90, Characteristic = 400 kHz mode. 90, Min = 0.6. 90, Max = -. 90, Units = \uf06d s. 90, Conditions = Only relevant for Repeated START condition. 91, Symbol = THD: STA. 91, Characteristic = START condition hold time. 91, Characteristic = 100 kHz mode. 91, Min =",
    "TABLE 21-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n4.0. 91, Max = -. 91, Units = \uf06d s. 91, Conditions = After this period the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = START condition hold time. 91, Characteristic = 400 kHz mode. 91, Min = 0.6. 91, Max = -. 91, Units = \uf06d s. 91, Conditions = After this period the first clock pulse is generated. 106, Symbol = THD: DAT. 106, Characteristic = Data input hold time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD: DAT. 106, Characteristic = Data input hold time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = \uf06d s. 106, Conditions = . 107, Symbol = T SU: DAT. 107, Characteristic = Data input setup time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107, Units = ns. 107, Conditions = (Note",
    "TABLE 21-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n2). 107, Symbol = T SU: DAT. 107, Characteristic = Data input setup time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = T SU: STO. 92, Characteristic = STOP condition setup time. 92, Characteristic = 100 kHz mode. 92, Min = 4.7. 92, Max = -. 92, Units = \uf06d s. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = STOP condition setup time. 92, Characteristic = 400 kHz mode. 92, Min = 0.6. 92, Max = -. 92, Units = \uf06d s. 92, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output valid from clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109, Units = ns. 109, Conditions = (Note 1). 109, Symbol = T AA. 109, Characteristic = Output valid from clock. 109, Characteristic = 400 kHz mode. 109, Min =",
    "TABLE 21-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n-. 109, Max = -. 109, Units = ns. 109, Conditions = (Note 1). 110, Symbol = TBUF. 110, Characteristic = Bus free time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = \uf06d s. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus free time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = \uf06d s. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus capacitive loading. D102, Characteristic = Bus capacitive loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = ",
    "TABLE 21-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\nNote 1: As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of START or STOP conditions.\n2: A fast mode I 2 C bus device can be used in a standard mode I 2 C bus system, but the requirement TSU:DAT \uf0b3 250 ns must then be met. This will automatically be the case if the device does not stretch the LOW period of the SCL signal. If such a\ndevice does stretch the LOW period of the SCL signal, it must output the next data bit to the SDA line. TR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the standard mode I 2 C bus specification) before the SCL line is\nreleased.",
    "TABLE 21-17: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\n\nNote 1: Maximum pin capacitance = 10 pF for all I 2 C pins.",
    "TABLE 21-17: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\n90, Symbol = T SU: STA. 90, Characteristic = START condition. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated START condition. 90, Symbol = T SU: STA. 90, Characteristic = Setup time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated START condition. 90, Symbol = T SU: STA. 90, Characteristic = Setup time. 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated START condition. 91, Symbol = THD: STA. 91, Characteristic = START condition. 91, Characteristic = 100 kHz mode. 91, Min = 2(T OSC)(BRG +",
    "TABLE 21-17: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\n1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Hold time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Hold time. 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period the first clock pulse is generated. 92, Symbol = T SU: STO. 92, Characteristic = STOP condition. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 92, Symbol = T SU: STO. 92,",
    "TABLE 21-17: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\nCharacteristic = Setup time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 92, Symbol = T SU: STO. 92, Characteristic = Setup time. 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 93, Symbol = THD: STO. 93, Characteristic = STOP condition. 93, Characteristic = 100 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = . 93, Symbol = THD: STO. 93, Characteristic = Hold time. 93, Characteristic = 400 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = . 93, Symbol = THD: STO. 93,",
    "TABLE 21-17: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\nCharacteristic = Hold time. 93, Characteristic = 1 MHz mode (1). 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = ",
    "TABLE 21-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = 100 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = 400 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = 1 MHz mode (1). 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock low time. 101, Characteristic = 100 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock low",
    "TABLE 21-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\ntime. 101, Characteristic = 400 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock low time. 101, Characteristic = 1 MHz mode (1). 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL rise time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA and SCL rise time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1C B. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA",
    "TABLE 21-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\nand SCL rise time. 102, Characteristic = 1 MHz mode (1). 102, Min = -. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL fall time. 103, Characteristic = 100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL fall time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1C B. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL fall time. 103, Characteristic = 1 MHz mode (1). 103, Min = -. 103, Max = 100. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400",
    "TABLE 21-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\npF. 90, Symbol = T SU: STA. 90, Characteristic = STARTcondition setup time. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated START condition. 90, Symbol = T SU: STA. 90, Characteristic = STARTcondition setup time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated START condition. 90, Symbol = T SU: STA. 90, Characteristic = STARTcondition setup time. 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated START condition. 91, Symbol = THD: STA. 91, Characteristic = STARTcondition hold time. 91, Characteristic = 100 kHz mode. 91, Min =",
    "TABLE 21-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = STARTcondition hold time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = STARTcondition hold time. 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period the first clock pulse is generated. 106, Symbol = THD: DAT. 106, Characteristic = Data input hold time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD: DAT.",
    "TABLE 21-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n106, Characteristic = Data input hold time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = ms. 106, Conditions = . 106, Symbol = THD: DAT. 106, Characteristic = Data input hold time. 106, Characteristic = 1 MHz mode (1). 106, Min = TBD. 106, Max = -. 106, Units = ns. 106, Conditions = . 107, Symbol = T SU: DAT. 107, Characteristic = Data input setup time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = T SU: DAT. 107, Characteristic = Data input setup time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = T SU: DAT. 107, Characteristic = Data input setup time. 107, Characteristic = 1 MHz mode (1). 107, Min = TBD. 107, Max =",
    "TABLE 21-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n-. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = T SU: STO. 92, Characteristic = STOP condition setup time. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = STOP condition setup time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = STOP condition setup time. 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output valid from clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109,",
    "TABLE 21-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\nUnits = ns. 109, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output valid from clock. 109, Characteristic = 400 kHz mode. 109, Min = -. 109, Max = 1000. 109, Units = ns. 109, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output valid from clock. 109, Characteristic = 1 MHz mode (1). 109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = . 110, Symbol = TBUF. 110, Characteristic = Bus free time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus free time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus free time.",
    "TABLE 21-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n110, Characteristic = 1 MHz mode (1). 110, Min = TBD. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = capacitive loading. D102, Characteristic = capacitive loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = \n2: A fast mode I 2 C bus device can be used in a standard mode I 2 C bus system, but parameter #107 \uf0b3 250 ns must then be met. This will automatically be the case if the device does not stretch the LOW period of the SCL signal. If such a device does stretch the LOW period of the SCL signal, it must output the next data bit to the SDA line, parameter #102 + parameter #107 = 1000 + 250 = 1250 ns (for 100 kHz mode) before the SCL line is released.\nNote 1: Maximum pin capacitance = 10 pF for all I 2 C pins.",
    "TABLE 21-19: USART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n120, Symbol = TckH2dtV. 120, Characteristic = SYNC XMIT (MASTER & SLAVE) Clock high to data out valid. 120, Characteristic = PIC18 C XXX. 120, Min = -. 120, Max = 40. 120, Units = ns. 120, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LC XXX. , Min = -. , Max = 100. , Units = ns. , Conditions = . 121, Symbol = Tckrf. 121, Characteristic = Clock out rise time and fall time. 121, Characteristic = PIC18 C XXX. 121, Min = -. 121, Max = 25. 121, Units = ns. 121, Conditions = . , Symbol = . , Characteristic = (Master mode). , Characteristic = PIC18 LC XXX. , Min = -. , Max = 50. , Units = ns. , Conditions = . 122, Symbol = Tdtrf. 122, Characteristic = Data out rise time and fall time. 122, Characteristic = PIC18 C XXX. 122, Min = -. 122, Max = 25. 122, Units = ns. 122, Conditions =",
    "TABLE 21-19: USART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n. , Symbol = . , Characteristic = . , Characteristic = PIC18 LC XXX. , Min = -. , Max = 50. , Units = ns. , Conditions = ",
    "TABLE 21-20: USART SYNCHRONOUS RECEIVE REQUIREMENTS\n125, Symbol = TdtV2ckl. 125, Characteristic = SYNC RCV (MASTER & SLAVE) Data hold before CK \uf0af (DT hold time). 125, Min = 10. 125, Max = -. 125, Units = ns. 125, Conditions = . 126, Symbol = TckL2dtl. 126, Characteristic = Data hold after CK \uf0af (DT hold time). 126, Min = 15. 126, Max = -. 126, Units = ns. 126, Conditions = ",
    "TABLE 21-21: A/D CONVERTER CHARACTERISTICS: PIC18CXX2 (INDUSTRIAL, EXTENDED) PIC18LCXX2 (INDUSTRIAL)\nA01, Symbol = NR. A01, Characteristic = Resolution. A01, Characteristic = Resolution. A01, Min = - -. A01, Typ = - -. A01, Max = 10 10. A01, Units = bit bit. A01, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A03, Symbol = EIL. A03, Characteristic = Integral linearity error. A03, Characteristic = Integral linearity error. A03, Min = - -. A03, Typ = - -. A03, Max = <\u00b11 <\u00b12. A03, Units = LSb LSb. A03, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A04, Symbol = EDL. A04, Characteristic = Differential linearity error. A04, Characteristic = Differential linearity error. A04, Min = - -. A04, Typ = -",
    "TABLE 21-21: A/D CONVERTER CHARACTERISTICS: PIC18CXX2 (INDUSTRIAL, EXTENDED) PIC18LCXX2 (INDUSTRIAL)\n-. A04, Max = <\u00b11 <\u00b12. A04, Units = LSb LSb. A04, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A05, Symbol = EFS. A05, Characteristic = Full scale error. A05, Characteristic = Full scale error. A05, Min = - -. A05, Typ = - -. A05, Max = <\u00b11 <\u00b11. A05, Units = LSb LSb. A05, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A06, Symbol = EOFF. A06, Characteristic = Offset error. A06, Characteristic = Offset error. A06, Min = - -. A06, Typ = - -. A06, Max = <\u00b11 <\u00b11. A06, Units = LSb LSb. A06, Conditions = VREF",
    "TABLE 21-21: A/D CONVERTER CHARACTERISTICS: PIC18CXX2 (INDUSTRIAL, EXTENDED) PIC18LCXX2 (INDUSTRIAL)\n= VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A10, Symbol = -. A10, Characteristic = Monotonicity. A10, Characteristic = Monotonicity. A10, Min = guaranteed (3). A10, Typ = guaranteed (3). A10, Max = guaranteed (3). A10, Units = -. A10, Conditions = VSS \uf0a3 VAIN \uf0a3 VREF. A20 A20A, Symbol = VREF. A20 A20A, Characteristic = Reference voltage (V REFH - VREFL ). A20 A20A, Characteristic = Reference voltage (V REFH - VREFL ). A20 A20A, Min = 0V 3V. A20 A20A, Typ = - -. A20 A20A, Max = - -. A20 A20A, Units = V V. A20 A20A, Conditions = For 10-bit resolution. A21, Symbol = VREFH. A21, Characteristic = Reference voltage High. A21, Characteristic =",
    "TABLE 21-21: A/D CONVERTER CHARACTERISTICS: PIC18CXX2 (INDUSTRIAL, EXTENDED) PIC18LCXX2 (INDUSTRIAL)\nReference voltage High. A21, Min = AVSS. A21, Typ = -. A21, Max = AVDD + 0.3V. A21, Units = V. A21, Conditions = . A22, Symbol = VREFL. A22, Characteristic = Reference voltage Low. A22, Characteristic = Reference voltage Low. A22, Min = AVSS - 0.3V. A22, Typ = -. A22, Max = AVDD. A22, Units = V. A22, Conditions = . A25, Symbol = VAIN. A25, Characteristic = Analog input voltage. A25, Characteristic = Analog input voltage. A25, Min = AVSS - 0.3V. A25, Typ = -. A25, Max = VREF + 0.3V. A25, Units = V. A25, Conditions = . A30, Symbol = ZAIN. A30, Characteristic = Recommended impedance of analog voltage source. A30, Characteristic = Recommended impedance of analog voltage source. A30, Min =",
    "TABLE 21-21: A/D CONVERTER CHARACTERISTICS: PIC18CXX2 (INDUSTRIAL, EXTENDED) PIC18LCXX2 (INDUSTRIAL)\n-. A30, Typ = -. A30, Max = 10.0. A30, Units = k \uf057. A30, Conditions = . A40, Symbol = I AD. A40, Characteristic = A/D conversion current (V DD). A40, Characteristic = PIC18 C XXX PIC18 LC XXX. A40, Min = - -. A40, Typ = 180 90. A40, Max = - -. A40, Units = \uf06d A \uf06d A. A40, Conditions = Average current consumption when A/D is on (Note 1) .. A50, Symbol = I REF. A50, Characteristic = VREF input current (Note 2). A50, Characteristic = VREF input current (Note 2). A50, Min = 10 -. A50, Typ = - -. A50, Max = 1000 10. A50, Units = \uf06d A \uf06d A. A50, Conditions = During VAIN acquisition. Based on differential of VHOLD to VAIN . To charge CHOLD, see Section 16.0. During A/D",
    "TABLE 21-21: A/D CONVERTER CHARACTERISTICS: PIC18CXX2 (INDUSTRIAL, EXTENDED) PIC18LCXX2 (INDUSTRIAL)\nconversion cycle.\n- Note 1: When A/D is off, it will not consume any current other than minor leakage current. The power-down current spec includes any such leakage from the A/D module. VREF current is from RA2/AN2/VREF- and RA3/AN3/VREF+ pins or AVDD and AVSS pins, whichever is\nselected as reference input.\n2: VSS \uf0a3 VAIN \uf0a3 VREF\n3: The A/D conversion result never decreases with an increase in the Input Voltage, and has no missing codes.",
    "FIGURE 21-22: A/D CONVERSION TIMING\nNote 1: If the A/D clock source is selected as RC, a time of TCY is added before the A/D clock starts.\nThis allows the SLEEP instruction to be executed.\n2: This is a minimal RC delay (typically 100 ns), which also disconnects the holding capacitor from the analog input.",
    "TABLE 21-22: A/D CONVERSION REQUIREMENTS\n130, Symbol = T AD. 130, Characteristic = A/D clock period. 130, Characteristic = PIC18 C XXX. 130, Min = 1.6. 130, Max = 20 (5). 130, Units = \uf06d s. 130, Conditions = T OSC based, VREF \uf0b3 3.0V. 130, Symbol = T AD. 130, Characteristic = A/D clock period. 130, Characteristic = PIC18 LC XXX. 130, Min = 3.0. 130, Max = 20 (5). 130, Units = \uf06d s. 130, Conditions = T OSC based, VREF full range. 130, Symbol = T AD. 130, Characteristic = A/D clock period. 130, Characteristic = PIC18 C XXX. 130, Min = 2.0. 130, Max = 6.0. 130, Units = \uf06d s. 130, Conditions = A/D RC mode. 130, Symbol = T AD. 130, Characteristic = A/D clock period. 130, Characteristic = PIC18 LC XXX. 130, Min = 3.0. 130, Max = 9.0. 130, Units = \uf06d s. 130, Conditions = A/D RC",
    "TABLE 21-22: A/D CONVERSION REQUIREMENTS\nmode. 131, Symbol = T CNV. 131, Characteristic = Conversion time (not including acquisition time) (Note 1). 131, Characteristic = Conversion time (not including acquisition time) (Note 1). 131, Min = 11. 131, Max = 12. 131, Units = T AD. 131, Conditions = . 132, Symbol = T ACQ. 132, Characteristic = Acquisition time (Note 3). 132, Characteristic = Acquisition time (Note 3). 132, Min = 15 10. 132, Max = - -. 132, Units = \uf06d s \uf06d s. 132, Conditions = -40 \uf0b0 C \uf0a3 Temp \uf0a3 125 \uf0b0 C 0 \uf0b0 C \uf0a3 Temp \uf0a3 125 \uf0b0 C. 135, Symbol = T SWC. 135, Characteristic = Switching Time from convert \uf0ae sample. 135, Characteristic = Switching Time from convert \uf0ae sample. 135, Min = -. 135, Max = (Note 4). 135, Units = . 135, Conditions = . 136, Symbol = T AMP. 136, Characteristic = Amplifier settling time (Note 2). 136, Characteristic = Amplifier settling time (Note 2). 136, Min = 1. 136, Max = -. 136, Units = \uf06d s. 136, Conditions = This may be",
    "TABLE 21-22: A/D CONVERSION REQUIREMENTS\nused if the 'new' input voltage has not changed by more than 1 LSb (i.e., 5 mV @5.12V) from the last sampled voltage (as stated on CHOLD).\nNote 1: ADRES register may be read on the following TCY cycle.\n2: See Section 16.0 for minimum conditions, when input voltage has changed more than 1 LSb.\n3: The time for the holding capacitor to acquire the 'New' input voltage, when the voltage changes full scale after the conversion (AVDD to AVSS, or AVSS to AVDD). The source impedance ( RS ) on the input channels is 50 \uf057 .\n4: On the next Q4 cycle of the device clock.\n5: The time of the A/D clock period is dependent on the device frequency and the TAD clock divider.",
    "22.0 DC AND AC CHARACTERISTICS GRAPHS AND TABLES\nThe graphs and tables provided in this section are for design guidance and are not tested .\nThe data presented in this section is a statistical summary of data collected on units from different lots over a period of  time  and  matrix  samples.  'Typical'  represents  the  mean  of  the  distribution  at  25 \uf0b0 C.  'Max'  or  'min'  represents (mean + 3 \uf073 ) or (mean - 3 \uf073 ) respectively, where \uf073 is standard deviation, over the whole temperature range.\nFIGURE 22-1: TYPICAL IDD vs. FOSC OVER VDD (HS MODE)",
    "PIC18CXX2\nFIGURE 22-3: TYPICAL IDD vs. FOSC OVER VDD (HS/PLL MODE)\nFIGURE 22-4: MAXIMUM IDD vs. FOSC OVER VDD (HS/PLL MODE)\nFIGURE 22-5: TYPICAL IDD vs. FOSC OVER VDD (XT MODE)\nFIGURE 22-6: MAXIMUM IDD vs. FOSC OVER VDD (XT MODE)\nFIGURE 22-7: TYPICAL IDD vs. FOSC OVER VDD (LP MODE)\nFIGURE 22-8: MAXIMUM IDD vs. FOSC OVER VDD (LP MODE)\nFIGURE 22-9: TYPICAL AND MAXIMUM IDD vs. VDD (TIMER1 AS MAIN OSCILLATOR, 32.768 kHz, C = 47 pF)\nFIGURE 22-10: AVERAGE FOSC vs. VDD FOR VARIOUS VALUES OF R (RC MODE, C = 20 pF, 25 C) \uf0b0\nFIGURE 22-11: AVERAGE FOSC vs. VDD FOR VARIOUS VALUES OF R (RC MODE, C = 100 pF, 25 C) \uf0b0",
    "PIC18CXX2\nFIGURE 22-12: AVERAGE FOSC vs. VDD FOR VARIOUS VALUES OF R (RC MODE, C = 300 pF, 25 C) \uf0b0\nFIGURE 22-13: IPD vs. VDD (SLEEP MODE, ALL PERIPHERALS DISABLED)\nFIGURE 22-14: \uf044 IBOR vs. VDD OVER TEMPERATURE (BOR ENABLED, VBOR = 2.50V - 2.66V)\nFIGURE 22-15: TYPICAL AND MAXIMUM \uf020\uf044 ITMR1 vs. VDD OVER TEMPERATURE (-40 C TO +125 C, TIMER1 WITH OSCILLATOR, XTAL=32 kHZ, C1 AND C2 = 47 pF) \uf0b0 \uf0b0\nFIGURE 22-16: TYPICAL AND MAXIMUM \uf044 IWDT vs. VDD OVER TEMPERATURE (WDT ENABLED)\nFIGURE 22-17: TYPICAL, MINIMUM AND MAXIMUM WDT PERIOD vs. VDD (-40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 22-18: \uf044 ILVD vs. VDD OVER TEMPERATURE (LVD ENABLED, VLVD = 3.0V - 3.2V)\nFIGURE 22-19: \uf044 ILVD vs. VDD OVER TEMPERATURE (LVD ENABLED, VLVD = 4.5V - 4.78V)",
    "PIC18CXX2\nFIGURE 22-20: TYPICAL, MINIMUM AND MAXIMUM VOH vs. IOH (VDD = 5V, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 22-22: TYPICAL AND MAXIMUM VOL vs. IOL (VDD = 5V, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 22-23: TYPICAL AND MAXIMUM VOL vs. IOL (VDD = 3V, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 22-24: MINIMUM AND MAXIMUM VIN vs. VDD (ST INPUT, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 22-25: MINIMUM AND MAXIMUM VIN vs. VDD, (TTL INPUT, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 22-26: MINIMUM AND MAXIMUM VIN vs. VDD (I 2 C INPUT, -40 C TO +125 C) \uf0b0 \uf0b0\nNOTES:",
    "Legend:\nXX...X\n0117017\nPIC18C242-I/SP",
    "Example\n0110017\nPIC18C242-E/SO\nCustomer-specific information\nY\nYY\nWW\nNNN\n*\nYear code (last digit of calendar year)\nYear code (last 2 digits of calendar year)\nWeek code (week of January 1 is week '01')\nAlphanumeric traceability code\nPb-free JEDEC designator for Matte Tin (Sn)\nThis package is Pb-free. The Pb-free JEDEC designator (     ) 3 e\ncan be found on the outer packaging for this package.",
    "Note :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.",
    "23.2 Package Details\nThe following sections give the technical details of the packages.",
    "Note:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Note:\nNumber of Pins, Units.Dimension Limits = n. Number of Pins, INCHES*.MIN = . Number of Pins, INCHES*.NOM = 28. Number of Pins, INCHES*.MAX = . Number of Pins, MILLIMETERS.MIN = . Number of Pins, MILLIMETERS.NOM = 28. Number of Pins, MILLIMETERS.MAX = . Pitch, Units.Dimension Limits = p. Pitch, INCHES*.MIN = . Pitch, INCHES*.NOM = .100. Pitch, INCHES*.MAX = . Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 2.54. Pitch, MILLIMETERS.MAX = . Top to Seating Plane, Units.Dimension Limits = A. Top to Seating Plane, INCHES*.MIN = .140. Top to Seating Plane, INCHES*.NOM = .150. Top to Seating Plane, INCHES*.MAX = .160. Top to Seating Plane, MILLIMETERS.MIN = 3.56. Top to Seating Plane, MILLIMETERS.NOM = 3.81. Top to Seating Plane, MILLIMETERS.MAX = 4.06. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, INCHES*.MIN =",
    "Note:\n.125. Molded Package Thickness, INCHES*.NOM = .130. Molded Package Thickness, INCHES*.MAX = .135. Molded Package Thickness, MILLIMETERS.MIN = 3.18. Molded Package Thickness, MILLIMETERS.NOM = 3.30. Molded Package Thickness, MILLIMETERS.MAX = 3.43. Base to Seating Plane, Units.Dimension Limits = A1. Base to Seating Plane, INCHES*.MIN = .015. Base to Seating Plane, INCHES*.NOM = . Base to Seating Plane, INCHES*.MAX = . Base to Seating Plane, MILLIMETERS.MIN = 0.38. Base to Seating Plane, MILLIMETERS.NOM = . Base to Seating Plane, MILLIMETERS.MAX = . Shoulder to Shoulder Width, Units.Dimension Limits = E. Shoulder to Shoulder Width, INCHES*.MIN = .300. Shoulder to Shoulder Width, INCHES*.NOM = .310. Shoulder to Shoulder Width, INCHES*.MAX = .325. Shoulder to Shoulder Width, MILLIMETERS.MIN = 7.62. Shoulder to Shoulder Width, MILLIMETERS.NOM = 7.87. Shoulder to Shoulder Width, MILLIMETERS.MAX = 8.26. Molded Package Width,",
    "Note:\nUnits.Dimension Limits = E1. Molded Package Width, INCHES*.MIN = .275. Molded Package Width, INCHES*.NOM = .285. Molded Package Width, INCHES*.MAX = .295. Molded Package Width, MILLIMETERS.MIN = 6.99. Molded Package Width, MILLIMETERS.NOM = 7.24. Molded Package Width, MILLIMETERS.MAX = 7.49. Overall Length, Units.Dimension Limits = D. Overall Length, INCHES*.MIN = 1.345. Overall Length, INCHES*.NOM = 1.365. Overall Length, INCHES*.MAX = 1.385. Overall Length, MILLIMETERS.MIN = 34.16. Overall Length, MILLIMETERS.NOM = 34.67. Overall Length, MILLIMETERS.MAX = 35.18. Tip to Seating Plane, Units.Dimension Limits = L. Tip to Seating Plane, INCHES*.MIN = .125. Tip to Seating Plane, INCHES*.NOM = .130. Tip to Seating Plane, INCHES*.MAX = .135. Tip to Seating Plane, MILLIMETERS.MIN = 3.18. Tip to Seating Plane, MILLIMETERS.NOM = 3.30. Tip to Seating",
    "Note:\nPlane, MILLIMETERS.MAX = 3.43. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, INCHES*.MIN = .008. Lead Thickness, INCHES*.NOM = .012. Lead Thickness, INCHES*.MAX = .015. Lead Thickness, MILLIMETERS.MIN = 0.20. Lead Thickness, MILLIMETERS.NOM = 0.29. Lead Thickness, MILLIMETERS.MAX = 0.38. Upper Lead Width, Units.Dimension Limits = B1. Upper Lead Width, INCHES*.MIN = .040. Upper Lead Width, INCHES*.NOM = .053. Upper Lead Width, INCHES*.MAX = .065. Upper Lead Width, MILLIMETERS.MIN = 1.02. Upper Lead Width, MILLIMETERS.NOM = 1.33. Upper Lead Width, MILLIMETERS.MAX = 1.65. Lower Lead Width, Units.Dimension Limits = B. Lower Lead Width, INCHES*.MIN = .016. Lower Lead Width, INCHES*.NOM = .019. Lower Lead Width, INCHES*.MAX = .022. Lower Lead Width, MILLIMETERS.MIN = 0.41. Lower Lead Width,",
    "Note:\nMILLIMETERS.NOM = 0.48. Lower Lead Width, MILLIMETERS.MAX = 0.56. Overall Row Spacing, Units.Dimension Limits = eB. Overall Row Spacing, INCHES*.MIN = .320. Overall Row Spacing, INCHES*.NOM = .350. Overall Row Spacing, INCHES*.MAX = .430. Overall Row Spacing, MILLIMETERS.MIN = 8.13. Overall Row Spacing, MILLIMETERS.NOM = 8.89. Overall Row Spacing, MILLIMETERS.MAX = 10.92. Mold Draft Angle Top, Units.Dimension Limits = \uf061. Mold Draft Angle Top, INCHES*.MIN = 5. Mold Draft Angle Top, INCHES*.NOM = 10. Mold Draft Angle Top, INCHES*.MAX = 15. Mold Draft Angle Top, MILLIMETERS.MIN = 5. Mold Draft Angle Top, MILLIMETERS.NOM = 10. Mold Draft Angle Top, MILLIMETERS.MAX = 15. Mold Draft Angle Bottom, Units.Dimension Limits = . Mold Draft Angle Bottom, INCHES*.MIN = 5 \uf062. Mold Draft Angle Bottom, INCHES*.NOM = 10. Mold Draft Angle Bottom, INCHES*.MAX = 15. Mold Draft",
    "Note:\nAngle Bottom, MILLIMETERS.MIN = 5. Mold Draft Angle Bottom, MILLIMETERS.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS.MAX = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic\nNotes:\nDimension D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed\n.010' (0.254mm) per side.\nJEDEC Equivalent:  MO-095\nDrawing No. C04-070",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil (SOIC)\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil (SOIC)\nNumber of Pins, Dimension Limits = n. Number of Pins, INCHES*.MIN = . Number of Pins, INCHES*.NOM = 28. Number of Pins, INCHES*.MAX = . Number of Pins, MILLIMETERS.MIN = . Number of Pins, MILLIMETERS.NOM = 28. Number of Pins, MILLIMETERS.MAX = . Pitch, Dimension Limits = p. Pitch, INCHES*.MIN = . Pitch, INCHES*.NOM = .050. Pitch, INCHES*.MAX = . Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 1.27. Pitch, MILLIMETERS.MAX = . Overall Height, Dimension Limits = A. Overall Height, INCHES*.MIN = .093. Overall Height, INCHES*.NOM = .099. Overall Height, INCHES*.MAX = .104. Overall Height, MILLIMETERS.MIN = 2.36. Overall Height, MILLIMETERS.NOM = 2.50. Overall Height, MILLIMETERS.MAX = 2.64. Molded Package Thickness, Dimension Limits = A2. Molded Package Thickness, INCHES*.MIN = .088.",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil (SOIC)\nMolded Package Thickness, INCHES*.NOM = .091. Molded Package Thickness, INCHES*.MAX = .094. Molded Package Thickness, MILLIMETERS.MIN = 2.24. Molded Package Thickness, MILLIMETERS.NOM = 2.31. Molded Package Thickness, MILLIMETERS.MAX = 2.39. Standoff, Dimension Limits = A1. Standoff, INCHES*.MIN = .004. Standoff, INCHES*.NOM = .008. Standoff, INCHES*.MAX = .012. Standoff, MILLIMETERS.MIN = 0.10. Standoff, MILLIMETERS.NOM = 0.20. Standoff, MILLIMETERS.MAX = 0.30. Overall Width, Dimension Limits = E. Overall Width, INCHES*.MIN = .394. Overall Width, INCHES*.NOM = .407. Overall Width, INCHES*.MAX = .420. Overall Width, MILLIMETERS.MIN = 10.01. Overall Width, MILLIMETERS.NOM = 10.34. Overall Width, MILLIMETERS.MAX = 10.67. Molded Package Width, Dimension Limits =",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil (SOIC)\nE1. Molded Package Width, INCHES*.MIN = .288. Molded Package Width, INCHES*.NOM = .295. Molded Package Width, INCHES*.MAX = .299. Molded Package Width, MILLIMETERS.MIN = 7.32. Molded Package Width, MILLIMETERS.NOM = 7.49. Molded Package Width, MILLIMETERS.MAX = 7.59. Overall Length, Dimension Limits = D. Overall Length, INCHES*.MIN = .695. Overall Length, INCHES*.NOM = .704. Overall Length, INCHES*.MAX = .712. Overall Length, MILLIMETERS.MIN = 17.65. Overall Length, MILLIMETERS.NOM = 17.87. Overall Length, MILLIMETERS.MAX = 18.08. Chamfer Distance, Dimension Limits = h. Chamfer Distance, INCHES*.MIN = .010. Chamfer Distance, INCHES*.NOM = .020. Chamfer Distance, INCHES*.MAX = .029. Chamfer Distance, MILLIMETERS.MIN = 0.25. Chamfer Distance,",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil (SOIC)\nMILLIMETERS.NOM = 0.50. Chamfer Distance, MILLIMETERS.MAX = 0.74. Foot Length, Dimension Limits = L. Foot Length, INCHES*.MIN = .016. Foot Length, INCHES*.NOM = .033. Foot Length, INCHES*.MAX = .050. Foot Length, MILLIMETERS.MIN = 0.41. Foot Length, MILLIMETERS.NOM = 0.84. Foot Length, MILLIMETERS.MAX = 1.27. Foot Angle Top, Dimension Limits = \uf066. Foot Angle Top, INCHES*.MIN = 0. Foot Angle Top, INCHES*.NOM = 4. Foot Angle Top, INCHES*.MAX = 8. Foot Angle Top, MILLIMETERS.MIN = 0. Foot Angle Top, MILLIMETERS.NOM = 4. Foot Angle Top, MILLIMETERS.MAX = 8. Lead Thickness, Dimension Limits = c. Lead Thickness, INCHES*.MIN = .009. Lead Thickness, INCHES*.NOM = .011. Lead Thickness, INCHES*.MAX = .013. Lead Thickness, MILLIMETERS.MIN = 0.23.",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil (SOIC)\nLead Thickness, MILLIMETERS.NOM = 0.28. Lead Thickness, MILLIMETERS.MAX = 0.33. Lead Width, Dimension Limits = B. Lead Width, INCHES*.MIN = .014. Lead Width, INCHES*.NOM = .017. Lead Width, INCHES*.MAX = .020. Lead Width, MILLIMETERS.MIN = 0.36. Lead Width, MILLIMETERS.NOM = 0.42. Lead Width, MILLIMETERS.MAX = 0.51. Mold Draft Angle Top, Dimension Limits = \uf061. Mold Draft Angle Top, INCHES*.MIN = 0. Mold Draft Angle Top, INCHES*.NOM = 12. Mold Draft Angle Top, INCHES*.MAX = 15. Mold Draft Angle Top, MILLIMETERS.MIN = 0. Mold Draft Angle Top, MILLIMETERS.NOM = 12. Mold Draft Angle Top, MILLIMETERS.MAX = 15. Mold Draft Angle Bottom, Dimension Limits = \uf062. Mold Draft Angle Bottom, INCHES*.MIN = 0. Mold Draft Angle Bottom, INCHES*.NOM = 12. Mold Draft Angle Bottom, INCHES*.MAX = 15. Mold Draft",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil (SOIC)\nAngle Bottom, MILLIMETERS.MIN = 0. Mold Draft Angle Bottom, MILLIMETERS.NOM = 12. Mold Draft Angle Bottom, MILLIMETERS.MAX = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side. JEDEC Equivalent:  MS-013 Drawing No. C04-052",
    "40-Lead Plastic Dual In-line (P) - 600 mil (PDIP)\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "40-Lead Plastic Dual In-line (P) - 600 mil (PDIP)\nNumber of Pins, Dimension Limits = n. Number of Pins, INCHES*.MIN = . Number of Pins, INCHES*.NOM = 40. Number of Pins, INCHES*.MAX = . Number of Pins, MILLIMETERS.MIN = . Number of Pins, MILLIMETERS.NOM = 40. Number of Pins, MILLIMETERS.MAX = . Pitch, Dimension Limits = p. Pitch, INCHES*.MIN = . Pitch, INCHES*.NOM = .100. Pitch, INCHES*.MAX = . Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 2.54. Pitch, MILLIMETERS.MAX = . Top to Seating Plane, Dimension Limits = A. Top to Seating Plane, INCHES*.MIN = .160. Top to Seating Plane, INCHES*.NOM = .175. Top to Seating Plane, INCHES*.MAX = .190. Top to Seating Plane, MILLIMETERS.MIN = 4.06. Top to Seating Plane, MILLIMETERS.NOM = 4.45. Top to Seating Plane, MILLIMETERS.MAX = 4.83. Molded Package Thickness, Dimension Limits = A2. Molded",
    "40-Lead Plastic Dual In-line (P) - 600 mil (PDIP)\nPackage Thickness, INCHES*.MIN = .140. Molded Package Thickness, INCHES*.NOM = .150. Molded Package Thickness, INCHES*.MAX = .160. Molded Package Thickness, MILLIMETERS.MIN = 3.56. Molded Package Thickness, MILLIMETERS.NOM = 3.81. Molded Package Thickness, MILLIMETERS.MAX = 4.06. Base to Seating Plane, Dimension Limits = A1. Base to Seating Plane, INCHES*.MIN = .015. Base to Seating Plane, INCHES*.NOM = . Base to Seating Plane, INCHES*.MAX = . Base to Seating Plane, MILLIMETERS.MIN = 0.38. Base to Seating Plane, MILLIMETERS.NOM = . Base to Seating Plane, MILLIMETERS.MAX = . Shoulder to Shoulder Width, Dimension Limits = E. Shoulder to Shoulder Width, INCHES*.MIN = .595. Shoulder to Shoulder Width, INCHES*.NOM = .600. Shoulder to Shoulder Width, INCHES*.MAX = .625. Shoulder to Shoulder Width, MILLIMETERS.MIN = 15.11. Shoulder to Shoulder Width, MILLIMETERS.NOM =",
    "40-Lead Plastic Dual In-line (P) - 600 mil (PDIP)\n15.24. Shoulder to Shoulder Width, MILLIMETERS.MAX = 15.88. Molded Package Width, Dimension Limits = E1. Molded Package Width, INCHES*.MIN = .530. Molded Package Width, INCHES*.NOM = .545. Molded Package Width, INCHES*.MAX = .560. Molded Package Width, MILLIMETERS.MIN = 13.46. Molded Package Width, MILLIMETERS.NOM = 13.84. Molded Package Width, MILLIMETERS.MAX = 14.22. Overall Length, Dimension Limits = D. Overall Length, INCHES*.MIN = 2.045. Overall Length, INCHES*.NOM = 2.058. Overall Length, INCHES*.MAX = 2.065. Overall Length, MILLIMETERS.MIN = 51.94. Overall Length, MILLIMETERS.NOM = 52.26. Overall Length, MILLIMETERS.MAX = 52.45. Tip to Seating Plane, Dimension Limits = L. Tip to Seating Plane, INCHES*.MIN = .120. Tip to Seating Plane, INCHES*.NOM = .130. Tip to Seating Plane, INCHES*.MAX =",
    "40-Lead Plastic Dual In-line (P) - 600 mil (PDIP)\n.135. Tip to Seating Plane, MILLIMETERS.MIN = 3.05. Tip to Seating Plane, MILLIMETERS.NOM = 3.30. Tip to Seating Plane, MILLIMETERS.MAX = 3.43. Lead Thickness, Dimension Limits = c. Lead Thickness, INCHES*.MIN = .008. Lead Thickness, INCHES*.NOM = .012. Lead Thickness, INCHES*.MAX = .015. Lead Thickness, MILLIMETERS.MIN = 0.20. Lead Thickness, MILLIMETERS.NOM = 0.29. Lead Thickness, MILLIMETERS.MAX = 0.38. Upper Lead Width, Dimension Limits = B1. Upper Lead Width, INCHES*.MIN = .030. Upper Lead Width, INCHES*.NOM = .050. Upper Lead Width, INCHES*.MAX = .070. Upper Lead Width, MILLIMETERS.MIN = 0.76. Upper Lead Width, MILLIMETERS.NOM = 1.27. Upper Lead Width, MILLIMETERS.MAX = 1.78. Lower Lead Width, Dimension Limits = B. Lower Lead Width, INCHES*.MIN = .014.",
    "40-Lead Plastic Dual In-line (P) - 600 mil (PDIP)\nLower Lead Width, INCHES*.NOM = .018. Lower Lead Width, INCHES*.MAX = .022. Lower Lead Width, MILLIMETERS.MIN = 0.36. Lower Lead Width, MILLIMETERS.NOM = 0.46. Lower Lead Width, MILLIMETERS.MAX = 0.56. Overall Row Spacing, Dimension Limits = \u00a7. Overall Row Spacing, INCHES*.MIN = .620 eB. Overall Row Spacing, INCHES*.NOM = .650. Overall Row Spacing, INCHES*.MAX = .680. Overall Row Spacing, MILLIMETERS.MIN = 15.75. Overall Row Spacing, MILLIMETERS.NOM = 16.51. Overall Row Spacing, MILLIMETERS.MAX = 17.27. Mold Draft Angle Top, Dimension Limits = \uf061. Mold Draft Angle Top, INCHES*.MIN = 5. Mold Draft Angle Top, INCHES*.NOM = 10. Mold Draft Angle Top, INCHES*.MAX = 15. Mold Draft Angle Top, MILLIMETERS.MIN = 5. Mold Draft Angle Top, MILLIMETERS.NOM = 10. Mold Draft Angle Top,",
    "40-Lead Plastic Dual In-line (P) - 600 mil (PDIP)\nMILLIMETERS.MAX = 15. Mold Draft Angle Bottom, Dimension Limits = \uf062. Mold Draft Angle Bottom, INCHES*.MIN = 5. Mold Draft Angle Bottom, INCHES*.NOM = 10. Mold Draft Angle Bottom, INCHES*.MAX = 15. Mold Draft Angle Bottom, MILLIMETERS.MIN = 5. Mold Draft Angle Bottom, MILLIMETERS.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS.MAX = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed\n.010' (0.254mm) per side. JEDEC Equivalent:  MO-011\nDrawing No. C04-016",
    "28-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nB",
    "28-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\nNumber of Pins, Units.Dimension Limits = n. Number of Pins, INCHES*.MIN = . Number of Pins, INCHES*.NOM = 28. Number of Pins, INCHES*.MAX = . Number of Pins, MILLIMETERS.MIN = . Number of Pins, MILLIMETERS.NOM = 28. Number of Pins, MILLIMETERS.MAX = . Pitch, Units.Dimension Limits = p. Pitch, INCHES*.MIN = . Pitch, INCHES*.NOM = .100. Pitch, INCHES*.MAX = . Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 2.54. Pitch, MILLIMETERS.MAX = . Top to Seating Plane, Units.Dimension Limits = A. Top to Seating Plane, INCHES*.MIN = .195. Top to Seating Plane, INCHES*.NOM = .210. Top to Seating Plane, INCHES*.MAX = .225. Top to Seating Plane, MILLIMETERS.MIN = 4.95. Top to Seating Plane, MILLIMETERS.NOM = 5.33. Top to Seating Plane, MILLIMETERS.MAX = 5.72.",
    "28-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\nCeramic Package Height, Units.Dimension Limits = A2. Ceramic Package Height, INCHES*.MIN = .155. Ceramic Package Height, INCHES*.NOM = .160. Ceramic Package Height, INCHES*.MAX = .165. Ceramic Package Height, MILLIMETERS.MIN = 3.94. Ceramic Package Height, MILLIMETERS.NOM = 4.06. Ceramic Package Height, MILLIMETERS.MAX = 4.19. Standoff, Units.Dimension Limits = A1. Standoff, INCHES*.MIN = .015. Standoff, INCHES*.NOM = .038. Standoff, INCHES*.MAX = .060. Standoff, MILLIMETERS.MIN = 0.38. Standoff, MILLIMETERS.NOM = 0.95. Standoff, MILLIMETERS.MAX = 1.52. Shoulder to Shoulder Width, Units.Dimension Limits = E. Shoulder to Shoulder Width, INCHES*.MIN = .595. Shoulder to Shoulder Width, INCHES*.NOM = .600. Shoulder to Shoulder Width, INCHES*.MAX = .625. Shoulder to Shoulder Width, MILLIMETERS.MIN",
    "28-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\n= 15.11. Shoulder to Shoulder Width, MILLIMETERS.NOM = 15.24. Shoulder to Shoulder Width, MILLIMETERS.MAX = 15.88. Ceramic Pkg. Width, Units.Dimension Limits = E1. Ceramic Pkg. Width, INCHES*.MIN = .514. Ceramic Pkg. Width, INCHES*.NOM = .520. Ceramic Pkg. Width, INCHES*.MAX = .526. Ceramic Pkg. Width, MILLIMETERS.MIN = 13.06. Ceramic Pkg. Width, MILLIMETERS.NOM = 13.21. Ceramic Pkg. Width, MILLIMETERS.MAX = 13.36. Overall Length, Units.Dimension Limits = D. Overall Length, INCHES*.MIN = 1.430. Overall Length, INCHES*.NOM = 1.460. Overall Length, INCHES*.MAX = 1.490. Overall Length, MILLIMETERS.MIN = 36.32. Overall Length, MILLIMETERS.NOM = 37.08. Overall Length, MILLIMETERS.MAX = 37.85. Tip to Seating",
    "28-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\nPlane, Units.Dimension Limits = L. Tip to Seating Plane, INCHES*.MIN = .125. Tip to Seating Plane, INCHES*.NOM = .138. Tip to Seating Plane, INCHES*.MAX = .150. Tip to Seating Plane, MILLIMETERS.MIN = 3.18. Tip to Seating Plane, MILLIMETERS.NOM = 3.49. Tip to Seating Plane, MILLIMETERS.MAX = 3.81. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, INCHES*.MIN = .008. Lead Thickness, INCHES*.NOM = .010. Lead Thickness, INCHES*.MAX = .012. Lead Thickness, MILLIMETERS.MIN = 0.20. Lead Thickness, MILLIMETERS.NOM = 0.25. Lead Thickness, MILLIMETERS.MAX = 0.30. Upper Lead Width, Units.Dimension Limits = B1. Upper Lead Width, INCHES*.MIN = .050. Upper Lead Width, INCHES*.NOM = .058. Upper Lead Width, INCHES*.MAX = .065. Upper Lead Width, MILLIMETERS.MIN",
    "28-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\n= 1.27. Upper Lead Width, MILLIMETERS.NOM = 1.46. Upper Lead Width, MILLIMETERS.MAX = 1.65. Lower Lead Width, Units.Dimension Limits = B. Lower Lead Width, INCHES*.MIN = .016. Lower Lead Width, INCHES*.NOM = .020. Lower Lead Width, INCHES*.MAX = .023. Lower Lead Width, MILLIMETERS.MIN = 0.41. Lower Lead Width, MILLIMETERS.NOM = 0.51. Lower Lead Width, MILLIMETERS.MAX = 0.58. Overall Row Spacing, Units.Dimension Limits = eB. Overall Row Spacing, INCHES*.MIN = .610. Overall Row Spacing, INCHES*.NOM = .660. Overall Row Spacing, INCHES*.MAX = .710. Overall Row Spacing, MILLIMETERS.MIN = 15.49. Overall Row Spacing, MILLIMETERS.NOM = 16.76. Overall Row Spacing, MILLIMETERS.MAX = 18.03. Window Diameter, Units.Dimension Limits = W. Window Diameter,",
    "28-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\nINCHES*.MIN = .270. Window Diameter, INCHES*.NOM = .280. Window Diameter, INCHES*.MAX = .290. Window Diameter, MILLIMETERS.MIN = 6.86. Window Diameter, MILLIMETERS.NOM = 7.11. Window Diameter, MILLIMETERS.MAX = 7.37\n* Controlling Parameter\n\u00a7 Significant Characteristic\nJEDEC Equivalent:  MO-103\nDrawing No. C04-013",
    "40-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "40-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\nNumber of Pins, Units.Dimension Limits = n. Number of Pins, INCHES*.MIN = . Number of Pins, INCHES*.NOM = 40. Number of Pins, INCHES*.MAX = . Number of Pins, MILLIMETERS.MIN = . Number of Pins, MILLIMETERS.NOM = 40. Number of Pins, MILLIMETERS.MAX = . Pitch, Units.Dimension Limits = p. Pitch, INCHES*.MIN = . Pitch, INCHES*.NOM = .100. Pitch, INCHES*.MAX = . Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 2.54. Pitch, MILLIMETERS.MAX = . Top to Seating Plane, Units.Dimension Limits = A. Top to Seating Plane, INCHES*.MIN = .185. Top to Seating Plane, INCHES*.NOM = .205. Top to Seating Plane, INCHES*.MAX = .225. Top to Seating Plane, MILLIMETERS.MIN = 4.70. Top to Seating Plane, MILLIMETERS.NOM = 5.21. Top to Seating Plane, MILLIMETERS.MAX = 5.72.",
    "40-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\nCeramic Package Height, Units.Dimension Limits = A2. Ceramic Package Height, INCHES*.MIN = .155. Ceramic Package Height, INCHES*.NOM = .160. Ceramic Package Height, INCHES*.MAX = .165. Ceramic Package Height, MILLIMETERS.MIN = 3.94. Ceramic Package Height, MILLIMETERS.NOM = 4.06. Ceramic Package Height, MILLIMETERS.MAX = 4.19. Standoff, Units.Dimension Limits = A1. Standoff, INCHES*.MIN = .030. Standoff, INCHES*.NOM = .045. Standoff, INCHES*.MAX = .060. Standoff, MILLIMETERS.MIN = 0.76. Standoff, MILLIMETERS.NOM = 1.14. Standoff, MILLIMETERS.MAX = 1.52. Shoulder to Shoulder Width, Units.Dimension Limits = E. Shoulder to Shoulder Width, INCHES*.MIN = .595. Shoulder to Shoulder Width, INCHES*.NOM = .600. Shoulder to Shoulder Width, INCHES*.MAX = .625. Shoulder to Shoulder Width, MILLIMETERS.MIN",
    "40-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\n= 15.11. Shoulder to Shoulder Width, MILLIMETERS.NOM = 15.24. Shoulder to Shoulder Width, MILLIMETERS.MAX = 15.88. Ceramic Pkg. Width, Units.Dimension Limits = E1. Ceramic Pkg. Width, INCHES*.MIN = .514. Ceramic Pkg. Width, INCHES*.NOM = .520. Ceramic Pkg. Width, INCHES*.MAX = .526. Ceramic Pkg. Width, MILLIMETERS.MIN = 13.06. Ceramic Pkg. Width, MILLIMETERS.NOM = 13.21. Ceramic Pkg. Width, MILLIMETERS.MAX = 13.36. Overall Length, Units.Dimension Limits = D. Overall Length, INCHES*.MIN = 2.040. Overall Length, INCHES*.NOM = 2.050. Overall Length, INCHES*.MAX = 2.060. Overall Length, MILLIMETERS.MIN = 51.82. Overall Length, MILLIMETERS.NOM = 52.07. Overall Length, MILLIMETERS.MAX = 52.32. Tip to",
    "40-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\nSeating Plane, Units.Dimension Limits = L. Tip to Seating Plane, INCHES*.MIN = .135. Tip to Seating Plane, INCHES*.NOM = .140. Tip to Seating Plane, INCHES*.MAX = .145. Tip to Seating Plane, MILLIMETERS.MIN = 3.43. Tip to Seating Plane, MILLIMETERS.NOM = 3.56. Tip to Seating Plane, MILLIMETERS.MAX = 3.68. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, INCHES*.MIN = .008. Lead Thickness, INCHES*.NOM = .011. Lead Thickness, INCHES*.MAX = .014. Lead Thickness, MILLIMETERS.MIN = 0.20. Lead Thickness, MILLIMETERS.NOM = 0.28. Lead Thickness, MILLIMETERS.MAX = 0.36. Upper Lead Width, Units.Dimension Limits = . Upper Lead Width, INCHES*.MIN = .050 B1. Upper Lead Width, INCHES*.NOM = .053. Upper Lead Width, INCHES*.MAX = .055. Upper Lead Width,",
    "40-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\nMILLIMETERS.MIN = 1.27. Upper Lead Width, MILLIMETERS.NOM = 1.33. Upper Lead Width, MILLIMETERS.MAX = 1.40. Lower Lead Width, Units.Dimension Limits = . Lower Lead Width, INCHES*.MIN = .016 B. Lower Lead Width, INCHES*.NOM = .020. Lower Lead Width, INCHES*.MAX = .023. Lower Lead Width, MILLIMETERS.MIN = 0.41. Lower Lead Width, MILLIMETERS.NOM = 0.51. Lower Lead Width, MILLIMETERS.MAX = 0.58. Overall Row Spacing, Units.Dimension Limits = . Overall Row Spacing, INCHES*.MIN = .610 eB. Overall Row Spacing, INCHES*.NOM = .660. Overall Row Spacing, INCHES*.MAX = .710. Overall Row Spacing, MILLIMETERS.MIN = 15.49. Overall Row Spacing, MILLIMETERS.NOM = 16.76. Overall Row Spacing, MILLIMETERS.MAX = 18.03. Window Diameter, Units.Dimension Limits = . Window",
    "40-Lead Ceramic Dual In-line with Window (JW) - 600 mil (CERDIP)\nDiameter, INCHES*.MIN = .340 W. Window Diameter, INCHES*.NOM = .350. Window Diameter, INCHES*.MAX = .360. Window Diameter, MILLIMETERS.MIN = 8.64. Window Diameter, MILLIMETERS.NOM = 8.89. Window Diameter, MILLIMETERS.MAX = 9.14\n* Controlling Parameter\n\u00a7 Significant Characteristic\nJEDEC Equivalent:  MO-103\nDrawing No. C04-014",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNumber of Pins, Dimension Limits = n. Number of Pins, INCHES.MIN = . Number of Pins, INCHES.NOM = 44. Number of Pins, INCHES.MAX = . Number of Pins, MILLIMETERS*.MIN = . Number of Pins, MILLIMETERS*.NOM = 44. Number of Pins, MILLIMETERS*.MAX = . Pitch, Dimension Limits = p. Pitch, INCHES.MIN = . Pitch, INCHES.NOM = .031. Pitch, INCHES.MAX = . Pitch, MILLIMETERS*.MIN = . Pitch, MILLIMETERS*.NOM = 0.80. Pitch, MILLIMETERS*.MAX = . Pins per Side, Dimension Limits = n1. Pins per Side, INCHES.MIN = . Pins per Side, INCHES.NOM = 11. Pins per Side, INCHES.MAX = . Pins per Side, MILLIMETERS*.MIN = . Pins per Side, MILLIMETERS*.NOM = 11. Pins per Side, MILLIMETERS*.MAX = . Overall Height, Dimension Limits = A. Overall Height,",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nINCHES.MIN = .039. Overall Height, INCHES.NOM = .043. Overall Height, INCHES.MAX = .047. Overall Height, MILLIMETERS*.MIN = 1.00. Overall Height, MILLIMETERS*.NOM = 1.10. Overall Height, MILLIMETERS*.MAX = 1.20. Molded Package Thickness, Dimension Limits = A2. Molded Package Thickness, INCHES.MIN = .037. Molded Package Thickness, INCHES.NOM = .039. Molded Package Thickness, INCHES.MAX = .041. Molded Package Thickness, MILLIMETERS*.MIN = 0.95. Molded Package Thickness, MILLIMETERS*.NOM = 1.00. Molded Package Thickness, MILLIMETERS*.MAX = 1.05. Standoff, Dimension Limits = A1. Standoff, INCHES.MIN = .002. Standoff, INCHES.NOM = .004. Standoff, INCHES.MAX = .006. Standoff, MILLIMETERS*.MIN = 0.05. Standoff,",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nMILLIMETERS*.NOM = 0.10. Standoff, MILLIMETERS*.MAX = 0.15. Foot Length, Dimension Limits = L. Foot Length, INCHES.MIN = .018. Foot Length, INCHES.NOM = .024. Foot Length, INCHES.MAX = .030. Foot Length, MILLIMETERS*.MIN = 0.45. Foot Length, MILLIMETERS*.NOM = 0.60. Foot Length, MILLIMETERS*.MAX = 0.75. Footprint (Reference), Dimension Limits = (F). Footprint (Reference), INCHES.MIN = . Footprint (Reference), INCHES.NOM = .039. Footprint (Reference), INCHES.MAX = . Footprint (Reference), MILLIMETERS*.MIN = 1.00. Footprint (Reference), MILLIMETERS*.NOM = . Footprint (Reference), MILLIMETERS*.MAX = . Foot Angle, Dimension Limits = \uf066. Foot Angle, INCHES.MIN = 0. Foot Angle, INCHES.NOM = 3.5. Foot Angle,",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nINCHES.MAX = 7. Foot Angle, MILLIMETERS*.MIN = 0. Foot Angle, MILLIMETERS*.NOM = 3.5. Foot Angle, MILLIMETERS*.MAX = 7. Overall Width, Dimension Limits = E. Overall Width, INCHES.MIN = .463. Overall Width, INCHES.NOM = .472. Overall Width, INCHES.MAX = .482. Overall Width, MILLIMETERS*.MIN = 11.75. Overall Width, MILLIMETERS*.NOM = 12.00. Overall Width, MILLIMETERS*.MAX = 12.25. Overall Length, Dimension Limits = D. Overall Length, INCHES.MIN = .463. Overall Length, INCHES.NOM = .472. Overall Length, INCHES.MAX = .482. Overall Length, MILLIMETERS*.MIN = 11.75. Overall Length, MILLIMETERS*.NOM = 12.00. Overall Length, MILLIMETERS*.MAX = 12.25. Molded Package Width, Dimension Limits = E1. Molded Package Width, INCHES.MIN",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n= .390. Molded Package Width, INCHES.NOM = .394. Molded Package Width, INCHES.MAX = .398. Molded Package Width, MILLIMETERS*.MIN = 9.90. Molded Package Width, MILLIMETERS*.NOM = 10.00. Molded Package Width, MILLIMETERS*.MAX = 10.10. Molded Package Length, Dimension Limits = D1. Molded Package Length, INCHES.MIN = .390. Molded Package Length, INCHES.NOM = .394. Molded Package Length, INCHES.MAX = .398. Molded Package Length, MILLIMETERS*.MIN = 9.90. Molded Package Length, MILLIMETERS*.NOM = 10.00. Molded Package Length, MILLIMETERS*.MAX = 10.10. Lead Thickness, Dimension Limits = c. Lead Thickness, INCHES.MIN = .004. Lead Thickness, INCHES.NOM = .006. Lead Thickness, INCHES.MAX = .008. Lead Thickness, MILLIMETERS*.MIN = 0.09. Lead Thickness,",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nMILLIMETERS*.NOM = 0.15. Lead Thickness, MILLIMETERS*.MAX = 0.20. Lead Width, Dimension Limits = B. Lead Width, INCHES.MIN = .012. Lead Width, INCHES.NOM = .015. Lead Width, INCHES.MAX = .017. Lead Width, MILLIMETERS*.MIN = 0.30. Lead Width, MILLIMETERS*.NOM = 0.38. Lead Width, MILLIMETERS*.MAX = 0.44. Pin 1 Corner Chamfer, Dimension Limits = CH. Pin 1 Corner Chamfer, INCHES.MIN = .025. Pin 1 Corner Chamfer, INCHES.NOM = .035. Pin 1 Corner Chamfer, INCHES.MAX = .045. Pin 1 Corner Chamfer, MILLIMETERS*.MIN = 0.64. Pin 1 Corner Chamfer, MILLIMETERS*.NOM = 0.89. Pin 1 Corner Chamfer, MILLIMETERS*.MAX = 1.14. Mold Draft Angle Top, Dimension Limits",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n= \uf061. Mold Draft Angle Top, INCHES.MIN = 5. Mold Draft Angle Top, INCHES.NOM = 10. Mold Draft Angle Top, INCHES.MAX = 15. Mold Draft Angle Top, MILLIMETERS*.MIN = 5. Mold Draft Angle Top, MILLIMETERS*.NOM = 10. Mold Draft Angle Top, MILLIMETERS*.MAX = 15. Mold Draft Angle Bottom, Dimension Limits = \uf062. Mold Draft Angle Bottom, INCHES.MIN = 5. Mold Draft Angle Bottom, INCHES.NOM = 10. Mold Draft Angle Bottom, INCHES.MAX = 15. Mold Draft Angle Bottom, MILLIMETERS*.MIN = 5. Mold Draft Angle Bottom, MILLIMETERS*.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS*.MAX = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D1 and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side. JEDEC Equivalent:  MS-026 Drawing No. C04-076",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nNumber of Pins, Units.MIN Dimension Limits = n. Number of Pins, INCHES*.MIN Dimension Limits = . Number of Pins, INCHES*. = 44. Number of Pins, INCHES*.MAX NOM = . Number of Pins, MILLIMETERS.MIN = . Number of Pins, MILLIMETERS.NOM = 44. Number of Pins, MILLIMETERS.MAX = . Pitch, Units.MIN Dimension Limits = p. Pitch, INCHES*.MIN Dimension Limits = . Pitch, INCHES*. = .050. Pitch, INCHES*.MAX NOM = . Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 1.27. Pitch, MILLIMETERS.MAX = . Pins per Side, Units.MIN Dimension Limits = n1. Pins per Side, INCHES*.MIN Dimension Limits = . Pins per Side, INCHES*. = 11. Pins per Side, INCHES*.MAX NOM = . Pins per Side, MILLIMETERS.MIN = . Pins per Side, MILLIMETERS.NOM = 11. Pins per Side, MILLIMETERS.MAX = . Overall Height, Units.MIN Dimension Limits = A. Overall Height,",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nINCHES*.MIN Dimension Limits = .165. Overall Height, INCHES*. = .173. Overall Height, INCHES*.MAX NOM = .180. Overall Height, MILLIMETERS.MIN = 4.19. Overall Height, MILLIMETERS.NOM = 4.39. Overall Height, MILLIMETERS.MAX = 4.57. Molded Package Thickness, Units.MIN Dimension Limits = A2. Molded Package Thickness, INCHES*.MIN Dimension Limits = .145. Molded Package Thickness, INCHES*. = .153. Molded Package Thickness, INCHES*.MAX NOM = .160. Molded Package Thickness, MILLIMETERS.MIN = 3.68. Molded Package Thickness, MILLIMETERS.NOM = 3.87. Molded Package Thickness, MILLIMETERS.MAX = 4.06. Standoff \u00a7, Units.MIN Dimension Limits = A1. Standoff \u00a7, INCHES*.MIN Dimension Limits = .020. Standoff \u00a7, INCHES*. = .028. Standoff \u00a7, INCHES*.MAX NOM = .035. Standoff \u00a7, MILLIMETERS.MIN = 0.51. Standoff \u00a7, MILLIMETERS.NOM =",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n0.71. Standoff \u00a7, MILLIMETERS.MAX = 0.89. Side 1 Chamfer Height, Units.MIN Dimension Limits = A3. Side 1 Chamfer Height, INCHES*.MIN Dimension Limits = .024. Side 1 Chamfer Height, INCHES*. = .029. Side 1 Chamfer Height, INCHES*.MAX NOM = .034. Side 1 Chamfer Height, MILLIMETERS.MIN = 0.61. Side 1 Chamfer Height, MILLIMETERS.NOM = 0.74. Side 1 Chamfer Height, MILLIMETERS.MAX = 0.86. Corner Chamfer 1, Units.MIN Dimension Limits = CH1. Corner Chamfer 1, INCHES*.MIN Dimension Limits = .040. Corner Chamfer 1, INCHES*. = .045. Corner Chamfer 1, INCHES*.MAX NOM = .050. Corner Chamfer 1, MILLIMETERS.MIN = 1.02. Corner Chamfer 1, MILLIMETERS.NOM = 1.14. Corner Chamfer 1, MILLIMETERS.MAX =",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n1.27. Corner Chamfer (others), Units.MIN Dimension Limits = CH2. Corner Chamfer (others), INCHES*.MIN Dimension Limits = .000. Corner Chamfer (others), INCHES*. = .005. Corner Chamfer (others), INCHES*.MAX NOM = .010. Corner Chamfer (others), MILLIMETERS.MIN = 0.00. Corner Chamfer (others), MILLIMETERS.NOM = 0.13. Corner Chamfer (others), MILLIMETERS.MAX = 0.25. Overall Width, Units.MIN Dimension Limits = E. Overall Width, INCHES*.MIN Dimension Limits = .685. Overall Width, INCHES*. = .690. Overall Width, INCHES*.MAX NOM = .695. Overall Width, MILLIMETERS.MIN = 17.40. Overall Width, MILLIMETERS.NOM = 17.53. Overall Width, MILLIMETERS.MAX = 17.65. Overall Length, Units.MIN Dimension Limits = D. Overall Length, INCHES*.MIN Dimension Limits = .685. Overall",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nLength, INCHES*. = .690. Overall Length, INCHES*.MAX NOM = .695. Overall Length, MILLIMETERS.MIN = 17.40. Overall Length, MILLIMETERS.NOM = 17.53. Overall Length, MILLIMETERS.MAX = 17.65. Molded Package Width, Units.MIN Dimension Limits = E1. Molded Package Width, INCHES*.MIN Dimension Limits = .650. Molded Package Width, INCHES*. = .653. Molded Package Width, INCHES*.MAX NOM = .656. Molded Package Width, MILLIMETERS.MIN = 16.51. Molded Package Width, MILLIMETERS.NOM = 16.59. Molded Package Width, MILLIMETERS.MAX = 16.66. Molded Package Length, Units.MIN Dimension Limits = D1. Molded Package Length, INCHES*.MIN Dimension Limits = .650. Molded Package Length, INCHES*. = .653. Molded Package Length, INCHES*.MAX NOM = .656. Molded Package Length, MILLIMETERS.MIN = 16.51. Molded Package Length, MILLIMETERS.NOM = 16.59. Molded Package Length,",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nMILLIMETERS.MAX = 16.66. Footprint Width, Units.MIN Dimension Limits = E2. Footprint Width, INCHES*.MIN Dimension Limits = .590. Footprint Width, INCHES*. = .620. Footprint Width, INCHES*.MAX NOM = .630. Footprint Width, MILLIMETERS.MIN = 14.99. Footprint Width, MILLIMETERS.NOM = 15.75. Footprint Width, MILLIMETERS.MAX = 16.00. Footprint Length, Units.MIN Dimension Limits = D2. Footprint Length, INCHES*.MIN Dimension Limits = .590. Footprint Length, INCHES*. = .620. Footprint Length, INCHES*.MAX NOM = .630. Footprint Length, MILLIMETERS.MIN = 14.99. Footprint Length, MILLIMETERS.NOM = 15.75. Footprint Length, MILLIMETERS.MAX = 16.00. Lead Thickness, Units.MIN Dimension Limits = c. Lead Thickness, INCHES*.MIN Dimension Limits = .008. Lead Thickness, INCHES*. = .011. Lead Thickness, INCHES*.MAX NOM = .013. Lead Thickness, MILLIMETERS.MIN =",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n0.20. Lead Thickness, MILLIMETERS.NOM = 0.27. Lead Thickness, MILLIMETERS.MAX = 0.33. Upper Lead Width, Units.MIN Dimension Limits = B1. Upper Lead Width, INCHES*.MIN Dimension Limits = .026. Upper Lead Width, INCHES*. = .029. Upper Lead Width, INCHES*.MAX NOM = .032. Upper Lead Width, MILLIMETERS.MIN = 0.66. Upper Lead Width, MILLIMETERS.NOM = 0.74. Upper Lead Width, MILLIMETERS.MAX = 0.81. Lower Lead Width, Units.MIN Dimension Limits = B. Lower Lead Width, INCHES*.MIN Dimension Limits = .013. Lower Lead Width, INCHES*. = .020. Lower Lead Width, INCHES*.MAX NOM = .021. Lower Lead Width, MILLIMETERS.MIN = 0.33. Lower Lead Width, MILLIMETERS.NOM = 0.51. Lower Lead Width, MILLIMETERS.MAX = 0.53. Mold Draft Angle Top, Units.MIN Dimension Limits = \uf061. Mold Draft Angle Top, INCHES*.MIN Dimension",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nLimits = 0. Mold Draft Angle Top, INCHES*. = 5. Mold Draft Angle Top, INCHES*.MAX NOM = 10. Mold Draft Angle Top, MILLIMETERS.MIN = 0. Mold Draft Angle Top, MILLIMETERS.NOM = 5. Mold Draft Angle Top, MILLIMETERS.MAX = 10. Mold Draft Angle Bottom, Units.MIN Dimension Limits = \uf062. Mold Draft Angle Bottom, INCHES*.MIN Dimension Limits = 0. Mold Draft Angle Bottom, INCHES*. = 5. Mold Draft Angle Bottom, INCHES*.MAX NOM = 10. Mold Draft Angle Bottom, MILLIMETERS.MIN = 0. Mold Draft Angle Bottom, MILLIMETERS.NOM = 5. Mold Draft Angle Bottom, MILLIMETERS.MAX = 10\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed\n.010' (0.254mm) per side. JEDEC Equivalent:  MO-047 Drawing No. C04-048",
    "PIC18CXX2\nNOTES:",
    "APPENDIX A: REVISION HISTORY\nRevision A (July 1999)\nOriginal data sheet for PIC18CXX2 family.",
    "Revision B (March 2001)\nAdded DC and AC characteristics graphs (Section 22.0).",
    "Revision C (January 2013)\nAdded a note to each package outline drawing.",
    "TABLE 1: DEVICE DIFFERENCES\nProgram Memory (Kbytes), PIC18C242 = 16. Program Memory (Kbytes), PIC18C252 = 32. Program Memory (Kbytes), PIC18C442 = 16. Program Memory (Kbytes), PIC18C452 = 32. Data Memory (Bytes), PIC18C242 = 512. Data Memory (Bytes), PIC18C252 = 1536. Data Memory (Bytes), PIC18C442 = 512. Data Memory (Bytes), PIC18C452 = 1536. A/D Channels, PIC18C242 = 5. A/D Channels, PIC18C252 = 5. A/D Channels, PIC18C442 = 8. A/D Channels, PIC18C452 = 8. Parallel Slave Port (PSP), PIC18C242 = No. Parallel Slave Port (PSP), PIC18C252 = No. Parallel Slave Port (PSP), PIC18C442 = Yes. Parallel Slave Port (PSP), PIC18C452 = Yes. Package Types, PIC18C242 = 28-pin DIP",
    "TABLE 1: DEVICE DIFFERENCES\n28-pin SOIC 28-pin JW. Package Types, PIC18C252 = 28-pin DIP 28-pin SOIC 28-pin JW. Package Types, PIC18C442 = 40-pin DIP 44-pin PLCC 44-pin TQFP 40-pin JW. Package Types, PIC18C452 = 40-pin DIP 44-pin PLCC 44-pin TQFP 40-pin JW",
    "PIC18CXX2\nAPPENDIX B:\nDEVICE\nDIFFERENCES\nThe differences between the devices listed in this data sheet are shown in Table 1.",
    "APPENDIX C: CONVERSION CONSIDERATIONS\nThis  appendix  discusses  the  considerations  for  converting from previous versions of a device to the ones listed in this data sheet. Typically, these changes are due to the differences in the process technology used. An  example  of  this  type  of  conversion  is  from  a PIC16C74A to a PIC16C74B.\nNot Applicable\nAPPENDIX D:\nMIGRATION FROM BASELINE TO ENHANCED DEVICES\nThis section discusses how to migrate from a Baseline device (i.e., PIC16C5X) to an Enhanced MCU device (i.e., PIC18CXXX).\nThe  following  are  the  list  of  modifications  over  the PIC16C5X microcontroller family:\nNot Currently Available",
    "APPENDIX E: MIGRATION FROM MID-RANGE TO ENHANCED DEVICES\nA detailed  discussion of the  differences between  the mid-range  MCU  devices  (i.e.,  PIC16CXXX)  and  the enhanced  devices  (i.e.,  PIC18CXXX)  is  provided  in AN716,  ' Migrating  Designs  from  PIC16C74A/74B  to PIC18C442 .'  The  changes  discussed,  while  device specific,  are  generally  applicable  to  all  mid-range  to enhanced device migrations.\nThis Application Note is available as Literature Number DS00716.",
    "APPENDIX F: MIGRATION FROM HIGH-END TO ENHANCED DEVICES\nA detailed discussion of the migration pathway and differences  between  the  high-end  MCU  devices  (i.e., PIC17CXXX) and the enhanced devices (i.e., PIC18CXXX)  is  provided  in  AN726,  ' PIC17CXXX to PIC18CXXX Migration .' This Application Note is available as Literature Number DS00726.",
    "PIC18CXX2\nNOTES:",
    "A\nA/D ..................................................................................., 1 = 165. A/D Converter Flag (ADIF Bit) ................................., 1 = 167. A/D Converter Interrupt, Configuring, 1 = ....................... 168. ADCON0 Register ...................................................., 1 = 165. ADCON1 Register, 1 =",
    "A\n............................................ 165, 166. ADRES Register, 1 = .............................................. 165, 167. Analog Port Pins .................................................., 1 = 89, 90. Analog Port Pins, Configuring, 1 = .................................. 170. Associated Registers",
    "A\n..............................................., 1 = 172. Block Diagram .........................................................., 1 = 167. Block Diagram, Analog Input Model, 1 = ......................... 168. Configuring the Module ............................................, 1 = 168. Conversion Clock (T AD)",
    "A\n..........................................., 1 = 170. Conversion Status (GO/DONE Bit), 1 = .......................... 167. Conversions ............................................................., 1 = 171. Converter Characteristics, 1 = ........................................ 261. Equations, 1 =",
    "A\n................................................................. 169. Sampling Requirements, 1 = ........................................... 168. Sampling Time, 1 = ......................................................... 169 110,. Special Event Trigger (CCP), 1 = ............................ 171. Timing Diagram",
    "A\n........................................................, 1 = 262. Absolute Maximum Ratings ............................................., 1 = 235. ACKSTAT ........................................................................, 1 = 139. ADCON0 Register, 1 =",
    "A\n............................................................ 165. ADCON1 Register, 1 = .................................................... 165, 166. ADDLW, 1 = ............................................................................ 193. ADDWF",
    "A\n............................................................................, 1 = 193. ADDWFC, 1 = ......................................................................... 194. ADRES Register, 1 = ...................................................... 165, 167. Analog-to-Digital Converter. See A/D ANDLW",
    "A\n............................................................................, 1 = 194 195. ANDWF ............................................................................, 1 = . Assembler, 1 = . MPASM Assembler, 1 = .................................................. 229. B, 1 = . BCF",
    "A\n.................................................................................., 1 = 196. BF ...................................................................................., 1 = 139. Block Diagrams A/D Converter, 1 = .......................................................... 167 168. Baud Rate Generator",
    "A\n............................................... Capture Mode Operation Compare Mode Operation, 1 = 136. , 1 = ......................................... 109. Low Voltage Detect, 1 = ....................................... 110. External Reference Source, 1 = .............................. 174. Internal Reference Source, 1 = ............................... 174. MSSP",
    "A\n.........................................................., 1 = . I 2 C Mode, 1 = 128 121 ................................................. SPI Mode ......................................................... On-Chip Reset Circuit, 1 = 25. PORTA and RA5 Port Pins, 1 = . Parallel Slave Port (PORTD and PORTE), 1 = ................. 90. , 1 =",
    "A\n............................. 77. Pin, 1 = .................................................. 78. RA3:RA0 RA4/T0CKI, 1 = . RA6 Pin .............................................................., 1 = 78\nPORTB",
    "A\nRB3 Pin, 1 = ............................................................. 81. RB3:RB0 Port Pins, 1 = ............................................ 81. RB7:RB4 Port Pins ............................................, 1 = 80. PORTC (Peripheral Output Override), 1 = ........................ 83. PORTD (I/O Mode)",
    "A\n...................................................., 1 = 85. PORTE (I/O Mode), 1 = 87. .................................................... PWM Operation (Simplified), 1 = .................................... 112. SSP (SPI Mode), 1 = ...................................................... 121. Timer1, 1 =",
    "A\n....................................................................... 98. Timer1 (16-bit R/W Mode), 1 = ......................................... 98. Timer2, 1 = ..................................................................... 102. Timer3, 1 =",
    "A\n..................................................................... 104. Timer3 (16-bit R/W Mode), 1 = ....................................... 104. USART, 1 = . Asynchronous Receive, 1 = .................................... 157. Asynchronous Transmit, 1 = ................................... 155. Watchdog Timer, 1 =",
    "A\n...................................................... 184. BN .................................................................................... BNC, 1 = 196 197. BNOV .............................................................................., 1 = 198.",
    "A\n................................................................................., 1 = . BNZ, 1 = 198. BOR. See Brown-out Reset, 1 = . BOV ................................................................................., 1 = 201 199. BRA",
    "A\n................................................................................., 1 = 179. BRG. See Baud Rate Generator Brown-out Reset (BOR) ............................................. Timing Diagram, 1 = 26, ....................................................... 248. BSF",
    "A\n.................................................................................., 1 = 199. BTFSC ............................................................................., 1 = 200. BTFSS ............................................................................., 1 =",
    "A\n200. BTG ................................................................................., 1 = 201. Bus Collision During a Repeated START Condition, 1 = ........ 147. Bus Collision During a START Condition ........................, 1 = 145. Bus Collision During a STOP Condition, 1 = .......................... 148. BZ",
    "A\n...................................................................................., 1 = 202. C, 1 = . CALL ................................................................................, 1 = 202. Capture (CCP Module) ...................................................., 1 = 109. Associated Registers, 1 =",
    "A\n............................................... 111. Block Diagram, 1 = ......................................................... 109. CCP Pin Configuration ............................................, 1 = 109. Software Interrupt, 1 = .................................................... 109. Timer1 Mode Selection, 1 = 109.",
    "A\n............................................, 1 = . Capture/Compare/PWM (CCP) ......................................., 1 = 107. Capture Mode. See Capture ......................................................................., 1 = . CCP1, 1 = 108. CCPR1H Register, 1 = ........................................... 108. CCPR1L Register",
    "A\n............................................, 1 = 108. CCP1CON and CCP2CON Registers, 1 = ..................... 107. CCP2 ......................................................................., 1 = 108. CCPR2H Register CCPR2L Register, 1 = ........................................... 108 108. Compare Mode. See Compare, 1 = . Interaction of Two CCP Modules PWM Mode. See PWM, 1 =",
    "A\n............................. 108. Timer Resources ....................................................., 1 = 108. Timing Diagram, 1 = ....................................................... 250. Clocking Scheme CLRF ..............................................................................., 1 =",
    "A\n............................................................... 39 203. CLRWDT, 1 = ......................................................................... 203",
    "PIC18CXX2\nCode Examples\n16 x 16 Signed Multiply Routine ................................, 1 = 62. 16 x 16 Unsigned Multiply Routine, 1 = ............................ 62. 8 x 8 Signed Multiply Routine ...................................., 1 = 61. 8 x 8 Unsigned Multiply Routine, 1 = ................................ 61. Changing Between Capture Prescalers, 1 = ................... 109. Fast Register Stack, 1 =",
    "PIC18CXX2\n.................................................... 39. Initializing PORTA, 1 = ...................................................... 77. Initializing PORTB, 1 = ...................................................... 80. Initializing PORTC, 1 = ...................................................... 83. Initializing PORTD, 1 =",
    "PIC18CXX2\n...................................................... 85. Initializing PORTE, 1 = ...................................................... 87. Loading the SSPBUF Register ................................, 1 = 122. Saving STATUS, WREG and BSR Registers in RAM ..............................................................., 1 = 75. Code Protection, 1 =",
    "PIC18CXX2\n....................................................... 179, 186. COMF ..............................................................................., 1 = 204. Compare (CCP Module) ..................................................., 1 = 110. Associated Registers",
    "PIC18CXX2\n.........................................................., 1 = ............................................... 111. Block Diagram, 1 = 110. CCP Pin Configuration ............................................., 1 = 110. CCPR1H:CCPR1L Registers, 1 = ................................... 110. Software Interrupt",
    "PIC18CXX2\n...................................................., 1 = 110. Special Event Trigger ........................., 1 = 99, 105, 110, 171. Timer1 Mode Selection, 1 = ............................................ 110. Configuration Bits ............................................................. Context Saving During, 1 = 179",
    "PIC18CXX2\n....................................... 75. Interrupts Example Code ..........................................................., 1 = 75. Conversion Considerations, 1 = .............................................. 288. CPFSEQ, 1 = .......................................................................... 204. CPFSGT, 1 =",
    "PIC18CXX2\n........................................................................... 205. CPFSLT, 1 = ........................................................................... 205. D, 1 = . Data Memory, 1 = ...................................................................... 42. General Purpose Registers, 1 =",
    "PIC18CXX2\n........................................ 42. Special Function Registers, 1 = ........................................ 42. DAW ................................................................................., 1 = 206. DC Characteristics, 1 = ................................................... 237, 240. DECF",
    "PIC18CXX2\n..............................................................................., 1 = 206. DECFSNZ, 1 = ........................................................................ 207. DECFSZ ..........................................................................., 1 = 207. Device Differences, 1",
    "PIC18CXX2\n= ........................................................... 287. Direct Addressing, 1 = ............................................................... 51. E, 1 = . Electrical Characteristics .................................................., 1 = 235. Errata, 1 =",
    "PIC18CXX2\n................................................................................... 5. F, 1 = . Firmware Instructions, 1 = ....................................................... 187. G, 1 = . , 1 = ....................................... General Call Address Sequence, 1 = 133. General Call Address Support, 1 =",
    "PIC18CXX2\n......................................... 133 ............................................................................... 208",
    "I\nI 2 C (SSP Module), 77 = ............................................................ 128. ACK Pulse, 77 = ....................................................... 128, 129. Addressing, 77 = ............................................................... 129. Block Diagram, 77 =",
    "I\n......................................................... 128. Read/Write Bit Information (R/W Bit), 77 = ....................... 129. Reception, 77 = ................................................................ 129. Serial Clock (RC3/SCK/SCL), 77 = ................................... 129. Slave Mode",
    "I\n.............................................................., 77 = 128. Timing Diagram, Data .............................................., 77 = 257. Timing Diagram, START/STOP Bits, 77 = ........................ 256. Transmission, 77 = ........................................................... 129. I 2 C Master Mode Reception",
    "I\n............................................, 77 = 139. I 2 C Master Mode Repeated START Condition, 77 = ................ 138. I 2 C Module, 77 = . Acknowledge Sequence Timing, 77 = .............................. 142. Baud Rate Generator, 77 = . Block Diagram, 77 = . Baud Rate Generator, 77 = 136. ...................................... BRG Reset Due to SDA Collision, 77 = ............................ 146. BRG Timing",
    "I\n............................................................., 77 = 136. Bus Collision, 77 = . Acknowledge, 77 = ................................................... 144. Repeated START Condition, 77 = 147. ............................ Repeated START Condition Timing, 77 = . (Case 1) ..................................................., 77 = 147. Repeated START Condition Timing",
    "I\n..................................................., 77 = . (Case 2), 77 = 147. START Condition ............................................., 77 = 145. START Condition Timing, 77 = ......................... 145, 146. STOP Condition ..............................................., 77 = 148. STOP Condition Timing (Case 1), 77 = .................... 148. STOP Condition Timing",
    "I\n..............................................., 77 = (Case 2) .................... 148. Transmit Timing, 77 = 144. Bus Collision Timing, 77 = ................................................ 144. Clock Arbitration, 77 = ...................................................... 143. Clock Arbitration Timing (Master Transmit), 77 = ............. 143 133. General Call Address Support",
    "I\n................................. Master Mode 7-bit Reception Timing, 77 = . ..........................................., 77 = ....................... 141. Master Mode Operation, 77 = 135 137. Master Mode START Condition Master Mode Transmission ....................................., 77 = ............................... 139. Master Mode Transmit Sequence, 77 = ............................ 135. Multi-Master Mode",
    "I\n..................................................., 77 = 144. Repeat START Condition Timing, 77 = ............................ 138. STOP Condition Receive or Transmit Timing, 77 = .......... 143. STOP Condition Timing, 77 = 142. ........................................... Waveforms for 7-bit Reception, 77 = ................................ 130. Waveforms for 7-bit Transmission, 77 = 130. ICEPIC In-Circuit Emulator, 77 =",
    "I\n............................ ............................................................., 77 = .............................................. 230. ID Locations ................................................................................, 77 = 179, 186. INCF, 77 = 208. INCFSZ",
    "I\n............................................................................, 77 = 209. In-Circuit Serial Programming (ICSP), 77 = ...................... 179, 186. Indirect Addressing, 77 = ............................................................ 51 ............................................................. 50. FSR Register INFSNZ",
    "I\n............................................................................, 77 = 209. Instruction Cycle, 77 = ................................................................ 39. Instruction Flow/Pipelining Instruction Format ............................................................, 77 =",
    "I\n................................................. 40 189",
    "I\nSet, 1 = .................................................................. 187. ADDLW, 1 = .................................................................... 193. ADDWF, 1 = .................................................................... 193. ADDWFC, 1 =",
    "I\n................................................................. 194. ANDLW, 1 = .................................................................... 194. ANDWF, 1 = .................................................................... 195. BC",
    "I\n............................................................................, 1 = 195. BCF, 1 = .......................................................................... 196. BN, 1 = ............................................................................ 196. BNC, 1 =",
    "I\n......................................................................... 197. BNOV, 1 = ....................................................................... 198. BNZ, 1 = .......................................................................... 198. BOV, 1 =",
    "I\n......................................................................... 201. BRA, 1 = .......................................................................... 199. BSF .........................................................................., 1 = 199. BTFSC, 1 =",
    "I\n..................................................................... 200. BTFSS, 1 = ..................................................................... 200. BTG, 1 = .......................................................................... 201. BZ, 1 =",
    "I\n............................................................................ 202. , 1 = ........................................................................ 202. CALL CLRF, 1 = ........................................................................ 203. CLRWDT, 1 =",
    "I\n.................................................................. 203. COMF ......................................................................, 1 = 204. CPFSEQ, 1 = .................................................................. 204. CPFSGT, 1 =",
    "I\n.................................................................. 205. CPFSLT ........................................................................., 1 = ................................................................... 205. DAW, 1 = 206. DECF DECFSNZ, 1 =",
    "I\n....................................................................... 206 ................................................................ 207. DECFSZ, 1 = ................................................................... 207. , 1 =",
    "I\n...................................................................... 208. GOTO, 1 = . INCFSZ INFSNZ, 1 = .................................................................... 209. , 1 = .................................................................... 209. IORLW, 1 =",
    "I\n..................................................................... 210. IORWF, 1 = ..................................................................... 210 ........................................................................ 211. MOVF, 1 =",
    "I\n....................................................................... 211. LFSR, 1 = .................................................................... 212. MOVFF MOVLB, 1 = .................................................................... 212. MOVLW, 1 =",
    "I\n................................................................... 213. MOVWF, 1 = ................................................................... 213. MULLW, 1 = .................................................................... 214",
    "I\n.................................................................... 214. MULWF, 1 = . NEGF, 1 = ....................................................................... 215. NOP, 1 = ......................................................................... 215. RCALL, 1 =",
    "I\n..................................................................... 217. RESET, 1 = ..................................................................... 217. RETFIE, 1 = .................................................................... 218. RETLW, 1 =",
    "I\n.................................................................... 218. RETURN RLCF ........................................................................, 1 = .................................................................. 219. , 1 = 219",
    "I\n..................................................................... 220. RLNCF, 1 = 220. RRCF, 1 = ....................................................................... .................................................................... 221. RRNCF, 1 = . SETF SLEEP, 1 =",
    "I\n........................................................................ 221 ..................................................................... 222. , 1 = 222. SUBFWB, 1 = ................................................................... SUBLW, 1 =",
    "I\n.................................................................... 223 223. SUBWF, 1 = ..................................................................... SUBWFB SWAPF, 1 = .................................................................. 224",
    "I\n.................................................................... 224. TBLRD, 1 = ..................................................................... 225. TBLWT, 1 = ..................................................................... 226. TSTFSZ, 1 =",
    "I\n.................................................................... , 1 = 227",
    "PIC18CXX2\nXORLW, 1 = ................................................................... 227. XORWF, 1 = 228. ................................................................... Summary Table, 1 = ....................................................... 190. INT Interrupt (RB0/INT). See Interrupt Sources INTCON Register",
    "PIC18CXX2\n....................................................................., 1 = . RBIF Bit, 1 = 80. INTCON Registers, 1 = ............................................................. 65. Inter-Integrated Circuit. See I 2 C, 1 = . Internal Program Memory Read/Writes ..............................................................., 1 = 57. Interrupt Sources, 1 =",
    "PIC18CXX2\n....................................................... 63, 179. A/D Conversion Complete, 1 = ....................................... 168. Capture Complete (CCP), 1 = ........................................ 109. Compare Complete (CCP), 1 = ...................................... 110. INT0, 1 =",
    "PIC18CXX2\n........................................................................... 75. Interrupt-on-Change (RB7:RB4, 1 = ) ............................... 80 .................................................... PORTB, on Change, 1 = 75. RB0/INT Pin, External ..............................................., 1 = 75. SSP Receive/Transmit",
    "PIC18CXX2\nComplete, 1 = ............................ 115. TMR0, 1 = ......................................................................... 75. TMR0 Overflow, 1 = .......................................................... 95. TMR1 Overflow ...................................., 1 = 97, 99, 103, 105. TMR2 to PR2 Match",
    "PIC18CXX2\n................................................, 1 = 102 112. TMR2 to PR2 Match (PWM) ............................, 1 = 101,. USART Receive/Transmit Complete, 1 = ....................... 149. Interrupts, Enable Bits CCP1 Enable (CCP1IE Bit), 1 = ..................................... 109. Interrupts, Flag Bits, 1 = . A/D Converter Flag (ADIF Bit), 1 = ................................. 167.",
    "PIC18CXX2\nCCP1 Flag (CCP1IF Bit) .................................., 1 = 109, 110. Interrupt-on-Change (RB7:RB4) Flag (RBIF, 1 = Bit) ....... 80. IORLW, 1 = ............................................................................. 210. IORWF, 1 = .............................................................................",
    "PIC18CXX2\n210. IPR Registers, 1 = ..................................................................... 72. K, 1 = . KEELOQ Evaluation and Programming Tools, 1 = ................... 232. L, 1 = . LFSR ..............................................................................., 1 = 211. Long Write, 1 = . and Interrupts, 1 =",
    "PIC18CXX2\n............................................................ 59. Operation ..................................................................., 1 = 58. Sequence of Events, 1 = .................................................. 58. Unexpected Termination, 1 = ........................................... 59. Low Voltage Detect, 1 = 173.",
    "PIC18CXX2\n......................................................... Block Diagrams, 1 = . External Reference Source, 1 = ............................. 174. Internal Reference Source, 1 = ............................... 174. Converter Characteristics, 1 = ........................................ 242. Effects of a RESET, 1 = .................................................. 177. Operation",
    "PIC18CXX2\n................................................................., 1 = 176. Current Consumption, 1 = ...................................... 177. During SLEEP ................................................., 1 = 177. Reference Voltage Set Point See Low Voltage Detect., 1 = ........................... 177",
    "M\nData Memory .............................................................,  = 42. Program Memory .......................................................,  = 35. Migration from Baseline to Enhanced Devices,  = ................ 288. MOVF ...............................................................................,  = 211. MOVFF,",
    "M\n= ............................................................................. 212. MOVLB,  = ............................................................................. 212. MOVLW,",
    "M\n= ............................................................................ 213. MOVWF ...........................................................................,  = 213. MPLAB C17 and MPLAB C18 C Compilers,  = ..................... 229. MPLAB ICD In-Circuit Debugger ......................................,",
    "M\n= 231. MPLAB ICE High Performance Universal In-Circuit Emulator with MPLAB IDE,  = ........................ 230. MPLAB Integrated Development Environment Software ..............................................,  = 229. MPLINK Object Linker/MPLIB Object Librarian ............................................................................,  = ............... 230. MULLW,",
    "M\n= 214. MULWF ............................................................................,  = ........................................................... 144. Multi-Master Mode,  = . N,  = 214. ,  = ............................................................................... 215. NEGF NOP,",
    "M\n= ................................................................................. 215. O,  = . On-Chip Reset Circuit Block Diagram,",
    "M\n= ............................................................ 25 188. OPCODE Field Descriptions OPTION_REG Register PS2:PS0 Bits ............................................................. PSA Bit .......................................................................",
    "M\n.....................................................................,",
    "M\n= ............................................ 95 95. T0CS Bit,  = 95. T0SE Bit,  = 95. ..................................................................... Oscillator Configuration,  = .................................................... 179. Oscillator Configurations,",
    "M\n= .................................................... 17 17. HS .............................................................................. PLL ....................................................................,",
    "M\n= . HS + ...............................................................................,  = 17 17. LP,  = 17, 18. RC ........................................................................,  = 17. RCIO,",
    "M\n= ........................................................................... XT .............................................................................. Timer1 .........................................,",
    "M\n= 17. Oscillator, Oscillator, WDT ................................................................,  = 97, 99, 103, 105. ,  = 183. ,  = 277. P Packaging ........................................................................ Parallel Slave Port (PSP),",
    "M\n= ............................................. 85, 90 ................................................. 91. Associated Registers Block Diagram ............................................................ RE0/RD/AN5 Pin ..................................................",
    "M\n.................................................,",
    "M\n= 90 89, 90. RE1/WR/AN6 Pin,  = 89, 90 89,. RE2/CS/AN7 Pin .................................................. Read Waveforms,  = 90. Select (PSPMODE,  = ....................................................... 91 85, 90. Bit) ........................................................,",
    "M\n= ......................................... Timing Diagram,  = 251. Write Waveforms,  = 90. ....................................................... 1 Low Cost PIC,  = 231. PICDEM MCU Demonstration Board ...............................................,  = ................................... 232. PICDEM 17 Demonstration Board PICDEM 2 Low Cost PIC16CXX,",
    "M\n= . Demonstration Board ............................................... PICDEM 3 Low Cost PIC16CXXX,  = 231. Demonstration Board ...............................................,  = . ,  = 232",
    "M\nPIE Registers Pin Functions, Development System ......... 231 = ..................................................................... 70. MCLR/VPP, Development System ......... 231 = ........................................................... 10, 13. OSC1/CLKIN ......................................................., Development System ......... 231 = 10, 13.",
    "M\nOSC2/CLKOUT, Development System ......... 231 = ................................................... 10, 13. RA0/AN0, Development System ......... 231 = .............................................................. 10, 13. RA1/AN1, Development System ......... 231 = .............................................................. 10, 13. RA2/AN2, Development System",
    "M\n......... 231 = 10, 13. .............................................................. RA3/AN3/VREF, Development System ......... 231 = ..................................................... 10, 13. RA4/T0CKI .........................................................., Development System ......... 231 = 10, 13. RA5/AN4/SS, Development System",
    "M\n......... 231 = ........................................................ 10, 13. RB0/INT, Development System ......... 231 = ............................................................... 11, 14. RB1 ......................................................................, Development System ......... 231 = 11, 14. RB2",
    "M\n......................................................................, Development System ......... 231 = 11, 14. RB3 ......................................................................, Development System ......... 231 = 11, 14. RB4 ......................................................................, Development System",
    "M\n......... 231 = 11, 14. RB5 ......................................................................, Development System ......... 231 = 11, 14. RB6 ......................................................................, Development System ......... 231 = 11, 14. RB7",
    "M\n......................................................................, Development System ......... 231 = 11, 14. RC0/T1OSO/T1CKI, Development System ......... 231 = ............................................. 12, 15. RC1/T1OSI/CCP2, Development System ......... 231 = ................................................ 12, 15. RC2/CCP1, Development System .........",
    "M\n231 = ........................................................... 12, 15. RC3/SCK/SCL, Development System ......... 231 = ..................................................... 12, 15. RC4/SDI/SDA, Development System ......... 231 = ...................................................... 12, 15. RC5/SDO",
    "M\n............................................................. RC6/TX/CK, Development System ......... 231 = 12, 15 12, 15. RC7/RX/DT, Development System ......... 231 = .......................................................... 12, 15. RD0/PSP0, Development System ......... 231 =",
    "M\n................................................................. 16. RD1/PSP1, Development System ......... 231 = ................................................................. 16. RD2/PSP2, Development System ......... 231 = ................................................................. 16. RD3/PSP3, Development System",
    "M\n......... 231 = ................................................................. 16. RD4/PSP4, Development System ......... 231 = ................................................................. 16. RD5/PSP5, Development System ......... 231 = ................................................................. 16.",
    "M\nRD6/PSP6, Development System ......... 231 = ................................................................. 16. RD7/PSP7, Development System ......... 231 = ................................................................. 16. RE0/RD/AN5, Development System ......... 231 =",
    "M\n.............................................................. 16. RE1/WR/AN6, Development System ......... 231 = ............................................................. 16. RE2/CS/AN7, Development System ......... 231 = .............................................................. 16. VDD",
    "M\n...................................................................... VSS, Development System ......... 231 = 12, 16 12, 16. PIR Registers, Development System ......... 231 = ..................................................................... 68. Pointer, FSR POR. See Power-on, Development System ......... 231 =",
    "M\n...................................................................... 50. PORTA, Development System ......... 231 = . Associated Registers, Development System ......... 231 = ................................................. 79. Initialization ................................................................, Development System ......... 231 = 77. PORTA Register, Development System ......... 231 =",
    "M\n........................................................ 77. RA3:RA0 and RA5 Port Pins, Development System ......... 231 = ..................................... 77. RA4/T0CKI Pin, Development System ......... 231 = .......................................................... 78. RA6 Pin",
    "M\n....................................................................., Development System ......... 231 = 78 77. PORTB, Development System ......... 231 = . Associated Registers, Development System ......... 231 = ................................................. 82. Initialization ................................................................, Development System ......... 231 = 80. PORTB",
    "M\nRegister, Development System ......... 231 = ........................................................ 80. RB0/INT Pin, External, Development System ......... 231 = ................................................ 75. RB3 Pin, Development System ......... 231 = ..................................................................... 81. RB3:RB0 Port Pins, Development System ......... 231 =",
    "M\n.................................................... 81. RB7:RB4 Interrupt-on-Change Flag (RBIF Bit) RB7:RB4 Port Pins ...................................................., Development System ......... 231 = .......... 80 80. TRISB Register, Development System ......... 231 = .......................................................... 80\nPORTC",
    "M\nAssociated Registers, 1 = ................................................. 84. Block Diagram (Peripheral Output Override), 1 = ............. 83. Initialization .........................................................., 1 = 83, 85. PORTC Register ........................................................, 1 = 83. RC3/SCK/SCL Pin, 1 =",
    "M\n................................................... 129. RC7/RX/DT Pin, 1 = ........................................................ 151. TRISC Register .................................................., 1 = 83, 149. PORTD",
    "M\n.............................................................................., 1 = 90. Associated Registers ................................................., 1 = 86 .......................................... Block Diagram (I/O Mode), 1 = 85. Parallel Slave Port (PSP) Function, 1 = ............................ 85",
    "M\n......................................................... PORTD Register, 1 = 85. TRISD Register, 1 = .......................................................... 85. PORTE, 1 = . Analog Port Pins .................................................., 1 = 89, 90. Associated Registers, 1 = ................................................. 89. Block Diagram",
    "M\n(I/O Mode), 1 = ......................................... 87. Initialization, 1 = ................................................................ 87. PORTE Register, 1 = 87. ........................................................ PSP Mode Select (PSPMODE Bit), 1 = ...................... 85, 90. RE0/RD/AN5 Pin",
    "M\n.................................................., 1 = 89, 90. RE1/WR/AN6 Pin ................................................., 1 = 89, 90. RE2/CS/AN7 Pin .................................................., 1 = 89, 90. TRISE Register, 1 = .................................................... 87, 88. Postscaler, WDT,",
    "M\n1 = . Assignment (PSA Bit), 1 = ................................................ 95. Rate Select (PS2:PS0 Bits), 1 = ....................................... 95. Switching Between Timer0 and WDT, 1 = ........................ 95. Power-down Mode. See SLEEP. .............................................., 1 = . Power-on Reset (POR), 1 = 26, 179. Oscillator Start-up Timer (OST)",
    "M\n........................., 1 = 26, 179. Power-up Timer (PWRT) ..................................., 1 = 26, 179. Time-out Sequence, 1 = .................................................... 26. Time-out Sequence on Power-up, 1 = ........................ 32, 33. Timing Diagram, 1 = ........................................................ 248. Prescaler, Capture",
    "M\n..........................................................., 1 = 109. Prescaler, Timer0, 1 = ............................................................... 95. Assignment (PSA Bit), 1 = ................................................ 95. Rate Select (PS2:PS0 Bits), 1 = ....................................... 95. Switching Between Timer0",
    "M\nand WDT ..............................................................., 1 = ........................ 95. Prescaler, Timer1, 1 = 98. Prescaler, Timer2 ............................................................., 1 = 112. PRO MATE II Universal Programmer Product Identification System .........................................., 1 =",
    "M\n.............................. 231. Program Counter, 1 = 301. PCL Register, 1 = .............................................................. 39. PCLATH Register, 1 = ...................................................... 39. Program Memory, 1 = ............................................................... 35. Interrupt Vector",
    "M\n.........................................................., 1 = 35. RESET Vector Program Verification, 1 = ............................................................ 35. ........................................................ Programming, Device Instructions, 1 = 186 187. PSP. See Parallel Slave Port., 1 = .................................... Pulse Width Modulation. See PWM",
    "M\n(CCP Module). PWM (CCP Module) ........................................................, 1 = 112. Associated Registers ..............................................., 1 = 113. Block Diagram .........................................................., 1 = 112. CCPR1H:CCPR1L Registers, 1 = ................................... 112. Duty Cycle, 1 =",
    "M\n................................................................ 112. Example Frequencies/Resolutions, 1 = .......................... 113. Output Diagram, 1 = ........................................................ 112 112. Period ....................................................................... Setup for PWM Operation",
    "M\n........................................ TMR2 to PR2 Match ........................................, 1 = 113 101, 112",
    "Q\nQ Clock, 1 = ............................................................................ 112",
    "R\nRAM. See Data Memory., 1 = . RCALL ............................................................................., 1 = 217. RCON Register, 1 = ............................................................ 53, 56. RCSTA Register, 1 = . SPEN Bit, 1 = .................................................................. 149. Register File, 1 =",
    "R\n....................................................................... 42. Registers, 1 = . ADCON0 (A/D Control 0), 1 = ......................................... 165. ADCON1 (A/D Control 1), 1 = ......................................... 166. CCP1CON and CCP2CON, 1 = . (Capture/Compare/PWM Control), 1 = ................... 107. CONFIG1H (Configuration 1 High), 1 =",
    "R\n.......................... 180. CONFIG1L (Configuration 1 Low), 1 = ........................... 180. CONFIG2H (Configuration 2 High), 1 = .......................... 181. CONFIG2L (Configuration 2 Low), 1 = ........................... 181. CONFIG3H (Configuration 3 High), 1 = .......................... 182. CONFIG4L (Configuration 4 Low), 1 = ........................... 182. Flag",
    "R\n......................................................................, 1 = 68, 69. INTCON (Interrupt Control), 1 = ....................................... 65. INTCON2 (Interrupt Control 2), 1 = .................................. 66. INTCON3 (Interrupt Control 3), 1 = .................................. 67. IPR1 (Peripheral Interrupt Priority 1), 1 =",
    "R\n......................... 72. IPR2 (Peripheral Interrupt Priority 2), 1 = ......................... 73. LVDCON (LVD Control) ..........................................., 1 = 175. PIE2 (Peripheral Interrupt Enable 1), 1 = ......................... 70. PIE2 (Peripheral Interrupt Enable 2), 1 = ......................... 71. PIR1 (Peripheral Interrupt Request 1), 1 = ....................... 68. PIR2 (Peripheral Interrupt Request 2), 1 =",
    "R\n....................... 69. RCON (Register Control) ......................................, 1 = ........................................... 74. RCON (RESET Control), 1 = 53, 56. RCSTA (Receive Status and Control), 1 = ..................... 150. SSPCON1 (SSP Control 1), 1 = ..................................... 118. SSPCON2 (SSP Control 2), 1 =",
    "R\n..................................... 120. STATUS ...................................................................., 1 = 52. STKPTR (Stack Pointer), 1 = ............................................ 38. Summary ................................................................... T0CON (Timer0 Control), 1 = 46",
    "R\n........................................... 93. T1CON (Timer1 Control), 1 = ........................................... 97. T2CON (Timer2 Control), 1 = ......................................... 101. T3CON (Timer3 Control), 1 = ......................................... 103. , 1 = 88. TRISE",
    "R\n........................................................................, 1 = . RESET ..............................................................., 1 = ..................... 149 25, 179, 217. Timing Diagram, 1 = ....................................................... 248. RETFIE, 1 =",
    "R\n............................................................................ 218. RETLW, 1 = ............................................................................ 218. RETURN, 1 = .......................................................................... 219. Revision History, 1 =",
    "R\n............................................................... 287. RLCF, 1 = ............................................................................... 219. RLNCF, 1 = ............................................................................. 220. RRCF",
    "R\n..............................................................................., 1 = 220. RRNCF, 1 = ............................................................................ 221",
    "S\nSCI.\nSee\nUSART.\n.................................................................................., 1 = 121. SCK, 1 = . SDI, 1 = ................................................................................... 121. SDO",
    "S\n................................................................................. Serial Clock, SCK, 1 = 121 121. ............................................................. Serial Communication Interface. See USART, 1 = . Serial Data In, SDI, 1 = ........................................................... 121. Serial Data Out, SDO, 1 =",
    "S\n....................................................... 121. Serial Peripheral Interface. See SPI, 1 = . SETF ................................................................................, 1 = 221. Slave Select Synchronization ..........................................., 1 = 125. Slave Select, SS, 1 =",
    "S\n.............................................................. 121. SLEEP .............................................................., 1 = 179, 185, 222. Software Simulator (MPLAB SIM), 1 = .................................... 230. Special Event Trigger. See Compare, 1 = . Special Features of the CPU, 1 = ............................................ 179. Configuration Registers, 1 =",
    "S\n................................... 180-182. Special Function Registers Map ............................................................................, 1 = ................................................ 42. , 1 = 45. SPI, 1 = ............................................................. Master Mode, 1 = 124",
    "S\n............................................................... Serial Clock, 1 = 121. Serial Data In, 1 = ........................................................... 121. Serial Data Out, 1 = ........................................................ 121. Slave Select, 1 =",
    "S\n............................................................. 121. SPI Clock, 1 = ................................................................. 124. SPI Mode, 1 = ................................................................. 121. SPI Master/Slave Connection, 1 =",
    "S\n.......................................... 123. SPI Module, 1 = . Master/Slave Connection, 1 = ......................................... 123. Slave Mode, 1 = .............................................................. 125. Slave Select Synchronization, 1 = .................................. 125. Slave Synch Timing",
    "S\n................................................., 1 = 125. Slave Timing with CKE = 0, 1 = ...................................... 126. Slave Timing with CKE = 1, 1 = ...................................... 126. ...................................................................................., 1 = . SSP, 1 = 115. SS, 1 = 121",
    "S\n................................................................................... Block Diagram (SPI Mode) I 2 C Mode. See I 2 C. SPI Mode, 1 = ...................................... 121 ................................................................. 121. Associated Registers, 1 =",
    "S\n....................................... 127. Block Diagram SPI Mode. See SPI., 1 = .................................................. 121. SSPBUF ..................................................................., 1 = 124. SSPCON1, 1 = ................................................................ 118.",
    "S\nSSPCON2 Register, 1 = ................................................. 120. SSPSR, 1 = ..................................................................... 124. SSPSTAT, 1 = ................................................................. 116. TMR2 Output for Clock Shift, 1 = ............................ 101, 102. SSP",
    "S\nModule, 1 = . SPI Master Mode, 1 = 124 .................................. ..................................................... SPI Master./Slave Connection, 1 = 123. SPI Slave Mode, 1 = ....................................................... 125. SSPCON1 Register, 1 = .......................................................... 118. SSPOV, 1 =",
    "S\n............................................................................. 139. SSPSTAT Register, 1 = .......................................................... 116. R/W Bit ....................................................................., 1 = 129. STATUS Register, 1 =",
    "S\n............................................................... 52. STKPTR Register, 1 = ............................................................... 38. SUBFWB, 1 = .......................................................................... 222. SUBLW SUBWF, 1 =",
    "S\n............................................................................ 223 ............................................................................ 223. SUBWFB, 1 = .......................................................................... 224. SWAPF",
    "S\n............................................................................, 1 = 224. Synchronous Serial Port. See SSP., 1 = ",
    "T\nTABLAT Register, 1 = ............................................................... 57. Table Pointer Operations (Table), 1 = ...................................... 57. Table Read Operation, Diagram ........................................, 1 = 55. Table Write Operation, Diagram, 1 = ........................................ 55. TBLPTR Register, 1 =",
    "T\n............................................................... 57. TBLRD ............................................................................., 1 = 225. TBLWT ............................................................................., 1 = 226. Timer0",
    "T\n................................................................................, 1 = 93. Clock Source Edge Select (T0SE Bit), 1 = ....................... 95. Clock Source Select (T0CS Bit) ................................., 1 = 95. Overflow Interrupt ......................................................, 1 = 95. Prescaler. See Prescaler, Timer0 T0CON Register",
    "T\n........................................................ ......................................................., 1 = 93. Timing Diagram, 1 = 249. Timer1 ................................................................................, 1 = 97. Block Diagram, 1 =",
    "T\n........................................................... 98. Block Diagram (16-bit R/W Mode), 1 = ............................. 98. Oscillator .............................................. 97, 99,, 1 = 105. Overflow Interrupt ................................ 97, 99,, 1 = 105. Prescaler., 1 =",
    "T\n.................................................................. 98. Special Event Trigger (CCP) ..................... 99,, 1 = 110. T1CON Register, 1 = ........................................................ 97. Timing Diagram ......................................................., 1 = 249. TMR1H Register",
    "T\n................................................, 1 = 103. TMR1L Register ................................................., 1 = 103. Timer2 .............................................................................. ..............................................., 1 = 101. Associated Registers, 1 = 102. Block Diagram",
    "T\n........................................................., 1 = 102. Postscaler. See Postscaler, Timer2. PR2 Register ................................................... Prescaler. See Prescaler, Timer2., 1 = 112. SSP Clock Shift ............................................... T2CON Register ......................................................",
    "T\nTMR2 Register ........................................................., 1 = 102 101. , 1 = 101. TMR2 to PR2 Match Interrupt .................. 101,, 1 = 112. .............................................................................., 1 = 103. Timer3 Associated Registers ..............................................., 1 = 105. Block Diagram",
    "T\n......................................................... ..........................., 1 = 104. Block Diagram (16-bit R/W Mode) ......................................................, 1 = 104. T3CON Register Diagrams, 1 = 103. Timing Acknowledge Sequence Timing .............................. ............, 1 = 142 136. Baud Rate Generator with Clock Arbitration BRG Reset Due to SDA Collision",
    "T\n............................ Bus Collision, 1 = 146 145. START Condition Timing ................................. Bus Collision During a Repeated START Condition (Case 1) ........................................... START, 1 = 147. Bus Collision During a Repeated Condition (Case2) ............................................, 1 = 147. Bus Collision During a START Condition (SCL = 0)",
    "T\n........................................................., 1 = 146. Bus Collision During a STOP Condition .................. Bus Collision for Transmit and Acknowledge .........., 1 = 148 144. I 2 C Bus Data ............................................................ ................, 1 = 259. I 2 C Master Mode First START Bit Timing, 1 = 137. I 2 C Master Mode Reception Timing ......................... 2",
    "T\n..................., 1 = . I C Master Mode Transmission Timing, 1 = 141. Arbitration ................., 1 = 140 143. Master Mode Transmit Clock Repeat START Condition, 1 = 138. ........................................ Slave Synchronization ............................................., 1 = 125. SPI Mode Timing (Master Mode) SPI Mode Master Mode Timing Diagram ......................... SPI Mode Timing (Slave Mode with CKE = 0) ........., 1 = 124 126. SPI Mode Timing (Slave Mode with CKE = 1), 1 = 126.",
    "T\n........., 1 = ",
    "T\nSTOP Condition Receive or Transmit, 1 = ...................... 143. Time-out Sequence on Power-up, 1 = ........................ 32, 33. USART Asynchronous Master Transmission, 1 = ........... 156. USART Asynchronous Reception, 1 = ............................ 158. USART Synchronous Reception, 1 = .............................. 161. USART Synchronous Transmission, 1 = ........................ 160. Wake-up from SLEEP via Interrupt, 1 = .......................... 186. Timing Diagrams",
    "T\nand Specifications, 1 = ................................ 246. A/D Conversion, 1 = ........................................................ 262. Brown-out Reset (BOR), 1 = ........................................... 248. Capture/Compare/PWM (CCP), 1 = ................................ 250. CLKOUT and I/O, 1 =",
    "T\n...................................................... 247. External Clock, 1 = .......................................................... 246. I 2 C Bus Data, 1 = ............................................................ 257. I 2 C Bus START/STOP Bits, 1 = ...................................... 256. Oscillator Start-up Timer (OST),",
    "T\n1 = ............................... 248. Parallel Slave Port (PSP), 1 = ......................................... 251. Power-up Timer (PWRT), 1 = ......................................... 248. RESET, 1 = ..................................................................... 248. Timer0 and Timer1, 1 =",
    "T\n................................................... 249. USART Synchronous Receive (Master/Slave) ................................................., 1 = 260. USART SynchronousTransmission (Master/Slave) ................................................., 1 = 260. Watchdog Timer (WDT), 1 = ........................................... 248. TRISE Register, 1 =",
    "T\n.................................................................. 87. PSPMODE Bit, 1 = ...................................................... 85, 90. TSTFSZ, 1 = ........................................................................... 227. Two-Word Instructions, 1 = . Example Cases, 1 =",
    "T\n.......................................................... 41. TXSTA Register, 1 = . BRGH Bit, 1 = ................................................................. 151",
    "U\nUniversal Synchronous Asynchronous Receiver\nTransmitter.\nSee\nUSART.\nUSART ............................................................................. 149\nAsynchronous Mode  ................................................ 155\nAssociated Registers, Receive  ........................ 158\nAssociated Registers, Transmit  ....................... 156\nMaster Transmission  ....................................... 156",
    "U\nReceive Block Diagram  ................................... 157\nReceiver ........................................................... 157\nReception ......................................................... 158\nTransmit Block Diagram  .................................. 155\nTransmitter ....................................................... 155",
    "PIC18CXX2\nBaud Rate Generator (BRG) ..................................., 1 = 151. Associated Registers ......................................., 1 = 151. Baud Rate Error, Calculating, 1 = ........................... 151. Baud Rate Formula ........................................., 1 = 151. Baud Rates, Asynchronous Mode (BRGH = 0) .............................................., 1 = 153. Baud",
    "PIC18CXX2\nRates, Asynchronous Mode (BRGH = 1) .............................................., 1 = 154. Baud Rates, Synchronous Mode ....................., 1 = 152. High Baud Rate Select (BRGH Bit), 1 = ................. 151. Sampling, 1 = ......................................................... 151. RCSTA Register, 1 =",
    "PIC18CXX2\n...................................................... 150. Serial Port Enable (SPEN Bit), 1 = ................................. 149. Synchronous Master Mode, 1 = ...................................... 159. Associated Registers, Reception, 1 = ..................... 161. Associated Registers, Transmit, 1 = ....................... 159. Reception, 1 =",
    "PIC18CXX2\n........................................................ 161. Timing Diagram, Synchronous Receive, 1 = .......... 260. Timing Diagram, Synchronous Transmission, 1 = ........................................... 260. Transmission, 1 = ................................................... 160. Associated Registers, 1 = ............................... 159. Synchronous Slave Mode",
    "PIC18CXX2\n........................................, 1 = 162. Associated Registers, Receive, 1 = ........................ 163. Associated Registers, Transmit, 1 = ....................... 162. Reception, 1 = ........................................................ 163. Transmission, 1 = ................................................... 162. TXSTA Register",
    "PIC18CXX2\n......................................................., 1 = 149. W, 1 = . Wake-up from SLEEP, 1 = .............................................. 179, 185. Timing Diagram, 1 = ....................................................... 186. Using Interrupts, 1 = ....................................................... 185. Watchdog Timer",
    "PIC18CXX2\n(WDT) ..........................................., 1 = 179, 183. Associated Registers, 1 = ............................................... 184. Block Diagram, 1 = ......................................................... 184. Postscaler, 1 = ................................................................ 184. Programming Considerations, 1 =",
    "PIC18CXX2\n.................................. 183. RC Oscillator, 1 = ........................................................... 183. Time-out Period, 1 = ....................................................... 183. Timing Diagram, 1 = ....................................................... 248. Waveform for General Call Address Sequence",
    "PIC18CXX2\n..............., 1 = 133. WCOL .............................................................. 137,, 1 = 139, 142. WCOL Status Flag, 1 = ........................................................... 137. WDT ................................................................................, 1 = 183. X, 1",
    "PIC18CXX2\n= . XORLW, 1 = ........................................................................... 227. XORWF, 1 = ........................................................................... 228\nNOTES:",
    "THE MICROCHIP WEB SITE\nMicrochip provides online support via our WWW site at www.microchip.com. This web site is used as a means to make  files and  information  easily available to customers. Accessible by using your favorite Internet browser, the web site contains the following information:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQ), technical support requests, online discussion groups, Microchip consultant program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "CUSTOMER CHANGE NOTIFICATION SERVICE\nMicrochip's  customer  notification  service  helps  keep customers current on Microchip products. Subscribers will receive  e-mail  notification  whenever  there  are changes,  updates,  revisions  or  errata  related  to  a specified product family or development tool of interest.\nTo register, access the Microchip web site at www.microchip.com. Under 'Support', click on 'Customer Change Notification' and follow the registration instructions.",
    "CUSTOMER SUPPORT\nUsers  of  Microchip  products  can  receive  assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Field Application Engineer (FAE)\n\u00b7 Technical Support\nCustomers should contact their distributor, representative  or  field  application  engineer  (FAE)  for support. Local sales offices are also available to help customers.  A  listing  of  sales  offices  and  locations  is included in the back of this document.\nTechnical support is available through the web site at: http://microchip.com/support",
    "READER RESPONSE\nIt  is  our  intention  to  provide  you  with  the  best  documentation  possible to ensure  successful  use of your  Microchip product.  If  you  wish  to  provide  your  comments  on  organization,  clarity,  subject  matter,  and  ways  in  which  our documentation  can  better  serve  you,  please  FAX  your  comments  to  the  Technical  Publications  Manager  at (480) 792-4150.\nPlease list the following information, and use this outline to provide us with your comments about this document.\nTO: Technical Publications Manager\nRE: Reader Response\nTotal Pages Sent ________\nFrom: Name\nCompany\nAddress\nCity / State / ZIP / Country\nTelephone: (_______) _________ - _________\nApplication (optional):\nWould you like a reply?       Y         N\nDevice:\nLiterature Number:  DS39026D\nQuestions:\nFAX: (______) _________ - _________\n1. What are the best features of this document?\n2. How does this document meet your hardware and software development needs?\n3. Do you find the organization of this document easy to follow? If not, why?",
    "READER RESPONSE\n4. What additions to the document do you think would enhance the structure and subject?\n5. What deletions from the document could be made without affecting the overall usefulness?\n6. Is there any incorrect or misleading information (what and where)?\n7. How would you improve this document?",
    "PIC18CXX2 PRODUCT IDENTIFICATION SYSTEM\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.\nDevice,",
    "PIC18CXX2 PRODUCT IDENTIFICATION SYSTEM\n= PIC18CXX2 (1) , PIC18CXX2T (2) ; VDD range 4.2V to 5.5V PIC18LCXX2 (1) , PIC18LCXX2T (2) ; VDD range 2.5V to 5.5V. Device, \uf02d X Temperature Range = PIC18CXX2 (1) , PIC18CXX2T (2) ; VDD range 4.2V to 5.5V PIC18LCXX2 (1) , PIC18LCXX2T (2) ; VDD range 2.5V to 5.5V. Device, /XX Package = PIC18CXX2 (1) , PIC18CXX2T (2) ; VDD range 4.2V to 5.5V PIC18LCXX2 (1) , PIC18LCXX2T (2) ; VDD range 2.5V to 5.5V. Device, XXX Pattern = PIC18CXX2 (1) , PIC18CXX2T (2) ; VDD range 4.2V to 5.5V PIC18LCXX2 (1) ,",
    "PIC18CXX2 PRODUCT IDENTIFICATION SYSTEM\nPIC18LCXX2T (2) ; VDD range 2.5V to 5.5V. Temperature Range,\n= I E. Temperature Range, \uf02d X Temperature Range = = =. Temperature Range, /XX Package = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range, XXX Pattern = . Package,  = JW PT SO SP P. Package, \uf02d X Temperature Range = = Windowed CERDIP (3) = TQFP (Thin Quad Flatpack). Package, /XX Package = = Windowed CERDIP (3) = TQFP (Thin Quad Flatpack). Package, XXX Pattern = = Windowed CERDIP (3) = TQFP (Thin Quad Flatpack). Pattern,  = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, \uf02d X Temperature Range = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, /XX Package = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, XXX Pattern = QTP, SQTP, Code or Special Requirements (blank otherwise)",
    "Data Sheets\nProducts supported by a preliminary Data Sheet may have an errata sheet describing minor operational differences and recommended workarounds. To determine if an errata sheet exists for a particular device, please contact one of the following:\n1. Your local Microchip sales office\n2. The Microchip Worldwide Site (www.microchip.com)",
    "Examples:\na) PIC18LC452 - I/P 301 = Industrial temp., PDIP package, 4 MHz, Extended VDD limits, QTP pattern #301.\nb) PIC18LC242 - I/SO = Industrial temp., SOIC package, Extended VDD limits.\nc) PIC18C442 - E/P = Extended temp., PDIP package, 40MHz, normal VDD limits.\nNote 1: C = Standard Voltage range LC = Wide Voltage Range\n2: T = in tape and reel - SOIC, PLCC, and TQFP packages only.\n3: JW Devices are UV erasable and can be programmed to any device configuration. JW Devices meet the electrical requirement of each  oscillator type (including LC devices).",
    "Note the following details of the code protection feature on Microchip devices:\n\u00b7 Microchip products meet the specification contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is one of the most secure families of its kind on the market today, when used in the intended manner and under normal conditions.\n\u00b7 There are dishonest and possibly illegal methods used to breach the code protection feature. All of these methods, to our knowledge, require using the Microchip products in a manner outside the operating specifications contained in Microchip's Data Sheets. Most likely, the person doing so is engaged in theft of intellectual property.\n\u00b7 Microchip is willing to work with the customer who is concerned about the integrity of their code.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of their code. Code protection does not mean that we are guaranteeing the product as 'unbreakable.'",
    "Note the following details of the code protection feature on Microchip devices:\nCode protection is constantly evolving. We at Microchip are committed to continuously improving the code protection features of our products. Attempts to break Microchip's code protection feature may be a violation of the Digital Millennium Copyright Act. If such acts allow unauthorized access to your software or other copyrighted work, you may have a right to sue for relief under that Act.",
    "Note the following details of the code protection feature on Microchip devices:\nInformation  contained  in  this  publication  regarding  device applications and the like is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure  that  your  application  meets  with  your  specifications. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES  OF  ANY  KIND  WHETHER  EXPRESS  OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION, INCLUDING  BUT  NOT  LIMITED  TO  ITS CONDITION, QUALITY, PERFORMANCE, MERCHANTABILITY OR FITNESS  FOR  PURPOSE . Microchip  disclaims  all  liability arising  from  this  information  and  its  use.  Use  of  Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold  harmless  Microchip  from  any  and  all  damages,  claims, suits,  or  expenses  resulting  from  such  use.  No  licenses  are conveyed, implicitly or otherwise, under any Microchip intellectual property rights.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, dsPIC, FlashFlex, KEELOQ, KEELOQ logo, MPLAB, PIC, PICmicro, PICSTART, PIC 32  logo, rfPIC, SST, SST Logo, SuperFlash and UNI/O are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nFilterLab, Hampshire, HI-TECH C, Linear Active Thermistor, MTP, SEEVAL and The Embedded Control Solutions Company are registered trademarks of Microchip Technology Incorporated in the U.S.A.\nSilicon Storage Technology is a registered trademark of Microchip Technology Inc. in other countries.",
    "Trademarks\nAnalog-for-the-Digital Age, Application Maestro, BodyCom, chipKIT, chipKIT logo, CodeGuard, dsPICDEM, dsPICDEM.net, dsPICworks, dsSPEAK, ECAN, ECONOMONITOR, FanSense, HI-TIDE, In-Circuit Serial Programming, ICSP, Mindi, MiWi, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, mTouch, Omniscient Code Generation, PICC, PICC-18, PICDEM, PICDEM.net, PICkit, PICtail, REAL ICE, rfLAB, Select Mode, SQI, Serial Quad I/O, Total Endurance, TSHARC, UniWinDriver, WiperLock, ZENA and Z-Scale are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nGestIC and ULPP are registered trademarks of Microchip Technology Germany II GmbH & Co. & KG, a subsidiary of Microchip Technology Inc., in other countries.",
    "Trademarks\nAll other trademarks mentioned herein are property of their respective companies.\n\u00a9 1999-2013, Microchip Technology Incorporated, Printed in the U.S.A., All Rights Reserved.\nPrinted on recycled paper.\nISBN: 9781620769676\nMicrochip received ISO/TS-16949:2009 certification for its worldwide headquarters, design and wafer fabrication facilities in Chandler and Tempe, Arizona; Gresham, Oregon and design centers in California and India. The Company's quality system processes and procedures are for its PIC \u00ae MCUs and dsPIC \u00ae  DSCs, KEELOQ \u00ae  code hopping devices, Serial EEPROMs, microperipherals, nonvolatile memory and analog products. In addition, Microchip's quality system for the design and manufacture of development systems is ISO 9001:2000 certified.\nQUALITY MANAGEMENT  SYSTEM CERTIFIED BY DNV == ISO/TS 16949 ==",
    "AMERICAS\nCorporate Office 2355 West Chandler Blvd. Chandler, AZ 85224-6199 Tel: 480-792-7200 Fax: 480-792-7277 Technical Support:\nhttp://www.microchip.com/ support\nWeb Address:\nwww.microchip.com\nAtlanta Duluth, GA Tel: 678-957-9614 Fax: 678-957-1455",
    "Boston\nWestborough, MA Tel: 774-760-0087 Fax: 774-760-0088",
    "Chicago\nItasca, IL Tel: 630-285-0071 Fax: 630-285-0075\nCleveland Independence, OH Tel: 216-447-0464 Fax: 216-447-0643\nDallas Addison, TX Tel: 972-818-7423 Fax: 972-818-2924\nDetroit Farmington Hills, MI Tel: 248-538-2250 Fax: 248-538-2260\nIndianapolis Noblesville, IN Tel: 317-773-8323 Fax: 317-773-5453",
    "Los Angeles\nMission Viejo, CA Tel: 949-462-9523 Fax: 949-462-9608\nSanta Clara Santa Clara, CA Tel: 408-961-6444 Fax: 408-961-6445\nToronto Mississauga, Ontario, Canada Tel: 905-673-0699 Fax: 905-673-6509",
    "ASIA/PACIFIC\nAsia Pacific Office Suites 3707-14, 37th Floor Tower 6, The Gateway Harbour City, Kowloon Hong Kong Tel: 852-2401-1200 Fax: 852-2401-3431\nAustralia - Sydney Tel: 61-2-9868-6733 Fax: 61-2-9868-6755\nChina - Beijing Tel: 86-10-8569-7000 Fax: 86-10-8528-2104\nChina - Chengdu Tel: 86-28-8665-5511 Fax: 86-28-8665-7889\nChina - Chongqing Tel: 86-23-8980-9588 Fax: 86-23-8980-9500\nChina - Hangzhou Tel: 86-571-2819-3187 Fax: 86-571-2819-3189\nChina - Hong Kong SAR Tel: 852-2943-5100 Fax: 852-2401-3431\nChina - Nanjing Tel: 86-25-8473-2460 Fax: 86-25-8473-2470",
    "ASIA/PACIFIC\nChina - Qingdao Tel: 86-532-8502-7355 Fax: 86-532-8502-7205\nChina - Shanghai Tel: 86-21-5407-5533 Fax: 86-21-5407-5066\nChina - Shenyang Tel: 86-24-2334-2829 Fax: 86-24-2334-2393\nChina - Shenzhen Tel: 86-755-8864-2200 Fax: 86-755-8203-1760\nChina - Wuhan Tel: 86-27-5980-5300 Fax: 86-27-5980-5118",
    "China - Xian\nTel: 86-29-8833-7252 Fax: 86-29-8833-7256\nChina - Xiamen Tel: 86-592-2388138 Fax: 86-592-2388130\nChina - Zhuhai\nTel: 86-756-3210040 Fax: 86-756-3210049\nIndia - Bangalore Tel: 91-80-3090-4444 Fax: 91-80-3090-4123\nIndia - New Delhi Tel: 91-11-4160-8631 Fax: 91-11-4160-8632\nIndia - Pune Tel: 91-20-2566-1512 Fax: 91-20-2566-1513\nJapan - Osaka Tel: 81-6-6152-7160 Fax: 81-6-6152-9310\nJapan - Tokyo\nTel: 81-3-6880- 3770\nFax: 81-3-6880-3771\nKorea - Daegu Tel: 82-53-744-4301 Fax: 82-53-744-4302",
    "China - Xian\nKorea - Seoul Tel: 82-2-554-7200 Fax: 82-2-558-5932 or 82-2-558-5934\nMalaysia - Kuala Lumpur Tel: 60-3-6201-9857 Fax: 60-3-6201-9859\nMalaysia - Penang Tel: 60-4-227-8870 Fax: 60-4-227-4068\nPhilippines - Manila Tel: 63-2-634-9065 Fax: 63-2-634-9069",
    "Singapore\nTel: 65-6334-8870 Fax: 65-6334-8850\nTaiwan - Hsin Chu Tel: 886-3-5778-366 Fax: 886-3-5770-955\nTaiwan - Kaohsiung Tel: 886-7-213-7828 Fax: 886-7-330-9305\nTaiwan - Taipei Tel: 886-2-2508-8600 Fax: 886-2-2508-0102",
    "Thailand - Bangkok\nTel: 66-2-694-1351 Fax: 66-2-694-1350",
    "EUROPE\nAustria - Wels Tel: 43-7242-2244-39 Fax: 43-7242-2244-393 Denmark - Copenhagen Tel: 45-4450-2828 Fax: 45-4485-2829\nFrance - Paris Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79\nGermany - Munich Tel: 49-89-627-144-0 Fax: 49-89-627-144-44",
    "Italy - Milan\nTel: 39-0331-742611 Fax: 39-0331-466781",
    "Netherlands - Drunen\nTel: 31-416-690399 Fax: 31-416-690340\nSpain - Madrid Tel: 34-91-708-08-90 Fax: 34-91-708-08-91\nUK - Wokingham Tel: 44-118-921-5869 Fax: 44-118-921-5820",
    "Mouser Electronics\nAuthorized Distributor\nClick to View Pricing, Inventory, Delivery & Lifecycle Information:\nMicrochip:\nPIC18C242-I/SO\u00a0 PIC18C242-I/SP\u00a0 PIC18LC242-I/SO\u00a0 PIC18LC252-I/SO\u00a0 PIC18C452-I/P\u00a0 PIC18C452-E/P PIC18C252-I/SO\u00a0 PIC18C252-I/SP\u00a0 PIC18C442-I/P"
]
[
    "High Performance RISC CPU:\n- \u00b7 Linear program memory addressing to 64 Kbytes",
    "External Memory Interface (PIC18F8525/8621 Devices Only):\n\u00b7 Linear data memory addressing to 4 Kbytes\n\u00b7 1 Kbyte of data EEPROM\n\u00b7 Up to 10 MIPs operation:\n-DC - 40 MHz osc./clock input\n-4 MHz - 10 MHz osc./clock input with PLL active\n\u00b7 16-bit wide instructions, 8-bit wide data path\n\u00b7 Priority levels for interrupts\n\u00b7 31-level, software accessible hardware stack\n\u00b7 8 x 8 Single-cycle Hardware Multiplier",
    "Peripheral Features:\n\u00b7 High current sink/source 25 mA/25 mA\n\u00b7 Four external interrupt pins\n\u00b7 Timer0 module: 8-bit/16-bit timer/counter\n\u00b7 Timer1 module: 16-bit timer/counter\n\u00b7 Timer2 module: 8-bit timer/counter\n\u00b7 Timer3 module: 16-bit timer/counter\n\u00b7 Timer4 module: 8-bit timer/counter\n\u00b7 Secondary oscillator clock option - Timer1/Timer3\n\u00b7 Two Capture/Compare/PWM (CCP) modules:\n-Capture is 16-bit, max. resolution 6.25 ns (TCY/16)\n-Compare is 16-bit, max. resolution 100 ns (TCY)\n-PWM output: 1 to 10-bit PWM resolution\n\u00b7 Three Enhanced Capture/Compare/PWM (ECCP) modules:\n-Same Capture/Compare features as CCP\n-One, two or four PWM outputs\n-Selectable polarity\n-Programmable dead time\n-Auto-Shutdown on external event\n-Auto-Restart\n\u00b7 Master Synchronous Serial Port (MSSP) module with two modes of operation:\n-2/3/4-wire SPI (supports all 4 SPI modes)",
    "Peripheral Features:\n-I 2 C\u2122 Master and Slave mode\n\u00b7 Two Enhanced USART modules:\n-Supports RS-485, RS-232 and LIN 1.2\n-Auto-Wake-up on Start bit\n-Auto-Baud Rate Detect\n\u00b7 Address capability of up to 2 Mbytes\n\u00b7 16-bit interface",
    "Analog Features:\n\u00b7 10-bit, up to 16-channel Analog-to-Digital Converter (A/D):\n-Auto-Acquisition\n-Conversion available during Sleep\n\u00b7 Programmable 16-level Low-Voltage Detection (LVD) module:\n-Supports interrupt on Low-Voltage Detection\n\u00b7 Programmable Brown-out Reset (BOR)\n\u00b7 Dual analog comparators:\n-Programmable input/output configuration",
    "Special Microcontroller Features:\n\u00b7 100,000 erase/write cycle Enhanced Flash program memory typical\n\u00b7 1,000,000 erase/write cycle Data EEPROM memory typical\n\u00b7 1 second programming time\n\u00b7 Flash/Data EEPROM Retention: > 100 years\n\u00b7 Self-reprogrammable under software control\n\u00b7 Power-on Reset (POR), Power-up Timer (PWRT) and Oscillator Start-up Timer (OST)\n\u00b7 Watchdog Timer (WDT) with its own On-Chip RC Oscillator for reliable operation\n\u00b7 Programmable code protection\n\u00b7 Power-saving Sleep mode\n\u00b7 Selectable oscillator options including:\n-4x Phase Lock Loop (PLL) - of primary oscillator\n-Secondary Oscillator (32 kHz) clock input\n\u00b7 In-Circuit Serial Programming\u2122 (ICSP\u2122) via two pins\n\u00b7 MPLAB \u00ae  In-Circuit Debug (ICD 2) via two pins",
    "CMOS Technology:\n\u00b7 Low power, high-speed Flash technology\n\u00b7 Fully static design\n\u00b7 Wide operating voltage range (2.0V to 5.5V)\n\u00b7 Industrial and Extended temperature ranges\n\u00b7 Parallel Slave Port (PSP) module",
    "CMOS Technology:\nPIC18F6525, Program Memory.Bytes = 48K. PIC18F6525, Program Memory.#Single-Word Instructions = 24576. PIC18F6525, Data Memory.SRAM (bytes) = 3840. PIC18F6525, Data Memory.EEPROM (bytes) = 1024. PIC18F6525, I/O.I/O = 53. PIC18F6525, 10-bit A/D (ch).10-bit A/D (ch) = 12. PIC18F6525, CCP/ ECCP.CCP/ ECCP = 2/3. PIC18F6525, PWM.PWM = 14. PIC18F6525, MSSP/SPI\u2122/ Master I 2 C\u2122.MSSP/SPI\u2122/ Master I 2 C\u2122 = Y. PIC18F6525, EUSART.EUSART = 2. PIC18F6525, Timers.8-bit/16-bit = 2/3. PIC18F6525, EMI = N. PIC18F6621, Program Memory.Bytes = 64K.",
    "CMOS Technology:\nPIC18F6621, Program Memory.#Single-Word Instructions = 32768. PIC18F6621, Data Memory.SRAM (bytes) = 3840. PIC18F6621, Data Memory.EEPROM (bytes) = 1024. PIC18F6621, I/O.I/O = 53. PIC18F6621, 10-bit A/D (ch).10-bit A/D (ch) = 12. PIC18F6621, CCP/ ECCP.CCP/ ECCP = 2/3. PIC18F6621, PWM.PWM = 14. PIC18F6621, MSSP/SPI\u2122/ Master I 2 C\u2122.MSSP/SPI\u2122/ Master I 2 C\u2122 = Y. PIC18F6621, EUSART.EUSART = 2. PIC18F6621, Timers.8-bit/16-bit = 2/3. PIC18F6621, EMI = N. PIC18F8525, Program Memory.Bytes = 48K. PIC18F8525, Program Memory.#Single-Word Instructions = 24576.",
    "CMOS Technology:\nPIC18F8525, Data Memory.SRAM (bytes) = 3840. PIC18F8525, Data Memory.EEPROM (bytes) = 1024. PIC18F8525, I/O.I/O = 70. PIC18F8525, 10-bit A/D (ch).10-bit A/D (ch) = 16. PIC18F8525, CCP/ ECCP.CCP/ ECCP = 2/3. PIC18F8525, PWM.PWM = 14. PIC18F8525, MSSP/SPI\u2122/ Master I 2 C\u2122.MSSP/SPI\u2122/ Master I 2 C\u2122 = Y. PIC18F8525, EUSART.EUSART = 2. PIC18F8525, Timers.8-bit/16-bit = 2/3. PIC18F8525, EMI = Y. PIC18F8621, Program Memory.Bytes = 64K. PIC18F8621, Program Memory.#Single-Word Instructions = 32768. PIC18F8621, Data Memory.SRAM (bytes) = 3840.",
    "CMOS Technology:\nPIC18F8621, Data Memory.EEPROM (bytes) = 1024. PIC18F8621, I/O.I/O = 70. PIC18F8621, 10-bit A/D (ch).10-bit A/D (ch) = 16. PIC18F8621, CCP/ ECCP.CCP/ ECCP = 2/3. PIC18F8621, PWM.PWM = 14. PIC18F8621, MSSP/SPI\u2122/ Master I 2 C\u2122.MSSP/SPI\u2122/ Master I 2 C\u2122 = Y. PIC18F8621, EUSART.EUSART = 2. PIC18F8621, Timers.8-bit/16-bit = 2/3. PIC18F8621, EMI = Y",
    "Pin Diagrams (Cont.'d)\nNote\n1: ECCP2/P2A are multiplexed with RC1 when CCP2MX is set; with RE7 when CCP2MX is cleared and the device is configured in Microcontroller mode; or with RB3 when CCP2MX is cleared in all other program memory modes.\n2: P1B/P1C/P3B/P3C are multiplexed with RE6:RE3 when ECCPMX is set and with RH7:RH4 when ECCPMX is not set.\n3: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.",
    "Table of Contents\n1.0, 1 = Device Overview ........................................................................................................................................................................... 1.0, 2 = 7. 2.0, 1 = Oscillator Configurations",
    "Table of Contents\n............................................................................................................................................................. 2.0, 2 = 21. 3.0, 1 =",
    "Table of Contents\nReset........................................................................................................................................................................................... 3.0, 2 = 29. 4.0, 1 = Memory",
    "Table of Contents\nOrganization.................................................................................................................................................................. 4.0, 2 = 39. 5.0, 1 = Flash Program",
    "Table of Contents\nMemory............................................................................................................................................................... 5.0, 2 = 61. 6.0, 1 = External Memory Interface",
    "Table of Contents\n.......................................................................................................................................................... 6.0, 2 = 71. 7.0, 1 = Data EEPROM Memory",
    "Table of Contents\n.............................................................................................................................................................. 7.0, 2 = 79. 8.0, 1 = 8 x 8 Hardware",
    "Table of Contents\nMultiplier............................................................................................................................................................. 8.0, 2 = 85. 9.0, 1 = Interrupts",
    "Table of Contents\n..................................................................................................................................................................................... 9.0, 2 = 87. 10.0, 1 = I/O Ports",
    "Table of Contents\n.................................................................................................................................................................................... 10.0, 2 = 103. 11.0, 1 = Timer0 Module",
    "Table of Contents\n.......................................................................................................................................................................... 11.0, 2 = 131. 12.0, 1 = Timer1 Module",
    "Table of Contents\n.......................................................................................................................................................................... 12.0, 2 = 135. 13.0, 1 = Timer2 Module",
    "Table of Contents\n.......................................................................................................................................................................... 13.0, 2 = 141. 14.0, 1 = Timer3 Module",
    "Table of Contents\n.......................................................................................................................................................................... 14.0, 2 = 143. 15.0, 1 = Timer4 Module",
    "Table of Contents\n.......................................................................................................................................................................... 15.0, 2 = 147. 16.0, 1 = Capture/Compare/PWM (CCP) Modules",
    "Table of Contents\n.................................................................................................................................. 16.0, 2 = 149. 17.0, 1 = Enhanced Capture/Compare/PWM (ECCP)",
    "Table of Contents\nModule................................................................................................................. 17.0, 2 = 157. 18.0, 1 = Master Synchronous Serial Port (MSSP) Module",
    "Table of Contents\n..................................................................................................................... 18.0, 2 = 173. 19.0, 1 = Enhanced Universal Synchronous Asynchronous Receiver Transmitter (EUSART)................................................................ 19.0, 2 = 213. 20.0, 1 = 10-Bit Analog-to-Digital Converter (A/D) Module",
    "Table of Contents\n...................................................................................................................... 20.0, 2 = 233. 21.0, 1 = Comparator",
    "Table of Contents\nModule................................................................................................................................................................... 21.0, 2 = 243. 22.0, 1 = Comparator Voltage Reference",
    "Table of Contents\nModule.................................................................................................................................... 22.0, 2 = 249. 23.0, 1 = Low-Voltage Detect",
    "Table of Contents\n................................................................................................................................................................... 23.0, 2 = 253. 24.0, 1 = Special Features of the",
    "Table of Contents\nCPU..................................................................................................................................................... 24.0, 2 = 259. 25.0, 1 = Instruction Set",
    "Table of Contents\nSummary........................................................................................................................................................... 25.0, 2 = 275. 26.0, 1 = Development",
    "Table of Contents\nSupport................................................................................................................................................................ 26.0, 2 = 317. 27.0, 1 = Electrical Characteristics",
    "Table of Contents\n........................................................................................................................................................... 27.0, 2 = 323. 28.0, 1 = DC and AC Characteristics Graphs And Tables",
    "Table of Contents\n....................................................................................................................... 28.0, 2 = 357. 29.0, 1 = Packaging",
    "Table of Contents\nInformation............................................................................................................................................................... 29.0, 2 = 373. Appendix A: Revision",
    "Table of Contents\nHistory............................................................................................................................................................., 1 = Appendix A: Revision",
    "Table of Contents\nHistory.............................................................................................................................................................. Appendix A: Revision",
    "Table of Contents\nHistory............................................................................................................................................................., 2 = 377. Appendix B: Device",
    "Table of Contents\nDifferences........................................................................................................................................................., 1 = Appendix B: Device",
    "Table of Contents\nDifferences.......................................................................................................................................................... Appendix B: Device",
    "Table of Contents\nDifferences........................................................................................................................................................., 2 = 377. Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 1 = Appendix C: Conversion Considerations",
    "Table of Contents\n............................................................................................................................................ Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 2 = 378. Appendix D: Migration From Mid-Range to Enhanced",
    "Table of Contents\nDevices........................................................................................................., 1 = Appendix D: Migration From Mid-Range to Enhanced Devices.......................................................................................................... Appendix D: Migration From Mid-Range to Enhanced",
    "Table of Contents\nDevices........................................................................................................., 2 = 378. Appendix E: Migration From High-End to Enhanced Devices............................................................................................................, 1 = Appendix E: Migration From High-End to Enhanced",
    "Table of Contents\nDevices............................................................................................................. Appendix E: Migration From High-End to Enhanced Devices............................................................................................................, 2 = 379. Index",
    "Table of Contents\n.................................................................................................................................................................................................., 1 = Index",
    "Table of Contents\n................................................................................................................................................................................................... Index",
    "Table of Contents\n.................................................................................................................................................................................................., 2 = 381. On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................., 1 = On-Line",
    "Table of Contents\nSupport.................................................................................................................................................................................. On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................., 2 = 391. Systems Information and Upgrade Hot Line",
    "Table of Contents\n......................................................................................................................................, 1 = Systems Information and Upgrade Hot Line",
    "Table of Contents\n....................................................................................................................................... Systems Information and Upgrade Hot Line",
    "Table of Contents\n......................................................................................................................................, 2 = 391. Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 1 = Reader",
    "Table of Contents\nResponse............................................................................................................................................................................... Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 2 = 392. PIC18F6525/6621/8525/8621 Product Identification System",
    "Table of Contents\n............................................................................................................, 1 = PIC18F6525/6621/8525/8621 Product Identification System ............................................................................................................. PIC18F6525/6621/8525/8621 Product Identification",
    "Table of Contents\nSystem ............................................................................................................, 2 = 393",
    "TO OUR VALUED CUSTOMERS\nIt is our intention to provide our valued customers with the best documentation possible to ensure successful use of your Microchip products. To this end, we will continue to improve our publications to better suit your needs. Our publications will be refined and enhanced as new volumes and updates are introduced.\nIf you have any questions or comments regarding this publication, please contact the Marketing Communications Department via E-mail at docerrors@mail.microchip.com or fax the Reader Response Form in the back of this data sheet to (480) 792-4150. We welcome your feedback.",
    "Most Current Data Sheet\nTo obtain the most up-to-date version of this data sheet, please register at our Worldwide Web site at:\nhttp://www.microchip.com\nYou can determine the version of a data sheet by examining its literature number found on the bottom outside corner of any page. The last character of the literature number is the version number, (e.g., DS30000A is version A of document DS30000).",
    "Errata\nAn errata sheet, describing minor operational differences from the data sheet and recommended workarounds, may exist for current devices. As device/documentation issues become known to us, we will publish an errata sheet. The errata will specify the revision of silicon and revision of document to which it applies.\nTo determine if an errata sheet exists for a particular device, please check with one of the following:\n\u00b7 Microchip's Worldwide Web site; http://www.microchip.com\n\u00b7 Your local Microchip sales office (see last page)\n\u00b7 The Microchip Corporate Literature Center; U.S. FAX: (480) 792-7277\nWhen contacting a sales office or the literature center, please specify which device, revision of silicon and data sheet (include literature number) you are using.",
    "Customer Notification System\nRegister on our Web site at www.microchip.com/cn to receive the most current information on all of our products.",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "1.0 DEVICE OVERVIEW\nThis document contains device specific information for the following devices:\nWith the addition of new operating modes, the external memory interface offers many new options, including:\n\u00b7 PIC18F6525\n\u00b7 PIC18F6621\n\u00b7 PIC18F8525\n\u00b7 PIC18F8621\nThis family offers the advantages of all PIC18 microcontrollers  -  namely,  high  computational performance at an economical price - with the addition of high-endurance Enhanced Flash program memory. The PIC18F6525/6621/8525/8621 family also provides an enhanced range of program memory options and versatile analog features that make it ideal for complex, high performance applications.",
    "1.1.1 EXPANDED MEMORY\nThe PIC18F6525/6621/8525/8621 family provides ample room for application code and includes members with 48 Kbytes or 64 Kbytes of code space.\nOther memory features are:\n\u00b7 Data RAM and Data EEPROM: The  PIC18F6525/ 6621/8525/8621 family also provides plenty of room for application data. The devices have 3840 bytes of data RAM, as well as 1024 bytes of data EEPROM for long term retention of nonvolatile data.\n\u00b7 Memory Endurance: The Enhanced Flash cells for both program memory and data EEPROM are rated to  last  for  many  thousands  of  erase/write  cycles  up to 100,000 for program memory and 1,000,000 for EEPROM.  Data  retention  without  refresh  is conservatively estimated to be greater than 40 years.",
    "1.1.2 EXTERNAL MEMORY INTERFACE\nIn the unlikely event that 64 Kbytes of program memory is inadequate for an application, the PIC18F8525/8621 members  of  the  family  also  implement  an  external memory interface. This allows the controller's internal program counter to address a memory space of up to 2 MBytes, permitting  a  level  of  data  access  that  few 8-bit devices can claim.\n\u00b7 Operating the microcontroller entirely from external memory\n\u00b7 Using combinations of on-chip and external memory, up to the 2-Mbyte limit\n\u00b7 Using external Flash memory for reprogrammable application code or large data tables\n\u00b7 Using external RAM devices for storing large amounts of variable data",
    "1.1.3 EASY MIGRATION\nRegardless of the memory size, all devices share the same  rich  set  of  peripherals,  allowing  for  a  smooth migration path as applications grow and evolve.\nThe  consistent  pinout  scheme  used  throughout  the entire  family  also aids in migrating  to the  next larger device. This is true when moving between the 64-pin members,  between  the  80-pin  members,  or  even Jumping From 64-pin To 80-pin Devices.",
    "1.1.4 OTHER SPECIAL FEATURES\n\u00b7 Communications: The PIC18F6525/6621/8525/ 8621 family incorporates a range of serial communication peripherals, including 2 independent Enhanced USARTs and a Master SSP module capable of both SPI and I 2 C (Master and Slave) modes of operation. Also, for PIC18F6525/6621/8525/8621 devices, one of the general purpose I/O ports can be reconfigured as an 8-bit Parallel Slave Port for direct processor to processor communications.\n\u00b7 CCP Modules: All devices in the family incorporate two  Capture/Compare/PWM  (CCP)  modules  and three Enhanced CCP (ECCP) modules to maximize flexibility in control applications. Up to four different time bases may be used to perform several different operations at once. Each of the three ECCPs offer up  to  four  PWM  outputs,  allowing  for  a  total  of 12 PWMs.  The  ECCPs  also  offer  many  beneficial features, including polarity selection, Programmable Dead Time, Auto-Shutdown and Restart and Half-Bridge and Full-Bridge Output modes.",
    "1.1.4 OTHER SPECIAL FEATURES\n\u00b7 Analog Features: All  devices in the family feature 10-bit A/D converters with up to 16 input channels, as well as the ability to perform conversions during Sleep mode and auto-acquisition conversions. Also included are dual analog comparators with programmable  input  and  output  configuration,  a programmable  Low-Voltage  Detect  module  and  a Programmable Brown-out Reset module.\n\u00b7 Self-programmability: These devices can write to their  own  program  memory  spaces  under  internal software  control.  By  using  a  bootloader  routine located  in  the  protected  boot  block  at  the  top  of program memory, it becomes possible to create an application that can update itself in the field.",
    "1.2 Details on Individual Family Members\n- 3. I/O ports (7 on PIC18F6525/6621 devices; 9 on PIC18F8525/8621 devices).\nThe  PIC18F6525/6621/8525/8621  devices  are  available in 64-pin (PIC18F6525/6621) and 80-pin (PIC18F8525/8621) packages. They are differentiated from each other in four ways:\n1. Flash program memory (48 Kbytes for PIC18F6525/8525 devices; 64 Kbytes for PIC18F6621/8621 devices).\n4. External  program  memory  interface  (present only on PIC18F8525/8621 devices)\nAll other features for devices in the PIC18F6525/6621/ 8525/8621 family are identical. These are summarized in Table 1-1.\n- 2. A/D channels (12 for PIC18F6525/6621 devices; 16 for PIC18F8525/8621 devices).",
    "1.2 Details on Individual Family Members\nBlock diagrams of the PIC18F6525/6621 and PIC18F8525/8621 devices are provided in Figure 1-1 and  Figure 1-2,  respectively.  The  pinouts  for  these device families are listed in Table 1-2.",
    "TABLE 1-1: PIC18F6525/6621/8525/8621 DEVICE FEATURES\nOperating Frequency, PIC18F6525 = DC - 40 MHz. Operating Frequency, PIC18F6621 = DC - 40 MHz. Operating Frequency, PIC18F8525 = DC - 40 MHz. Operating Frequency, PIC18F8621 = DC - 40 MHz. Program Memory (Bytes), PIC18F6525 = 48K. Program Memory (Bytes), PIC18F6621 = 64K. Program Memory (Bytes), PIC18F8525 = 48K. Program Memory (Bytes), PIC18F8621 = 64K. Program Memory (Instructions), PIC18F6525 = 24576. Program Memory (Instructions), PIC18F6621 = 32768. Program Memory (Instructions), PIC18F8525 = 24576. Program Memory (Instructions), PIC18F8621 = 32768. Data Memory (Bytes), PIC18F6525 = 3840. Data Memory (Bytes), PIC18F6621 = 3840. Data Memory (Bytes), PIC18F8525 = 3840. Data Memory (Bytes),",
    "TABLE 1-1: PIC18F6525/6621/8525/8621 DEVICE FEATURES\nPIC18F8621 = 3840. Data EEPROM Memory (Bytes), PIC18F6525 = 1024. Data EEPROM Memory (Bytes), PIC18F6621 = 1024. Data EEPROM Memory (Bytes), PIC18F8525 = 1024. Data EEPROM Memory (Bytes), PIC18F8621 = 1024. External Memory Interface, PIC18F6525 = No. External Memory Interface, PIC18F6621 = No. External Memory Interface, PIC18F8525 = Yes. External Memory Interface, PIC18F8621 = Yes. Interrupt Sources, PIC18F6525 = 17. Interrupt Sources, PIC18F6621 = 17. Interrupt Sources, PIC18F8525 = 17. Interrupt Sources, PIC18F8621 = 17. I/O Ports, PIC18F6525 = Ports A, B, C, D, E, F, G. I/O Ports, PIC18F6621 = Ports A, B, C, D, E, F, G. I/O Ports, PIC18F8525",
    "TABLE 1-1: PIC18F6525/6621/8525/8621 DEVICE FEATURES\n= Ports A, B, C, D, E, F, G, H, J. I/O Ports, PIC18F8621 = Ports A, B, C, D, E, F, G, H, J. Timers, PIC18F6525 = 5. Timers, PIC18F6621 = 5. Timers, PIC18F8525 = 5. Timers, PIC18F8621 = 5. Capture/Compare/PWM Modules, PIC18F6525 = 2. Capture/Compare/PWM Modules, PIC18F6621 = 2. Capture/Compare/PWM Modules, PIC18F8525 = 2. Capture/Compare/PWM Modules, PIC18F8621 = 2. Enhanced Capture/Compare/ PWM Module, PIC18F6525 = 3. Enhanced Capture/Compare/ PWM Module, PIC18F6621 = 3. Enhanced Capture/Compare/ PWM Module, PIC18F8525 = 3. Enhanced Capture/Compare/ PWM Module, PIC18F8621 = 3. Serial",
    "TABLE 1-1: PIC18F6525/6621/8525/8621 DEVICE FEATURES\nCommunications, PIC18F6525 = MSSP, Addressable EUSART (2). Serial Communications, PIC18F6621 = MSSP, Addressable EUSART (2). Serial Communications, PIC18F8525 = MSSP, Addressable EUSART (2). Serial Communications, PIC18F8621 = MSSP, Addressable EUSART (2). Parallel Communications, PIC18F6525 = PSP. Parallel Communications, PIC18F6621 = PSP. Parallel Communications, PIC18F8525 = PSP. Parallel Communications, PIC18F8621 = PSP. 10-bit Analog-to-Digital Module, PIC18F6525 = 12 input channels. 10-bit Analog-to-Digital Module, PIC18F6621 = 12 input channels. 10-bit Analog-to-Digital Module, PIC18F8525 = 16 input channels. 10-bit Analog-to-Digital Module, PIC18F8621 = 16 input channels. Resets (and Delays), PIC18F6525 = POR, BOR, RESET Instruction, Stack Full,",
    "TABLE 1-1: PIC18F6525/6621/8525/8621 DEVICE FEATURES\nStack Underflow (PWRT, OST). Resets (and Delays), PIC18F6621 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Resets (and Delays), PIC18F8525 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Resets (and Delays), PIC18F8621 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Programmable Low-Voltage Detect, PIC18F6525 = Yes. Programmable Low-Voltage Detect, PIC18F6621 = Yes. Programmable Low-Voltage Detect, PIC18F8525 = Yes. Programmable Low-Voltage Detect, PIC18F8621 = Yes. Programmable Brown-out Reset, PIC18F6525 = Yes. Programmable Brown-out Reset, PIC18F6621 = Yes. Programmable Brown-out Reset, PIC18F8525 = Yes. Programmable Brown-out Reset,",
    "TABLE 1-1: PIC18F6525/6621/8525/8621 DEVICE FEATURES\nPIC18F8621 = Yes. Instruction Set, PIC18F6525 = 77 Instructions. Instruction Set, PIC18F6621 = 77 Instructions. Instruction Set, PIC18F8525 = 77 Instructions. Instruction Set, PIC18F8621 = 77 Instructions. Package, PIC18F6525 = 64-pin TQFP. Package, PIC18F6621 = 64-pin TQFP. Package, PIC18F8525 = 80-pin TQFP. Package, PIC18F8621 = 80-pin TQFP",
    "FIGURE 1-1: PIC18F6525/6621 BLOCK DIAGRAM\nNote\n1: ECCP2/P2A are multiplexed with RC1 when CCP2MX is set, or RE7 when CCP2MX is not set.\n2: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS\nMCLR/VPP/RG5 (9), Pin Number.PIC18F6X2X = 7. MCLR/VPP/RG5 (9), Pin Number.PIC18F8X2X = 9. MCLR/VPP/RG5 (9), Pin Type. = . MCLR/VPP/RG5 (9), Buffer.Type = . MCLR/VPP/RG5 (9), Description = Master Clear (input) or programming voltage (output).. MCLR, Pin Number.PIC18F6X2X = . MCLR, Pin Number.PIC18F8X2X = . MCLR, Pin Type. = I. MCLR, Buffer.Type = ST. MCLR, Description = Master Clear (Reset) input. This pin is an active-low Reset to the device.. VPP, Pin Number.PIC18F6X2X = . VPP, Pin Number.PIC18F8X2X = . VPP, Pin Type. = P. VPP,",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS\nBuffer.Type = -. VPP, Description = Programming voltage input.. RG5, Pin Number.PIC18F6X2X = . RG5, Pin Number.PIC18F8X2X = . RG5, Pin Type. = I. RG5, Buffer.Type = ST. RG5, Description = Digital input.. OSC1/CLKI, Pin Number.PIC18F6X2X = 39. OSC1/CLKI, Pin Number.PIC18F8X2X = 49. OSC1/CLKI, Pin Type. = . OSC1/CLKI, Buffer.Type = . OSC1/CLKI, Description = Oscillator crystal or external clock input.. OSC1, Pin Number.PIC18F6X2X = . OSC1, Pin Number.PIC18F8X2X = . OSC1, Pin Type. = I. OSC1, Buffer.Type = CMOS/ST. OSC1, Description = Oscillator crystal input or external",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS\nclock source input. ST buffer when configured in RC mode; otherwise CMOS.. CLKI, Pin Number.PIC18F6X2X = . CLKI, Pin Number.PIC18F8X2X = . CLKI, Pin Type. = I. CLKI, Buffer.Type = CMOS. CLKI, Description = External clock source input. Always associated with pin function OSC1 (see OSC1/CLKI, OSC2/CLKO pins).. OSC2/CLKO/RA6, Pin Number.PIC18F6X2X = 40. OSC2/CLKO/RA6, Pin Number.PIC18F8X2X = 50. OSC2/CLKO/RA6, Pin Type. = . OSC2/CLKO/RA6, Buffer.Type = . OSC2/CLKO/RA6, Description = Oscillator crystal or clock output.. OSC2, Pin Number.PIC18F6X2X = . OSC2, Pin Number.PIC18F8X2X",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS\n= . OSC2, Pin Type. = O. OSC2, Buffer.Type = -. OSC2, Description = Oscillator crystal output. Connects to crystal or resonator in Crystal oscillator mode.. CLKO, Pin Number.PIC18F6X2X = . CLKO, Pin Number.PIC18F8X2X = . CLKO, Pin Type. = O. CLKO, Buffer.Type = -. CLKO, Description = In RC mode, OSC2 pin outputs CLKO which has 1/4 the frequency of OSC1 and denotes the instruction cycle rate.. RA6, Pin Number.PIC18F6X2X = . RA6, Pin Number.PIC18F8X2X = . RA6, Pin Type. = I/O. RA6, Buffer.Type = TTL. RA6, Description = General purpose I/O pin.\nLegend:\nTTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS\nI = Input\nP = Power\nNote 1: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX (CONFIG3H<0>) is not set (all Program Memory modes except Microcontroller).\n2: Default assignment for ECCP2/P2A when CCP2MX is set (all devices).\n3: External memory interface functions are only available on PIC18F8525/8621 devices.\n4: Default assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is set and for all PIC18F6525/6621 devices.\n5: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX is not set (Microcontroller mode).\n6: PORTH and PORTJ (and their multiplexed functions) are only available on PIC18F8525/8621 devices.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS\n7: Alternate assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is not set.\n8: AVDD must be connected to a positive supply and AVSS must be connected to a ground reference for proper operation of the part in user or ICSP\u2122 modes. See parameter D001 for details.\n9: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.\nCMOS = CMOS compatible input or output\nAnalog = Analog input\nO\n= Output\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRA0/AN0 RA0 AN0, Pin Number.PIC18F6X2X = 24. RA0/AN0 RA0 AN0, Pin Number.PIC18F8X2X = 30. RA0/AN0 RA0 AN0, Pin.Type = I/O I I/O. RA0/AN0 RA0 AN0, Buffer.Type = TTL Analog. RA0/AN0 RA0 AN0, Description = PORTA is a bidirectional I/O port. Digital I/O. Analog input 0.. RA1/AN1 RA1 AN1, Pin Number.PIC18F6X2X = 23. RA1/AN1 RA1 AN1, Pin Number.PIC18F8X2X = 29. RA1/AN1 RA1 AN1, Pin.Type = I. RA1/AN1 RA1 AN1, Buffer.Type = TTL Analog. RA1/AN1 RA1 AN1, Description = Digital I/O. Analog input 1..",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+, Pin Number.PIC18F6X2X = 22. RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+, Pin Number.PIC18F8X2X = 28. RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+, Pin.Type = I/O I I. RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+, Buffer.Type = TTL Analog Analog. RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+, Description = Digital I/O. Analog input 2. A/D reference voltage (low) input.. RA3 AN3 VREF+, Pin Number.PIC18F6X2X = 21. RA3 AN3 VREF+, Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F8X2X = 27. RA3 AN3 VREF+, Pin.Type = I/O I I. RA3 AN3 VREF+, Buffer.Type = TTL Analog Analog. RA3 AN3 VREF+, Description = Digital I/O. Analog input 3.. RA4/T0CKI RA4, Pin Number.PIC18F6X2X = 28. RA4/T0CKI RA4, Pin Number.PIC18F8X2X = 34. RA4/T0CKI RA4, Pin.Type = I/O. RA4/T0CKI RA4, Buffer.Type = ST/OD. RA4/T0CKI RA4, Description = Digital I/O - Open-drain when configured as output.. T0CKI RA5/AN4/LVDIN RA5 AN4 LVDIN RA6, Pin Number.PIC18F6X2X = 27. T0CKI RA5/AN4/LVDIN RA5 AN4 LVDIN RA6,",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin Number.PIC18F8X2X = 33. T0CKI RA5/AN4/LVDIN RA5 AN4 LVDIN RA6, Pin.Type = I I/O I I. T0CKI RA5/AN4/LVDIN RA5 AN4 LVDIN RA6, Buffer.Type = ST TTL Analog Analog. T0CKI RA5/AN4/LVDIN RA5 AN4 LVDIN RA6, Description = Timer0 external clock input. Digital I/O. Analog input 4. Low-Voltage Detect input. See the OSC2/CLKO/RA6 pin.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nAnalog\n= Analog input\nI\n= Input\nO\n= Output\nP = Power\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNote 1: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX (CONFIG3H<0>) is not set (all Program Memory modes except Microcontroller).\n2: Default assignment for ECCP2/P2A when CCP2MX is set (all devices).\n3: External memory interface functions are only available on PIC18F8525/8621 devices.\n4: Default assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is set and for all PIC18F6525/6621 devices.\n5: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX is not set (Microcontroller mode).\n6: PORTH and PORTJ (and their multiplexed functions) are only available on PIC18F8525/8621 devices.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n7: Alternate assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is not set.\n8: AVDD must be connected to a positive supply and AVSS must be connected to a ground reference for proper operation of the part in user or ICSP\u2122 modes. See parameter D001 for details.\n9: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB0/INT0/FLT0, Pin Number.PIC18F6X2X = 48. RB0/INT0/FLT0, Pin Number.PIC18F8X2X = 58. RB0/INT0/FLT0, Pin.Type = . RB0/INT0/FLT0, Buffer.Type = . RB0/INT0/FLT0, Description = . RB0, Pin Number.PIC18F6X2X = . RB0, Pin Number.PIC18F8X2X = . RB0, Pin.Type = I/O. RB0, Buffer.Type = TTL. RB0, Description = Digital I/O.. INT0, Pin Number.PIC18F6X2X = . INT0, Pin Number.PIC18F8X2X = . INT0, Pin.Type = I. INT0, Buffer.Type = ST. INT0, Description = External interrupt 0.. FLT0, Pin Number.PIC18F6X2X = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nFLT0, Pin Number.PIC18F8X2X = . FLT0, Pin.Type = I. FLT0, Buffer.Type = ST. FLT0, Description = PWM Fault input for ECCP1.. RB1/INT1, Pin Number.PIC18F6X2X = 47. RB1/INT1, Pin Number.PIC18F8X2X = 57. RB1/INT1, Pin.Type = . RB1/INT1, Buffer.Type = . RB1/INT1, Description = . RB1, Pin Number.PIC18F6X2X = . RB1, Pin Number.PIC18F8X2X = . RB1, Pin.Type = I/O. RB1, Buffer.Type = TTL. RB1, Description = Digital I/O.. INT1, Pin Number.PIC18F6X2X = . INT1, Pin Number.PIC18F8X2X = . INT1, Pin.Type = I. INT1,",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = ST. INT1, Description = External interrupt 1.. RB2/INT2, Pin Number.PIC18F6X2X = 46. RB2/INT2, Pin Number.PIC18F8X2X = 56. RB2/INT2, Pin.Type = . RB2/INT2, Buffer.Type = . RB2/INT2, Description = . RB2, Pin Number.PIC18F6X2X = . RB2, Pin Number.PIC18F8X2X = . RB2, Pin.Type = I/O. RB2, Buffer.Type = TTL. RB2, Description = Digital I/O.. INT2, Pin Number.PIC18F6X2X = . INT2, Pin Number.PIC18F8X2X = . INT2, Pin.Type = I. INT2, Buffer.Type = ST. INT2, Description = External interrupt 2.. RB3/INT3/ECCP2/P2A, Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F6X2X = 45. RB3/INT3/ECCP2/P2A, Pin Number.PIC18F8X2X = 55. RB3/INT3/ECCP2/P2A, Pin.Type = . RB3/INT3/ECCP2/P2A, Buffer.Type = . RB3/INT3/ECCP2/P2A, Description = . RB3, Pin Number.PIC18F6X2X = . RB3, Pin Number.PIC18F8X2X = . RB3, Pin.Type = I/O. RB3, Buffer.Type = TTL. RB3, Description = Digital I/O.. INT3, Pin Number.PIC18F6X2X = . INT3, Pin Number.PIC18F8X2X = . INT3, Pin.Type = I/O. INT3, Buffer.Type = ST. INT3, Description = External interrupt 3.. ECCP2 (1), Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F6X2X = . ECCP2 (1), Pin Number.PIC18F8X2X = . ECCP2 (1), Pin.Type = I/O. ECCP2 (1), Buffer.Type = ST. ECCP2 (1), Description = Enhanced Capture 2 input, Compare 2 output, PWM2 output.. P2A (1), Pin Number.PIC18F6X2X = . P2A (1), Pin Number.PIC18F8X2X = . P2A (1), Pin.Type = O. P2A (1), Buffer.Type = -. P2A (1), Description = ECCP2 output P2A.. RB4/KBI0, Pin Number.PIC18F6X2X = 44. RB4/KBI0, Pin Number.PIC18F8X2X = 54. RB4/KBI0, Pin.Type = . RB4/KBI0, Buffer.Type =",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. RB4/KBI0, Description = . RB4, Pin Number.PIC18F6X2X = . RB4, Pin Number.PIC18F8X2X = . RB4, Pin.Type = I/O. RB4, Buffer.Type = TTL. RB4, Description = Digital I/O.. KBI0, Pin Number.PIC18F6X2X = . KBI0, Pin Number.PIC18F8X2X = . KBI0, Pin.Type = I. KBI0, Buffer.Type = ST. KBI0, Description = Interrupt-on-change pin.. RB5/KBI1/PGM, Pin Number.PIC18F6X2X = 43. RB5/KBI1/PGM, Pin Number.PIC18F8X2X = 53. RB5/KBI1/PGM, Pin.Type = . RB5/KBI1/PGM, Buffer.Type = . RB5/KBI1/PGM, Description = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB5, Pin Number.PIC18F6X2X = . RB5, Pin Number.PIC18F8X2X = . RB5, Pin.Type = I/O. RB5, Buffer.Type = TTL. RB5, Description = Digital I/O.. KBI1, Pin Number.PIC18F6X2X = . KBI1, Pin Number.PIC18F8X2X = . KBI1, Pin.Type = I. KBI1, Buffer.Type = ST. KBI1, Description = Interrupt-on-change pin.. PGM, Pin Number.PIC18F6X2X = . PGM, Pin Number.PIC18F8X2X = . PGM, Pin.Type = I/O. PGM, Buffer.Type = ST. PGM, Description = Low-Voltage ICSP\u2122 programming enable pin.. RB6/KBI2/PGC, Pin Number.PIC18F6X2X = 42. RB6/KBI2/PGC, Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F8X2X = 52. RB6/KBI2/PGC, Pin.Type = . RB6/KBI2/PGC, Buffer.Type = . RB6/KBI2/PGC, Description = . RB6, Pin Number.PIC18F6X2X = . RB6, Pin Number.PIC18F8X2X = . RB6, Pin.Type = I/O. RB6, Buffer.Type = TTL. RB6, Description = Digital I/O.. KBI2, Pin Number.PIC18F6X2X = . KBI2, Pin Number.PIC18F8X2X = . KBI2, Pin.Type = I. KBI2, Buffer.Type = ST. KBI2, Description = Interrupt-on-change pin.. PGC, Pin Number.PIC18F6X2X = . PGC, Pin Number.PIC18F8X2X = . PGC, Pin.Type = I/O. PGC,",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = ST. PGC, Description = In-Circuit Debugger and. RB7/KBI3/PGD, Pin Number.PIC18F6X2X = 37. RB7/KBI3/PGD, Pin Number.PIC18F8X2X = 47. RB7/KBI3/PGD, Pin.Type = . RB7/KBI3/PGD, Buffer.Type = . RB7/KBI3/PGD, Description = . RB7, Pin Number.PIC18F6X2X = . RB7, Pin Number.PIC18F8X2X = . RB7, Pin.Type = I/O. RB7, Buffer.Type = TTL. RB7, Description = Digital I/O.. KBI3, Pin Number.PIC18F6X2X = . KBI3, Pin Number.PIC18F8X2X = . KBI3, Pin.Type = I. KBI3, Buffer.Type = ST. KBI3, Description =",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nInterrupt-on-change pin.. PGD, Pin Number.PIC18F6X2X = . PGD, Pin Number.PIC18F8X2X = . PGD, Pin.Type = I/O. PGD, Buffer.Type = ST. PGD, Description = In-Circuit Debugger and. , Pin Number.PIC18F6X2X = . , Pin Number.PIC18F8X2X = . , Pin.Type = . , Buffer.Type = . , Description = ICSP programming data.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nAnalog\n= Analog input\nI\n= Input\nO\n= Output\nP = Power\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNote 1: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX (CONFIG3H<0>) is not set (all Program Memory modes except Microcontroller).\n2: Default assignment for ECCP2/P2A when CCP2MX is set (all devices).\n3: External memory interface functions are only available on PIC18F8525/8621 devices.\n4: Default assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is set and for all PIC18F6525/6621 devices.\n5: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX is not set (Microcontroller mode).\n6: PORTH and PORTJ (and their multiplexed functions) are only available on PIC18F8525/8621 devices.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n7: Alternate assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is not set.\n8: AVDD must be connected to a positive supply and AVSS must be connected to a ground reference for proper operation of the part in user or ICSP\u2122 modes. See parameter D001 for details.\n9: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC0/T1OSO/T13CKI, Pin Number.PIC18F6X2X = 30. RC0/T1OSO/T13CKI, Pin Number.PIC18F8X2X = 36. RC0/T1OSO/T13CKI, Pin.Type = . RC0/T1OSO/T13CKI, Buffer.Type = . RC0/T1OSO/T13CKI, Description = . RC0, Pin Number.PIC18F6X2X = . RC0, Pin Number.PIC18F8X2X = . RC0, Pin.Type = I/O. RC0, Buffer.Type = ST. RC0, Description = Digital I/O.. T1OSO, Pin Number.PIC18F6X2X = . T1OSO, Pin Number.PIC18F8X2X = . T1OSO, Pin.Type = O. T1OSO, Buffer.Type = -. T1OSO, Description = Timer1 oscillator output.. T13CKI, Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F6X2X = . T13CKI, Pin Number.PIC18F8X2X = . T13CKI, Pin.Type = I. T13CKI, Buffer.Type = ST. T13CKI, Description = Timer1/Timer3 external clock input.. RC1/T1OSI/ECCP2/P2A, Pin Number.PIC18F6X2X = 29. RC1/T1OSI/ECCP2/P2A, Pin Number.PIC18F8X2X = 35. RC1/T1OSI/ECCP2/P2A, Pin.Type = . RC1/T1OSI/ECCP2/P2A, Buffer.Type = . RC1/T1OSI/ECCP2/P2A, Description = . RC1, Pin Number.PIC18F6X2X = . RC1, Pin Number.PIC18F8X2X = . RC1, Pin.Type = I/O. RC1, Buffer.Type = ST.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC1, Description = Digital I/O.. T1OSI, Pin Number.PIC18F6X2X = . T1OSI, Pin Number.PIC18F8X2X = . T1OSI, Pin.Type = I. T1OSI, Buffer.Type = CMOS. T1OSI, Description = Timer1 oscillator input.. ECCP2 (2), Pin Number.PIC18F6X2X = . ECCP2 (2), Pin Number.PIC18F8X2X = . ECCP2 (2), Pin.Type = I/O. ECCP2 (2), Buffer.Type = ST. ECCP2 (2), Description = Enhanced Capture 2 input, Compare 2 output, PWM 2 output.. P2A (2), Pin Number.PIC18F6X2X = . P2A (2), Pin Number.PIC18F8X2X = . P2A (2), Pin.Type = O. P2A (2),",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = -. P2A (2), Description = ECCP2 output P2A.. RC2/ECCP1/P1A, Pin Number.PIC18F6X2X = 33. RC2/ECCP1/P1A, Pin Number.PIC18F8X2X = 43. RC2/ECCP1/P1A, Pin.Type = . RC2/ECCP1/P1A, Buffer.Type = . RC2/ECCP1/P1A, Description = . RC2, Pin Number.PIC18F6X2X = . RC2, Pin Number.PIC18F8X2X = . RC2, Pin.Type = I/O. RC2, Buffer.Type = ST. RC2, Description = Digital I/O.. ECCP1, Pin Number.PIC18F6X2X = . ECCP1, Pin Number.PIC18F8X2X = . ECCP1, Pin.Type = I/O. ECCP1,",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = ST. ECCP1, Description = Enhanced Capture 1 input, Compare 1 output, PWM 1 output.. P1A, Pin Number.PIC18F6X2X = . P1A, Pin Number.PIC18F8X2X = . P1A, Pin.Type = O. P1A, Buffer.Type = -. P1A, Description = ECCP1 output P1A.. RC3/SCK/SCL, Pin Number.PIC18F6X2X = 34. RC3/SCK/SCL, Pin Number.PIC18F8X2X = 44. RC3/SCK/SCL, Pin.Type = . RC3/SCK/SCL, Buffer.Type = . RC3/SCK/SCL, Description = . RC3, Pin Number.PIC18F6X2X = . RC3, Pin Number.PIC18F8X2X = . RC3, Pin.Type = I/O. RC3, Buffer.Type =",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nST. RC3, Description = Digital I/O.. SCK, Pin Number.PIC18F6X2X = . SCK, Pin Number.PIC18F8X2X = . SCK, Pin.Type = I/O. SCK, Buffer.Type = ST. SCK, Description = Synchronous serial clock input/output for SPI\u2122 mode.. SCL, Pin Number.PIC18F6X2X = . SCL, Pin Number.PIC18F8X2X = . SCL, Pin.Type = I/O. SCL, Buffer.Type = ST. SCL, Description = Synchronous serial clock input/output for I 2 C\u2122 mode.. RC4/SDI/SDA, Pin Number.PIC18F6X2X = 35. RC4/SDI/SDA, Pin Number.PIC18F8X2X = 45. RC4/SDI/SDA, Pin.Type = . RC4/SDI/SDA, Buffer.Type = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC4/SDI/SDA, Description = . RC4, Pin Number.PIC18F6X2X = . RC4, Pin Number.PIC18F8X2X = . RC4, Pin.Type = I/O. RC4, Buffer.Type = ST. RC4, Description = Digital I/O.. SDI, Pin Number.PIC18F6X2X = . SDI, Pin Number.PIC18F8X2X = . SDI, Pin.Type = I. SDI, Buffer.Type = ST. SDI, Description = SPI data in.. SDA, Pin Number.PIC18F6X2X = . SDA, Pin Number.PIC18F8X2X = . SDA, Pin.Type = I/O. SDA, Buffer.Type = ST. SDA, Description = I 2 C data I/O.. RC5/SDO, Pin Number.PIC18F6X2X = 36. RC5/SDO, Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F8X2X = 46. RC5/SDO, Pin.Type = . RC5/SDO, Buffer.Type = . RC5/SDO, Description = . RC5, Pin Number.PIC18F6X2X = . RC5, Pin Number.PIC18F8X2X = . RC5, Pin.Type = I/O. RC5, Buffer.Type = ST. RC5, Description = Digital I/O.. SDO, Pin Number.PIC18F6X2X = . SDO, Pin Number.PIC18F8X2X = . SDO, Pin.Type = O. SDO, Buffer.Type = -. SDO, Description = SPI data out.. RC6/TX1/CK1, Pin Number.PIC18F6X2X = . RC6/TX1/CK1, Pin Number.PIC18F8X2X = . RC6/TX1/CK1, Pin.Type = . RC6/TX1/CK1,",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = . RC6/TX1/CK1, Description = clock. CK1, Pin Number.PIC18F6X2X = 31. CK1, Pin Number.PIC18F8X2X = 37. CK1, Pin.Type = . CK1, Buffer.Type = . CK1, Description = . RC6, Pin Number.PIC18F6X2X = . RC6, Pin Number.PIC18F8X2X = . RC6, Pin.Type = I/O. RC6, Buffer.Type = ST. RC6, Description = Digital I/O.. TX1, Pin Number.PIC18F6X2X = . TX1, Pin Number.PIC18F8X2X = . TX1, Pin.Type = O. TX1, Buffer.Type = -. TX1, Description = USART1 asynchronous transmit.. , Pin Number.PIC18F6X2X = . , Pin Number.PIC18F8X2X = . , Pin.Type =",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. , Buffer.Type = ST. , Description = USART1 synchronous (see RX1/DT1).. RC7/RX1/DT1, Pin Number.PIC18F6X2X = 32. RC7/RX1/DT1, Pin Number.PIC18F8X2X = 38. RC7/RX1/DT1, Pin.Type = . RC7/RX1/DT1, Buffer.Type = . RC7/RX1/DT1, Description = . RC7, Pin Number.PIC18F6X2X = . RC7, Pin Number.PIC18F8X2X = . RC7, Pin.Type = I/O. RC7, Buffer.Type = ST. RC7, Description = Digital I/O.. RX1, Pin Number.PIC18F6X2X = . RX1, Pin Number.PIC18F8X2X = . RX1, Pin.Type = I. RX1,",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = ST. RX1, Description = USART1 asynchronous receive.. DT1, Pin Number.PIC18F6X2X = . DT1, Pin Number.PIC18F8X2X = . DT1, Pin.Type = I/O. DT1, Buffer.Type = ST. DT1, Description = USART1 synchronous data (see TX1/CK1).\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nAnalog\n= Analog input\nI = Input\nO\n= Output\nP = Power\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNote 1: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX (CONFIG3H<0>) is not set (all Program Memory modes except Microcontroller).\n2: Default assignment for ECCP2/P2A when CCP2MX is set (all devices).\n3: External memory interface functions are only available on PIC18F8525/8621 devices.\n4: Default assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is set and for all PIC18F6525/6621 devices.\n5: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX is not set (Microcontroller mode).\n6: PORTH and PORTJ (and their multiplexed functions) are only available on PIC18F8525/8621 devices.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n7: Alternate assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is not set.\n8: AVDD must be connected to a positive supply and AVSS must be connected to a ground reference for proper operation of the part in user or ICSP\u2122 modes. See parameter D001 for details.\n9: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD0/AD0/PSP0, Pin Number.PIC18F6X2X = 58. RD0/AD0/PSP0, Pin Number.PIC18F8X2X = 72. RD0/AD0/PSP0, Pin.Type = . RD0/AD0/PSP0, Buffer.Type = . RD0/AD0/PSP0, Description = memory is enabled.. RD0, Pin Number.PIC18F6X2X = . RD0, Pin Number.PIC18F8X2X = . RD0, Pin.Type = I/O. RD0, Buffer.Type = ST. RD0, Description = Digital I/O.. AD0 (3), Pin Number.PIC18F6X2X = . AD0 (3), Pin Number.PIC18F8X2X = . AD0 (3), Pin.Type = I/O. AD0 (3), Buffer.Type = TTL. AD0 (3), Description = External memory",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\naddress/data 0.. PSP0, Pin Number.PIC18F6X2X = . PSP0, Pin Number.PIC18F8X2X = . PSP0, Pin.Type = I/O. PSP0, Buffer.Type = TTL. PSP0, Description = Parallel Slave Port data.. RD1/AD1/PSP1, Pin Number.PIC18F6X2X = 55. RD1/AD1/PSP1, Pin Number.PIC18F8X2X = 69. RD1/AD1/PSP1, Pin.Type = . RD1/AD1/PSP1, Buffer.Type = . RD1/AD1/PSP1, Description = . RD1, Pin Number.PIC18F6X2X = . RD1, Pin Number.PIC18F8X2X = . RD1, Pin.Type = I/O. RD1, Buffer.Type = ST. RD1, Description = Digital I/O.. AD1",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n(3), Pin Number.PIC18F6X2X = . AD1 (3), Pin Number.PIC18F8X2X = . AD1 (3), Pin.Type = I/O. AD1 (3), Buffer.Type = TTL. AD1 (3), Description = External memory address/data 1.. PSP1, Pin Number.PIC18F6X2X = . PSP1, Pin Number.PIC18F8X2X = . PSP1, Pin.Type = I/O. PSP1, Buffer.Type = TTL. PSP1, Description = Parallel Slave Port data.. RD2/AD2/PSP2, Pin Number.PIC18F6X2X = 54. RD2/AD2/PSP2, Pin Number.PIC18F8X2X = 68. RD2/AD2/PSP2, Pin.Type = . RD2/AD2/PSP2, Buffer.Type = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD2/AD2/PSP2, Description = . RD2, Pin Number.PIC18F6X2X = . RD2, Pin Number.PIC18F8X2X = . RD2, Pin.Type = I/O. RD2, Buffer.Type = ST. RD2, Description = Digital I/O.. AD2 (3), Pin Number.PIC18F6X2X = . AD2 (3), Pin Number.PIC18F8X2X = . AD2 (3), Pin.Type = I/O. AD2 (3), Buffer.Type = TTL. AD2 (3), Description = External memory address/data 2.. PSP2, Pin Number.PIC18F6X2X = . PSP2, Pin Number.PIC18F8X2X = . PSP2, Pin.Type = I/O. PSP2, Buffer.Type = TTL. PSP2, Description = Parallel Slave Port data..",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD3/AD3/PSP3, Pin Number.PIC18F6X2X = 53. RD3/AD3/PSP3, Pin Number.PIC18F8X2X = 67. RD3/AD3/PSP3, Pin.Type = . RD3/AD3/PSP3, Buffer.Type = . RD3/AD3/PSP3, Description = . RD3, Pin Number.PIC18F6X2X = . RD3, Pin Number.PIC18F8X2X = . RD3, Pin.Type = I/O. RD3, Buffer.Type = ST. RD3, Description = Digital I/O.. AD3 (3), Pin Number.PIC18F6X2X = . AD3 (3), Pin Number.PIC18F8X2X = . AD3 (3), Pin.Type = I/O. AD3 (3), Buffer.Type = TTL. AD3 (3), Description = External memory address/data",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n3.. PSP3, Pin Number.PIC18F6X2X = . PSP3, Pin Number.PIC18F8X2X = . PSP3, Pin.Type = I/O. PSP3, Buffer.Type = TTL. PSP3, Description = Parallel Slave Port data.. RD4/AD4/PSP4, Pin Number.PIC18F6X2X = 52. RD4/AD4/PSP4, Pin Number.PIC18F8X2X = 66. RD4/AD4/PSP4, Pin.Type = . RD4/AD4/PSP4, Buffer.Type = . RD4/AD4/PSP4, Description = . RD4, Pin Number.PIC18F6X2X = . RD4, Pin Number.PIC18F8X2X = . RD4, Pin.Type = I/O. RD4, Buffer.Type = ST. RD4, Description = Digital I/O.. AD4 (3), Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F6X2X = . AD4 (3), Pin Number.PIC18F8X2X = . AD4 (3), Pin.Type = I/O. AD4 (3), Buffer.Type = TTL. AD4 (3), Description = External memory address/data 4.. PSP4, Pin Number.PIC18F6X2X = . PSP4, Pin Number.PIC18F8X2X = . PSP4, Pin.Type = I/O. PSP4, Buffer.Type = TTL. PSP4, Description = Parallel Slave Port data.. RD5/AD5/PSP5, Pin Number.PIC18F6X2X = 51. RD5/AD5/PSP5, Pin Number.PIC18F8X2X = 65. RD5/AD5/PSP5, Pin.Type = . RD5/AD5/PSP5, Buffer.Type = . RD5/AD5/PSP5, Description = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD5, Pin Number.PIC18F6X2X = . RD5, Pin Number.PIC18F8X2X = . RD5, Pin.Type = I/O. RD5, Buffer.Type = ST. RD5, Description = Digital I/O.. AD5 (3), Pin Number.PIC18F6X2X = . AD5 (3), Pin Number.PIC18F8X2X = . AD5 (3), Pin.Type = I/O. AD5 (3), Buffer.Type = TTL. AD5 (3), Description = External memory address/data 5.. PSP5, Pin Number.PIC18F6X2X = . PSP5, Pin Number.PIC18F8X2X = . PSP5, Pin.Type = I/O. PSP5, Buffer.Type = TTL. PSP5, Description = Parallel Slave Port data.. RD6/AD6/PSP6, Pin Number.PIC18F6X2X =",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n50. RD6/AD6/PSP6, Pin Number.PIC18F8X2X = 64. RD6/AD6/PSP6, Pin.Type = . RD6/AD6/PSP6, Buffer.Type = . RD6/AD6/PSP6, Description = . RD6, Pin Number.PIC18F6X2X = . RD6, Pin Number.PIC18F8X2X = . RD6, Pin.Type = I/O. RD6, Buffer.Type = ST. RD6, Description = Digital I/O.. AD6 (3), Pin Number.PIC18F6X2X = . AD6 (3), Pin Number.PIC18F8X2X = . AD6 (3), Pin.Type = I/O. AD6 (3), Buffer.Type = TTL. AD6 (3), Description = External memory address/data 6.. PSP6, Pin Number.PIC18F6X2X = . PSP6,",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin Number.PIC18F8X2X = . PSP6, Pin.Type = I/O. PSP6, Buffer.Type = TTL. PSP6, Description = Parallel Slave Port data.. RD7/AD7/PSP7, Pin Number.PIC18F6X2X = 49. RD7/AD7/PSP7, Pin Number.PIC18F8X2X = 63. RD7/AD7/PSP7, Pin.Type = . RD7/AD7/PSP7, Buffer.Type = . RD7/AD7/PSP7, Description = . RD7, Pin Number.PIC18F6X2X = . RD7, Pin Number.PIC18F8X2X = . RD7, Pin.Type = I/O. RD7, Buffer.Type = ST. RD7, Description = Digital I/O.. AD7 (3), Pin Number.PIC18F6X2X = . AD7 (3), Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F8X2X = . AD7 (3), Pin.Type = I/O. AD7 (3), Buffer.Type = TTL. AD7 (3), Description = External memory address/data 7.. PSP7, Pin Number.PIC18F6X2X = . PSP7, Pin Number.PIC18F8X2X = . PSP7, Pin.Type = I/O. PSP7, Buffer.Type = TTL. PSP7, Description = Parallel Slave Port data.\nLegend: TTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI\n= Input\nAnalog\n= Analog input\nO\n= Output\n- P = Power\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNote 1: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX (CONFIG3H<0>) is not set (all Program Memory modes except Microcontroller).\n2: Default assignment for ECCP2/P2A when CCP2MX is set (all devices).\n3: External memory interface functions are only available on PIC18F8525/8621 devices.\n4: Default assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is set and for all PIC18F6525/6621 devices.\n5: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX is not set (Microcontroller mode).\n6: PORTH and PORTJ (and their multiplexed functions) are only available on PIC18F8525/8621 devices.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n7: Alternate assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is not set.\n8: AVDD must be connected to a positive supply and AVSS must be connected to a ground reference for proper operation of the part in user or ICSP\u2122 modes. See parameter D001 for details.\n9: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRE0/AD8/RD/P2D, Pin Number.PIC18F6X2X = 2. RE0/AD8/RD/P2D, Pin Number.PIC18F8X2X = 4. RE0/AD8/RD/P2D, Pin.Type = . RE0/AD8/RD/P2D, Buffer.Type = . RE0/AD8/RD/P2D, Description = PORTE is a bidirectional I/O port.. RE0, Pin Number.PIC18F6X2X = . RE0, Pin Number.PIC18F8X2X = . RE0, Pin.Type = I/O. RE0, Buffer.Type = ST. RE0, Description = Digital I/O.. AD8 (3), Pin Number.PIC18F6X2X = . AD8 (3), Pin Number.PIC18F8X2X = . AD8 (3), Pin.Type = I/O. AD8 (3),",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = TTL. AD8 (3), Description = External memory address/data 8.. RD, Pin Number.PIC18F6X2X = . RD, Pin Number.PIC18F8X2X = . RD, Pin.Type = I. RD, Buffer.Type = TTL. RD, Description = Read control for Parallel Slave Port.. P2D, Pin Number.PIC18F6X2X = . P2D, Pin Number.PIC18F8X2X = . P2D, Pin.Type = O. P2D, Buffer.Type = -. P2D, Description = ECCP2 output P2D.. RE1/AD9/WR/P2C, Pin Number.PIC18F6X2X = 1. RE1/AD9/WR/P2C, Pin Number.PIC18F8X2X = 3. RE1/AD9/WR/P2C, Pin.Type = . RE1/AD9/WR/P2C,",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = . RE1/AD9/WR/P2C, Description = . RE1, Pin Number.PIC18F6X2X = . RE1, Pin Number.PIC18F8X2X = . RE1, Pin.Type = I/O. RE1, Buffer.Type = ST. RE1, Description = Digital I/O.. AD9 (3), Pin Number.PIC18F6X2X = . AD9 (3), Pin Number.PIC18F8X2X = . AD9 (3), Pin.Type = I/O. AD9 (3), Buffer.Type = TTL. AD9 (3), Description = External memory address/data 9.. WR, Pin Number.PIC18F6X2X = . WR, Pin Number.PIC18F8X2X = . WR, Pin.Type = I. WR, Buffer.Type = TTL. WR, Description = Write control for Parallel Slave Port.. P2C, Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F6X2X = . P2C, Pin Number.PIC18F8X2X = . P2C, Pin.Type = O. P2C, Buffer.Type = ST. P2C, Description = ECCP2 output P2C.. RE2/AD10/CS/P2B, Pin Number.PIC18F6X2X = 64. RE2/AD10/CS/P2B, Pin Number.PIC18F8X2X = 78. RE2/AD10/CS/P2B, Pin.Type = . RE2/AD10/CS/P2B, Buffer.Type = . RE2/AD10/CS/P2B, Description = . RE2, Pin Number.PIC18F6X2X = . RE2, Pin Number.PIC18F8X2X = . RE2, Pin.Type = I/O. RE2, Buffer.Type = ST. RE2, Description = Digital I/O.. AD10 (3),",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin Number.PIC18F6X2X = . AD10 (3), Pin Number.PIC18F8X2X = . AD10 (3), Pin.Type = I/O. AD10 (3), Buffer.Type = TTL. AD10 (3), Description = External memory address/data 10.. CS, Pin Number.PIC18F6X2X = . CS, Pin Number.PIC18F8X2X = . CS, Pin.Type = I. CS, Buffer.Type = TTL. CS, Description = Chip select control for Parallel Slave Port.. P2B, Pin Number.PIC18F6X2X = . P2B, Pin Number.PIC18F8X2X = . P2B, Pin.Type = O. P2B, Buffer.Type = -. P2B, Description = ECCP2 output P2B.. RE3/AD11/P3C, Pin Number.PIC18F6X2X = 63.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRE3/AD11/P3C, Pin Number.PIC18F8X2X = 77. RE3/AD11/P3C, Pin.Type = . RE3/AD11/P3C, Buffer.Type = . RE3/AD11/P3C, Description = . RE3, Pin Number.PIC18F6X2X = . RE3, Pin Number.PIC18F8X2X = . RE3, Pin.Type = I/O. RE3, Buffer.Type = ST. RE3, Description = Digital I/O.. AD11 (3), Pin Number.PIC18F6X2X = . AD11 (3), Pin Number.PIC18F8X2X = . AD11 (3), Pin.Type = I/O. AD11 (3), Buffer.Type = TTL. AD11 (3), Description = External memory address/data 11.. P3C (4), Pin Number.PIC18F6X2X = . P3C",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n(4), Pin Number.PIC18F8X2X = . P3C (4), Pin.Type = O. P3C (4), Buffer.Type = -. P3C (4), Description = ECCP3 output P3C.. RE4/AD12/P3B, Pin Number.PIC18F6X2X = 62. RE4/AD12/P3B, Pin Number.PIC18F8X2X = 76. RE4/AD12/P3B, Pin.Type = . RE4/AD12/P3B, Buffer.Type = . RE4/AD12/P3B, Description = . RE4, Pin Number.PIC18F6X2X = . RE4, Pin Number.PIC18F8X2X = . RE4, Pin.Type = I/O. RE4, Buffer.Type = ST. RE4, Description = Digital I/O.. AD12 (3), Pin Number.PIC18F6X2X = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nAD12 (3), Pin Number.PIC18F8X2X = . AD12 (3), Pin.Type = I/O. AD12 (3), Buffer.Type = TTL. AD12 (3), Description = External memory address/data 12.. P3B (4), Pin Number.PIC18F6X2X = . P3B (4), Pin Number.PIC18F8X2X = . P3B (4), Pin.Type = O. P3B (4), Buffer.Type = . P3B (4), Description = . , Pin Number.PIC18F6X2X = . , Pin Number.PIC18F8X2X = . , Pin.Type = . , Buffer.Type = -. , Description = ECCP3 output P3B.. RE5/AD13/P1C, Pin Number.PIC18F6X2X = 61. RE5/AD13/P1C, Pin Number.PIC18F8X2X",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= 75. RE5/AD13/P1C, Pin.Type = . RE5/AD13/P1C, Buffer.Type = . RE5/AD13/P1C, Description = . RE5, Pin Number.PIC18F6X2X = . RE5, Pin Number.PIC18F8X2X = . RE5, Pin.Type = I/O. RE5, Buffer.Type = ST. RE5, Description = Digital I/O.. AD13 (3), Pin Number.PIC18F6X2X = . AD13 (3), Pin Number.PIC18F8X2X = . AD13 (3), Pin.Type = I/O. AD13 (3), Buffer.Type = TTL. AD13 (3), Description = External memory address/data 13.. P1C (4), Pin Number.PIC18F6X2X = . P1C (4), Pin Number.PIC18F8X2X = . P1C",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n(4), Pin.Type = O. P1C (4), Buffer.Type = -. P1C (4), Description = ECCP1 output P1C.. RE6/AD14/P1B, Pin Number.PIC18F6X2X = 60. RE6/AD14/P1B, Pin Number.PIC18F8X2X = 74. RE6/AD14/P1B, Pin.Type = . RE6/AD14/P1B, Buffer.Type = . RE6/AD14/P1B, Description = . RE6, Pin Number.PIC18F6X2X = . RE6, Pin Number.PIC18F8X2X = . RE6, Pin.Type = I/O. RE6, Buffer.Type = ST. RE6, Description = Digital I/O.. AD14 (3), Pin Number.PIC18F6X2X = . AD14 (3), Pin Number.PIC18F8X2X = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nAD14 (3), Pin.Type = I/O. AD14 (3), Buffer.Type = TTL. AD14 (3), Description = External memory address/data 14.. P1B (4), Pin Number.PIC18F6X2X = . P1B (4), Pin Number.PIC18F8X2X = . P1B (4), Pin.Type = O. P1B (4), Buffer.Type = -. P1B (4), Description = ECCP1 output P1B.. RE7/AD15/ECCP2/P2A, Pin Number.PIC18F6X2X = 59. RE7/AD15/ECCP2/P2A, Pin Number.PIC18F8X2X = 73. RE7/AD15/ECCP2/P2A, Pin.Type = . RE7/AD15/ECCP2/P2A, Buffer.Type = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRE7/AD15/ECCP2/P2A, Description = . RE7, Pin Number.PIC18F6X2X = . RE7, Pin Number.PIC18F8X2X = . RE7, Pin.Type = I/O. RE7, Buffer.Type = ST. RE7, Description = Digital I/O.. AD15 (3), Pin Number.PIC18F6X2X = . AD15 (3), Pin Number.PIC18F8X2X = . AD15 (3), Pin.Type = I/O. AD15 (3), Buffer.Type = TTL. AD15 (3), Description = External memory address/data 15.. ECCP2 (5), Pin Number.PIC18F6X2X = . ECCP2 (5), Pin Number.PIC18F8X2X = . ECCP2 (5), Pin.Type = I/O. ECCP2 (5), Buffer.Type = ST. ECCP2",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n(5), Description = Enhanced Capture 2 input, Compare 2 output, PWM 2 output.. P2A (5), Pin Number.PIC18F6X2X = . P2A (5), Pin Number.PIC18F8X2X = . P2A (5), Pin.Type = O. P2A (5), Buffer.Type = -. P2A (5), Description = ECCP2 output P2A.\nLegend: TTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels\nI\n= Input",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nP = Power\nNote 1: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX (CONFIG3H<0>) is not set (all Program Memory modes except Microcontroller).\n2: Default assignment for ECCP2/P2A when CCP2MX is set (all devices).\n3: External memory interface functions are only available on PIC18F8525/8621 devices.\n4: Default assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is set and for all PIC18F6525/6621 devices.\n5: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX is not set (Microcontroller mode).\n6: PORTH and PORTJ (and their multiplexed functions) are only available on PIC18F8525/8621 devices.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n7: Alternate assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is not set.\n8: AVDD must be connected to a positive supply and AVSS must be connected to a ground reference for proper operation of the part in user or ICSP\u2122 modes. See parameter D001 for details.\n9: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.\nCMOS = CMOS compatible input or output\nAnalog = Analog input\nO\n= Output\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRF0/AN5 RF0 AN5, Pin Number.PIC18F6X2X = 18. RF0/AN5 RF0 AN5, Pin Number.PIC18F8X2X = 24. RF0/AN5 RF0 AN5, Pin.Type = I/O I. RF0/AN5 RF0 AN5, Buffer.Type = ST Analog ST Analog ST ST. RF0/AN5 RF0 AN5, Description. = PORTF is a bidirectional I/O port. Digital I/O. Analog input 5. Digital I/O.. RF1/AN6/C2OUT RF1 AN6, Pin Number.PIC18F6X2X = 17. RF1/AN6/C2OUT RF1 AN6, Pin Number.PIC18F8X2X = 23. RF1/AN6/C2OUT RF1 AN6, Pin.Type = I/O I O. RF1/AN6/C2OUT RF1 AN6, Buffer.Type = . RF1/AN6/C2OUT",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRF1 AN6, Description. = Analog input 6. Comparator 2 output.. RF2/AN7/C1OUT RF2 AN7 C1OUT, Pin Number.PIC18F6X2X = 16. RF2/AN7/C1OUT RF2 AN7 C1OUT, Pin Number.PIC18F8X2X = 18. RF2/AN7/C1OUT RF2 AN7 C1OUT, Pin.Type = I/O I O. RF2/AN7/C1OUT RF2 AN7 C1OUT, Buffer.Type = Analog ST. RF2/AN7/C1OUT RF2 AN7 C1OUT, Description. = Digital I/O. Analog input 7. Comparator 1 output.. RF3/AN8 RF1 AN8, Pin Number.PIC18F6X2X = 15. RF3/AN8 RF1 AN8, Pin Number.PIC18F8X2X = 17. RF3/AN8 RF1 AN8, Pin.Type = I/O I. RF3/AN8 RF1",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nAN8, Buffer.Type = ST Analog. RF3/AN8 RF1 AN8, Description. = Digital I/O. Analog input 8.. RF4/AN9 RF1 AN9, Pin Number.PIC18F6X2X = 14. RF4/AN9 RF1 AN9, Pin Number.PIC18F8X2X = 16. RF4/AN9 RF1 AN9, Pin.Type = . RF4/AN9 RF1 AN9, Buffer.Type = ST. RF4/AN9 RF1 AN9, Description. = . RF5/AN10/CVREF RF1, Pin Number.PIC18F6X2X = 13. RF5/AN10/CVREF RF1, Pin Number.PIC18F8X2X = 15. RF5/AN10/CVREF RF1, Pin.Type = I/O I. RF5/AN10/CVREF RF1, Buffer.Type = Analog ST. RF5/AN10/CVREF RF1, Description.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= Digital I/O. Analog input 9.. AN10 CVREF, Pin Number.PIC18F6X2X = 12. AN10 CVREF, Pin Number.PIC18F8X2X = 14. AN10 CVREF, Pin.Type = I O I/O I. AN10 CVREF, Buffer.Type = Analog Analog ST Analog. AN10 CVREF, Description. = Analog input 10. Comparator VREF output. Digital I/O. Analog input 11.. RF6/AN11 RF6 AN11, Pin Number.PIC18F6X2X = . RF6/AN11 RF6 AN11, Pin Number.PIC18F8X2X = . RF6/AN11 RF6 AN11, Pin.Type = . RF6/AN11 RF6 AN11, Buffer.Type = . RF6/AN11 RF6 AN11, Description. = . RF7/SS, Pin Number.PIC18F6X2X = 11. RF7/SS, Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F8X2X = 13. RF7/SS, Pin.Type = I/O. RF7/SS, Buffer.Type = . RF7/SS, Description. = . RF7, Pin Number.PIC18F6X2X = . RF7, Pin Number.PIC18F8X2X = . RF7, Pin.Type = . RF7, Buffer.Type = ST. RF7, Description. = Digital I/O.. , Pin Number.PIC18F6X2X = . , Pin Number.PIC18F8X2X = . , Pin.Type = I. , Buffer.Type = . , Description. = . SS, Pin Number.PIC18F6X2X = . SS, Pin Number.PIC18F8X2X = . SS, Pin.Type = . SS, Buffer.Type = . SS, Description. = . , Pin Number.PIC18F6X2X = . , Pin Number.PIC18F8X2X = . , Pin.Type = . ,",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = TTL. , Description. = SPI\u2122 slave select. , Pin Number.PIC18F6X2X = . , Pin Number.PIC18F8X2X = . , Pin.Type = . , Buffer.Type = . , Description. = input.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nAnalog\n= Analog input\nI = Input\nO\n= Output\nP = Power\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNote 1: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX (CONFIG3H<0>) is not set (all Program Memory modes except Microcontroller).\n2: Default assignment for ECCP2/P2A when CCP2MX is set (all devices).\n3: External memory interface functions are only available on PIC18F8525/8621 devices.\n4: Default assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is set and for all PIC18F6525/6621 devices.\n5: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX is not set (Microcontroller mode).\n6: PORTH and PORTJ (and their multiplexed functions) are only available on PIC18F8525/8621 devices.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n7: Alternate assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is not set.\n8: AVDD must be connected to a positive supply and AVSS must be connected to a ground reference for proper operation of the part in user or ICSP\u2122 modes. See parameter D001 for details.\n9: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRG0/ECCP3/P3A, Pin Number.PIC18F6X2X = 3. RG0/ECCP3/P3A, Pin Number.PIC18F8X2X = 5. RG0/ECCP3/P3A, Pin.Type = . RG0/ECCP3/P3A, Buffer.Type = . RG0/ECCP3/P3A, Description. = PORTG is a bidirectional I/O port.. RG0, Pin Number.PIC18F6X2X = . RG0, Pin Number.PIC18F8X2X = . RG0, Pin.Type = I/O. RG0, Buffer.Type = ST. RG0, Description. = Digital I/O.. ECCP3, Pin Number.PIC18F6X2X = . ECCP3, Pin Number.PIC18F8X2X = . ECCP3, Pin.Type = I/O. ECCP3,",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = ST. ECCP3, Description. = Enhanced Capture 3 input, Compare 3 output, PWM 3 output.. P3A, Pin Number.PIC18F6X2X = . P3A, Pin Number.PIC18F8X2X = . P3A, Pin.Type = O. P3A, Buffer.Type = -. P3A, Description. = ECCP3 output P3A.. RG1/TX2/CK2, Pin Number.PIC18F6X2X = 4. RG1/TX2/CK2, Pin Number.PIC18F8X2X = 6. RG1/TX2/CK2, Pin.Type = . RG1/TX2/CK2, Buffer.Type = . RG1/TX2/CK2, Description. = . RG1, Pin Number.PIC18F6X2X = . RG1, Pin Number.PIC18F8X2X = . RG1, Pin.Type =",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. RG1, Buffer.Type = ST. RG1, Description. = Digital I/O.. TX2, Pin Number.PIC18F6X2X = . TX2, Pin Number.PIC18F8X2X = . TX2, Pin.Type = O. TX2, Buffer.Type = -. TX2, Description. = USART2 asynchronous transmit.. CK2, Pin Number.PIC18F6X2X = . CK2, Pin Number.PIC18F8X2X = . CK2, Pin.Type = I/O. CK2, Buffer.Type = ST. CK2, Description. = USART2 synchronous clock. RG2/RX2/DT2, Pin Number.PIC18F6X2X = 5. RG2/RX2/DT2, Pin Number.PIC18F8X2X = 7. RG2/RX2/DT2, Pin.Type = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRG2/RX2/DT2, Buffer.Type = . RG2/RX2/DT2, Description. = . RG2, Pin Number.PIC18F6X2X = . RG2, Pin Number.PIC18F8X2X = . RG2, Pin.Type = I/O. RG2, Buffer.Type = ST. RG2, Description. = Digital I/O.. RX2, Pin Number.PIC18F6X2X = . RX2, Pin Number.PIC18F8X2X = . RX2, Pin.Type = I. RX2, Buffer.Type = ST. RX2, Description. = USART2 asynchronous receive.. DT2, Pin Number.PIC18F6X2X = . DT2, Pin Number.PIC18F8X2X = . DT2, Pin.Type = I/O. DT2, Buffer.Type = ST. DT2, Description. = USART2",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nsynchronous data (see TX2/CK2).. RG3/CCP4/P3D, Pin Number.PIC18F6X2X = 6. RG3/CCP4/P3D, Pin Number.PIC18F8X2X = 8. RG3/CCP4/P3D, Pin.Type = . RG3/CCP4/P3D, Buffer.Type = . RG3/CCP4/P3D, Description. = . RG3, Pin Number.PIC18F6X2X = . RG3, Pin Number.PIC18F8X2X = . RG3, Pin.Type = I/O. RG3, Buffer.Type = ST. RG3, Description. = Digital I/O.. CCP4, Pin Number.PIC18F6X2X = . CCP4, Pin Number.PIC18F8X2X = . CCP4, Pin.Type = I/O. CCP4, Buffer.Type",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= ST. CCP4, Description. = Capture 4 input, Compare 4 output, PWM 4 output.. P3D, Pin Number.PIC18F6X2X = . P3D, Pin Number.PIC18F8X2X = . P3D, Pin.Type = O. P3D, Buffer.Type = -. P3D, Description. = ECCP3 output P3D.. RG4/CCP5/P1D, Pin Number.PIC18F6X2X = 8. RG4/CCP5/P1D, Pin Number.PIC18F8X2X = 10. RG4/CCP5/P1D, Pin.Type = . RG4/CCP5/P1D, Buffer.Type = . RG4/CCP5/P1D, Description. = . RG4, Pin Number.PIC18F6X2X = . RG4, Pin Number.PIC18F8X2X = . RG4, Pin.Type =",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. RG4, Buffer.Type = ST. RG4, Description. = Digital I/O.. CCP5, Pin Number.PIC18F6X2X = . CCP5, Pin Number.PIC18F8X2X = . CCP5, Pin.Type = I/O. CCP5, Buffer.Type = ST. CCP5, Description. = Capture 5 input, Compare 5 output, PWM 5 output.. P1D, Pin Number.PIC18F6X2X = . P1D, Pin Number.PIC18F8X2X = . P1D, Pin.Type = O. P1D, Buffer.Type = -. P1D, Description. = ECCP1 output P1D.. RG5, Pin Number.PIC18F6X2X = 7. RG5, Pin Number.PIC18F8X2X = 9. RG5, Pin.Type = -. RG5, Buffer.Type = -.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRG5, Description. = See MCLR/VPP/RG5 pin.\nLegend:\nTTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels\nI\n= Input\nP = Power\nCMOS = CMOS compatible input or output\nAnalog\n= Analog input\nO\n= Output\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNote 1: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX (CONFIG3H<0>) is not set (all Program Memory modes except Microcontroller).\n2: Default assignment for ECCP2/P2A when CCP2MX is set (all devices).\n3: External memory interface functions are only available on PIC18F8525/8621 devices.\n4: Default assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is set and for all PIC18F6525/6621 devices.\n5: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX is not set (Microcontroller mode).\n6: PORTH and PORTJ (and their multiplexed functions) are only available on PIC18F8525/8621 devices.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n7: Alternate assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is not set.\n8: AVDD must be connected to a positive supply and AVSS must be connected to a ground reference for proper operation of the part in user or ICSP\u2122 modes. See parameter D001 for details.\n9: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRH0/A16, Pin Number.PIC18F6X2X = -. RH0/A16, Pin Number.PIC18F8X2X = 79. RH0/A16, Pin.Type = . RH0/A16, Buffer.Type = . RH0/A16, Description. = . RH0, Pin Number.PIC18F6X2X = . RH0, Pin Number.PIC18F8X2X = . RH0, Pin.Type = I/O. RH0, Buffer.Type = ST. RH0, Description. = Digital I/O.. A16, Pin Number.PIC18F6X2X = . A16, Pin Number.PIC18F8X2X = . A16, Pin.Type = O. A16, Buffer.Type = TTL. A16, Description. = External memory address 16.. RH1/A17, Pin Number.PIC18F6X2X = -.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRH1/A17, Pin Number.PIC18F8X2X = 80. RH1/A17, Pin.Type = . RH1/A17, Buffer.Type = . RH1/A17, Description. = . RH1, Pin Number.PIC18F6X2X = . RH1, Pin Number.PIC18F8X2X = . RH1, Pin.Type = I/O. RH1, Buffer.Type = ST. RH1, Description. = Digital I/O.. A17, Pin Number.PIC18F6X2X = . A17, Pin Number.PIC18F8X2X = . A17, Pin.Type = O. A17, Buffer.Type = TTL. A17, Description. = External memory address 17.. RH2/A18, Pin Number.PIC18F6X2X = -. RH2/A18, Pin Number.PIC18F8X2X = 1.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRH2/A18, Pin.Type = . RH2/A18, Buffer.Type = . RH2/A18, Description. = . RH2, Pin Number.PIC18F6X2X = . RH2, Pin Number.PIC18F8X2X = . RH2, Pin.Type = I/O. RH2, Buffer.Type = ST. RH2, Description. = Digital I/O.. A18, Pin Number.PIC18F6X2X = . A18, Pin Number.PIC18F8X2X = . A18, Pin.Type = O. A18, Buffer.Type = TTL. A18, Description. = External memory address 18.. RH3/A19, Pin Number.PIC18F6X2X = -. RH3/A19, Pin Number.PIC18F8X2X = 2. RH3/A19, Pin.Type = . RH3/A19, Buffer.Type = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRH3/A19, Description. = . RH3, Pin Number.PIC18F6X2X = . RH3, Pin Number.PIC18F8X2X = . RH3, Pin.Type = I/O. RH3, Buffer.Type = ST. RH3, Description. = Digital I/O.. A19, Pin Number.PIC18F6X2X = . A19, Pin Number.PIC18F8X2X = . A19, Pin.Type = O. A19, Buffer.Type = TTL. A19, Description. = External memory address 19.. RH4/AN12/P3C, Pin Number.PIC18F6X2X = -. RH4/AN12/P3C, Pin Number.PIC18F8X2X = 22. RH4/AN12/P3C, Pin.Type = . RH4/AN12/P3C, Buffer.Type = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRH4/AN12/P3C, Description. = . RH4, Pin Number.PIC18F6X2X = . RH4, Pin Number.PIC18F8X2X = . RH4, Pin.Type = I/O. RH4, Buffer.Type = ST. RH4, Description. = Digital I/O.. AN12, Pin Number.PIC18F6X2X = . AN12, Pin Number.PIC18F8X2X = . AN12, Pin.Type = I. AN12, Buffer.Type = Analog. AN12, Description. = Analog input 12.. P3C (7), Pin Number.PIC18F6X2X = . P3C (7), Pin Number.PIC18F8X2X = . P3C (7), Pin.Type = O. P3C (7), Buffer.Type = -. P3C (7), Description. = ECCP3 output P3C..",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRH5/AN13/P3B, Pin Number.PIC18F6X2X = -. RH5/AN13/P3B, Pin Number.PIC18F8X2X = 21. RH5/AN13/P3B, Pin.Type = . RH5/AN13/P3B, Buffer.Type = . RH5/AN13/P3B, Description. = . RH5, Pin Number.PIC18F6X2X = . RH5, Pin Number.PIC18F8X2X = . RH5, Pin.Type = I/O. RH5, Buffer.Type = ST. RH5, Description. = Digital I/O.. AN13, Pin Number.PIC18F6X2X = . AN13, Pin Number.PIC18F8X2X = . AN13, Pin.Type = I. AN13, Buffer.Type = Analog. AN13, Description. = Analog input 13.. P3B (7),",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin Number.PIC18F6X2X = . P3B (7), Pin Number.PIC18F8X2X = . P3B (7), Pin.Type = O. P3B (7), Buffer.Type = -. P3B (7), Description. = ECCP3 output P3B.. RH6/AN14/P1C, Pin Number.PIC18F6X2X = -. RH6/AN14/P1C, Pin Number.PIC18F8X2X = 20. RH6/AN14/P1C, Pin.Type = . RH6/AN14/P1C, Buffer.Type = . RH6/AN14/P1C, Description. = . RH6, Pin Number.PIC18F6X2X = . RH6, Pin Number.PIC18F8X2X = . RH6, Pin.Type = I/O. RH6, Buffer.Type = ST.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRH6, Description. = Digital I/O.. AN14, Pin Number.PIC18F6X2X = . AN14, Pin Number.PIC18F8X2X = . AN14, Pin.Type = I. AN14, Buffer.Type = Analog. AN14, Description. = Analog input 14.. P1C (7), Pin Number.PIC18F6X2X = . P1C (7), Pin Number.PIC18F8X2X = . P1C (7), Pin.Type = O. P1C (7), Buffer.Type = -. P1C (7), Description. = ECCP1 output P1C.. RH7/AN15/P1B, Pin Number.PIC18F6X2X = -. RH7/AN15/P1B, Pin Number.PIC18F8X2X = 19. RH7/AN15/P1B, Pin.Type = .",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRH7/AN15/P1B, Buffer.Type = . RH7/AN15/P1B, Description. = . RH7, Pin Number.PIC18F6X2X = . RH7, Pin Number.PIC18F8X2X = . RH7, Pin.Type = I/O. RH7, Buffer.Type = ST. RH7, Description. = Digital I/O.. AN15, Pin Number.PIC18F6X2X = . AN15, Pin Number.PIC18F8X2X = . AN15, Pin.Type = I. AN15, Buffer.Type = Analog. AN15, Description. = Analog input 15.. P1B (7), Pin Number.PIC18F6X2X = . P1B (7), Pin Number.PIC18F8X2X = . P1B (7), Pin.Type = O. P1B (7), Buffer.Type = -. P1B (7),",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nDescription. = ECCP1 output P1B.\nLegend: TTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nAnalog\n= Analog input\nI = Input\nO\n= Output\nP = Power\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNote 1: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX (CONFIG3H<0>) is not set (all Program Memory modes except Microcontroller).\n2: Default assignment for ECCP2/P2A when CCP2MX is set (all devices).\n3: External memory interface functions are only available on PIC18F8525/8621 devices.\n4: Default assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is set and for all PIC18F6525/6621 devices.\n5: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX is not set (Microcontroller mode).\n6: PORTH and PORTJ (and their multiplexed functions) are only available on PIC18F8525/8621 devices.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n7: Alternate assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is not set.\n8: AVDD must be connected to a positive supply and AVSS must be connected to a ground reference for proper operation of the part in user or ICSP\u2122 modes. See parameter D001 for details.\n9: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRJ0/ALE RJ0 ALE RJ1/OE RJ1 OE RJ2 WRL RJ3, Pin Number.PIC18F6X2X = -. RJ0/ALE RJ0 ALE RJ1/OE RJ1 OE RJ2 WRL RJ3, Pin Number.PIC18F8X2X = 62. RJ0/ALE RJ0 ALE RJ1/OE RJ1 OE RJ2 WRL RJ3, Pin Type. = I/O O I/O. RJ0/ALE RJ0 ALE RJ1/OE RJ1 OE RJ2 WRL RJ3, Buffer Type. = ST TTL ST. RJ0/ALE RJ0 ALE RJ1/OE RJ1 OE RJ2 WRL RJ3, Description. = PORTJ is a bidirectional I/O port (6) . Digital I/O. External memory address latch enable.. , Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F6X2X = -. , Pin Number.PIC18F8X2X = 61. , Pin Type. = O. , Buffer Type. = TTL. , Description. = Digital I/O. External memory output enable.. RJ2/WRL, Pin Number.PIC18F6X2X = -. RJ2/WRL, Pin Number.PIC18F8X2X = 60. RJ2/WRL, Pin Type. = I/O O. RJ2/WRL, Buffer Type. = ST TTL. RJ2/WRL, Description. = Digital I/O. External memory write low control.. RJ3/WRH WRH, Pin Number.PIC18F6X2X = -. RJ3/WRH WRH, Pin Number.PIC18F8X2X = 59. RJ3/WRH WRH, Pin Type. = I/O O. RJ3/WRH WRH, Buffer Type. = ST TTL.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRJ3/WRH WRH, Description. = Digital I/O. External memory write high control.. RJ4/BA0 RJ4 BA0, Pin Number.PIC18F6X2X = -. RJ4/BA0 RJ4 BA0, Pin Number.PIC18F8X2X = 39. RJ4/BA0 RJ4 BA0, Pin Type. = I/O O. RJ4/BA0 RJ4 BA0, Buffer Type. = ST TTL. RJ4/BA0 RJ4 BA0, Description. = Digital I/O. System bus byte address 0 control.. RJ5/CE RJ5 CE, Pin Number.PIC18F6X2X = -. RJ5/CE RJ5 CE, Pin Number.PIC18F8X2X = 40. RJ5/CE RJ5 CE, Pin Type. = I/O O. RJ5/CE RJ5 CE, Buffer Type. = ST TTL.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRJ5/CE RJ5 CE, Description. = Digital I/O External memory access indicator.. RJ6/LB RJ6 LB, Pin Number.PIC18F6X2X = -. RJ6/LB RJ6 LB, Pin Number.PIC18F8X2X = 41. RJ6/LB RJ6 LB, Pin Type. = I/O O. RJ6/LB RJ6 LB, Buffer Type. = ST TTL. RJ6/LB RJ6 LB, Description. = Digital I/O. External memory low byte select.. RJ7/UB RJ7 UB, Pin Number.PIC18F6X2X = -. RJ7/UB RJ7 UB, Pin Number.PIC18F8X2X = 42. RJ7/UB RJ7 UB, Pin Type. = I/O O P. RJ7/UB RJ7 UB, Buffer Type. = ST TTL -.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRJ7/UB RJ7 UB, Description. = Digital I/O. External memory high byte select. Ground reference for logic and I/O pins.. VDD, Pin Number.PIC18F6X2X = 41, 56 10, 26, 38, 57. VDD, Pin Number.PIC18F8X2X = 51, 70 12, 32,. VDD, Pin Type. = P. VDD, Buffer Type. = -. VDD, Description. = Positive supply for logic and I/O pins.. , Pin Number.PIC18F6X2X = . , Pin Number.PIC18F8X2X = 48, 71. , Pin Type. = . , Buffer Type. = . , Description. = . AVSS (8) AVDD (8), Pin Number.PIC18F6X2X = 20 19. AVSS (8) AVDD (8), Pin Number.PIC18F8X2X = 26 25. AVSS (8) AVDD (8), Pin",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nType. = P P. AVSS (8) AVDD (8), Buffer Type. = - -. AVSS (8) AVDD (8), Description. = Ground reference for analog modules. Positive supply for analog modules.\nLegend: TTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nAnalog\n= Analog input\nI\n= Input\nO\n= Output\nP = Power\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNote 1: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX (CONFIG3H<0>) is not set (all Program Memory modes except Microcontroller).\n2: Default assignment for ECCP2/P2A when CCP2MX is set (all devices).\n3: External memory interface functions are only available on PIC18F8525/8621 devices.\n4: Default assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is set and for all PIC18F6525/6621 devices.\n5: Alternate assignment for ECCP2/P2A in PIC18F8525/8621 devices when CCP2MX is not set (Microcontroller mode).\n6: PORTH and PORTJ (and their multiplexed functions) are only available on PIC18F8525/8621 devices.",
    "TABLE 1-2: PIC18F6525/6621/8525/8621 PINOUT I/O DESCRIPTIONS (CONTINUED)\n7: Alternate assignment for P1B/P1C/P3B/P3C for PIC18F8525/8621 devices when ECCPMX (CONFIG3H<1>) is not set.\n8: AVDD must be connected to a positive supply and AVSS must be connected to a ground reference for proper operation of the part in user or ICSP\u2122 modes. See parameter D001 for details.\n9: RG5 is multiplexed with MCLR and is only available when the MCLR Resets are disabled.",
    "2.1 Oscillator Types\nThe  PIC18F6525/6621/8525/8621  devices  can  be operated in twelve different oscillator modes. The user can program four configuration bits (FOSC3, FOSC2, FOSC1  and  FOSC0)  to  select  one  of  these  eight modes:\n1. LP\nLow-Power Crystal\n2. XT\nCrystal/Resonator\n3. HS\nHigh-Speed Crystal/Resonator\n4. RC\nExternal Resistor/Capacitor\n5. EC\nExternal Clock\n6. ECIO\nExternal Clock with I/O pin enabled\n7. HS+PLL\nHigh-Speed Crystal/Resonator with PLL enabled\n8. RCIO\nExternal Resistor/Capacitor with I/O pin enabled\n9.\nECIO+SPLL External Clock with software controlled PLL\n10. ECIO+PLL\nExternal Clock with PLL and I/O pin enabled\n11. HS+SPLL\nHigh-Speed Crystal/Resonator with software control\n12. RCIO\nExternal Resistor/Capacitor with I/O pin enabled",
    "2.2 Crystal Oscillator/Ceramic Resonators\nIn XT, LP, HS, HS+PLL or HS+SPLL Oscillator modes, a crystal or ceramic resonator is connected to the OSC1 and OSC2 pins to establish oscillation. Figure 2-1 shows the pin connections.\nThe  PIC18F6525/6621/8525/8621  oscillator design requires the use of a parallel cut crystal.\nNote:, 1 = Use of a series cut crystal may give a frequency out of the crystal manufacturers specifications.",
    "FIGURE 2-1:\nCRYSTAL/CERAMIC RESONATOR OPERATION (HS, XT OR LP CONFIGURATION)\nNote 1: See Table 2-1 and Table 2-2 for recommended values of C1 and C2.\n2: A series resistor (RS) may be required for AT strip cut crystals.\n3: RF varies with the oscillator mode chosen.",
    "Ranges Tested:\nXT, Freq = 455 kHz 2.0 MHz 4.0 MHz. XT, C1 = 68-100 pF 15-68 pF 15-68 pF. XT, C2 = 68-100 pF 15-68 pF 15-68 pF. HS, Freq = 8.0 MHz 16.0 MHz. HS, C1 = 10-68 pF 10-22 pF. HS, C2 = 10-68 pF 10-22 pF\nThese values are for design guidance only. See notes following this table.\n2 kHz, Resonators Used: = 8 MHz. 4 MHz, Resonators Used: = 16 MHz",
    "Ranges Tested:\nNote 1: Higher capacitance increases the stability of  the  oscillator  but  also  increases  the start-up time.\n2: When operating below 3V VDD, or when using  certain  ceramic  resonators  at  any voltage, it may be necessary to use high gain  HS  mode,  try  a  lower  frequency resonator or switch to a crystal oscillator.\n3: Since each resonator/crystal has its own characteristics, the user should consult the resonator/crystal manufacturer for appropriate  values  of  external  components  or verify oscillator performance.",
    "2.3 RC Oscillator\nLP, Ranges Tested:.Freq = 32.0 kHz. LP, Ranges Tested:.C1 = 33 pF. LP, Ranges Tested:.C2 = 33 pF. XT, Ranges Tested:.Freq = 200 kHz. XT, Ranges Tested:.C1 = 47-68 pF. XT, Ranges Tested:.C2 = 47-68 pF. XT, Ranges Tested:.Freq = 1.0 MHz. XT, Ranges Tested:.C1 = 15 pF. XT, Ranges Tested:.C2 = 15 pF. XT, Ranges Tested:.Freq = 4.0 MHz. XT, Ranges Tested:.C1 = 15 pF. XT, Ranges Tested:.C2 = 15 pF. HS, Ranges Tested:.Freq = 4.0 MHz. HS, Ranges Tested:.C1 = 15 pF. HS, Ranges Tested:.C2 = 15 pF. HS, Ranges Tested:.Freq = 8.0 MHz. HS, Ranges Tested:.C1 = 15-33 pF. HS, Ranges Tested:.C2 = 15-33",
    "2.3 RC Oscillator\npF. HS, Ranges Tested:.Freq = 20.0 MHz. HS, Ranges Tested:.C1 = 15-33 pF. HS, Ranges Tested:.C2 = 15-33 pF. HS, Ranges Tested:.Freq = 25.0 MHz. HS, Ranges Tested:.C1 = 15-33 pF. HS, Ranges Tested:.C2 = 15-33 pF\nThese values are for design guidance only. See notes following this table.",
    "Crystals Used\n200 kHz, 4 MHz = 8 MHz. 1 MHz, 4 MHz = 20 MHz\nNote 1: Higher capacitance increases the stability of  the  oscillator  but  also  increases  the start-up time.\n2: RS (see  Figure 2-1)  may  be  required  in HS mode, as well as XT mode, to avoid overdriving  crystals  with  low  drive  level specification.\n3: Since each resonator/crystal has its own characteristics, the user should consult the resonator/crystal manufacturer for appropriate  values  of  external  components  or verify oscillator performance.\nAn external clock source may also be connected to the OSC1 pin in the HS, XT and LP modes as shown in Figure 2-2.",
    "EXTERNAL CLOCK INPUT OPERATION (HS, XT OR LP OSCILLATOR CONFIGURATION)\nFor timing insensitive applications, the 'RC'  and 'RCIO'  device  options  offer  additional  cost  savings. The RC oscillator frequency is a function of the supply voltage, the resistor (REXT)  and  capacitor  (CEXT) values  and  the  operating  temperature.  In  addition  to this, the oscillator frequency will vary from unit to unit due  to  normal  process  parameter  variation.  Furthermore, the difference in lead frame capacitance between package types will also affect the oscillation frequency,  especially  for  low  CEXT  values.  The  user also  needs  to  take  into  account  variation  due  to tolerance  of  external  R  and  C  components  used. Figure 2-3 shows how the R/C combination is connected.\nIn  the  RC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic.",
    "FIGURE 2-3: RC OSCILLATOR MODE\nThe RCIO Oscillator mode functions like the RC mode except  that  the  OSC2  pin  becomes  an  additional general purpose I/O pin. The I/O pin becomes bit 6 of PORTA (RA6).",
    "2.4 External Clock Input\nThe  EC,  ECIO,  EC+PLL  and  EC+SPLL  Oscillator modes  require  an  external  clock  source  to  be  connected to the OSC1 pin. The feedback device between OSC1 and OSC2 is turned off in these modes to save current. There is a maximum 1.5 \uf06d s start-up required after a Power-on Reset or wake-up from Sleep mode.\nIn  the  EC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic. Figure 2-4 shows the pin connections for the EC Oscillator mode.",
    "FIGURE 2-4: EXTERNAL CLOCK INPUT OPERATION (EC CONFIGURATION)\nThe ECIO Oscillator mode functions like the EC mode except  that  the  OSC2  pin  becomes  an  additional general purpose I/O pin. The I/O pin becomes bit 6 of PORTA (RA6). Figure 2-5 shows the pin connections for the ECIO Oscillator mode.",
    "2.5 Phase Locked Loop (PLL)\nA  Phase  Locked  Loop  circuit  is  provided  as a programmable option for users that want to multiply the frequency of the incoming oscillator signal by 4. For an input clock frequency of 10 MHz, the internal clock frequency will be multiplied to 40 MHz. This is useful for customers who are concerned with EMI due to high-frequency crystals.",
    "2.5 Phase Locked Loop (PLL)\nThe  PLL  can  only  be  enabled  when  the  oscillator configuration  bits  are  programmed  for  High-Speed Oscillator or External Clock mode. If they are programmed  for  any  other  mode,  the  PLL  is  not enabled and the system clock will come directly from OSC1. There are two types of PLL modes: Software Controlled PLL and Configuration Bits Controlled PLL. In Software Controlled PLL mode, PIC18F6525/6621/ 8525/8621 executes at regular clock frequency after all Reset conditions. During execution, the application can enable PLL and switch to 4x clock frequency operation by setting the PLLEN bit in the OSCCON register. In Configuration Bits Controlled PLL, the PLL operation cannot be changed 'on-the-fly'. To enable or disable it, the  controller  must  either  cycle  through  a  Power-on Reset,  or  switch  the  clock  source  from  the  main oscillator to the Timer1 oscillator and back again (see Section 2.6 'Oscillator Switching Feature' for details).",
    "2.5 Phase Locked Loop (PLL)\nThe type of PLL is selected by programming FOSC<3:0>  configuration bits in the CONFIG1H Configuration register. The oscillator mode is specified during device programming.\nA PLL lock timer is used to ensure that the PLL has locked  before  device  execution  starts.  The  PLL  lock timer has a time-out that is called TPLL.",
    "2.6 Oscillator Switching Feature\nThe  PIC18F6525/6621/8525/8621  devices  include  a feature  that  allows  the  system  clock  source  to  be switched from the main oscillator to an alternate low frequency  clock  source.  For  the  PIC18F6525/6621/ 8525/8621 devices, this alternate clock source is the Timer1 oscillator. If a low-frequency crystal (32 kHz, for example) has been attached to the  Timer1 oscillator pins and the Timer1 oscillator has been enabled, the device  can  switch  to  a  low-power  execution  mode.\nFigure 2-7 shows a block diagram of the system clock sources.  The  clock  switching  feature  is  enabled  by programming the Oscillator Switching Enable (OSCSEN) bit in the CONFIG1H Configuration register to a ' 0 '. Clock switching is disabled in an erased device. See Section 12.0 'Timer1 Module' for further details of  the  Timer1  oscillator.  See Section 24.0  'Special Features  of  the  CPU' for Configuration  register details.\nFIGURE 2-7: DEVICE CLOCK SOURCES",
    "2.6.1 SYSTEM CLOCK SWITCH BIT\nNote:\nThe system clock source switching is performed under software control. The system clock switch bits, SCS1:SCS0 (OSCCON<1:0>), control the clock switching. When the SCS0 bit is ' 0 ', the system clock source comes from the main oscillator that is selected by  the  FOSC  configuration  bits  in  the  CONFIG1H Configuration register. When the SCS0 bit is set, the system  clock source will come  from  the Timer1 oscillator. The SCS0 bit is cleared on all forms of Reset.\nThe  Timer1  oscillator  must  be  enabled and operating to switch the system clock source.  The  Timer1  oscillator  is  enabled by setting the T1OSCEN bit in the Timer1 Control  register  (T1CON).  If  the  Timer1 oscillator is not enabled, then any write to the  SCS0  bit  will  be  ignored  (SCS0  bit forced cleared) and the main oscillator will continue to be the system clock source.",
    "2.6.1 SYSTEM CLOCK SWITCH BIT\nWhen the FOSC bits are programmed for Software PLL mode,  the  SCS1  bit  can  be  used  to  select  between primary oscillator/clock and PLL output. The SCS1 bit will only have an effect on the system clock if the PLL is enabled (PLLEN = 1 ) and locked (LOCK = 1 ), else it will be forced cleared. When  programmed with Configuration  Controlled  PLL,  the  SCS1  bit  will  be forced clear.",
    "REGISTER 2-1: OSCCON: OSCILLATOR CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = LOCK. -, 5 = PLLEN (1). -, 6 = SCS1. -, 7 = SCS0 (2)\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3 LOCK: Phase Lock Loop Lock Status bit\n1 = Phase Lock Loop output is stable as system clock\n0 = Phase Lock Loop output is not stable and output cannot be used as system clock\nbit 2 PLLEN: Phase Lock Loop Enable bit (1)\n1 = Enable Phase Lock Loop output as system clock\n0 = Disable Phase Lock Loop",
    "bit 1 SCS1: System Clock Switch bit 1\nWhen PLLEN and LOCK bits are set:\n1 = Use PLL output\n0 = Use primary oscillator/clock input pin\nWhen PLLEN or LOCK bit is cleared:\nBit is forced clear.",
    "bit 0 SCS0: System Clock Switch bit 0 (2)\nWhen OSCSEN configuration bit = 0 and T1OSCEN bit = 1 :\n1 = Switch to Timer1 oscillator/clock pin\n0 = Use primary oscillator/clock input pin\nWhen OSCSEN and T1OSCEN are in other states:\nBit is forced clear.\nNote 1: PLLEN bit is forced set when configured for ECIO+PLL and HS+PLL modes. This bit is writable for ECIO+SPLL and HS+SPLL modes only; forced cleared for all other oscillator modes.\n2: The setting of SCS0 = 1 supersedes SCS1 = 1 .",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "2.6.2 OSCILLATOR TRANSITIONS\nPIC18F6525/6621/8525/8621 devices contain circuitry to prevent 'glitches' when switching between oscillator sources. Essentially, the circuitry waits for eight rising edges of the clock source that the processor is switching to. This ensures that the new clock source is stable and that its pulse width will not be less than the shortest pulse width of the two clock sources.\nA timing diagram indicating the transition from the main oscillator to the Timer1 oscillator is shown in Figure 2-8. The Timer1 oscillator is assumed to be running all the time. After the SCS0 bit is set, the processor is frozen at the next occurring Q1 cycle. After eight synchronization cycles are counted from the Timer1 oscillator, operation resumes.  No  additional  delays  are  required  after  the synchronization cycles.",
    "FIGURE 2-8: TIMING DIAGRAM FOR TRANSITION FROM OSC1 TO TIMER1 OSCILLATOR\nThe sequence of events that takes place when switching from the Timer1 oscillator to the main oscillator will depend on the mode of the main oscillator. In addition to  eight clock cycles of the main oscillator, additional delays may take place.\nIf the  main  oscillator  is  configured  for  an  external crystal (HS, XT, LP), then the transition will take place after an oscillator start-up time (TOST) has occurred. A timing diagram,  indicating the transition from  the Timer1 oscillator to the main oscillator for HS, XT and LP modes, is shown in Figure 2-9.",
    "PIC18F6525/6621/8525/8621\nIf  the  main  oscillator  is  configured  for  HS  mode  with PLL active, an oscillator start-up time (TOST) plus an additional PLL time-out (TPLL) will occur. The PLL timeout is typically 2 ms and allows the PLL to lock to the main oscillator frequency. A timing diagram, indicating the  transition  from  the  Timer1  oscillator  to  the  main oscillator for HS+PLL mode, is shown in Figure 2-10.",
    "FIGURE 2-10: TIMING FOR TRANSITION BETWEEN TIMER1 AND OSC1 (HS WITH PLL ACTIVE, SCS1 = 1 )\nNote: TOST = 1024 TOSC (drawing not to scale).\nIf the main oscillator is configured for EC mode with PLL active, only PLL time-out (TPLL) will occur. The PLL timeout is typically 2 ms and allows the PLL to lock to the main oscillator frequency. A timing diagram, indicating the  transition  from  the  Timer1  oscillator  to  the  main oscillator for EC with PLL active, is shown in Figure 2-11.",
    "PIC18F6525/6621/8525/8621\nIf the main oscillator is configured in the RC, RCIO, EC or ECIO modes, there is no oscillator start-up time-out. Operation  will  resume  after  eight  cycles  of  the  main oscillator have been counted. A timing diagram, indicating the transition from the Timer1 oscillator to the main oscillator for RC, RCIO, EC and ECIO modes, is shown in Figure 2-12.\nFIGURE 2-12:",
    "2.7 Effects of Sleep Mode on the On-Chip Oscillator\nWhen the device executes a SLEEP instruction, the onchip clocks and oscillator are turned off and the device is  held  at  the  beginning  of  an  instruction  cycle  (Q1 state).  With  the  oscillator  off,  the  OSC1  and  OSC2 signals  will  stop  oscillating.  Since  all  the  transistor switching  currents  have  been  removed,  Sleep  mode achieves the lowest current consumption of the device (only leakage currents). Enabling any on-chip feature that will operate during Sleep will increase the current consumed  during  Sleep.  The  user  can  wake  from Sleep through external Reset, Watchdog Timer Reset, or through an interrupt.",
    "2.7 Effects of Sleep Mode on the On-Chip Oscillator\nTABLE 2-3: OSC1 AND OSC2 PIN STATES IN SLEEP MODE\n\nRC, OSC1 Pin = Floating, external resistor should pull high. RC, OSC2 Pin = At logic low. RCIO, OSC1 Pin = Floating, external resistor should pull high. RCIO, OSC2 Pin = Configured as PORTA, bit 6. ECIO, OSC1 Pin = Floating. ECIO, OSC2 Pin = Configured as PORTA, bit 6. EC, OSC1 Pin = Floating. EC, OSC2 Pin = At logic low. LP, XT and HS, OSC1 Pin = Feedback inverter disabled at quiescent voltage level. LP, XT and HS, OSC2 Pin = Feedback inverter disabled at quiescent voltage level\nNote: See Table 3-1 in Section 3.0 'Reset' for time-outs due to Sleep and MCLR Reset.",
    "2.8 Power-up Delays\nPower-up delays are controlled by two timers so that no external Reset circuitry is required for most applications. The delays ensure that the device is kept in Reset until the device power supply and clock are stable. For additional information on Reset operation, see Section 3.0 'Reset' .\nThe first  timer  is  the  Power-up  Timer  (PWRT)  which optionally provides a fixed delay of 72 ms (nominal) on power-up only (POR and BOR). The second timer is the Oscillator Start-up Timer (OST), intended to keep the chip in Reset until the crystal oscillator is stable.",
    "2.8 Power-up Delays\nWith the PLL enabled (HS+PLL and EC+PLL oscillator mode),  the  time-out  sequence  following  a  Power-on Reset  is  different  from  other  oscillator  modes.  The time-out sequence is as follows: First, the PWRT timeout  is  invoked  after  a  POR  time  delay  has  expired. Then, the Oscillator Start-up Timer (OST) is invoked. However, this is still not a sufficient amount of time to allow the PLL to lock at high frequencies. The PWRT timer  is  used  to  provide  an  additional  fixed  2  ms (nominal) time-out to allow the PLL ample time to lock to the incoming clock frequency.",
    "3.0 RESET\nThe PIC18F6525/6621/8525/8621 devices differentiate between various kinds of Reset:\na) Power-on Reset (POR)\nb) MCLR Reset during normal operation\nc) MCLR Reset during Sleep\nd) Watchdog  Timer  (WDT)  Reset  (during  normal operation)\nMost  registers  are  not  affected  by  a  WDT  wake-up since this is viewed as the resumption of normal operation. Status bits from the RCON register, RI, TO, PD, POR and BOR, are set or cleared differently in different Reset situations as indicated in Table 3-2. These bits are  used  in  software  to  determine  the  nature  of  the Reset. See Table 3-3 for a full description of the Reset states of all registers.\ne) Programmable Brown-out Reset (BOR)\nf) RESET Instruction\ng) Stack Full Reset\nh) Stack Underflow Reset\nA simplified block diagram of the On-Chip Reset Circuit is shown in Figure 3-1.\nThe Enhanced MCU devices have a MCLR noise filter in  the  MCLR  Reset  path.  The  filter  will  detect  and ignore small pulses. The MCLR pin is not driven low by any internal Resets, including the WDT.",
    "3.0 RESET\nMost registers are unaffected by a Reset. Their status is unknown  on  POR  and  unchanged  by  all  other Resets.  The  other  registers  are  forced  to  a  'Reset state' on Power-on Reset, MCLR, WDT Reset, Brownout  Reset,  MCLR  Reset  during  Sleep  and  by  the RESET instruction.",
    "FIGURE 3-1: SIMPLIFIED BLOCK DIAGRAM OF ON-CHIP RESET CIRCUIT\nNote 1: This is a separate oscillator from the RC oscillator of the CLKI pin.\n- 2: See Table 3-1 for time-out situations.",
    "3.1 Power-on Reset (POR)\nA  Power-on  Reset  pulse  is  generated  on-chip  when VDD rise is detected. To  take  advantage  of  the  POR circuitry,  tie  the  MCLR  pin  through  a  1 k \uf057 to  10 k \uf057 resistor to VDD. This will eliminate external RC components  usually  needed  to  create  a  Power-on Reset delay. A minimum rise rate for VDD is specified (parameter D004). For a slow rise time, see Figure 3-2.\nWhen the device starts normal operation (i.e., exits the Reset condition), device operating parameters (voltage, frequency, temperature, etc.) must be met to ensure operation. If these conditions are not met, the device  must  be  held  in  Reset  until  the  operating conditions are met.",
    "EXTERNAL POWER-ON RESET CIRCUIT (FOR SLOW VDD POWER-UP)\nNote 1: External Power-on Reset circuit is required only if the VDD power-up slope is too slow. The diode D helps discharge the capacitor quickly when VDD powers down.\n2: R < 40 k \uf057 is recommended to make sure that the voltage drop across R does not violate the device's electrical specification.\n3: R1 = 1 k \uf057 to 10 k \uf057 will limit any current flowing into MCLR from external capacitor C in the event of MCLR/VPP pin breakdown, due to Electrostatic Discharge (ESD) or Electrical Overstress (EOS).",
    "3.2 Power-up Timer (PWRT)\nThe Power-up Timer provides a fixed nominal time-out (parameter 33) only on power-up from the POR. The Power-up Timer operates on an internal RC oscillator. The chip is kept in Reset as long as the PWRT is active. The  PWRT's  time  delay  allows  VDD  to  rise  to  an acceptable  level.  A  configuration  bit  is  provided  to enable/disable the PWRT.\nThe power-up time delay will vary from chip-to-chip due to  VDD,  temperature  and  process  variation.  See  DC parameter 33 for details.",
    "3.3 Oscillator Start-up Timer (OST)\nThe Oscillator Start-up Timer (OST) provides a 1024 oscillator  cycle  (from  OSC1  input)  delays  after  the PWRT delay is over (parameter 32). This ensures that the  crystal  oscillator  or  resonator  has  started  and stabilized.\nThe OST time-out is invoked only for XT, LP and HS modes and only on Power-on Reset, or wake-up from Sleep.",
    "3.4 PLL Lock Time-out\nWith the PLL enabled, the time-out sequence following a  Power-on  Reset  is  different  from  other  oscillator modes. A portion of the Power-up Timer is used to provide a fixed time-out that is sufficient for the PLL to lock to the main oscillator frequency. This PLL lock time-out (TPLL)  is typically 2 ms  and  follows  the  oscillator start-up time-out.",
    "3.5 Brown-out Reset (BOR)\nA configuration bit, BOR, can disable (if clear/ programmed) or enable (if  set)  the  Brown-out  Reset circuitry. If VDD falls below parameter D005 for greater than  parameter  35,  the  brown-out  situation  will  reset the  chip.  A  Reset  may  not  occur  if  VDD  falls  below parameter D005 for less than parameter 35. The chip will remain in Brown-out Reset until VDD rises above BVDD.  If  the  Power-up  Timer  is  enabled,  it  will  be invoked after VDD rises above BVDD; it then will keep the chip in Reset for an additional time delay (parameter  33).  If  VDD  drops  below  BVDD  while  the Power-up Timer is running, the chip will go back into a Brown-out  Reset  and  the  Power-up  Timer  will  be initialized. Once VDD rises above BVDD, the Power-up Timer will execute the additional time delay.",
    "3.6 Time-out Sequence\nOn  power-up,  the  time-out  sequence  is  as  follows: First,  PWRT  time-out  is  invoked  after  the  POR  time delay has expired. Then, OST is activated. The total time-out will vary based on oscillator configuration and the status of the PWRT. For example, in RC mode with the  PWRT  disabled,  there  will  be  no  time-out  at  all. Figure 3-3, Figure 3-4, Figure 3-5, Figure 3-6 and Figure 3-7 depict time-out sequences on power-up.\nSince  the  time-outs  occur  from  the  POR  pulse,  the time-outs will expire if MCLR is kept low long enough. Bringing MCLR high will begin execution immediately (Figure 3-5). This is useful for testing purposes or to synchronize  more  than  one  PIC18F6525/6621/8525/ 8621 device operating in parallel.\nTable 3-2 shows the Reset conditions for some Special Function Registers, while Table 3-3 shows the Reset conditions for all of the registers.",
    "TABLE 3-1: TIME-OUT IN VARIOUS SITUATIONS\nHS with PLL enabled (1), Power-up (2).PWRTE = 0 = 72 ms + 1024 T OSC + 2 ms. HS with PLL enabled (1), Power-up (2).PWRTE = 1 = 1024 T OSC + 2 ms. HS with PLL enabled (1), Brown-out.Brown-out = 72 ms (2) + 1024 T OSC + 2 ms. HS with PLL enabled (1), Wake-up from Sleep or Oscillator Switch.Wake-up from Sleep or Oscillator Switch = 1024 T OSC + 2 ms. HS, XT, LP, Power-up (2).PWRTE = 0 = 72 ms + 1024 T OSC. HS, XT, LP, Power-up (2).PWRTE = 1 = 1024 T OSC. HS, XT, LP, Brown-out.Brown-out = 72 ms (2) + 1024 T OSC. HS, XT, LP, Wake-up from Sleep or Oscillator Switch.Wake-up from Sleep",
    "TABLE 3-1: TIME-OUT IN VARIOUS SITUATIONS\nor Oscillator Switch = 1024 T OSC. EC, Power-up (2).PWRTE = 0 = 72 ms. EC, Power-up (2).PWRTE = 1 = 1.5 \uf06d s. EC, Brown-out.Brown-out = 72 ms (2). EC, Wake-up from Sleep or Oscillator Switch.Wake-up from Sleep or Oscillator Switch = 1.5 \uf06d s (3). External RC, Power-up (2).PWRTE = 0 = 72 ms. External RC, Power-up (2).PWRTE = 1 = -. External RC, Brown-out.Brown-out = 72 ms (2). External RC, Wake-up from Sleep or Oscillator Switch.Wake-up from Sleep or Oscillator Switch = -\nNote 1: 2 ms is the nominal time required for the 4x PLL to lock.\n2: 72 ms is the nominal power-up timer delay, if implemented.\n3: 1.5 \uf06d s is the recovery time from Sleep. There is no recovery time from oscillator switch.",
    "REGISTER 3-1: RCON REGISTER BITS AND POSITIONS (1)\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R/W-1. R/W-0, 5 = R/W-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0\nNote 1: Refer to Section 4.14 'RCON Register' for bit definitions.",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nPower-on Reset, Program Counter = 0000h. Power-on Reset, RI = 1. Power-on Reset, TO = 1. Power-on Reset, PD = 1. Power-on Reset, POR = 0. Power-on Reset, BOR = 0. Power-on Reset, STKFUL = u. Power-on Reset, STKUNF = u. MCLR Reset during normal operation, Program Counter = 0000h. MCLR Reset during normal operation, RI = u. MCLR Reset during normal operation, TO = u. MCLR Reset during normal operation, PD = u. MCLR Reset during normal operation, POR = u. MCLR Reset during normal operation, BOR = u. MCLR Reset during normal operation, STKFUL = u. MCLR Reset during normal operation, STKUNF = u. Software Reset during normal operation, Program Counter = 0000h. Software Reset during normal operation, RI = 0. Software Reset during normal operation, TO = u. Software Reset during normal operation, PD = u. Software Reset during normal operation, POR = u. Software Reset during normal operation,",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nBOR = u. Software Reset during normal operation, STKFUL = u. Software Reset during normal operation, STKUNF = u. Stack Full Reset during normal operation, Program Counter = 0000h. Stack Full Reset during normal operation, RI = u. Stack Full Reset during normal operation, TO = u. Stack Full Reset during normal operation, PD = u. Stack Full Reset during normal operation, POR = u. Stack Full Reset during normal operation, BOR = u. Stack Full Reset during normal operation, STKFUL = u. Stack Full Reset during normal operation, STKUNF = 1. Stack Underflow Reset during normal operation, Program Counter = 0000h. Stack Underflow Reset during normal operation, RI = u. Stack Underflow Reset during normal operation, TO = u. Stack Underflow Reset during normal operation, PD = u. Stack Underflow Reset during normal operation, POR = u. Stack Underflow Reset during normal operation, BOR = u. Stack Underflow Reset during normal operation, STKFUL = 1. Stack Underflow Reset during normal operation, STKUNF = u. MCLR Reset during",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nSleep, Program Counter = 0000h. MCLR Reset during Sleep, RI = u. MCLR Reset during Sleep, TO = 1. MCLR Reset during Sleep, PD = 0. MCLR Reset during Sleep, POR = u. MCLR Reset during Sleep, BOR = u. MCLR Reset during Sleep, STKFUL = u. MCLR Reset during Sleep, STKUNF = u. WDT Reset, Program Counter = 0000h. WDT Reset, RI = 1. WDT Reset, TO = 0. WDT Reset, PD = 1. WDT Reset, POR = u. WDT Reset, BOR = u. WDT Reset, STKFUL = u. WDT Reset, STKUNF = u. WDT Wake-up, Program Counter = PC + 2. WDT Wake-up, RI = u. WDT Wake-up, TO = 0. WDT Wake-up, PD = 0. WDT Wake-up, POR = u. WDT Wake-up, BOR = u. WDT Wake-up, STKFUL = u. WDT",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nWake-up, STKUNF = u. Brown-out Reset, Program Counter = 0000h. Brown-out Reset, RI = 1. Brown-out Reset, TO = 1. Brown-out Reset, PD = 1. Brown-out Reset, POR = 1. Brown-out Reset, BOR = 0. Brown-out Reset, STKFUL = u. Brown-out Reset, STKUNF = u. Interrupt Wake-up from Sleep, Program Counter = PC + 2 (1). Interrupt Wake-up from Sleep, RI = u. Interrupt Wake-up from Sleep, TO = 1. Interrupt Wake-up from Sleep, PD = 0. Interrupt Wake-up from Sleep, POR = u. Interrupt Wake-up from Sleep, BOR = u. Interrupt Wake-up from Sleep, STKFUL = u. Interrupt Wake-up from Sleep, STKUNF = u\nLegend:\nu\n= unchanged,\nx\n= unknown",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nNote 1: When the wake-up is due to an interrupt and the GIEH or GIEL bits are set, the PC is loaded with the interrupt vector (0008h or 0018h).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTOSU, Applicable Devices = Feature1. TOSU, Applicable Devices = Feature2. TOSU, Power-on Reset, Brown-out Reset = ---0 0000. TOSU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. TOSU, Wake-up via WDT or Interrupt = ---0 uuuu (3). TOSH, Applicable Devices = Feature1. TOSH, Applicable Devices = Feature2. TOSH, Power-on Reset, Brown-out Reset = 0000 0000. TOSH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSH, Wake-up via WDT or Interrupt = uuuu uuuu (3). TOSL, Applicable Devices = Feature1. TOSL, Applicable Devices = Feature2. TOSL, Power-on Reset, Brown-out Reset = 0000 0000. TOSL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSL, Wake-up via WDT or Interrupt = uuuu uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n(3). STKPTR, Applicable Devices = Feature1. STKPTR, Applicable Devices = Feature2. STKPTR, Power-on Reset, Brown-out Reset = 00-0 0000. STKPTR, MCLR Resets WDT Reset RESET Instruction Stack Resets = uu-0 0000. STKPTR, Wake-up via WDT or Interrupt = uu-u uuuu (3). PCLATU, Applicable Devices = Feature1. PCLATU, Applicable Devices = Feature2. PCLATU, Power-on Reset, Brown-out Reset = ---0 0000. PCLATU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. PCLATU, Wake-up via WDT or Interrupt = ---u uuuu. PCLATH, Applicable Devices = Feature1. PCLATH, Applicable Devices = Feature2. PCLATH, Power-on Reset, Brown-out Reset = 0000 0000. PCLATH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n0000. PCLATH, Wake-up via WDT or Interrupt = uuuu uuuu. PCL, Applicable Devices = Feature1. PCL, Applicable Devices = Feature2. PCL, Power-on Reset, Brown-out Reset = 0000 0000. PCL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCL, Wake-up via WDT or Interrupt = PC + 2 (2). TBLPTRU, Applicable Devices = Feature1. TBLPTRU, Applicable Devices = Feature2. TBLPTRU, Power-on Reset, Brown-out Reset = --00 0000. TBLPTRU, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. TBLPTRU, Wake-up via WDT or Interrupt = --uu uuuu. TBLPTRH, Applicable Devices = Feature1. TBLPTRH, Applicable Devices = Feature2. TBLPTRH, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRH, MCLR Resets WDT Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nRESET Instruction Stack Resets = 0000 0000. TBLPTRH, Wake-up via WDT or Interrupt = uuuu uuuu. TBLPTRL, Applicable Devices = Feature1. TBLPTRL, Applicable Devices = Feature2. TBLPTRL, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRL, Wake-up via WDT or Interrupt = uuuu uuuu. TABLAT, Applicable Devices = Feature1. TABLAT, Applicable Devices = Feature2. TABLAT, Power-on Reset, Brown-out Reset = 0000 0000. TABLAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TABLAT, Wake-up via WDT or Interrupt = uuuu uuuu. PRODH, Applicable Devices = Feature1. PRODH, Applicable Devices = Feature2. PRODH, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODH, MCLR Resets WDT",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nReset RESET Instruction Stack Resets = uuuu uuuu. PRODH, Wake-up via WDT or Interrupt = uuuu uuuu. PRODL, Applicable Devices = Feature1. PRODL, Applicable Devices = Feature2. PRODL, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODL, Wake-up via WDT or Interrupt = uuuu uuuu. INTCON, Applicable Devices = Feature1. INTCON, Applicable Devices = Feature2. INTCON, Power-on Reset, Brown-out Reset = 0000 000x. INTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000u. INTCON, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON2, Applicable Devices = Feature1. INTCON2, Applicable Devices = Feature2. INTCON2, Power-on Reset, Brown-out Reset = 1111 1111. INTCON2, MCLR",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nResets WDT Reset RESET Instruction Stack Resets = 1111 1111. INTCON2, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON3, Applicable Devices = Feature1. INTCON3, Applicable Devices = Feature2. INTCON3, Power-on Reset, Brown-out Reset = 1100 0000. INTCON3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1100 0000. INTCON3, Wake-up via WDT or Interrupt = uuuu uuuu (1). INDF0, Applicable Devices = Feature1. INDF0, Applicable Devices = Feature2. INDF0, Power-on Reset, Brown-out Reset = N/A. INDF0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF0, Wake-up via WDT or Interrupt = N/A. POSTINC0, Applicable Devices = Feature1. POSTINC0, Applicable Devices = Feature2. POSTINC0, Power-on Reset, Brown-out Reset = N/A.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPOSTINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC0, Wake-up via WDT or Interrupt = N/A. POSTDEC0, Applicable Devices = Feature1. POSTDEC0, Applicable Devices = Feature2. POSTDEC0, Power-on Reset, Brown-out Reset = N/A. POSTDEC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC0, Wake-up via WDT or Interrupt = N/A. PREINC0, Applicable Devices = Feature1. PREINC0, Applicable Devices = Feature2. PREINC0, Power-on Reset, Brown-out Reset = N/A. PREINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC0, Wake-up via WDT or Interrupt = N/A. PLUSW0, Applicable Devices = Feature1. PLUSW0, Applicable Devices = Feature2. PLUSW0, Power-on Reset, Brown-out Reset = N/A. PLUSW0,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nMCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW0, Wake-up via WDT or Interrupt = N/A. FSR0H, Applicable Devices = Feature1. FSR0H, Applicable Devices = Feature2. FSR0H, Power-on Reset, Brown-out Reset = ---- 0000. FSR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. FSR0H, Wake-up via WDT or Interrupt = ---- uuuu. FSR0L, Applicable Devices = Feature1. FSR0L, Applicable Devices = Feature2. FSR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR0L, Wake-up via WDT or Interrupt = uuuu uuuu. WREG, Applicable Devices = Feature1. WREG, Applicable Devices = Feature2. WREG, Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nBrown-out Reset = xxxx xxxx. WREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. WREG, Wake-up via WDT or Interrupt = uuuu uuuu. INDF1, Applicable Devices = Feature1. INDF1, Applicable Devices = Feature2. INDF1, Power-on Reset, Brown-out Reset = N/A. INDF1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF1, Wake-up via WDT or Interrupt = N/A. POSTINC1, Applicable Devices = Feature1. POSTINC1, Applicable Devices = Feature2. POSTINC1, Power-on Reset, Brown-out Reset = N/A. POSTINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC1, Wake-up via WDT or Interrupt = N/A. POSTDEC1, Applicable Devices = Feature1. POSTDEC1, Applicable Devices = Feature2. POSTDEC1, Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nBrown-out Reset = N/A. POSTDEC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC1, Wake-up via WDT or Interrupt = N/A. PREINC1, Applicable Devices = Feature1. PREINC1, Applicable Devices = Feature2. PREINC1, Power-on Reset, Brown-out Reset = N/A. PREINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC1, Wake-up via WDT or Interrupt = N/A. PLUSW1, Applicable Devices = Feature1. PLUSW1, Applicable Devices = Feature2. PLUSW1, Power-on Reset, Brown-out Reset = N/A. PLUSW1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW1, Wake-up via WDT or Interrupt = N/A. FSR1H, Applicable Devices = Feature1. FSR1H, Applicable Devices = Feature2. FSR1H, Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n---- 0000. FSR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. FSR1H, Wake-up via WDT or Interrupt = ---- uuuu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition.\nShaded cells indicate conditions do not apply for the designated device.\nNote",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read ' 0 '.\n7: If MCLR function is disabled, PORTG<5> is a read-only bit.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n8: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.\n9: The MEMCON register is unimplemented and reads all ' 0 's when the device is in Microcontroller mode.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFSR1L, Applicable Devices = Feature1. FSR1L, Applicable Devices = Feature2. FSR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR1L, Wake-up via WDT or Interrupt = uuuu uuuu. BSR, Applicable Devices = Feature1. BSR, Applicable Devices = Feature2. BSR, Power-on Reset, Brown-out Reset = ---- 0000. BSR, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. BSR, Wake-up via WDT or Interrupt = ---- uuuu. INDF2, Applicable Devices = Feature1. INDF2, Applicable Devices = Feature2. INDF2, Power-on Reset, Brown-out Reset = N/A. INDF2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF2, Wake-up via",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = N/A. POSTINC2, Applicable Devices = Feature1. POSTINC2, Applicable Devices = Feature2. POSTINC2, Power-on Reset, Brown-out Reset = N/A. POSTINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC2, Wake-up via WDT or Interrupt = N/A. POSTDEC2, Applicable Devices = Feature1. POSTDEC2, Applicable Devices = Feature2. POSTDEC2, Power-on Reset, Brown-out Reset = N/A. POSTDEC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC2, Wake-up via WDT or Interrupt = N/A. PREINC2, Applicable Devices = Feature1. PREINC2, Applicable Devices = Feature2. PREINC2, Power-on Reset, Brown-out Reset = N/A. PREINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC2, Wake-up",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nvia WDT or Interrupt = N/A. PLUSW2, Applicable Devices = Feature1. PLUSW2, Applicable Devices = Feature2. PLUSW2, Power-on Reset, Brown-out Reset = N/A. PLUSW2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW2, Wake-up via WDT or Interrupt = N/A. FSR2H, Applicable Devices = Feature1. FSR2H, Applicable Devices = Feature2. FSR2H, Power-on Reset, Brown-out Reset = ---- 0000. FSR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. FSR2H, Wake-up via WDT or Interrupt = ---- uuuu. FSR2L, Applicable Devices = Feature1. FSR2L, Applicable Devices = Feature2. FSR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. FSR2L, Wake-up via WDT or Interrupt = uuuu uuuu. STATUS, Applicable Devices = Feature1. STATUS, Applicable Devices = Feature2. STATUS, Power-on Reset, Brown-out Reset = ---x xxxx. STATUS, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---u uuuu. STATUS, Wake-up via WDT or Interrupt = ---u uuuu. TMR0H, Applicable Devices = Feature1. TMR0H, Applicable Devices = Feature2. TMR0H, Power-on Reset, Brown-out Reset = 0000 0000. TMR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR0L, Applicable Devices = Feature1. TMR0L, Applicable Devices = Feature2. TMR0L, Power-on Reset, Brown-out",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset = xxxx xxxx. TMR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0L, Wake-up via WDT or Interrupt = uuuu uuuu. T0CON, Applicable Devices = Feature1. T0CON, Applicable Devices = Feature2. T0CON, Power-on Reset, Brown-out Reset = 1111 1111. T0CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. T0CON, Wake-up via WDT or Interrupt = uuuu uuuu. OSCCON, Applicable Devices = Feature1. OSCCON, Applicable Devices = Feature2. OSCCON, Power-on Reset, Brown-out Reset = ---- 0000. OSCCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. OSCCON, Wake-up via WDT or Interrupt = ---- uuuu. LVDCON, Applicable Devices = Feature1.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLVDCON, Applicable Devices = Feature2. LVDCON, Power-on Reset, Brown-out Reset = --00 0101. LVDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0101. LVDCON, Wake-up via WDT or Interrupt = --uu uuuu. WDTCON, Applicable Devices = Feature1. WDTCON, Applicable Devices = Feature2. WDTCON, Power-on Reset, Brown-out Reset = ---- ---0. WDTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- ---0. WDTCON, Wake-up via WDT or Interrupt = ---- ---u. RCON (4), Applicable Devices = Feature1. RCON (4), Applicable Devices = Feature2. RCON (4), Power-on Reset, Brown-out Reset = 0--1 11qq. RCON (4), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0--1 qquu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRCON (4), Wake-up via WDT or Interrupt = u--1 qquu. TMR1H, Applicable Devices = Feature1. TMR1H, Applicable Devices = Feature2. TMR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR1L, Applicable Devices = Feature1. TMR1L, Applicable Devices = Feature2. TMR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1L, Wake-up via WDT or Interrupt = uuuu uuuu. T1CON, Applicable Devices = Feature1. T1CON, Applicable Devices = Feature2. T1CON,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = 0-00 0000. T1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = u-uu uuuu. T1CON, Wake-up via WDT or Interrupt = u-uu uuuu. TMR2, Applicable Devices = Feature1. TMR2, Applicable Devices = Feature2. TMR2, Power-on Reset, Brown-out Reset = 0000 0000. TMR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TMR2, Wake-up via WDT or Interrupt = uuuu uuuu. PR2, Applicable Devices = Feature1. PR2, Applicable Devices = Feature2. PR2, Power-on Reset, Brown-out Reset = 1111 1111. PR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. PR2, Wake-up via WDT or Interrupt = uuuu uuuu. T2CON, Applicable Devices = Feature1.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nT2CON, Applicable Devices = Feature2. T2CON, Power-on Reset, Brown-out Reset = -000 0000. T2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. T2CON, Wake-up via WDT or Interrupt = -uuu uuuu. SSPBUF, Applicable Devices = Feature1. SSPBUF, Applicable Devices = Feature2. SSPBUF, Power-on Reset, Brown-out Reset = xxxx xxxx. SSPBUF, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. SSPBUF, Wake-up via WDT or Interrupt = uuuu uuuu. SSPADD, Applicable Devices = Feature1. SSPADD, Applicable Devices = Feature2. SSPADD, Power-on Reset, Brown-out Reset = 0000 0000. SSPADD, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPADD, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. SSPSTAT, Applicable Devices = Feature1. SSPSTAT, Applicable Devices = Feature2. SSPSTAT, Power-on Reset, Brown-out Reset = 0000 0000. SSPSTAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPSTAT, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON1, Applicable Devices = Feature1. SSPCON1, Applicable Devices = Feature2. SSPCON1, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON1, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON2, Applicable Devices = Feature1. SSPCON2, Applicable Devices = Feature2. SSPCON2, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000. SSPCON2, Wake-up via WDT or Interrupt = uuuu uuuu. , Applicable Devices = Feature1. , Applicable Devices = Feature2. , Power-on Reset, Brown-out Reset = xxxx. , MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. , Wake-up via WDT or Interrupt = uuuu uuuu. ADRESL, Applicable Devices = . ADRESL, Applicable Devices = . ADRESL, Power-on Reset, Brown-out Reset = xxxx. ADRESL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. ADRESL, Wake-up via WDT or Interrupt = \nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nShaded cells indicate conditions do not apply for the designated device.\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: If MCLR function is disabled, PORTG<5> is a read-only bit.\n8: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.\n9: The MEMCON register is unimplemented and reads all ' 0 's when the device is in Microcontroller mode.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADCON0, Applicable Devices = Feature1. ADCON0, Applicable Devices = Feature2. ADCON0, Power-on Reset, Brown-out Reset = --00 0000. ADCON0, WDT RESET Instruction = --00. ADCON0, Reset Wake-up via WDT or Interrupt = 0000 --uu. ADCON0, Reset Wake-up via WDT or Interrupt = uuuu. ADCON1, Applicable Devices = Feature1. ADCON1, Applicable Devices = Feature2. ADCON1, Power-on Reset, Brown-out Reset = --00 0000. ADCON1, WDT RESET Instruction = --00. ADCON1, Reset Wake-up via WDT or Interrupt = 0000. ADCON1, Reset Wake-up via WDT or Interrupt = --uu uuuu. ADCON2, Applicable Devices = Feature1. ADCON2, Applicable Devices = Feature2. ADCON2, Power-on Reset, Brown-out Reset = 0-00 0000. ADCON2, WDT RESET Instruction = 0-00.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADCON2, Reset Wake-up via WDT or Interrupt = 0000. ADCON2, Reset Wake-up via WDT or Interrupt = u-uu uuuu. CCPR1H, Applicable Devices = Feature1. CCPR1H, Applicable Devices = Feature2. CCPR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1H, WDT RESET Instruction = uuuu. CCPR1H, Reset Wake-up via WDT or Interrupt = uuuu. CCPR1H, Reset Wake-up via WDT or Interrupt = uuuu uuuu. CCPR1L, Applicable Devices = Feature1. CCPR1L, Applicable Devices = Feature2. CCPR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1L, WDT RESET Instruction = uuuu. CCPR1L, Reset Wake-up via WDT or Interrupt = uuuu. CCPR1L, Reset Wake-up via WDT or Interrupt = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCCP1CON, Applicable Devices = Feature1. CCP1CON, Applicable Devices = Feature2. CCP1CON, Power-on Reset, Brown-out Reset = 0000 0000. CCP1CON, WDT RESET Instruction = 0000. CCP1CON, Reset Wake-up via WDT or Interrupt = 0000. CCP1CON, Reset Wake-up via WDT or Interrupt = uuuu uuuu. CCPR2H, Applicable Devices = Feature1. CCPR2H, Applicable Devices = Feature2. CCPR2H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR2H, WDT RESET Instruction = uuuu. CCPR2H, Reset Wake-up via WDT or Interrupt = uuuu. CCPR2H, Reset Wake-up via WDT or Interrupt = uuuu uuuu. CCPR2L, Applicable Devices = Feature1. CCPR2L, Applicable Devices = Feature2. CCPR2L, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCCPR2L, WDT RESET Instruction = uuuu. CCPR2L, Reset Wake-up via WDT or Interrupt = uuuu. CCPR2L, Reset Wake-up via WDT or Interrupt = uuuu uuuu. CCP2CON, Applicable Devices = Feature1. CCP2CON, Applicable Devices = Feature2. CCP2CON, Power-on Reset, Brown-out Reset = --00 0000. CCP2CON, WDT RESET Instruction = --00. CCP2CON, Reset Wake-up via WDT or Interrupt = 0000. CCP2CON, Reset Wake-up via WDT or Interrupt = --uu uuuu. CCPR3H, Applicable Devices = Feature1. CCPR3H, Applicable Devices = Feature2. CCPR3H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR3H, WDT RESET Instruction = uuuu. CCPR3H, Reset Wake-up via WDT or Interrupt = uuuu. CCPR3H, Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu uuuu. CCPR3L, Applicable Devices = Feature1. CCPR3L, Applicable Devices = Feature2. CCPR3L, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR3L, WDT RESET Instruction = uuuu. CCPR3L, Reset Wake-up via WDT or Interrupt = uuuu. CCPR3L, Reset Wake-up via WDT or Interrupt = uuuu uuuu. CCP3CON, Applicable Devices = Feature1. CCP3CON, Applicable Devices = Feature2. CCP3CON, Power-on Reset, Brown-out Reset = 0000 0000. CCP3CON, WDT RESET Instruction = 0000. CCP3CON, Reset Wake-up via WDT or Interrupt = 0000. CCP3CON, Reset Wake-up via WDT or Interrupt = uuuu uuuu. ECCP1AS, Applicable Devices = Feature1. ECCP1AS, Applicable Devices = Feature2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nECCP1AS, Power-on Reset, Brown-out Reset = 0000 0000. ECCP1AS, WDT RESET Instruction = 0000. ECCP1AS, Reset Wake-up via WDT or Interrupt = 0000. ECCP1AS, Reset Wake-up via WDT or Interrupt = uuuu uuuu. CVRCON, Applicable Devices = Feature1. CVRCON, Applicable Devices = Feature2. CVRCON, Power-on Reset, Brown-out Reset = 0000 0000. CVRCON, WDT RESET Instruction = 0000. CVRCON, Reset Wake-up via WDT or Interrupt = 0000. CVRCON, Reset Wake-up via WDT or Interrupt = uuuu uuuu. CMCON, Applicable Devices = Feature1. CMCON, Applicable Devices = Feature2. CMCON, Power-on Reset, Brown-out Reset = 0000 0000. CMCON, WDT RESET Instruction = 0000. CMCON, Reset Wake-up via WDT or Interrupt = 0000. CMCON, Reset Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. TMR3H, Applicable Devices = Feature1. TMR3H, Applicable Devices = Feature2. TMR3H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3H, WDT RESET Instruction = uuuu. TMR3H, Reset Wake-up via WDT or Interrupt = uuuu. TMR3H, Reset Wake-up via WDT or Interrupt = uuuu uuuu. TMR3L, Applicable Devices = Feature1. TMR3L, Applicable Devices = Feature2. TMR3L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3L, WDT RESET Instruction = uuuu. TMR3L, Reset Wake-up via WDT or Interrupt = uuuu. TMR3L, Reset Wake-up via WDT or Interrupt = uuuu uuuu. T3CON, Applicable Devices = Feature1. T3CON, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFeature2. T3CON, Power-on Reset, Brown-out Reset = 0000 0000. T3CON, WDT RESET Instruction = uuuu. T3CON, Reset Wake-up via WDT or Interrupt = uuuu. T3CON, Reset Wake-up via WDT or Interrupt = uuuu uuuu. PSPCON (8), Applicable Devices = Feature1. PSPCON (8), Applicable Devices = Feature2. PSPCON (8), Power-on Reset, Brown-out Reset = 0000 ----. PSPCON (8), WDT RESET Instruction = 0000. PSPCON (8), Reset Wake-up via WDT or Interrupt = ----. PSPCON (8), Reset Wake-up via WDT or Interrupt = uuuu ----. SPBRG1, Applicable Devices = Feature1. SPBRG1, Applicable Devices = Feature2. SPBRG1, Power-on Reset, Brown-out Reset = 0000 0000. SPBRG1, WDT RESET Instruction",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 0000. SPBRG1, Reset Wake-up via WDT or Interrupt = 0000. SPBRG1, Reset Wake-up via WDT or Interrupt = uuuu uuuu. RCREG1, Applicable Devices = Feature1. RCREG1, Applicable Devices = Feature2. RCREG1, Power-on Reset, Brown-out Reset = 0000 0000. RCREG1, WDT RESET Instruction = 0000. RCREG1, Reset Wake-up via WDT or Interrupt = 0000. RCREG1, Reset Wake-up via WDT or Interrupt = uuuu uuuu. TXREG1, Applicable Devices = Feature1. TXREG1, Applicable Devices = Feature2. TXREG1, Power-on Reset, Brown-out Reset = 0000 0000. TXREG1, WDT RESET Instruction = 0000. TXREG1, Reset Wake-up via WDT or Interrupt = 0000. TXREG1, Reset Wake-up via WDT or Interrupt = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXSTA1, Applicable Devices = Feature1. TXSTA1, Applicable Devices = Feature2. TXSTA1, Power-on Reset, Brown-out Reset = 0000 0010. TXSTA1, WDT RESET Instruction = 0000. TXSTA1, Reset Wake-up via WDT or Interrupt = 0010. TXSTA1, Reset Wake-up via WDT or Interrupt = uuuu uuuu. RCSTA1, Applicable Devices = Feature1. RCSTA1, Applicable Devices = Feature2. RCSTA1, Power-on Reset, Brown-out Reset = 0000 000x. RCSTA1, WDT RESET Instruction = 0000. RCSTA1, Reset Wake-up via WDT or Interrupt = 000x. RCSTA1, Reset Wake-up via WDT or Interrupt = uuuu uuuu. EEADRH, Applicable Devices = Feature1. EEADRH, Applicable Devices = Feature2. EEADRH, Power-on Reset, Brown-out Reset = ---- --00. EEADRH, WDT RESET Instruction = ----. EEADRH,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset Wake-up via WDT or Interrupt = --00. EEADRH, Reset Wake-up via WDT or Interrupt = ---- --uu. EEADR, Applicable Devices = Feature1. EEADR, Applicable Devices = Feature2. EEADR, Power-on Reset, Brown-out Reset = 0000 0000. EEADR, WDT RESET Instruction = 0000 0000. EEADR, Reset Wake-up via WDT or Interrupt = uuuu. EEADR, Reset Wake-up via WDT or Interrupt = uuuu. EEDATA, Applicable Devices = Feature1. EEDATA, Applicable Devices = Feature2. EEDATA, Power-on Reset, Brown-out Reset = 0000 0000. EEDATA, WDT RESET Instruction = 0000. EEDATA, Reset Wake-up via WDT or Interrupt = 0000. EEDATA, Reset Wake-up via WDT or Interrupt = uuuu uuuu. EECON2, Applicable Devices = Feature1. EECON2, Applicable Devices = Feature2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nEECON2, Power-on Reset, Brown-out Reset = ---- ----. EECON2, WDT RESET Instruction = ----. EECON2, Reset Wake-up via WDT or Interrupt = ----. EECON2, Reset Wake-up via WDT or Interrupt = ---- ----. EECON1, Applicable Devices = Feature1. EECON1, Applicable Devices = Feature2. EECON1, Power-on Reset, Brown-out Reset = xx-0 x000. EECON1, WDT RESET Instruction = uu-0. EECON1, Reset Wake-up via WDT or Interrupt = u000. EECON1, Reset Wake-up via WDT or Interrupt = uu-u u000\nLegend:\nu x -0 q Shaded cells indicate conditions do not apply for the designated device.\n= unchanged, = unknown, = unimplemented bit, read as ' ', = value depends on condition.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: If MCLR function is disabled, PORTG<5> is a read-only bit.\n8: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.\n9: The MEMCON register is unimplemented and reads all ' 0 's when the device is in Microcontroller mode.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nIPR3, Applicable Devices = Feature1. IPR3, Applicable Devices = Feature2. IPR3, Power-on Reset, Brown-out Reset = --11 1111. IPR3, RESET = --11 1111. IPR3, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = --uu. IPR3, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIR3, Applicable Devices = Feature1. PIR3, Applicable Devices = Feature2. PIR3, Power-on Reset, Brown-out Reset = --00 0000. PIR3, RESET = --00 0000. PIR3, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = --uu. PIR3, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIE3, Applicable Devices = Feature1. PIE3, Applicable Devices = Feature2. PIE3,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = --00 0000. PIE3, RESET = --00 0000. PIE3, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = --uu. PIE3, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. IPR2, Applicable Devices = Feature1. IPR2, Applicable Devices = Feature2. IPR2, Power-on Reset, Brown-out Reset = -1-1 1111. IPR2, RESET = -1-1 1111. IPR2, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = -u-u. IPR2, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIR2, Applicable Devices = Feature1. PIR2, Applicable Devices = Feature2. PIR2, Power-on Reset, Brown-out Reset = -0-0 0000. PIR2, RESET =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-0-0 0000. PIR2, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = -u-u. PIR2, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu (1). PIE2, Applicable Devices = Feature1. PIE2, Applicable Devices = Feature2. PIE2, Power-on Reset, Brown-out Reset = -0-0 0000. PIE2, RESET = -0-0 0000. PIE2, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = -u-u. PIE2, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. IPR1, Applicable Devices = Feature1. IPR1, Applicable Devices = Feature2. IPR1, Power-on Reset, Brown-out Reset = 1111 1111. IPR1, RESET = 1111 1111. IPR1, MCLR Resets WDT Reset Instruction Stack Resets Wake-up",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nvia WDT or Interrupt = uuuu. IPR1, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIR1, Applicable Devices = Feature1. PIR1, Applicable Devices = Feature2. PIR1, Power-on Reset, Brown-out Reset = 0000 0000. PIR1, RESET = 0000 0000. PIR1, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIR1, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu (1). PIE1, Applicable Devices = Feature1. PIE1, Applicable Devices = Feature2. PIE1, Power-on Reset, Brown-out Reset = 0000 0000. PIE1, RESET = 0000 0000. PIE1, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIE1, MCLR Resets WDT Reset Instruction Stack Resets Wake-up",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nvia WDT or Interrupt = uuuu. MEMCON (9), Applicable Devices = Feature1. MEMCON (9), Applicable Devices = Feature2. MEMCON (9), Power-on Reset, Brown-out Reset = 0-00 --00. MEMCON (9), RESET = 0-00 --00. MEMCON (9), MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = u-uu. MEMCON (9), MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = --uu. TRISJ, Applicable Devices = Feature1. TRISJ, Applicable Devices = Feature2. TRISJ, Power-on Reset, Brown-out Reset = 1111 1111. TRISJ, RESET = 1111 1111. TRISJ, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISJ, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInterrupt = uuuu. TRISH, Applicable Devices = Feature1. TRISH, Applicable Devices = Feature2. TRISH, Power-on Reset, Brown-out Reset = 1111 1111. TRISH, RESET = 1111 1111. TRISH, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISH, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISG, Applicable Devices = Feature1. TRISG, Applicable Devices = Feature2. TRISG, Power-on Reset, Brown-out Reset = ---1 1111. TRISG, RESET = ---1 1111. TRISG, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = ---u. TRISG, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISF, Applicable Devices = Feature1. TRISF, Applicable Devices = Feature2. TRISF, Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = 1111 1111. TRISF, RESET = 1111 1111. TRISF, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISF, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISE, Applicable Devices = Feature1. TRISE, Applicable Devices = Feature2. TRISE, Power-on Reset, Brown-out Reset = 1111 1111. TRISE, RESET = 1111 1111. TRISE, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISE, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISD, Applicable Devices = Feature1. TRISD, Applicable Devices = Feature2. TRISD, Power-on Reset, Brown-out Reset = 1111 1111. TRISD, RESET = 1111 1111. TRISD, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu. TRISD, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISC, Applicable Devices = Feature1. TRISC, Applicable Devices = Feature2. TRISC, Power-on Reset, Brown-out Reset = 1111 1111. TRISC, RESET = 1111 1111. TRISC, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISC, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISB, Applicable Devices = Feature1. TRISB, Applicable Devices = Feature2. TRISB, Power-on Reset, Brown-out Reset = 1111 1111. TRISB, RESET = 1111 1111. TRISB, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TRISB, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTRISA (5,6), Applicable Devices = Feature1. TRISA (5,6), Applicable Devices = Feature2. TRISA (5,6), Power-on Reset, Brown-out Reset = -111 1111 (5). TRISA (5,6), RESET = -111 1111. TRISA (5,6), MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = -uuu. TRISA (5,6), MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu (5). LATJ, Applicable Devices = Feature1. LATJ, Applicable Devices = Feature2. LATJ, Power-on Reset, Brown-out Reset = xxxx xxxx. LATJ, RESET = uuuu uuuu. LATJ, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATJ, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nor Interrupt = uuuu. LATH, Applicable Devices = Feature1. LATH, Applicable Devices = Feature2. LATH, Power-on Reset, Brown-out Reset = xxxx xxxx. LATH, RESET = uuuu uuuu. LATH, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATH, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATG, Applicable Devices = Feature1. LATG, Applicable Devices = Feature2. LATG, Power-on Reset, Brown-out Reset = ---x xxxx. LATG, RESET = ---u uuuu. LATG, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = ---u. LATG, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATF, Applicable Devices = Feature1. LATF, Applicable Devices",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= Feature2. LATF, Power-on Reset, Brown-out Reset = xxxx xxxx. LATF, RESET = uuuu uuuu. LATF, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATF, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATE, Applicable Devices = Feature1. LATE, Applicable Devices = Feature2. LATE, Power-on Reset, Brown-out Reset = xxxx xxxx. LATE, RESET = uuuu uuuu. LATE, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATE, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATD, Applicable Devices = Feature1. LATD, Applicable Devices = Feature2. LATD, Power-on Reset, Brown-out Reset = xxxx xxxx. LATD, RESET = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. LATD, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATD, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATC, Applicable Devices = Feature1. LATC, Applicable Devices = Feature2. LATC, Power-on Reset, Brown-out Reset = xxxx xxxx. LATC, RESET = uuuu uuuu. LATC, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATC, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATB, Applicable Devices = Feature1. LATB, Applicable Devices = Feature2. LATB, Power-on Reset, Brown-out Reset = xxxx xxxx. LATB, RESET = uuuu uuuu. LATB, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu. LATB, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. LATA (5,6), Applicable Devices = Feature1. LATA (5,6), Applicable Devices = Feature2. LATA (5,6), Power-on Reset, Brown-out Reset = -xxx xxxx (5). LATA (5,6), RESET = -uuu uuuu uuuu. LATA (5,6), MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = -uuu. LATA (5,6), MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu (5) uuuu. PORTH, Applicable Devices = Feature1. PORTH, Applicable Devices = Feature2. PORTH, Power-on Reset, Brown-out Reset = 0000 xxxx. PORTH, RESET = uuuu 0000 uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPORTH, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PORTH, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PORTJ, Applicable Devices = Feature1. PORTJ, Applicable Devices = Feature2. PORTJ, Power-on Reset, Brown-out Reset = xxxx xxxx. PORTJ, RESET = . PORTJ, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PORTJ, MCLR Resets WDT Reset Instruction Stack Resets Wake-up via WDT or Interrupt = ",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLegend: = unchanged, = unknown, = unimplemented bit, read as ' ', = value depends on condition.\nu x -0 q Shaded cells indicate conditions do not apply for the designated device.\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read ' 0 '.\n7: If MCLR function is disabled, PORTG<5> is a read-only bit.\n8: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.\n9: The MEMCON register is unimplemented and reads all ' 0 's when the device is in Microcontroller mode.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPORTG (7), Applicable Devices = Feature1. PORTG (7), Applicable Devices = Feature2. PORTG (7), Power-on Reset, Brown-out Reset = --xx. PORTG (7), Power-on Reset, Brown-out Reset = xxxx. PORTG (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = --uu. PORTG (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTG (7), Wake-up via WDT or Interrupt = --uu. PORTG (7), Wake-up via WDT or Interrupt = uuuu. PORTF, Applicable Devices = Feature1. PORTF, Applicable Devices = Feature2. PORTF, Power-on Reset, Brown-out Reset = x000. PORTF, Power-on Reset, Brown-out Reset = 0000. PORTF, MCLR Resets WDT Reset RESET Instruction Stack Resets = u000. PORTF, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPORTF, Wake-up via WDT or Interrupt = uuuu. PORTF, Wake-up via WDT or Interrupt = uuuu. PORTE, Applicable Devices = Feature1. PORTE, Applicable Devices = Feature2. PORTE, Power-on Reset, Brown-out Reset = xxxx. PORTE, Power-on Reset, Brown-out Reset = xxxx. PORTE, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTE, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTE, Wake-up via WDT or Interrupt = uuuu. PORTE, Wake-up via WDT or Interrupt = uuuu. PORTD, Applicable Devices = Feature1. PORTD, Applicable Devices = Feature2. PORTD, Power-on Reset, Brown-out Reset = xxxx. PORTD, Power-on Reset, Brown-out Reset = xxxx. PORTD, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTD, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. PORTD, Wake-up via WDT or Interrupt = uuuu. PORTD, Wake-up via WDT or Interrupt = uuuu. PORTC, Applicable Devices = Feature1. PORTC, Applicable Devices = Feature2. PORTC, Power-on Reset, Brown-out Reset = xxxx. PORTC, Power-on Reset, Brown-out Reset = xxxx. PORTC, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTC, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTC, Wake-up via WDT or Interrupt = uuuu. PORTC, Wake-up via WDT or Interrupt = uuuu. PORTB, Applicable Devices = Feature1. PORTB, Applicable Devices = Feature2. PORTB, Power-on Reset, Brown-out Reset = xxxx. PORTB, Power-on Reset, Brown-out Reset = xxxx. PORTB, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTB, MCLR",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets WDT Reset RESET Instruction Stack Resets = uuuu. PORTB, Wake-up via WDT or Interrupt = uuuu. PORTB, Wake-up via WDT or Interrupt = uuuu. PORTA (5,6), Applicable Devices = Feature1. PORTA (5,6), Applicable Devices = Feature2. PORTA (5,6), Power-on Reset, Brown-out Reset = -x0x. PORTA (5,6), Power-on Reset, Brown-out Reset = 0000 (5). PORTA (5,6), MCLR Resets WDT Reset RESET Instruction Stack Resets = -u0u. PORTA (5,6), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 (5). PORTA (5,6), Wake-up via WDT or Interrupt = -uuu. PORTA (5,6), Wake-up via WDT or Interrupt = uuuu (5). SPBRGH1, Applicable Devices = Feature1. SPBRGH1, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = Feature2. SPBRGH1, Power-on Reset, Brown-out Reset = 0000. SPBRGH1, Power-on Reset, Brown-out Reset = 0000. SPBRGH1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. SPBRGH1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. SPBRGH1, Wake-up via WDT or Interrupt = uuuu. SPBRGH1, Wake-up via WDT or Interrupt = uuuu. BAUDCON1, Applicable Devices = Feature1. BAUDCON1, Applicable Devices = Feature2. BAUDCON1, Power-on Reset, Brown-out Reset = -1-0. BAUDCON1, Power-on Reset, Brown-out Reset = 0-00. BAUDCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -1-0. BAUDCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0-00. BAUDCON1, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-u-u. BAUDCON1, Wake-up via WDT or Interrupt = u-uu. SPBRGH2, Applicable Devices = Feature1. SPBRGH2, Applicable Devices = Feature2. SPBRGH2, Power-on Reset, Brown-out Reset = 0000. SPBRGH2, Power-on Reset, Brown-out Reset = 0000. SPBRGH2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. SPBRGH2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. SPBRGH2, Wake-up via WDT or Interrupt = uuuu. SPBRGH2, Wake-up via WDT or Interrupt = uuuu. BAUDCON2, Applicable Devices = Feature1. BAUDCON2, Applicable Devices = Feature2. BAUDCON2, Power-on Reset, Brown-out Reset = -1-0. BAUDCON2, Power-on Reset, Brown-out Reset = 0-00. BAUDCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-1-0. BAUDCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0-00. BAUDCON2, Wake-up via WDT or Interrupt = -u-1. BAUDCON2, Wake-up via WDT or Interrupt = u-uu. ECCP1DEL, Applicable Devices = Feature1. ECCP1DEL, Applicable Devices = Feature2. ECCP1DEL, Power-on Reset, Brown-out Reset = 0000. ECCP1DEL, Power-on Reset, Brown-out Reset = 0000. ECCP1DEL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECCP1DEL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECCP1DEL, Wake-up via WDT or Interrupt = uuuu. ECCP1DEL, Wake-up via WDT or Interrupt = uuuu. TMR4, Applicable Devices = Feature1. TMR4, Applicable Devices = Feature2. TMR4, Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000. TMR4, Power-on Reset, Brown-out Reset = 0000. TMR4, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. TMR4, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. TMR4, Wake-up via WDT or Interrupt = uuuu. TMR4, Wake-up via WDT or Interrupt = uuuu. PR4, Applicable Devices = Feature1. PR4, Applicable Devices = Feature2. PR4, Power-on Reset, Brown-out Reset = 1111. PR4, Power-on Reset, Brown-out Reset = 1111. PR4, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111. PR4, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111. PR4, Wake-up via WDT or Interrupt = uuuu. PR4, Wake-up via WDT or Interrupt = uuuu. T4CON, Applicable Devices = Feature1. T4CON, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFeature2. T4CON, Power-on Reset, Brown-out Reset = -000. T4CON, Power-on Reset, Brown-out Reset = 0000. T4CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000. T4CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. T4CON, Wake-up via WDT or Interrupt = -uuu. T4CON, Wake-up via WDT or Interrupt = uuuu. CCPR4H, Applicable Devices = Feature1. CCPR4H, Applicable Devices = Feature2. CCPR4H, Power-on Reset, Brown-out Reset = xxxx. CCPR4H, Power-on Reset, Brown-out Reset = xxxx. CCPR4H, MCLR Resets WDT Reset RESET Instruction Stack Resets = xxxx. CCPR4H, MCLR Resets WDT Reset RESET Instruction Stack Resets = xxxx. CCPR4H, Wake-up via WDT or Interrupt = uuuu. CCPR4H, Wake-up via",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu. CCPR4L, Applicable Devices = Feature1. CCPR4L, Applicable Devices = Feature2. CCPR4L, Power-on Reset, Brown-out Reset = xxxx. CCPR4L, Power-on Reset, Brown-out Reset = xxxx. CCPR4L, MCLR Resets WDT Reset RESET Instruction Stack Resets = xxxx. CCPR4L, MCLR Resets WDT Reset RESET Instruction Stack Resets = xxxx. CCPR4L, Wake-up via WDT or Interrupt = uuuu. CCPR4L, Wake-up via WDT or Interrupt = uuuu. CCP4CON, Applicable Devices = Feature1. CCP4CON, Applicable Devices = Feature2. CCP4CON, Power-on Reset, Brown-out Reset = --00. CCP4CON, Power-on Reset, Brown-out Reset = 0000. CCP4CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00. CCP4CON, MCLR Resets WDT Reset RESET",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInstruction Stack Resets = 0000. CCP4CON, Wake-up via WDT or Interrupt = --uu. CCP4CON, Wake-up via WDT or Interrupt = uuuu. CCPR5H, Applicable Devices = Feature1. CCPR5H, Applicable Devices = Feature2. CCPR5H, Power-on Reset, Brown-out Reset = xxxx. CCPR5H, Power-on Reset, Brown-out Reset = xxxx. CCPR5H, MCLR Resets WDT Reset RESET Instruction Stack Resets = xxxx. CCPR5H, MCLR Resets WDT Reset RESET Instruction Stack Resets = xxxx. CCPR5H, Wake-up via WDT or Interrupt = uuuu. CCPR5H, Wake-up via WDT or Interrupt = uuuu. CCPR5L, Applicable Devices = Feature1. CCPR5L, Applicable Devices = Feature2. CCPR5L, Power-on Reset, Brown-out Reset = xxxx. CCPR5L, Power-on Reset, Brown-out Reset = xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCCPR5L, MCLR Resets WDT Reset RESET Instruction Stack Resets = xxxx. CCPR5L, MCLR Resets WDT Reset RESET Instruction Stack Resets = xxxx. CCPR5L, Wake-up via WDT or Interrupt = uuuu. CCPR5L, Wake-up via WDT or Interrupt = uuuu. CCP5CON, Applicable Devices = Feature1. CCP5CON, Applicable Devices = Feature2. CCP5CON, Power-on Reset, Brown-out Reset = --00. CCP5CON, Power-on Reset, Brown-out Reset = 0000. CCP5CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00. CCP5CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. CCP5CON, Wake-up via WDT or Interrupt = --uu. CCP5CON, Wake-up via WDT or Interrupt = uuuu. SPBRG2, Applicable Devices = Feature1. SPBRG2, Applicable Devices = Feature2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nSPBRG2, Power-on Reset, Brown-out Reset = 0000. SPBRG2, Power-on Reset, Brown-out Reset = 0000. SPBRG2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. SPBRG2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. SPBRG2, Wake-up via WDT or Interrupt = uuuu. SPBRG2, Wake-up via WDT or Interrupt = uuuu. RCREG2, Applicable Devices = Feature1. RCREG2, Applicable Devices = Feature2. RCREG2, Power-on Reset, Brown-out Reset = 0000. RCREG2, Power-on Reset, Brown-out Reset = 0000. RCREG2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. RCREG2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. RCREG2, Wake-up via WDT or Interrupt = uuuu. RCREG2,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu. TXREG2, Applicable Devices = Feature1. TXREG2, Applicable Devices = Feature2. TXREG2, Power-on Reset, Brown-out Reset = 0000. TXREG2, Power-on Reset, Brown-out Reset = 0000. TXREG2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. TXREG2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. TXREG2, Wake-up via WDT or Interrupt = uuuu. TXREG2, Wake-up via WDT or Interrupt = uuuu. TXSTA2, Applicable Devices = Feature1. TXSTA2, Applicable Devices = Feature2. TXSTA2, Power-on Reset, Brown-out Reset = 0000. TXSTA2, Power-on Reset, Brown-out Reset = 0010. TXSTA2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. TXSTA2, MCLR Resets WDT Reset RESET Instruction Stack Resets",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 0010. TXSTA2, Wake-up via WDT or Interrupt = uuuu. TXSTA2, Wake-up via WDT or Interrupt = uuuu. RCSTA2, Applicable Devices = Feature1. RCSTA2, Applicable Devices = Feature2. RCSTA2, Power-on Reset, Brown-out Reset = 0000. RCSTA2, Power-on Reset, Brown-out Reset = 000x. RCSTA2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. RCSTA2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 000x. RCSTA2, Wake-up via WDT or Interrupt = uuuu. RCSTA2, Wake-up via WDT or Interrupt = uuuu. ECCP3AS, Applicable Devices = Feature1. ECCP3AS, Applicable Devices = Feature2. ECCP3AS, Power-on Reset, Brown-out Reset = 0000. ECCP3AS, Power-on Reset, Brown-out Reset = 0000. ECCP3AS, MCLR Resets WDT Reset RESET Instruction",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nStack Resets = 0000. ECCP3AS, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECCP3AS, Wake-up via WDT or Interrupt = uuuu. ECCP3AS, Wake-up via WDT or Interrupt = uuuu. ECCP3DEL, Applicable Devices = Feature1. ECCP3DEL, Applicable Devices = Feature2. ECCP3DEL, Power-on Reset, Brown-out Reset = 0000. ECCP3DEL, Power-on Reset, Brown-out Reset = 0000. ECCP3DEL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECCP3DEL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECCP3DEL, Wake-up via WDT or Interrupt = uuuu. ECCP3DEL, Wake-up via WDT or Interrupt = uuuu. ECCP2AS, Applicable Devices = Feature1. ECCP2AS, Applicable Devices = Feature2. ECCP2AS, Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000. ECCP2AS, Power-on Reset, Brown-out Reset = 0000. ECCP2AS, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECCP2AS, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECCP2AS, Wake-up via WDT or Interrupt = uuuu. ECCP2AS, Wake-up via WDT or Interrupt = uuuu. ECCP2DEL, Applicable Devices = Feature1. ECCP2DEL, Applicable Devices = Feature2. ECCP2DEL, Power-on Reset, Brown-out Reset = 0000. ECCP2DEL, Power-on Reset, Brown-out Reset = 0000. ECCP2DEL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECCP2DEL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECCP2DEL, Wake-up via WDT or Interrupt = uuuu. ECCP2DEL, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition.\nShaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: If MCLR function is disabled, PORTG<5> is a read-only bit.\n8: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.\n9: The MEMCON register is unimplemented and reads all ' 0 's when the device is in Microcontroller mode.",
    "FIGURE 3-3: TIME-OUT SEQUENCE ON POWER-UP (MCLR TIED TO VDD VIA 1 k \uf057 RESISTOR)\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET",
    "TIME-OUT SEQUENCE ON POWER-UP (MCLR NOT TIED TO VDD): CASE 1\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET",
    "FIGURE 3-5: TIME-OUT SEQUENCE ON POWER-UP (MCLR NOT TIED TO VDD): CASE 2\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET\nTPWRT\nTOST",
    "FIGURE 3-7: TIME-OUT SEQUENCE ON POR W/PLL ENABLED (MCLR TIED TO VDD VIA 1 k \uf057\uf020 RESISTOR)\nNote:\nTOST = 1024 clock cycles.\nTPLL \uf0bb 2 ms max. First three stages of the PWRT timer.",
    "4.0 MEMORY ORGANIZATION\nThere are three memory blocks in PIC18F6525/6621/ 8525/8621 devices. They are:",
    "4.1.1 PIC18F6525/6621/8525/8621 PROGRAM MEMORY MODES\n\u00b7 Program Memory\n\u00b7 Data RAM\n\u00b7 Data EEPROM\nData and program memory use separate busses which allow for concurrent access of these blocks. Additional detailed  information  for  Flash  program  memory  and data  EEPROM  is  provided  in Section 5.0  'Flash Program Memory' and Section 7.0 'Data EEPROM Memory' , respectively.\nIn  addition  to  on-chip  Flash,  the  PIC18F8525/8621 devices are also capable of accessing external program  memory  through  an  external  memory  bus. Depending on the selected operating mode (discussed in Section 4.1.1 'PIC18F6525/6621/8525/8621 Program  Memory  Modes' ), the controllers may access  either  internal  or  external  program  memory exclusively,  or  both  internal  and  external  memory  in selected blocks. Additional information on the external memory interface is provided in Section 6.0 'External Memory Interface' .",
    "4.1 Program Memory Organization\nA 21-bit program counter is capable of addressing the 2-Mbyte program memory space. Accessing a location between the physically implemented memory and the 2-Mbyte address will cause a read of all ' 0 's  (a NOP instruction).\nThe PIC18F6525 and PIC18F8525 each have 48 Kbytes of on-chip Flash memory, while the PIC18F6621 and PIC18F8621 have 64 Kbytes of Flash. This means that PIC18FX525 devices can store internally up to 24,576 single-word instructions and PIC18FX621 devices can store up to 32,768 single-word instructions.\nThe Reset vector address is at 0000h and the interrupt vector addresses are at 0008h and 0018h.\nFigure 4-1 shows the program memory  map  for PIC18FX525  devices,  while  Figure 4-2  shows  the program memory map for PIC18FX621 devices.",
    "4.1 Program Memory Organization\nPIC18F8525/8621 devices differ significantly from their PIC18  predecessors  in  their  utilization  of  program memory. In addition to available on-chip Flash program memory,  these  controllers  can  also  address  up  to 2 Mbytes  of  external  program  memory  through  the external  memory  interface.  There  are  four  distinct operating modes available to the controllers:\n\u00b7 Microprocessor (MP)\n\u00b7 Microprocessor with Boot Block (MPBB)\n\u00b7 Extended Microcontroller (EMC)\n\u00b7 Microcontroller (MC)\nThe Program Memory mode is determined by setting the two Least Significant bits of the CONFIG3L Configuration  Byte  register  as  shown  in  Register 4-1 (see Section 24.1 'Configuration Bits' for additional details on the device configuration bits).\nThe Program Memory modes operate as follows:",
    "4.1 Program Memory Organization\n\u00b7 The Microprocessor Mode permits access only to external program memory; the contents of the on-chip Flash memory are ignored. The 21-bit program counter permits access to a 2-Mbyte linear program memory space.\n\u00b7 The Microprocessor with Boot Block Mode accesses on-chip Flash memory from addresses 000000h to 0007FFh. Above this, external program memory is accessed all the way up to the 2-Mbyte limit. Program execution automatically switches between the two memories as required.\n\u00b7 The Microcontroller Mode accesses only on-chip Flash memory. Attempts to read above the physical limit of the on-chip Flash (BFFFh for the PIC18FX525, FFFFh for the PIC18FX621) causes a read of all ' 0 's (a NOP instruction). The Microcontroller mode is also the only operating\nmode available to PIC18F6525/6621 devices.",
    "4.1 Program Memory Organization\n\u00b7 The Extended Microcontroller Mode allows access to both internal and external program memories as a single block. The device can access its entire on-chip Flash memory; above this, the device accesses external program memory up to the 2-Mbyte program space limit. As with Boot Block mode, execution automatically switches between the two memories as required.\nIn all modes, the microcontroller has complete access to data RAM and EEPROM.\nFigure 4-3 compares the memory maps of the different program  memory  modes.  The  differences  between on-chip  and  external  memory  access  limitations  are more fully explained in Table 4-1.",
    "PIC18F6525/6621/8525/8621\nFIGURE 4-1:\nINTERNAL PROGRAM MEMORY MAP AND STACK FOR PIC18FX525\nFIGURE 4-2:\nINTERNAL PROGRAM MEMORY MAP AND STACK FOR PIC18FX621",
    "TABLE 4-1: MEMORY ACCESS FOR PIC18F8525/8621 PROGRAM MEMORY MODES\nMicroprocessor, Internal Program Memory.Execution From = No Access. Microprocessor, Internal Program Memory.Table Read From = No Access. Microprocessor, Internal Program Memory.Table Write To = No Access. Microprocessor, External Program Memory.Execution From = Yes. Microprocessor, External Program Memory.Table Read From = Yes. Microprocessor, External Program Memory.Table Write To = Yes. Microprocessor w/Boot Block, Internal Program Memory.Execution From = Yes. Microprocessor w/Boot Block, Internal Program Memory.Table Read From = Yes. Microprocessor w/Boot Block, Internal Program Memory.Table Write To = Yes. Microprocessor w/Boot Block, External Program Memory.Execution From = Yes. Microprocessor w/Boot Block, External Program Memory.Table Read From = Yes. Microprocessor w/Boot Block, External Program Memory.Table Write To = Yes. Microcontroller, Internal Program Memory.Execution From = Yes. Microcontroller, Internal Program Memory.Table Read From = Yes. Microcontroller,",
    "TABLE 4-1: MEMORY ACCESS FOR PIC18F8525/8621 PROGRAM MEMORY MODES\nInternal Program Memory.Table Write To = Yes. Microcontroller, External Program Memory.Execution From = No Access. Microcontroller, External Program Memory.Table Read From = No Access. Microcontroller, External Program Memory.Table Write To = No Access. Extended Microcontroller, Internal Program Memory.Execution From = Yes. Extended Microcontroller, Internal Program Memory.Table Read From = Yes. Extended Microcontroller, Internal Program Memory.Table Write To = Yes. Extended Microcontroller, External Program Memory.Execution From = Yes. Extended Microcontroller, External Program Memory.Table Read From = Yes. Extended Microcontroller, External Program Memory.Table Write To = Yes",
    "CONFIG3L: CONFIGURATION REGISTER 3 LOW\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = U-0. R/P-1, 6 = R/P-1. R/P-1, 7 = R/P-1. WAIT, 1 = -. WAIT, 2 = -. WAIT, 3 = -. WAIT, 4 = -. WAIT, 5 = -. WAIT, 6 = PM1. WAIT, 7 = PM0\nbit 7\nbit 0\nbit 7\nWAIT: External Bus Data Wait Enable bit\n1 = Wait selections unavailable, device will not wait\n0 = Wait programmed by WAIT1 and WAIT0 bits of MEMCOM register (MEMCOM<5:4>)\nbit 6-2\nUnimplemented: Read as ' 0 '\nbit 1-0\nPM1:PM0: Processor Data Memory Mode Select bits\n- 11 = Microcontroller mode\n01 = Microcontroller with Boot Block mode (1)\n10 = Microprocessor mode (1)",
    "CONFIG3L: CONFIGURATION REGISTER 3 LOW\n- 00 = Extended Microcontroller mode (1)\nNote 1: This mode is available only on PIC18F8525/8621 devices.",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value after erase\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "FIGURE 4-3: MEMORY MAPS FOR PIC18F6525/6621/8525/8621 PROGRAM MEMORY MODES\n, Microprocessor Mode (3) = 000000h External Program Memory. , Microprocessor Mode (3) = On-Chip Program Memory (No access). , Microprocessor with Boot Block Mode (3) = 0007FFh 000000h. , Microprocessor with Boot Block Mode (3) = On-Chip Program Memory. , Microprocessor with Boot Block Mode (3) = 000000h 00FFFFh (2) 00BFFFh (1) 010000h (2) 00C000h (1). , Microcontroller Mode = On-Chip Program Memory. , Microcontroller Mode = 000000h 010000h (2) 00FFFFh (2) 00BFFFh (1) 00C000h (1). , Extended Microcontroller Mode (3) = . , Extended Microcontroller Mode (3) = On-Chip Program Memory. , Microprocessor Mode (3) = 000000h External Program Memory. ,",
    "FIGURE 4-3: MEMORY MAPS FOR PIC18F6525/6621/8525/8621 PROGRAM MEMORY MODES\nMicroprocessor Mode (3) = . , Microprocessor with Boot Block Mode (3) = 000800h. , Microprocessor with Boot Block Mode (3) = . , Microprocessor with Boot Block Mode (3) = . , Microcontroller Mode = Reads ' 0 's. , Microcontroller Mode = . , Extended Microcontroller Mode (3) = External Program Memory. , Extended Microcontroller Mode (3) = . , Microprocessor Mode (3) = . , Microprocessor Mode (3) = On-Chip Flash. , Microprocessor with Boot Block Mode (3) = 1FFFFFh External Memory. , Microprocessor with Boot Block Mode (3) = On-Chip Flash. , Microprocessor with Boot Block Mode (3) = 1FFFFFh. , Microcontroller Mode = On-Chip Flash. , Microcontroller Mode = 1FFFFFh. , Extended Microcontroller Mode (3) = External Memory. , Extended",
    "FIGURE 4-3: MEMORY MAPS FOR PIC18F6525/6621/8525/8621 PROGRAM MEMORY MODES\nMicrocontroller Mode (3) = On-Chip Flash\nNote\n1: PIC18F8525 and PIC18F6525.\n2: PIC18F8621 and PIC18F6621.\n3: This mode is available only on PIC18F8525/8621 devices.",
    "4.2 Return Address Stack\nThe return address stack allows any combination of up to  31  program  calls  and  interrupts  to  occur.  The  PC (Program Counter) is pushed onto the stack when a CALL or RCALL instruction is executed, or an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN RETLW , or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.",
    "4.2.2 RETURN STACK POINTER (STKPTR)\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit Stack Pointer, with the Stack Pointer initialized to 00000b after all Resets. There is no RAM associated with Stack Pointer 00000b . This is only a Reset value. During a CALL type instruction causing a push onto the stack,  the  Stack  Pointer  is  first  incremented  and  the RAM location pointed to by the Stack Pointer is written with  the  contents  of  the  PC.  During  a RETURN type instruction causing a pop from the stack, the contents of the RAM location pointed to by the STKPTR register are transferred to the PC and then the Stack Pointer is decremented.\nThe stack space is not part of either program or data space. The Stack Pointer is readable and writable and the  address  on  the  top  of  the  stack  is  readable  and writable  through  SFR  registers.  Data  can  also  be pushed to, or popped from the stack using the Top-ofStack SFRs. Status bits indicate if the Stack Pointer is at or beyond the 31 levels provided.",
    "4.2.1 TOP-OF-STACK ACCESS\nThe top of the stack is  readable  and writable. Three register  locations,  TOSU, TOSH and TOSL, hold the contents  of  the stack  location pointed  to by  the STKPTR  register.  This  allows  users  to  implement  a software stack if necessary. After a CALL, RCALL or interrupt, the software can read the pushed value by reading the TOSU, TOSH and TOSL registers. These values can be placed on a user defined software stack. At  return  time,  the  software  can  replace  the  TOSU, TOSH and TOSL and do a return.\nThe user must disable the global interrupt enable bits during this time to prevent inadvertent stack operations.",
    "4.2.1 TOP-OF-STACK ACCESS\nThe STKPTR register contains the Stack Pointer value, the STKFUL (Stack Full) status bit and the STKUNF (Stack Underflow) status bits. Register 4-2 shows the STKPTR register. The value of the Stack Pointer can be 0 through 31. The Stack Pointer increments when values  are  pushed  onto  the  stack  and  decrements when values are popped off the stack. At Reset, the Stack Pointer value will be ' 0 '. The user may read and write the Stack Pointer value. This feature can be used by  a real-time operating  system  for return stack maintenance.\nAfter the PC is pushed onto the stack 31 times (without popping any values off the stack), the STKFUL bit is set. The STKFUL bit can only be cleared in software or by a POR.",
    "4.2.1 TOP-OF-STACK ACCESS\nThe action that takes place when the stack becomes full depends  on  the  state  of  the  STVREN  (Stack Overflow  Reset  Enable)  configuration  bit.  Refer  to Section 25.0 'Instruction Set Summary' for a description of the device configuration bits. If STVREN is  set  (default),  the  31st  push will  push the (PC + 2) value onto the stack, set the STKFUL bit and reset the device. The STKFUL bit will remain set and the Stack Pointer will be set to ' 0 '.\nIf STVREN is cleared, the STKFUL bit will be set on the 31st push and the Stack Pointer will increment to 31. Any additional pushes will not overwrite the 31st push and STKPTR will remain at 31.\nWhen  the  stack  has  been  popped  enough  times  to unload the stack, the next pop will return a value of zero to  the  PC  and sets the STKUNF bit, while the Stack Pointer remains at ' 0 '. The STKUNF bit will remain set until cleared in software or a POR occurs.\nNote:",
    "4.2.1 TOP-OF-STACK ACCESS\nReturning a value of zero to the PC on an underflow has the effect of vectoring the program  to  the  Reset  vector,  where  the stack conditions can be verified and appropriate actions can be taken.",
    "STKPTR: STACK POINTER REGISTER\nR/C-0, 1 = R/C-0. R/C-0, 2 = U-0. R/C-0, 3 = R/W-0. R/C-0, 4 = R/W-0. R/C-0, 5 = R/W-0. R/C-0, 6 = R/W-0. R/C-0, 7 = R/W-0. STKFUL (1), 1 = STKUNF (1). STKFUL (1), 2 = -. STKFUL (1), 3 = SP4. STKFUL (1), 4 = SP3. STKFUL (1), 5 = SP2. STKFUL (1), 6 = SP1. STKFUL (1), 7 = SP0\nbit 7\nbit 0\nbit 7 STKFUL: Stack Full Flag bit (1)\n1 = Stack became full or overflowed\n0 = Stack has not become full or overflowed\nbit 6\nSTKUNF: Stack Underflow Flag bit (1)\n1 = Stack underflow occurred",
    "STKPTR: STACK POINTER REGISTER\n0 = Stack underflow did not occur\nbit 5 Unimplemented: Read as ' 0 '\nbit 4-0 SP4:SP0:\nStack Pointer Location bits\nNote 1: Bit 7 and bit 6 can only be cleared in user software or by a POR.\n\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "4.2.4 STACK FULL/UNDERFLOW RESETS\nSince the Top-of-Stack (TOS) is readable and writable, the ability to push values onto the stack and pull values off the stack, without disturbing normal program execution, is a desirable option. To push the current PC value  onto  the  stack,  a PUSH instruction can  be executed.  This  will  increment  the  Stack  Pointer  and load the current PC value onto the stack. TOSU, TOSH and  TOSL  can  then  be  modified  to  place  a  return address on the stack.\nThe ability to pull the TOS value off of the stack and replace  it  with  the  value  that  was  previously  pushed onto the stack, without disturbing normal execution, is achieved  by  using  the POP instruction. The POP instruction discards the current TOS by decrementing the Stack Pointer. The previous value pushed onto the stack then becomes the TOS value.",
    "4.2.4 STACK FULL/UNDERFLOW RESETS\nThese Resets are enabled by programming the STVREN configuration bit.  When  the  STVREN  bit  is disabled,  a  full  or  underflow  condition  will  set  the appropriate STKFUL or STKUNF bit, but not cause a device Reset. When the STVREN bit is enabled, a full or underflow condition will set the appropriate STKFUL or  STKUNF bit and then cause a device Reset. The STKFUL or STKUNF bits are only cleared by the user software or a Power-on Reset.",
    "4.3 Fast Register Stack\nA 'fast interrupt return' option is available for interrupts. A  fast  register  stack  is  provided  for  the  STATUS, WREG and BSR registers and is only one in depth. The stack is not readable or writable and is loaded with the current value of the corresponding register when the processor vectors for  an  interrupt.  The  values in  the registers are then loaded back  into the working registers  if  the FAST  RETURN instruction  is  used  to return from the interrupt.\nA low or high priority interrupt source will push values into  the  stack  registers.  If  both  low  and  high  priority interrupts  are  enabled,  the  stack  registers  cannot  be used reliably for low priority interrupts. If a high priority interrupt occurs while servicing a low priority interrupt, the  stack  register  values  stored  by  the  low  priority interrupt will be overwritten.\nIf  high  priority  interrupts  are  not  disabled  during  low priority interrupts, users must save the key registers in software during a low priority interrupt.\nIf no interrupts are used, the fast register stack can be used to restore the STATUS, WREG and BSR registers at the end of a subroutine call. To use the fast register stack for a subroutine call, a FAST  CALL instruction must be executed.",
    "4.3 Fast Register Stack\nExample 4-1 shows a source code example that uses the fast register stack.",
    "4.4 PCL, PCLATH and PCLATU\nThe Program Counter (PC) specifies the address of the instruction  to  fetch  for  execution.  The  PC  is  21  bits wide. The low byte is called the PCL register; this register is readable and writable. The high byte is called the PCH register. This register contains the PC<15:8> bits and is not directly readable or writable; updates to the  PCH  register  may  be  performed  through  the PCLATH register. The upper byte is called PCU. This register contains the PC<20:16> bits and is not directly readable or writable; updates to the PCU register may be performed through the PCLATU register.\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the LSB of the PCL is fixed to a value of ' 0 '.  The  PC  increments  by  2  to  address  sequential instructions in the program memory.\nThe CALL RCALL , , GOTO and program branch instructions write to the program counter directly. For these instructions, the contents of PCLATH and PCLATU are not transferred to the program counter.",
    "4.4 PCL, PCLATH and PCLATU\nThe contents of PCLATH  and  PCLATU  will be transferred to the program counter by an operation that writes  PCL.  Similarly,  the  upper  two  bytes  of  the program  counter  will  be  transferred  to  PCLATH  and PCLATU by an operation that reads PCL. This is useful for  computed  offsets  to  the  PC  (see Section 4.8.1 'Computed GOTO' ).",
    "4.5 Clocking Scheme/Instruction Cycle\nThe clock  input  (from  OSC1)  is  internally  divided  by four to generate four non-overlapping quadrature clocks,  namely  Q1,  Q2,  Q3  and  Q4.  Internally,  the Program Counter (PC) is incremented every Q1, the instruction  is  fetched  from  the  program  memory  and latched  into  the  Instruction  Register  (IR)  in  Q4.  The instruction is decoded and executed during the following  Q1  through  Q4.  The  clocks  and  instruction execution flow are shown in Figure 4-5.\nCALL, 1 = ;STATUS, WREG, BSR ;SAVED IN FAST REGISTER ;STACK. SUB1 RETURN, 1 = ;RESTORE VALUES SAVED ;IN FAST REGISTER STACK",
    "4.6 Instruction Flow/Pipelining\nAn 'Instruction  Cycle'  consists  of  four  Q  cycles  (Q1, Q2, Q3 and Q4). The instruction fetch and execute are pipelined such that  fetch takes  one  instruction cycle, while  decode  and  execute  take  another  instruction cycle. However, due to the pipelining, each instruction effectively  executes  in  one  cycle.  If  an  instruction causes the  program  counter to  change (e.g., GOTO ), then two cycles are required to complete the instruction (Example 4-2).\nA fetch cycle begins with the Program Counter (PC) incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched into  the  'Instruction  Register'  (IR)  in  cycle  Q1.  This instruction  is  then  decoded  and  executed  during  the Q2, Q3 and Q4 cycles. Data memory is read during Q2 (operand  read)  and  written  during  Q4  (destination write).",
    "EXAMPLE 4-2: INSTRUCTION PIPELINE FLOW\nAll instructions are single-cycle except for any program branches. These take two cycles since the fetch instruction is 'flushed' from the pipeline, while the new instruction is being fetched and then executed.",
    "4.7 Instructions in Program Memory\nThe program memory is addressed in bytes. Instructions are stored as two bytes or four bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSB = 0 ). Figure 4-6 shows an example of how instruction words are stored in the program memory. To maintain alignment with instruction boundaries, the PC increments in steps of 2 and the LSB  will  always  read  ' 0 ' (see Section 4.4  'PCL, PCLATH and PCLATU' ).\nword boundaries, the data contained in the instruction is  a  word  address.  The  word  address  is  written  to PC<20:1> which accesses the desired byte address in program memory. Instruction #2 in  Figure 4-6  shows how the instruction ' GOTO 000006h ' is encoded in the program memory. Program branch instructions, which encode a relative address offset, operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions that the PC will be offset by. Section 25.0 'Instruction Set Summary' provides  further  details  of  the  instruction set.",
    "4.7 Instructions in Program Memory\nThe CALL and GOTO instructions  have  an  absolute program memory address embedded into the instruction.  Since  instructions  are  always  stored  on",
    "FIGURE 4-6: INSTRUCTIONS IN PROGRAM MEMORY\nProgram Memory\nByte Locations\n\uf0ae\uf020\nInstruction 1:\nInstruction 2:\nInstruction 3:\nMOVLW\n055h\nGOTO\nMOVFF\n000006h\n123h, 456h\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address \uf0af. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. EFh, 1 = 03h. EFh, 2 = 00000Ah. F0h, 1 = 00h. F0h, 2 = 00000Ch. C1h, 1 = 23h. C1h, 2 = 00000Eh. F4h, 1 = 56h. F4h, 2 = 000010h. , 1 = . , 2 = 000012h. , 1 = . , 2 = 000014h",
    "4.7.1 TWO-WORD INSTRUCTIONS\nThe  PIC18F6525/6621/8525/8621  devices  have  four two-word instructions: MOVFF CALL , , GOTO and LFSR . The second word of these instructions has the 4 MSBs set to ' 1 's and is a special kind of NOP instruction. The lower  12  bits  of  the  second  word  contain  data  to  be used by the instruction. If the first word of the instruction is executed, the data in the second word is accessed.\nIf the second word of the instruction is executed by itself (first word was skipped), it will execute as a NOP . This action is  necessary when the two-word instruction is preceded by a conditional instruction that changes the PC. A program example that demonstrates this concept is shown  in Example 4-3. Refer to Section 25.0 'Instruction Set Summary' for further details of the instruction set.",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\n0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ; is RAM location 0?. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:.Source Code = ; No, execute 2-word instruction. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = .",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\n1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; 2nd operand holds address of REG2. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ; continue code. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\n1:.Object Code = Object Code. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. 0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ; is RAM location 0?. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\n1:.Source Code = ; Yes. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; 2nd operand becomes NOP. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ; continue code",
    "4.8 Look-up Tables\nLook-up tables are implemented two ways. These are:\nroutine is the ADDWF PCL instruction. The next instruction executed will be one of the RETLW 0xnn instructions that returns the value 0xnn to the calling function.\n\u00b7 Computed GOTO\n\u00b7 Table Reads",
    "4.8.1 COMPUTED GOTO\nA computed GOTO is accomplished by adding an offset to the program counter ( ADDWF PCL ).\nThe offset value (value in WREG) specifies the number of bytes that the program counter should advance.\nIn  this  method,  only  one  data  byte  may  be  stored  in each  instruction  location  and  room  on  the  return address stack is required.\nA  look-up  table  can  be  formed  with  an ADDWF PCL instruction  and  a  group  of RETLW 0xnn instructions. WREG is loaded with an offset into the table before executing a call to that table. The first instruction of the called\nNote:, 1 = The ADDWF PCL instruction does not update PCLATH and PCLATU. A read operation on PCL must be performed to update PCLATH and PCLATU.",
    "EXAMPLE 4-4: COMPUTED GOTO USING AN OFFSET VALUE\nMAIN:, 1 = ORG. MAIN:, 2 = 0x0000. , 1 = MOVLW. , 2 = 0x00. , 1 = CALL. , 2 = TABLE. \u2026, 1 = . \u2026, 2 = . , 1 = ORG. , 2 = 0x8000. TABLE, 1 = MOVF. TABLE, 2 = PCL, F ; A simple read of PCL will update PCLATH, PCLATU. , 1 = RLNCF. , 2 = W, W ; Multiply by 2 to get correct offset in table. , 1 = ADDWF. , 2 = PCL ; Add the modified offset to force jump into table. , 1 = RETLW. , 2 = 'A'. , 1 = RETLW. , 2 = 'B'. , 1 = RETLW. , 2 = 'C'. , 1 = RETLW. , 2 = 'D'. , 1 = RETLW. , 2 = 'E'. , 1 = END. , 2 = ",
    "4.8.2 TABLE READS/TABLE WRITES\nA  better  method  of  storing  data  in  program  memory allows 2 bytes of data to be stored in each instruction location.\nLook-up table data may be stored 2 bytes per program word by using table reads and writes. The Table Pointer (TBLPTR)  specifies  the  byte  address  and  the  Table Latch (TABLAT) contains the data that is read from, or written to program memory. Data is transferred to/from program memory, one byte at a time.\nA description of the table read/table write operation is shown in Section 5.0 'Flash Program Memory' .",
    "4.9 Data Memory Organization\nThe data memory is implemented as static RAM. Each register  in  the  data  memory  has  a  12-bit  address, allowing up to 4096 bytes of data memory. Figure 4-7 shows the data memory organization for the PIC18F6525/6621/8525/8621 devices.\nThe data memory map is divided into 16 banks that contain 256 bytes each. The lower 4 bits of the Bank Select Register (BSR<3:0>) select which bank will be accessed.  The  upper  4  bits  for  the  BSR  are  not implemented.\nThe data memory contains Special Function Registers (SFR)  and  General  Purpose  Registers  (GPR).  The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratch pad operations in the user's application. The SFRs start at the last location of Bank 15 (0FFFh) and extend downwards. Any remaining space beyond the SFRs in the bank may be implemented as GPRs. GPRs start at the first location of Bank 0 and grow upwards. Any read of an unimplemented location will read as ' 0 's.",
    "4.9 Data Memory Organization\nThe entire  data  memory  may  be accessed directly  or indirectly. Direct addressing may require the use of the BSR register. Indirect addressing requires the use of a File Select Register (FSRn)  and  a corresponding Indirect File Operand (INDFn). Each FSR holds a 12-bit address value that can be used to access any location in the data memory map without banking.\nThe instruction  set  and  architecture  allow  operations across all banks. This may be accomplished by indirect addressing or by the use of the MOVFF instruction. The MOVFF instruction  is  a  two-word/two-cycle  instruction that moves a value from one register to another.\nTo  ensure  that  commonly  used  registers  (SFRs  and select  GPRs)  can  be  accessed  in  a  single  cycle regardless of the current BSR values, an Access Bank is implemented. A segment of Bank 0 and a segment of Bank  15  comprise  the  Access  RAM. Section 4.10 'Access Bank' provides a detailed description of the Access RAM.",
    "4.9.1 GENERAL PURPOSE REGISTER FILE\nThe  register  file  can  be  accessed  either  directly  or indirectly.  Indirect  addressing  operates  using  a  File Select Register and corresponding Indirect File Operand.  The  operation  of  indirect addressing  is shown  in Section 4.12  'Indirect  Addressing,  INDF and FSR Registers' .\nEnhanced MCU devices may have banked memory in the GPR area. GPRs are not initialized by a Power-on Reset and are unchanged on all other Resets.\nData  RAM  is  available  for  use  as  General  Purpose Registers by all instructions. The top section of Bank 15 (F60h to FFFh) contains SFRs. All other banks of data memory contain GPRs, starting with Bank 0.",
    "4.9.2 SPECIAL FUNCTION REGISTERS\nThe Special Function  Registers (SFRs) are registers used by the CPU and peripheral modules for controlling the desired operation of the device. These registers are implemented as static RAM. A list of these registers is given in Table 4-2 and Table 4-3.\nThe SFRs can be classified into two sets: those associated with the 'core' function and those related to the peripheral  functions.  Those  registers  related  to  the 'core' are described in this section, while those related to the operation of the peripheral features are described in the section of that peripheral feature. The SFRs are typically distributed among the peripherals whose functions they control.\nThe  unused  SFR  locations  are  unimplemented  and read as ' 0 's. The addresses for the SFRs are listed in Table 4-2.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nFFFh, Name = TOSU. FFFh, Address = FDFh. FFFh, Name = INDF2 (3). FFFh, Address = FBFh. FFFh, Name = CCPR1H. FFFh, Address = F9Fh. FFFh, Name = IPR1. FFEh, Name = TOSH. FFEh, Address = FDEh. FFEh, Name = POSTINC2 (3). FFEh, Address = FBEh. FFEh, Name = CCPR1L. FFEh, Address = F9Eh. FFEh, Name = PIR1. FFDh, Name = TOSL. FFDh, Address = FDDh. FFDh, Name = POSTDEC2 (3). FFDh, Address = FBDh. FFDh, Name = CCP1CON. FFDh, Address = F9Dh. FFDh, Name = PIE1. FFCh, Name = STKPTR. FFCh, Address = FDCh. FFCh, Name = PREINC2 (3). FFCh, Address = FBCh.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nFFCh, Name = CCPR2H. FFCh, Address = F9Ch. FFCh, Name = MEMCON (2). FFBh, Name = PCLATU. FFBh, Address = FDBh. FFBh, Name = PLUSW2 (3). FFBh, Address = FBBh. FFBh, Name = CCPR2L. FFBh, Address = F9Bh. FFBh, Name = - (1). FFAh, Name = PCLATH. FFAh, Address = FDAh. FFAh, Name = FSR2H. FFAh, Address = FBAh. FFAh, Name = CCP2CON. FFAh, Address = F9Ah. FFAh, Name = TRISJ (2). FF9h, Name = PCL. FF9h, Address = FD9h. FF9h, Name = FSR2L. FF9h, Address = FB9h. FF9h, Name = CCPR3H. FF9h, Address = F99h. FF9h, Name = TRISH (2). FF8h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nTBLPTRU. FF8h, Address = FD8h. FF8h, Name = STATUS. FF8h, Address = FB8h. FF8h, Name = CCPR3L. FF8h, Address = F98h. FF8h, Name = TRISG. FF7h, Name = TBLPTRH. FF7h, Address = FD7h. FF7h, Name = TMR0H. FF7h, Address = FB7h. FF7h, Name = CCP3CON. FF7h, Address = F97h. FF7h, Name = TRISF. FF6h, Name = TBLPTRL. FF6h, Address = FD6h. FF6h, Name = TMR0L. FF6h, Address = FB6h. FF6h, Name = ECCP1AS. FF6h, Address = F96h. FF6h, Name = TRISE. FF5h, Name = TABLAT. FF5h, Address = FD5h. FF5h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nT0CON. FF5h, Address = FB5h. FF5h, Name = CVRCON. FF5h, Address = F95h. FF5h, Name = TRISD. FF4h, Name = PRODH. FF4h, Address = FD4h. FF4h, Name = - (1). FF4h, Address = FB4h. FF4h, Name = CMCON. FF4h, Address = F94h. FF4h, Name = TRISC. FF3h, Name = PRODL. FF3h, Address = FD3h. FF3h, Name = OSCCON. FF3h, Address = FB3h. FF3h, Name = TMR3H. FF3h, Address = F93h. FF3h, Name = TRISB. FF2h, Name = INTCON. FF2h, Address = FD2h. FF2h, Name = LVDCON. FF2h, Address = FB2h. FF2h, Name = TMR3L. FF2h, Address",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\n= F92h. FF2h, Name = TRISA. FF1h, Name = INTCON2. FF1h, Address = FD1h. FF1h, Name = WDTCON. FF1h, Address = FB1h. FF1h, Name = T3CON. FF1h, Address = F91h. FF1h, Name = LATJ (2). FF0h, Name = INTCON3. FF0h, Address = FD0h. FF0h, Name = RCON. FF0h, Address = FB0h. FF0h, Name = PSPCON (4). FF0h, Address = F90h. FF0h, Name = LATH (2). FEFh, Name = INDF0 (3). FEFh, Address = FCFh. FEFh, Name = TMR1H. FEFh, Address = FAFh. FEFh, Name = SPBRG1. FEFh, Address = F8Fh. FEFh, Name = LATG. FEEh,",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nName = POSTINC0 (3). FEEh, Address = FCEh. FEEh, Name = TMR1L. FEEh, Address = FAEh. FEEh, Name = RCREG1. FEEh, Address = F8Eh. FEEh, Name = LATF. FEDh, Name = POSTDEC0 (3). FEDh, Address = FCDh. FEDh, Name = T1CON. FEDh, Address = FADh. FEDh, Name = TXREG1. FEDh, Address = F8Dh. FEDh, Name = LATE. FECh, Name = PREINC0 (3). FECh, Address = FCCh. FECh, Name = TMR2. FECh, Address = FACh. FECh, Name = TXSTA1. FECh, Address = F8Ch. FECh, Name = LATD. FEBh, Name = PLUSW0 (3). FEBh, Address = FCBh. FEBh, Name = PR2. FEBh, Address = FABh. FEBh, Name = RCSTA1. FEBh, Address =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nF8Bh. FEBh, Name = LATC. FEAh, Name = FSR0H. FEAh, Address = FCAh. FEAh, Name = T2CON. FEAh, Address = FAAh. FEAh, Name = EEADRH. FEAh, Address = F8Ah. FEAh, Name = LATB. FE9h, Name = FSR0L. FE9h, Address = FC9h. FE9h, Name = SSPBUF. FE9h, Address = FA9h. FE9h, Name = EEADR. FE9h, Address = F89h. FE9h, Name = LATA. FE8h, Name = WREG. FE8h, Address = FC8h. FE8h, Name = SSPADD. FE8h, Address = FA8h. FE8h, Name = EEDATA. FE8h, Address = F88h. FE8h, Name = PORTJ (2). FE7h, Name = INDF1 (3). FE7h, Address = FC7h. FE7h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nSSPSTAT. FE7h, Address = FA7h. FE7h, Name = EECON2. FE7h, Address = F87h. FE7h, Name = PORTH (2). FE6h, Name = POSTINC1 (3). FE6h, Address = FC6h. FE6h, Name = SSPCON1. FE6h, Address = FA6h. FE6h, Name = EECON1. FE6h, Address = F86h. FE6h, Name = PORTG. FE5h, Name = POSTDEC1 (3). FE5h, Address = FC5h. FE5h, Name = SSPCON2. FE5h, Address = FA5h. FE5h, Name = IPR3. FE5h, Address = F85h. FE5h, Name = PORTF. FE4h, Name = PREINC1 (3). FE4h, Address = FC4h. FE4h, Name = ADRESH. FE4h, Address = FA4h. FE4h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nPIR3. FE4h, Address = F84h. FE4h, Name = PORTE. FE3h, Name = PLUSW1 (3). FE3h, Address = FC3h. FE3h, Name = ADRESL. FE3h, Address = FA3h. FE3h, Name = PIE3. FE3h, Address = F83h. FE3h, Name = PORTD. FE2h, Name = FSR1H. FE2h, Address = FC2h. FE2h, Name = ADCON0. FE2h, Address = FA2h. FE2h, Name = IPR2. FE2h, Address = F82h. FE2h, Name = PORTC. FE1h, Name = FSR1L. FE1h, Address = FC1h. FE1h, Name = ADCON1. FE1h, Address = FA1h. FE1h, Name = PIR2. FE1h, Address = F81h. FE1h, Name = PORTB. FE0h, Name = BSR.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nFE0h, Address = FC0h. FE0h, Name = ADCON2. FE0h, Address = FA0h. FE0h, Name = PIE2. FE0h, Address = F80h. FE0h, Name = PORTA\nNote\n1: Unimplemented registers are read as ' 0 '.\n2: This register is not available on PIC18F6525/6621 devices and reads as ' 0 '.\n3: This is not a physical register.\n4: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF7Fh, Name = SPBRGH1. F7Fh, Address = F5Fh. F7Fh, Name = - (1). F7Fh, Address = F3Fh. F7Fh, Name = - (1). F7Fh, Address = F1Fh. F7Fh, Name = - (1). F7Eh, Name = BAUDCON1. F7Eh, Address = F5Eh. F7Eh, Name = - (1). F7Eh, Address = F3Eh. F7Eh, Name = - (1). F7Eh, Address = F1Eh. F7Eh, Name = - (1). F7Dh, Name = SPBRGH2. F7Dh, Address = F5Dh. F7Dh, Name = - (1). F7Dh, Address = F3Dh. F7Dh, Name = - (1). F7Dh, Address = F1Dh. F7Dh, Name = - (1). F7Ch, Name = BAUDCON2. F7Ch,",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nAddress = F5Ch. F7Ch, Name = - (1). F7Ch, Address = F3Ch. F7Ch, Name = - (1). F7Ch, Address = F1Ch. F7Ch, Name = - (1). F7Bh, Name = - (1). F7Bh, Address = F5Bh. F7Bh, Name = - (1). F7Bh, Address = F3Bh. F7Bh, Name = - (1). F7Bh, Address = F1Bh. F7Bh, Name = - (1). F7Ah, Name = - (1). F7Ah, Address = F5Ah. F7Ah, Name = - (1). F7Ah, Address = F3Ah. F7Ah, Name = - (1). F7Ah, Address = F1Ah. F7Ah, Name = - (1). F79h, Name = ECCP1DEL. F79h, Address = F59h. F79h, Name = - (1). F79h,",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nAddress = F39h. F79h, Name = - (1). F79h, Address = F19h. F79h, Name = - (1). F78h, Name = TMR4. F78h, Address = F58h. F78h, Name = - (1). F78h, Address = F38h. F78h, Name = - (1). F78h, Address = F18h. F78h, Name = - (1). F77h, Name = PR4. F77h, Address = F57h. F77h, Name = - (1). F77h, Address = F37h. F77h, Name = - (1). F77h, Address = F17h. F77h, Name = - (1). F76h, Name = T4CON. F76h, Address = F56h. F76h, Name = - (1). F76h, Address =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF36h. F76h, Name = - (1). F76h, Address = F16h. F76h, Name = - (1). F75h, Name = CCPR4H. F75h, Address = F55h. F75h, Name = - (1). F75h, Address = F35h. F75h, Name = - (1). F75h, Address = F15h. F75h, Name = - (1). F74h, Name = CCPR4L. F74h, Address = F54h. F74h, Name = - (1). F74h, Address = F34h. F74h, Name = - (1). F74h, Address = F14h. F74h, Name = - (1). F73h, Name = CCP4CON. F73h, Address = F53h. F73h, Name = - (1). F73h, Address = F33h.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF73h, Name = - (1). F73h, Address = F13h. F73h, Name = - (1). F72h, Name = CCPR5H. F72h, Address = F52h. F72h, Name = - (1). F72h, Address = F32h. F72h, Name = - (1). F72h, Address = F12h. F72h, Name = - (1). F71h, Name = CCPR5L. F71h, Address = F51h. F71h, Name = - (1). F71h, Address = F31h. F71h, Name = - (1). F71h, Address = F11h. F71h, Name = - (1). F70h, Name = CCP5CON. F70h, Address = F50h. F70h, Name = - (1). F70h, Address = F30h. F70h, Name",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\n= - (1). F70h, Address = F10h. F70h, Name = - (1). F6Fh, Name = SPBRG2. F6Fh, Address = F4Fh. F6Fh, Name = - (1). F6Fh, Address = F2Fh. F6Fh, Name = - (1). F6Fh, Address = F0Fh. F6Fh, Name = - (1). F6Eh, Name = RCREG2. F6Eh, Address = F4Eh. F6Eh, Name = - (1). F6Eh, Address = F2Eh. F6Eh, Name = - (1). F6Eh, Address = F0Eh. F6Eh, Name = - (1). F6Dh, Name = TXREG2. F6Dh, Address = F4Dh. F6Dh, Name = - (1). F6Dh, Address = F2Dh. F6Dh, Name = - (1). F6Dh, Address =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF0Dh. F6Dh, Name = - (1). F6Ch, Name = TXSTA2. F6Ch, Address = F4Ch. F6Ch, Name = - (1). F6Ch, Address = F2Ch. F6Ch, Name = - (1). F6Ch, Address = F0Ch. F6Ch, Name = - (1). F6Bh, Name = RCSTA2. F6Bh, Address = F4Bh. F6Bh, Name = - (1). F6Bh, Address = F2Bh. F6Bh, Name = - (1). F6Bh, Address = F0Bh. F6Bh, Name = - (1). F6Ah, Name = ECCP3AS. F6Ah, Address = F4Ah. F6Ah, Name = - (1). F6Ah, Address = F2Ah. F6Ah, Name = - (1). F6Ah, Address = F0Ah. F6Ah, Name = - (1). F69h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nECCP3DEL. F69h, Address = F49h. F69h, Name = - (1). F69h, Address = F29h. F69h, Name = - (1). F69h, Address = F09h. F69h, Name = - (1). F68h, Name = ECCP2AS. F68h, Address = F48h. F68h, Name = - (1). F68h, Address = F28h. F68h, Name = - (1). F68h, Address = F08h. F68h, Name = - (1). F67h, Name = ECCP2DEL. F67h, Address = F47h. F67h, Name = - (1). F67h, Address = F27h. F67h, Name = - (1). F67h, Address = F07h. F67h, Name = - (1). F66h, Name",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\n= - (1). F66h, Address = F46h. F66h, Name = - (1). F66h, Address = F26h. F66h, Name = - (1). F66h, Address = F06h. F66h, Name = - (1). F65h, Name = - (1). F65h, Address = F45h. F65h, Name = - (1). F65h, Address = F25h. F65h, Name = - (1). F65h, Address = F05h. F65h, Name = - (1). F64h, Name = - (1). F64h, Address = F44h. F64h, Name = - (1). F64h, Address = F24h. F64h, Name = - (1). F64h, Address = F04h. F64h, Name = - (1). F63h, Name = - (1). F63h, Address = F43h.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF63h, Name = - (1). F63h, Address = F23h. F63h, Name = - (1). F63h, Address = F03h. F63h, Name = - (1). F62h, Name = - (1). F62h, Address = F42h. F62h, Name = - (1). F62h, Address = F22h. F62h, Name = - (1). F62h, Address = F02h. F62h, Name = - (1). F61h, Name = - (1). F61h, Address = F41h. F61h, Name = - (1). F61h, Address = F21h. F61h, Name = - (1). F61h, Address = F01h. F61h, Name = - (1). F60h, Name = - (1). F60h, Address = F40h.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF60h, Name = - (1). F60h, Address = F20h. F60h, Name = - (1). F60h, Address = F00h. F60h, Name = - (1)\nNote 1: Unimplemented registers are read as ' 0 '.\n2: This register is not available on PIC18F6525/6621 devices and reads as ' 0 '.\n3: This is not a physical register.\n4: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "TABLE 4-3: REGISTER FILE SUMMARY\nTOSU, Bit 7 = -. TOSU, Bit 6 = -. TOSU, Bit 5 = -. TOSU, Bit 4 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 3 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 2 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 1 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 0 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Value on POR, BOR = ---0 0000. TOSU, Details on page: = 32, 42. TOSH, Bit 7 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 6 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 5 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 4 = Top-of-Stack",
    "TABLE 4-3: REGISTER FILE SUMMARY\nHigh Byte (TOS<15:8>). TOSH, Bit 3 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 2 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 1 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 0 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Value on POR, BOR = 0000 0000. TOSH, Details on page: = 32, 42. TOSL, Bit 7 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 6 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 5 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 4 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 3 = Top-of-Stack Low Byte (TOS<7:0>).",
    "TABLE 4-3: REGISTER FILE SUMMARY\nTOSL, Bit 2 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 1 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 0 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Value on POR, BOR = 0000 0000. TOSL, Details on page: = 32, 42. STKPTR, Bit 7 = STKFUL. STKPTR, Bit 6 = STKUNF. STKPTR, Bit 5 = -. STKPTR, Bit 4 = Return Stack Pointer. STKPTR, Bit 3 = Return Stack Pointer. STKPTR, Bit 2 = Return Stack Pointer. STKPTR, Bit 1 = Return Stack Pointer. STKPTR, Bit 0 = Return Stack Pointer. STKPTR, Value on POR, BOR = 00-0 0000. STKPTR, Details on page: = 32, 43. PCLATU, Bit 7 = -. PCLATU, Bit 6 = -. PCLATU, Bit 5 =",
    "TABLE 4-3: REGISTER FILE SUMMARY\n-. PCLATU, Bit 4 = Holding Register for PC<20:16>. PCLATU, Bit 3 = Holding Register for PC<20:16>. PCLATU, Bit 2 = Holding Register for PC<20:16>. PCLATU, Bit 1 = Holding Register for PC<20:16>. PCLATU, Bit 0 = Holding Register for PC<20:16>. PCLATU, Value on POR, BOR = ---0 0000. PCLATU, Details on page: = 32, 44. PCLATH, Bit 7 = Holding Register for PC<15:8>. PCLATH, Bit 6 = Holding Register for PC<15:8>. PCLATH, Bit 5 = Holding Register for PC<15:8>. PCLATH, Bit 4 = Holding Register for PC<15:8>. PCLATH, Bit 3 = Holding Register for PC<15:8>. PCLATH, Bit 2 = Holding Register for PC<15:8>. PCLATH, Bit 1 = Holding Register for PC<15:8>. PCLATH, Bit 0 = Holding Register for",
    "TABLE 4-3: REGISTER FILE SUMMARY\nPC<15:8>. PCLATH, Value on POR, BOR = 0000 0000. PCLATH, Details on page: = 32, 44. PCL, Bit 7 = PC Low Byte (PC<7:0>). PCL, Bit 6 = PC Low Byte (PC<7:0>). PCL, Bit 5 = PC Low Byte (PC<7:0>). PCL, Bit 4 = PC Low Byte (PC<7:0>). PCL, Bit 3 = PC Low Byte (PC<7:0>). PCL, Bit 2 = PC Low Byte (PC<7:0>). PCL, Bit 1 = PC Low Byte (PC<7:0>). PCL, Bit 0 = PC Low Byte (PC<7:0>). PCL, Value on POR, BOR = 0000 0000. PCL, Details on page: = 32, 44. TBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit 21 (2). TBLPTRU, Bit 4",
    "TABLE 4-3: REGISTER FILE SUMMARY\n= Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on POR, BOR = --00 0000. TBLPTRU, Details on page: = 32, 69. TBLPTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 4 = Program Memory Table Pointer High Byte",
    "TABLE 4-3: REGISTER FILE SUMMARY\n(TBLPTR<15:8>). TBLPTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Value on POR, BOR = 0000 0000. TBLPTRH, Details on page: = 32, 69. TBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit",
    "TABLE 4-3: REGISTER FILE SUMMARY\n3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Value on POR, BOR = 0000 0000. TBLPTRL, Details on page: = 32, 69. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on POR, BOR = 0000 0000. TABLAT, Details on page: = 32, 69. PRODH, Bit 7 = Product Register",
    "TABLE 4-3: REGISTER FILE SUMMARY\nHigh Byte. PRODH, Bit 6 = Product Register High Byte. PRODH, Bit 5 = Product Register High Byte. PRODH, Bit 4 = Product Register High Byte. PRODH, Bit 3 = Product Register High Byte. PRODH, Bit 2 = Product Register High Byte. PRODH, Bit 1 = Product Register High Byte. PRODH, Bit 0 = Product Register High Byte. PRODH, Value on POR, BOR = xxxx xxxx. PRODH, Details on page: = 32, 85. PRODL, Bit 7 = Product Register Low Byte. PRODL, Bit 6 = Product Register Low Byte. PRODL, Bit 5 = Product Register Low Byte. PRODL, Bit 4 = Product Register Low Byte. PRODL, Bit 3 = Product Register Low Byte. PRODL, Bit 2 = Product Register Low Byte. PRODL, Bit 1 = Product Register Low Byte. PRODL, Bit 0 = Product Register Low Byte. PRODL, Value on POR, BOR = xxxx xxxx. PRODL, Details on page: = 32, 85. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL.",
    "TABLE 4-3: REGISTER FILE SUMMARY\nINTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Details on page: = 32, 89. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = INTEDG3. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = INT3IP. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111 1111. INTCON2, Details on page: = 32, 90. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = INT3IE. INTCON3, Bit",
    "TABLE 4-3: REGISTER FILE SUMMARY\n4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = INT3IF. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 1100 0000. INTCON3, Details on page: = 32, 91. INDF0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 2 = Uses contents of",
    "TABLE 4-3: REGISTER FILE SUMMARY\nFSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Value on POR, BOR = N/A. INDF0, Details on page: = 56. POSTINC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. POSTINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. POSTINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. POSTINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. POSTINC0, Bit 3 = Uses contents of FSR0 to address",
    "TABLE 4-3: REGISTER FILE SUMMARY\ndata memory - value of FSR0 post-incremented. POSTINC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. POSTINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. POSTINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented. POSTINC0, Value on POR, BOR = N/A. POSTINC0, Details on page: = 56. POSTDEC0, Bit 7 = (not a physical register) Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 6 = (not a physical register) Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 5 = (not a physical register) Uses contents of FSR0 to address data memory - value of FSR0",
    "TABLE 4-3: REGISTER FILE SUMMARY\npost-decremented (not a physical register). POSTDEC0, Bit 4 = (not a physical register) Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 3 = (not a physical register) Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 2 = (not a physical register) Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 1 = (not a physical register) Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 0 = (not a physical register) Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Value on POR, BOR = N/A. POSTDEC0, Details on page: =",
    "TABLE 4-3: REGISTER FILE SUMMARY\n56. PREINC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented",
    "TABLE 4-3: REGISTER FILE SUMMARY\n(not a physical register). PREINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Value on POR, BOR = N/A. PREINC0, Details on page: = 56. PLUSW0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0 offset by value in WREG. PLUSW0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0 offset by value in WREG. PLUSW0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0 offset by value in WREG. PLUSW0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value",
    "TABLE 4-3: REGISTER FILE SUMMARY\nof FSR0 offset by value in WREG. PLUSW0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0 offset by value in WREG. PLUSW0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0 offset by value in WREG. PLUSW0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0 offset by value in WREG. PLUSW0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) - value of FSR0 offset by value in WREG. PLUSW0, Value on POR, BOR = N/A. PLUSW0, Details on page: = 56. FSR0H, Bit 7 = - - - - Indirect Data Memory Address Pointer 0 High Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY\nFSR0H, Bit 6 = - - - - Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 5 = - - - - Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 4 = - - - - Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 3 = - - - - Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 2 = - - - - Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 1 = - - - - Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 0 = - - - - Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Value on POR, BOR = ---- 0000. FSR0H, Details on page: = 32, 56. FSR0L, Bit 7 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 6 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 5 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 4 = Indirect Data Memory Address Pointer 0 Low Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY\nFSR0L, Bit 3 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 2 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 1 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 0 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Value on POR, BOR = xxxx xxxx. FSR0L, Details on page: = 32, 56. WREG, Bit 7 = Working Register. WREG, Bit 6 = Working Register. WREG, Bit 5 = Working Register. WREG, Bit 4 = Working Register. WREG, Bit 3 = Working Register. WREG, Bit 2 = Working Register. WREG, Bit 1 = Working Register. WREG, Bit 0 = Working Register. WREG, Value on POR, BOR = xxxx xxxx. WREG, Details on page: = 32. INDF1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 6 = Uses contents of FSR1 to address data memory - value of",
    "TABLE 4-3: REGISTER FILE SUMMARY\nFSR1 not changed (not a physical register). INDF1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Value on POR, BOR = N/A. INDF1, Details on page: = 56. POSTINC1, Bit 7 = Uses contents of FSR1 to address data memory",
    "TABLE 4-3: REGISTER FILE SUMMARY\n- value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 0 = Uses contents of FSR1",
    "TABLE 4-3: REGISTER FILE SUMMARY\nto address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Value on POR, BOR = N/A. POSTINC1, Details on page: = 56. POSTDEC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 2 = Uses contents of FSR1 to address data memory",
    "TABLE 4-3: REGISTER FILE SUMMARY\n- value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Value on POR, BOR = N/A. POSTDEC1, Details on page: = 56. PREINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of",
    "TABLE 4-3: REGISTER FILE SUMMARY\nFSR1 pre-incremented (not a physical register). PREINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Value on POR, BOR = N/A. PREINC1, Details on page: = 56. PLUSW1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 6 = Uses contents of FSR1 to",
    "TABLE 4-3: REGISTER FILE SUMMARY\naddress data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1",
    "TABLE 4-3: REGISTER FILE SUMMARY\npre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1 offset by value in WREG. PLUSW1, Value on POR, BOR = N/A. PLUSW1, Details on page: = 56. FSR1H FSR1L, Bit 7 = - Indirect Data Memory Address Pointer 1 Low Byte. FSR1H FSR1L, Bit 6 = -. FSR1H FSR1L, Bit 5 = -. FSR1H FSR1L, Bit 4 = -. FSR1H FSR1L, Bit 3 = Indirect Data. FSR1H FSR1L, Bit 2 = Memory. FSR1H FSR1L, Bit 1 = Address Pointer. FSR1H FSR1L, Bit 0 = High Byte. FSR1H FSR1L, Value on POR, BOR = ---- 0000. FSR1H",
    "TABLE 4-3: REGISTER FILE SUMMARY\nFSR1L, Details on page: = 32, 56 33, 56. , Bit 7 = . , Bit 6 = . , Bit 5 = . , Bit 4 = . , Bit 3 = . , Bit 2 = . , Bit 1 = . , Bit 0 = . , Value on POR, BOR = xxxx xxxx. , Details on page: = 33, 55. BSR, Bit 7 = -. BSR, Bit 6 = -. BSR, Bit 5 = -. BSR, Bit 4 = -. BSR, Bit 3 = Bank Select Register. BSR, Bit 2 = Bank Select Register. BSR, Bit 1 = Bank Select Register. BSR, Bit 0 = Bank Select Register. BSR, Value on POR, BOR = ---- 0000. BSR, Details on page: = . INDF2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 5",
    "TABLE 4-3: REGISTER FILE SUMMARY\n= Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Value on POR, BOR = N/A. INDF2, Details on page: = 56. POSTINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register).",
    "TABLE 4-3: REGISTER FILE SUMMARY\nPOSTINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a",
    "TABLE 4-3: REGISTER FILE SUMMARY\nphysical register). POSTINC2, Value on POR, BOR = N/A. POSTINC2, Details on page: = 56. POSTDEC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register).",
    "TABLE 4-3: REGISTER FILE SUMMARY\nPOSTDEC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Value on POR, BOR = N/A. POSTDEC2, Details on page: = 56\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: RA6 and associated bits are configured as a port pin in RCIO and ECIO Oscillator modes only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6525/6621 devices and read as ' 0 '.\n4: RG5 is available only if MCLR function is disabled in configuration.\n5: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPREINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n(not a physical register). PREINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Value on POR, BOR = N/A. PREINC2, Details on page: = 56. PLUSW2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nregister) - value of FSR2 offset by value in WREG. PLUSW2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register) - value of FSR2 offset by value in WREG. PLUSW2, Value on POR, BOR = N/A. PLUSW2, Details on page: = 56. FSR2H, Bit 7 = -. FSR2H, Bit",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n6 = -. FSR2H, Bit 5 = -. FSR2H, Bit 4 = -. FSR2H, Bit 3 = Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 2 = Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 1 = Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 0 = Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Value on POR, BOR = ---- 0000. FSR2H, Details on page: = 33, 56. FSR2L, Bit 7 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 6 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 5 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 4 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 3 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 2 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 1 = Indirect Data Memory Address Pointer 2 Low Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nFSR2L, Bit 0 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Value on POR, BOR = xxxx xxxx. FSR2L, Details on page: = 33, 56. STATUS, Bit 7 = -. STATUS, Bit 6 = -. STATUS, Bit 5 = -. STATUS, Bit 4 = N. STATUS, Bit 3 = OV. STATUS, Bit 2 = Z. STATUS, Bit 1 = DC. STATUS, Bit 0 = C. STATUS, Value on POR, BOR = ---x xxxx. STATUS, Details on page: = 33, 58. TMR0H, Bit 7 = Timer0 Register High Byte. TMR0H, Bit 6 = Timer0 Register High Byte. TMR0H, Bit 5 = Timer0 Register High Byte. TMR0H, Bit 4 = Timer0 Register High Byte. TMR0H, Bit 3 = Timer0 Register High Byte. TMR0H, Bit 2 = Timer0 Register High Byte. TMR0H, Bit 1 = Timer0 Register High Byte. TMR0H, Bit 0",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n= Timer0 Register High Byte. TMR0H, Value on POR, BOR = 0000 0000. TMR0H, Details on page: = 33, 133. TMR0L, Bit 7 = Timer0 Register Low Byte. TMR0L, Bit 6 = Timer0 Register Low Byte. TMR0L, Bit 5 = Timer0 Register Low Byte. TMR0L, Bit 4 = Timer0 Register Low Byte. TMR0L, Bit 3 = Timer0 Register Low Byte. TMR0L, Bit 2 = Timer0 Register Low Byte. TMR0L, Bit 1 = Timer0 Register Low Byte. TMR0L, Bit 0 = Timer0 Register Low Byte. TMR0L, Value on POR, BOR = xxxx xxxx. TMR0L, Details on page: = 33, 133. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111 1111. T0CON, Details on page: = 33, 131. OSCCON, Bit 7 = -. OSCCON, Bit 6 = -. OSCCON, Bit 5 = -. OSCCON, Bit 4 = -. OSCCON, Bit 3 = LOCK. OSCCON, Bit 2 = PLLEN. OSCCON, Bit 1 = SCS1. OSCCON, Bit 0 = SCS0. OSCCON, Value on POR, BOR = ---- 0000. OSCCON, Details on page: = 25, 33. LVDCON, Bit 7 = -. LVDCON, Bit 6 = -. LVDCON, Bit 5 = IRVST. LVDCON, Bit 4 = LVDEN. LVDCON, Bit 3 = LVDL3. LVDCON, Bit 2 = LVDL2.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nLVDCON, Bit 1 = LVDL1. LVDCON, Bit 0 = LVDL0. LVDCON, Value on POR, BOR = --00 0101. LVDCON, Details on page: = 33, 255. WDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN. WDTCON, Value on POR, BOR = ---- ---0. WDTCON, Details on page: = 33, 267. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0--1 11qq.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRCON, Details on page: = 33, 59, 101. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Value on POR, BOR = xxxx xxxx. TMR1H, Details on page: = 33, 139. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Value on POR, BOR = xxxx xxxx. TMR1L, Details on page: = 33, 139. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00 0000. T1CON, Details on page: = 33, 139. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Value on POR, BOR = 0000 0000. TMR2, Details on page: = 33, 142. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111 1111. PR2, Details on page: = 33, 142. T2CON, Bit 7 = -. T2CON, Bit 6 = T2OUTPS3. T2CON, Bit 5 = T2OUTPS2. T2CON, Bit 4 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nT2OUTPS1. T2CON, Bit 3 = T2OUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000 0000. T2CON, Details on page: = 33, 142. SSPBUF, Bit 7 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 0 = MSSP Receive Buffer/Transmit Register. SSPBUF, Value on POR, BOR = xxxx xxxx. SSPBUF, Details on page: = 33,",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n181. SSPADD, Bit 7 = MSSP Address Register in I 2 C Slave mode. MSSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 6 = MSSP Address Register in I 2 C Slave mode. MSSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 5 = MSSP Address Register in I 2 C Slave mode. MSSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 4 = MSSP Address Register in I 2 C Slave mode. MSSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 3 = MSSP Address Register in I 2 C Slave mode. MSSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 2 = MSSP Address Register in I 2 C Slave mode. MSSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 1 = MSSP Address Register in I 2 C Slave mode. MSSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n0 = MSSP Address Register in I 2 C Slave mode. MSSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Value on POR, BOR = 0000 0000. SSPADD, Details on page: = 33, 181. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR, BOR = 0000 0000. SSPSTAT, Details on page: = 33, 174. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nSSPM1. SSPCON1, Bit 0 = SSPM0. SSPCON1, Value on POR, BOR = 0000 0000. SSPCON1, Details on page: = 33, 175. SSPCON2, Bit 7 = GCEN. SSPCON2, Bit 6 = ACKSTAT. SSPCON2, Bit 5 = ACKDT. SSPCON2, Bit 4 = ACKEN. SSPCON2, Bit 3 = RCEN. SSPCON2, Bit 2 = PEN. SSPCON2, Bit 1 = RSEN. SSPCON2, Bit 0 = SEN. SSPCON2, Value on POR, BOR = 0000 0000. SSPCON2, Details on page: = 33, 185. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nResult Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Value on POR, BOR = xxxx xxxx. ADRESH, Details on page: = 33, 241. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Value on POR, BOR = xxxx xxxx. ADRESL, Details on page: = 33, 241. ADCON0, Bit 7 = -. ADCON0, Bit 6 = -. ADCON0, Bit 5 = CHS3. ADCON0, Bit 4 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCHS2. ADCON0, Bit 3 = CHS1. ADCON0, Bit 2 = CHS0. ADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = --00 0000. ADCON0, Details on page: = 34, 233. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = --00 0000. ADCON1, Details on page: = 34, 234. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = -. ADCON2, Bit 5 = ACQT2. ADCON2, Bit 4 = ACQT1. ADCON2, Bit",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n3 = ACQT0. ADCON2, Bit 2 = ADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Value on POR, BOR = 0-00 0000. ADCON2, Details on page: = 34, 235. CCPR1H, Bit 7 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Value on",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPOR, BOR = xxxx xxxx. CCPR1H, Details on page: = 34, 172. CCPR1L, Bit 7 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Value on POR, BOR = xxxx xxxx. CCPR1L, Details on page: = 34, 172. CCP1CON, Bit 7 = P1M1. CCP1CON, Bit 6 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nP1M0. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = 0000 0000. CCP1CON, Details on page: = 34, 157. CCPR2H, Bit 7 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 6 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 5 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 4 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 3 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 2 = Enhanced Capture/Compare/PWM Register 2 High Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCCPR2H, Bit 1 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 0 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Value on POR, BOR = xxxx xxxx. CCPR2H, Details on page: = 34, 172. CCPR2L, Bit 7 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 6 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 5 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 4 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 3 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 2 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 1 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 0 = Enhanced Capture/Compare/PWM Register 2 Low Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCCPR2L, Value on POR, BOR = xxxx xxxx. CCPR2L, Details on page: = 34, 172. CCP2CON, Bit 7 = P2M1. CCP2CON, Bit 6 = P2M0. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Value on POR, BOR = 0000 0000. CCP2CON, Details on page: = 34, 157. CCPR3H, Bit 7 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 6 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 5 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 4 = Enhanced",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCapture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 3 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 2 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 1 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 0 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Value on POR, BOR = xxxx xxxx. CCPR3H, Details on page: = 34, 172. CCPR3L, Bit 7 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 6 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 5 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 4 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 3 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 2 = Enhanced",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCapture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 1 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 0 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Value on POR, BOR = xxxx xxxx. CCPR3L, Details on page: = 34, 172. CCP3CON, Bit 7 = P3M1. CCP3CON, Bit 6 = P3M0. CCP3CON, Bit 5 = DC3B1. CCP3CON, Bit 4 = DC2B0. CCP3CON, Bit 3 = CCP3M3. CCP3CON, Bit 2 = CCP3M2. CCP3CON, Bit 1 = CCP3M1. CCP3CON, Bit 0 = CCP3M0. CCP3CON, Value on POR, BOR = 0000 0000. CCP3CON, Details on page: = 34, 157. ECCP1AS, Bit 7 = ECCP1ASE. ECCP1AS, Bit 6 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nECCP1AS2. ECCP1AS, Bit 5 = ECCP1AS1. ECCP1AS, Bit 4 = ECCP1AS0. ECCP1AS, Bit 3 = PSS1AC1. ECCP1AS, Bit 2 = PSS1AC0. ECCP1AS, Bit 1 = PSS1BD1. ECCP1AS, Bit 0 = PSS1BD0. ECCP1AS, Value on POR, BOR = 0000 0000. ECCP1AS, Details on page: = 34, 169 34, 249. CVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0 0000. CVRCON, Value on POR, BOR = 0000. CVRCON, Details on page: = ",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote\n1: RA6 and associated bits are configured as a port pin in RCIO and ECIO Oscillator modes only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6525/6621 devices and read as ' 0 '.\n4: RG5 is available only if MCLR function is disabled in configuration.\n5: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "TABLE 4-3:\nCMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Value on POR, BOR = 0000 0000. CMCON, Details on page: = 34, 243. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = Timer3 Register High Byte. TMR3H, Value on POR, BOR = xxxx xxxx. TMR3H, Details on page: = 34,",
    "TABLE 4-3:\n145. TMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = Timer3 Register Low Byte. TMR3L, Value on POR, BOR = xxxx xxxx. TMR3L, Details on page: = 34, 145. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 =",
    "TABLE 4-3:\nTMR3ON. T3CON, Value on POR, BOR = 0000 0000. T3CON, Details on page: = 34, 145. PSPCON (5), Bit 7 = IBF. PSPCON (5), Bit 6 = OBF. PSPCON (5), Bit 5 = IBOV. PSPCON (5), Bit 4 = PSPMODE. PSPCON (5), Bit 3 = -. PSPCON (5), Bit 2 = -. PSPCON (5), Bit 1 = -. PSPCON (5), Bit 0 = -. PSPCON (5), Value on POR, BOR = 0000 ----. PSPCON (5), Details on page: = 34, 129. SPBRG1, Bit 7 = Enhanced USART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 6 = Enhanced USART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 5 = Enhanced USART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 4 = Enhanced USART1 Baud Rate Generator Register Low",
    "TABLE 4-3:\nByte. SPBRG1, Bit 3 = Enhanced USART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 2 = Enhanced USART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 1 = Enhanced USART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 0 = Enhanced USART1 Baud Rate Generator Register Low Byte. SPBRG1, Value on POR, BOR = 0000 0000. SPBRG1, Details on page: = 34, 217. RCREG1, Bit 7 = Enhanced USART1 Receive Register. RCREG1, Bit 6 = Enhanced USART1 Receive Register. RCREG1, Bit 5 = Enhanced USART1 Receive Register. RCREG1, Bit 4 = Enhanced USART1 Receive Register. RCREG1, Bit 3 = Enhanced USART1 Receive Register. RCREG1, Bit 2 = Enhanced USART1 Receive Register. RCREG1, Bit 1 = Enhanced USART1 Receive Register. RCREG1, Bit 0 = Enhanced USART1 Receive Register. RCREG1, Value on POR, BOR = 0000 0000.",
    "TABLE 4-3:\nRCREG1, Details on page: = 34, 224. TXREG1, Bit 7 = Enhanced USART1 Transmit Register. TXREG1, Bit 6 = Enhanced USART1 Transmit Register. TXREG1, Bit 5 = Enhanced USART1 Transmit Register. TXREG1, Bit 4 = Enhanced USART1 Transmit Register. TXREG1, Bit 3 = Enhanced USART1 Transmit Register. TXREG1, Bit 2 = Enhanced USART1 Transmit Register. TXREG1, Bit 1 = Enhanced USART1 Transmit Register. TXREG1, Bit 0 = Enhanced USART1 Transmit Register. TXREG1, Value on POR, BOR = 0000 0000. TXREG1, Details on page: = 34, 222. TXSTA1, Bit 7 = CSRC. TXSTA1, Bit 6 = TX9. TXSTA1, Bit 5 = TXEN. TXSTA1, Bit 4 = SYNC. TXSTA1, Bit 3 = SENDB. TXSTA1, Bit 2 = BRGH. TXSTA1, Bit 1 = TRMT. TXSTA1, Bit 0 = TX9D. TXSTA1, Value on",
    "TABLE 4-3:\nPOR, BOR = 0000 0010. TXSTA1, Details on page: = 34, 214. RCSTA1, Bit 7 = SPEN. RCSTA1, Bit 6 = RX9. RCSTA1, Bit 5 = SREN. RCSTA1, Bit 4 = CREN. RCSTA1, Bit 3 = ADDEN. RCSTA1, Bit 2 = FERR. RCSTA1, Bit 1 = OERR. RCSTA1, Bit 0 = RX9D. RCSTA1, Value on POR, BOR = 0000 000x. RCSTA1, Details on page: = 34, 215. EEADRH, Bit 7 = -. EEADRH, Bit 6 = -. EEADRH, Bit 5 = -. EEADRH, Bit 4 = -. EEADRH, Bit 3 = -. EEADRH, Bit 2 = -. EEADRH, Bit 1 = EE Addr Register High. EEADRH, Bit 0 = EE Addr Register High. EEADRH, Value on POR, BOR = ---- --00. EEADRH, Details on page: = 34, 83.",
    "TABLE 4-3:\nEEADR, Bit 7 = Data EEPROM Address Register. EEADR, Bit 6 = Data EEPROM Address Register. EEADR, Bit 5 = Data EEPROM Address Register. EEADR, Bit 4 = Data EEPROM Address Register. EEADR, Bit 3 = Data EEPROM Address Register. EEADR, Bit 2 = Data EEPROM Address Register. EEADR, Bit 1 = Data EEPROM Address Register. EEADR, Bit 0 = Data EEPROM Address Register. EEADR, Value on POR, BOR = 0000 0000. EEADR, Details on page: = 34, 83. EEDATA, Bit 7 = Data EEPROM Data Register. EEDATA, Bit 6 = Data EEPROM Data Register. EEDATA, Bit 5 = Data EEPROM Data Register. EEDATA, Bit 4 = Data EEPROM Data Register. EEDATA, Bit 3 = Data EEPROM Data Register. EEDATA, Bit 2 = Data EEPROM Data Register. EEDATA, Bit 1 = Data EEPROM Data Register. EEDATA, Bit 0 = Data EEPROM Data",
    "TABLE 4-3:\nRegister. EEDATA, Value on POR, BOR = 0000 0000. EEDATA, Details on page: = 34, 83. EECON2, Bit 7 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = Data EEPROM Control Register 2 (not a physical register). EECON2, Value on POR, BOR = ---- ----. EECON2, Details on page: = 34, 83. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 =",
    "TABLE 4-3:\nCFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on POR, BOR = xx-0 x000. EECON1, Details on page: = 34, 80. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = TMR4IP. IPR3, Bit 2 = CCP5IP. IPR3, Bit 1 = CCP4IP. IPR3, Bit 0 = CCP3IP. IPR3, Value on POR, BOR = --11 1111. IPR3, Details on page: = 35, 100. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF.",
    "TABLE 4-3:\nPIR3, Bit 3 = TMR4IF. PIR3, Bit 2 = CCP5IF. PIR3, Bit 1 = CCP4IF. PIR3, Bit 0 = CCP3IF. PIR3, Value on POR, BOR = --00 0000. PIR3, Details on page: = 35, 94. PIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 = TMR4IE. PIE3, Bit 2 = CCP5IE. PIE3, Bit 1 = CCP4IE. PIE3, Bit 0 = CCP3IE. PIE3, Value on POR, BOR = --00 0000. PIE3, Details on page: = 35, 97. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2,",
    "TABLE 4-3:\nBit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = -1-1 1111. IPR2, Details on page: = 35, 99. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = -0-0 0000. PIR2, Details on page: = 35, 93. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR,",
    "TABLE 4-3:\nBOR = -0-0 0000. PIE2, Details on page: = 35, 96. IPR1, Bit 7 = PSPIP (5). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111 1111. IPR1, Details on page: = 35, 98. PIR1, Bit 7 = PSPIF (5). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR",
    "TABLE 4-3:\n= 0000 0000. PIR1, Details on page: = 35, 92. PIE1, Bit 7 = PSPIE (5). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000. PIE1, Details on page: = 35, 95. MEMCON (3), Bit 7 = EBDIS. MEMCON (3), Bit 6 = -. MEMCON (3), Bit 5 = WAIT1. MEMCON (3), Bit 4 = WAIT0. MEMCON (3), Bit 3 = -. MEMCON (3), Bit 2 = -. MEMCON (3), Bit 1 = WM1. MEMCON (3), Bit 0 = WM0. MEMCON (3), Value on POR, BOR =",
    "TABLE 4-3:\n0-00 --00. MEMCON (3), Details on page: = 35, 71. TRISJ (3), Bit 7 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 6 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 5 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 4 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 3 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 2 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 1 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 0 = Data Direction Control Register for PORTJ. TRISJ (3), Value on POR, BOR = 1111 1111. TRISJ (3), Details on page: = 35, 127. TRISH (3), Bit 7 = Data Direction Control Register for PORTH. TRISH (3), Bit 6 = Data Direction Control Register for PORTH. TRISH (3), Bit 5 = Data Direction Control Register for",
    "TABLE 4-3:\nPORTH. TRISH (3), Bit 4 = Data Direction Control Register for PORTH. TRISH (3), Bit 3 = Data Direction Control Register for PORTH. TRISH (3), Bit 2 = Data Direction Control Register for PORTH. TRISH (3), Bit 1 = Data Direction Control Register for PORTH. TRISH (3), Bit 0 = Data Direction Control Register for PORTH. TRISH (3), Value on POR, BOR = 1111 1111. TRISH (3), Details on page: = 35, 124. TRISG, Bit 7 = - - - Data Direction Control Register for PORTG Direction Control Register for PORTF. TRISG, Bit 6 = - - - Data Direction Control Register for PORTG Direction Control Register for PORTF. TRISG, Bit 5 = - - - Data Direction Control Register for PORTG Direction Control Register for PORTF. TRISG, Bit 4 = - - - Data Direction Control Register for PORTG Direction Control Register for PORTF. TRISG, Bit 3 = - - - Data Direction Control Register for PORTG Direction Control Register for PORTF. TRISG, Bit 2 = - - - Data Direction Control Register for",
    "TABLE 4-3:\nPORTG Direction Control Register for PORTF. TRISG, Bit 1 = - - - Data Direction Control Register for PORTG Direction Control Register for PORTF. TRISG, Bit 0 = - - - Data Direction Control Register for PORTG Direction Control Register for PORTF. TRISG, Value on POR, BOR = ---1 1111 1111 1111. TRISG, Details on page: = 35, 119 35, 116. TRISF, Bit 7 = Data. TRISF, Bit 6 = Data. TRISF, Bit 5 = Data. TRISF, Bit 4 = Data. TRISF, Bit 3 = Data. TRISF, Bit 2 = Data. TRISF, Bit 1 = Data. TRISF, Bit 0 = Data. TRISF, Value on POR, BOR = . TRISF, Details on page: = . TRISE, Bit 7 = Data Direction Control Register for PORTE. TRISE, Bit 6 = Data Direction Control Register for PORTE. TRISE, Bit 5 = Data Direction Control Register for PORTE. TRISE, Bit 4 = Data Direction Control Register for PORTE. TRISE, Bit 3 = Data Direction Control Register for PORTE. TRISE, Bit 2 = Data Direction Control Register for",
    "TABLE 4-3:\nPORTE. TRISE, Bit 1 = Data Direction Control Register for PORTE. TRISE, Bit 0 = Data Direction Control Register for PORTE. TRISE, Value on POR, BOR = 1111 1111. TRISE, Details on page: = 35, 113. TRISD, Bit 7 = Data Direction Control Register for PORTD. TRISD, Bit 6 = Data Direction Control Register for PORTD. TRISD, Bit 5 = Data Direction Control Register for PORTD. TRISD, Bit 4 = Data Direction Control Register for PORTD. TRISD, Bit 3 = Data Direction Control Register for PORTD. TRISD, Bit 2 = Data Direction Control Register for PORTD. TRISD, Bit 1 = Data Direction Control Register for PORTD. TRISD, Bit 0 = Data Direction Control Register for PORTD. TRISD, Value on POR, BOR = 1111 1111. TRISD, Details on page: = 35, 110. TRISC, Bit 7 = Data Direction Control Register for PORTC Data Direction Control Register for PORTB. TRISC, Bit 6 = Data Direction Control Register for PORTC Data Direction Control Register for PORTB. TRISC, Bit 5 = Data Direction Control Register for PORTC Data Direction",
    "TABLE 4-3:\nControl Register for PORTB. TRISC, Bit 4 = Data Direction Control Register for PORTC Data Direction Control Register for PORTB. TRISC, Bit 3 = Data Direction Control Register for PORTC Data Direction Control Register for PORTB. TRISC, Bit 2 = Data Direction Control Register for PORTC Data Direction Control Register for PORTB. TRISC, Bit 1 = Data Direction Control Register for PORTC Data Direction Control Register for PORTB. TRISC, Bit 0 = Data Direction Control Register for PORTC Data Direction Control Register for PORTB. TRISC, Value on POR, BOR = 1111 1111. TRISC, Details on page: = 35, 108. TRISB, Bit 7 = . TRISB, Bit 6 = . TRISB, Bit 5 = . TRISB, Bit 4 = . TRISB, Bit 3 = . TRISB, Bit 2 = . TRISB, Bit 1 = . TRISB, Bit 0 = . TRISB, Value on POR, BOR = 1111 1111. TRISB, Details on page: = 35, 105. TRISA, Bit 7 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 6 = -",
    "TABLE 4-3:\nTRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 5 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 4 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 3 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 2 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 1 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 0 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Value on POR, BOR = -111 1111. TRISA, Details on page: = 35, 121. LATJ (3), Bit 7 = Read PORTJ Data Latch, Write PORTJ Data Latch. LATJ (3), Bit 6 = Read PORTJ Data Latch, Write PORTJ Data Latch. LATJ (3), Bit 5 = Read PORTJ Data Latch, Write PORTJ Data Latch. LATJ (3), Bit 4 = Read PORTJ Data Latch, Write",
    "TABLE 4-3:\nPORTJ Data Latch. LATJ (3), Bit 3 = Read PORTJ Data Latch, Write PORTJ Data Latch. LATJ (3), Bit 2 = Read PORTJ Data Latch, Write PORTJ Data Latch. LATJ (3), Bit 1 = Read PORTJ Data Latch, Write PORTJ Data Latch. LATJ (3), Bit 0 = Read PORTJ Data Latch, Write PORTJ Data Latch. LATJ (3), Value on POR, BOR = xxxx xxxx. LATJ (3), Details on page: = 35, 127. LATH (3), Bit 7 = Read PORTH Data Latch, Write PORTH Data Latch. LATH (3), Bit 6 = Read PORTH Data Latch, Write PORTH Data Latch. LATH (3), Bit 5 = Read PORTH Data Latch, Write PORTH Data Latch. LATH (3), Bit 4 = Read PORTH Data Latch, Write PORTH Data Latch. LATH (3), Bit 3 = Read PORTH Data Latch, Write PORTH Data Latch. LATH (3), Bit 2 = Read PORTH Data Latch, Write PORTH",
    "TABLE 4-3:\nData Latch. LATH (3), Bit 1 = Read PORTH Data Latch, Write PORTH Data Latch. LATH (3), Bit 0 = Read PORTH Data Latch, Write PORTH Data Latch. LATH (3), Value on POR, BOR = xxxx xxxx. LATH (3), Details on page: = 35, 124. LATG, Bit 7 = - Read PORTG Data Latch, Write PORTG Data Latch. LATG, Bit 6 = - Read PORTG Data Latch, Write PORTG Data Latch. LATG, Bit 5 = - Read PORTG Data Latch, Write PORTG Data Latch. LATG, Bit 4 = - Read PORTG Data Latch, Write PORTG Data Latch. LATG, Bit 3 = - Read PORTG Data Latch, Write PORTG Data Latch. LATG, Bit 2 = - Read PORTG Data Latch, Write PORTG Data Latch. LATG, Bit 1 = - Read PORTG Data Latch, Write PORTG Data Latch. LATG, Bit 0 = - Read PORTG Data Latch, Write PORTG Data Latch. LATG, Value on POR, BOR =",
    "TABLE 4-3:\n---x xxxx. LATG, Details on page: = 35, 121. LATF, Bit 7 = . LATF, Bit 6 = -. LATF, Bit 5 = -. LATF, Bit 4 = . LATF, Bit 3 = . LATF, Bit 2 = . LATF, Bit 1 = . LATF, Bit 0 = . LATF, Value on POR, BOR = . LATF, Details on page: = . , Bit 7 = Read PORTF Data Latch, Write PORTF Data Latch. , Bit 6 = Read PORTF Data Latch, Write PORTF Data Latch. , Bit 5 = Read PORTF Data Latch, Write PORTF Data Latch. , Bit 4 = Read PORTF Data Latch, Write PORTF Data Latch. , Bit 3 = Read PORTF Data Latch, Write PORTF Data Latch. , Bit 2 = Read PORTF Data Latch, Write PORTF Data Latch. , Bit 1 = Read PORTF Data Latch, Write PORTF Data Latch. , Bit 0 = Read PORTF Data Latch, Write PORTF Data Latch. , Value on POR, BOR = xxxx xxxx. , Details on page: = 35, 119 35,",
    "TABLE 4-3:\n116. LATE, Bit 7 = Read PORTE Data Latch, Write PORTE Data Latch. LATE, Bit 6 = Read PORTE Data Latch, Write PORTE Data Latch. LATE, Bit 5 = Read PORTE Data Latch, Write PORTE Data Latch. LATE, Bit 4 = Read PORTE Data Latch, Write PORTE Data Latch. LATE, Bit 3 = Read PORTE Data Latch, Write PORTE Data Latch. LATE, Bit 2 = Read PORTE Data Latch, Write PORTE Data Latch. LATE, Bit 1 = Read PORTE Data Latch, Write PORTE Data Latch. LATE, Bit 0 = Read PORTE Data Latch, Write PORTE Data Latch. LATE, Value on POR, BOR = xxxx xxxx. LATE, Details on page: = . LATD LATC, Bit 7 = Read PORTD Data Latch, Write PORTD Data Latch Read PORTC. LATD LATC, Bit 6 = Data Latch,. LATD LATC, Bit 5 = Write PORTC. LATD LATC, Bit 4 = Data Latch. LATD LATC, Bit 3 = Read PORTD Data Latch, Write PORTD Data Latch Read PORTC. LATD LATC, Bit 2 = Read PORTD Data Latch, Write PORTD Data Latch Read",
    "TABLE 4-3:\nPORTC. LATD LATC, Bit 1 = Read PORTD Data Latch, Write PORTD Data Latch Read PORTC. LATD LATC, Bit 0 = Read PORTD Data Latch, Write PORTD Data Latch Read PORTC. LATD LATC, Value on POR, BOR = xxxx xxxx xxxx xxxx xxxx xxxx. LATD LATC, Details on page: = 35, 113 35, 110 35, 108. LATB, Bit 7 = Read PORTB - LATA6 Read PORTA Data Latch, Write PORTA Data Latch. LATB, Bit 6 = Data Latch,. LATB, Bit 5 = Write PORTB. LATB, Bit 4 = Data Latch. LATB, Bit 3 = Read PORTB - LATA6 Read PORTA Data Latch, Write PORTA Data Latch. LATB, Bit 2 = Read PORTB - LATA6 Read PORTA Data Latch, Write PORTA Data Latch. LATB, Bit 1 = Read PORTB - LATA6 Read PORTA Data Latch, Write PORTA Data Latch. LATB, Bit 0 = Read PORTB - LATA6 Read PORTA",
    "TABLE 4-3:\nData Latch, Write PORTA Data Latch. LATB, Value on POR, BOR = -xxx. LATB, Details on page: = 35, 105. LATA, Bit 7 = (1) (1). LATA, Bit 6 = (1) (1). LATA, Bit 5 = (1) (1). LATA, Bit 4 = (1) (1). LATA, Bit 3 = (1) (1). LATA, Bit 2 = (1) (1). LATA, Bit 1 = (1) (1). LATA, Bit 0 = (1) (1). LATA, Value on POR, BOR = xxxx. LATA, Details on page: = ",
    "REGISTER FILE SUMMARY (CONTINUED)\n- Legend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote\n1: RA6 and associated bits are configured as a port pin in RCIO and ECIO Oscillator modes only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6525/6621 devices and read as ' 0 '.\n4: RG5 is available only if MCLR function is disabled in configuration.\n5: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPORTJ (3), Bit 7 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 6 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 5 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 4 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 3 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 2 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 1 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 0 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Value on POR, BOR = xxxx xxxx. PORTJ (3), Details on page: = 35, 127. PORTH (3), Bit 7 = Read PORTH pins, Write PORTH Data Latch. PORTH (3), Bit 6 = Read PORTH pins, Write PORTH Data Latch. PORTH (3), Bit 5 = Read PORTH",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\npins, Write PORTH Data Latch. PORTH (3), Bit 4 = Read PORTH pins, Write PORTH Data Latch. PORTH (3), Bit 3 = Read PORTH pins, Write PORTH Data Latch. PORTH (3), Bit 2 = Read PORTH pins, Write PORTH Data Latch. PORTH (3), Bit 1 = Read PORTH pins, Write PORTH Data Latch. PORTH (3), Bit 0 = Read PORTH pins, Write PORTH Data Latch. PORTH (3), Value on POR, BOR = 0000 xxxx. PORTH (3), Details on page: = 35, 124. PORTG, Bit 7 = -. PORTG, Bit 6 = -. PORTG, Bit 5 = RG5 (4). PORTG, Bit 4 = Read PORTG pins, Write PORTG Data Latch. PORTG, Bit 3 = Read PORTG pins, Write PORTG Data Latch. PORTG, Bit 2 = Read PORTG pins, Write PORTG Data Latch. PORTG, Bit 1 = Read PORTG pins, Write PORTG Data Latch. PORTG, Bit 0 = Read",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPORTG pins, Write PORTG Data Latch. PORTG, Value on POR, BOR = --xx xxxx. PORTG, Details on page: = 36, 121. PORTF, Bit 7 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 6 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 5 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 4 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 3 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 2 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 1 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 0 = Read PORTF pins, Write PORTF Data Latch. PORTF, Value on POR, BOR = x000 0000. PORTF, Details on page: = 36, 119. PORTE, Bit 7 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 6 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 5 = Read PORTE pins, Write PORTE Data Latch.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPORTE, Bit 4 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 3 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 2 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 1 = Read PORTE pins, Write PORTE Data Latch. PORTE, Bit 0 = Read PORTE pins, Write PORTE Data Latch. PORTE, Value on POR, BOR = xxxx xxxx. PORTE, Details on page: = 36, 116. PORTD, Bit 7 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 6 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 5 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 4 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 3 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 2 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 1 = Read PORTD pins, Write PORTD Data Latch. PORTD, Bit 0 = Read PORTD pins, Write PORTD Data Latch. PORTD, Value on POR, BOR = xxxx",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nxxxx. PORTD, Details on page: = 36, 113. PORTC, Bit 7 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 6 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 5 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 4 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 3 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 2 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 1 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 0 = Read PORTC pins, Write PORTC Data Latch. PORTC, Value on POR, BOR = xxxx xxxx. PORTC, Details on page: = 36, 110. PORTB, Bit 7 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 6 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 5 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 4 = Read PORTB pins, Write PORTB Data",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nLatch. PORTB, Bit 3 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 2 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 1 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 0 = Read PORTB pins, Write PORTB Data Latch. PORTB, Value on POR, BOR = xxxx xxxx. PORTB, Details on page: = 36, 108. PORTA, Bit 7 = -. PORTA, Bit 6 = RA6 (1). PORTA, Bit 5 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 4 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 3 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 2 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 1 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 0 = Read PORTA pins, Write PORTA Data Latch (1). PORTA, Value on POR,",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nBOR = -x0x 0000. PORTA, Details on page: = 36, 105. SPBRGH1, Bit 7 = Enhanced USART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 6 = Enhanced USART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 5 = Enhanced USART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 4 = Enhanced USART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 3 = Enhanced USART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 2 = Enhanced USART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 1 = Enhanced USART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 0 = Enhanced USART1 Baud Rate Generator Register High Byte. SPBRGH1, Value on POR, BOR = 0000 0000. SPBRGH1, Details on page: = 36, 217. BAUDCON1, Bit 7 = -. BAUDCON1, Bit 6 = RCIDL. BAUDCON1, Bit 5 = -.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nBAUDCON1, Bit 4 = SCKP. BAUDCON1, Bit 3 = BRG16. BAUDCON1, Bit 2 = -. BAUDCON1, Bit 1 = WUE. BAUDCON1, Bit 0 = ABDEN. BAUDCON1, Value on POR, BOR = -1-0 0-00. BAUDCON1, Details on page: = 36, 216. SPBRGH2, Bit 7 = Enhanced USART2 Baud Rate Generator Register High Byte. SPBRGH2, Bit 6 = Enhanced USART2 Baud Rate Generator Register High Byte. SPBRGH2, Bit 5 = Enhanced USART2 Baud Rate Generator Register High Byte. SPBRGH2, Bit 4 = Enhanced USART2 Baud Rate Generator Register High Byte. SPBRGH2, Bit 3 = Enhanced USART2 Baud Rate Generator Register High Byte. SPBRGH2, Bit 2 = Enhanced USART2 Baud Rate Generator Register High Byte. SPBRGH2, Bit 1 = Enhanced USART2 Baud Rate Generator Register High Byte. SPBRGH2, Bit 0 = Enhanced USART2 Baud Rate",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nGenerator Register High Byte. SPBRGH2, Value on POR, BOR = 0000 0000. SPBRGH2, Details on page: = 36, 217. BAUDCON2, Bit 7 = -. BAUDCON2, Bit 6 = RCIDL. BAUDCON2, Bit 5 = -. BAUDCON2, Bit 4 = SCKP. BAUDCON2, Bit 3 = BRG16. BAUDCON2, Bit 2 = -. BAUDCON2, Bit 1 = WUE. BAUDCON2, Bit 0 = ABDEN. BAUDCON2, Value on POR, BOR = -1-0 0-00. BAUDCON2, Details on page: = 36, 216. ECCP1DEL, Bit 7 = P1RSEN. ECCP1DEL, Bit 6 = P1DC6. ECCP1DEL, Bit 5 = P1DC5. ECCP1DEL, Bit 4 = P1DC4. ECCP1DEL, Bit 3 = P1DC3. ECCP1DEL, Bit 2 = P1DC2. ECCP1DEL, Bit 1 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nP1DC1. ECCP1DEL, Bit 0 = P1DC0. ECCP1DEL, Value on POR, BOR = 0000 0000. ECCP1DEL, Details on page: = 36, 168. TMR4, Bit 7 = Timer4 Register. TMR4, Bit 6 = Timer4 Register. TMR4, Bit 5 = Timer4 Register. TMR4, Bit 4 = Timer4 Register. TMR4, Bit 3 = Timer4 Register. TMR4, Bit 2 = Timer4 Register. TMR4, Bit 1 = Timer4 Register. TMR4, Bit 0 = Timer4 Register. TMR4, Value on POR, BOR = 0000 0000. TMR4, Details on page: = 36, 148. PR4, Bit 7 = Timer4 Period Register. PR4, Bit 6 = Timer4 Period Register. PR4, Bit 5 = Timer4 Period Register. PR4, Bit 4 = Timer4 Period Register. PR4, Bit 3 = Timer4 Period Register. PR4, Bit 2 = Timer4 Period Register. PR4,",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nBit 1 = Timer4 Period Register. PR4, Bit 0 = Timer4 Period Register. PR4, Value on POR, BOR = 1111 1111. PR4, Details on page: = 36, 148. T4CON, Bit 7 = -. T4CON, Bit 6 = T4OUTPS3. T4CON, Bit 5 = T4OUTPS2. T4CON, Bit 4 = T4OUTPS1. T4CON, Bit 3 = T4OUTPS0. T4CON, Bit 2 = TMR4ON. T4CON, Bit 1 = T4CKPS1. T4CON, Bit 0 = T4CKPS0. T4CON, Value on POR, BOR = -000 0000. T4CON, Details on page: = 36, 147. CCPR4H, Bit 7 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 6 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 5 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 4 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCapture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 3 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 2 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 1 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 0 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Value on POR, BOR = xxxx xxxx. CCPR4H, Details on page: = 36, 153. CCPR4L, Bit 7 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 6 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 5 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 4 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 3 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 2 = Capture/Compare/PWM Register 4 Low Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCCPR4L, Bit 1 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 0 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Value on POR, BOR = xxxx xxxx. CCPR4L, Details on page: = 36, 153. CCP4CON, Bit 7 = -. CCP4CON, Bit 6 = -. CCP4CON, Bit 5 = DC4B1. CCP4CON, Bit 4 = DC4B0. CCP4CON, Bit 3 = CCP4M3. CCP4CON, Bit 2 = CCP4M2. CCP4CON, Bit 1 = CCP4M1. CCP4CON, Bit 0 = CCP4M0. CCP4CON, Value on POR, BOR = --00 0000. CCP4CON, Details on page: = 36, 149. CCPR5H, Bit 7 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 6 = Capture/Compare/PWM Register 5 High Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCCPR5H, Bit 5 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 4 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 3 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 2 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 1 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 0 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Value on POR, BOR = xxxx xxxx. CCPR5H, Details on page: = 36, 153. CCPR5L, Bit 7 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 6 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 5 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 4 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 3 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCapture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 2 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 1 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 0 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Value on POR, BOR = xxxx xxxx. CCPR5L, Details on page: = 36, 153. CCP5CON, Bit 7 = -. CCP5CON, Bit 6 = -. CCP5CON, Bit 5 = DC5B1. CCP5CON, Bit 4 = DC5B0. CCP5CON, Bit 3 = CCP5M3. CCP5CON, Bit 2 = CCP5M2. CCP5CON, Bit 1 = CCP5M1. CCP5CON, Bit 0 = CCP5M0. CCP5CON, Value on POR, BOR = --00 0000. CCP5CON, Details on page: = 36, 149. SPBRG2, Bit 7 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nEnhanced USART2 Baud Rate Generator Register Low Byte. SPBRG2, Bit 6 = Enhanced USART2 Baud Rate Generator Register Low Byte. SPBRG2, Bit 5 = Enhanced USART2 Baud Rate Generator Register Low Byte. SPBRG2, Bit 4 = Enhanced USART2 Baud Rate Generator Register Low Byte. SPBRG2, Bit 3 = Enhanced USART2 Baud Rate Generator Register Low Byte. SPBRG2, Bit 2 = Enhanced USART2 Baud Rate Generator Register Low Byte. SPBRG2, Bit 1 = Enhanced USART2 Baud Rate Generator Register Low Byte. SPBRG2, Bit 0 = Enhanced USART2 Baud Rate Generator Register Low Byte. SPBRG2, Value on POR, BOR = 0000 0000. SPBRG2, Details on page: = 36, 217. RCREG2, Bit 7 = Enhanced USART2 Receive Register. RCREG2, Bit 6 = Enhanced USART2 Receive Register. RCREG2, Bit 5 = Enhanced USART2 Receive Register. RCREG2, Bit 4 = Enhanced USART2 Receive Register.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRCREG2, Bit 3 = Enhanced USART2 Receive Register. RCREG2, Bit 2 = Enhanced USART2 Receive Register. RCREG2, Bit 1 = Enhanced USART2 Receive Register. RCREG2, Bit 0 = Enhanced USART2 Receive Register. RCREG2, Value on POR, BOR = 0000 0000. RCREG2, Details on page: = 36, 224. TXREG2, Bit 7 = Enhanced USART2 Transmit Register. TXREG2, Bit 6 = Enhanced USART2 Transmit Register. TXREG2, Bit 5 = Enhanced USART2 Transmit Register. TXREG2, Bit 4 = Enhanced USART2 Transmit Register. TXREG2, Bit 3 = Enhanced USART2 Transmit Register. TXREG2, Bit 2 = Enhanced USART2 Transmit Register. TXREG2, Bit 1 = Enhanced USART2 Transmit Register. TXREG2, Bit 0 = Enhanced USART2 Transmit Register. TXREG2, Value on POR, BOR = 0000 0000. TXREG2, Details on page: = 36, 222.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTXSTA2, Bit 7 = CSRC. TXSTA2, Bit 6 = TX9. TXSTA2, Bit 5 = TXEN. TXSTA2, Bit 4 = SYNC. TXSTA2, Bit 3 = SENDB. TXSTA2, Bit 2 = BRGH. TXSTA2, Bit 1 = TRMT. TXSTA2, Bit 0 = TX9D. TXSTA2, Value on POR, BOR = 0000 0010. TXSTA2, Details on page: = 36, 222. RCSTA2, Bit 7 = SPEN. RCSTA2, Bit 6 = RX9. RCSTA2, Bit 5 = SREN. RCSTA2, Bit 4 = CREN. RCSTA2, Bit 3 = ADDEN. RCSTA2, Bit 2 = FERR. RCSTA2, Bit 1 = OERR. RCSTA2, Bit 0 = RX9D. RCSTA2, Value on POR, BOR = 0000 000x. RCSTA2, Details on page: = 36, 222. ECCP3AS, Bit 7 = ECCP3ASE. ECCP3AS, Bit 6 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nECCP3AS2. ECCP3AS, Bit 5 = ECCP3AS1. ECCP3AS, Bit 4 = ECCP3AS0. ECCP3AS, Bit 3 = PSS3AC1. ECCP3AS, Bit 2 = PSS3AC0. ECCP3AS, Bit 1 = PSS3BD1. ECCP3AS, Bit 0 = PSS3BD0. ECCP3AS, Value on POR, BOR = 0000. ECCP3AS, Details on page: = 36, 169. ECCP3DEL, Bit 7 = P3RSEN. ECCP3DEL, Bit 6 = P3DC6. ECCP3DEL, Bit 5 = P3DC5. ECCP3DEL, Bit 4 = P3DC4. ECCP3DEL, Bit 3 = P3DC3. ECCP3DEL, Bit 2 = P3DC2. ECCP3DEL, Bit 1 = P3DC1. ECCP3DEL, Bit 0 = P3DC0. ECCP3DEL, Value on POR, BOR = 0000 0000 0000.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nECCP3DEL, Details on page: = 36, 168. ECCP2AS, Bit 7 = ECCP2ASE. ECCP2AS, Bit 6 = ECCP2AS2. ECCP2AS, Bit 5 = ECCP2AS1. ECCP2AS, Bit 4 = ECCP2AS0. ECCP2AS, Bit 3 = PSS2AC1. ECCP2AS, Bit 2 = PSS2AC0. ECCP2AS, Bit 1 = PSS2BD1. ECCP2AS, Bit 0 = PSS2BD0. ECCP2AS, Value on POR, BOR = 0000 0000. ECCP2AS, Details on page: = 36, 169. ECCP2DEL, Bit 7 = P2RSEN. ECCP2DEL, Bit 6 = P2DC6. ECCP2DEL, Bit 5 = P2DC5. ECCP2DEL, Bit 4 = P2DC4. ECCP2DEL, Bit 3 = P2DC3. ECCP2DEL, Bit 2 = P2DC2. ECCP2DEL, Bit 1 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nP2DC1. ECCP2DEL, Bit 0 = P2DC0. ECCP2DEL, Value on POR, BOR = 0000 0000. ECCP2DEL, Details on page: = 36, 168\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote\n1: RA6 and associated bits are configured as a port pin in RCIO and ECIO Oscillator modes only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6525/6621 devices and read as ' 0 '.\n4: RG5 is available only if MCLR function is disabled in configuration.\n5: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "4.10 Access Bank\nThe  Access  Bank  is  an  architectural  enhancement, which is very useful for C compiler code optimization. The techniques used by the C compiler may also be useful for programs written in assembly.\nThis data memory region can be used for:\n\u00b7 Intermediate computational values\n\u00b7 Local variables of subroutines\n\u00b7 Faster context saving/switching of variables\n\u00b7 Common variables\n\u00b7 Faster evaluation/control of SFRs (no banking)\nThe Access Bank is comprised of the upper 160 bytes in Bank 15 (SFRs) and the lower 96 bytes in Bank 0. These two sections will be referred to as Access RAM High  and  Access  RAM  Low,  respectively.  Figure 4-7 indicates the Access RAM areas.\nA bit in the instruction word specifies if the operation is to occur in the bank specified by the BSR register or in the Access Bank. This bit is denoted by the 'a' bit (for access bit).\nWhen  forced  in  the  Access  Bank  (a  = 0 ),  the  last address  in  Access  RAM  Low  is  followed  by  the  first address in Access RAM High. Access RAM High maps the Special Function Registers so that these registers can be accessed without any software overhead. This is useful for testing status flags and modifying control bits.",
    "4.11 Bank Select Register (BSR)\nThe need for a large general purpose memory space dictates a RAM banking scheme. The data memory is partitioned into sixteen  banks.  When  using  direct addressing,  the  BSR  should  be  configured  for  the desired bank.\nBSR<3:0> holds  the  upper  4  bits  of  the  12-bit  RAM address. The BSR<7:4> bits will always read ' 0 's and writes will have no effect.\nA MOVLB instruction has been provided in the instruction set to assist in selecting banks.\nIf the currently selected bank is not implemented, any read will return all ' 0 's and all writes are ignored. The STATUS register bits will be set/cleared as appropriate for the instruction performed.\nEach  Bank  extends  up  to  FFh  (256  bytes).  All  data memory is implemented as static RAM.\nA MOVFF instruction ignores the BSR since the 12-bit addresses are embedded into the instruction word.\nSection 4.12  'Indirect  Addressing, INDF  and  FSR Registers' provides a description of indirect addressing which allows linear addressing of the entire RAM space.",
    "FIGURE 4-8: DIRECT ADDRESSING\nNote 1: For register file map detail, see Table 4-2.\n2: The access bit of the instruction can be used to force an override of the selected bank (BSR<3:0>) to the registers of the Access Bank.\n3: The MOVFF instruction embeds the entire 12-bit address in the instruction.",
    "4.12 Indirect Addressing, INDF and FSR Registers\nIndirect addressing is a mode of addressing data memory, where the data memory address in the instruction is not fixed. An FSR register is used as a pointer to the data memory location that is to be read or written. Since this pointer is in RAM, the contents can be modified by the program. This can be useful for data tables in the data  memory  and  for  software  stacks.  Figure 4-9 shows the operation of indirect addressing. This shows the moving of the value to the data memory address specified by the value of the FSR register.\nIndirect addressing is possible by using one of the INDF registers. Any instruction using the INDF  register actually  accesses  the  register  pointed  to  by  the  File Select Register, FSR. Reading the INDF register itself indirectly (FSR = 0 ), will read 00h. Writing to the INDF register indirectly, results in a no operation ( NOP ). The FSR register contains a 12-bit address which is shown in Figure 4-10.\nThe INDFn register is not a physical register. Addressing INDFn  actually  addresses  the  register  whose address is contained in the FSRn register (FSRn is a pointer). This is indirect addressing.",
    "4.12 Indirect Addressing, INDF and FSR Registers\nExample 4-5 shows a simple use of indirect addressing to clear the RAM in Bank 1 (locations 100h-1FFh) in a minimum number of instructions.",
    "EXAMPLE 4-5: HOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nLFSR NEXT CLRF, 1 = FSR0, 0x100 POSTINC0. LFSR NEXT CLRF, 2 = ; ; Clear INDF ; register and ; inc pointer. BTFSS, 1 = FSR0H,. BTFSS, 2 = ; All done with ; Bank1?. GOTO CONTINUE, 1 = NEXT. GOTO CONTINUE, 2 = ; NO, clear next ; YES, continue\nThere  are  three indirect addressing  registers. To address the entire data memory space (4096 bytes), these registers are 12 bits wide. To store the 12 bits of addressing information, two 8-bit registers are required. These indirect addressing registers are:\n1. FSR0: composed of FSR0H:FSR0L\n2. FSR1: composed of FSR1H:FSR1L\n3. FSR2: composed of FSR2H:FSR2L",
    "EXAMPLE 4-5: HOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nIn  addition,  there  are  registers  INDF0,  INDF1  and INDF2, which are not physically implemented. Reading or writing to these registers activates indirect addressing, with the value in the corresponding FSR register being the address of the data. If an instruction writes a value to INDF0, the value will be written to the address pointed to by FSR0H:FSR0L. A read from INDF1 reads the data from the address pointed to by FSR1H:FSR1L. INDFn can be used in code anywhere an operand can be used.\nIf  INDF0,  INDF1  or  INDF2  are  read  indirectly  via  an FSR,  all  ' 0 's  are  read  (zero  bit  is  set).  Similarly,  if INDF0, INDF1 or INDF2 are written to indirectly, the operation will be equivalent to a NOP instruction and the Status bits are not affected.",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nEach  FSR  register  has  an  INDF  register  associated with it, plus four additional register addresses. Performing an operation on one  of these five registers determines  how  the  FSR  will  be  modified  during indirect addressing.\nWhen data access is done to one of the five INDFn locations, the address selected will configure the FSRn register to:\n\u00b7 Do nothing to FSRn after an indirect access (no change) - INDFn.\n\u00b7 Auto-decrement FSRn after an indirect access (post-decrement) - POSTDECn.\n\u00b7 Auto-increment FSRn after an indirect access (post-increment) - POSTINCn.\n\u00b7 Auto-increment FSRn before an indirect access (pre-increment) - PREINCn.\n\u00b7 Use the value in the WREG register as an offset to FSRn. Do not modify the value of the WREG or the FSRn register after an indirect access (no change) - PLUSWn.",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nWhen  using  the  auto-increment  or  auto-decrement features, the effect on the FSR is not reflected in the STATUS register. For example, if the indirect address causes the FSR to equal ' 0 ', the Z bit will not be set.\nIncrementing  or  decrementing  an  FSR  affects  all 12 bits. That  is, when  FSRnL  overflows  from  an increment, FSRnH will be incremented automatically.\nAdding these features allows the FSRn to be used as a Stack Pointer in addition to its uses for table operations in data memory.\nEach  FSR  has  an  address  associated  with  it  that performs  an  indexed  indirect  access.  When  a  data access to this INDFn location (PLUSWn) occurs, the FSRn  is  configured  to  add  the  signed  value  in  the WREG  register  and  the  value  in  FSR  to  form  the address before an indirect access. The FSR value is not changed.\nIf an FSR register contains a value that points to one of the INDFn, an indirect read will read 00h (zero bit is set), while an indirect write will be equivalent to a NOP (Status bits are not affected).",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nIf  an indirect addressing operation is done where the target address  is an FSRnH  or  FSRnL  register, the write  operation  will  dominate  over  the  pre-  or post-increment/decrement functions.",
    "4.13 STATUS Register\nThe STATUS register, shown in Register 4-3, contains the arithmetic status of the ALU. As with any other SFR, it can be the operand for any instruction.\nIt is recommended that only BCF BSF SWAPF MOVFF , , , and MOVWF instructions are used to alter the STATUS register, because these instructions do not affect the Z, C, DC, OV or N bits in the STATUS register.\nIf the STATUS register is the destination for an instruction that affects the Z, DC, C, OV or N bits, the results of the  instruction  are  not  written;  instead,  the  status  is updated according to the instruction performed. Therefore, the result of an instruction with the STATUS register as its destination may be different than intended. As an example, CLRF STATUS will set the Z bit and leave the remaining Status bits unchanged (' 000u u1uu ').\nFor other instructions that do not affect Status bits, see the instruction set summaries in Table 25-2.\nNote:\nThe C and DC bits operate as the borrow and digit borrow bits respectively in subtraction.",
    "REGISTER 4-3: STATUS REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-x. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = -. -, 2 = -. -, 3 = N. -, 4 = OV. -, 5 = Z. -, 6 = DC. -, 7 = C\nbit 7\nbit 0",
    "bit 4 N: Negative bit\nThis bit is used for signed arithmetic (2's complement). It indicates whether the result was negative (ALU MSB = 1 ).\n1 = Result was negative\n0 = Result was positive",
    "bit 3 OV: Overflow bit\nThis bit is used for signed arithmetic (2's complement). It indicates an overflow of the 7-bit magnitude which causes the sign bit (bit 7) to change state.\n1 = Overflow occurred for signed arithmetic (in this arithmetic operation)\n0 = No overflow occurred",
    "bit 2 Z: Zero bit\n1 = The result of an arithmetic or logic operation is zero\n0 = The result of an arithmetic or logic operation is not zero\nDC: Digit Carry/Borrow bit\nFor ADDWF ADDLW SUBLW , , and SUBWF instructions:\n1 = A carry-out from the 4th low-order bit of the result occurred\n0 = No carry-out from the 4th low-order bit of the result\nNote:\nFor  borrow,  the  polarity  is  reversed.  A  subtraction  is  executed  by  adding  the 2's complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either bit 4 or bit 3 of the source register.",
    "bit 0 C: Carry/Borrow bit\nFor ADDWF ADDLW SUBLW , , and SUBWF instructions:\n1 = A carry-out from the Most Significant bit of the result occurred\n0 = No carry-out from the Most Significant bit of the result occurred\nNote:\nFor  borrow,  the  polarity  is  reversed.  A  subtraction  is  executed  by  adding  the 2's complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either the high- or low-order bit of the source register.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "4.14 RCON Register\nThe Reset Control (RCON) register contains flag bits that  allow  differentiation  between  the  sources  of  a device Reset. These flags include the TO, PD, POR, BOR and RI bits. This register is readable and writable.\nNote:\nIt is recommended that the POR bit be set after a Power-on Reset has been detected,  so  that  subsequent  Power-on Resets may be detected.",
    "REGISTER 4-4: RCON: RESET CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R/W-1. R/W-0, 5 = R/W-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0",
    "bit 7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16CXXX Compatibility mode)",
    "bit 4 RI: RESET Instruction Flag bit\n1 = The RESET instruction was not executed\n0 = The RESET instruction was executed causing a device Reset\n(must be set in software after a Brown-out Reset occurs)",
    "bit 3 TO: Watchdog Time-out Flag bit\n1 = After power-up, CLRWDT instruction or SLEEP instruction\n0 = A WDT time-out occurred\nPD: Power-down Detection Flag bit\n1 = After power-up or by the CLRWDT instruction\n0 = By execution of the SLEEP instruction",
    "bit 1 POR: Power-on Reset Status bit\n1 = A Power-on Reset has not occurred\n0 = A Power-on Reset occurred\n(must be set in software after a Power-on Reset occurs)",
    "bit 0 BOR: Brown-out Reset Status bit\n1 = A Brown-out Reset has not occurred\n0 = A Brown-out Reset occurred\n(must be set in software after a Brown-out Reset occurs)",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "5.1 Table Reads and Table Writes\nThe Flash program memory is readable, writable and erasable, during normal operation over the entire VDD range.\nA read from program memory is executed on one byte at a time. A write to program memory is executed on blocks of 8 bytes at a time. Program memory is erased in blocks of 64 bytes at a time. A bulk erase operation may not be issued from user code.\nWriting or erasing program memory will cease instruction fetches until the operation  is complete.  The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming timer terminates program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing  a  program  memory location  that  forms  an  invalid  instruction  results  in  a NOP .\nIn order to read and write program memory, there are two operations that allow the processor to move bytes between the program memory space and the data RAM:\n\u00b7 Table Read ( TBLRD )\n\u00b7 Table Write ( TBLWT )\nThe program memory space is 16 bits wide, while the data RAM space is 8 bits wide. Table reads and table writes move data between these two memory spaces through an 8-bit register (TABLAT).",
    "5.1 Table Reads and Table Writes\nTable  read  operations  retrieve  data  from  program memory  and  place  it  into  the  data  RAM  space. Figure 5-1  shows  the  operation  of  a  table  read  with program memory and data RAM.\nTable write operations store data from the data memory space  into  holding  registers  in  program  memory.  The procedure to write the contents of the holding registers into program memory is detailed in Section 5.5 'Writing  to Flash  Program  Memory' . Figure 5-2 shows  the  operation  of  a  table  write  with  program memory and data RAM.\nTable operations work with byte entities. A table block containing data, rather than program instructions, is not required to be word aligned. Therefore, a table block can start and end at any byte address. If a table write is being used  to  write  executable  code  into  program  memory, program instructions will need to be word aligned.",
    "5.2 Control Registers\nSeveral control registers are used in conjunction with the TBLRD and TBLWT instructions. These include the:\nThe FREE bit, when set, will allow a program memory erase operation. When the FREE bit is set, the erase operation is initiated on the next WR command. When FREE is clear, only writes are enabled.\n\u00b7 EECON1 register\n\u00b7 EECON2 register\n\u00b7 TABLAT register\n\u00b7 TBLPTR registers",
    "5.2.1 EECON1 AND EECON2 REGISTERS\nEECON1 is the control register for memory accesses.\nEECON2 is not a physical register. Reading EECON2 will read  all ' 0 's. The  EECON2  register  is  used exclusively in the memory write and erase sequences.\nControl bit, EEPGD, determines if the access will be a program  or  data  EEPROM  memory  access.  When clear,  any  subsequent operations will operate on the data  EEPROM  memory.  When  set,  any  subsequent operations will operate on the program memory.\nControl bit, CFGS, determines if the access will be to the  Configuration/Calibration  registers  or  to  program memory/data EEPROM memory. When set, subsequent  operations  will  operate  on  Configuration registers  regardless  of  EEPGD  (see Section 24.0 'Special Features of the CPU' ). When clear, memory selection access is determined by EEPGD.",
    "5.2.1 EECON1 AND EECON2 REGISTERS\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear. The WRERR bit is set when a write operation is interrupted by a MCLR Reset or a WDT Time-out Reset during normal operation. In these  situations,  the  user  can  check  the WRERR bit and rewrite the location. It is necessary to reload  the  data  and  address  registers  (EEDATA  and EEADR) due to Reset values of zero.",
    "Note:\nDuring normal operation, the WRERR bit is read as ' 1 '. This can indicate that a write operation was prematurely terminated by a Reset, or a write operation was attempted improperly.\nThe WR control bit initiates  write operations. The  bit cannot be cleared, only set, in software; it is cleared in hardware at the completion of the write operation. The inability  to  clear  the  WR  bit  in  software  prevents  the accidental or premature termination of a write operation.\nNote:, 1 = Interrupt flag bit, EEIF in the PIR2 register, is set when the write is complete. It must be cleared in software.",
    "EECON1 REGISTER (ADDRESS FA6h)\nR/W-x, 1 = R/W-x. R/W-x, 2 = U-0. R/W-x, 3 = R/W-0. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-0. R/W-x, 6 = R/S-0. R/W-x, 7 = R/S-0. EEPGD, 1 = CFGS. EEPGD, 2 = -. EEPGD, 3 = FREE. EEPGD, 4 = WRERR. EEPGD, 5 = WREN. EEPGD, 6 = WR. EEPGD, 7 = RD\nbit 7\nbit 0",
    "bit 7 EEPGD: Flash Program or Data EEPROM Memory Select bit\n1 = Access Flash program memory\n0 = Access data EEPROM memory",
    "bit 6 CFGS: Flash Program/Data EEPROM or Configuration Select bit\n1 = Access Configuration registers\n0 = Access Flash program or data EEPROM memory",
    "bit 4 FREE: Flash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation)\n0 = Perform write only",
    "bit 3 WRERR: Flash Program/Data EEPROM Error Flag bit\n1 = A write operation is prematurely terminated\n(any Reset during self-timed programming in normal operation)\n0 = The write operation completed\nNote:\nWhen a WRERR occurs, the EEPGD and CFGS bits are not cleared. This allows tracing of the error condition.",
    "bit 2 WREN: Flash Program/Data EEPROM Write Enable bit\n1 = Allows write cycles to Flash program/data EEPROM\n0 = Inhibits write cycles to Flash program/data EEPROM\nWR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle. (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle to the EEPROM is complete",
    "bit 0 RD: Read Control bit\n1 =\n(Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared)\nInitiates an EEPROM read in software. RD bit cannot be set when EEPGD = 1 .)\n0 = Does not initiate an EEPROM read\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "5.2.4 TABLE POINTER BOUNDARIES\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch register is used to hold 8-bit data during data transfers between program memory and data RAM.",
    "5.2.3 TBLPTR - TABLE POINTER REGISTER\nThe Table Pointer register (TBLPTR) addresses a byte within the program memory. The TBLPTR is comprised of three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL).  These  three  registers join  to  form a  22-bit  wide  pointer.  The  low-order 21 bits allow the device to address up to 2 Mbytes of program memory space. The 22nd bit allows access to the device ID, the user ID and the configuration bits.\nTBLPTR is  used  in  reads,  writes  and  erases  of  the Flash program memory.\nWhen a TBLRD is executed, all 22 bits of the TBLPTR determine  which  byte  is  read  from  program  memory into TABLAT.",
    "5.2.3 TBLPTR - TABLE POINTER REGISTER\nWhen a TBLWT is executed, the three LSbs of the Table Pointer register (TBLPTR<2:0>) determine which of the eight program memory holding registers is written to. When the timed write to program memory (long write) begins, the 19 MSbs of the TBLPTR (TBLPTR<21:3>) will determine which program memory block of 8 bytes is written to. For more detail, see Section 5.5 'Writing to Flash Program Memory' .\nThe Table Pointer, TBLPTR, is used by the TBLRD and TBLWT instructions. These instructions can update the TBLPTR in one of four ways based on the table operation. These operations are shown in Table 5-1. These operations  on  the  TBLPTR  only  affect  the  low-order 21 bits.\nWhen an erase of program memory is executed, the 16 MSbs of the Table Pointer register (TBLPTR<21:6>) point to the 64-byte block that will be erased. The Least Significant bits (TBLPTR<5:0>) are ignored.",
    "5.2.3 TBLPTR - TABLE POINTER REGISTER\nFigure 5-3 describes the relevant boundaries of TBLPTR based on Flash program memory operations.",
    "TABLE 5-1: TABLE POINTER OPERATIONS WITH TBLRD AND TBLWT INSTRUCTIONS\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "5.3 Reading the Flash Program Memory\nThe TBLRD instruction  is  used  to  retrieve  data  from program memory and places it into data RAM. Table reads from program memory are performed one byte at a time.\nTBLPTR points to a byte address in program space. Executing TBLRD places  the  byte  pointed  to  into TABLAT. In addition, TBLPTR can be modified automatically for the next table read operation.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. Figure 5-4 shows  the  interface  between  the  internal  program memory and the TABLAT.",
    "EXAMPLE 5-1: READING A FLASH PROGRAM MEMORY WORD\n, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. , 2 = CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL. READ_WORD, 1 = READ_WORD. READ_WORD, 2 = READ_WORD. , 1 = TBLRD*+ MOVF MOVWF TBLRD*+ MOVFW MOVWF. , 2 = TABLAT, W WORD_EVEN TABLAT, W WORD_ODD",
    "5.4 Erasing Flash Program Memory\nThe minimum erase block is 32 words or 64 bytes. Only through the use of an external programmer, or through ICSP control, can larger blocks of program memory be bulk  erased.  Word  erase  in  the  Flash  array  is  not supported.\nWhen  initiating  an  erase  sequence  from  the  microcontroller itself, a block of 64 bytes of program memory is erased. The Most Significant 16 bits of the TBLPTR<21:6>  point  to  the block being erased. TBLPTR<5:0> are ignored.\nThe EECON1 register commands the erase operation. The  EEPGD  bit  must  be  set  to  point  to  the  Flash program memory. The WREN bit must be set to enable write operations. The FREE bit is set to select an erase operation.\nFor protection, the write initiate sequence for EECON2 must be used.",
    "5.4.1 FLASH PROGRAM MEMORY ERASE SEQUENCE\nThe sequence of events for erasing a block of internal program memory location is:\n1. Load Table Pointer register with address of row being erased.\n2. Set the EECON1 register for the erase operation:\n\u00b7 set EEPGD bit to point to program memory;\n\u00b7 clear the CFGS bit to access program memory;\n\u00b7 set WREN bit to enable writes;\n\u00b7 set FREE bit to enable the erase.\n3. Disable interrupts.\n4. Write 55h to EECON2.\n5. Write AAh to EECON2.\n6. Set  the  WR  bit.  This  will  begin  the  row  erase cycle.\nA long write is necessary for erasing the internal Flash. Instruction  execution  is  halted  while  in  a  long  write cycle. The long write will be terminated by the internal programming timer.\n7. The  CPU  will  stall  for  duration  of  the  erase (about 2 ms using internal timer).\n8. Re-enable interrupts.",
    "EXAMPLE 5-2: ERASING A FLASH PROGRAM MEMORY ROW\nERASE_ROW, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF BSF. ERASE_ROW, 2 = CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL. ERASE_ROW, 3 = ; load TBLPTR with the base ; address of the memory block. ERASE_ROW, 1 = BCF BSF. ERASE_ROW, 2 = EECON1, EEPGD EECON1, CFGS EECON1, WREN FREE. ERASE_ROW, 3 = ; point to Flash program memory ; access Flash program memory ; enable write to memory ; enable Row Erase operation. ERASE_ROW, 1 = BCF. ERASE_ROW, 2 = GIE. ERASE_ROW, 3 = . ERASE_ROW, 1 = BSF. ERASE_ROW, 2 = EECON1,. ERASE_ROW, 3 = . ERASE_ROW, 1 = . ERASE_ROW, 2 = . ERASE_ROW, 3 = ; disable interrupts. ERASE_ROW, 1 = .",
    "EXAMPLE 5-2: ERASING A FLASH PROGRAM MEMORY ROW\nERASE_ROW, 2 = INTCON,. ERASE_ROW, 3 = . , 1 = MOVLW. , 2 = 55h EECON2. , 3 = ; write 55h. , 1 = MOVWF MOVLW MOVWF. , 2 = AAh EECON2. , 3 = ; write AAh. , 1 = BSF. , 2 = EECON1, WR GIE. , 3 = ; start erase (CPU stall). , 1 = BSF. , 2 = INTCON,. , 3 = ; re-enable interrupts",
    "5.5 Writing to Flash Program Memory\nThe minimum programming block is 4 words or 8 bytes. Word or byte programming is not supported.\nthe holding registers are written. At the end of updating 8 registers, the EECON1 register must be written to, to start the programming operation with a long write.\nTable  writes  are  used  internally  to  load  the  holding registers needed to program the Flash memory. There are  8  holding  registers  used  by  the  table  writes  for programming.\nThe  long  write  is  necessary  for  programming  the internal Flash. Instruction execution is halted while in a long write cycle. The long write will be terminated by the internal programming timer.\nSince the Table Latch (TABLAT) is only a single byte, the TBLWT instruction has to be executed 8 times for each  programming  operation.  All  of  the  table  write operations will essentially be short writes because only\nThe  EEPROM  on-chip  timer  controls  the  write  time. The write/erase voltages are generated by an on-chip charge pump, rated to operate over the voltage range of the device for byte or word operations.",
    "5.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThe sequence of events for programming an internal program memory location should be:\n1. Read 64 bytes into RAM.\n2. Update data values in RAM as necessary.\n3. Load Table Pointer register with address being erased.\n4. Do the row erase procedure.\n5. Load Table Pointer register with address of first byte being written.\n6. Write the first 8 bytes into the holding registers with auto-increment.\n7. Set the EECON1 register for the write operation:\n\u00b7 set EEPGD bit to point to program memory;\n\u00b7 clear the CFGS bit to access program memory;\n\u00b7 set WREN to enable byte writes.\n8. Disable interrupts.\n9. Write 55h to EECON2.\n10. Write AAh to EECON2.\n11. Set the WR bit. This will begin the write cycle.\n12. The CPU will stall for duration of the write (about 2 ms using internal timer).\n13. Re-enable interrupts.\n14. Repeat steps 6-14 seven times to write 64 bytes.\n15. Verify the memory (table read).",
    "5.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThis procedure will require about 18 ms to update one row of 64 bytes of memory. An example of the required code is given in Example 5-3.",
    "Note:\nBefore  setting the WR  bit, the Table Pointer  address  needs  to  be  within  the intended address range of the eight bytes in the holding register.",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\n, MOVLW = MOVWF. , D'64 = COUNTER. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = BUFFER_ADDR_HIGH. , ; number of bytes in erase block = ; point to buffer. , MOVLW = MOVWF. , D'64 = FSR0H. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = BUFFER_ADDR_LOW. , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = FSR0L. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = CODE_ADDR_UPPER. , ; number of bytes in erase block = ; Load TBLPTR with the base. , MOVLW = MOVWF. , D'64 = TBLPTRU. , ; number of bytes in erase block = ; address of the memory block. , MOVLW =",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\nMOVLW. , D'64 = CODE_ADDR_HIGH. , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = TBLPTRH. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = CODE_ADDR_LOW. , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = TBLPTRL. , ; number of bytes in erase block = . READ_BLOCK, MOVLW = . READ_BLOCK, D'64 = . READ_BLOCK, ; number of bytes in erase block = . , MOVLW = TBLRD*+. , D'64 = . , ; number of bytes in erase block = ; read into TABLAT, and inc. , MOVLW = MOVF. , D'64 = TABLAT, W. , ; number of bytes in erase block = ; get data. , MOVLW = MOVWF. , D'64 = POSTINC0. , ;",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\nnumber of bytes in erase block = ; store data. , MOVLW = DECFSZ. , D'64 = COUNTER. , ; number of bytes in erase block = ; done?. , MOVLW = BRA. , D'64 = READ_BLOCK. , ; number of bytes in erase block = ; repeat. MODIFY_WORD, MOVLW = . MODIFY_WORD, D'64 = . MODIFY_WORD, ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = DATA_ADDR_HIGH. , ; number of bytes in erase block = point to buffer. , MOVLW = MOVWF. , D'64 = FSR0H. , ; number of bytes in erase block = ;. , MOVLW = MOVLW. , D'64 = DATA_ADDR_LOW. , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = FSR0L. , ; number of bytes in erase block = . , MOVLW = . , D'64 =",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\n. , ; number of bytes in erase block = ;. , MOVLW = MOVLW. , D'64 = NEW_DATA_LOW. , ; number of bytes in erase block = update buffer word. , MOVLW = MOVWF. , D'64 = POSTINC0. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = NEW_DATA_HIGH. , ; number of bytes in erase block = . ERASE_BLOCK, MOVLW = MOVWF. ERASE_BLOCK, D'64 = . ERASE_BLOCK, ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = CODE_ADDR_UPPER. , ; number of bytes in erase block = ; load TBLPTR with the base. , MOVLW = MOVWF. , D'64 = TBLPTRU. , ; number of bytes in erase block = ; address of the memory block. , MOVLW = MOVLW. , D'64 =",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\nCODE_ADDR_HIGH. , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = TBLPTRH. , ; number of bytes in erase block = . , MOVLW = . , D'64 = CODE_ADDR_LOW. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = . , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = TBLPTRL. , ; number of bytes in erase block = . , MOVLW = BSF. , D'64 = EECON1, EEPGD. , ; number of bytes in erase block = ; point to Flash program memory. , MOVLW = BCF. , D'64 = EECON1, CFGS. , ; number of bytes in erase block = ; access Flash program memory. , MOVLW = BSF. , D'64 = EECON1, WREN. , ; number of bytes in erase block = ; enable write to memory. ,",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\nMOVLW = BSF. , D'64 = EECON1, FREE. , ; number of bytes in erase block = ; enable Row Erase operation. , MOVLW = BCF. , D'64 = INTCON, GIE. , ; number of bytes in erase block = ; disable interrupts. , MOVLW = MOVLW. , D'64 = 55h. , ; number of bytes in erase block = . Required, MOVLW = MOVWF. Required, D'64 = EECON2. Required, ; number of bytes in erase block = ; write 55h. Sequence, MOVLW = MOVLW. Sequence, D'64 = AAh. Sequence, ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = EECON2. , ; number of bytes in erase block = . , MOVLW = BSF. , D'64 = EECON1, WR. , ; number of bytes in erase block = ; write AAh ; start erase (CPU stall). , MOVLW =",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\nBSF. , D'64 = INTCON, GIE. , ; number of bytes in erase block = ; re-enable interrupts. , MOVLW = TBLRD*-. , D'64 = . , ; number of bytes in erase block = ; dummy read decrement. WRITE_BUFFER_BACK, MOVLW = . WRITE_BUFFER_BACK, D'64 = . WRITE_BUFFER_BACK, ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = 8. , ; number of bytes in erase block = ; number of write buffer groups of 8 bytes. , MOVLW = MOVWF. , D'64 = COUNTER_HI. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = BUFFER_ADDR_HIGH. , ; number of bytes in erase block = ; point to buffer. , MOVLW = MOVWF. , D'64 = FSR0H. , ; number of bytes in erase block = . , MOVLW =",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\nMOVLW. , D'64 = BUFFER_ADDR_LOW. , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = FSR0L. , ; number of bytes in erase block = . PROGRAM_LOOP, MOVLW = . PROGRAM_LOOP, D'64 = . PROGRAM_LOOP, ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = 8. , ; number of bytes in erase block = ; number of bytes in holding register. , MOVLW = MOVWF. , D'64 = COUNTER. , ; number of bytes in erase block = . WRITE_WORD_TO_HREGS, MOVLW = . WRITE_WORD_TO_HREGS, D'64 = . WRITE_WORD_TO_HREGS, ; number of bytes in erase block = . , MOVLW = MOVFF. , D'64 = POSTINC0, WREG. , ; number of bytes in erase block = ; get low byte of buffer data. ,",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\nMOVLW = TBLWT+*. , D'64 = . , ; number of bytes in erase block = ; present data to table latch ; write data, perform a short. , MOVLW = . , D'64 = . , ; number of bytes in erase block = write ; to internal TBLWT holding register.. , MOVLW = DECFSZ BRA. , D'64 = COUNTER WRITE_WORD_TO_HREGS. , ; number of bytes in erase block = ; loop until buffers are full",
    "WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\nPROGRAM_MEMORY, 1 = PROGRAM_MEMORY. , 1 = BSF EECON1, EEPGD ; point to Flash program memory. , 1 = BCF EECON1, CFGS ; access Flash program memory. , 1 = BSF EECON1, WREN ; enable write to memory. , 1 = BCF INTCON, GIE ; disable interrupts. , 1 = MOVLW 55h. Required, 1 = MOVWF EECON2 ; write 55h. Sequence, 1 = MOVLW AAh. , 1 = MOVWF EECON2 ; write AAh. , 1 = BSF EECON1, WR ; start program (CPU stall). BSF, 1 = INTCON, GIE ; re-enable interrupts. , 1 = DECFSZ COUNTER_HI ; loop until done. , 1 = EECON1, WREN ; disable write to memory. , 1 = BCF",
    "5.5.2 WRITE VERIFY\nDepending  on  the  application,  good  programming practice  may  dictate  that  the  value  written  to  the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "5.5.3 UNEXPECTED TERMINATION OF WRITE OPERATION\nIf a write is terminated by an unplanned event, such as loss  of  power  or  an  unexpected  Reset,  the  memory location just programmed should be verified and reprogrammed  if  needed.  The  WRERR  bit  is  set  when  a write  operation  is  interrupted  by  a  MCLR  Reset  or  a WDT Time-out Reset during normal operation. In these situations, users can check the WRERR bit and rewrite the location.",
    "5.5.4 PROTECTION AGAINST SPURIOUS WRITES\nTo  protect  against  spurious  writes  to  Flash  program memory,  the  write  initiate  sequence  must  also  be followed. See Section 24.0 'Special Features of the CPU' for more detail.",
    "5.6 Flash Program Operation During Code Protection\nSee Section 24.0 'Special Features of the CPU' for details on code protection of Flash program memory.",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nTBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit 21 (1). TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on: POR, BOR all = --00 0000. TBLPTRU, Value on other Resets = --00 0000. TBLPTRU,",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n= . TBLPTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Value on: POR, BOR all = 0000. TBLPTRH, Value on other Resets = 0000 0000. TBLPTRH,",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n= . TBLPTRL, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Value on: POR, BOR all = 0000. TBLPTRL, Value on other Resets = 0000 0000. TBLPTRL,",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n= . TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on: POR, BOR all = 0000 0000. TABLAT, Value on other Resets = 0000 0000. TABLAT,",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n= . INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on: POR, BOR all = 0000 000x. INTCON, Value on other Resets = 0000 000u. INTCON,",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n= . EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Value on: POR, BOR all = -. EECON2, Value on other Resets = -. EECON2,",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n= . EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on: POR, BOR all = xx-0 x000. EECON1, Value on other Resets = uu-0 u000. EECON1,",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n= . IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on: POR, BOR all = -1-1 1111. IPR2, Value on other Resets = -1-1 1111. IPR2,",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n= . PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on: POR, BOR all = -0-0 0000. PIR2, Value on other Resets = -0-0 0000. PIR2,  = . PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on: POR, BOR all = -0-0 0000. PIE2, Value on other Resets = -0-0 0000. PIE2,  = ",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nLegend:\nx = unknown, u = unchanged, r = reserved, - = unimplemented, read as ' 0 '.\nShaded cells are not used during Flash/EEPROM access.\nNote 1: Bit 21 of the TBLPTRU allows access to device configuration bits.",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "6.1 Program Memory Modes and the External Memory Interface\nNote:\nThe external memory interface is not implemented on PIC18F6525/6621 (64-pin) devices.\nThe  external  memory  interface  is  a  feature  of  the PIC18F8525/8621 devices that allows the controller to access  external  memory  devices  (such  as  Flash, EPROM, SRAM, etc.) as program or data memory.\nThe  physical  implementation  of  the  interface  uses 27 pins. These pins are reserved for external address/ data  bus  functions;  they  are  multiplexed  with  I/O  port pins on four ports. Three I/O ports are multiplexed with the address/data bus, while the fourth port is multiplexed with the bus control signals. The I/O port functions are enabled when the EBDIS bit in the MEMCON register is set (see Register 6-1). A list of the multiplexed pins and their functions is provided in Table 6-1.",
    "6.1 Program Memory Modes and the External Memory Interface\nAs implemented in the PIC18F8525/8621 devices, the interface  operates  in  a  similar  manner  to  the  external memory interface introduced on PIC18C601/801 microcontrollers.  The  most  notable  difference  is  that  the interface on PIC18F8525/8621 devices only operates in 16-bit modes. The 8-bit mode is not supported.\nFor a more complete discussion of the operating modes that use  the external memory  interface, refer to Section 4.1.1  'PIC18F6525/6621/8525/8621  Program Memory Modes' .\nAs previously noted, PIC18F8525/8621 controllers are capable of operating in any one of four program memory modes using combinations of on-chip and external program memory. The functions of the multiplexed port pins depends on the program memory mode selected, as well as the setting of the EBDIS bit.",
    "6.1 Program Memory Modes and the External Memory Interface\nIn Microprocessor Mode , the external bus is always active  and  the  port  pins  have  only  the  external  bus function.\nIn Microcontroller  Mode, the  bus  is  not  active  and the  pins  have  their  port  functions  only.  Writes  to  the MEMCOM register are not permitted.\nIn Microprocessor  with  Boot  Block or Extended Microcontroller Mode, the external program memory bus shares I/O port functions on the pins. When the device is fetching or doing table read/table write operations  on  the  external  program  memory  space,  the pins will have the external bus function. If the device is fetching and accessing internal program memory locations only, the EBDIS control bit will change the pins from  external  memory  to  I/O  port  functions.  When EBDIS  = 0 ,  the  pins  function  as  the  external  bus. When EBDIS = 1 , the pins function as I/O ports.",
    "MEMCON: MEMORY CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = U-0. R/W-0, 5 = U-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. EBDIS, 1 = -. EBDIS, 2 = WAIT1. EBDIS, 3 = WAIT0. EBDIS, 4 = -. EBDIS, 5 = -. EBDIS, 6 = WM1. EBDIS, 7 = WM0\nbit 7\nbit 0\nEBDIS : External Bus Disable bit\n1 = External system bus disabled, all external bus drivers are mapped as I/O ports\n0 = External system bus enabled and I/O ports are disabled",
    "bit 6\nUnimplemented : Read as ' 0 '\nbit 5-4 WAIT1:WAIT0 : Table Reads and Writes Bus Cycle Wait Count bits\n11 = Table reads and writes will wait 0 TCY\n10 = Table reads and writes will wait 1 TCY\n01 = Table reads and writes will wait 2 TCY\n00 = Table reads and writes will wait 3 TCY\nbit 3-2 Unimplemented : Read as ' 0 '\nbit 1-0\nWM1:WM0 : TBLWRT Operation with 16-Bit Bus bits\n1x = Word  Write  mode:  TABLAT<0>  and  TABLAT<1>  word  output,  WRH  active  when TABLAT<1> written\n01 = Byte Select mode: TABLAT data copied on both MSB and LSB, WRH and (UB or LB) will activate\n00 = Byte Write mode: TABLAT data copied on both MSB and LSB, WRH or WRL will activate\nNote:\nThe MEMCON register is unimplemented and reads all ' 0 's when the device is in Microcontroller mode.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "PIC18F6525/6621/8525/8621\nIf  the  device  fetches  or  accesses  external  memory while EBDIS = 1 , the pins will switch to external bus. If the  EBDIS  bit  is  set  by  a  program  executing  from external  memory,  the  action  of  setting  the  bit  will  be delayed  until  the  program  branches  into  the  internal memory.  At  that  time,  the  pins  will  change  from external bus to I/O ports.\nWhen the device is executing out of internal memory (EBDIS = 0 ) in Microprocessor with Boot Block mode or Extended Microcontroller mode, the control signals will  NOT be active. They will go to a state where the AD<15:0>  and  A<19:16>  are  tri-state;  the  CE,  OE, WRH, WRL, UB and LB signals are ' 1 '  and ALE and BA0 are ' 0 '.",
    "TABLE 6-1: PIC18F8525/8621 EXTERNAL BUS - I/O PORT FUNCTIONS\nRD0/AD0, Port = PORTD. RD0/AD0, Bit = bit 0. RD0/AD0, Function = Input/Output or System Bus Address bit 0 or Data bit 0. RD1/AD1, Port = PORTD. RD1/AD1, Bit = bit 1. RD1/AD1, Function = Input/Output or System Bus Address bit 1 or Data bit 1. RD2/AD2, Port = PORTD. RD2/AD2, Bit = bit 2. RD2/AD2, Function = Input/Output or System Bus Address bit 2 or Data bit 2. RD3/AD3, Port = PORTD. RD3/AD3, Bit = bit 3. RD3/AD3, Function = Input/Output or System Bus Address bit 3 or Data bit 3. RD4/AD4, Port = PORTD. RD4/AD4, Bit = bit 4. RD4/AD4, Function = Input/Output or System Bus Address bit 4 or Data bit 4. RD5/AD5, Port = PORTD.",
    "TABLE 6-1: PIC18F8525/8621 EXTERNAL BUS - I/O PORT FUNCTIONS\nRD5/AD5, Bit = bit 5. RD5/AD5, Function = Input/Output or System Bus Address bit 5 or Data bit 5. RD6/AD6, Port = PORTD. RD6/AD6, Bit = bit 6. RD6/AD6, Function = Input/Output or System Bus Address bit 6 or Data bit 6. RD7/AD7, Port = PORTD. RD7/AD7, Bit = bit 7. RD7/AD7, Function = Input/Output or System Bus Address bit 7 or Data bit 7. RE0/AD8, Port = PORTE. RE0/AD8, Bit = bit 0. RE0/AD8, Function = Input/Output or System Bus Address bit 8 or Data bit 8. RE1/AD9, Port = PORTE. RE1/AD9, Bit = bit 1. RE1/AD9, Function = Input/Output or System Bus Address bit 9 or Data bit 9. RE2/AD10, Port = PORTE. RE2/AD10, Bit = bit 2. RE2/AD10, Function",
    "TABLE 6-1: PIC18F8525/8621 EXTERNAL BUS - I/O PORT FUNCTIONS\n= Input/Output or System Bus Address bit 10 or Data bit 10. RE3/AD11, Port = PORTE. RE3/AD11, Bit = bit 3. RE3/AD11, Function = Input/Output or System Bus Address bit 11 or Data bit 11. RE4/AD12, Port = PORTE. RE4/AD12, Bit = bit 4. RE4/AD12, Function = Input/Output or System Bus Address bit 12 or Data bit 12. RE5/AD13, Port = PORTE. RE5/AD13, Bit = bit 5. RE5/AD13, Function = Input/Output or System Bus Address bit 13 or Data bit 13. RE6/AD14, Port = PORTE. RE6/AD14, Bit = bit 6. RE6/AD14, Function = Input/Output or System Bus Address bit 14 or Data bit 14. RE7/AD15, Port = PORTE. RE7/AD15, Bit = bit 7. RE7/AD15, Function = Input/Output or System Bus Address bit 15 or Data bit 15.",
    "TABLE 6-1: PIC18F8525/8621 EXTERNAL BUS - I/O PORT FUNCTIONS\nRH0/A16, Port = PORTH. RH0/A16, Bit = bit 0. RH0/A16, Function = Input/Output or System Bus Address bit 16. RH1/A17, Port = PORTH. RH1/A17, Bit = bit 1. RH1/A17, Function = Input/Output or System Bus Address bit 17. RH2/A18, Port = PORTH. RH2/A18, Bit = bit 2. RH2/A18, Function = Input/Output or System Bus Address bit 18. RH3/A19, Port = PORTH. RH3/A19, Bit = bit 3. RH3/A19, Function = Input/Output or System Bus Address bit 19. RJ0/ALE, Port = PORTJ. RJ0/ALE, Bit = bit 0. RJ0/ALE, Function = Input/Output or System Bus Address Latch Enable (ALE) Control pin. RJ1/OE, Port = PORTJ.",
    "TABLE 6-1: PIC18F8525/8621 EXTERNAL BUS - I/O PORT FUNCTIONS\nRJ1/OE, Bit = bit 1. RJ1/OE, Function = Input/Output or System Bus Output Enable (OE) Control pin. RJ2/WRL, Port = PORTJ. RJ2/WRL, Bit = bit 2. RJ2/WRL, Function = Input/Output or System Bus Write Low (WRL) Control pin. RJ3/WRH, Port = PORTJ. RJ3/WRH, Bit = bit 3. RJ3/WRH, Function = Input/Output or System Bus Write High (WRH) Control pin. RJ4/BA0, Port = PORTJ. RJ4/BA0, Bit = bit 4. RJ4/BA0, Function = Input/Output or System Bus Byte Address bit 0. RJ5/CE, Port = PORTJ. RJ5/CE, Bit = bit 5. RJ5/CE, Function = Input/Output or System Bus Chip Enable (CE) Control pin. RJ6/LB, Port = PORTJ.",
    "TABLE 6-1: PIC18F8525/8621 EXTERNAL BUS - I/O PORT FUNCTIONS\nRJ6/LB, Bit = bit 6. RJ6/LB, Function = Input/Output or System Bus Lower Byte Enable (LB) Control pin. RJ7/UB, Port = PORTJ. RJ7/UB, Bit = bit 7. RJ7/UB, Function = Input/Output or System Bus Upper Byte Enable (UB) Control pin",
    "6.2 16-Bit Mode\nThe external memory interface implemented in PIC18F8525/8621  devices  operates  only  in  16-bit mode. The mode selection is not software configurable but is programmed via the configuration bits.\nThe WM1:WM0 bits in the MEMCON  register determine three types of connections in 16-bit mode. They are referred to as:\n\u00b7 16-bit Byte Write\n\u00b7 16-bit Word Write\n\u00b7 16-bit Byte Select\nThese three different configurations allow the designer maximum flexibility  in  using  8-bit  and  16-bit  memory devices.\nIn Byte Select mode, JEDEC standard Flash memories will require BA0 for the byte address line and one I/O line, to select between Byte and Word mode. The other 16-bit modes do not need BA0. JEDEC standard static RAM memories will use the UB or LB signals for byte selection.",
    "6.2.1 16-BIT BYTE WRITE MODE\nFigure 6-1 shows an example of 16-bit Byte Write mode for  PIC18F8525/8621  devices.  This  mode  is  used  for two separate 8-bit memories  connected  for  16-bit operation.  This  generally  includes  basic  EPROM  and Flash devices. It allows table writes to byte-wide external memories.\nFor all 16-bit modes, the Address Latch Enable (ALE) pin indicates that the address bits, A15:A0, are available on the external memory  interface bus. Following the address latch, the Output Enable signal (OE) will enable both bytes of program memory at once to  form  a  16-bit  instruction  word.  The  Chip  Enable signal (CE) is active at any time that the microcontroller accesses external memory, whether reading or writing; it is inactive (asserted high) whenever the device is in Sleep mode.\nDuring a TBLWT instruction cycle, the TABLAT data is presented  on  the  upper  and  lower  bytes  of the AD15:AD0 bus. The appropriate WRH or WRL control line is strobed on the LSb of the TBLPTR.",
    "FIGURE 6-1: 16-BIT BYTE WRITE MODE EXAMPLE\nNote 1: This signal only applies to table writes. See Section 5.1 'Table Reads and Table Writes' .",
    "6.2.2 16-BIT WORD WRITE MODE\nFigure 6-2  shows  an  example  of  16-bit  Word  Write mode  for  PIC18F8525/8621  devices.  This  mode  is used for word-wide memories which include some of the  EPROM  and  Flash  type  memories.  This  mode allows opcode fetches and table reads from all forms of 16-bit  memory and table writes to  any  type of  wordwide external memories. This method makes a distinction  between TBLWT cycles  to  even  or  odd addresses.\nDuring a TBLWT cycle to an odd address (TBLPTR<0> = 1 ),  the  TABLAT data is presented on the upper byte of the AD15:AD0 bus. The contents of the holding latch are presented on the lower byte of the AD15:AD0 bus.\nDuring a TBLWT cycle to an even address (TBLPTR<0> = 0 ), the TABLAT data is transferred to a holding latch and the external address data bus is tristated for the data portion of the bus cycle. No write signals are activated.",
    "6.2.2 16-BIT WORD WRITE MODE\nThe WRH signal is strobed for each write cycle; the WRL pin is unused. The signal on the BA0 pin indicates the  LSb  of  the  TBLPTR  but  it  is  left  unconnected. Instead, the UB and LB signals are active to select both bytes. The obvious limitation to this method is that the table  write  must  be  done  in  pairs  on  a  specific  word boundary to correctly write a word location.",
    "FIGURE 6-2: 16-BIT WORD WRITE MODE EXAMPLE\nNote 1: This signal only applies to table writes. See Section 5.1 'Table Reads and Table Writes' .",
    "6.2.3 16-BIT BYTE SELECT MODE\nFigure 6-3  shows  an  example  of  16-bit  Byte  Select mode for PIC18F8525/8621 devices. This mode allows table write operations to word-wide external memories with byte selection capability. This generally includes both word-wide Flash and SRAM devices.\nDuring a TBLWT cycle, the TABLAT data is presented on the upper and lower byte of the AD15:AD0 bus. The WRH signal is strobed for each write cycle; the WRL pin is not used. The BA0 or UB/LB signals are used to select  the  byte  to  be  written  based  on  the  Least Significant bit of the TBLPTR register.\nFlash and SRAM devices use different control signal combinations to implement Byte Select mode. JEDEC standard Flash memories require that a controller I/O port pin be connected to the memory's BYTE/WORD pin to provide the select signal. They also use the BA0 signal from the controller as a byte address. JEDEC standard static RAM memories, on the other hand, use the UB or LB signals to select the byte.",
    "FIGURE 6-3: 16-BIT BYTE SELECT MODE EXAMPLE\nNote\n1: This signal only applies to table writes. See Section 5.1 'Table Reads and Table Writes' .\n2: Demultiplexing is only required when multiple memory devices are accessed.",
    "6.2.4 16-BIT MODE TIMING\nThe  presentation  of  control  signals  on  the  external memory  bus  is  different  for  the  various  operating modes.  Typical  signal  timing  diagrams  are  shown  in Figure 6-4 through Figure 6-6.",
    "FIGURE 6-4: EXTERNAL MEMORY BUS TIMING FOR TBLRD (MICROPROCESSOR MODE)\nFIGURE 6-5: EXTERNAL MEMORY BUS TIMING FOR TBLRD (EXTENDED MICROCONTROLLER MODE)",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "7.0 DATA EEPROM MEMORY\nThe  data  EEPROM  is  readable  and  writable  during normal operation over the entire VDD range. The data memory  is  not  directly  mapped  in  the  register  file space. Instead, it is  indirectly  addressed through  the Special Function Registers (SFR).\nThere  are  five  SFRs  used  to  read  and  write  the program and data EEPROM memory. These registers are:\n\u00b7 EECON1\n\u00b7 EECON2\n\u00b7 EEDATA\n\u00b7 EEADRH\n\u00b7 EEADR\nThe EEPROM data memory allows byte read and write. When interfacing to the data memory block, EEDATA holds the 8-bit data for read/write. EEADR  and EEADRH hold the address of the EEPROM location being  accessed.  These  devices  have  1024  bytes  of data  EEPROM  with  an  address  range  from  00h  to 3FFh.",
    "7.0 DATA EEPROM MEMORY\nThe EEPROM data memory is rated for high  erase/ write cycles. A byte write automatically erases the location and writes the new data (erase-before-write). The write time is controlled by an on-chip timer. The write time will vary with voltage and temperature, as well as from  chip-to-chip.  Please  refer  to  parameter  D122 ( Section 27.0 'Electrical Characteristics' ) for exact limits.",
    "7.1 EEADR and EEADRH\nThe  address  register pair can address up to a maximum of 1024 bytes  of  data  EEPROM.  The  two Most  Significant  bits  of  the  address  are  stored  in EEADRH, while the remaining eight Least Significant bits are stored in EEADR. The six Most Significant bits of EEADRH are unused and are read as ' 0 '.",
    "7.2 EECON1 and EECON2 Registers\nEECON1 is the control register for EEPROM memory accesses.\nEECON2 is not a physical register. Reading EECON2 will read  all ' 0 's. The  EECON2  register  is  used exclusively in the EEPROM write sequence.\nControl bits RD  and  WR  initiate  read  and  write operations, respectively. These bits cannot be cleared, only set in software. They are cleared in hardware at the  completion  of  the  read  or  write  operation.  The inability  to  clear  the  WR  bit  in  software  prevents  the accidental or premature termination of a write operation.",
    "Note:\nDuring normal operation, the WRERR bit is read as ' 1 '. This can indicate that a write operation was prematurely terminated by a Reset, or a write operation was attempted improperly.\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear. The WRERR bit is set when a write operation is interrupted by a MCLR Reset or a WDT  Time-out  Reset  during  normal operation. In these situations, the user can check the WRERR bit and rewrite the location. It is necessary to reload  the  data  and  address  registers  (EEDATA  and EEADR)  due  to  the Reset condition forcing the contents of the registers to zero.\nNote:\nInterrupt flag bit, EEIF in the PIR2 register, is set when write is complete. It must be cleared in software.",
    "EECON1 REGISTER (ADDRESS FA6h)\nR/W-x, 1 = R/W-x. R/W-x, 2 = U-0. R/W-x, 3 = R/W-0. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-0. R/W-x, 6 = R/S-0. R/W-x, 7 = R/S-0. EEPGD, 1 = CFGS. EEPGD, 2 = -. EEPGD, 3 = FREE. EEPGD, 4 = WRERR. EEPGD, 5 = WREN. EEPGD, 6 = WR. EEPGD, 7 = RD\nbit 7\nbit 0\nEEPGD: Flash Program/Data EEPROM Memory Select bit\n1 = Access Flash program memory\n0 = Access data EEPROM memory\nCFGS: Flash Program/Data EEPROM or Configuration Select bit\n1 = Access Configuration or Calibration registers\n0 = Access Flash program or data EEPROM memory\nbit 5 Unimplemented: Read as ' 0 '",
    "bit 4 FREE: Flash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation)\n0 = Perform write only",
    "bit 3 WRERR: Flash Program/Data EEPROM Error Flag bit\n- 1 = A write operation is prematurely terminated\n(any MCLR or any WDT Reset during self-timed programming in normal operation)\n- 0 = The write operation completed\nNote:\nWhen a WRERR occurs, the EEPGD or FREE bits are not cleared. This allows tracing of the error condition.",
    "bit 2 WREN: Flash Program/Data EEPROM Write Enable bit\n1 = Allows write cycles to Flash program/data EEPROM\n0 = Inhibits write cycles to Flash program/data EEPROM",
    "bit 1 WR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle to the EEPROM is complete\nRD: Read Control bit\n1\n= Initiates an EEPROM read (Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1 .)\n0 = Does not initiate an EEPROM read",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "7.3 Reading the Data EEPROM Memory\nTo read a data memory location, the user must write the address to the EEADRH:EEADR register pair, clear the EEPGD  control  bit  (EECON1<7>),  clear  the  CFGS\ncontrol bit (EECON1<6>) and then set the RD control bit  (EECON1<0>). The data is available for the very next instruction cycle; therefore, the EEDATA register can be read by the next instruction. EEDATA will hold this  value  until  another  read  operation  or  until  it  is written to by the user (during a write operation).",
    "EXAMPLE 7-1: DATA EEPROM READ\nMOVLW, 1 = DATA_EE_ADDRH. MOVLW, 2 = ;. MOVWF, 1 = EEADRH. MOVWF, 2 = ; Upper bits of Data Memory Address to read. MOVLW, 1 = DATA_EE_ADDR. MOVLW, 2 = ;. MOVWF, 1 = EEADR. MOVWF, 2 = ; Lower bits of Data Memory Address to read. BCF, 1 = EECON1, EEPGD. BCF, 2 = ; Point to DATA memory. BCF, 1 = EECON1, CFGS. BCF, 2 = ; Access EEPROM. BSF, 1 = EECON1, RD. BSF, 2 = ; EEPROM Read. MOVF, 1 = EEDATA, W. MOVF, 2 = ; W = EEDATA",
    "7.4 Writing to the Data EEPROM Memory\nTo write an EEPROM data location, the address must first  be  written  to  the  EEADRH:EEADR  register  pair and the data written to the EEDATA register. Then the sequence in Example 7-2 must be followed to initiate the write cycle.\nexecution  (i.e.,  runaway  programs).  The  WREN  bit should be kept clear at all times except when updating the EEPROM. The WREN bit is not cleared by hardware.\nThe write will not initiate if the above sequence is not exactly followed (write 55h to EECON2, write AAh to EECON2, then set WR bit) for each byte. It is strongly recommended that  interrupts  be  disabled  during  this code segment.\nAdditionally, the WREN bit in EECON1 must be set to enable  writes.  This  mechanism  prevents  accidental writes  to  data  EEPROM  due  to  unexpected  code\nAfter  a  write  sequence  has  been  initiated,  EECON1, EEADRH, EEADR and EEDATA cannot be modified. The WR bit will be inhibited from being set unless the WREN bit is set. Both WR and WREN cannot be set with the same instruction.",
    "7.4 Writing to the Data EEPROM Memory\nAt  the  completion  of  the  write  cycle,  the  WR  bit  is cleared in hardware and the EEPROM Write Complete Interrupt  Flag  bit  (EEIF)  is  set.  The  user  may  either enable  this  interrupt  or  poll  this  bit.  EEIF  must  be cleared by software.",
    "EXAMPLE 7-2: DATA EEPROM WRITE\nMOVLW MOVWF MOVLW MOVWF MOVLW MOVWF BCF BCF BSF, 1 = DATA_EE_ADDRH EEADRH DATA_EE_ADDR EEADR DATA_EE_DATA EEDATA EECON1, EEPGD EECON1, CFGS EECON1, WREN. MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF BCF BCF BSF, 2 = ; ; ; ; ; ; ; ; ;. MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF BCF BCF BSF, 3 = Upper bits of Data Memory Address to write Lower bits of Data Memory Address to write Data Memory Value to write Point to DATA memory Access EEPROM Enable writes. BCF MOVLW MOVWF, 1 = INTCON, GIE 0x55. BCF MOVLW MOVWF, 2 = ; ;. BCF MOVLW MOVWF, 3 = Disable Interrupts. MOVWF",
    "EXAMPLE 7-2: DATA EEPROM WRITE\nBSF, 1 = EECON2 EECON1, WR. MOVWF BSF, 2 = ; ;. MOVWF BSF, 3 = Write AAh Set WR bit to begin write. BSF BCF, 1 = INTCON, GIE EECON1, WREN. BSF BCF, 2 = ; ; ;. BSF BCF, 3 = Enable User code execution Disable",
    "7.7 Operation During Code-Protect\nDepending  on  the  application,  good  programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "7.6 Protection Against Spurious Write\nThere are conditions when the user may not want to write to the data EEPROM memory. To protect against spurious EEPROM writes, various mechanisms have been built-in. On power-up, the WREN bit is cleared. Also,  the  Power-up  Timer  (72  ms  duration)  prevents EEPROM write.\nThe write initiate sequence and the WREN bit together help  prevent  an  accidental  write  during  brown-out, power glitch or software malfunction.\nData  EEPROM  memory  has  its  own  code-protect mechanism.  External  read  and  write  operations  are disabled  if  either  of  these  mechanisms  are  enabled. Refer  to Section 24.0  'Special  Features  of  the CPU' , for additional information.",
    "7.8 Using the Data EEPROM\nThe data EEPROM  is a high endurance, byte addressable  array  that  has  been  optimized  for  the storage of frequently changing information (e.g., program  variables  or  other  data  that  are  updated often).  Frequently  changing  values  will  typically  be updated more often than specification D124. If this is not the case, an array refresh must be performed. For this reason, variables that change infrequently (such as constants,  IDs,  calibration,  etc.)  should  be  stored  in Flash program memory.\nA  simple  data  EEPROM  refresh  routine  is  shown  in Example 7-3.",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\n, 1 = CLRF CLRF BCF. , 2 = EEADR EEADRH. , 3 = ;. , 4 = Start at address 0. Loop, 1 = . Loop, 2 = . Loop, 3 = ;. Loop, 4 = Loop to refresh array. , 1 = BSF. , 2 = EECON1, RD. , 3 = ;. , 4 = Read current address. , 1 = BCF BCF BSF MOVLW. , 2 = EECON1, EEPGD. , 3 = ; ; ;. , 4 = Set for Data EEPROM Disable interrupts. , 1 = MOVWF. , 2 = INTCON, GIE EECON1, WREN 55h. , 3 = ;. , 4 = Enable writes. , 1 = . , 2 = EECON2. , 3 = ;. , 4 = Write 55h Set WR bit to begin write. , 1 = MOVWF BSF. , 2 = EECON1, WR. , 3 = . , 4 = . , 1 = MOVLW. , 2 = AAh. , 3 = . , 4 =",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\n; Write AAh. , 1 = . , 2 = . , 3 = ;. , 4 = . , 1 = . , 2 = EECON2. , 3 = ;. , 4 = . , 1 = BTFSC. , 2 = EECON1,. , 3 = ;. , 4 = Wait for write to. , 1 = . , 2 = WR. , 3 = . , 4 = complete. , 1 = INCFSZ. , 2 = EEADR, F. , 3 = ; ;. , 4 = Increment address. , 1 = BRA. , 2 = Loop. , 3 = . , 4 = Not zero, do it again. , 1 = INCFSZ. , 2 = EEADRH, F. , 3 = ;. , 4 = Increment the high address. , 1 = BRA. , 2 = Loop. , 3 = ;. , 4 = Not zero, do it again. , 1 = BCF. , 2 = EECON1, WREN. , 3 = ;. , 4 = Disable writes. , 1 = BSF. , 2 = INTCON, GIE. , 3 =",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\n;. , 4 = Enable interrupts",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on: POR, BOR = 0000 000x. INTCON, Value on all other Resets = 0000 000u. EEADRH, Bit 7 = -. EEADRH, Bit 6 = -. EEADRH, Bit 5 = -. EEADRH, Bit 4 = -. EEADRH, Bit 3 = -. EEADRH, Bit 2 = -. EEADRH, Bit 1 = EE Addr Register High. EEADRH, Bit 0 = EE Addr Register High. EEADRH, Value on: POR, BOR = ---- --00. EEADRH, Value on all other Resets = ---- --00. EEADR, Bit 7 =",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nData EEPROM Address Register. EEADR, Bit 6 = Data EEPROM Address Register. EEADR, Bit 5 = Data EEPROM Address Register. EEADR, Bit 4 = Data EEPROM Address Register. EEADR, Bit 3 = Data EEPROM Address Register. EEADR, Bit 2 = Data EEPROM Address Register. EEADR, Bit 1 = Data EEPROM Address Register. EEADR, Bit 0 = Data EEPROM Address Register. EEADR, Value on: POR, BOR = 0000 0000. EEADR, Value on all other Resets = 0000 0000. EEDATA, Bit 7 = Data EEPROM Data Register. EEDATA, Bit 6 = Data EEPROM Data Register. EEDATA, Bit 5 = Data EEPROM Data Register. EEDATA, Bit 4 = Data EEPROM Data Register. EEDATA, Bit 3 = Data EEPROM Data Register. EEDATA, Bit 2 = Data EEPROM Data Register. EEDATA, Bit 1 = Data EEPROM Data Register. EEDATA, Bit 0 =",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nData EEPROM Data Register. EEDATA, Value on: POR, BOR = 0000 0000. EEDATA, Value on all other Resets = 0000 0000. EECON2, Bit 7 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = Data EEPROM Control Register 2 (not a physical register). EECON2, Value on: POR, BOR = -. EECON2, Value on all other Resets = -. EECON1, Bit 7 =",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nEEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on: POR, BOR = xx-0 x000. EECON1, Value on all other Resets = uu-0 u000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on: POR, BOR = -1-1 1111. IPR2, Value on all other Resets = -1-1 1111. PIR2, Bit 7 = -. PIR2, Bit",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\n6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on: POR, BOR = -0-0 0000. PIR2, Value on all other Resets = ---0 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on: POR, BOR = -0-0 0000. PIE2, Value on all other Resets = ---0 0000\nLegend:",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used during Flash/EEPROM access.",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "8.1 Introduction\nAn 8 x 8 hardware multiplier is included in the ALU of the PIC18F6525/6621/8525/8621  devices.  By  making  the multiply a hardware operation, it completes in a single instruction cycle. This is an unsigned multiply that gives a 16-bit result. The result is stored in the 16-bit product register pair (PRODH:PRODL). The multiplier does not affect any flags in the ALUSTA register.\nMaking the 8 x 8 multiplier execute in a single cycle gives the following advantages:\n\u00b7 Higher computational throughput\n\u00b7 Reduces code size requirements for multiply algorithms\nThe performance increase allows the device to be used in  applications  previously  reserved  for  Digital  Signal Processors.\nTable 8-1 shows a performance comparison between Enhanced  devices  using  the  single-cycle  hardware multiply and performing the same function without the hardware multiply.",
    "8.2 Operation\nExample 8-1  shows  the  sequence  to  do  an  8  x  8 unsigned  multiply.  Only  one  instruction  is  required when one argument of the multiply is already loaded in the WREG register.\nExample 8-2 shows the sequence to do an 8 x 8 signed multiply. To account for the signed bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "EXAMPLE 8-1: 8 x 8 UNSIGNED MULTIPLY ROUTINE\nMOVF, 1 = ARG1, W. MOVF, 2 = ;. MULWF, 1 = ARG2. MULWF, 2 = ; ARG1 * ARG2 ->",
    "EXAMPLE 8-2: 8 x 8 SIGNED MULTIPLY ROUTINE\nMOVF MULWF BTFSC SUBWF MOVF, 1 = ARG1, W ARG2 ARG2, SB. MOVF MULWF BTFSC SUBWF MOVF, 2 = ; ; ARG1 * ARG2 -> ; PRODH:PRODL ; Test Sign Bit ; PRODH = PRODH ; - ARG1 ; ; Test Sign Bit",
    "TABLE 8-1: PERFORMANCE COMPARISON\n8 x 8 unsigned, Multiply Method = Without hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 13. 8 x 8 unsigned, Cycles (Max). = 69. 8 x 8 unsigned, Time.@40 MHz = 6.9 \uf06d s. 8 x 8 unsigned, Time.@10 MHz = 27.6 \uf06d s. 8 x 8 unsigned, Time.@4MHz = 69 \uf06d s. 8 x 8 unsigned, Multiply Method = Hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 1. 8 x 8 unsigned, Cycles (Max). = 1. 8 x 8 unsigned, Time.@40 MHz = 100 ns. 8 x 8 unsigned, Time.@10 MHz = 400 ns. 8 x 8 unsigned, Time.@4MHz = 1 \uf06d s. 8 x 8 signed, Multiply Method = Without hardware multiply. 8 x 8 signed, Program Memory (Words). = 33. 8 x 8 signed, Cycles (Max). = 91. 8 x 8 signed, Time.@40 MHz = 9.1 \uf06d s. 8 x 8 signed, Time.@10 MHz = 36.4 \uf06d s. 8 x 8",
    "TABLE 8-1: PERFORMANCE COMPARISON\nsigned, Time.@4MHz = 91 \uf06d s. 8 x 8 signed, Multiply Method = Hardware multiply. 8 x 8 signed, Program Memory (Words). = 6. 8 x 8 signed, Cycles (Max). = 6. 8 x 8 signed, Time.@40 MHz = 600 ns. 8 x 8 signed, Time.@10 MHz = 2.4 \uf06d s. 8 x 8 signed, Time.@4MHz = 6 \uf06d s. 16 x 16 unsigned, Multiply Method = Without hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 21. 16 x 16 unsigned, Cycles (Max). = 242. 16 x 16 unsigned, Time.@40 MHz = 24.2 \uf06d s. 16 x 16 unsigned, Time.@10 MHz = 96.8 \uf06d s. 16 x 16 unsigned, Time.@4MHz = 242 \uf06d s. 16 x 16 unsigned, Multiply Method = Hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 24. 16 x 16 unsigned, Cycles (Max). = 24. 16 x 16 unsigned, Time.@40 MHz = 2.4 \uf06d s. 16 x 16 unsigned,",
    "TABLE 8-1: PERFORMANCE COMPARISON\nTime.@10 MHz = 9.6 \uf06d s. 16 x 16 unsigned, Time.@4MHz = 24 \uf06d s. 16 x 16 signed, Multiply Method = Without hardware multiply. 16 x 16 signed, Program Memory (Words). = 52. 16 x 16 signed, Cycles (Max). = 254. 16 x 16 signed, Time.@40 MHz = 25.4 \uf06d s. 16 x 16 signed, Time.@10 MHz = 102.6 \uf06d s. 16 x 16 signed, Time.@4MHz = 254 \uf06d s. 16 x 16 signed, Multiply Method = Hardware multiply. 16 x 16 signed, Program Memory (Words). = 36. 16 x 16 signed, Cycles (Max). = 36. 16 x 16 signed, Time.@40 MHz = 3.6 \uf06d s. 16 x 16 signed, Time.@10 MHz = 14.4 \uf06d s. 16 x 16 signed, Time.@4MHz = 36 \uf06d s",
    "PIC18F6525/6621/8525/8621\nExample 8-3  shows  the  sequence  to  do  a  16  x  16 unsigned  multiply.  Equation 8-1  shows  the  algorithm that is used. The 32-bit result is stored in four registers, RES3:RES0.\nEQUATION 8-1:\n16 x 16 UNSIGNED MULTIPLICATION ALGORITHM\nRES3:RES0\n=\nARG1H:ARG1L   ARG2H:ARG2L \uf0b7\n=\n(ARG1H   ARG2H   2 16 ) + \uf0b7 \uf0b7\n(ARG1H   ARG2L   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2H   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2L) \uf0b7",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1L * ARG2L -> PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES1. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES0. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1H, ARG2H. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = . MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1H * ARG2H -> PRODH:PRODL.",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVFF, 1 = PRODH,. MOVFF, 2 = RES3. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES2. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1L,W. MOVF, 2 = . MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1L * ARG2H -> PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1 = RES1,. ADDWF, 2 = F. ADDWF, 3 = ;. ADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W.",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF, 3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1H * ARG2L ->. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1 = RES1,. ADDWF, 2 = F.",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nADDWF, 3 = ;. ADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = \nExample 8-4  shows  the  sequence  to  do  a  16  x  16 signed  multiply.  Equation 8-2  shows  the  algorithm used.  The  32-bit  result  is  stored  in  four  registers, RES3:RES0.  To  account  for  the  signed  bits  of  the arguments, each argument pairs' Most Significant bit (MSb) is tested and the appropriate subtractions are done.\nEQUATION 8-2:\n16 x 16 SIGNED MULTIPLICATION ALGORITHM",
    "RES3:RES0\n= ARG1H:ARG1L   ARG2H:ARG2L \uf0b7\n= (ARG1H   ARG2H   2 16 ) + \uf0b7 \uf0b7\n(ARG1H   ARG2L   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2H   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2L) + \uf0b7\n(-1 \uf0b7 ARG2H<7>   ARG1H:ARG1L   2 16 ) + \uf0b7 \uf0b7\n(-1 \uf0b7 ARG1H<7>   ARG2H:ARG2L   2 16 ) \uf0b7 \uf0b7",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nMULWF, ARG1L, = ARG2L. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1L * ARG2L -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES1. MOVFF,  = ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES0. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1H * ARG2H ->. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES3. MOVFF,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES2. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1L,. MOVF, W = W. MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1L * ARG2H -> PRODH:PRODL. MOVF, ARG1L, = PRODL,. MOVF, W = W. MOVF,  = ;. MOVF,  = . ADDWF, ARG1L, = RES1,. ADDWF, W = F. ADDWF,  = ;. ADDWF,  = Add cross. MOVF, ARG1L, = PRODH,. MOVF, W = W. MOVF,  = ;. MOVF,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= products. ADDWFC, ARG1L, = RES2,. ADDWFC, W = F. ADDWFC,  = ;. ADDWFC,  = . CLRF, ARG1L, = WREG. CLRF, W = . CLRF,  = ;. CLRF,  = . ADDWFC, ARG1L, = RES3,. ADDWFC, W = F. ADDWFC,  = ;. ADDWFC,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = ;. MOVF,  = . MULWF, ARG1L, = ARG2L. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1H * ARG2L -> PRODH:PRODL. MOVF ADDWF, ARG1L, = PRODL, RES1,. MOVF ADDWF, W = W F. MOVF ADDWF,  = ; ;. MOVF ADDWF,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= Add cross. MOVF, ARG1L, = PRODH,. MOVF, W = W. MOVF,  = ;. MOVF,  = products. ADDWFC, ARG1L, = RES2,. ADDWFC, W = F. ADDWFC,  = ;. ADDWFC,  = . CLRF, ARG1L, = WREG. CLRF, W = . CLRF,  = . CLRF,  = . ADDWFC, ARG1L, = RES3,. ADDWFC, W = . ADDWFC,  = ; ;. ADDWFC,  = . ; BTFSS, ARG1L, = ARG2H,. ; BTFSS, W = F 7. ; BTFSS,  = ;. ; BTFSS,  = ARG2H:ARG2L neg?. BRA, ARG1L, = SIGN_ARG1. BRA, W = . BRA,  = ;. BRA,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= no, check ARG1. MOVF, ARG1L, = ARG1L,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWF, ARG1L, = RES2. SUBWF, W = . SUBWF,  = ;. SUBWF,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWFB, ARG1L, = RES3. SUBWFB, W = . SUBWFB,  = . SUBWFB,  = . BRA MOVF, ARG1L, = CONT_CODE ARG2L,. BRA MOVF, W = W. BRA MOVF,  = ; ;. BRA MOVF,  = no, done. SUBWF MOVF, ARG1L, = RES2. SUBWF MOVF, W = W. SUBWF MOVF,  = ;. SUBWF MOVF,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . , ARG1L, = . , W = . ,  = ;. ,  = . SUBWFB, ARG1L, = ARG2H, RES3. SUBWFB, W = . SUBWFB,  = . SUBWFB,  = . ;, ARG1L, = . ;, W = . ;,  = . ;,  = . CONT_CODE, ARG1L, = . CONT_CODE, W = . CONT_CODE,  = . CONT_CODE,  = . :, ARG1L, = . :, W = . :,  = . :,  = ",
    "9.0 INTERRUPTS\nThe PIC18F6525/6621/8525/8621 devices have multiple  interrupt  sources  and  an  interrupt  priority  feature that allows each interrupt source to be assigned a high or a low priority level. The high priority interrupt vector is at 000008h, while the low priority interrupt vector is at 000018h. High priority interrupt events will override any low priority interrupts that may be in progress.\nWhen  the  IPEN  bit  is  cleared  (default  state),  the interrupt priority feature is disabled and interrupts are compatible with PIC \u00ae mid-range devices. In Compatibility mode, the interrupt priority bits for each source  have  no  effect.  INTCON<6>  is  the  PEIE  bit which enables/disables all peripheral interrupt sources. INTCON<7> is the GIE bit which enables/disables all interrupt  sources.  All  interrupts  branch  to  address 000008h in Compatibility mode.\nThere are thirteen registers which are used to control interrupt operation. They are:\n\u00b7 RCON\n\u00b7 INTCON\n\u00b7 INTCON2\n\u00b7 INTCON3\n\u00b7 PIR1, PIR2, PIR3\n\u00b7 PIE1, PIE2, PIE3\n\u00b7 IPR1, IPR2, IPR3",
    "9.0 INTERRUPTS\nIt is  recommended  that  the  Microchip  header  files supplied with MPLAB \u00ae  IDE be used for the symbolic bit names in these registers. This allows the assembler/ compiler to automatically take care of the placement of these bits within the specified register.\nEach  interrupt  source  has  three  bits  to  control  its operation. The functions of these bits are:\n\u00b7 Flag bit to indicate that an interrupt event occurred\n\u00b7 Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\n\u00b7 Priority bit to select high priority or low priority\nThe interrupt priority feature is enabled by setting the IPEN bit (RCON<7>). When  interrupt priority is enabled,  there  are  two  bits  which  enable  interrupts globally. Setting the GIEH bit (INTCON<7>) enables all interrupts that have the priority bit set. Setting the GIEL bit  (INTCON<6>) enables all interrupts that have the priority bit cleared. When the interrupt flag, enable bit and appropriate global interrupt enable bit are set, the interrupt will vector immediately to address 000008h or 000018h,  depending  on  the  priority  level.  Individual interrupts can be disabled through their corresponding enable bits.",
    "9.0 INTERRUPTS\nWhen an interrupt is responded to, the global interrupt enable bit is cleared to disable further interrupts. If the IPEN bit is cleared, this is the GIE bit. If interrupt priority levels are used, this will be either the GIEH or GIEL bit. High  priority  interrupt  sources  can  interrupt  a  low priority interrupt.\nThe return address is pushed onto the stack and the PC  is loaded with the interrupt vector address (000008h or 000018h). Once in the Interrupt Service Routine,  the  source(s)  of  the  interrupt  can  be  determined by polling the  interrupt  flag  bits.  The  interrupt flag bits must be cleared in software before re-enabling interrupts to avoid recursive interrupts.\nThe 'return  from  interrupt'  instruction, RETFIE ,  exits the interrupt routine and sets the GIE bit (GIEH or GIEL if priority levels are used) which re-enables interrupts.\nFor external interrupt events, such as the INT pins or the PORTB input change interrupt, the interrupt latency will be  three  to  four  instruction  cycles.  The  exact latency is the same for one or two-cycle instructions. Individual  interrupt  flag  bits  are  set  regardless  of  the status of their corresponding enable bit or the GIE bit.",
    "FIGURE 9-1: INTERRUPT LOGIC\nbit 2",
    "9.1 INTCON Registers\nNote:\nThe  INTCON  registers  are  readable  and  writable registers which contain various enable, priority and flag bits.\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global interrupt enable bit. User software should ensure  the  appropriate  interrupt  flag  bits are  clear  prior  to  enabling  an  interrupt. This feature allows for software polling.",
    "INTCON: INTERRUPT CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-x. GIE/GIEH, 1 = PEIE/GIEL. GIE/GIEH, 2 = TMR0IE. GIE/GIEH, 3 = INT0IE. GIE/GIEH, 4 = RBIE. GIE/GIEH, 5 = TMR0IF. GIE/GIEH, 6 = INT0IF. GIE/GIEH, 7 = RBIF\nbit 7\nbit 0",
    "bit 7 GIE/GIEH: Global Interrupt Enable bit\nWhen IPEN (RCON<7>) = 0 :\n1 =  Enables all unmasked interrupts\n0 =  Disables all interrupts",
    "When IPEN (RCON<7>) = 1 :\n1 =  Enables all high priority interrupts\n0 =  Disables all interrupts",
    "When IPEN (RCON<7>) = 0 :\n1 =  Enables all unmasked peripheral interrupts\n0 =  Disables all peripheral interrupts",
    "When IPEN (RCON<7>) = 1 :\n1 =  Enables all low priority peripheral interrupts\n0 =  Disables all low priority peripheral interrupts",
    "bit 5 TMR0IE: TMR0 Overflow Interrupt Enable bit\n1 =  Enables the TMR0 overflow interrupt\n0 =  Disables the TMR0 overflow interrupt\nbit 4 INT0IE: INT0 External Interrupt Enable bit\n1 =  Enables the INT0 external interrupt\n0 =  Disables the INT0 external interrupt\nbit 3 RBIE: RB Port Change Interrupt Enable bit\n1 =  Enables the RB port change interrupt\n0 =  Disables the RB port change interrupt\nTMR0IF:\nTMR0 Overflow Interrupt Flag bit\n1 = TMR0 register has overflowed (must be cleared in software)\n0 = TMR0 register did not overflow",
    "bit 1 INT0IF: INT0 External Interrupt Flag bit\n1 = The INT0 external interrupt occurred (must be cleared in software)\n0 = The INT0 external interrupt did not occur",
    "bit 0 RBIF: RB Port Change Interrupt Flag bit\n1 = At least one of the RB7:RB4 pins changed state (must be cleared in software)\n0 = None of the RB7:RB4 pins have changed state\nNote:\nA mismatch condition will continue to set this bit. Reading PORTB will end the mismatch condition and allow the bit to be cleared.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "INTCON2: INTERRUPT CONTROL REGISTER 2\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = R/W-1. R/W-1, 4 = R/W-1. R/W-1, 5 = R/W-1. R/W-1, 6 = R/W-1. R/W-1, 7 = R/W-1. RBPU, 1 = INTEDG0. RBPU, 2 = INTEDG1. RBPU, 3 = INTEDG2. RBPU, 4 = INTEDG3. RBPU, 5 = TMR0IP. RBPU, 6 = INT3IP. RBPU, 7 = RBIP\nbit 7\nbit 0\nbit 7 RBPU : PORTB Pull-up Enable bit\n1 = All PORTB pull-ups are disabled\n0 = PORTB pull-ups are enabled by individual port latch values",
    "bit 6 INTEDG0 : External Interrupt 0 Edge Select bit\n1 =  Interrupt on rising edge\n0 =  Interrupt on falling edge\nbit 5 INTEDG1 : External Interrupt 1 Edge Select bit\n1 = Interrupt on rising edge\n0 =  Interrupt on falling edge",
    "bit 4 INTEDG2 : External Interrupt 2 Edge Select bit\n1 =  Interrupt on rising edge\n0 =  Interrupt on falling edge\nbit 3 INTEDG3 : External Interrupt 3 Edge Select bit\n1\n=  Interrupt on rising edge\n0 =  Interrupt on falling edge",
    "bit 2 TMR0IP : TMR0 Overflow Interrupt Priority bit\n1 =  High priority\n0 =  Low priority",
    "bit 1 INT3IP: INT3 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0 RBIP : RB Port Change Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "Legend:\nR = Readable bit\n-n = Value at POR\nW = Writable bit\nU = Unimplemented bit, read as '0'\n'1' = Bit is set\n'0' = Bit is cleared x = Bit is unknown\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of  its  corresponding  enable  bit  or  the  global  interrupt  enable  bit.  User  software should  ensure  the  appropriate  interrupt  flag  bits  are  clear  prior  to  enabling  an interrupt. This feature allows for software polling.",
    "INTCON3: INTERRUPT CONTROL REGISTER 3\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-0. R/W-1, 3 = R/W-0. R/W-1, 4 = R/W-0. R/W-1, 5 = R/W-0. R/W-1, 6 = R/W-0. R/W-1, 7 = R/W-0. INT2IP, 1 = INT1IP. INT2IP, 2 = INT3IE. INT2IP, 3 = INT2IE. INT2IP, 4 = INT1IE. INT2IP, 5 = INT3IF. INT2IP, 6 = INT2IF. INT2IP, 7 = INT1IF\nbit 7\nbit 0\nbit 7 INT2IP: INT2 External Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 6 INT1IP: INT1 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5 INT3IE: INT3 External Interrupt Enable bit\n1 = Enables the INT3 external interrupt\n0 = Disables the INT3 external interrupt",
    "bit 4 INT2IE: INT2 External Interrupt Enable bit\n1 = Enables the INT2 external interrupt\n0 = Disables the INT2 external interrupt\nbit 3\nINT1IE: INT1 External Interrupt Enable bit\n1 = Enables the INT1 external interrupt\n0 = Disables the INT1 external interrupt\nbit 2 INT3IF: INT3 External Interrupt Flag bit\n1 = The INT3 external interrupt occurred (must be cleared in software)\n0 = The INT3 external interrupt did not occur\nbit 1 INT2IF: INT2 External Interrupt Flag bit\n1 = The INT2 external interrupt occurred (must be cleared in software)\n0 = The INT2 external interrupt did not occur\nbit 0 INT1IF: INT1 External Interrupt Flag bit\n1 = The INT1 external interrupt occurred (must be cleared in software)\n0 = The INT1 external interrupt did not occur",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of  its  corresponding  enable  bit  or  the  global  interrupt  enable  bit.  User  software should  ensure  the  appropriate  interrupt  flag  bits  are  clear  prior  to  enabling  an interrupt. This feature allows for software polling.",
    "9.2 PIR Registers\nThe PIR registers contain the individual flag bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are three Peripheral Interrupt Request Flag registers (PIR1, PIR2 and PIR3).\nNote 1: Interrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the Global Interrupt Enable bit, GIE (INTCON<7>).\n2: User software should ensure the appropriate interrupt flag bits are cleared prior to enabling  an  interrupt  and  after  servicing that interrupt.",
    "PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIF (1), 1 = ADIF. PSPIF (1), 2 = RC1IF. PSPIF (1), 3 = TX1IF. PSPIF (1), 4 = SSPIF. PSPIF (1), 5 = CCP1IF. PSPIF (1), 6 = TMR2IF. PSPIF (1), 7 = TMR1IF\nbit 7\nbit 0",
    "PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nbit 7 PSPIF: Parallel Slave Port Read/Write Interrupt Flag bit (1)\n1 = A read or a write operation has taken place (must be cleared in software)\n0 = No read or write has occurred\nNote 1: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "bit 6 ADIF : A/D Converter Interrupt Flag bit\n1 = An A/D conversion completed (must be cleared in software)\n0 = The A/D conversion is not complete\nbit 5 RC1IF : USART1 Receive Interrupt Flag bit\n1 = The USART1 receive buffer, RCREGx, is full (cleared when RCREGx is read)\n0 = The USART1 receive buffer is empty\nbit 4 TX1IF : USART1 Transmit Interrupt Flag bit\n1 = The USART1 transmit buffer, TXREGx, is empty (cleared when TXREGx is written)\n0 = The USART1 transmit buffer is full\nbit 3 SSPIF : Master Synchronous Serial Port Interrupt Flag bit\n1 = The transmission/reception is complete (must be cleared in software)\n0 = Waiting to transmit/receive",
    "Capture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n0 = No TMR1 register capture occurred",
    "Compare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n0 = No TMR1 register compare match occurred",
    "PWM mode:\nUnused in this mode.\nbit 1 TMR2IF: TMR2 to PR2 Match Interrupt Flag bit\n1 = TMR2 to PR2 match occurred (must be cleared in software)\n0 = No TMR2 to PR2 match occurred\nTMR1IF:\nTMR1 Overflow Interrupt Flag bit\n1 = TMR1 register overflowed (must be cleared in software)\n0 = TMR1 register did not overflow",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 0",
    "PIR2: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 2\nU-0, 1 = R/W-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = CMIF. -, 2 = -. -, 3 = EEIF. -, 4 = BCLIF. -, 5 = LVDIF. -, 6 = TMR3IF. -, 7 = CCP2IF\nbit 7\nbit 0",
    "bit 6 CMIF : Comparator Interrupt Flag bit\n1 = The comparator input has changed (must be cleared in software)\n0 = The comparator input has not changed",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nEEIF\n: Data EEPROM/Flash Write Operation Interrupt Flag bit\n1 = The write operation is complete (must be cleared in software)\n0 = The write operation is not complete, or has not been started\nBCLIF : Bus Collision Interrupt Flag bit\n1 = A bus collision occurred while the MSSP module (configured in I 2 C Master mode) was transmitting (must be cleared in software)\n0 = No bus collision occurred",
    "bit 2 LVDIF : Low-Voltage Detect Interrupt Flag bit\n1 = A low voltage condition occurred (must be cleared in software)\n0 = The device voltage is above the Low-Voltage Detect trip point",
    "bit 1 TMR3IF : TMR3 Overflow Interrupt Flag bit\n1 = TMR3 register overflowed (must be cleared in software)\n0 = TMR3 register did not overflow",
    "Capture mode:\n1 = A TMR1 or TMR3 register capture occurred (must be cleared in software)\n0 = No TMR1 or TMR3 register capture occurred",
    "Compare mode:\n1 = A TMR1 or TMR3 register compare match occurred (must be cleared in software)\n0 = No TMR1 or TMR3 register compare match occurred",
    "PWM mode:\nUnused in this mode.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "PIC18F6525/6621/8525/8621\nREGISTER 9-6:",
    "PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\nU-0, 1 = U-0. U-0, 2 = R-0. U-0, 3 = R-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = RC2IF. -, 3 = TX2IF. -, 4 = TMR4IF. -, 5 = CCP5IF. -, 6 = CCP4IF. -, 7 = CCP3IF\nbit 7\nbit 0",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5\nRC2IF : USART2 Receive Interrupt Flag bit\n1 = The USART2 receive buffer, RCREGx, is full (cleared when RCREGx is read)\n0 = The USART2 receive buffer is empty",
    "bit 4\nTX2IF : USART2 Transmit Interrupt Flag bit\n1 = The USART2 transmit buffer, TXREGx, is empty (cleared when TXREGx is written)\n0 = The USART2 transmit buffer is full",
    "bit 3 TMR4IF : TMR3 Overflow Interrupt Flag bit\n1 = TMR4 register overflowed (must be cleared in software)\n0 = TMR4 register did not overflow\nbit 2-0\nCCPxIF : CCPx Interrupt Flag bit (ECCP3, CCP4 and CCP5)",
    "Capture mode:\n1 = A TMR1 or TMR3 register capture occurred (must be cleared in software)\n0 = No TMR1 or TMR3 register capture occurred",
    "Compare mode:\n1 = A TMR1 or TMR3 register compare match occurred (must be cleared in software)\n0 = No TMR1 or TMR3 register compare match occurred",
    "PWM mode:\nUnused in this mode.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "9.3 PIE Registers\nThe PIE registers contain the individual enable bits for the peripheral interrupts. Due  to the number  of peripheral interrupt sources, there are three Peripheral Interrupt  Enable  registers  (PIE1,  PIE2  and  PIE3). When the IPEN bit (RCON<7>) is ' 0 ', the PEIE bit must be set to enable any of these peripheral interrupts.",
    "REGISTER 9-7: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIE (1), 1 = ADIE. PSPIE (1), 2 = RC1IE. PSPIE (1), 3 = TX1IE. PSPIE (1), 4 = SSPIE. PSPIE (1), 5 = CCP1IE. PSPIE (1), 6 = TMR2IE. PSPIE (1), 7 = TMR1IE\nbit 7\nbit 0\n- bit 7 PSPIE: Parallel Slave Port Read/Write Interrupt Enable bit\n(1)\n1 = Enables the PSP read/write interrupt\n0 = Disables the PSP read/write interrupt",
    "REGISTER 9-7: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nNote: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.\nADIE : A/D Converter Interrupt Enable bit\n- 1 = Enables the A/D interrupt\n0 = Disables the A/D interrupt\nRC1IE : USART1 Receive Interrupt Enable bit\n- 1 = Enables the USART1 receive interrupt\n0 = Disables the USART1 receive interrupt\nTX1IE : USART1 Transmit Interrupt Enable bit\n1 = Enables the USART1 transmit interrupt\n0 = Disables the USART1 transmit interrupt",
    "bit 3 SSPIE : Master Synchronous Serial Port Interrupt Enable bit\n1 = Enables the MSSP interrupt\n0 = Disables the MSSP interrupt\nCCP1IE : ECCP1 Interrupt Enable bit\n1 = Enables the ECCP1 interrupt\n0 = Disables the ECCP1 interrupt\nTMR2IE : TMR2 to PR2 Match Interrupt Enable bit\n1 = Enables the TMR2 to PR2 match interrupt\n0 = Disables the TMR2 to PR2 match interrupt\nTMR1IE : TMR1 Overflow Interrupt Enable bit\n1 = Enables the TMR1 overflow interrupt\n0 = Disables the TMR1 overflow interrupt",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "bit 1\nbit 0",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nU-0, 1 = R/W-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = CMIE. -, 2 = -. -, 3 = EEIE. -, 4 = BCLIE. -, 5 = LVDIE. -, 6 = TMR3IE. -, 7 = CCP2IE\nbit 7\nbit 0",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6 CMIE : Comparator Interrupt Enable bit\n1 = Enables the comparator interrupt\n0 = Disables the comparator interrupt\nbit 5 Unimplemented: Read as ' 0 '\nbit 4\nEEIE : Data EEPROM/Flash Write Operation Interrupt Enable bit\n1 = Enables the write operation interrupt\n0 = Disables the write operation interrupt\nbit 3 BCLIE : Bus Collision Interrupt Enable bit\n1 = Enables the bus collision interrupt\n0 = Disables the bus collision interrupt",
    "bit 2 LVDIE : Low-Voltage Detect Interrupt Enable bit\n1 = Enables the Low-Voltage Detect interrupt\n0 = Disables the Low-Voltage Detect interrupt",
    "bit 1 TMR3IE : TMR3 Overflow Interrupt Enable bit\n1 = Enables the TMR3 overflow interrupt\n0 = Disables the TMR3 overflow interrupt",
    "bit 0\nCCP2IE : ECCP2 Interrupt Enable bit\n1 = Enables the ECCP2 interrupt\n0 = Disables the ECCP2 interrupt",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nREGISTER 9-9:",
    "PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = RC2IE. -, 3 = TX2IE. -, 4 = TMR4IE. -, 5 = CCP5IE. -, 6 = CCP4IE. -, 7 = CCP3IE\nbit 7\nbit 0",
    "bit 7-6\nUnimplemented: Read as ' 0 '\nbit 5\nRC2IE : USART2 Receive Interrupt Enable bit\n1 = Enables the USART2 receive interrupt\n0 = Disables the USART2 receive interrupt",
    "bit 4 TX2IE : USART2 Transmit Interrupt Enable bit\n1 = Enables the USART2 transmit interrupt\n0 = Disables the USART2 transmit interrupt",
    "bit 3\nTMR4IE : TMR4 to PR4 Match Interrupt Enable bit\n1 = Enables the TMR4 to PR4 match interrupt\n0 = Disables the TMR4 to PR4 match interrupt\nbit 2-0\nCCPxIE : CCPx Interrupt Enable bit (ECCP3, CCP4 and CCP5)\n1 = Enables the CCPx interrupt\n0 = Disables the CCPx interrupt",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "9.4 IPR Registers\nThe IPR registers contain the individual priority bits for the peripheral interrupts. Due  to the number  of peripheral interrupt sources, there are three Peripheral Interrupt Priority registers (IPR1, IPR2 and IPR3). The operation of the priority bits requires that the Interrupt Priority Enable (IPEN) bit be set.",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = R/W-1. R/W-1, 4 = R/W-1. R/W-1, 5 = R/W-1. R/W-1, 6 = R/W-1. R/W-1, 7 = R/W-1. PSPIP (1), 1 = ADIP. PSPIP (1), 2 = RC1IP. PSPIP (1), 3 = TX1IP. PSPIP (1), 4 = SSPIP. PSPIP (1), 5 = CCP1IP. PSPIP (1), 6 = TMR2IP. PSPIP (1), 7 = TMR1IP\nbit 7\nbit 0\nPSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1)\nbit 7\n1 = High priority\n0 = Low priority\nNote: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.\nbit 6",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nADIP : A/D Converter Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nRC1IP : USART1 Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4\nTX1IP : USART1 Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nSSPIP : Master Synchronous Serial Port Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nCCP1IP : ECCP1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR2IP : TMR2 to PR2 Match Interrupt Priority bit\n1 = High priority\n0 =  Low priority\nbit 0\nTMR1IP : TMR1 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nU-0, 1 = R/W-1. U-0, 2 = U-0. U-0, 3 = R/W-1. U-0, 4 = R/W-1. U-0, 5 = R/W-1. U-0, 6 = R/W-1. U-0, 7 = R/W-1. -, 1 = CMIP. -, 2 = -. -, 3 = EEIP. -, 4 = BCLIP. -, 5 = LVDIP. -, 6 = TMR3IP. -, 7 = CCP2IP\nbit 7\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nCMIP : Comparator Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 5 Unimplemented: Read as ' 0\n'\nbit 4 EEIP : Data EEPROM/Flash Write Operation Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nBCLIP : Bus Collision Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nLVDIP : Low-Voltage Detect Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR3IP : TMR3 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 0\nCCP2IP : ECCP2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nU-0\nU-0\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nR/W-1\n-\n-\nRC2IP\nTX2IP\nTMR4IP\nCCP5IP\nbit 7\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5\nRC2IP : USART2 Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4\nTX2IP : USART2 Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nTMR4IP : TMR4 to PR4 Match Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2-0\nCCPxIP : CCPx Interrupt Priority bit (ECCP3, CCP4 and CCP5)\n1 = High priority\n0 = Low priority",
    "Legend:\nR = Readable bit\n-n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown\nCCP4IP\nR/W-1\nCCP3IP\nbit 0",
    "9.5 RCON Register\nThe RCON register contains the IPEN bit which is used to  enable  prioritized  interrupts.  The  functions  of  the other bits in this register are discussed in more detail in\nSection 4.14 'RCON Register' .",
    "REGISTER 9-13: RCON: RESET CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R-1. R/W-0, 5 = R-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0\nbit 7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16 Compatibility mode)\nbit 6-5 Unimplemented: Read as ' 0 '\nbit 4\nRI: RESET Instruction Flag bit\nFor details of bit operation, see Register 4-4.\nbit 3\nTO: Watchdog Time-out Flag bit\nFor details of bit operation, see Register 4-4.\nbit 2\nPD: Power-down Detection Flag bit",
    "REGISTER 9-13: RCON: RESET CONTROL REGISTER\nFor details of bit operation, see Register 4-4.\nbit 1\nPOR: Power-on Reset Status bit\nFor details of bit operation, see Register 4-4.\nbit 0\nBOR:\nBrown-out Reset Status bit\nFor details of bit operation, see Register 4-4.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "9.8 PORTB Interrupt-on-Change\nExternal interrupts on the RB0/INT0/FLT0, RB1/INT1, RB2/INT2  and  RB3/INT3  pins  are  edge-triggered; either rising if the corresponding INTEDGx bit is set in the INTCON2 register, or falling if the INTEDGx bit is clear. When a valid edge appears on the RBx/INTx pin, the corresponding flag bit, INTxF, is set. This interrupt can be disabled by clearing the corresponding enable bit, INTxE. Flag bit, INTxF, must be cleared in software in the Interrupt Service Routine before re-enabling the interrupt. All external interrupts (INT0, INT1, INT2 and INT3)  can  wake-up  the  processor  from  Sleep  if  bit INTxIE was set prior to going into Sleep. If the Global Interrupt  Enable  bit,  GIE,  is  set,  the  processor  will branch to the interrupt vector following wake-up.",
    "9.8 PORTB Interrupt-on-Change\nThe  interrupt priority for INT1, INT2  and  INT3  is determined by the value contained in the interrupt priority bits: INT1IP (INTCON3<6>), INT2IP (INTCON3<7>) and INT3IP (INTCON2<1>). There is no priority bit associated with INT0; it is always a high priority interrupt source.",
    "9.7 TMR0 Interrupt\nIn 8-bit mode (which is the default), an overflow in the TMR0 register (FFh \uf0ae\uf020 00h) will set flag bit TMR0IF. In 16-bit mode,  an overflow in the TMR0H:TMR0L registers (FFFFh \uf0ae\uf020 0000h) will set flag bit TMR0IF. The interrupt  can  be  enabled/disabled  by  setting/clearing enable bit, TMR0IE (INTCON<5>). Interrupt priority for Timer0  is  determined  by  the  value  contained  in  the interrupt priority bit, TMR0IP  (INTCON2<2>).  See Section 11.0 'Timer0 Module' for  further  details  on the Timer0 module.",
    "SAVING STATUS, WREG AND BSR REGISTERS IN RAM\nMOVWF\nW_TEMP\n; W_TEMP is in virtual bank\nMOVFF\nSTATUS, STATUS_TEMP\n; STATUS_TEMP located anywhere\nMOVFF\nBSR, BSR_TEMP\n; BSR located anywhere\n;\n; USER ISR CODE\n;\nMOVFF\nBSR_TEMP, BSR\n; Restore BSR\nMOVF\nW_TEMP, W\n; Restore WREG\nMOVFF\nSTATUS_TEMP, STATUS\n; Restore STATUS\nAn input change on PORTB<7:4> sets flag bit, RBIF (INTCON<0>). The interrupt can be enabled/disabled by  setting/clearing  enable  bit,  RBIE  (INTCON<3>). Interrupt  priority  for  PORTB  interrupt-on-change  is determined  by  the  value  contained  in  the  interrupt priority bit, RBIP (INTCON2<0>).",
    "9.9 Context Saving During Interrupts\nDuring an interrupt, the return PC value is saved on the stack. Additionally, the WREG,  STATUS  and  BSR registers  are  saved  on  the  fast  return  stack.  If  a  fast return from interrupt is not used (see Section 4.3 'Fast Register  Stack' ), the  user  may  need  to  save  the WREG,  STATUS  and  BSR  registers in software. Depending on the user's application, other registers may also need to be saved. Example 9-1 saves and restores the  WREG,  STATUS  and  BSR  registers  during  an Interrupt Service Routine.",
    "10.0 I/O PORTS\nDepending  on  the  device  selected,  there  are  either seven or nine I/O ports available on PIC18F6525/6621/ 8525/8621 devices. Some of their pins are multiplexed with  one  or  more  alternate  functions  from  the  other peripheral features on the device. In general, when a peripheral is enabled, that pin may not be used as a general purpose I/O pin.\nEach port has three registers for its operation. These registers are:\n\u00b7 TRIS register (data direction register)\n\u00b7 PORT register (reads the levels on the pins of the device)\n\u00b7 LAT register (output latch register)\nThe Data Latch (LAT) register is useful for read-modifywrite  operations  on  the  value  that  the  I/O  pins  are driving.\nA  simplified  version  of  a  generic  I/O  port  and  its operation is shown in Figure 10-1.",
    "10.1 PORTA, TRISA and LATA Registers\nPORTA is a 7-bit  wide, bidirectional  port.  The  corresponding  data  direction  register  is  TRISA.  Setting  a TRISA bit (= 1 ) will make the corresponding PORTA pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISA bit (= 0 ) will make the corresponding PORTA pin an output (i.e., put the contents of the output latch on the selected pin).\nReading the  PORTA register reads the  status of  the pins, whereas writing to it will write to the port latch.\nThe  Data  Latch  register (LATA)  is also memory mapped.  Read-modify-write  operations  on  the  LATA register,  read  and  write  the  latched  output  value  for PORTA.\nThe  RA4  pin  is  multiplexed  with  the  Timer0  module clock input to become the RA4/T0CKI pin. The RA4/ T0CKI pin is a Schmitt Trigger input and an open-drain output. All other RA port pins have TTL input levels and full CMOS output drivers.",
    "10.1 PORTA, TRISA and LATA Registers\nThe RA6 pin is only enabled as a general I/O pin in ECIO and RCIO Oscillator modes.\nThe  other  PORTA  pins  are  multiplexed  with  analog inputs  and  the  analog  VREF+  and  VREF-  inputs.  The operation of each pin is selected by clearing/setting the control  bits  in  the  ADCON1  register  (A/D  Control Register 1).\nNote:, 1 = On a Power-on Reset, RA5 and RA3:RA0 are configured as analog inputs and read as ' 0 '. RA6 and RA4 are configured as digital inputs.\nThe TRISA register controls the direction of the RA pins even when they are being used as analog inputs. The user  must  ensure  the  bits  in  the  TRISA  register  are maintained set when using them as analog inputs.",
    "EXAMPLE 10-1: INITIALIZING PORTA\nCLRF, 1 = PORTA. CLRF, 2 = ; Initialize PORTA by ; clearing output ; data latches. CLRF, 1 = LATA. CLRF, 2 = ; Alternate method to clear output data latches. MOVLW MOVWF, 1 = 0x0F. MOVLW MOVWF, 2 = ; Configure A/D. , 1 = ADCON1. , 2 = ; for digital inputs. MOVWF, 1 = TRISA. MOVWF, 2 = ; Set RA<3:0> as inputs ; RA<6:4> as outputs",
    "BLOCK DIAGRAM OF RA4/T0CKI PIN\nNote 1: I/O pins have protection diodes to VDD and VSS.",
    "TABLE 10-1: PORTA FUNCTIONS\nRA0/AN0, Bit# = bit 0. RA0/AN0, Buffer = TTL. RA0/AN0, Function = Input/output or analog input.. RA1/AN1, Bit# = bit 1. RA1/AN1, Buffer = TTL. RA1/AN1, Function = Input/output or analog input.. RA2/AN2/VREF-, Bit# = bit 2. RA2/AN2/VREF-, Buffer = TTL. RA2/AN2/VREF-, Function = Input/output, analog input or VREF-.. RA3/AN3/VREF+, Bit# = bit 3. RA3/AN3/VREF+, Buffer = TTL. RA3/AN3/VREF+, Function = Input/output, analog input or VREF+.. RA4/T0CKI, Bit# = bit 4. RA4/T0CKI, Buffer = ST. RA4/T0CKI, Function = Input/output or external clock input for Timer0. Output is open-drain type..",
    "TABLE 10-1: PORTA FUNCTIONS\nRA5/AN4/LVDIN, Bit# = bit 5. RA5/AN4/LVDIN, Buffer = TTL. RA5/AN4/LVDIN, Function = Input/output, analog input or Low-Voltage Detect input.. OSC2/CLKO/RA6, Bit# = bit 6. OSC2/CLKO/RA6, Buffer = TTL. OSC2/CLKO/RA6, Function = OSC2, clock output or I/O pin\nLegend: TTL = TTL input, ST = Schmitt Trigger input",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nPORTA, Bit 7 = -. PORTA, Bit 6 = RA6 (1). PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = -x0x 0000. PORTA, Value on all other Resets = -u0u 0000. LATA, Bit 7 = -. LATA, Bit 6 = LATA6 (1). LATA, Bit 5 = LATA Data Output Register. LATA, Bit 4 = LATA Data Output Register. LATA, Bit 3 = LATA Data Output Register. LATA, Bit 2 = LATA Data Output Register. LATA, Bit 1 = LATA Data Output Register. LATA, Bit 0 = LATA Data Output Register. LATA, Value on POR, BOR = -xxx xxxx. LATA, Value on all other Resets = -uuu uuuu. TRISA, Bit 7 = -.",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nTRISA, Bit 6 = TRISA6 (1). TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = -111 1111. TRISA, Value on all other Resets = -111 1111. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = --00 0000. ADCON1, Value on all other Resets = --00 0000\nLegend:",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nx = unknown, u = unchanged, - = unimplemented locations read as ' 0 '. Shaded cells are not used by PORTA.\nNote 1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator modes only and read ' 0 ' in all other oscillator modes.",
    "10.2 PORTB, TRISB and LATB Registers\nPORTB is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISB.  Setting  a TRISB bit (= 1 )  will  make the corresponding PORTB pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISB bit (= 0 ) will make the corresponding PORTB pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATB)  is also memory mapped.  Read-modify-write  operations  on  the  LATB register,  read  and  write  the  latched  output  value  for PORTB.",
    "EXAMPLE 10-2: INITIALIZING PORTB\nCLRF, 1 = PORTB. CLRF, 2 = ; ; ;. CLRF, 3 = Initialize PORTB by clearing output data latches. CLRF, 1 = LATB. CLRF, 2 = ; ;. CLRF, 3 = Alternate method to clear output. MOVLW, 1 = 0xCF. MOVLW, 2 = ; ; ;. MOVLW, 3 = Value used to initialize data direction. MOVWF, 1 = TRISB. MOVWF, 2 = ; ; ;. MOVWF, 3 = Set RB<3:0> as inputs RB<5:4> as outputs RB<7:6> as inputs\nEach of the PORTB pins has a weak internal pull-up. A single  control  bit  can  turn  on  all  the  pull-ups.  This  is performed by clearing bit RBPU (INTCON2<7>). The weak pull-up is automatically turned off when the port pin  is configured  as  an  output.  The  pull-ups  are disabled on a Power-on Reset.\nOn  a  Power-on  Reset,  these  pins  are\nNote: configured as digital inputs.",
    "EXAMPLE 10-2: INITIALIZING PORTB\nFour of the PORTB pins (RB3:RB0) are the external interrupt pins, INT3 through INT0. In order to use these pins as external interrupts, the corresponding TRISB bit must be set to ' 1 '.\nThe  other  four  PORTB  pins  (RB7:RB4)  have  an interrupt-on-change  feature.  Only  pins  configured  as inputs  can  cause  this  interrupt  to  occur  (i.e.,  any RB7:RB4 pin configured as an output is excluded from the interrupt-on-change comparison). The input pins (of RB7:RB4) are compared with the old value latched on the  last  read  of  PORTB.  The  'mismatch'  outputs  of RB7:RB4 are ORed together to generate the RB Port Change Interrupt with Flag bit, RBIF (INTCON<0>).\nThis  interrupt  can  wake  the  device  from  Sleep.  The user,  in  the  Interrupt  Service  Routine,  can  clear  the interrupt in the following manner:\na) Any  read  or  write  of  PORTB  (except  with  the MOVFF instruction).\nb) Clear flag bit RBIF.",
    "EXAMPLE 10-2: INITIALIZING PORTB\nA mismatch condition will continue to set flag bit, RBIF. Reading PORTB will end the mismatch condition and allow flag bit RBIF to be cleared.\nThe interrupt-on-change  feature  is  recommended  for wake-up on key depression operation and operations where PORTB is only used for the interrupt-on-change feature. Polling of PORTB is not recommended while using the interrupt-on-change feature.\nFor PIC18F8525/8621 devices, RB3 can be configured by  the  configuration  bit,  CCP2MX,  as  the  alternate peripheral  pin  for  the  ECCP2  module.  This  is  only available when the device is configured in Microprocessor,  Microprocessor  with  Boot  Block  or Extended Microcontroller operating modes.\nThe  RB5  pin  is  used  as  the  LVP  programming  pin. When the LVP configuration bit is programmed, this pin loses the I/O function and becomes a programming test function.\nNote:\nWhen LVP is enabled, the weak pull-up on RB5 is disabled.",
    "FIGURE 10-5: BLOCK DIAGRAM OF RB7:RB4 PINS\nNote 1: I/O pins have diode protection to VDD and VSS.\n- 2: To enable weak pull-ups, set the appropriate TRIS bit(s) and clear the RBPU bit (INTCON2<7>).",
    "FIGURE 10-7: BLOCK DIAGRAM OF RB3 PIN\nNote\n1: I/O pin has diode protection to VDD and VSS.\n2: To enable weak pull-ups, set the appropriate TRIS bit(s) and clear the RBPU bit (INTCON2<7>).\n3: For PIC18F8525/8621 parts, the ECCP2 input/output is multiplexed with RB3 if the CCP2MX bit is enabled (= 0 ) in the Configuration register and the device is operating in Microprocessor, Microprocessor with Boot Block or Extended Microcontroller mode.",
    "TABLE 10-3: PORTB FUNCTIONS\nRB0/INT0/FLT0, Bit# = bit 0. RB0/INT0/FLT0, Buffer = TTL/ST (1). RB0/INT0/FLT0, Function = Input/output pin or external interrupt input 0, ECCP1 PWM Fault input. Internal software programmable weak pull-up.. RB1/INT1, Bit# = bit 1. RB1/INT1, Buffer = TTL/ST (1). RB1/INT1, Function = Input/output pin or external interrupt input 1. Internal software programmable weak pull-up.. RB2/INT2, Bit# = bit 2. RB2/INT2, Buffer = TTL/ST (1). RB2/INT2, Function = Input/output pin or external interrupt input 2. Internal software programmable weak pull-up.. RB3/INT3/ ECCP2 (3) /P2A (3), Bit# = bit 3. RB3/INT3/ ECCP2 (3) /P2A (3), Buffer = TTL/ST (4).",
    "TABLE 10-3: PORTB FUNCTIONS\nRB3/INT3/ ECCP2 (3) /P2A (3), Function = Input/output pin, external interrupt input 3, Enhanced Capture 2 input/ Compare 2 output/PWM 2 output or Enhanced PWM output P2A. Internal software programmable weak pull-up.. RB4/KBI0, Bit# = bit 4. RB4/KBI0, Buffer = TTL. RB4/KBI0, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up.. RB5/KBI1/PGM, Bit# = bit 5. RB5/KBI1/PGM, Buffer = TTL/ST (2). RB5/KBI1/PGM, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Low-Voltage ICSP\u2122 enable pin.. RB6/KBI2/PGC, Bit# = bit 6. RB6/KBI2/PGC, Buffer = TTL/ST (2).",
    "TABLE 10-3: PORTB FUNCTIONS\nRB6/KBI2/PGC, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Serial programming clock.. RB7/KBI3/PGD, Bit# = bit 7. RB7/KBI3/PGD, Buffer = TTL/ST (2). RB7/KBI3/PGD, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Serial programming data.\nLegend: TTL = TTL input, ST = Schmitt Trigger input",
    "TABLE 10-3: PORTB FUNCTIONS\nNote 1: This buffer is a Schmitt Trigger input when configured as the external interrupt.\n2: This buffer is a Schmitt Trigger input when used in Serial Programming mode.\n3: Valid for PIC18F8525/8621 devices in all operating modes except Microcontroller mode when CCP2MX is not set. RC1 is the default assignment for ECCP2/PA2 when CCP2MX is set in all devices; RE7 is the alternate assignment for PIC18F8525/8621 devices in Microcontroller mode when CCP2MX is clear.\n4: This buffer is a Schmitt Trigger input when configured as the ECCP2 input.",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nPORTB, Bit 7 = RB7. PORTB, Bit 6 = RB6. PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 = RB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTB, Value on POR, BOR = xxxx xxxx. PORTB, Value on all other Resets = uuuu. PORTB, Value on all other Resets = uuuu. LATB, Bit 7 = LATB Data Output Register. LATB, Bit 6 = LATB Data Output Register. LATB, Bit 5 = LATB Data Output Register. LATB, Bit 4 = LATB Data Output Register. LATB, Bit 3 = LATB Data Output Register. LATB, Bit 2 = LATB Data Output Register. LATB, Bit 1 = LATB Data Output Register. LATB, Bit 0 = LATB Data Output Register. LATB, Value on POR, BOR = xxxx",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nxxxx. LATB, Value on all other Resets = uuuu. LATB, Value on all other Resets = uuuu. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111 1111. TRISB, Value on all other Resets = 1111. TRISB, Value on all other Resets = 1111. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\n= INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = INTEDG3. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = INT3IP. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111 1111. INTCON2, Value on all other Resets = 1111. INTCON2, Value on all other Resets = 1111. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = INT3IE. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 =",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nINT1IE. INTCON3, Bit 2 = INT3IF. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 1100 0000. INTCON3, Value on all other Resets = 1100. INTCON3, Value on all other Resets = 0000\nLegend:\nx = unknown, u = unchanged. Shaded cells are not used by PORTB.",
    "10.3 PORTC, TRISC and LATC Registers\nPORTC is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISC.  Setting  a TRISC bit (= 1 )  will  make the corresponding PORTC pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISC bit (= 0 ) will make the corresponding PORTC pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATC)  is  also memory mapped.  Read-modify-write  operations  on  the  LATC register,  read  and  write  the  latched  output  value  for PORTC.\nPORTC is multiplexed with several peripheral functions (Table 10-5). PORTC pins have Schmitt Trigger input buffers.\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTC pin. Some peripherals  override  the  TRIS  bit  to  make  a  pin  an output, while other peripherals override the TRIS bit to make  a  pin  an  input.  The  user  should  refer  to  the corresponding peripheral section for the correct TRIS bit settings.",
    "10.3 PORTC, TRISC and LATC Registers\nThe  pin  override  value  is  not  loaded  into  the  TRIS register.  This  allows  read-modify-write  of  the  TRIS register without concern due to peripheral overrides.\nRC1  is normally configured by configuration bit, CCP2MX, as the default peripheral pin of the ECCP2 module (default/erased state, CCP2MX = 1 ).",
    "EXAMPLE 10-3: INITIALIZING PORTC\nCLRF, 1 = PORTC. CLRF, 2 = ; Initialize PORTC by ; clearing output ; data latches. CLRF, 1 = LATC. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0xCF. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISC. MOVWF, 2 = ; Set RC<3:0> as inputs ; RC<5:4> as outputs ; RC<7:6> as inputs\nNote:, 1 = On a Power-on Reset, these pins are configured as digital inputs.",
    "FIGURE 10-8: PORTC BLOCK DIAGRAM (PERIPHERAL OUTPUT OVERRIDE)\nRC0, Override = Yes. RC0, Peripheral = Timer1 Oscillator for Timer1/Timer3. RC1, Override = Yes. RC1, Peripheral = Timer1 OSC for Timer1/Timer3, ECCP2 I/O. RC2, Override = Yes. RC2, Peripheral = ECCP1 I/O. RC3, Override = Yes. RC3, Peripheral = SPI\u2122/I 2 C\u2122 Master Clock. RC4, Override = Yes. RC4, Peripheral = I 2 C Data Out. RC5, Override = Yes. RC5, Peripheral = SPI Data Out. RC6, Override = Yes. RC6, Peripheral = USART1 Async Xmit, Sync Clock. RC7, Override = Yes. RC7, Peripheral = USART1 Sync Data Out",
    "TABLE 10-5: PORTC FUNCTIONS\nRC0/T1OSO/T13CKI, Bit# = bit 0. RC0/T1OSO/T13CKI, Buffer Type = ST. RC0/T1OSO/T13CKI, Function = Input/output port pin, Timer1 oscillator output or Timer1/Timer3 clock input.. RC1/T1OSI/ ECCP2 (1) /P2A (1), Bit# = bit 1. RC1/T1OSI/ ECCP2 (1) /P2A (1), Buffer Type = ST. RC1/T1OSI/ ECCP2 (1) /P2A (1), Function = Input/output port pin, Timer1 oscillator input, Enhanced Capture 2 input/Compare 2 output/PWM 2 output or Enhanced PWM output P2A.. RC2/ECCP1/P1A, Bit# = bit 2. RC2/ECCP1/P1A, Buffer Type = ST. RC2/ECCP1/P1A, Function = Input/output port pin, Enhanced Capture 1 input/Compare 1 output/ PWM",
    "TABLE 10-5: PORTC FUNCTIONS\n1 output or Enhanced PWM output P1A.. RC3/SCK/SCL, Bit# = bit 3. RC3/SCK/SCL, Buffer Type = ST. RC3/SCK/SCL, Function = RC3 can also be the synchronous serial clock for both SPI\u2122 and I 2 C\u2122modes.. RC4/SDI/SDA, Bit# = bit 4. RC4/SDI/SDA, Buffer Type = ST. RC4/SDI/SDA, Function = RC4 can also be the SPI data in (SPI mode) or data I/O (I 2 C mode).. RC5/SDO, Bit# = bit 5. RC5/SDO, Buffer Type = ST. RC5/SDO, Function = Input/output port pin or synchronous serial port data output.. RC6/TX1/CK1, Bit# = bit 6. RC6/TX1/CK1, Buffer Type = ST. RC6/TX1/CK1, Function = Input/output port pin, Addressable USART1",
    "TABLE 10-5: PORTC FUNCTIONS\nAsynchronous Transmit or Addressable USART1 Synchronous Clock.. RC7/RX1/DT1, Bit# = bit 7. RC7/RX1/DT1, Buffer Type = ST. RC7/RX1/DT1, Function = Input/output port pin, Addressable USART1 Asynchronous Receive or Addressable USART1 Synchronous Data.\nLegend:\nST = Schmitt Trigger input\nNote 1:\nValid when CCP2MX is set in all devices and in all operating modes (default). RE7 is the alternate assignment for ECCP2/P2A for all PIC18F6525/6621 devices and PIC18F8525/8621 devices in Microcontroller modes when CCP2MX is not set; RB3 is the alternate assignment for PIC18F8525/8621 devices in all other operating modes.",
    "TABLE 10-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nPORTC, Bit 7 = RC7. PORTC, Bit 6 = RC6. PORTC, Bit 5 = RC5. PORTC, Bit 4 = RC4. PORTC, Bit 3 = RC3. PORTC, Bit 2 = RC2. PORTC, Bit 1 = RC1. PORTC, Bit 0 = RC0. PORTC, Value on POR, BOR = xxxx. PORTC, Value on POR, BOR = xxxx. PORTC, Value on all other Resets = uuuu. PORTC, Value on all other Resets = uuuu. LATC, Bit 7 = LATC Data Output Register. LATC, Bit 6 = LATC Data Output Register. LATC, Bit 5 = LATC Data Output Register. LATC, Bit 4 = LATC Data Output Register. LATC, Bit 3 = LATC Data Output Register. LATC, Bit 2 = LATC Data Output Register. LATC, Bit 1 = LATC Data Output Register. LATC, Bit 0 = LATC Data Output Register. LATC, Value on POR, BOR = xxxx. LATC, Value on POR,",
    "TABLE 10-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nBOR = xxxx. LATC, Value on all other Resets = uuuu. LATC, Value on all other Resets = uuuu. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other Resets = 1111. TRISC, Value on all other Resets = 1111\nLegend:\nx = unknown, u = unchanged",
    "10.4 PORTD, TRISD and LATD Registers\nPORTD is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISD.  Setting  a TRISD bit (= 1 )  will  make the corresponding PORTD pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISD bit (= 0 ) will make the corresponding PORTD pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATD)  is  also memory mapped.  Read-modify-write  operations  on  the  LATD register,  read  and  write  the  latched  output  value  for PORTD.\nPORTD  is  an  8-bit  port  with  Schmitt  Trigger  input buffers. Each pin is individually configurable as an input or output.\nNote:, 1 = On a Power-on Reset, these pins are configured as digital inputs.",
    "10.4 PORTD, TRISD and LATD Registers\nPORTD  is  multiplexed  with  the  system  bus  as  the external memory interface. I/O port functions are only available when the system bus is disabled by setting the EBDIS bit in the MEMCOM register (MEMCON<7>).  When  operating as the external memory interface, PORTD is the low-order byte of the multiplexed address/data bus (AD7:AD0).\nPORTD  can  also  be  configured  as  an  8-bit  wide microprocessor  port  (Parallel  Slave  Port)  by  setting control bit PSPMODE (TRISE<4>). In this mode, the input  buffers  are  TTL.  See Section 10.10  'Parallel Slave Port' for  additional information on the Parallel Slave Port (PSP).",
    "EXAMPLE 10-4: INITIALIZING PORTD\nCLRF, 1 = PORTD. CLRF, 2 = ; Initialize PORTD by ; clearing output ; data latches. CLRF, 1 = LATD. CLRF, 2 = ; Alternate method ; to clear output. MOVLW, 1 = 0xCF. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISD. MOVWF, 2 = ; Set RD<3:0> as inputs ; RD<5:4> as outputs ; RD<7:6> as inputs",
    "FIGURE 10-9: PORTD BLOCK DIAGRAM IN I/O PORT MODE\nNote 1: I/O pins have diode protection to VDD and VSS.",
    "TABLE 10-7: PORTD FUNCTIONS\nRD0/AD0 (2) /PSP0, Bit# = bit 0. RD0/AD0 (2) /PSP0, Buffer Type = ST/TTL (1). RD0/AD0 (2) /PSP0, Function = Input/output port pin, address/data bus bit 0 or Parallel Slave Port bit 0.. RD1/AD1 (2) /PSP1, Bit# = bit 1. RD1/AD1 (2) /PSP1, Buffer Type = ST/TTL (1). RD1/AD1 (2) /PSP1, Function = Input/output port pin, address/data bus bit 1 or Parallel Slave Port bit 1.. RD2/AD2 (2) /PSP2, Bit# = bit 2. RD2/AD2 (2) /PSP2, Buffer Type = ST/TTL (1). RD2/AD2 (2) /PSP2, Function = Input/output port pin, address/data bus bit 2 or Parallel Slave Port bit 2.. RD3/AD3 (2) /PSP3,",
    "TABLE 10-7: PORTD FUNCTIONS\nBit# = bit 3. RD3/AD3 (2) /PSP3, Buffer Type = ST/TTL (1). RD3/AD3 (2) /PSP3, Function = Input/output port pin, address/data bus bit 3 or Parallel Slave Port bit 3.. RD4/AD4 (2) /PSP4, Bit# = bit 4. RD4/AD4 (2) /PSP4, Buffer Type = ST/TTL (1). RD4/AD4 (2) /PSP4, Function = Input/output port pin, address/data bus bit 4 or Parallel Slave Port bit 4.. RD5/AD5 (2) /PSP5, Bit# = bit 5. RD5/AD5 (2) /PSP5, Buffer Type = ST/TTL (1). RD5/AD5 (2) /PSP5, Function = Input/output port pin, address/data bus bit 5 or Parallel Slave Port bit 5.. RD6/AD6 (2) /PSP6, Bit# = bit 6. RD6/AD6 (2)",
    "TABLE 10-7: PORTD FUNCTIONS\n/PSP6, Buffer Type = ST/TTL (1). RD6/AD6 (2) /PSP6, Function = Input/output port pin, address/data bus bit 6 or Parallel Slave Port bit 6.. RD7/AD7 (2) /PSP7, Bit# = bit 7. RD7/AD7 (2) /PSP7, Buffer Type = ST/TTL (1). RD7/AD7 (2) /PSP7, Function = Input/output port pin, address/data bus bit 7 or Parallel Slave Port bit 7.\nLegend: ST = Schmitt Trigger input, TTL = TTL input\nNote 1: Input buffers are Schmitt Triggers when in I/O mode and TTL buffers when in System Bus or Parallel Slave Port mode.\n2: External memory interface functions are only available on PIC18F8525/8621 devices.",
    "TABLE 10-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nPORTD, Bit 7 = RD7. PORTD, Bit 6 = RD6. PORTD, Bit 5 = RD5. PORTD, Bit 4 = RD4. PORTD, Bit 3 = RD3. PORTD, Bit 2 = RD2. PORTD, Bit 1 = RD1. PORTD, Bit 0 = RD0. PORTD, Value on POR, BOR = xxxx. PORTD, Value on all other Resets = xxxx. PORTD, Value on all other Resets = uuuu. PORTD, Value on all other Resets = uuuu. LATD, Bit 7 = LATD Data Output Register. LATD, Bit 6 = LATD Data Output Register. LATD, Bit 5 = LATD Data Output Register. LATD, Bit 4 = LATD Data Output Register. LATD, Bit 3 = LATD Data Output Register. LATD, Bit 2 = LATD Data Output Register. LATD, Bit 1 = LATD Data Output Register. LATD, Bit 0 = LATD Data Output Register. LATD,",
    "TABLE 10-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nValue on POR, BOR = xxxx. LATD, Value on all other Resets = xxxx. LATD, Value on all other Resets = uuuu. LATD, Value on all other Resets = uuuu. TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Value on POR, BOR = 1111. TRISD, Value on all other Resets = 1111. TRISD, Value on all other Resets = 1111. TRISD, Value on all other Resets = 1111. PSPCON (1), Bit 7 = IBF. PSPCON (1), Bit 6 = OBF. PSPCON (1), Bit 5 = IBOV.",
    "TABLE 10-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nPSPCON (1), Bit 4 = PSPMODE. PSPCON (1), Bit 3 = -. PSPCON (1), Bit 2 = -. PSPCON (1), Bit 1 = -. PSPCON (1), Bit 0 = -. PSPCON (1), Value on POR, BOR = 0000. PSPCON (1), Value on all other Resets = ----. PSPCON (1), Value on all other Resets = 0000. PSPCON (1), Value on all other Resets = ----. MEMCON (2), Bit 7 = EBDIS. MEMCON (2), Bit 6 = -. MEMCON (2), Bit 5 = WAIT1. MEMCON (2), Bit 4 = WAIT0. MEMCON (2), Bit 3 = -. MEMCON (2), Bit 2 = -. MEMCON (2), Bit 1 = WM1. MEMCON (2), Bit 0 = WM0. MEMCON",
    "TABLE 10-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\n(2), Value on POR, BOR = 0-00. MEMCON (2), Value on all other Resets = --00. MEMCON (2), Value on all other Resets = 0-00. MEMCON (2), Value on all other Resets = --00\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by PORTD.\nNote\n1: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.\n2: This register is unused on PIC18F6525/6621 devices and reads as ' 0 '.",
    "10.5 PORTE, TRISE and LATE Registers\nPORTE is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISE.  Setting  a TRISE bit (= 1 )  will  make the corresponding PORTE pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISE bit (= 0 ) will make the corresponding PORTE pin an output (i.e., put the contents of the output latch on the selected pin).\nWhen the Parallel Slave Port is active, three PORTE pins (RE0/AD8/RD/P2D, RE1/AD9/WR/P2C and RE2/ AD10/CS/P2B)  function  as  its  control  inputs.  This automatically occurs when the PSPMODE bit (PSPCON<4>) is set. Users must also make certain that bits TRISE<2:0> are set to configure the pins as digital  inputs and the ADCON1 register is configured for digital I/O. The PORTE PSP control functions are summarized in Table 10-9.\nRead-modify-write  operations  on  the  LATE  register, read and write the latched output value for PORTE.",
    "10.5 PORTE, TRISE and LATE Registers\nPORTE  is  an  8-bit  port  with  Schmitt  Trigger  input buffers. Each pin is individually configurable as an input or output. PORTE  is  multiplexed  with  the  ECCP module (Table 10-9).\nOn PIC18F8525/8621 devices, PORTE is also multiplexed with the system bus as the external memory interface; the I/O bus is available only when the system bus is disabled by setting the EBDIS bit in the MEMCON register  (MEMCON<7>). If the device is configured in Microprocessor or Extended Microcontroller mode, then the PORTE<7:0> becomes the high byte of the address/ data bus for the external program memory interface. In Microcontroller  mode,  the  PORTE<2:0>  pins  become the  control  inputs  for  the  Parallel  Slave  Port  when  bit PSPMODE (PSPCON<4>) is set. (Refer to Section 4.1.1 'PIC18F6525/6621/8525/8621 Program Memory Modes' for more information.)",
    "10.5 PORTE, TRISE and LATE Registers\nPin RE7 can be configured as the alternate peripheral pin for the ECCP2 module when the device is operating in  Microcontroller mode. This is done by clearing the configuration bit, CCP2MX, in the CONFIG3H Configuration register (CONFIG3H<0>).",
    "Note:\nFor  PIC18F8525/8621  (80-pin)  devices operating in Extended Microcontroller mode, PORTE defaults to the system bus on Power-on Reset.",
    "EXAMPLE 10-5: INITIALIZING PORTE\nCLRF, 1 = PORTE. CLRF, 2 = ; Initialize PORTE by ; clearing output ; data latches. CLRF, 1 = LATE. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0x03. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISE. MOVWF, 2 = ; Set RE1:RE0 as inputs ; RE7:RE2 as outputs",
    "TABLE 10-9: PORTE FUNCTIONS\nRE0/AD8/RD/P2D, Bit# = bit 0. RE0/AD8/RD/P2D, Buffer Type = ST/TTL (1). RE0/AD8/RD/P2D, Function = Input/output port pin, address/data bit 8, read control for Parallel Slave Port or Enhanced PWM 2 output P2D For RD (PSP Control mode): 1 = Not a read operation 0 = Read operation, reads PORTD register (if chip selected). RE1/AD9/WR/P2C, Bit# = bit 1. RE1/AD9/WR/P2C, Buffer Type = ST/TTL (1). RE1/AD9/WR/P2C, Function = Input/output port pin, address/data bit 9, write control for Parallel Slave Port or Enhanced PWM 2 output P2C For WR (PSP Control mode): 1 = Not a write operation 0 = Write operation, writes PORTD register (if chip selected). RE2/AD10/CS/P2B, Bit# = bit 2.",
    "TABLE 10-9: PORTE FUNCTIONS\nRE2/AD10/CS/P2B, Buffer Type = ST/TTL (1). RE2/AD10/CS/P2B, Function = Input/output port pin, address/data bit 10, chip select control for Parallel Slave Port or Enhanced PWM 2 output P2B For CS (PSP Control mode): 1 = Device is not selected 0 = Device is selected. RE3/AD11/P3C (2), Bit# = bit 3. RE3/AD11/P3C (2), Buffer Type = ST/TTL (1). RE3/AD11/P3C (2), Function = Input/output port pin, address/data bit 11 or Enhanced PWM 3 output P3C.. RE4/AD12/P3B (2), Bit# = bit 4. RE4/AD12/P3B (2), Buffer Type = ST/TTL (1). RE4/AD12/P3B (2), Function = Input/output port pin, address/data bit 12 or Enhanced PWM 3 output P3B..",
    "TABLE 10-9: PORTE FUNCTIONS\nRE5/AD13/P1C (2), Bit# = bit 5. RE5/AD13/P1C (2), Buffer Type = ST/TTL (1). RE5/AD13/P1C (2), Function = Input/output port pin, address/data bit 13 or Enhanced PWM 1 output P1C.. RE6/AD14/P1B (2), Bit# = bit 6. RE6/AD14/P1B (2), Buffer Type = ST/TTL (1). RE6/AD14/P1B (2), Function = Input/output port pin, address/data bit 14 or Enhanced PWM 1 output P1B.. RE7/AD15/ ECCP2 (3) /P2A (3), Bit# = bit 7. RE7/AD15/ ECCP2 (3) /P2A (3), Buffer Type = ST/TTL (1). RE7/AD15/ ECCP2 (3) /P2A (3), Function = Input/output port pin,",
    "TABLE 10-9: PORTE FUNCTIONS\naddress/data bit 15, Enhanced Capture 2 input/ Compare 2 output/PWM 2 output or Enhanced PWM 2 output P2A.\nLegend: ST = Schmitt Trigger input, TTL = TTL input",
    "TABLE 10-9: PORTE FUNCTIONS\nNote 1: Input buffers are Schmitt Triggers when in I/O or CCP/ECCP modes and TTL buffers when in System Bus or PSP Control modes.\n2: Valid for all PIC18F6525/6621 devices and PIC18F8525/8621 devices when ECCPMX is set. Alternate assignments for P1B/P1C/P3B/P3C are RH7, RH6, RH5 and RH4, respectively.\n3: Valid for all PIC18F6525/6621 devices and PIC18F8525/8621 devices in Microcontroller mode when CCP2MX is not set. RC1 is the default assignment for ECCP2/P2A for all devices in Microcontroller mode when CCP2MX is set; RB3 is the alternate assignment for PIC18F8525/8621 devices in operating modes except Microcontroller mode when CCP2MX is not set.",
    "TABLE 10-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nTRISE, Bit 7 = PORTE Data Direction Control Register. TRISE, Bit 6 = PORTE Data Direction Control Register. TRISE, Bit 5 = PORTE Data Direction Control Register. TRISE, Bit 4 = PORTE Data Direction Control Register. TRISE, Bit 3 = PORTE Data Direction Control Register. TRISE, Bit 2 = PORTE Data Direction Control Register. TRISE, Bit 1 = PORTE Data Direction Control Register. TRISE, Bit 0 = PORTE Data Direction Control Register. TRISE,  = 1111. TRISE, Value on: POR, BOR = 1111. TRISE, Value on all other Resets = 1111 1111. TRISE,",
    "TABLE 10-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\n= 1111 1111. PORTE, Bit 7 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 6 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 5 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 4 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 3 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 2 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 1 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 0 = Read PORTE pin/Write PORTE Data Latch. PORTE,  = xxxx. PORTE, Value on: POR, BOR = xxxx. PORTE, Value on all other Resets = uuuu. PORTE,",
    "TABLE 10-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\n= uuuu. LATE, Bit 7 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 6 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 5 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 4 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 3 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 2 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 1 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 0 = Read PORTE Data Latch/Write PORTE Data Latch. LATE,  = xxxx. LATE, Value on: POR, BOR = xxxx. LATE, Value on all other Resets = uuuu. LATE,",
    "TABLE 10-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\n= uuuu. MEMCON (1), Bit 7 = EBDIS. MEMCON (1), Bit 6 = -. MEMCON (1), Bit 5 = WAIT1. MEMCON (1), Bit 4 = WAIT0. MEMCON (1), Bit 3 = -. MEMCON (1), Bit 2 = -. MEMCON (1), Bit 1 = WM1. MEMCON (1), Bit 0 = WM0. MEMCON (1),  = 0-00. MEMCON (1), Value on: POR, BOR = --00. MEMCON (1), Value on all other Resets = 0000. MEMCON (1),",
    "TABLE 10-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\n= --00. PSPCON (2), Bit 7 = IBF. PSPCON (2), Bit 6 = OBF. PSPCON (2), Bit 5 = IBOV. PSPCON (2), Bit 4 = PSPMODE. PSPCON (2), Bit 3 = -. PSPCON (2), Bit 2 = -. PSPCON (2), Bit 1 = -. PSPCON (2), Bit 0 = -. PSPCON (2),  = 0000. PSPCON (2), Value on: POR, BOR = ----. PSPCON (2), Value on all other Resets = 0000. PSPCON (2),  = ----\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by PORTE.\nNote 1: This register is unused on PIC18F6525/6621 devices and reads as ' 0 '.\n2: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "EXAMPLE 10-6: INITIALIZING PORTF\nPORTF is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISF.  Setting  a TRISF bit (= 1 ) will make the corresponding PORTF pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISF bit (= 0 ) will make the corresponding PORTF pin an output (i.e., put the contents of the output latch on the selected pin).\nRead-modify-write  operations  on  the  LATF  register, read and write the latched output value for PORTF.\nPORTF is multiplexed with several analog peripheral functions, including the A/D  converter  inputs  and comparator inputs, outputs and voltage reference.\nNote 1:, 1 = On a Power-on Reset, the RF6:RF0 pins are configured as inputs and read as ' 0 '.. 2:, 1 = To configure PORTFas digital I/O, turn off comparators and set ADCON1 value.",
    "EXAMPLE 10-6: INITIALIZING PORTF\nCLRF, 1 = PORTF. CLRF, 2 = ; ;. CLRF, 3 = Initialize PORTF by clearing output ; data latches. CLRF, 1 = LATF. CLRF, 2 = ; ; ;. CLRF, 3 = Alternate method to clear output data latches. MOVLW MOVWF MOVLW, 1 = 0x07 CMCON 0x0F. MOVLW MOVWF MOVLW, 2 = ; ; ;. MOVLW MOVWF MOVLW, 3 = Turn off comparators. MOVWF MOVLW, 1 = ADCON1 0xCF. MOVWF MOVLW, 2 = ; ; ;. MOVWF MOVLW, 3 = Set PORTF as digital I/O Value used to initialize data. MOVWF, 1 = TRISF. MOVWF, 2 = ; ;. MOVWF, 3 = Set RF3:RF0 as inputs RF5:RF4 as outputs ; RF7:RF6 as inputs",
    "FIGURE 10-15:\nNote 1: I/O pins have diode protection to VDD and VSS.",
    "TABLE 10-11: PORTF FUNCTIONS\nRF0/AN5, Bit# = bit 0. RF0/AN5, Buffer Type = ST. RF0/AN5, Function = Input/output port pin or analog input.. RF1/AN6/C2OUT, Bit# = bit 1. RF1/AN6/C2OUT, Buffer Type = ST. RF1/AN6/C2OUT, Function = Input/output port pin, analog input or Comparator 2 output.. RF2/AN7/C1OUT, Bit# = bit 2. RF2/AN7/C1OUT, Buffer Type = ST. RF2/AN7/C1OUT, Function = Input/output port pin, analog input or Comparator 1 output.. RF3/AN8, Bit# = bit 3. RF3/AN8, Buffer Type = ST. RF3/AN8, Function = Input/output port pin or analog input/comparator input.. RF4/AN9, Bit# = bit 4. RF4/AN9, Buffer Type = ST. RF4/AN9, Function = Input/output port pin or analog input/comparator input..",
    "TABLE 10-11: PORTF FUNCTIONS\nRF5/AN10/CVREF, Bit# = bit 5. RF5/AN10/CVREF, Buffer Type = ST. RF5/AN10/CVREF, Function = Input/output port pin, analog input/comparator input or comparator reference output.. RF6/AN11, Bit# = bit 6. RF6/AN11, Buffer Type = ST. RF6/AN11, Function = Input/output port pin or analog input/comparator input.. RF7/SS, Bit# = bit 7. RF7/SS, Buffer Type = ST/TTL. RF7/SS, Function = Input/output port pin or slave select pin for synchronous serial port.\nLegend: ST = Schmitt Trigger input, TTL = TTL input",
    "TABLE 10-12: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nTRISF, Bit 7 = PORTF Data Direction Control Register. TRISF, Bit 6 = PORTF Data Direction Control Register. TRISF, Bit 5 = PORTF Data Direction Control Register. TRISF, Bit 4 = PORTF Data Direction Control Register. TRISF, Bit 3 = PORTF Data Direction Control Register. TRISF, Bit 2 = PORTF Data Direction Control Register. TRISF, Bit 1 = PORTF Data Direction Control Register. TRISF, Bit 0 = PORTF Data Direction Control Register. TRISF, Value on: POR, BOR = 1111. TRISF, Value on: POR, BOR = 1111. TRISF, Value on all other Resets = 1111. TRISF, Value on all other Resets = 1111. PORTF, Bit 7 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 6 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 5 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 4 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 3 = Read PORTF pin/Write PORTF Data Latch.",
    "TABLE 10-12: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nPORTF, Bit 2 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 1 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 0 = Read PORTF pin/Write PORTF Data Latch. PORTF, Value on: POR, BOR = x000. PORTF, Value on: POR, BOR = 0000. PORTF, Value on all other Resets = u000. PORTF, Value on all other Resets = 0000. LATF, Bit 7 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 6 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 5 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 4 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 3 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 2 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 1 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 0 = Read PORTF Data",
    "TABLE 10-12: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nLatch/Write PORTF Data Latch. LATF, Value on: POR, BOR = xxxx. LATF, Value on: POR, BOR = xxxx. LATF, Value on all other Resets = uuuu. LATF, Value on all other Resets = uuuu. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on: POR, BOR = --00. ADCON1, Value on: POR, BOR = 0000. ADCON1, Value on all other Resets = --00. ADCON1, Value on all other Resets = 0000. CMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV.",
    "TABLE 10-12: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nCMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Value on: POR, BOR = 0000. CMCON, Value on: POR, BOR = 0000. CMCON, Value on all other Resets = 0000. CMCON, Value on all other Resets = 0000. CVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Value on: POR, BOR = 0000. CVRCON, Value on: POR, BOR = 0000. CVRCON, Value on all other Resets = 0000. CVRCON, Value on all other Resets = 0000",
    "TABLE 10-12: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by PORTF.",
    "10.7 PORTG, TRISG and LATG Registers\nPORTG is a 6-bit wide port  with  5  bidirectional  pins (RG0:RG4) and one optional input only pin (RG5). The corresponding data direction register is TRISG. Setting a TRISG bit (= 1 ) will make the corresponding PORTG pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISG bit (= 0 ) will make the corresponding PORTC pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register  (LATG)  is  also  memory mapped.  Read-modify-write  operations  on  the  LATG register,  read  and  write  the  latched  output  value  for PORTG.\nPORTG  is  multiplexed  with  both  CCP/ECCP  and EUSART functions  (Table 10-13).  PORTG  pins  have Schmitt Trigger input buffers.",
    "10.7 PORTG, TRISG and LATG Registers\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTG pin. Some peripherals  override  the  TRIS  bit  to  make  a  pin  an output, while other peripherals override the TRIS bit to make  a  pin  an  input.  The  user  should  refer  to  the corresponding peripheral section for the correct TRIS bit settings.\nNote:, 1 = On a Power-on Reset, these pins are configured as digital inputs.\nThe pin override value is not loaded into the TRIS register.  This  allows  read-modify-write  operations  of  the TRIS register without concern due to peripheral overrides.\nThe sixth pin of PORTG (MCLR/VPP/RG5) is a digital input  pin.  Its  operation  is  controlled  by  the  MCLRE configuration bit in Configuration Register 3H (CONFIG3H<7>). In its default configuration (MCLRE = 1 ),  the pin functions as the device Master Clear input. When selected as a port pin (MCLRE = 0 ), it  functions as an input only pin; as such, it does not have TRISG or LATG bits associated with it.",
    "10.7 PORTG, TRISG and LATG Registers\nIn either configuration,  RG5  also  functions  as  the programming voltage input during device programming.\nNote 1: On a Power-on Reset, RG5 is enabled as a digital input only if Master Clear functionality is disabled (MCLRE = 0 ).\n2: If  the  device  Master  Clear  is  disabled, verify that either of the following is done to ensure proper entry into ICSP mode:\na.) disable low-voltage programming (CONFIG4L<2> = 0 ); or\nb.) make certain that RB5/KBI1/PGM is held low during entry into ICSP.",
    "EXAMPLE 10-7: INITIALIZING PORTG\nCLRF, 1 = PORTG. CLRF, 2 = ; Initialize PORTG by ; clearing output ; data latches. CLRF, 1 = LATG. CLRF, 2 = ; Alternate method ; to clear output. MOVLW, 1 = 0x04. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISG. MOVWF, 2 = ; Set RG1:RG0 as outputs ; RG2 as input ; RG4:RG3 as inputs",
    "FIGURE 10-16: PORTG BLOCK DIAGRAM (PERIPHERAL OUTPUT OVERRIDE)\nRG0, Override = Yes. RG0, Peripheral = ECCP3 I/O. RG1, Override = Yes. RG1, Peripheral = USART1 Async Xmit, Sync Clock. RG2, Override = Yes. RG2, Peripheral = USART1 Async Rcv, Sync Data Out. RG3, Override = Yes. RG3, Peripheral = CCP4 I/O. RG4, Override = Yes. RG4, Peripheral = CCP5 I/O",
    "TABLE 10-13: PORTG FUNCTIONS\nRG0/ECCP3/P3A, Bit# = bit 0. RG0/ECCP3/P3A, Buffer Type = ST. RG0/ECCP3/P3A, Function = Input/output port pin, Enhanced Capture 3 input/Compare 3 output/ PWM 3 output or Enhanced PWM 3 output P3A.. RG1/TX2/CK2, Bit# = bit 1. RG1/TX2/CK2, Buffer Type = ST. RG1/TX2/CK2, Function = Input/output port pin, addressable USART2 asynchronous transmit or addressable USART2 synchronous clock.. RG2/RX2/DT2, Bit# = bit 2. RG2/RX2/DT2, Buffer Type = ST. RG2/RX2/DT2, Function = Input/output port pin, addressable USART2 asynchronous receive or addressable USART2 synchronous data.. RG3/CCP4/P3D, Bit# = bit 3.",
    "TABLE 10-13: PORTG FUNCTIONS\nRG3/CCP4/P3D, Buffer Type = ST. RG3/CCP4/P3D, Function = Input/output port pin, Capture 4 input/Compare 4 output/PWM 4 output or Enhanced PWM 3 output P3D.. RG4/CCP5/P1D, Bit# = bit 4. RG4/CCP5/P1D, Buffer Type = ST. RG4/CCP5/P1D, Function = Input/output port pin, Capture 5 input/Compare 5 output/PWM 5 output or Enhanced PWM 1 output P1D.. MCLR/VPP/RG5, Bit# = bit 5. MCLR/VPP/RG5, Buffer Type = ST. MCLR/VPP/RG5, Function = Master Clear input or programming voltage input (if MCLR is enabled). Input only port pin or programming voltage input (if MCLR is disabled).\nLegend: ST = Schmitt Trigger input",
    "TABLE 10-14: SUMMARY OF REGISTERS ASSOCIATED WITH PORTG\nPORTG, Bit 7 = -. PORTG, Bit 6 = -. PORTG, Bit 5 = RG5 (1). PORTG, Bit 4 = Read PORTG pins/Write PORTG Data Latch. PORTG, Bit 3 = Read PORTG pins/Write PORTG Data Latch. PORTG, Bit 2 = Read PORTG pins/Write PORTG Data Latch. PORTG, Bit 1 = Read PORTG pins/Write PORTG Data Latch. PORTG, Value on POR, BOR = --xx xxxx. PORTG, Value on all other Resets = --uu uuuu. LATG, Bit 7 = -. LATG, Bit 6 = -. LATG, Bit 5 = -. LATG, Bit 4 = LATG Data Output Register. LATG, Bit 3 = LATG Data Output Register. LATG, Bit 2 = LATG Data Output Register. LATG, Bit 1 = LATG Data Output Register. LATG, Value on POR, BOR = ---x xxxx. LATG, Value on all other Resets =",
    "TABLE 10-14: SUMMARY OF REGISTERS ASSOCIATED WITH PORTG\n---u uuuu. TRISG, Bit 7 = -. TRISG, Bit 6 = -. TRISG, Bit 5 = -. TRISG, Bit 4 = Data Direction Control Register for PORTG. TRISG, Bit 3 = Data Direction Control Register for PORTG. TRISG, Bit 2 = Data Direction Control Register for PORTG. TRISG, Bit 1 = Data Direction Control Register for PORTG. TRISG, Value on POR, BOR = ---1 1111. TRISG, Value on all other Resets = ---1 1111\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '\nNote 1: RG5 is available as an input only when MCLR is disabled.",
    "FIGURE 10-18: RH3:RH0 PINS BLOCK DIAGRAM IN I/O MODE\nNote:, 1 = PORTH is available only on PIC18F8525/ 8621 devices.\nPORTH is an 8-bit wide, bidirectional I/O port. The corresponding data direction register is TRISH. Setting a TRISH bit (= 1 )  will  make the corresponding PORTH pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISH bit (= 0 ) will make the corresponding PORTH pin an output (i.e., put the contents of the output latch on the selected pin).\nRead-modify-write  operations  on  the  LATH  register, read and write the latched output value for PORTH.",
    "FIGURE 10-18: RH3:RH0 PINS BLOCK DIAGRAM IN I/O MODE\nPins  RH7:RH4  are  multiplexed  with  analog  inputs AN15:AN12. Pins RH3:RH0 are multiplexed with the system bus as the external memory interface; they are the high-order address bits A19:A16. By default, pins RH7:RH4  are enabled as A/D inputs and pins RH3:RH0  are  enabled  as  the  system  address  bus. Register ADCON1 configures RH7:RH4 as I/O or A/D inputs. Register MEMCON configures RH3:RH0 as I/O or system bus pins.\nNote 1: On Power-on Reset, PORTH pins RH7:RH4 default to A/D inputs and read as ' 0 '.\n2: On Power-on Reset, PORTH pins RH3:RH0 default to system bus signals.",
    "EXAMPLE 10-8: INITIALIZING PORTH\nCLRF, 1 = PORTH. CLRF, 2 = ; Initialize PORTH by ; clearing output ; data latches. CLRF, 1 = LATH. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF MOVLW, 1 = 0Fh ADCON1 0CFh. MOVLW MOVWF MOVLW, 2 = ; ; ; Value used to ; initialize data. MOVWF, 1 = TRISH. MOVWF, 2 = ; Set RH3:RH0 as inputs ; RH5:RH4 as outputs ; RH7:RH6 as inputs",
    "FIGURE 10-19: RH7:RH4 PINS BLOCK DIAGRAM IN I/O MODE\nNote 1: I/O pins have diode protection to VDD and VSS.",
    "TABLE 10-15: PORTH FUNCTIONS\nRH0/A16, Bit# = bit 0. RH0/A16, Buffer Type = ST/TTL (1). RH0/A16, Function = Input/output port pin or address bit 16 for external memory interface.. RH1/A17, Bit# = bit 1. RH1/A17, Buffer Type = ST/TTL (1). RH1/A17, Function = Input/output port pin or address bit 17 for external memory interface.. RH2/A18, Bit# = bit 2. RH2/A18, Buffer Type = ST/TTL (1). RH2/A18, Function = Input/output port pin or address bit 18 for external memory interface.. RH3/A19, Bit# = bit 3. RH3/A19, Buffer Type = ST/TTL (1). RH3/A19, Function = Input/output port pin or address bit 19 for external memory interface.. RH4/AN12/P3C (2), Bit# = bit 4.",
    "TABLE 10-15: PORTH FUNCTIONS\nRH4/AN12/P3C (2), Buffer Type = ST. RH4/AN12/P3C (2), Function = Input/output port pin, analog input channel 12 or Enhanced PWM output P3C.. RH5/AN13/P3B (2), Bit# = bit 5. RH5/AN13/P3B (2), Buffer Type = ST. RH5/AN13/P3B (2), Function = Input/output port pin, analog input channel 13 or Enhanced PWM output P3B.. RH6/AN14/P1C (2), Bit# = bit 6. RH6/AN14/P1C (2), Buffer Type = ST. RH6/AN14/P1C (2), Function = Input/output port pin, analog input channel 14 or Enhanced PWM output P1C.. RH7/AN15/P1B (2), Bit# = bit 7. RH7/AN15/P1B (2), Buffer Type = ST.",
    "TABLE 10-15: PORTH FUNCTIONS\nRH7/AN15/P1B (2), Function = Input/output port pin, analog input channel 15 or Enhanced PWM3 output P1B.\nLegend: ST = Schmitt Trigger input, TTL = TTL input\nNote 1: Input buffers are Schmitt Triggers when in I/O mode and TTL buffers when in System Bus or Parallel Slave Port mode.\n2: Valid only for PIC18F8525/8621 devices when ECCPMX is not set. The alternate assignments for P1B/P1C/P3B/P3C in all PIC18F6525/6621 devices and in PIC18F8525/8621 devices when ECCPMX is set are RE6, RE5, RE4 and RE3, respectively.",
    "TABLE 10-16: SUMMARY OF REGISTERS ASSOCIATED WITH PORTH\nTRISH, Bit 7 = PORTH Data Direction Control Register. TRISH, Bit 6 = PORTH Data Direction Control Register. TRISH, Bit 5 = PORTH Data Direction Control Register. TRISH, Bit 4 = PORTH Data Direction Control Register. TRISH, Bit 3 = PORTH Data Direction Control Register. TRISH, Bit 2 = PORTH Data Direction Control Register. TRISH, Bit 1 = PORTH Data Direction Control Register. TRISH, Bit 0 = 1111 1111. TRISH, Value on: POR, BOR = 1111. TRISH, Value on all other Resets = 1111. PORTH, Bit 7 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 6 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 5 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 4 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 3 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 2 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 1 = Read PORTH pin/Write",
    "TABLE 10-16: SUMMARY OF REGISTERS ASSOCIATED WITH PORTH\nPORTH Data Latch. PORTH, Bit 0 = 0000 xxxx. PORTH, Value on: POR, BOR = 0000. PORTH, Value on all other Resets = uuuu. LATH, Bit 7 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 6 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 5 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 4 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 3 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 2 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 1 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 0 = xxxx xxxx. LATH, Value on: POR, BOR = uuuu. LATH, Value on all other Resets = uuuu. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1.",
    "TABLE 10-16: SUMMARY OF REGISTERS ASSOCIATED WITH PORTH\nADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on: POR, BOR = --00 0000. ADCON1, Value on all other Resets = --00 0000. MEMCON (1), Bit 7 = EBDIS. MEMCON (1), Bit 6 = -. MEMCON (1), Bit 5 = WAIT1. MEMCON (1), Bit 4 = WAIT0. MEMCON (1), Bit 3 = -. MEMCON (1), Bit 2 = -. MEMCON (1), Bit 1 = WM1. MEMCON (1), Bit 0 = WM0 0-00. MEMCON (1), Value on: POR, BOR = --00 0-00. MEMCON (1), Value on all other Resets = --00",
    "TABLE 10-16: SUMMARY OF REGISTERS ASSOCIATED WITH PORTH\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by PORTH.\nNote 1: This register is unused on PIC18F6525/6621 devices and reads as ' 0 '.",
    "EXAMPLE 10-9: INITIALIZING PORTJ\nNote:\nPORTJ is available only on PIC18F8525/ 8621 devices.\nPORTJ is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISJ.  Setting  a TRISJ bit (= 1 ) will make the corresponding PORTJ pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISJ bit (= 0 ) will make the corresponding PORTJ pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch register (LATJ) is also memory mapped.  Read-modify-write  operations  on  the  LATJ register,  read  and  write  the  latched  output  value  for PORTJ.\nPORTJ  is  multiplexed  with  the  system  bus  as  the external memory interface; I/O port functions are only available  when  the  system  bus  is  disabled.  When operating  as  the  external  memory  interface,  PORTJ provides the control signal to external memory devices. The RJ5 pin is not multiplexed  with  any  system  bus functions.",
    "EXAMPLE 10-9: INITIALIZING PORTJ\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTJ pin. Some peripherals  override  the  TRIS  bit  to  make  a  pin  an output, while other peripherals override the TRIS bit to make a pin an input. The user should refer to the corresponding  peripheral  section  for  the  correct  TRIS  bit settings.\nNote:\nOn  a  Power-on  Reset,  these  pins  are configured as digital inputs.\nThe pin override value is not loaded into the TRIS register. This allows read-modify-write of the TRIS register without concern due to peripheral overrides.",
    "EXAMPLE 10-9: INITIALIZING PORTJ\nCLRF, 1 = PORTJ. CLRF, 2 = ; Initialize PORTG by ; clearing output ; data latches. CLRF, 1 = LATJ. CLRF, 2 = ; Alternate method ; to clear output. MOVLW, 1 = 0xCF. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISJ. MOVWF, 2 = ; Set RJ3:RJ0 as inputs ; RJ5:RJ4 as output ; RJ7:RJ6 as inputs",
    "IN I/O MODE\nNote 1: I/O pins have diode protection to VDD and VSS.",
    "TABLE 10-17: PORTJ FUNCTIONS\nRJ0/ALE, Bit# = bit 0. RJ0/ALE, Buffer Type = ST. RJ0/ALE, Function = Input/output port pin or address latch enable control for external memory interface.. RJ1/OE, Bit# = bit 1. RJ1/OE, Buffer Type = ST. RJ1/OE, Function = Input/output port pin or output enable control for external memory interface.. RJ2/WRL, Bit# = bit 2. RJ2/WRL, Buffer Type = ST. RJ2/WRL, Function = Input/output port pin or write low byte control for external memory interface.. RJ3/WRH, Bit# = bit 3. RJ3/WRH, Buffer Type = ST. RJ3/WRH, Function = Input/output port pin or write high byte control for external memory interface.. RJ4/BA0, Bit# = bit 4. RJ4/BA0, Buffer Type = ST. RJ4/BA0, Function = Input/output port pin or byte address 0 control for external memory interface..",
    "TABLE 10-17: PORTJ FUNCTIONS\nRJ5/CE, Bit# = bit 5. RJ5/CE, Buffer Type = ST. RJ5/CE, Function = Input/output port pin or chip enable control for external memory interface.. RJ6/LB, Bit# = bit 6. RJ6/LB, Buffer Type = ST. RJ6/LB, Function = Input/output port pin or lower byte select control for external memory interface.. RJ7/UB, Bit# = bit 7. RJ7/UB, Buffer Type = ST. RJ7/UB, Function = Input/output port pin or upper byte select control for external memory interface.\nLegend: ST = Schmitt Trigger input",
    "TABLE 10-18: SUMMARY OF REGISTERS ASSOCIATED WITH PORTJ\nPORTJ, Bit 7 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 6 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 5 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 4 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 3 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 2 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 1 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 0 = xxxx. PORTJ, Value on POR, BOR = xxxx. PORTJ, Value on all other Resets = uuuu. PORTJ, Value on all other Resets = uuuu. LATJ, Bit 7 = LATJ Data Output Register. LATJ, Bit 6 = LATJ Data Output Register. LATJ, Bit 5 = LATJ Data Output Register. LATJ, Bit 4 = LATJ Data Output Register. LATJ, Bit 3 = LATJ Data Output Register.",
    "TABLE 10-18: SUMMARY OF REGISTERS ASSOCIATED WITH PORTJ\nLATJ, Bit 2 = LATJ Data Output Register. LATJ, Bit 1 = LATJ Data Output Register. LATJ, Bit 0 = xxxx. LATJ, Value on POR, BOR = xxxx. LATJ, Value on all other Resets = uuuu. LATJ, Value on all other Resets = uuuu. TRISJ, Bit 7 = Data Direction Control Register for PORTJ. TRISJ, Bit 6 = Data Direction Control Register for PORTJ. TRISJ, Bit 5 = Data Direction Control Register for PORTJ. TRISJ, Bit 4 = Data Direction Control Register for PORTJ. TRISJ, Bit 3 = Data Direction Control Register for PORTJ. TRISJ, Bit 2 = Data Direction Control Register for PORTJ. TRISJ, Bit 1 = Data Direction Control Register for PORTJ. TRISJ, Bit 0 = 1111. TRISJ, Value on POR, BOR = 1111. TRISJ, Value on all other Resets = 1111. TRISJ, Value on all other Resets = 1111",
    "TABLE 10-18: SUMMARY OF REGISTERS ASSOCIATED WITH PORTJ\nLegend: x = unknown, u = unchanged",
    "10.10 Parallel Slave Port\nFIGURE 10-24:\nPORTD also operates as an 8-bit wide Parallel Slave Port, or microprocessor port, when control bit PSPMODE (PSPCON<4>) is set. It is asynchronously readable and writable by the external world through RD control  input  pin,  RE0/RD  and  WR  control  input  pin, RE1/WR.\nNote:, 1 = For PIC18F8525/8621 devices, the Parallel Slave Port is available only in Microcontroller mode.",
    "10.10 Parallel Slave Port\nThe  PSP  can  directly  interface  to  an  8-bit  microprocessor data bus. The external microprocessor can read or write the PORTD latch as an 8-bit latch. Setting bit PSPMODE enables port pin RE0/RD to be the RD input, RE1/WR to be the WR input and RE2/CS to be the  CS  (chip  select)  input.  For  this  functionality,  the corresponding data direction bits of the TRISE register (TRISE<2:0>) must be configured as inputs (set). The A/D port configuration bits, PCFG2:PCFG0 (ADCON1<2:0>), must be set, which will configure pins RE2:RE0 as digital I/O.\nA write to the PSP occurs when both the CS and WR lines are first detected low. A read from the PSP occurs when both the CS and RD lines are first detected low.",
    "10.10 Parallel Slave Port\nThe PORTE I/O pins become control inputs for the microprocessor  port  when  bit  PSPMODE  (PSPCON<4>)  is set.  In  this  mode,  the  user  must  make  sure  that  the TRISE<2:0> bits are set (pins are configured as digital inputs) and the ADCON1 is configured for digital I/O. In this mode, the input buffers are TTL.",
    "PSPCON: PARALLEL SLAVE PORT CONTROL REGISTER (1)\nR-0, 1 = R-0. R-0, 2 = R/W-0. R-0, 3 = R/W-0. R-0, 4 = U-0. R-0, 5 = U-0. R-0, 6 = U-0. R-0, 7 = U-0. IBF, 1 = OBF. IBF, 2 = IBOV. IBF, 3 = PSPMODE. IBF, 4 = -. IBF, 5 = -. IBF, 6 = -. IBF, 7 = -\nbit 7\nbit 0\nbit 7\nIBF: Input Buffer Full Status bit\n1 = A word has been received and is waiting to be read by the CPU\n0 = No word has been received\nbit 6 OBF: Output Buffer Full Status bit\n1 = The output buffer still holds a previously written word\n0 = The output buffer has been read\nbit 5 IBOV: Input Buffer Overflow Detect bit\n1 = A write occurred when a previously input word has not been read (must be cleared in software)\n0 = No overflow occurred\nbit 4\nPSPMODE: Parallel Slave Port Mode Select bit",
    "PSPCON: PARALLEL SLAVE PORT CONTROL REGISTER (1)\n1 = Parallel Slave Port mode\n0 = General Purpose I/O mode\nbit 3-0 Unimplemented: Read as ' 0 '\nNote 1: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "FIGURE 10-25: PARALLEL SLAVE PORT WRITE WAVEFORMS\nCS, Q1 = . CS, Q2 = . CS, Q3 = . CS, Q4 = . CS, Q1 = . CS, Q2 = . CS, Q3 = . CS, Q4 = . CS, Q1 = . CS, Q2 = . CS, Q3 = . CS, Q4 = . WR, Q1 = . WR, Q2 = . WR, Q3 = . WR, Q4 = . WR, Q1 = . WR, Q2 = . WR, Q3 = . WR, Q4 = . WR, Q1 = . WR, Q2 = . WR, Q3 = . WR, Q4 = . RD, Q1 = . RD, Q2 = . RD, Q3 = . RD, Q4 = . RD, Q1 = . RD, Q2 = . RD, Q3 = . RD, Q4 = . RD, Q1 = . RD, Q2 = . RD, Q3 = . RD, Q4 = . PORTD<7:0>, Q1 = . PORTD<7:0>, Q2 = .",
    "FIGURE 10-25: PARALLEL SLAVE PORT WRITE WAVEFORMS\nPORTD<7:0>, Q3 = . PORTD<7:0>, Q4 = . PORTD<7:0>, Q1 = . PORTD<7:0>, Q2 = . PORTD<7:0>, Q3 = . PORTD<7:0>, Q4 = . PORTD<7:0>, Q1 = . PORTD<7:0>, Q2 = . PORTD<7:0>, Q3 = . PORTD<7:0>, Q4 = . IBF, Q1 = . IBF, Q2 = . IBF, Q3 = . IBF, Q4 = . IBF, Q1 = . IBF, Q2 = . IBF, Q3 = . IBF, Q4 = . IBF, Q1 = . IBF, Q2 = . IBF, Q3 = . IBF, Q4 = . OBF, Q1 = . OBF, Q2 = . OBF, Q3 = . OBF, Q4 = . OBF, Q1 = . OBF, Q2 =",
    "FIGURE 10-25: PARALLEL SLAVE PORT WRITE WAVEFORMS\n. OBF, Q3 = . OBF, Q4 = . OBF, Q1 = . OBF, Q2 = . OBF, Q3 = . OBF, Q4 = . PSPIF, Q1 = . PSPIF, Q2 = . PSPIF, Q3 = . PSPIF, Q4 = . PSPIF, Q1 = . PSPIF, Q2 = . PSPIF, Q3 = . PSPIF, Q4 = . PSPIF, Q1 = . PSPIF, Q2 = . PSPIF, Q3 = . PSPIF, Q4 = ",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nPORTD, Bit 7 = Port Data Latch when written; Port pins when read. PORTD, Bit 6 = Port Data Latch when written; Port pins when read. PORTD, Bit 5 = Port Data Latch when written; Port pins when read. PORTD, Bit 4 = Port Data Latch when written; Port pins when read. PORTD, Bit 3 = Port Data Latch when written; Port pins when read. PORTD, Bit 2 = Port Data Latch when written; Port pins when read. PORTD, Bit 1 = Port Data Latch when written; Port pins when read. PORTD, Bit 0 = Port Data Latch when written; Port pins when read. PORTD, Value on POR, BOR = xxxx. PORTD, Value on POR, BOR = xxxx. PORTD, Value on all other Resets = uuuu. PORTD, Value on all other Resets = uuuu. LATD, Bit 7 = LATD Data Output bits. LATD, Bit 6 = LATD Data Output bits. LATD, Bit 5 = LATD Data Output bits. LATD, Bit 4 = LATD Data",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nOutput bits. LATD, Bit 3 = LATD Data Output bits. LATD, Bit 2 = LATD Data Output bits. LATD, Bit 1 = LATD Data Output bits. LATD, Bit 0 = LATD Data Output bits. LATD, Value on POR, BOR = xxxx. LATD, Value on POR, BOR = xxxx. LATD, Value on all other Resets = uuuu. LATD, Value on all other Resets = uuuu. TRISD, Bit 7 = PORTD Data Direction bits. TRISD, Bit 6 = PORTD Data Direction bits. TRISD, Bit 5 = PORTD Data Direction bits. TRISD, Bit 4 = PORTD Data Direction bits. TRISD, Bit 3 = PORTD Data Direction bits. TRISD, Bit 2 = PORTD Data Direction bits. TRISD, Bit 1 = PORTD Data Direction bits. TRISD, Bit 0 = PORTD Data Direction bits. TRISD, Value on POR, BOR = 1111. TRISD, Value on POR, BOR = 1111. TRISD, Value",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\non all other Resets = 1111. TRISD, Value on all other Resets = 1111. PORTE, Bit 7 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 6 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 5 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 4 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 3 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 2 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 1 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 0 = Read PORTE pin/Write PORTE Data Latch. PORTE, Value on POR, BOR = xxxx. PORTE, Value on POR, BOR = xxxx. PORTE, Value on all other Resets = uuuu. PORTE, Value on all other Resets = uuuu. LATE, Bit 7 = LATE Data Output bits. LATE, Bit 6 = LATE Data Output bits. LATE, Bit 5 = LATE Data Output bits. LATE, Bit 4 = LATE Data Output bits. LATE, Bit 3 = LATE Data Output bits. LATE, Bit 2 = LATE Data Output",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nbits. LATE, Bit 1 = LATE Data Output bits. LATE, Bit 0 = LATE Data Output bits. LATE, Value on POR, BOR = xxxx. LATE, Value on POR, BOR = xxxx. LATE, Value on all other Resets = uuuu. LATE, Value on all other Resets = uuuu. TRISE, Bit 7 = PORTE Data Direction bits. TRISE, Bit 6 = PORTE Data Direction bits. TRISE, Bit 5 = PORTE Data Direction bits. TRISE, Bit 4 = PORTE Data Direction bits. TRISE, Bit 3 = PORTE Data Direction bits. TRISE, Bit 2 = PORTE Data Direction bits. TRISE, Bit 1 = PORTE Data Direction bits. TRISE, Bit 0 = PORTE Data Direction bits. TRISE, Value on POR, BOR = 1111. TRISE, Value on POR, BOR = 1111. TRISE, Value on all other Resets = 1111. TRISE, Value on all other Resets = 1111. PSPCON (1), Bit 7 = IBF. PSPCON (1), Bit 6 = OBF. PSPCON",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n(1), Bit 5 = IBOV. PSPCON (1), Bit 4 = PSPMODE. PSPCON (1), Bit 3 = -. PSPCON (1), Bit 2 = -. PSPCON (1), Bit 1 = -. PSPCON (1), Bit 0 = -. PSPCON (1), Value on POR, BOR = 0000. PSPCON (1), Value on POR, BOR = ----. PSPCON (1), Value on all other Resets = 0000. PSPCON (1), Value on all other Resets = ----. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000.",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nINTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111\nLegend:",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the Parallel Slave Port.\nNote 1: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "11.0 TIMER0 MODULE\nThe Timer0 module has the following features:\n- \u00b7 Software selectable as an 8-bit or 16-bit timer/counter\nFigure 11-1  shows  a  simplified  block  diagram  of  the Timer0 module in 8-bit mode and Figure 11-2 shows a simplified block diagram of the Timer0 module in 16-bit mode.\n\u00b7 Readable and writable\n\u00b7 Dedicated 8-bit software programmable prescaler\n\u00b7 Clock source selectable to be external or internal\n\u00b7 Interrupt-on-overflow from FFh to 00h in 8-bit mode and FFFFh to 0000h in 16-bit mode\n\u00b7 Edge select for external clock",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = R/W-1. R/W-1, 4 = R/W-1. R/W-1, 5 = R/W-1. R/W-1, 6 = R/W-1. R/W-1, 7 = R/W-1. TMR0ON, 1 = T08BIT. TMR0ON, 2 = T0CS. TMR0ON, 3 = T0SE. TMR0ON, 4 = PSA. TMR0ON, 5 = T0PS2. TMR0ON, 6 = T0PS1. TMR0ON, 7 = T0PS0\nbit 7\nbit 0\nbit 7\nTMR0ON: Timer0 On/Off Control bit\n1 = Enables Timer0\n0 = Stops Timer0",
    "bit 6\nT08BIT : Timer0 8-bit/16-bit Control bit\n1 = Timer0 is configured as an 8-bit timer/counter\n0 = Timer0 is configured as a 16-bit timer/counter\nbit 5\nT0CS : Timer0 Clock Source Select bit\n1 = Transition on T0CKI pin\n0 = Internal instruction cycle clock (CLKO)",
    "bit 4\nT0SE : Timer0 Source Edge Select bit\n1 = Increment on high-to-low transition on T0CKI pin\n0 = Increment on low-to-high transition on T0CKI pin\nbit 3\nPSA : Timer0 Prescaler Assignment bit\n1 = TImer0 prescaler is not assigned. Timer0 clock input bypasses prescaler.\n0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.",
    "bit 2-0 T0PS2:T0PS0 : Timer0 Prescaler Select bits\n111 = 1:256 Prescale value\n110 = 1:128 Prescale value\n101 = 1:64   Prescale value\n100 = 1:32   Prescale value\n011 = 1:16   Prescale value\n010 = 1:8     Prescale value\n001\n= 1:4     Prescale value\n000 = 1:2     Prescale value",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nThe T0CON register (Register 11-1) is a readable and writable register that controls all the aspects of Timer0, including the prescale selection.",
    "11.1 Timer0 Operation\nTimer0 can operate as a timer or as a counter.",
    "11.2.1 SWITCHING PRESCALER ASSIGNMENT\nTimer  mode  is  selected  by  clearing  the  T0CS  bit.  In Timer mode, the Timer0 module will increment every instruction cycle (without prescaler). If the TMR0 register is written, the increment is inhibited for the following two instruction cycles. The user can work around this by writing an adjusted value to the TMR0 register.\nCounter mode is selected by setting the T0CS bit. In Counter mode, Timer0 will increment, either on every rising or falling edge of pin RA4/T0CKI. The incrementing  edge  is  determined  by  the  Timer0  Source  Edge Select  bit  (T0SE).  Clearing  the  T0SE  bit  selects  the rising edge. Restrictions on the external clock input are discussed below.\nWhen an external clock input is used for Timer0, it must meet certain requirements. The requirements ensure the external clock can be synchronized with the internal phase clock (TOSC). Also, there is a delay in the actual incrementing of Timer0 after synchronization.",
    "11.2 Prescaler\nAn 8-bit counter is available as a prescaler for the Timer0 module. The prescaler is not readable or writable.\nThe PSA  and T0PS2:T0PS0  bits determine the prescaler assignment and prescale ratio.\nClearing bit PSA will assign the prescaler to the Timer0 module. When the prescaler is assigned to the Timer0 module,  prescale  values  of  1:2,  1:4,  ...,  1:256  are selectable.\nWhen assigned to the Timer0 module, all instructions writing to the TMR0 register (e.g., CLRF TMR0 MOVWF , TMR0 BSF TMR0 x , , and so on) will clear the prescaler count.\nThe  prescaler  assignment  is  fully  under  software control,  (i.e.,  it  can  be  changed  'on-the-fly'  during program execution).",
    "11.3 Timer0 Interrupt\nThe  TMR0  interrupt  is  generated  when  the  TMR0 register  overflows from  FFh  to  00h in 8-bit  mode, or FFFFh to 0000h in 16-bit mode. This overflow sets the TMR0IF bit. The interrupt can be masked by clearing the  TMR0IE bit.  The  TMR0IE bit  must  be  cleared  in software by the Timer0  module  Interrupt Service Routine  before  re-enabling  this  interrupt.  The  TMR0 interrupt  cannot  awaken  the  processor  from  Sleep since the timer is shut off during Sleep.",
    "11.4 16-Bit Mode Timer Reads and Writes\nTMR0H  is  not  the  high  byte  of  the  timer/counter  in 16-bit mode, but is actually a buffered version of the high byte of Timer0 (refer to Figure 11-2). The high byte of the Timer0 counter/timer is not directly readable nor writable.  TMR0H is  updated  with  the  contents  of  the high  byte  of  Timer0  during  a  read  of  TMR0L.  This provides the ability to read all 16 bits of Timer0 without having to verify that the read of the high and low byte were valid, due to a rollover between successive reads of the high and low byte.\nA write to the high byte of Timer0 must also take place through the TMR0H Buffer register. Timer0 high byte is updated  with  the  contents  of  TMR0H  when  a  write occurs to TMR0L. This allows all 16 bits of Timer0 to be updated at once.\nNote:, 1 = Writing to TMR0 when the prescaler is assigned to Timer0 will clear the prescaler count, but will not change the prescaler assignment.",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0L, Bit 7 = Timer0 Low Byte Register. TMR0L, Bit 6 = Timer0 Low Byte Register. TMR0L, Bit 5 = Timer0 Low Byte Register. TMR0L, Bit 4 = Timer0 Low Byte Register. TMR0L, Bit 3 = Timer0 Low Byte Register. TMR0L, Bit 2 = Timer0 Low Byte Register. TMR0L, Bit 1 = Timer0 Low Byte Register. TMR0L, Bit 0 = Timer0 Low Byte Register. TMR0L, Value on POR, BOR = xxxx. TMR0L, Value on POR, BOR = xxxx. TMR0L, Value onall other Resets = uuuu. TMR0L, Value onall other Resets = uuuu. TMR0H, Bit 7 = Timer0 High Byte Register. TMR0H, Bit 6 = Timer0 High Byte Register. TMR0H, Bit 5 = Timer0 High Byte Register. TMR0H, Bit 4 = Timer0 High Byte",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nRegister. TMR0H, Bit 3 = Timer0 High Byte Register. TMR0H, Bit 2 = Timer0 High Byte Register. TMR0H, Bit 1 = Timer0 High Byte Register. TMR0H, Bit 0 = Timer0 High Byte Register. TMR0H, Value on POR, BOR = 0000. TMR0H, Value on POR, BOR = 0000. TMR0H, Value onall other Resets = uuuu. TMR0H, Value onall other Resets = uuuu. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nonall other Resets = 0000. INTCON, Value onall other Resets = 000u. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111. T0CON, Value on POR, BOR = 1111. T0CON, Value onall other Resets = 1111. T0CON, Value onall other Resets = 1111. TRISA, Bit 7 = -. TRISA, Bit 6 = TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 5 = TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 4 = TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 3 = TRISA6 (1)",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nPORTA Data Direction Register. TRISA, Bit 2 = TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 1 = TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 0 = TRISA6 (1) PORTA Data Direction Register. TRISA, Value on POR, BOR = -111. TRISA, Value on POR, BOR = 1111. TRISA, Value onall other Resets = -111. TRISA, Value onall other Resets = 1111\nLegend:\nx = unknown, u = unchanged, - = unimplemented locations, read as ' 0 '. Shaded cells are not used by Timer0.\n- Note 1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator modes only and read ' 0 ' in all other oscillator modes.",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "12.0 TIMER1 MODULE\nThe  Timer1  module  timer/counter  has  the  following features:\n\u00b7 16-bit timer/counter\n(two 8-bit registers: TMR1H and TMR1L)\n\u00b7 Readable and writable (both registers)\n\u00b7 Internal or external clock select\n\u00b7 Interrupt-on-overflow from FFFFh to 0000h\n\u00b7 Reset from ECCP module special event trigger\nFigure 12-1 is a simplified block diagram of the Timer1 module.",
    "REGISTER 12-1: T1CON: TIMER1 CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. RD16, 1 = -. RD16, 2 = T1CKPS1. RD16, 3 = T1CKPS0. RD16, 4 = T1OSCEN. RD16, 5 = T1SYNC. RD16, 6 = TMR1CS. RD16, 7 = TMR1ON\nbit 7\nbit 0",
    "bit 7 RD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register read/write of Timer1 in one 16-bit operation\n0 = Enables register read/write of Timer1 in two 8-bit operations",
    "bit 5-4 T1CKPS1:T1CKPS0 : Timer1 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value",
    "bit 3 T1OSCEN: Timer1 Oscillator Enable bit\n1 = Timer1 oscillator is enabled\n0 = Timer1 oscillator is shut off\nThe oscillator inverter and feedback resistor are turned off to eliminate power drain.",
    "bit 2 T1SYNC: Timer1 External Clock Input Synchronization Select bit\nWhen TMR1CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR1CS = 0 :\nThis bit is ignored. Timer1 uses the internal clock when TMR1CS = 0 .",
    "bit 1 TMR1CS: Timer1 Clock Source Select bit\n1 = External clock from pin RC0/T1OSO/T13CKI (on the rising edge)\n0 = Internal clock (FOSC/4)",
    "bit 0 TMR1ON: Timer1 On bit\n1 = Enables Timer1\n0 = Stops Timer1",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nRegister 12-1 details the Timer1 Control register. This register  controls  the  operating  mode  of  the  Timer1 module and contains the Timer1 oscillator enable bit (T1OSCEN).  Timer1  can  be  enabled  or  disabled  by setting or clearing control bit, TMR1ON (T1CON<0>).\nTimer1 can also be used to provide Real-Time Clock (RTC) functionality to applications with only a minimal addition of external components and code overhead.",
    "12.1 Timer1 Operation\nTimer1 can operate in one of these modes:\n- \u00b7 As a timer\nWhen the Timer1 oscillator is enabled (T1OSCEN is set),  the  RC1/T1OSI  and  RC0/T1OSO/T13CKI  pins become  inputs.  That  is,  the  TRISC<1:0>  value  is ignored and the pins are read as ' 0 '.\n\u00b7 As a synchronous counter\n\u00b7 As an asynchronous counter\nThe operating mode is determined by the clock select bit, TMR1CS (T1CON<1>).\nWhen TMR1CS = 0 , Timer1 increments every instruction cycle. When TMR1CS = 1 , Timer1 increments on every  rising  edge  of  the  external  clock  input  or  the Timer1 oscillator, if enabled.\nTimer1 also has an internal 'Reset input'. This Reset can  be  generated  by  the  ECCP1  or  ECCP2  special event trigger. This is discussed in detail in Section 12.4 'Resetting Timer1 Using an ECCP Special Trigger Output' .",
    "12.2 Timer1 Oscillator\nA crystal oscillator circuit is built-in between pins T1OSI (input) and T1OSO (amplifier output). It is enabled by setting control bit T1OSCEN (T1CON<3>). The oscillator is a low-power oscillator rated up to 200 kHz. It will continue to run during Sleep. It is primarily intended for a 32 kHz crystal. The circuit for a typical LP oscillator is shown in Figure 12-3. Table 12-1 shows the capacitor selection for the Timer1 oscillator.\nThe user must provide a software time delay to ensure proper start-up of the Timer1 oscillator.",
    "EXTERNAL COMPONENTS FOR THE TIMER1 LP OSCILLATOR\nTABLE 12-1: CAPACITOR SELECTION FOR THE ALTERNATE",
    "OSCILLATOR (2-4)\nLP, Freq = 32 kHz. LP, C1 = 15-22 pF (1). LP, C2 = 15-22 pF (1). Crystal Tested, Freq = Crystal Tested. Crystal Tested, C1 = Crystal Tested. Crystal Tested, C2 = Crystal Tested. 32.768 kHz, Freq = 32.768 kHz. 32.768 kHz, C1 = 32.768 kHz. 32.768 kHz, C2 = 32.768 kHz\nNote 1: Microchip  suggests  33  pF  as  a  starting point in validating the oscillator circuit.\n2: Higher capacitance increases the stability of  the  oscillator  but  also  increases  the start-up time.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer for appropriate values of external components.\n4: Capacitor values are for design guidance only.",
    "12.3 Timer1 Interrupt\nThe TMR1 register pair (TMR1H:TMR1L) increments from  0000h  to  FFFFh  and  rolls  over  to  0000h.  The TMR1 interrupt, if  enabled,  is  generated  on  overflow which is latched in interrupt flag bit, TMR1IF (PIR1<0>). This interrupt can be enabled/disabled by setting/clearing the TMR1 Interrupt Enable bit, TMR1IE (PIE1<0>).",
    "12.4 Resetting Timer1 Using an ECCP Special Trigger Output\nIf either the ECCP1 or ECCP2 module is configured in Compare mode to generate a 'special event trigger' (CCP1M3:CCP1M0  = 1011 ), this signal  will  reset Timer1. The trigger for ECCP2 will also start an A/D conversion if the A/D module is enabled.\nNote:, 1 = The special event triggers from the ECCP1 module will not set interrupt flag bit TMR1IF (PIR1<0>).\nTimer1 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If  Timer1  is  running  in  Asynchronous  Counter mode, this Reset operation may not work.\nIn  the  event  that  a  write  to  Timer1  coincides  with  a special event trigger from ECCP1, the write will take precedence.\nIn this mode  of  operation,  the  CCPR1H:CCPR1L register pair effectively becomes the period register for Timer1.",
    "12.5 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured for 16-bit reads and writes (see Figure 12-2). When the RD16 control bit (T1CON<7>) is set, the address for TMR1H is mapped to a buffer register for the high byte of Timer1. A read from TMR1L will load the contents of the high byte of Timer1 into the Timer1 High Byte Buffer register. This provides the user with the ability to accurately read all 16 bits of Timer1 without having to determine whether a read of the high byte, followed by a read of the low byte, is valid due to a rollover between reads.\nA write to the high byte of Timer1 must also take place through the TMR1H Buffer register. Timer1 high byte is updated  with  the  contents  of  TMR1H  when  a  write occurs to TMR1L. This allows a user to write all 16 bits to both the high and low bytes of Timer1 at once.",
    "12.5 Timer1 16-Bit Read/Write Mode\nThe  high  byte  of  Timer1  is  not  directly  readable  or writable in this mode. All reads and writes must take place  through  the  Timer1  High  Byte  Buffer  register. Writes  to  TMR1H  do  not  clear  the  Timer1  prescaler. The prescaler is only cleared on writes to TMR1L.",
    "12.6 Using Timer1 as a Real-Time Clock\nthe routine which increments the seconds counter by one;  additional  counters  for  minutes  and  hours  are incremented as the previous counter overflow.\nAdding an external LP oscillator to Timer1 (such as the one  described  in Section 12.2  'Timer1  Oscillator' ) gives users the option to include RTC functionality to their applications. This is accomplished with an inexpensive watch crystal to provide an accurate time base and several lines of application code to calculate the time. When operating in Sleep mode and using a battery  or  supercapacitor  as  a  power  source,  it  can completely  eliminate  the  need  for  a  separate  RTC device and battery backup.\nSince the register pair is 16 bits wide, counting up to overflow the register directly from a 32.768 kHz clock would  take  2  seconds.  To  force  the  overflow  at  the required one-second intervals, it is necessary to preload it. The simplest method is to set the Most Significant bit of TMR1H with a BSF instruction. Note that the TMR1L register is never preloaded or altered; doing so may introduce cumulative error over many cycles.",
    "12.6 Using Timer1 as a Real-Time Clock\nThe  application code  routine, RTCisr , shown  in Example 12-1, demonstrates a simple method  to increment a counter at one-second intervals using an Interrupt  Service  Routine.  Incrementing  the  TMR1 register pair to overflow, triggers the interrupt and calls\nFor this method to be accurate, Timer1 must operate in Asynchronous mode and the Timer1 overflow interrupt must  be  enabled  (PIE1<0>  = 1 ), as  shown  in  the routine, RTCinit . The Timer1 oscillator must also be enabled and running at all times.",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nRTCinit, 1 = MOVLW MOVWF CLRF MOVLW MOVWF CLRF CLRF MOVLW MOVWF BSF RETURN. RTCinit, 2 = 0x80 TMR1H TMR1L b'00001111' T1CON secs mins .12 hours PIE1, TMR1IE. RTCinit, 3 = ; ; ; ;. RTCinit, 4 = Preload TMR1 register pair for 1 second overflow Configure for external clock, Asynchronous operation, external oscillator Initialize timekeeping registers. RTCisr, 1 = BSF. RTCisr, 2 = TMR1H, 7. RTCisr, 3 = ;. RTCisr, 4 = Preload for 1 sec. , 1 = MOVLW CPFSGT RETURN CLRF INCF MOVLW CPFSGT RETURN CLRF INCF MOVLW. , 2 = .59 secs secs F. , 3 = ; ; ;. , 4 = 60 seconds",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nelapsed? ; No, done Clear seconds Increment. , 1 = . , 2 = mins,. , 3 = . , 4 = minutes. , 1 = . , 2 = .59 mins. , 3 = ;. , 4 = 60 minutes elapsed?. , 1 = . , 2 = mins F. , 3 = ;. , 4 = Increment hours. , 1 = . , 2 = .23. , 3 = ;. , 4 = 24 hours. , 1 = . , 2 = . , 3 = . , 4 = No, done. , 1 = . , 2 = . , 3 = . , 4 = clear minutes. , 1 = . , 2 = hours,. , 3 = . , 4 = . , 1 = . , 2 = hours. , 3 = . , 4 = No, done Reset hours to 1. , 1 = RETURN MOVLW MOVWF. , 2 = .01. , 3 = ;. , 4 = elapsed?. , 1 = . , 2 = . , 3 = ;. , 4 = . , 1 =",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nCPFSGT. , 2 = . , 3 = . , 4 = . , 1 = . , 2 = hours. , 3 = . , 4 = . , 1 = RETURN. , 2 = . , 3 = . , 4 = . , 1 = . , 2 = . , 3 = ;. , 4 = . , 1 = Done. , 2 = Done. , 3 = Done. , 4 = Done. , 1 = . , 2 = ; ;. , 3 = . , 4 = ",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR,",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nBOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 =",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nSSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\non POR, BOR = xxxx. TMR1L, Value on all other Resets = uuuu. TMR1L, Value on all other Resets = uuuu. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on all other Resets = uuuu. TMR1H, Value on all other Resets = uuuu. T1CON, Bit 7 =",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nRD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00. T1CON, Value on POR, BOR = 0000. T1CON, Value on all other Resets = u-uu. T1CON, Value on all other Resets = uuuu\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer1 module.\nNote 1:\n- Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "13.1 Timer2 Operation\nThe Timer2 module timer has the following features:\n\u00b7 8-bit timer (TMR2 register)\n\u00b7 8-bit period register (PR2)\n\u00b7 Readable and writable (both registers)\n\u00b7 Software programmable prescaler (1:1, 1:4, 1:16)\n\u00b7 Software programmable postscaler (1:1 to 1:16)\n\u00b7 Interrupt on TMR2 match of PR2\n\u00b7 MSSP module optional use of TMR2 output to generate clock shift",
    "13.1 Timer2 Operation\nTimer2  can  be  used  as  the  PWM  time  base  for  the PWM mode of the ECCP module. The TMR2 register is readable  and  writable  and  is  cleared  on  any  device Reset. The input clock (FOSC/4) has a prescale option of 1:1, 1:4 or 1:16, selected by control bits T2CKPS1:T2CKPS0 (T2CON<1:0>). The match output of TMR2 goes through a 4-bit postscaler (which gives  a  1:1  to  1:16  scaling  inclusive)  to  generate  a TMR2 interrupt, latched in flag bit TMR2IF (PIR1<1>).\nTimer2 has a control register shown in Register 13-1. Timer2 can be shut off by clearing control bit TMR2ON (T2CON<2>) to minimize power consumption. Figure 13-1 is a simplified block diagram of the Timer2 module. Register 13-1 shows the Timer2 Control register.  The  prescaler  and  postscaler  selection  of Timer2 are controlled by this register.",
    "13.1 Timer2 Operation\nThe  prescaler  and  postscaler  counters  are  cleared when any of the following occurs:\n\u00b7 a write to the TMR2 register\n\u00b7 a write to the T2CON register\n\u00b7 any device Reset (Power-on Reset, MCLR Reset, Watchdog Timer Reset, or Brown-out Reset)\nTMR2 is not cleared when T2CON is written.",
    "REGISTER 13-1: T2CON: TIMER2 CONTROL REGISTER\nU-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\n-\nT2OUTPS3 T2OUTPS2\nT2OUTPS1\nT2OUTPS0\nTMR2ON\nT2CKPS1\nT2CKPS0\nbit 7\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6-3 T2OUTPS3:T2OUTPS0 : Timer2 Output Postscale Select bits\n0000 = 1:1 Postscale\n0001 = 1:2 Postscale\n\u2022\n\u2022\n\u2022\n1111 = 1:16 Postscale",
    "bit 2\nTMR2ON : Timer2 On bit\n1 = Timer2 is on\n0 = Timer2 is off\nbit 1-0 T2CKPS1:T2CKPS0 : Timer2 Clock Prescale Select bits\n00 = Prescaler is 1\n01 = Prescaler is 4\n1x = Prescaler is 16",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "13.3 Output of TMR2\nThe Timer2 module has an 8-bit period register, PR2. Timer2 increments from 00h until it matches PR2 and then resets to 00h on the next increment cycle. PR2 is a readable and writable register. The PR2 register is initialized to FFh upon Reset.\nThe output of TMR2 (before the postscaler) is fed to the synchronous serial port module which optionally uses it to generate the shift clock.",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR,",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nBOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 =",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nSSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Value on all other",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nResets = 0000. TMR2, Value on all other Resets = 0000. T2CON, Bit 7 = -. T2CON, Bit 6 = T2OUTPS3. T2CON, Bit 5 = T2OUTPS2. T2CON, Bit 4 = T2OUTPS1. T2CON, Bit 3 = T2OUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Value on all other Resets = -000. T2CON, Value on all other Resets = 0000. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nRegister. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. PR2, Value on all other Resets = 1111. PR2, Value on all other Resets = 1111\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer2 module.\nNote\n- 1: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "14.0 TIMER3 MODULE\nThe  Timer3  module  timer/counter  has  the  following features:\nFigure 14-1 is a simplified block diagram of the Timer3 module.\n- \u00b7 16-bit timer/counter\n(two 8-bit registers: TMR3H and TMR3L)\n\u00b7 Readable and writable (both registers)\n\u00b7 Internal or external clock select\n\u00b7 Interrupt-on-overflow from FFFFh to 0000h\n\u00b7 Reset from ECCP module trigger\nRegister 14-1 shows the Timer3 Control register. This register  controls  the  operating  mode  of  the  Timer3 module and sets the CCP/ECCP clock source.\nRegister 12-1 shows the Timer1 Control register. This register  controls  the  operating  mode  of  the  Timer1 module,  as  well  as  contains  the  Timer1  oscillator enable bit (T1OSCEN) which can be a clock source for Timer3.",
    "T3CON: TIMER3 CONTROL REGISTER\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nRD16\nT3CCP2\nT3CKPS1\nT3CKPS0\nT3CCP1\nT3SYNC\nTMR3CS\nTMR3ON\nbit 7\nbit 0",
    "bit 7 RD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register read/write of Timer3 in one 16-bit operation\n0 = Enables register read/write of Timer3 in two 8-bit operations",
    "bit 6,3 T3CCP2:T3CCP1: Timer3 and Timer1 to CCPx Enable bits\n11 = Timer3 and Timer4 are the clock sources for ECCP1 through CCP5\n10 = Timer3 and Timer4 are the clock sources for ECCP3 through CCP5;\nTimer1 and Timer2 are the clock sources for ECCP1 and ECCP2\n01 = Timer3 and Timer4 are the clock sources for ECCP2 through CCP5;\nTimer1 and Timer2 are the clock sources for ECCP1\n00 = Timer1 and Timer2 are the clock sources for ECCP1 through CCP5",
    "bit 5-4 T3CKPS1:T3CKPS0 : Timer3 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value\nbit 2 T3SYNC: Timer3 External Clock Input Synchronization Control bit\n(Not usable if the system clock comes from Timer1/Timer3)\nWhen TMR3CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR3CS =\n0\n:\nThis bit is ignored. Timer3 uses the internal clock when TMR3CS = 0 .",
    "bit 1 TMR3CS: Timer3 Clock Source Select bit\n1 = External clock input from Timer1 oscillator or T13CKI\n(on the rising edge after the first falling edge)\n0 = Internal clock (FOSC/4)",
    "bit 0 TMR3ON: Timer3 On bit\n1 = Enables Timer3\n0 = Stops Timer3",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "14.1 Timer3 Operation\nTimer3 can operate in one of these modes:\n- \u00b7 As a timer\nWhen TMR3CS = 0 , Timer3 increments every instruction cycle. When TMR3CS = 1 , Timer3 increments on every rising edge of the Timer1 external clock input or the Timer1 oscillator, if enabled.\n\u00b7 As a synchronous counter\n\u00b7 As an asynchronous counter\nThe operating mode is determined by the clock select bit, TMR3CS (T3CON<1>).\nWhen the Timer1 oscillator is enabled (T1OSCEN is set),  the  RC1/T1OSI  and  RC0/T1OSO/T13CKI  pins become  inputs.  That  is,  the  TRISC<1:0>  value  is ignored and the pins are read as ' 0 '.\nTimer3 also has an internal  'Reset input'. This Reset can be generated by the ECCP module ( Section 14.0 'Timer3 Module' ).",
    "14.2 Timer1 Oscillator\nThe Timer1 oscillator may be used as the clock source for Timer3. The Timer1 oscillator is enabled by setting the T1OSCEN (T1CON<3>) bit. The oscillator is a lowpower oscillator rated up to 200 kHz. See Section 12.0 'Timer1 Module' for further details.",
    "14.3 Timer3 Interrupt\nThe TMR3 register pair (TMR3H:TMR3L) increments from  0000h  to  FFFFh  and  rolls  over  to  0000h.  The TMR3 interrupt, if  enabled,  is  generated  on  overflow which is latched in interrupt flag bit, TMR3IF (PIR2<1>). This interrupt can be enabled/disabled by setting/clearing  TMR3  interrupt  enable  bit,  TMR3IE (PIE2<1>).",
    "14.4 Resetting Timer3 Using an ECCP Special Trigger Output\nIf either the ECCP1 or ECCP2 module is configured in Compare  mode  to  generate  a  special  event  trigger (CCP1M3:CCP1M0  = 1011 ), this signal  will  reset Timer3.\nNote:, 1 = The special event triggers from the ECCP module will not set interrupt flag bit, TMR3IF (PIR1<0>).\nTimer3 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If  Timer3  is  running  in  Asynchronous  Counter mode, this Reset operation may not work. In the event that a write to Timer3 coincides with a special event trigger from  ECCP1,  the  write  will  take  precedence.  In  this mode of operation, the CCPR1H:CCPR1L register pair effectively becomes the period register for Timer3.",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on all other Resets = 0000 000u. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF -0-0. PIR2, Value on POR, BOR = 0000. PIR2, Value on all other Resets = -0-0 0000. PIE2, Bit",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\n7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE -0-0 0000. PIE2, Value on POR, BOR = -0-0. PIE2, Value on all other Resets = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = -1-1 1111. IPR2, Value on all other Resets = -1-1 1111. TMR3L, Bit 7 = Timer3 Register Low Byte",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nxxxx. TMR3L, Bit 6 = Timer3 Register Low Byte xxxx. TMR3L, Bit 5 = Timer3 Register Low Byte xxxx. TMR3L, Bit 4 = Timer3 Register Low Byte xxxx. TMR3L, Bit 3 = Timer3 Register Low Byte xxxx. TMR3L, Bit 2 = Timer3 Register Low Byte xxxx. TMR3L, Bit 1 = Timer3 Register Low Byte xxxx. TMR3L, Bit 0 = Timer3 Register Low Byte xxxx. TMR3L, Value on POR, BOR = xxxx uuuu. TMR3L, Value on all other Resets = uuuu. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H,",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nBit 2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = Timer3 Register High Byte. TMR3H, Value on POR, BOR = xxxx xxxx. TMR3H, Value on all other Resets = uuuu uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00 0000. T1CON, Value on all other Resets = u-uu uuuu. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 =",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nT3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000 0000. T3CON, Value on all other Resets = uuuu uuuu\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer3 module.",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "15.1 Timer4 Operation\nThe Timer4 module timer has the following features:\n\u00b7 8-bit timer (TMR4 register)\n\u00b7 8-bit period register (PR4)\n\u00b7 Readable and writable (both registers)\n\u00b7 Software programmable prescaler (1:1, 1:4, 1:16)\n\u00b7 Software programmable postscaler (1:1 to 1:16)\n\u00b7 Interrupt on TMR4 match of PR4\nTimer4 has a control register shown in Register 15-1. Timer4 can be shut off by clearing control bit, TMR4ON (T4CON<2>),  to  minimize  power  consumption.  The prescaler and postscaler selection of Timer4 are also controlled  by  this  register.  Figure 15-1  is  a  simplified block diagram of the Timer4 module.",
    "15.1 Timer4 Operation\nTimer4  can  be  used  as  the  PWM  time  base  for  the PWM mode of the CCP module. The TMR4 register is readable  and  writable  and  is  cleared  on  any  device Reset. The input clock (FOSC/4) has a prescale option of 1:1, 1:4 or 1:16, selected by control bits T4CKPS1:T4CKPS0 (T4CON<1:0>). The match output of TMR4 goes through a 4-bit postscaler (which gives  a  1:1  to  1:16  scaling  inclusive)  to  generate  a TMR4 interrupt, latched in flag bit TMR4IF (PIR3<3>).\nThe  prescaler  and  postscaler  counters  are  cleared when any of the following occurs:\n\u00b7 a write to the TMR4 register\n\u00b7 a write to the T4CON register\n\u00b7 any device Reset (Power-on Reset, MCLR Reset, Watchdog Timer Reset, or Brown-out Reset)\nTMR4 is not cleared when T4CON is written.",
    "REGISTER 15-1: T4CON: TIMER4 CONTROL REGISTER\nU-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\n-\nT4OUTPS3 T4OUTPS2\nT4OUTPS1\nT4OUTPS0\nTMR4ON\nT4CKPS1\nT4CKPS0\nbit 7\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6-3 T4OUTPS3:T4OUTPS0 : Timer4 Output Postscale Select bits\n0000 = 1:1 Postscale\n0001 = 1:2 Postscale\n\u2022\n\u2022\n\u2022\n1111 = 1:16 Postscale",
    "bit 2\nTMR4ON : Timer4 On bit\n1 = Timer4 is on\n0 = Timer4 is off",
    "bit 1-0 T4CKPS1:T4CKPS0 : Timer4 Clock Prescale Select bits\n00 = Prescaler is 1\n01 = Prescaler is 4\n1x = Prescaler is 16",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "15.3 Output of TMR4\nThe Timer4 module has an 8-bit period register, PR4, which is both readable and writable. Timer4 increments from 00h until it matches PR4 and then resets to 00h on the next increment cycle. The PR4 register is initialized to FFh upon Reset.\nThe  output  of  TMR4  (before  the  postscaler)  is  used only as a PWM time base for the CCP modules. It is not used  as  a  baud  rate  clock  for  the  MSSP,  as  is  the Timer2 output.",
    "TABLE 15-1: REGISTERS ASSOCIATED WITH TIMER4 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = TMR4IP. IPR3, Bit 2 = CCP5IP. IPR3, Bit 1 = CCP4IP. IPR3, Bit 0 = CCP3IP. IPR3, Value on POR, BOR =",
    "TABLE 15-1: REGISTERS ASSOCIATED WITH TIMER4 AS A TIMER/COUNTER\n--11. IPR3, Value on POR, BOR = 1111. IPR3, Value on all other Resets = --00. IPR3, Value on all other Resets = 0000. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = TMR4IF. PIR3, Bit 2 = CCP5IF. PIR3, Bit 1 = CCP4IF. PIR3, Bit 0 = CCP3IF. PIR3, Value on POR, BOR = --00. PIR3, Value on POR, BOR = 0000. PIR3, Value on all other Resets = --00. PIR3, Value on all other Resets = 0000. PIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 =",
    "TABLE 15-1: REGISTERS ASSOCIATED WITH TIMER4 AS A TIMER/COUNTER\nTMR4IE. PIE3, Bit 2 = CCP5IE. PIE3, Bit 1 = CCP4IE. PIE3, Bit 0 = CCP3IE. PIE3, Value on POR, BOR = --00. PIE3, Value on POR, BOR = 0000. PIE3, Value on all other Resets = --00. PIE3, Value on all other Resets = 0000. TMR4, Bit 7 = Timer4 Register. TMR4, Bit 6 = Timer4 Register. TMR4, Bit 5 = Timer4 Register. TMR4, Bit 4 = Timer4 Register. TMR4, Bit 3 = Timer4 Register. TMR4, Bit 2 = Timer4 Register. TMR4, Bit 1 = Timer4 Register. TMR4, Bit 0 = Timer4 Register. TMR4, Value on POR, BOR = 0000. TMR4, Value on POR, BOR = 0000. TMR4, Value on all other Resets = 0000. TMR4, Value on",
    "TABLE 15-1: REGISTERS ASSOCIATED WITH TIMER4 AS A TIMER/COUNTER\nall other Resets = 0000. T4CON, Bit 7 = -. T4CON, Bit 6 = T4OUTPS3. T4CON, Bit 5 = T4OUTPS2. T4CON, Bit 4 = T4OUTPS1. T4CON, Bit 3 = T4OUTPS0. T4CON, Bit 2 = TMR4ON. T4CON, Bit 1 = T4CKPS1. T4CON, Bit 0 = T4CKPS0. T4CON, Value on POR, BOR = -000. T4CON, Value on POR, BOR = 0000. T4CON, Value on all other Resets = -000. T4CON, Value on all other Resets = 0000. PR4, Bit 7 = Timer4 Period Register. PR4, Bit 6 = Timer4 Period Register. PR4, Bit 5 = Timer4 Period Register. PR4, Bit 4 = Timer4 Period Register. PR4, Bit 3 = Timer4 Period Register. PR4, Bit 2 = Timer4 Period Register. PR4, Bit 1 = Timer4 Period Register.",
    "TABLE 15-1: REGISTERS ASSOCIATED WITH TIMER4 AS A TIMER/COUNTER\nPR4, Bit 0 = Timer4 Period Register. PR4, Value on POR, BOR = 1111. PR4, Value on POR, BOR = 1111. PR4, Value on all other Resets = 1111. PR4, Value on all other Resets = 1111\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer4 module.",
    "16.0 CAPTURE/COMPARE/PWM (CCP) MODULES\nPIC18F6525/6621/8525/8621 devices all have a total of five CCP (Capture/Compare/PWM) modules. Two of these (CCP4 and CCP5) implement standard Capture, Compare and Pulse-Width Modulation (PWM) modes and  are  discussed  in  this  section.  The  other  three modules (ECCP1, ECCP2, ECCP3) implement standard  Capture  and  Compare  modes,  as  well  as Enhanced  PWM  modes.  These  are  discussed  in Section 17.0 'Enhanced Capture/Compare/PWM (ECCP) Module' .\nCapture  and  Compare  operations  described  in  this chapter  apply  to  all  standard  and  Enhanced  CCP modules. The operations of PWM mode described in Section 16.4 'PWM Mode' apply to CCP4 and CCP5 only.\nNote:",
    "16.0 CAPTURE/COMPARE/PWM (CCP) MODULES\nEach  CCP/ECCP  module  contains  a  16-bit  register which can operate as a 16-bit Capture register, a 16-bit Compare register or a PWM Master/Slave Duty Cycle register. For the sake of clarity, all CCP module operation in the following sections is described with respect to CCP4, but is equally applicable to CCP5.\nThroughout this section and Section 17.0 'Enhanced Capture/Compare/PWM (ECCP)  Module' , references  to  register and bit names that may be associated with a  specific  CCP  module  are  referred  to generically by the use of 'x' or 'y' in place of the specific module number. Thus, 'CCPxCON'  might  refer  to  the  control register  for  CCP4  or  CCP5,  or  ECCP1, ECCP2  or  ECCP3.  'CCPxCON'  is  used throughout  these  sections  to  refer  to  the module control register, regardless of whether the CCP module is a standard or Enhanced implementation.",
    "REGISTER 16-1: CCPxCON REGISTER (CCP4 AND CCP5 MODULES)\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = DCxB1. -, 3 = DCxB0. -, 4 = CCPxM3. -, 5 = CCPxM2. -, 6 = CCPxM1. -, 7 = CCPxM0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-4 DCxB1:DCxB0 : PWM Duty Cycle bit 1 and bit 0 for CCP Module x\nCapture mode:\nUnused.\nCompare mode:\nUnused.\nPWM mode:",
    "REGISTER 16-1: CCPxCON REGISTER (CCP4 AND CCP5 MODULES)\nThese bits are the two Least Significant bits (bit 1 and bit 0) of the 10-bit PWM duty cycle. The eight Most Significant bits (DCx9:DCx2) of the duty cycle are found in CCPRxL.",
    "bit 3-0 CCPxM3:CCPxM0 : CCP Module x Mode Select bits\n0000 = Capture/Compare/PWM disabled (resets CCPx module)\n0001\n= Reserved\n0010 = Compare mode, toggle output on match (CCPxIF bit is set)\n0011 = Reserved\n0100 = Capture mode, every falling edge\n0101 = Capture mode, every rising edge\n0110 = Capture mode, every 4th rising edge\n0111 = Capture mode, every 16th rising edge\n1000 = Compare mode; initialize CCP pin low; on compare match, force CCP pin high (CCPIF bit is set)\n1001 = Compare mode; initialize CCP pin high; on compare match, force CCP pin low (CCPIF bit is set)\n1010 = Compare mode; generate software interrupt on compare match (CCPIF bit is set, CCP pin reflects I/O state)\n1011 = Reserved\n11xx = PWM mode",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "16.1 CCP Module Configuration\nEach  Capture/Compare/PWM  module  is  associated with a control register (generically, CCPxCON) and a data register (CCPRx). The data register in turn is comprised of two 8-bit registers: CCPRxL (low byte) and CCPRxH (high byte). All registers  are both readable and writable.",
    "16.1.1 CCP MODULES AND TIMER RESOURCES\nThe CCP/ECCP modules utilize Timers 1, 2, 3 or 4, depending on the mode selected. Timer1 and Timer3 are  available  to  modules  in  Capture  or  Compare modes,  while  Timer2  and  Timer4  are  available  for modules in PWM mode.\nTABLE 16-1: CCP MODE - TIMER RESOURCE\n\nCapture Compare PWM, Timer Resource = Timer1 or Timer3 Timer1 or Timer3 Timer2 or Timer4\nThe  assignment  of  a  particular  timer  to  a  module  is determined  by  the  Timer-to-CCP  enable  bits  in  the T3CON register (Register 14-1, page 143). Depending on the configuration selected, up to four timers may be active at once, with modules in the same configuration (Capture/Compare or PWM) sharing timer resources. The possible configurations are shown in Figure 16-1.",
    "FIGURE 16-1: CCP AND TIMER INTERCONNECT CONFIGURATIONS\nTimer1 is used for all Capture and  Compare  operations  for all  CCP  modules.  Timer2  is used for PWM operations for all CCP  modules.  Modules may share either timer resource  as  a  common  time base.\nTimer3  and  Timer4  are  not available.\nT3CCP<2:1> =\n01\nT3CCP<2:1> =\n10\nTimer1 and Timer2 are used for  Capture  and  Compare  or PWM  operations  for  ECCP1 only  (depending  on  selected mode).\nAll  other  modules  use  either Timer3  or  Timer4.  Modules may share either timer resource  as  a  common  time base  if  they  are  in  Capture/ Compare or PWM modes.\nTimer1  and  Timer2 are used for  Capture  and  Compare  or PWM  operations  for  ECCP1 and  ECCP2 only (depending on the mode selected for each module).  Both  modules  may use a timer as a common time base if they are both in Capture/Compare or PWM modes.\nThe other modules use either Timer3  or  Timer4.  Modules may share either timer resource  as  a  common  time base  if  they  are  in  Capture/ Compare or PWM modes.\n11",
    "FIGURE 16-1: CCP AND TIMER INTERCONNECT CONFIGURATIONS\nT3CCP<2:1> =\nTimer3 is used for all Capture and  Compare  operations  for all  CCP  modules.  Timer4  is used for PWM operations for all CCP  modules.  Modules may share either timer resource  as  a  common  time base.\nTimer1  and  Timer2  are  not available.",
    "16.2 Capture Mode\nIn Capture mode, the CCPR4H:CCPR4L register pair captures the 16-bit value of the TMR1 or TMR3 registers when an event occurs on pin RG3/CCP4/P1D. An event is defined as one of the following:\n\u00b7 every falling edge\n\u00b7 every rising edge\n\u00b7 every 4th rising edge\n\u00b7 every 16th rising edge\nThe  event  is selected by the mode  select bits, CCP4M3:CCP4M0 (CCP4CON<3:0>). When a capture is made, the interrupt request flag bit CCP4IF (PIR3<1>)  is  set;  it  must  be  cleared  in  software.  If another  capture  occurs  before  the  value  in  register CCPR4 is read, the old captured value is overwritten by the new captured value.",
    "16.2.1 CCP PIN CONFIGURATION\nIn  Capture mode, the RG3/CCP4/P1D pin should be configured as an input by setting the TRISG<3> bit.\nNote:, 1 = If the RG3/CCP4/P1D is configured as an output, a write to the port can cause a capture condition.",
    "16.2.2 TIMER1/TIMER3 MODE SELECTION\nThe timers that are to be used with the capture feature (Timer1 and/or Timer3) must be running in Timer mode or Synchronized  Counter  mode.  In  Asynchronous Counter  mode,  the  capture  operation  may  not  work. The timer to be used with each CCP module is selected in the  T3CON  register  (see Section 16.1.1  'CCP Modules and Timer Resources' ).",
    "16.2.3 SOFTWARE INTERRUPT\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep bit CCP4IE (PIE3<1>) clear to avoid false interrupts and should clear the flag bit, CCP4IF, following any such change in operating mode.",
    "16.2.4 CCP PRESCALER\nThere are four prescaler settings in Capture mode; they are specified as part of the operating mode selected by the mode select bits (CCP4M3:CCP4M0). Whenever the CCP module is turned off or the CCP module is not in Capture mode, the prescaler counter is cleared. This means that any Reset will clear the prescaler counter.\nSwitching from one capture prescaler to another may generate an interrupt. Also, the prescaler counter will not be cleared; therefore, the first capture may be from a non-zero prescaler. Example 16-1 shows the recommended method for switching between capture prescalers.  This  example  also  clears  the  prescaler counter and will not generate the 'false' interrupt.",
    "EXAMPLE 16-1: CHANGING BETWEEN CAPTURE PRESCALERS\nCLRF MOVLW, 1 = CCP4CON NEW_CAPT_PS. CLRF MOVLW, 2 = ; Turn CCP module off ; Load WREG with the ; new prescaler mode ; value and CCP ON. MOVWF, 1 = CCP4CON. MOVWF, 2 = ; Load CCP1CON with ; this value\nFIGURE 16-2: CAPTURE MODE OPERATION BLOCK DIAGRAM",
    "16.3.2 TIMER1/TIMER3 MODE SELECTION\nIn Compare mode, the 16-bit CCPR1 register value is constantly compared against either the TMR1 or TMR3 register  pair value. When a match occurs, the CCP4 pin can be:\n\u00b7 driven high\n\u00b7 driven low\n\u00b7 toggled (high-to-low or low-to-high)\n\u00b7 remain unchanged (that is, reflects the state of the I/O latch)\nThe action on the pin is based on the value of the mode select bits (CCP4M3:CCP4M0). At the same time, the interrupt flag bit CCP4IF is set.",
    "16.3.1 CCP PIN CONFIGURATION\nThe user must configure the CCPx pin as an output by clearing the appropriate TRIS bit.\nTimer1 and/or Timer3 must be running in Timer mode or Synchronized Counter mode, if the CCP module is using the compare feature. In Asynchronous Counter mode, the compare operation may not work.",
    "16.3.3 SOFTWARE INTERRUPT MODE\nWhen the Generate Software Interrupt mode is chosen (CCP4M3:CCP4M0  = 1010 ), the  CCP4  pin  is  not affected. Only a CCP interrupt is generated if enabled and the CCP4IE bit is set.",
    "16.3.4 SPECIAL EVENT TRIGGER\nAlthough shown in Figure 16-3, the compare on match special event triggers are not implemented on CCP4 or CCP5; they are only available on ECCP1 and ECCP2. Their operation is discussed in detail in Section 17.2.1 'Special Event Trigger' .\nNote:, 1 = Clearing the CCP4CON register will force the RG3/CCP4/P1D compare output latch to the default low level. This is not the PORTG I/O data latch.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nINTCON, Bit 7 = GIE/GIEH PEIE/GIEL. INTCON, Bit 6 = GIE/GIEH PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0--1. RCON, Value on",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nPOR, BOR = 11qq. RCON, Value on all other Resets = 0--q. RCON, Value on all other Resets = qquu. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nPIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nPIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = -0-0. PIR2, Value on POR, BOR = 0000. PIR2, Value on all other Resets = ---0. PIR2, Value on all other Resets = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = -0-0. PIE2,",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nValue on POR, BOR = 0000. PIE2, Value on all other Resets = ---0. PIE2, Value on all other Resets = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = -1-1. IPR2, Value on POR, BOR = 1111. IPR2, Value on all other Resets = ---1. IPR2, Value on all other Resets = 1111. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = TMR4IF. PIR3,",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nBit 2 = CCP5IF. PIR3, Bit 1 = CCP4IF. PIR3, Bit 0 = CCP3IF. PIR3, Value on POR, BOR = --00. PIR3, Value on POR, BOR = 0000. PIR3, Value on all other Resets = --00. PIR3, Value on all other Resets = 0000. PIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 = TMR4IE. PIE3, Bit 2 = CCP5IE. PIE3, Bit 1 = CCP4IE. PIE3, Bit 0 = CCP3IE. PIE3, Value on POR, BOR = --00. PIE3, Value on POR, BOR = 0000. PIE3, Value on all other Resets = --00. PIE3, Value on all other Resets = 0000. IPR3, Bit 7 = -. IPR3, Bit",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n6 = -. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = TMR4IP. IPR3, Bit 2 = CCP5IP. IPR3, Bit 1 = CCP4IP. IPR3, Bit 0 = CCP3IP. IPR3, Value on POR, BOR = --11. IPR3, Value on POR, BOR = 1111. IPR3, Value on all other Resets = --11. IPR3, Value on all other Resets = 1111. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR =",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n1111. TRISB, Value on POR, BOR = 1111. TRISB, Value on all other Resets = 1111. TRISB, Value on all other Resets = 1111. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other Resets = 1111. TRISC, Value on all other Resets = 1111. TRISE, Bit 7 = PORTE Data Direction Register. TRISE, Bit 6 = PORTE Data Direction Register. TRISE, Bit 5 = PORTE Data Direction Register. TRISE, Bit 4 = PORTE Data Direction Register. TRISE, Bit 3",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= PORTE Data Direction Register. TRISE, Bit 2 = PORTE Data Direction Register. TRISE, Bit 1 = PORTE Data Direction Register. TRISE, Bit 0 = PORTE Data Direction Register. TRISE, Value on POR, BOR = 1111. TRISE, Value on POR, BOR = 1111. TRISE, Value on all other Resets = 1111. TRISE, Value on all other Resets = 1111. TRISG, Bit 7 = -. TRISG, Bit 6 = -. TRISG, Bit 5 = -. TRISG, Bit 4 = PORTG Data Direction Register. TRISG, Bit 3 = PORTG Data Direction Register. TRISG, Bit 2 = PORTG Data Direction Register. TRISG, Bit 1 = PORTG Data Direction Register. TRISG, Bit 0 = PORTG Data Direction Register. TRISG, Value on POR, BOR = ---1. TRISG, Value on POR, BOR = 1111. TRISG, Value on all other Resets = ---1. TRISG, Value on all other Resets = 1111. TMR1L, Bit 7",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on all other Resets = uuuu. TMR1L, Value on all other Resets = uuuu. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nByte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on all other Resets = uuuu. TMR1H, Value on all other Resets = uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR =",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n0-00. T1CON, Value on POR, BOR = 0000. T1CON, Value on all other Resets = u-uu. T1CON, Value on all other Resets = uuuu. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = Timer3 Register High Byte. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on all other Resets = uuuu. TMR3H, Value on all other Resets = uuuu.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = Timer3 Register Low Byte. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on all other Resets = uuuu. TMR3L, Value on all other Resets = uuuu. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nT3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000. T3CON, Value on POR, BOR = 0000. T3CON, Value on all other Resets = uuuu. T3CON, Value on all other Resets = uuuu. CCPR1L, Bit 7 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Enhanced Capture/Compare/PWM Register 1 Low Byte.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCPR1L, Bit 1 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other Resets = uuuu. CCPR1L, Value on all other Resets = uuuu. CCPR1H, Bit 7 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other Resets = uuuu. CCPR1H, Value on all other Resets = uuuu. CCP1CON, Bit 7 = P1M1. CCP1CON, Bit 6 = P1M0. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on POR, BOR = 0000.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCP1CON, Value on all other Resets = 0000. CCP1CON, Value on all other Resets = 0000. CCPR2L, Bit 7 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 6 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 5 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 4 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 3 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 2 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 1 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 0 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on all other Resets",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= uuuu. CCPR2L, Value on all other Resets = uuuu. CCPR2H, Bit 7 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 6 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 5 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 4 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 3 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 2 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 1 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 0 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on all other Resets = uuuu.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCPR2H, Value on all other Resets = uuuu. CCP2CON, Bit 7 = P2M1. CCP2CON, Bit 6 = P2M0. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Value on POR, BOR = 0000. CCP2CON, Value on POR, BOR = 0000. CCP2CON, Value on all other Resets = 0000. CCP2CON, Value on all other Resets = 0000. CCPR3L, Bit 7 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 6 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 5 = Enhanced",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCapture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 4 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 3 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 2 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 1 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 0 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Value on POR, BOR = xxxx. CCPR3L, Value on POR, BOR = xxxx. CCPR3L, Value on all other Resets = uuuu. CCPR3L, Value on all other Resets = uuuu. CCPR3H, Bit 7 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 6 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 5 = Enhanced Capture/Compare/PWM",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nRegister 3 High Byte. CCPR3H, Bit 4 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 3 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 2 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 1 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 0 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Value on POR, BOR = xxxx. CCPR3H, Value on POR, BOR = xxxx. CCPR3H, Value on all other Resets = uuuu. CCPR3H, Value on all other Resets = uuuu. CCP3CON, Bit 7 = P3M1. CCP3CON, Bit 6 = P3M0. CCP3CON, Bit 5 = DC3B1. CCP3CON, Bit 4 = DC3B0. CCP3CON, Bit 3 =",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCP3M3. CCP3CON, Bit 2 = CCP3M2. CCP3CON, Bit 1 = CCP3M1. CCP3CON, Bit 0 = CCP3M0. CCP3CON, Value on POR, BOR = 0000. CCP3CON, Value on POR, BOR = 0000. CCP3CON, Value on all other Resets = 0000. CCP3CON, Value on all other Resets = 0000. CCPR4L, Bit 7 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 6 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 5 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 4 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 3 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 2 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 1 =",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCapture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 0 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Value on POR, BOR = xxxx. CCPR4L, Value on POR, BOR = xxxx. CCPR4L, Value on all other Resets = uuuu. CCPR4L, Value on all other Resets = uuuu. CCPR4H, Bit 7 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 6 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 5 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 4 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 3 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 2 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 1 = Capture/Compare/PWM Register 4 High Byte.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCPR4H, Bit 0 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Value on POR, BOR = xxxx. CCPR4H, Value on POR, BOR = xxxx. CCPR4H, Value on all other Resets = uuuu. CCPR4H, Value on all other Resets = uuuu. CCP4CON, Bit 7 = -. CCP4CON, Bit 6 = -. CCP4CON, Bit 5 = DC4B1. CCP4CON, Bit 4 = DC4B0. CCP4CON, Bit 3 = CCP4M3. CCP4CON, Bit 2 = CCP4M2. CCP4CON, Bit 1 = CCP4M1. CCP4CON, Bit 0 = CCP4M0. CCP4CON, Value on POR, BOR = --00. CCP4CON, Value on POR, BOR = 0000. CCP4CON, Value on all other Resets = --00. CCP4CON, Value",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\non all other Resets = 0000. CCPR5L, Bit 7 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 6 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 5 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 4 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 3 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 2 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 1 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 0 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Value on POR, BOR = xxxx. CCPR5L, Value on POR, BOR = xxxx. CCPR5L, Value on all other Resets = uuuu. CCPR5L, Value on all other Resets = uuuu. CCPR5H, Bit",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n7 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 6 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 5 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 4 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 3 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 2 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 1 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 0 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Value on POR, BOR = xxxx. CCPR5H, Value on POR, BOR = xxxx. CCPR5H, Value on all other Resets = uuuu. CCPR5H, Value on all other Resets = uuuu. CCP5CON, Bit 7 = -. CCP5CON, Bit 6 = -.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCP5CON, Bit 5 = DC5B1. CCP5CON, Bit 4 = . CCP5CON, Bit 3 = . CCP5CON, Bit 2 = . CCP5CON, Bit 1 = CCP5M1. CCP5CON, Bit 0 = . CCP5CON, Value on POR, BOR = --00. CCP5CON, Value on POR, BOR = 0000. CCP5CON, Value on all other Resets = --00. CCP5CON, Value on all other Resets = 0000. , Bit 7 = DC5B0 CCP5M3 CCP5M2 CCP5M0. , Bit 6 = DC5B0 CCP5M3 CCP5M2 CCP5M0. , Bit 5 = DC5B0 CCP5M3 CCP5M2 CCP5M0. , Bit 4 = DC5B0 CCP5M3 CCP5M2 CCP5M0. , Bit 3 = DC5B0 CCP5M3 CCP5M2",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCP5M0. , Bit 2 = DC5B0 CCP5M3 CCP5M2 CCP5M0. , Bit 1 = DC5B0 CCP5M3 CCP5M2 CCP5M0. , Bit 0 = DC5B0 CCP5M3 CCP5M2 CCP5M0. , Value on POR, BOR = . , Value on POR, BOR = . , Value on all other Resets = . , Value on all other Resets = \nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '.\nShaded cells are not used by Capture and Compare, Timer1 or Timer3.\n- Note 1: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "16.4 PWM Mode\nIn Pulse-Width Modulation (PWM) mode, the CCP4 pin produces up to a 10-bit resolution PWM output. Since the  CCP4  pin  is  multiplexed  with  the  PORTG  data latch, the TRISG<3> bit must be cleared to make the CCP4 pin an output.\nNote:, 1 = Clearing the CCP4CON register will force the CCP4 PWM output latch to the default low level. This is not the PORTG I/O data latch.\nFigure 16-4  shows  a  simplified  block  diagram  of  the CCP module in PWM mode.\nFor a step-by-step procedure on how to set up the CCP module for PWM  operation, see Section 16.4.3 'Setup for PWM Operation' .",
    "FIGURE 16-4: DIAGRAM\nA PWM output (Figure 16-5) has a time base (period) and a time that  the  output  stays  high  (duty  cycle). The  frequency  of  the  PWM  is  the  inverse  of  the period (1/period).",
    "16.4.1 PWM PERIOD\nThe  PWM  period  is  specified  by  writing  to  the  PR2 (PR4)  register.  The  PWM  period  can  be  calculated using the following formula:",
    "EQUATION 16-1:\nPWM Period   = [(PR2) + 1] \u00b7 4 \u00b7 TOSC \u00b7 (TMR2 Prescale Value)\nPWM frequency is defined as 1/[PWM period].\nWhen  TMR2  (TMR4)  is  equal  to  PR2  (PR2),  the following  three  events  occur  on  the  next  increment cycle:\n\u00b7 TMR2 (TMR4) is cleared\n\u00b7 The CCP4 pin is set (exception: if PWM duty cycle = 0%, the CCP4 pin will not be set)\n\u00b7 The PWM duty cycle is latched from CCPR4L into CCPR4H\nNote:\nThe Timer2 and Timer4 postscalers (see Section 13.0 'Timer2 Module' )  are  not used  in  the  determination  of  the  PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "16.4.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the CCPR4L register and to the CCP4CON<5:4> bits. Up to 10-bit resolution is available. The CCPR4L contains the eight MSbs and the CCP4CON<5:4> contains the two LSbs. This 10-bit value is represented by CCPR4L:CCP4CON<5:4>.  The  following  equation  is used to calculate the PWM duty cycle in time:",
    "EQUATION 16-2:\nPWM Duty Cycle   = (CCPR4L:CCP4CON<5:4>) \u00b7 TOSC \u00b7 (TMR2 Prescale Value)\nCCPR4L and CCP4CON<5:4> can be written to at any time,  but  the  duty  cycle  value  is  not  latched  into CCPR4H until after a match between PR2 and TMR2 occurs  (i.e.,  the  period  is  complete).  In  PWM  mode, CCPR4H is a read-only register.\nThe  CCPR4H  register  and  a  2-bit  internal  latch  are used  to  double-buffer the PWM  duty  cycle.  This double-buffering is essential for glitchless PWM operation.\nWhen the CCPR4H and 2-bit latch match TMR2, concatenated with an internal 2-bit Q clock or 2 bits of the TMR2 prescaler, the CCP4 pin is cleared.",
    "PIC18F6525/6621/8525/8621\nThe maximum PWM resolution (bits) for a given PWM frequency is given by the equation:",
    "EQUATION 16-3:\n<!-- formula-not-decoded -->\nNote:\nIf the PWM duty cycle value is longer than the PWM period, the CCP4 pin will not be cleared.\nThe following steps should be taken when configuring the CCP module for PWM operation:\n1. Select TMR2 or TMR4 by setting or clearing the T3CCP2:T3CCP1 bits in the T3CON register.\n2. Set  the  PWM period  by  writing  to  the  PR2  or PR4 register\n3. Set  the  PWM  duty  cycle  by  writing  to  the CCPR4L register and CCP4CON<5:4> bits.\n4. Make the CCP4 pin an output by clearing the TRISG<3> bit.\n5. Set  TMR2  or  TMR4  prescale  value,  enable Timer2  or  Timer4  by  writing  to  T2CON  or T4CON.\n6. Configure the CCP4 module for PWM operation.",
    "TABLE 16-3: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.77 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.25 kHz = 1. Timer Prescaler (1, 4, 16), 312.50 kHz = 1. Timer Prescaler (1, 4, 16), 416.67 kHz = 1. PR2 Value, 2.44 kHz = FFh. PR2 Value, 9.77 kHz = FFh. PR2 Value, 39.06 kHz = FFh. PR2 Value, 156.25 kHz = 3Fh. PR2 Value, 312.50 kHz = 1Fh. PR2 Value, 416.67 kHz = 17h. Maximum Resolution (bits), 2.44 kHz = 14. Maximum Resolution (bits), 9.77 kHz = 12. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits), 156.25 kHz =",
    "TABLE 16-3: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\n8. Maximum Resolution (bits), 312.50 kHz = 7. Maximum Resolution (bits), 416.67 kHz = 6.58",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0--1. RCON, Value on POR, BOR = 11qq. RCON, Value on all",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nother Resets = 0--q. RCON, Value on all other Resets = qquu. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\n1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. PIR2, Bit 7 = -. PIR2, Bit 6 =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nCMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = -0-0. PIR2, Value on POR, BOR = 0000. PIR2, Value on all other Resets = ---0. PIR2, Value on all other Resets = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = -0-0. PIE2, Value on POR, BOR = 0000. PIE2, Value on all",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nother Resets = ---0. PIE2, Value on all other Resets = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = -1-1. IPR2, Value on POR, BOR = 1111. IPR2, Value on all other Resets = ---1. IPR2, Value on all other Resets = 1111. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = TMR4IF. PIR3, Bit 2 = CCP5IF. PIR3, Bit 1 =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nCCP4IF. PIR3, Bit 0 = CCP3IF. PIR3, Value on POR, BOR = --00. PIR3, Value on POR, BOR = 0000. PIR3, Value on all other Resets = --00. PIR3, Value on all other Resets = 0000. PIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 = TMR4IE. PIE3, Bit 2 = CCP5IE. PIE3, Bit 1 = CCP4IE. PIE3, Bit 0 = CCP3IE. PIE3, Value on POR, BOR = --00. PIE3, Value on POR, BOR = 0000. PIE3, Value on all other Resets = --00. PIE3, Value on all other Resets = 0000. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = RC2IP.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nIPR3, Bit 4 = TX2IP. IPR3, Bit 3 = TMR4IP. IPR3, Bit 2 = CCP5IP. IPR3, Bit 1 = CCP4IP. IPR3, Bit 0 = CCP3IP. IPR3, Value on POR, BOR = --11. IPR3, Value on POR, BOR = 1111. IPR3, Value on all other Resets = --11. IPR3, Value on all other Resets = 1111. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nBOR = 0000. TMR2, Value on all other Resets = 0000. TMR2, Value on all other Resets = 0000. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. PR2, Value on all other Resets = 1111. PR2, Value on all other Resets = 1111. T2CON, Bit 7 = -. T2CON, Bit 6 = T2OUTPS3. T2CON, Bit 5 = T2OUTPS2. T2CON, Bit 4 = T2OUTPS1. T2CON, Bit 3 = T2OUTPS0.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nT2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Value on all other Resets = -000. T2CON, Value on all other Resets = 0000. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000. T3CON, Value on POR, BOR = 0000. T3CON, Value on all other Resets = uuuu.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nT3CON, Value on all other Resets = uuuu. TMR4, Bit 7 = Timer4 Register. TMR4, Bit 6 = Timer4 Register. TMR4, Bit 5 = Timer4 Register. TMR4, Bit 4 = Timer4 Register. TMR4, Bit 3 = Timer4 Register. TMR4, Bit 2 = Timer4 Register. TMR4, Bit 1 = Timer4 Register. TMR4, Bit 0 = Timer4 Register. TMR4, Value on POR, BOR = 0000. TMR4, Value on POR, BOR = 0000. TMR4, Value on all other Resets = uuuu. TMR4, Value on all other Resets = uuuu. PR4, Bit 7 = Timer4 Period Register. PR4, Bit 6 = Timer4 Period Register. PR4, Bit 5 = Timer4 Period Register. PR4, Bit 4 = Timer4 Period Register. PR4, Bit 3 = Timer4 Period Register. PR4, Bit 2 = Timer4",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nPeriod Register. PR4, Bit 1 = Timer4 Period Register. PR4, Bit 0 = Timer4 Period Register. PR4, Value on POR, BOR = 1111. PR4, Value on POR, BOR = 1111. PR4, Value on all other Resets = uuuu. PR4, Value on all other Resets = uuuu. T4CON, Bit 7 = -. T4CON, Bit 6 = T4OUTPS3 T4OUTPS2 T4OUTPS1 T4OUTPS0 TMR4ON T4CKPS1 T4CKPS0. T4CON, Bit 5 = T4OUTPS3 T4OUTPS2 T4OUTPS1 T4OUTPS0 TMR4ON T4CKPS1 T4CKPS0. T4CON, Bit 4 = T4OUTPS3 T4OUTPS2 T4OUTPS1 T4OUTPS0 TMR4ON T4CKPS1 T4CKPS0. T4CON, Bit 3 = T4OUTPS3 T4OUTPS2",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nT4OUTPS1 T4OUTPS0 TMR4ON T4CKPS1 T4CKPS0. T4CON, Bit 2 = T4OUTPS3 T4OUTPS2 T4OUTPS1 T4OUTPS0 TMR4ON T4CKPS1 T4CKPS0. T4CON, Bit 1 = T4OUTPS3 T4OUTPS2 T4OUTPS1 T4OUTPS0 TMR4ON T4CKPS1 T4CKPS0. T4CON, Bit 0 = T4OUTPS3 T4OUTPS2 T4OUTPS1 T4OUTPS0 TMR4ON T4CKPS1 T4CKPS0. T4CON, Value on POR, BOR = -000. T4CON, Value on POR, BOR = 0000. T4CON, Value on all other Resets = uuuu. T4CON, Value on all other Resets = uuuu. CCPR1L, Bit 7 = Enhanced Capture/Compare/PWM Register 1 Low Byte.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nCCPR1L, Bit 6 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other Resets = uuuu. CCPR1L, Value on all other Resets = uuuu. CCPR1H, Bit 7 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\n= Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other Resets = uuuu. CCPR1H, Value on all other Resets = uuuu. CCP1CON, Bit 7 = P1M1. CCP1CON, Bit 6 = P1M0. CCP1CON, Bit 5 =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nDC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on all other Resets = 0000. CCP1CON, Value on all other Resets = 0000. CCPR2L, Bit 7 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 6 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 5 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 4 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 3 = Enhanced Capture/Compare/PWM Register 2 Low Byte.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nCCPR2L, Bit 2 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 1 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 0 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on all other Resets = uuuu. CCPR2L, Value on all other Resets = uuuu. CCPR2H, Bit 7 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 6 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 5 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 4 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 3 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 2",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\n= Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 1 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 0 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on all other Resets = uuuu. CCPR2H, Value on all other Resets = uuuu. CCP2CON, Bit 7 = P2M1. CCP2CON, Bit 6 = P2M0. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Value on POR, BOR",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\n= 0000. CCP2CON, Value on POR, BOR = 0000. CCP2CON, Value on all other Resets = 0000. CCP2CON, Value on all other Resets = 0000. CCPR3L, Bit 7 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 6 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 5 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 4 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 3 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 2 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 1 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 0 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Value on POR, BOR = xxxx. CCPR3L, Value on",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nPOR, BOR = xxxx. CCPR3L, Value on all other Resets = uuuu. CCPR3L, Value on all other Resets = uuuu. CCPR3H, Bit 7 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 6 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 5 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 4 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 3 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 2 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 1 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 0 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Value on POR, BOR = xxxx. CCPR3H, Value on POR, BOR =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nxxxx. CCPR3H, Value on all other Resets = uuuu. CCPR3H, Value on all other Resets = uuuu. CCP3CON, Bit 7 = P3M1. CCP3CON, Bit 6 = P3M0. CCP3CON, Bit 5 = DC3B1. CCP3CON, Bit 4 = DC3B0. CCP3CON, Bit 3 = CCP3M3. CCP3CON, Bit 2 = CCP3M2. CCP3CON, Bit 1 = CCP3M1. CCP3CON, Bit 0 = CCP3M0. CCP3CON, Value on POR, BOR = 0000. CCP3CON, Value on POR, BOR = 0000. CCP3CON, Value on all other Resets = 0000. CCP3CON, Value on all other Resets = 0000. CCPR4L, Bit 7 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 6 =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nCapture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 5 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 4 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 3 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 2 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 1 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Bit 0 = Capture/Compare/PWM Register 4 Low Byte. CCPR4L, Value on POR, BOR = xxxx. CCPR4L, Value on POR, BOR = xxxx. CCPR4L, Value on all other Resets = uuuu. CCPR4L, Value on all other Resets = uuuu. CCPR4H, Bit 7 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 6 = Capture/Compare/PWM Register 4 High Byte.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nCCPR4H, Bit 5 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 4 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 3 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 2 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 1 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Bit 0 = Capture/Compare/PWM Register 4 High Byte. CCPR4H, Value on POR, BOR = xxxx. CCPR4H, Value on POR, BOR = xxxx. CCPR4H, Value on all other Resets = uuuu. CCPR4H, Value on all other Resets = uuuu. CCP4CON, Bit 7 = -. CCP4CON, Bit 6 = -. CCP4CON, Bit 5 = DC4B1. CCP4CON, Bit 4 = DC4B0. CCP4CON, Bit 3 =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nCCP4M3. CCP4CON, Bit 2 = CCP4M2. CCP4CON, Bit 1 = CCP4M1. CCP4CON, Bit 0 = CCP4M0. CCP4CON, Value on POR, BOR = --00. CCP4CON, Value on POR, BOR = 0000. CCP4CON, Value on all other Resets = --00. CCP4CON, Value on all other Resets = 0000. CCPR5L, Bit 7 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 6 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 5 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 4 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 3 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 2 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 1 =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nCapture/Compare/PWM Register 5 Low Byte. CCPR5L, Bit 0 = Capture/Compare/PWM Register 5 Low Byte. CCPR5L, Value on POR, BOR = xxxx. CCPR5L, Value on POR, BOR = xxxx. CCPR5L, Value on all other Resets = uuuu. CCPR5L, Value on all other Resets = uuuu. CCPR5H, Bit 7 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 6 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 5 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 4 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 3 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 2 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Bit 1 = Capture/Compare/PWM Register 5 High Byte.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\nCCPR5H, Bit 0 = Capture/Compare/PWM Register 5 High Byte. CCPR5H, Value on POR, BOR = xxxx. CCPR5H, Value on POR, BOR = xxxx. CCPR5H, Value on all other Resets = uuuu. CCPR5H, Value on all other Resets = uuuu. CCP5CON, Bit 7 = -. CCP5CON, Bit 6 = -. CCP5CON, Bit 5 = DC5B1. CCP5CON, Bit 4 = DC5B0. CCP5CON, Bit 3 = CCP5M3. CCP5CON, Bit 2 = CCP5M2. CCP5CON, Bit 1 = CCP5M1. CCP5CON, Bit 0 = CCP5M0. CCP5CON, Value on POR, BOR = --00. CCP5CON, Value on POR, BOR = 0000. CCP5CON, Value on all other Resets = --00. CCP5CON, Value",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM, TIMER2 AND TIMER4\non all other Resets = 0000\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by PWM, Timer2 or Timer4. Note 1: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "17.0 ENHANCED CAPTURE/ COMPARE/PWM (ECCP) MODULE\nCapture and Compare functions of the ECCP module are the same as the standard CCP module.\nThe Enhanced CCP (ECCP) modules differ from the standard CCP modules by the addition of Enhanced PWM  capabilities.  These  allow  for  2  or  4  output channels, user selectable polarity, dead-band control and automatic shutdown and restart and are discussed\nThe prototype control register for the Enhanced CCP module is  shown  in  Register 17-1.  In  addition  to  the expanded  range  of modes  available through the CCPxCON register, the ECCP modules each have two additional  registers  associated  with  Enhanced  PWM operation and auto-shutdown features. They are:\nin  detail  in Section 17.4  'Enhanced  PWM  Mode' . Except  for  the  addition  of  the  special  event  trigger,\n\u00b7 ECCPxDEL (Dead-Band Delay)\n\u00b7 ECCPxAS (Auto-Shutdown Configuration)",
    "REGISTER 17-1: CCPxCON REGISTER (ECCP1, ECCP2 AND ECCP3 MODULES)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PxM1, 1 = PxM0. PxM1, 2 = DCxB1. PxM1, 3 = DCxB0. PxM1, 4 = CCPxM3. PxM1, 5 = CCPxM2. PxM1, 6 = CCPxM1. PxM1, 7 = CCPxM0\nbit 7\nbit 0",
    "bit 7-6 PxM1:PxM0: Enhanced PWM Output Configuration bits\nIf CCPxM3:CCPxM2 = 00 01 10 , , :\nxx = PxA assigned as Capture/Compare input/output; PxB, PxC, PxD assigned as port pins\nIf CCPxM3:CCPxM2 = 11 :\n00 = Single output: PxA modulated; PxB, PxC, PxD assigned as port pins\n01 = Full-bridge output forward: P1D modulated; P1A active; P1B, P1C inactive\n10 = Half-bridge output: P1A, P1B modulated with dead-band control; P1C, P1D assigned as port pins\n11 = Full-bridge output reverse: P1B modulated; P1C active; P1A, P1D inactive",
    "bit 5-4 DCxB1:DCxB0 : PWM Duty Cycle bit 1 and bit 0\nCapture mode:\nUnused.\nCompare mode:\nUnused.\nPWM mode:\nThese bits are the two LSbs of the 10-bit PWM duty cycle. The eight MSbs of the duty cycle are found in CCPRxL.",
    "bit 3-0 CCPxM3:CCPxM0 : Enhanced CCP Mode Select bits\n0000 = Capture/Compare/PWM off (resets ECCPx module)\n0001 = Reserved\n0010 = Compare mode, toggle output on match\n0011 = Capture mode\n0100 = Capture mode, every falling edge\n0101 = Capture mode, every rising edge\n0110 = Capture mode, every 4th rising edge\n0111 = Capture mode, every 16th rising edge\n1000 = Compare mode, initialize ECCP pin low, set output on compare match (set CCPxIF)\n1001 = Compare mode, initialize ECCP pin high, clear output on compare match (set CCPxIF)\n1010 = Compare mode, generate software interrupt only, ECCP pin reverts to I/O state\n1011 = Compare mode, trigger special event (ECCP resets TMR1 or TMR3, sets CCxIF bit, (1)\nECCP2 trigger starts A/D conversion if A/D module is enabled)\n1100 = PWM mode; PxA, PxC active-high; PxB, PxD active-high",
    "bit 3-0 CCPxM3:CCPxM0 : Enhanced CCP Mode Select bits\n1101 = PWM mode; PxA, PxC active-high; PxB, PxD active-low\n1110 = PWM mode; PxA, PxC active-low; PxB, PxD active-high\n1111 = PWM mode; PxA, PxC active-low; PxB, PxD active-low\nNote 1: Implemented only for ECCP1 and ECCP2; same as ' 1010 ' for ECCP3.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "17.1 ECCP Outputs and Configuration\nEach of the Enhanced CCP modules may have up to four PWM  outputs, depending on the selected operating mode. These outputs, designated PxA through  PxD,  are  multiplexed  with  various  I/O  pins. Some  ECCP  pin  assignments  are  constant,  while others  change  based  on  device  configuration.  For those pins that do change, the controlling bits are:\nECCP1  and  ECCP3,  on  the  other  hand,  only  have three  dedicated  output  pins:  ECCPx/PxA,  PxB  and PxC.  Whenever  these  modules  are  configured  for Quad PWM mode, the pin normally used for CCP4 or CCP5  becomes  the  D  output  pins  for  ECCP3  and ECCP1, respectively. The CCP4 and CCP5 modules remain functional but their outputs are overridden.\n\u00b7 CCP2MX configuration bit (CONFIG3H<0>)\n\u00b7 ECCPMX configuration bit (CONFIG3H<1>)\n\u00b7 Program Memory mode (set by configuration bits CONFIG3L<1:0>)",
    "17.1 ECCP Outputs and Configuration\nThe pin assignments for the Enhanced CCP modules are summarized in Table 17-1, Table 17-2 and Table 17-3. To configure the I/O pins as PWM outputs, the proper PWM mode must be selected by setting the PxMx and CCPxMx bits (CCPxCON<7:6> and <3:0>, respectively).  The  appropriate  TRIS  direction  bits  for the  corresponding  port  pins  must  also  be  set  as outputs.",
    "17.1.1 USE OF CCP4 AND CCP5 WITH ECCP1 AND ECCP3\nOnly the ECCP2 module has four dedicated output pins available for use. Assuming that the I/O ports or other multiplexed  functions  on  those  pins  are  not  needed, they may be used whenever needed without interfering with any other CCP module.",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nFor PIC18F8525/8621 devices, the Program Memory mode of the device ( Section 4.1.1 'PIC18F6525/6621/ 8525/8621 Program Memory Modes' )  impacts both pin multiplexing and the operation of the module.\nThe ECCP2 input/output (ECCP2/P2A) can be multiplexed to one of three pins. By default, this is RC1 for all devices.  In  this  case,  the  default  occurs  when CCP2MX is set and the device is operating in Microcontroller mode. With PIC18F8525/8621 devices, three other options exist. When CCP2MX is not set (= 0 ) and the device is in Microcontroller mode, ECCP2/P2A is multiplexed  to  RE7;  in  all  other  program  memory modes, it is multiplexed to RB3.",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nThe  final  option  is  for  CCP2MX  to  be  set  while  the device is operating in one of the three other program memory modes. In this case, ECCP1 and ECCP3 operate as  compatible (i.e., single output)  CCP modules. The pins used by their other outputs (PxB through PxD) are  available  for  other  multiplexed  functions.  ECCP2 continues  to  operate  as  an  Enhanced  CCP  module regardless of the program memory mode.\n\nTABLE 17-1: PIN CONFIGURATIONS FOR ECCP1",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nAll PIC18F6525/6621 devices:, CCP1CON Configuration = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RC2 = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RE6 = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RE5 = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RG4 = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RH7 = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RH6 = All PIC18F6525/6621 devices:. Compatible CCP, CCP1CON Configuration = 00xx 11xx. Compatible CCP, RC2 = ECCP1. Compatible CCP, RE6 = RE6. Compatible CCP, RE5 = RE5. Compatible",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nCCP, RG4 = RG4/CCP5. Compatible CCP, RH7 = N/A. Compatible CCP, RH6 = N/A. Dual PWM, CCP1CON Configuration = 10xx 11xx. Dual PWM, RC2 = P1A. Dual PWM, RE6 = P1B. Dual PWM, RE5 = RE5. Dual PWM, RG4 = RG4/CCP5. Dual PWM, RH7 = N/A. Dual PWM, RH6 = N/A. Quad PWM, CCP1CON Configuration = x1xx 11xx. Quad PWM, RC2 = P1A. Quad PWM, RE6 = P1B. Quad PWM, RE5 = P1C. Quad PWM, RG4 = P1D. Quad PWM, RH7 = N/A. Quad PWM, RH6 = N/A. PIC18F8525/8621 devices, ECCPMX = 1 ,",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nMicrocontroller mode:, CCP1CON Configuration = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:, RC2 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:, RE6 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:, RE5 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:, RG4 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices,",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nECCPMX = 1 , Microcontroller mode:, RH7 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:, RH6 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. Compatible CCP, CCP1CON Configuration = 00xx 11xx. Compatible CCP, RC2 = ECCP1. Compatible CCP, RE6 = RE6/AD14. Compatible CCP, RE5 = RE5/AD13. Compatible CCP, RG4 = RG4/CCP5. Compatible CCP, RH7 = RH7/AN15. Compatible CCP, RH6 = RH6/AN14. Dual PWM, CCP1CON Configuration = 10xx 11xx. Dual PWM, RC2 = P1A. Dual PWM, RE6 = P1B. Dual PWM, RE5 = RE5/AD13. Dual",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nPWM, RG4 = RG4/CCP5. Dual PWM, RH7 = RH7/AN15. Dual PWM, RH6 = RH6/AN14. Quad PWM, CCP1CON Configuration = x1xx 11xx. Quad PWM, RC2 = P1A. Quad PWM, RE6 = P1B. Quad PWM, RE5 = P1C. Quad PWM, RG4 = P1D. Quad PWM, RH7 = RH7/AN15. Quad PWM, RH6 = RH6/AN14. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, CCP1CON Configuration = PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RC2 = PIC18F8525/8621 devices, ECCPMX = 0 ,",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nMicrocontroller mode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RE6 = PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RE5 = PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RG4 = PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RH7 = PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RH6 = PIC18F8525/8621 devices,",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nECCPMX = 0 , Microcontroller mode:. Compatible CCP, CCP1CON Configuration = 00xx 11xx. Compatible CCP, RC2 = ECCP1. Compatible CCP, RE6 = RE6/AD14. Compatible CCP, RE5 = RE5/AD13. Compatible CCP, RG4 = RG4/CCP5. Compatible CCP, RH7 = RH7/AN15. Compatible CCP, RH6 = RH6/AN14. Dual PWM, CCP1CON Configuration = 10xx 11xx. Dual PWM, RC2 = P1A. Dual PWM, RE6 = RE6/AD14. Dual PWM, RE5 = RE5/AD13. Dual PWM, RG4 = RG4/CCP5. Dual PWM, RH7 = P1B. Dual PWM, RH6 = RH6/AN14. Quad PWM, CCP1CON Configuration = x1xx 11xx. Quad PWM, RC2 = P1A. Quad",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nPWM, RE6 = RE6/AD14. Quad PWM, RE5 = RE5/AD13. Quad PWM, RG4 = P1D. Quad PWM, RH7 = P1B. Quad PWM, RH6 = P1C. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, CCP1CON Configuration = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RC2 = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RE6 = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RE5 =",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nPIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RG4 = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RH7 = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RH6 = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. Compatible CCP, CCP1CON Configuration = 00xx 11xx. Compatible CCP, RC2 = ECCP1. Compatible CCP, RE6 = RE6/AD14. Compatible CCP, RE5 = RE5/AD13. Compatible CCP, RG4 = RG4/CCP5. Compatible",
    "17.1.2 ECCP MODULE OUTPUTS AND PROGRAM MEMORY MODES\nCCP, RH7 = RH7/AN15. Compatible CCP, RH6 = RH6/AN14\nLegend: x = Don't care, N/A = Not available. Shaded cells indicate pin assignments not used by ECCP1 in a given mode.\nNote 1: With ECCP1 in Quad PWM mode, CCP5's output is overridden by P1D; otherwise CCP5 is fully operational.",
    "TABLE 17-2: PIN CONFIGURATIONS FOR ECCP2\nAll devices, CCP2MX = 1 , Microcontroller mode:, CCP2CON Configuration = All devices, CCP2MX = 1 , Microcontroller mode:. All devices, CCP2MX = 1 , Microcontroller mode:, RB3 = All devices, CCP2MX = 1 , Microcontroller mode:. All devices, CCP2MX = 1 , Microcontroller mode:, RC1 = All devices, CCP2MX = 1 , Microcontroller mode:. All devices, CCP2MX = 1 , Microcontroller mode:, RE7 = All devices, CCP2MX = 1 , Microcontroller mode:. All devices, CCP2MX = 1 , Microcontroller mode:, RE2 = All devices, CCP2MX = 1 , Microcontroller mode:. All devices, CCP2MX = 1 , Microcontroller mode:, RE1 = All devices, CCP2MX = 1 , Microcontroller mode:. All devices, CCP2MX = 1 , Microcontroller mode:, RE0 =",
    "TABLE 17-2: PIN CONFIGURATIONS FOR ECCP2\nAll devices, CCP2MX = 1 , Microcontroller mode:. Compatible CCP, CCP2CON Configuration = 00xx 11xx. Compatible CCP, RB3 = RB3/INT3. Compatible CCP, RC1 = . Compatible CCP, RE7 = ECCP2 RE7. Compatible CCP, RE2 = RE2. Compatible CCP, RE1 = RE1. Compatible CCP, RE0 = RE0. Dual PWM, CCP2CON Configuration = 10xx. Dual PWM, RB3 = 11xx. Dual PWM, RC1 = RB3/INT3. Dual PWM, RE7 = P2A RE7. Dual PWM, RE2 = P2B. Dual PWM, RE1 = RE1. Dual PWM, RE0 = RE0. Quad PWM, CCP2CON Configuration = x1xx. Quad PWM, RB3 = 11xx. Quad PWM, RC1 = RB3/INT3. Quad PWM, RE7 = P2A RE7. Quad PWM, RE2 =",
    "TABLE 17-2: PIN CONFIGURATIONS FOR ECCP2\nP2B. Quad PWM, RE1 = P2C. Quad PWM, RE0 = P2D. All devices, CCP2MX = 0 , Microcontroller mode:, CCP2CON Configuration = All devices, CCP2MX = 0 , Microcontroller mode:. All devices, CCP2MX = 0 , Microcontroller mode:, RB3 = All devices, CCP2MX = 0 , Microcontroller mode:. All devices, CCP2MX = 0 , Microcontroller mode:, RC1 = All devices, CCP2MX = 0 , Microcontroller mode:. All devices, CCP2MX = 0 , Microcontroller mode:, RE7 = All devices, CCP2MX = 0 , Microcontroller mode:. All devices, CCP2MX = 0 , Microcontroller mode:, RE2 = All devices, CCP2MX = 0 , Microcontroller mode:. All devices, CCP2MX = 0 , Microcontroller mode:, RE1 = All devices, CCP2MX = 0",
    "TABLE 17-2: PIN CONFIGURATIONS FOR ECCP2\n, Microcontroller mode:. All devices, CCP2MX = 0 , Microcontroller mode:, RE0 = All devices, CCP2MX = 0 , Microcontroller mode:. Compatible CCP, CCP2CON Configuration = 00xx. Compatible CCP, RB3 = 11xx. Compatible CCP, RC1 = RB3/INT3. Compatible CCP, RE7 = RC1/T1OS1 ECCP2. Compatible CCP, RE2 = RE2. Compatible CCP, RE1 = RE1. Compatible CCP, RE0 = RE0. Dual PWM, CCP2CON Configuration = 10xx. Dual PWM, RB3 = 11xx. Dual PWM, RC1 = RB3/INT3. Dual PWM, RE7 = RC1/T1OS1 P2A. Dual PWM, RE2 = P2B. Dual PWM, RE1 = RE1. Dual PWM, RE0 = RE0. Quad PWM, CCP2CON Configuration = x1xx. Quad PWM, RB3 =",
    "TABLE 17-2: PIN CONFIGURATIONS FOR ECCP2\n11xx. Quad PWM, RC1 = RB3/INT3. Quad PWM, RE7 = RC1/T1OS1 P2A. Quad PWM, RE2 = P2B. Quad PWM, RE1 = P2C. Quad PWM, RE0 = P2D. PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:, CCP2CON Configuration = PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:. PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:, RB3 = PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:. PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:, RC1 = PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:. PIC18F8525/8621 devices, CCP2MX = 0 ,",
    "TABLE 17-2: PIN CONFIGURATIONS FOR ECCP2\nall other Program Memory modes:, RE7 = PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:. PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:, RE2 = PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:. PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:, RE1 = PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:. PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:, RE0 = PIC18F8525/8621 devices, CCP2MX = 0 , all other Program Memory modes:. Compatible CCP, CCP2CON Configuration = 00xx. Compatible CCP, RB3 = 11xx. Compatible CCP, RC1 = ECCP2. Compatible CCP, RE7 = RC1/T1OS1 RE7/AD15. Compatible CCP,",
    "TABLE 17-2: PIN CONFIGURATIONS FOR ECCP2\nRE2 = RE2/CS. Compatible CCP, RE1 = RE1/WR. Compatible CCP, RE0 = RE0/RD. Dual PWM, CCP2CON Configuration = 10xx. Dual PWM, RB3 = 11xx. Dual PWM, RC1 = P2A. Dual PWM, RE7 = RC1/T1OS1 RE7/AD15. Dual PWM, RE2 = P2B. Dual PWM, RE1 = RE1/WR. Dual PWM, RE0 = RE0/RD. Quad PWM, CCP2CON Configuration = x1xx. Quad PWM, RB3 = 11xx. Quad PWM, RC1 = P2A. Quad PWM, RE7 = RC1/T1OS1 RE7/AD15. Quad PWM, RE2 = P2B. Quad PWM, RE1 = P2C. Quad PWM, RE0 = P2D",
    "TABLE 17-2: PIN CONFIGURATIONS FOR ECCP2\nLegend: x = Don't care. Shaded cells indicate pin assignments not used by ECCP2 in a given mode.",
    "TABLE 17-3: PIN CONFIGURATIONS FOR ECCP3\nAll PIC18F6525/6621 devices:, CCP3CON Configuration = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RG0 = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RE4 = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RE3 = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RG3 = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RH5 = All PIC18F6525/6621 devices:. All PIC18F6525/6621 devices:, RH4 = All PIC18F6525/6621 devices:. Compatible CCP, CCP3CON Configuration = 00xx 11xx. Compatible CCP, RG0 = ECCP3. Compatible CCP, RE4 = RE4. Compatible CCP, RE3 = RE3. Compatible",
    "TABLE 17-3: PIN CONFIGURATIONS FOR ECCP3\nCCP, RG3 = RG3/CCP4. Compatible CCP, RH5 = N/A. Compatible CCP, RH4 = N/A. Dual PWM, CCP3CON Configuration = 10xx 11xx. Dual PWM, RG0 = P3A. Dual PWM, RE4 = P3B. Dual PWM, RE3 = RE3. Dual PWM, RG3 = RG3/CCP4. Dual PWM, RH5 = N/A. Dual PWM, RH4 = N/A. Quad PWM, CCP3CON Configuration = x1xx 11xx. Quad PWM, RG0 = P3A. Quad PWM, RE4 = P3B. Quad PWM, RE3 = P3C. Quad PWM, RG3 = P3D. Quad PWM, RH5 = N/A. Quad PWM, RH4 = N/A. PIC18F8525/8621 devices, ECCPMX = 1 ,",
    "TABLE 17-3: PIN CONFIGURATIONS FOR ECCP3\nMicrocontroller mode:, CCP3CON Configuration = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:, RG0 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:, RE4 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:, RE3 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:, RG3 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices,",
    "TABLE 17-3: PIN CONFIGURATIONS FOR ECCP3\nECCPMX = 1 , Microcontroller mode:, RH5 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:, RH4 = PIC18F8525/8621 devices, ECCPMX = 1 , Microcontroller mode:. Compatible CCP, CCP3CON Configuration = 00xx 11xx. Compatible CCP, RG0 = ECCP3. Compatible CCP, RE4 = RE4/AD12. Compatible CCP, RE3 = RE3/AD11. Compatible CCP, RG3 = RG3/CCP4. Compatible CCP, RH5 = RH5/AN13. Compatible CCP, RH4 = RH4/AN12. Dual PWM, CCP3CON Configuration = 10xx 11xx. Dual PWM, RG0 = P3A. Dual PWM, RE4 = P3B. Dual PWM, RE3 = RE3/AD11. Dual",
    "TABLE 17-3: PIN CONFIGURATIONS FOR ECCP3\nPWM, RG3 = RG3/CCP4. Dual PWM, RH5 = RH5/AN13. Dual PWM, RH4 = RH4/AN12. Quad PWM, CCP3CON Configuration = x1xx 11xx. Quad PWM, RG0 = P3A. Quad PWM, RE4 = P3B. Quad PWM, RE3 = P3C. Quad PWM, RG3 = P3D. Quad PWM, RH5 = RH5/AN13. Quad PWM, RH4 = RH4/AN12. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, CCP3CON Configuration = PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RG0 = PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller",
    "TABLE 17-3: PIN CONFIGURATIONS FOR ECCP3\nmode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RE4 = PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RE3 = PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RG3 = PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RH5 = PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:. PIC18F8525/8621 devices, ECCPMX = 0 , Microcontroller mode:, RH4 = PIC18F8525/8621 devices, ECCPMX = 0 ,",
    "TABLE 17-3: PIN CONFIGURATIONS FOR ECCP3\nMicrocontroller mode:. Compatible CCP, CCP3CON Configuration = 00xx 11xx. Compatible CCP, RG0 = ECCP3. Compatible CCP, RE4 = RE6/AD14. Compatible CCP, RE3 = RE5/AD13. Compatible CCP, RG3 = RG3/CCP4. Compatible CCP, RH5 = RH7/AN15. Compatible CCP, RH4 = RH6/AN14. Dual PWM, CCP3CON Configuration = 10xx 11xx. Dual PWM, RG0 = P3A. Dual PWM, RE4 = RE6/AD14. Dual PWM, RE3 = RE5/AD13. Dual PWM, RG3 = RG3/CCP4. Dual PWM, RH5 = P3B. Dual PWM, RH4 = RH6/AN14. Quad PWM, CCP3CON Configuration = x1xx 11xx. Quad PWM, RG0 = P3A. Quad PWM,",
    "TABLE 17-3: PIN CONFIGURATIONS FOR ECCP3\nRE4 = RE6/AD14. Quad PWM, RE3 = RE5/AD13. Quad PWM, RG3 = P3D. Quad PWM, RH5 = P3B. Quad PWM, RH4 = P3C. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, CCP3CON Configuration = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RG0 = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RE4 = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RE3 =",
    "TABLE 17-3: PIN CONFIGURATIONS FOR ECCP3\nPIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RG3 = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RH5 = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:, RH4 = PIC18F8525/8621 devices, ECCPMX = 1 , all other Program Memory modes:. Compatible CCP, CCP3CON Configuration = 00xx 11xx. Compatible CCP, RG0 = ECCP3. Compatible CCP, RE4 = RE6/AD14. Compatible CCP, RE3 = RE5/AD13. Compatible CCP, RG3 = RG3/CCP4. Compatible",
    "TABLE 17-3: PIN CONFIGURATIONS FOR ECCP3\nCCP, RH5 = RH7/AN15. Compatible CCP, RH4 = RH6/AN14\nLegend: x = Don't care, N/A = Not available. Shaded cells indicate pin assignments not used by ECCP3 in a given mode.\nNote 1: With ECCP3 in Quad PWM mode, CCP4's output is overridden by P1D; otherwise CCP4 is fully operational.",
    "17.4 Enhanced PWM Mode\nLike the standard CCP modules, the ECCP modules can utilize Timers 1, 2, 3 or 4, depending on the mode selected. Timer1 and Timer3 are available for modules in  Capture  or  Compare  modes,  while  Timer2  and Timer4  are  available  for  modules  in  PWM  mode. Additional  details  on  timer  resources  are  provided  in Section 16.1.1 'CCP Modules and Timer Resources' .",
    "17.2 Capture and Compare Modes\nExcept  for  the  operation  of  the  special  event  trigger discussed below, the Capture and Compare modes of the ECCP module are identical in operation to that of CCP4. These are discussed in detail in Section 16.2 'Capture Mode' and Section 16.3 'Compare Mode' .",
    "17.2.1 SPECIAL EVENT TRIGGER\nIn this mode, an internal hardware trigger is generated in  Compare  mode,  on  a  match  between  the  CCPR register pair and the selected timer. This can be used in turn to initiate an action.\nThe special  event  trigger  output  of  either  ECCP1  or ECCP2  resets  the  TMR1  or  TMR3  register  pair, depending on which timer resource is currently selected. This allows the CCPRx register to effectively be a 16-bit programmable period register for Timer1 or Timer3. In addition, the  ECCP2 special event trigger will also start an A/D conversion if the A/D module is enabled.\nThe triggers are not implemented for ECCP3, CCP4 or CCP5. Selecting the Special Event mode (CCPxM3:CCPxM0 = 1011 ) for these modules has the same effect as selecting the Compare with Software Interrupt mode (CCPxM3:CCPxM0 = 1010 ).",
    "Note:\nThe special event trigger from ECCP2 will not set the Timer1 or Timer3 interrupt flag bits.",
    "17.3 Standard PWM Mode\nWhen configured  in  Single  Output  mode,  the  ECCP module  functions  identically  to  the  standard  CCP module in PWM mode as described in Section 16.4 'PWM Mode' .  This is also sometimes referred to as 'Compatible CCP' mode as in Tables 17-1 through 17-3.\nNote: When setting up single output PWM operations,  users  are  free  to  use  either  of  the processes described in Section 16.4.3 'Setup for PWM Operation' or Section 17.4.9  'Setup  for  PWM  Operation' .  The  latter  is  more  generic  but  will work for either single or multi-output PWM.",
    "17.3 Standard PWM Mode\nThe Enhanced PWM mode provides additional PWM output options for a broader range of control applications. The module is a backward compatible version of the standard CCP module and offers up to four outputs, designated PxA through PxD. Users are also able to select  the  polarity  of  the  signal  (either  active-high  or active-low).  The  module's  output  mode  and  polarity are configured by setting the PxM1:PxM0 and CCPxM3CCPxM0  bits  of the CCPxCON  register (CCPxCON<7:6> and CCPxCON<3:0>, respectively).\nFor the sake of clarity, Enhanced PWM mode operation is  described  generically  throughout  this  section  with respect to ECCP1 and TMR2 modules. Control register names  are  presented  in  terms  of  ECCP1.  All  three Enhanced modules, as well as the two timer resources, can be used interchangeably and function identically. TMR2 or TMR4 can be selected for PWM operation by selecting the proper bits in T3CON.",
    "17.3 Standard PWM Mode\nFigure 17-1 shows a simplified block diagram of PWM operation. All control registers are double-buffered and are loaded at the beginning of a new PWM cycle (the period  boundary  when  Timer2  resets)  in  order  to prevent glitches on any of the outputs. The exception is the PWM Delay register, ECCP1DEL, which is loaded at  either  the  duty  cycle  boundary  or  the  boundary period (whichever comes first). Because of the buffering,  the  module  waits  until  the  assigned  timer  resets instead of starting immediately. This means  that Enhanced PWM waveforms do not exactly match the standard  PWM waveforms, but are instead offset  by one full instruction cycle (4 TOSC).\nAs  before,  the  user  must  manually  configure  the appropriate TRIS bits for output.",
    "17.4.1 PWM PERIOD\nThe  PWM  period  is  specified  by  writing  to  the  PR2 register. The PWM period can be calculated using the equation:",
    "EQUATION 17-1:\nPWM Period   = [(PR2) + 1] \u00b7 4 \u00b7 TOSC \u00b7 (TMR2 Prescale Value)\nPWM frequency is defined as 1/[PWM period]. When TMR2 is equal to PR2, the following three events occur on the next increment cycle:\n\u00b7 TMR2 is cleared\n\u00b7 The ECCP1 pin is set (if PWM duty cycle = 0%, the ECCP1 pin will not be set)\n\u00b7 The PWM duty cycle is copied from CCPR1L into CCPR1H\nNote:\nThe Timer2 postscaler (see Section 13.0 'Timer2  Module' ) is not  used  in  the determination of the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "17.4.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the CCPR1L register and to the CCP1CON<5:4> bits. Up to 10-bit resolution is available. The CCPR1L contains the eight MSbs and the CCP1CON<5:4> contains the two LSbs. This 10-bit value is represented by CCPRxL:CCPxCON<5:4>.  The  PWM  duty  cycle  is calculated by the equation:\nThe  CCPRxH  register  and  a  2-bit  internal  latch  are used  to  double-buffer the PWM  duty  cycle.  This double-buffering is essential for glitchless PWM operation. When the CCPR1H and 2-bit latch match TMR2, concatenated with an internal 2-bit Q clock or two bits of the TMR2 prescaler, the ECCP1 pin is cleared. The maximum  PWM  resolution  (bits)  for  a  given  PWM frequency is given by the equation:",
    "EQUATION 17-2:\nPWM Duty Cycle  = (CCPR1L:CCP1CON<5:4>) \u00b7 TOSC \u00b7 (TMR2 Prescale Value)",
    "EQUATION 17-3:\n<!-- formula-not-decoded -->\nCCPR1L and CCP1CON<5:4> can be written to at any time  but  the  duty  cycle  value  is  not  copied  into CCPR1H until a match between PR2 and TMR2 occurs (i.e., the period is complete). In PWM mode, CCPR1H is a read-only register.\nNote:\nIf the PWM duty cycle value is longer than the PWM period, the ECCP1 pin will not be cleared.\n\nTABLE 17-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz",
    "EQUATION 17-3:\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.77 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.25 kHz = 1. Timer Prescaler (1, 4, 16), 312.50 kHz = 1. Timer Prescaler (1, 4, 16), 416.67 kHz = 1. PR2 Value, 2.44 kHz = FFh. PR2 Value, 9.77 kHz = FFh. PR2 Value, 39.06 kHz = FFh. PR2 Value, 156.25 kHz = 3Fh. PR2 Value, 312.50 kHz = 1Fh. PR2 Value, 416.67 kHz = 17h. Maximum Resolution (bits), 2.44 kHz = 10. Maximum Resolution (bits), 9.77 kHz = 10. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits), 156.25 kHz = 8. Maximum Resolution (bits), 312.50",
    "EQUATION 17-3:\nkHz = 7. Maximum Resolution (bits), 416.67 kHz = 6.58",
    "17.4.3 PWM OUTPUT CONFIGURATIONS\nThe P1M1:P1M0 bits in the CCP1CON register allow one of four configurations:\n- \u00b7 Single Output\nThe Single Output mode is the standard PWM mode discussed in Section 17.4 'Enhanced PWM Mode' . The  Half-Bridge  and  Full-Bridge  Output  modes  are covered in detail in the sections that follow.\n\u00b7 Half-Bridge Output\n\u00b7 Full-Bridge Output, Forward mode\nThe general relationship of the outputs in all configurations is summarized in Figure 17-2.\n- \u00b7 Full-Bridge Output, Reverse mode",
    "FIGURE 17-2: PWM OUTPUT RELATIONSHIPS (ACTIVE-HIGH STATE)\n00, 0.CCP1CON <7:6> = (Single Output). 00, 0.SIGNAL = P1A Modulated. 00, PR2 + 1 Duty.Cycle = Delay. 00, PR2 + 1 Duty. = Delay. 00, PR2 + 1 Duty. = . 00,  = . 10, 0.CCP1CON <7:6> = (Half-Bridge). 10, 0.SIGNAL = P1A Modulated P1B Modulated. 10, PR2 + 1 Duty.Cycle = . 10, PR2 + 1 Duty. = . 10, PR2 + 1 Duty. = . 10,  = . 01, 0.CCP1CON <7:6> = (Full-Bridge, Forward). 01, 0.SIGNAL = . 01, PR2 + 1 Duty.Cycle = . 01, PR2 + 1 Duty. = . 01, PR2 + 1 Duty. = . 01,",
    "FIGURE 17-2: PWM OUTPUT RELATIONSHIPS (ACTIVE-HIGH STATE)\n= . , 0.CCP1CON <7:6> = . , 0.SIGNAL = P1A Active P1B Inactive. , PR2 + 1 Duty.Cycle = . , PR2 + 1 Duty. = . , PR2 + 1 Duty. = . ,  = . , 0.CCP1CON <7:6> = . , 0.SIGNAL = P1C Inactive. , PR2 + 1 Duty.Cycle = . , PR2 + 1 Duty. = . , PR2 + 1 Duty. = . ,  = . 11, 0.CCP1CON <7:6> = . 11, 0.SIGNAL = P1D Modulated. 11, PR2 + 1 Duty.Cycle = . 11, PR2 + 1 Duty. = . 11, PR2 + 1 Duty. = . 11,",
    "FIGURE 17-2: PWM OUTPUT RELATIONSHIPS (ACTIVE-HIGH STATE)\n= . , 0.CCP1CON <7:6> = (Full-Bridge, Reverse). , 0.SIGNAL = P1A Inactive P1B Modulated P1C Active. , PR2 + 1 Duty.Cycle = . , PR2 + 1 Duty. = . , PR2 + 1 Duty. = . ,  = ",
    "Relationships:\n\u00b7 Period = 4 * TOSC * (PR2 + 1) * (TMR2 Prescale Value)\n\u00b7 Duty Cycle = TOSC * (CCPR1L<7:0>:CCP1CON<5:4>) * (TMR2 Prescale Value)\n\u00b7 Delay = 4 * TOSC * (ECCP1DEL<6:0>)\nNote 1: Dead-band delay is programmed using the ECCP1DEL register ( Section 17.4.6 'Programmable Dead-Band Delay' ).",
    "17.4.4 HALF-BRIDGE MODE\nIn the Half-Bridge Output mode, two pins are used as outputs to drive push-pull loads. The PWM output signal is output on the P1A pin, while the complementary PWM  output signal is output on the P1B pin (Figure 17-4). This mode can be used for half-bridge applications, as shown in Figure 17-5, or for full-bridge applications,  where  four  power  switches  are  being modulated with two PWM signals.",
    "FIGURE 17-4: HALF-BRIDGE PWM OUTPUT\nIn Half-Bridge Output mode, the programmable dead-band delay can be used to prevent shoot-through current in half-bridge power devices. The value of bits PDC6:PDC0  sets  the  number  of  instruction  cycles before the output is driven active. If the value is greater than the duty cycle, the corresponding output remains inactive  during  the  entire  cycle.  See Section 17.4.6 'Programmable Dead-Band Delay' for more details on dead-band delay operations.\nSince the P1A and P1B outputs are multiplexed with the  PORTC<2>  and  PORTE<6>  data  latches,  the TRISC<2>  and  TRISE<6>  bits  must  be  cleared  to configure P1A and P1B as outputs.\nNote 1: At this time, the TMR2 register is equal to the PR2 register.\n- 2: Output signals are shown as active-high.",
    "17.4.5 FULL-BRIDGE MODE\nIn  Full-Bridge  Output  mode,  four  pins  are  used  as outputs; however, only two outputs are active at a time. In  the  Forward mode, pin P1A is continuously active and pin P1D is modulated. In the Reverse mode, pin P1C is continuously active and pin P1B is modulated. These are illustrated in Figure 17-6.\nP1A, P1B, P1C and P1D outputs are multiplexed with the  PORTC<2>,  PORTE<6:5>  and  PORTG<4>  data latches. The TRISC<2>, TRISC<6:5> and TRISG<4> bits must be cleared to make the P1A, P1B, P1C and P1D pins outputs.\nFIGURE 17-6: FULL-BRIDGE PWM OUTPUT",
    "17.4.5 FULL-BRIDGE MODE\n, Forward Mode = . , Forward Mode = Period. , Forward Mode = . , Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . , Forward Mode = Duty Cycle. , Forward Mode = . , Forward Mode = . , Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . P1D (2), Forward Mode = . P1D (2), Forward Mode = . P1D (2), Forward Mode = . P1D (2), Forward Mode = . , Forward Mode = (1). , Forward Mode = . , Forward Mode = (1). , Forward Mode = . Reverse",
    "17.4.5 FULL-BRIDGE MODE\nMode, Forward Mode = Reverse Mode. Reverse Mode, Forward Mode = Reverse Mode. Reverse Mode, Forward Mode = Reverse Mode. Reverse Mode, Forward Mode = Reverse Mode. , Forward Mode = . , Forward Mode = Period. , Forward Mode = . , Forward Mode = . , Forward Mode = Duty Cycle. , Forward Mode = . , Forward Mode = . , Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . P1A (2), Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1B (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . P1C (2), Forward Mode = . P1D (2), Forward Mode = . P1D (2), Forward Mode = . P1D (2), Forward Mode = . P1D",
    "17.4.5 FULL-BRIDGE MODE\n(2), Forward Mode = . , Forward Mode = (1). , Forward Mode = . , Forward Mode = . , Forward Mode = . , Forward Mode = . , Forward Mode = . , Forward Mode = (1). , Forward Mode = . Note 1: At this time, the TMR2 register is equal to the PR2 register., Forward Mode = Note 1: At this time, the TMR2 register is equal to the PR2 register.. Note 1: At this time, the TMR2 register is equal to the PR2 register., Forward Mode = Note 1: At this time, the TMR2 register is equal to the PR2 register.. Note 1: At this time, the TMR2 register is equal to the PR2 register., Forward Mode = Note 1: At this time, the TMR2 register is equal to the PR2 register.. Note 1: At this time, the TMR2 register is equal to the PR2 register., Forward Mode = Note 1: At this time, the TMR2 register is equal to the PR2 register.. Note 2: Output signal",
    "17.4.5 FULL-BRIDGE MODE\nis shown as active-high., Forward Mode = Note 2: Output signal is shown as active-high.. Note 2: Output signal is shown as active-high., Forward Mode = Note 2: Output signal is shown as active-high.. Note 2: Output signal is shown as active-high., Forward Mode = Note 2: Output signal is shown as active-high.. Note 2: Output signal is shown as active-high., Forward Mode = Note 2: Output signal is shown as active-high.",
    "17.4.5.1 Direction Change in Full-Bridge Mode\nIn  the  Full-Bridge  Output  mode,  the  P1M1  bit  in  the CCP1CON register allows users to control the forward/ reverse direction. When  the application firmware changes  this  direction  control  bit,  the  module  will assume the new direction on the next PWM cycle.\nJust  before  the  end  of  the  current  PWM  period,  the modulated outputs (P1B and P1D) are placed in their inactive state, while the unmodulated outputs (P1A and P1C) are switched to drive in the opposite direction. This  occurs  in  a  time  interval  of  (4  TOSC  *  (Timer2 Prescale Value) before the next PWM period begins. The Timer2 prescaler will be either 1, 4 or 16, depending  on  the  value  of  the  T2CKPS  bit  (T2CON<1:0>). During the interval from the switch of the unmodulated outputs  to the beginning  of  the  next  period,  the modulated  outputs  (P1B  and  P1D)  remain  inactive. This relationship is shown in Figure 17-8.",
    "17.4.5.1 Direction Change in Full-Bridge Mode\nNote that in the Full-Bridge Output mode, the ECCP1 module does not provide any dead-band delay. In general,  since only one output is modulated at all times, dead-band delay is not required. However, there is a situation where a dead-band delay might be required. This situation occurs  when  both  of  the  following conditions are true:\n1. The direction of the PWM output changes when the duty cycle of the output is at or near 100%.\n2. The turn-off time of the power switch, including the  power  device  and  driver  circuit,  is  greater than the turn-on time.",
    "17.4.5.1 Direction Change in Full-Bridge Mode\nFigure 17-9 shows  an  example  where  the PWM direction  changes  from  forward  to  reverse  at  a  near 100% duty cycle. At time t1, the output P1A and P1D become inactive, while output P1C becomes active. In this  example,  since  the  turn-off  time  of  the  power devices is longer than the turn-on time, a shoot-through current may flow through power devices QC and QD (see  Figure 17-7)  for  the  duration  of  't'.  The  same phenomenon will occur to power devices QA and QB for PWM direction change from reverse to forward.\nIf changing PWM direction at high duty cycle is required for  an  application,  one  of  the  following  requirements must be met:\n1. Reduce PWM  for a PWM  period before changing directions.\n2. Use switch drivers that can drive the switches off faster than they can drive them on.\nOther  options  to  prevent  shoot-through  current  may exist.",
    "17.4.6 PROGRAMMABLE DEAD-BAND DELAY\nIn half-bridge applications where all power switches are modulated  at  the  PWM  frequency  at  all  times,  the power switches normally require more time to turn off than  to  turn  on.  If  both  the  upper  and  lower  power switches are switched at the same time (one turned on and the other turned off), both switches may be on for a short period of time until one switch completely turns off. During  this  brief  interval,  a  very  high  current ( shoot-through current )  may flow through both power switches,  shorting  the  bridge  supply.  To  avoid  this potentially destructive shoot-through current from flowing  during  switching,  turning  on  either  of  the  power switches is normally delayed to allow the other switch to completely turn off.",
    "17.4.6 PROGRAMMABLE DEAD-BAND DELAY\nA shutdown event can be caused by either of the two comparator modules or the INT0/FLT0 pin (or any combination of these three sources). The comparators may be used to monitor a voltage input proportional to a current being monitored in the bridge circuit. If the voltage exceeds a threshold, the comparator switches state and triggers a shutdown. Alternatively, a digital signal on the INT0/FLT0  pin can also trigger a shutdown.  The auto-shutdown feature can be disabled by not selecting any auto-shutdown sources. The auto-shutdown sources to be used are selected using the ECCP1AS2:ECCP1AS0 bits (bits<6:4> of the ECCP1AS register).",
    "17.4.6 PROGRAMMABLE DEAD-BAND DELAY\nIn  the  Half-Bridge  Output  mode,  a  digitally  programmable dead-band delay is available to avoid shoot-through current from destroying the bridge power  switches. The  delay occurs at the signal transition from the non-active state to the active state. See Figure 17-4 for illustration. The lower seven bits of the ECCPxDEL register (Register 17-2) set the delay period  in  terms  of  microcontroller  instruction  cycles (TCY or 4 TOSC).",
    "17.4.7 ENHANCED PWM AUTO-SHUTDOWN\nWhen  a  shutdown  occurs,  the output pin(s) are asynchronously placed in their shutdown states, specified by the PSS1AC1:PSS1AC0 and PSS1BD1:PSS1BD0  bits  (ECCP1AS3:ECCP1AS0). Each pin pair (P1A/P1C and P1B/P1D) may be set to drive high, drive low or be tri-stated (not driving). The ECCP1ASE bit (ECCP1AS<7>) is also set to hold the Enhanced PWM outputs in their shutdown states.\nThe  ECCP1ASE  bit  is  set  by  hardware  when  a shutdown event occurs. If  automatic restarts  are  not enabled, the ECCPASE bit is cleared by firmware when the cause of the shutdown clears. If automatic restarts are enabled, the ECCPASE bit is automatically cleared when the cause of the Auto-Shutdown has cleared.",
    "17.4.7 ENHANCED PWM AUTO-SHUTDOWN\nWhen an ECCP module is programmed for any PWM mode, the active output pin(s) may be configured for auto-shutdown. Auto-shutdown immediately places the PWM output pin(s) into a defined shutdown state when a shutdown event occurs.\nIf the ECCPASE bit is set when a PWM period begins, the PWM outputs remain in their shutdown state for that entire PWM period. When the ECCPASE bit is cleared, the PWM outputs will return to normal operation at the beginning of the next PWM period.\nNote:\nWriting  to  the  ECCPASE  bit  is  disabled while a shutdown condition is active.",
    "REGISTER 17-2: ECCPxDEL: PWM CONFIGURATION REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PxRSEN, 1 = PxDC6. PxRSEN, 2 = PxDC5. PxRSEN, 3 = PxDC4. PxRSEN, 4 = PxDC3. PxRSEN, 5 = PxDC2. PxRSEN, 6 = PxDC1. PxRSEN, 7 = PxDC0\nbit 7\nbit 0\nPxRSEN: PWM Restart Enable bit",
    "REGISTER 17-2: ECCPxDEL: PWM CONFIGURATION REGISTER\n1 = Upon Auto-Shutdown, the ECCPxASE bit clears automatically once the shutdown event goes away; the PWM restarts automatically\n0 = Upon Auto-Shutdown, ECCPxASE must be cleared in software to restart the PWM\nPxDC6:PxDC0: PWM Delay Count bits\nDelay time, in number of FOSC/4 (4 * TOSC) cycles, between the scheduled and actual time for a PWM signal to transition to active.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 17-3: CONTROL REGISTER\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nECCPxASE ECCPxAS2 ECCPxAS1 ECCPxAS0\nPSSxAC1\nPSSxAC0\nPSSxBD1\nPSSxBD0\nbit 7\nbit 0\nbit 7\nECCPxASE: ECCP Auto-Shutdown Event Status bit\n0 = ECCP outputs are operating\n1 = A shutdown event has occurred; ECCP outputs are in shutdown state\nbit 6-4\nECCPxAS2:ECCPxAS0:\nECCP Auto-Shutdown Source Select bits\n000 = Auto-shutdown is disabled\n001 = Comparator 1 output\n010 = Comparator 2 output\n011 = Either Comparator 1 or 2\n100 = INT0/FLT0\n101 = INT0/FLT0 or Comparator 1\n110 = INT0/FLT0 or Comparator 2\n111 = INT0/FLT0 or Comparator 1 or Comparator 2",
    "REGISTER 17-3: CONTROL REGISTER\nbit 3-2 PSSxAC1:PSSxAC0: Pins A and C Shutdown State Control bits\n00 = Drive Pins A and C to ' 0 '\n01 = Drive Pins A and C to ' 1 '\n1x = Pins A and C tri-state\nbit 1-0\nPSSxBD1:PSSxBD0:\nPins B and D Shutdown State Control bits\n00 = Drive Pins B and D to ' 0 '\n01 = Drive Pins B and D to ' 1 '\n1x = Pins B and D tri-state",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "17.4.8 START-UP CONSIDERATIONS\nThe auto-shutdown feature can be configured to allow automatic restarts of the module following a shutdown event. This is enabled by setting the P1RSEN bit of the ECCP1DEL register (ECCP1DEL<7>).\nIn Shutdown mode with PRSEN = 1 (Figure 17-10), the ECCPASE bit will remain set for as long as the cause of the shutdown continues. When the shutdown condition clears, the ECCP1ASE bit is cleared. If PRSEN = 0 (Figure 17-11), once a shutdown condition occurs, the ECCP1ASE  bit  will  remain  set  until  it  is  cleared  by firmware. Once ECCP1ASE is cleared, the Enhanced PWM will resume at the beginning of the next PWM period.\nNote:\nWriting  to  the  ECCPASE  bit  is  disabled while a shutdown condition is active.\nIndependent of the P1RSEN  bit setting, if the auto-shutdown source is one of the comparators, the shutdown condition is a level. The ECCP1ASE bit cannot be cleared as long as the cause of the shutdown persists.",
    "17.4.8 START-UP CONSIDERATIONS\nWhen the ECCP module is used in the PWM mode, the application  hardware  must  use  the  proper  external pull-up and/or pull-down resistors on the PWM output pins. When the microcontroller is released from Reset, all of the I/O pins are in the high-impedance state. The external circuits must keep the power switch devices in the off state until the microcontroller drives the I/O pins with  the  proper  signal  levels,  or  activates  the  PWM output(s).\nThe  CCP1M1:CCP1M0  bits  (CCP1CON<1:0>)  allow the user to choose whether the PWM output signals are active-high or active-low for each pair of PWM output pins (P1A/P1C  and  P1B/P1D).  The  PWM  output polarities must be selected before the PWM pins are configured as outputs. Changing the polarity configuration while the PWM pins are configured as outputs is not recommended since it may result in damage to the application circuits.",
    "17.4.8 START-UP CONSIDERATIONS\nThe Auto-Shutdown mode can be forced by writing a ' 1 ' to the ECCPASE bit.\nThe P1A, P1B, P1C and P1D output latches may not be in the proper states when the PWM module is initialized. Enabling the PWM pins for output at the same time as the ECCP module may cause damage to the application circuit. The ECCP module must be enabled in the proper  output  mode  and  complete  a  full  PWM  cycle before configuring the PWM pins as outputs. The completion of a full PWM cycle is indicated by the TMR2IF bit being set as the second PWM period begins.",
    "FIGURE 17-10: PWM AUTO-SHUTDOWN (PRSEN =  , AUTO-RESTART ENABLED) 1\nFIGURE 17-11: PWM AUTO-SHUTDOWN (PRSEN =  , AUTO-RESTART DISABLED) 0",
    "17.4.9 SETUP FOR PWM OPERATION\nThe following steps should be taken when configuring the ECCP1 module for PWM operation using Timer2:",
    "17.4.9 SETUP FOR PWM OPERATION\n1. Configure  the  PWM  pins,  P1A  and  P1B  (and P1C and P1D, if used), as inputs by setting the corresponding TRIS bits.\n2. Set the PWM period by loading the PR2 register.\n3. If auto-shutdown is required do the following:\n\u00b7 Disable auto-shutdown (ECCP1AS = 0 )\n\u00b7 Configure source (FLT0, Comparator 1 or Comparator 2)\n\u00b7 Wait for non-shutdown condition\n4. Configure  the  ECCP1  module  for  the  desired PWM  mode  and  configuration  by  loading  the CCP1CON register with the appropriate values:\n\u00b7 Select one of the available output configurations and direction with the P1M1:P1M0 bits.\n\u00b7 Select the polarities of the PWM output signals with the CCP1M3:CCP1M0 bits.\n5. Set the PWM duty cycle by loading the CCPR1L register and CCP1CON<5:4> bits.",
    "17.4.9 SETUP FOR PWM OPERATION\n6. For Half-Bridge Output mode, set the dead-band delay  by  loading  ECCP1DEL<6:0> with the appropriate value.\n7. If auto-shutdown operation is required, load the ECCP1AS register:\n\u00b7 Select the auto-shutdown sources using the ECCP1AS2:ECCP1AS0 bits.\n\u00b7 Select the shutdown states of the PWM output pins using the PSS1AC1:PSS1AC0 and PSS1BD1:PSS1BD0 bits.\n\u00b7 Set the ECCP1ASE bit (ECCP1AS<7>).\n\u00b7 Configure the comparators using the CMCON register.\n\u00b7 Configure the comparator inputs as analog inputs.\n8. If auto-restart  operation  is  required,  set  the P1RSEN bit (ECCP1DEL<7>).\n9. Configure and start TMR2:\n\u00b7 Clear the TMR2 interrupt flag bit by clearing the TMR2IF bit (PIR1<1>).",
    "17.4.9 SETUP FOR PWM OPERATION\n\u00b7 Set the TMR2 prescale value by loading the T2CKPS bits (T2CON<1:0>).\n\u00b7 Enable Timer2 by setting the TMR2ON bit (T2CON<2>).\n10. Enable  PWM  outputs  after  a  new  PWM  cycle has started:\n\u00b7 Wait until TMRn overflows (TMRnIF bit is set).\n\u00b7 Enable the ECCP1/P1A, P1B, P1C and/or P1D pin outputs by clearing the respective TRIS bits.\n\u00b7 Clear the ECCP1ASE bit (ECCP1AS<7>).",
    "17.4.10 EFFECTS OF A RESET\nBoth Power-on Reset and subsequent Resets will force all ports to Input mode and the CCP registers to their Reset states.\nThis forces the Enhanced CCP module to reset to a state compatible with the standard CCP module.",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0--1. RCON, Value on POR, BOR = 11qq. RCON, Value on all",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nother Resets = 0--q. RCON, Value on all other Resets = qquu. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\n1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. PIR2, Bit 7 = -. PIR2, Bit 6 =",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nCMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = -0-0. PIR2, Value on POR, BOR = 0000. PIR2, Value on all other Resets = ---0. PIR2, Value on all other Resets = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = -0-0. PIE2, Value on POR, BOR = 0000. PIE2, Value on all",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nother Resets = ---0. PIE2, Value on all other Resets = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = -1-1. IPR2, Value on POR, BOR = 1111. IPR2, Value on all other Resets = ---1. IPR2, Value on all other Resets = 1111. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = TMR4IF. PIR3, Bit 2 = CCP5IF. PIR3, Bit 1 =",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nCCP4IF. PIR3, Bit 0 = CCP3IF. PIR3, Value on POR, BOR = --00. PIR3, Value on POR, BOR = 0000. PIR3, Value on all other Resets = --00. PIR3, Value on all other Resets = 0000. PIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 = TMR4IE. PIE3, Bit 2 = CCP5IE. PIE3, Bit 1 = CCP4IE. PIE3, Bit 0 = CCP3IE. PIE3, Value on POR, BOR = --00. PIE3, Value on POR, BOR = 0000. PIE3, Value on all other Resets = --00. PIE3, Value on all other Resets = 0000. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = RC2IP.",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nIPR3, Bit 4 = TX2IP. IPR3, Bit 3 = TMR4IP. IPR3, Bit 2 = CCP5IP. IPR3, Bit 1 = CCP4IP. IPR3, Bit 0 = CCP3IP. IPR3, Value on POR, BOR = --11. IPR3, Value on POR, BOR = 1111. IPR3, Value on all other Resets = --11. IPR3, Value on all other Resets = 1111. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111. TRISB, Value on POR, BOR =",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\n1111. TRISB, Value on all other Resets = 1111. TRISB, Value on all other Resets = 1111. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other Resets = 1111. TRISC, Value on all other Resets = 1111. TRISCD, Bit 7 = PORTD Data Direction Register. TRISCD, Bit 6 = PORTD Data Direction Register. TRISCD, Bit 5 = PORTD Data Direction Register. TRISCD, Bit 4 = PORTD Data Direction Register. TRISCD, Bit 3 = PORTD Data",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nDirection Register. TRISCD, Bit 2 = PORTD Data Direction Register. TRISCD, Bit 1 = PORTD Data Direction Register. TRISCD, Bit 0 = PORTD Data Direction Register. TRISCD, Value on POR, BOR = 1111. TRISCD, Value on POR, BOR = 1111. TRISCD, Value on all other Resets = 1111. TRISCD, Value on all other Resets = 1111. TRISE, Bit 7 = PORTE Data Direction Register. TRISE, Bit 6 = PORTE Data Direction Register. TRISE, Bit 5 = PORTE Data Direction Register. TRISE, Bit 4 = PORTE Data Direction Register. TRISE, Bit 3 = PORTE Data Direction Register. TRISE, Bit 2 = PORTE Data Direction Register. TRISE, Bit 1 = PORTE Data Direction Register. TRISE, Bit 0 = PORTE Data Direction Register. TRISE, Value on POR, BOR = 1111. TRISE, Value on POR, BOR = 1111. TRISE, Value on all other Resets = 1111. TRISE, Value on all other Resets = 1111.",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nTRISF, Bit 7 = PORTF Data Direction Register. TRISF, Bit 6 = PORTF Data Direction Register. TRISF, Bit 5 = PORTF Data Direction Register. TRISF, Bit 4 = PORTF Data Direction Register. TRISF, Bit 3 = PORTF Data Direction Register. TRISF, Bit 2 = PORTF Data Direction Register. TRISF, Bit 1 = PORTF Data Direction Register. TRISF, Bit 0 = PORTF Data Direction Register. TRISF, Value on POR, BOR = 1111. TRISF, Value on POR, BOR = 1111. TRISF, Value on all other Resets = 1111. TRISF, Value on all other Resets = 1111. TRISG, Bit 7 = -. TRISG, Bit 6 = -. TRISG, Bit 5 = -. TRISG, Bit 4 = PORTG Data Direction Register. TRISG, Bit 3 = PORTG Data Direction Register. TRISG, Bit 2 = PORTG Data Direction Register. TRISG, Bit 1 = PORTG Data Direction Register. TRISG, Bit 0 = PORTG Data Direction Register. TRISG, Value on POR,",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nBOR = ---1. TRISG, Value on POR, BOR = 1111. TRISG, Value on all other Resets = ---1. TRISG, Value on all other Resets = 1111. TRISH, Bit 7 = PORTH Data Direction Register. TRISH, Bit 6 = PORTH Data Direction Register. TRISH, Bit 5 = PORTH Data Direction Register. TRISH, Bit 4 = PORTH Data Direction Register. TRISH, Bit 3 = PORTH Data Direction Register. TRISH, Bit 2 = PORTH Data Direction Register. TRISH, Bit 1 = PORTH Data Direction Register. TRISH, Bit 0 = PORTH Data Direction Register. TRISH, Value on POR, BOR = 1111. TRISH, Value on POR, BOR = 1111. TRISH, Value on all other Resets = 1111. TRISH, Value on all other Resets = 1111. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nLow Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on all other Resets = uuuu. TMR1L, Value on all other Resets = uuuu. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte.",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nTMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on all other Resets = uuuu. TMR1H, Value on all other Resets = uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00. T1CON, Value on POR, BOR = 0000. T1CON, Value on all other Resets = u-uu.",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nT1CON, Value on all other Resets = uuuu. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Value on all other Resets = 0000. TMR2, Value on all other Resets = 0000. T2CON, Bit 7 = -. T2CON, Bit 6 = T2OUTPS3 T2OUTPS2 T2OUTPS1 T2OUTPS0 TMR2ON T2CKPS1 T2CKPS0. T2CON, Bit 5 = T2OUTPS3",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nT2OUTPS2 T2OUTPS1 T2OUTPS0 TMR2ON T2CKPS1 T2CKPS0. T2CON, Bit 4 = T2OUTPS3 T2OUTPS2 T2OUTPS1 T2OUTPS0 TMR2ON T2CKPS1 T2CKPS0. T2CON, Bit 3 = T2OUTPS3 T2OUTPS2 T2OUTPS1 T2OUTPS0 TMR2ON T2CKPS1 T2CKPS0. T2CON, Bit 2 = T2OUTPS3 T2OUTPS2 T2OUTPS1 T2OUTPS0 TMR2ON T2CKPS1 T2CKPS0. T2CON, Bit 1 = T2OUTPS3 T2OUTPS2 T2OUTPS1 T2OUTPS0 TMR2ON T2CKPS1 T2CKPS0. T2CON, Bit 0 = T2OUTPS3 T2OUTPS2 T2OUTPS1 T2OUTPS0 TMR2ON",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nT2CKPS1 T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Value on all other Resets = -000. T2CON, Value on all other Resets = 0000. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. PR2, Value on all other Resets = 1111. PR2, Value on all other Resets = 1111. TMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte.",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nTMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = Timer3 Register Low Byte. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on POR, BOR = . TMR3L, Value on all other Resets = uuuu. TMR3L, Value on all other Resets = uuuu. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\n= Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = Timer3 Register High Byte. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on POR, BOR = xxxx xxxx. TMR3H, Value on all other Resets = uuuu. TMR3H, Value on all other Resets = uuuu. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000. T3CON, Value on POR, BOR = 0000. T3CON,",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nValue on all other Resets = uuuu. T3CON, Value on all other Resets = uuuu. TMR4, Bit 7 = Timer4 Register. TMR4, Bit 6 = Timer4 Register. TMR4, Bit 5 = Timer4 Register. TMR4, Bit 4 = Timer4 Register. TMR4, Bit 3 = Timer4 Register. TMR4, Bit 2 = Timer4 Register. TMR4, Bit 1 = Timer4 Register. TMR4, Bit 0 = Timer4 Register. TMR4, Value on POR, BOR = 0000. TMR4, Value on POR, BOR = 0000. TMR4, Value on all other Resets = 0000. TMR4, Value on all other Resets = 0000. T4CON, Bit 7 = -. T4CON, Bit 6 = T4OUTPS3. T4CON, Bit 5 = T4OUTPS2. T4CON, Bit 4 = T4OUTPS1. T4CON, Bit 3 =",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nT4OUTPS0. T4CON, Bit 2 = TMR4ON. T4CON, Bit 1 = T4CKPS1. T4CON, Bit 0 = T4CKPS0. T4CON, Value on POR, BOR = -000. T4CON, Value on POR, BOR = 0000. T4CON, Value on all other Resets = -000. T4CON, Value on all other Resets = 0000. PR4, Bit 7 = Timer4 Period Register. PR4, Bit 6 = Timer4 Period Register. PR4, Bit 5 = Timer4 Period Register. PR4, Bit 4 = Timer4 Period Register. PR4, Bit 3 = Timer4 Period Register. PR4, Bit 2 = Timer4 Period Register. PR4, Bit 1 = Timer4 Period Register. PR4, Bit 0 = Timer4 Period Register. PR4, Value on POR, BOR = 1111. PR4, Value on POR, BOR = 1111. PR4, Value on all other Resets = 1111. PR4, Value on all other Resets =",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\n1111. CCPR1L, Bit 7 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other Resets = uuuu. CCPR1L, Value on all other Resets = uuuu.",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nCCPR1H, Bit 7 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Value on POR, BOR = . CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other Resets = uuuu. CCPR1H, Value on all other Resets = uuuu. , Bit 7 = . , Bit 6 =",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\n. , Bit 5 = . , Bit 4 = . , Bit 3 = . , Bit 2 = . , Bit 1 = . , Bit 0 = . , Value on POR, BOR = xxxx. , Value on POR, BOR = . , Value on all other Resets = . , Value on all other Resets = . CCP1CON, Bit 7 = P1M1. CCP1CON, Bit 6 = P1M0. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on all other Resets = 0000. CCP1CON, Value on all other Resets = 0000.",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nECCP1AS, Bit 7 = ECCP1ASE. ECCP1AS, Bit 6 = ECCP1AS2. ECCP1AS, Bit 5 = ECCP1AS1. ECCP1AS, Bit 4 = ECCP1AS0. ECCP1AS, Bit 3 = PSS1AC1. ECCP1AS, Bit 2 = PSS1AC0. ECCP1AS, Bit 1 = PSS1BD1. ECCP1AS, Bit 0 = PSS1BD0. ECCP1AS, Value on POR, BOR = 0000. ECCP1AS, Value on POR, BOR = 0000. ECCP1AS, Value on all other Resets = 0000. ECCP1AS, Value on all other Resets = 0000. ECCP1DEL, Bit 7 = P1RSEN. ECCP1DEL, Bit 6 = P1DC6. ECCP1DEL, Bit 5 = P1DC5. ECCP1DEL, Bit 4 = P1DC4. ECCP1DEL, Bit 3 = P1DC3.",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nECCP1DEL, Bit 2 = P1DC2. ECCP1DEL, Bit 1 = P1DC1. ECCP1DEL, Bit 0 = P1DC0. ECCP1DEL, Value on POR, BOR = 0000. ECCP1DEL, Value on POR, BOR = 0000. ECCP1DEL, Value on all other Resets = uuuu. ECCP1DEL, Value on all other Resets = uuuu. CCPR2L, Bit 7 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 6 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 5 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 4 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 3 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 2 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 1 = Enhanced",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nCapture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 0 = Enhanced Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on all other Resets = uuuu. CCPR2L, Value on all other Resets = uuuu. CCPR2H, Bit 7 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 6 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 5 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 4 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 3 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 2 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 1 = Enhanced Capture/Compare/PWM",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nRegister 2 High Byte. CCPR2H, Bit 0 = Enhanced Capture/Compare/PWM Register 2 High Byte. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on all other Resets = uuuu. CCPR2H, Value on all other Resets = uuuu. CCP2CON, Bit 7 = P2M1. CCP2CON, Bit 6 = P2M0. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Value on POR, BOR = 0000. CCP2CON, Value on POR, BOR = 0000. CCP2CON, Value on all other Resets",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\n= 0000. CCP2CON, Value on all other Resets = 0000. ECCP2AS, Bit 7 = ECCP2ASE. ECCP2AS, Bit 6 = ECCP2AS2. ECCP2AS, Bit 5 = ECCP2AS1. ECCP2AS, Bit 4 = ECCP2AS0. ECCP2AS, Bit 3 = PSS2AC1. ECCP2AS, Bit 2 = PSS2AC0. ECCP2AS, Bit 1 = PSS2BD1. ECCP2AS, Bit 0 = PSS2BD0. ECCP2AS, Value on POR, BOR = 0000. ECCP2AS, Value on POR, BOR = 0000. ECCP2AS, Value on all other Resets = 0000. ECCP2AS, Value on all other Resets = 0000. ECCP2DEL, Bit 7 = P2RSEN. ECCP2DEL, Bit 6 = P2DC6. ECCP2DEL, Bit 5 = P2DC5. ECCP2DEL, Bit 4 =",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nP2DC4. ECCP2DEL, Bit 3 = P2DC3. ECCP2DEL, Bit 2 = P2DC2. ECCP2DEL, Bit 1 = P2DC1. ECCP2DEL, Bit 0 = P2DC0. ECCP2DEL, Value on POR, BOR = 0000. ECCP2DEL, Value on POR, BOR = 0000. ECCP2DEL, Value on all other Resets = uuuu. ECCP2DEL, Value on all other Resets = uuuu. CCPR3L, Bit 7 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 6 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 5 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 4 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 3 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 2 = Enhanced",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nCapture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 1 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Bit 0 = Enhanced Capture/Compare/PWM Register 3 Low Byte. CCPR3L, Value on POR, BOR = xxxx. CCPR3L, Value on POR, BOR = xxxx. CCPR3L, Value on all other Resets = uuuu. CCPR3L, Value on all other Resets = uuuu. CCPR3H, Bit 7 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 6 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 5 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 4 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 3 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 2 = Enhanced Capture/Compare/PWM",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nRegister 3 High Byte. CCPR3H, Bit 1 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Bit 0 = Enhanced Capture/Compare/PWM Register 3 High Byte. CCPR3H, Value on POR, BOR = xxxx. CCPR3H, Value on POR, BOR = xxxx. CCPR3H, Value on all other Resets = uuuu. CCPR3H, Value on all other Resets = uuuu. CCP3CON, Bit 7 = P3M1. CCP3CON, Bit 6 = P3M0. CCP3CON, Bit 5 = DC3B1. CCP3CON, Bit 4 = DC3B0. CCP3CON, Bit 3 = CCP3M3. CCP3CON, Bit 2 = CCP3M2. CCP3CON, Bit 1 = CCP3M1. CCP3CON, Bit 0 = CCP3M0. CCP3CON, Value on POR, BOR = 0000. CCP3CON,",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nValue on POR, BOR = 0000. CCP3CON, Value on all other Resets = 0000. CCP3CON, Value on all other Resets = 0000. ECCP3AS, Bit 7 = ECCP3ASE. ECCP3AS, Bit 6 = ECCP3AS2. ECCP3AS, Bit 5 = ECCP3AS1. ECCP3AS, Bit 4 = ECCP3AS0. ECCP3AS, Bit 3 = PSS3AC1. ECCP3AS, Bit 2 = PSS3AC0. ECCP3AS, Bit 1 = PSS3BD1. ECCP3AS, Bit 0 = PSS3BD0. ECCP3AS, Value on POR, BOR = 0000. ECCP3AS, Value on POR, BOR = 0000. ECCP3AS, Value on all other Resets = 0000. ECCP3AS, Value on all other Resets = 0000. ECCP3DEL, Bit 7 = Px3RSEN. ECCP3DEL, Bit 6 =",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ECCP MODULES AND TIMER1 TO TIMER4\nP3DC6. ECCP3DEL, Bit 5 = P3DC5. ECCP3DEL, Bit 4 = P3DC4. ECCP3DEL, Bit 3 = P3DC3. ECCP3DEL, Bit 2 = P3DC2. ECCP3DEL, Bit 1 = P3DC1. ECCP3DEL, Bit 0 = P3DC0. ECCP3DEL, Value on POR, BOR = 0000. ECCP3DEL, Value on POR, BOR = 0000. ECCP3DEL, Value on all other Resets = uuuu. ECCP3DEL, Value on all other Resets = uuuu\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used during ECCP operation.\nNote 1:\n- Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "18.1 Master SSP (MSSP) Module Overview\nThe Master Synchronous Serial Port (MSSP) module is a serial interface, useful for communicating with other peripheral or microcontroller devices. These peripheral devices  may  be  serial  EEPROMs,  shift  registers, display drivers, A/D converters, etc. The MSSP module can operate in one of two modes:\n\u00b7 Serial Peripheral Interface (SPI)\n\u00b7 Inter-Integrated Circuit (I C) 2\n-Full Master mode\n-Slave mode (with general address call)\nThe  I 2 C  interface  supports  the  following  modes  in hardware:\n\u00b7 Master mode\n\u00b7 Multi-Master mode\n\u00b7 Slave mode",
    "18.2 Control Registers\nThe  MSSP  module  has  three  associated  registers. These  include  a  status  register  (SSPSTAT)  and  two control registers (SSPCON1 and SSPCON2). The use of these registers and their individual configuration bits differ  significantly  depending  on  whether  the  MSSP module is operated in SPI or I 2 C mode.\nAdditional  details  are  provided  under  the  individual sections.",
    "18.3 SPI Mode\nThe SPI mode allows 8 bits of data to be synchronously transmitted and received simultaneously. All four modes of SPI are supported. To accomplish communication, typically three pins are used:\n\u00b7 Serial Data Out (SDO) - RC5/SDO\n\u00b7 Serial Data In (SDI) - RC4/SDI/SDA\n\u00b7 Serial Clock (SCK) - RC3/SCK/SCL\nAdditionally, a fourth pin may be used when in a Slave mode of operation:\n- \u00b7 Slave Select (SS) - RF7/SS\nFigure 18-1  shows  the  block  diagram  of  the  MSSP module when operating in SPI mode.",
    "18.3.1 REGISTERS\nThe  MSSP  module  has  four  registers  for  SPI  mode operation. These are:\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to or read from.\n\u00b7 MSSP Control Register 1 (SSPCON1)\n\u00b7 MSSP Status Register (SSPSTAT)\n\u00b7 Serial Receive/Transmit Buffer Register (SSPBUF)\n\u00b7 MSSP Shift Register (SSPSR) - Not directly accessible\nIn receive operations, SSPSR and SSPBUF together create a double-buffered receiver. When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.\nDuring  transmission,  the  SSPBUF  is  not  doublebuffered. A write to SSPBUF will write to both SSPBUF and SSPSR.\nSSPCON1 and SSPSTAT are the control and status registers in SPI mode operation. The SSPCON1 register  is  readable  and  writable.  The  lower  6  bits  of  the SSPSTAT  are  read-only.  The  upper  two  bits  of  the SSPSTAT are read/write.",
    "REGISTER 18-1: SSPSTAT: MSSP STATUS REGISTER (SPI MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "bit 7 SMP: Sample bit\nSPI Master mode:\n1 = Input data sampled at end of data output time\n0 = Input data sampled at middle of data output time\nSPI Slave mode:\nSMP must be cleared when SPI is used in Slave mode.",
    "bit 6\nCKE: SPI Clock Edge Select bit\n1 = Transmit occurs on transition from active to Idle clock state\n0 = Transmit occurs on transition from Idle to active clock state\nNote:\nPolarity of clock state is set by the CKP bit (SSPCON1<4>).",
    "bit 5 D/A: Data/Address bit\nUsed in I C mode only. 2",
    "bit 4 P: Stop bit\nUsed in I C mode only. This bit is cleared when the MSSP module is disabled, SSPEN is 2 cleared.",
    "bit 3 S: Start bit\nUsed in I C mode only. 2",
    "bit 2 R/W: Read/Write bit Information\nUsed in I C mode only. 2",
    "bit 1 UA: Update Address bit\nUsed in I C mode only. 2\nbit 0\nBF: Buffer Full Status bit\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 18-2: SSPCON1: MSSP CONTROL REGISTER 1 (SPI MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0",
    "bit 7 WCOL: Write Collision Detect bit (Transmit mode only)\n1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision",
    "SPI Slave mode:\n1 = A new byte is received while the SSPBUF register is still holding the previous data. In case of overflow, the data in SSPSR is lost. Overflow can only occur in Slave mode. The user must read the SSPBUF, even if only transmitting data, to avoid setting overflow (must be cleared in software).\n0 = No overflow\nNote:\nIn  Master  mode,  the  overflow  bit  is  not  set  since  each  new  reception  (and transmission) is initiated by writing to the SSPBUF register.",
    "bit 5 SSPEN: Master Synchronous Serial Port Enable bit\n1 = Enables serial port and configures SCK, SDO, SDI and SS as serial port pins\n0 = Disables serial port and configures these pins as I/O port pins\nNote:\nWhen enabled, these pins must be properly configured as input or output.",
    "bit 4 CKP: Clock Polarity Select bit\n1 = Idle state for clock is a high level\n0 = Idle state for clock is a low level",
    "bit 3-0 SSPM3:SSPM0: Master Synchronous Serial Port Mode Select bits\n0101 = SPI Slave mode, clock = SCK pin, SS pin control disabled, SS can be used as I/O pin 0100 = SPI Slave mode, clock = SCK pin, SS pin control enabled\n0011 = SPI Master mode, clock = TMR2 output/2\n0010 = SPI Master mode, clock = FOSC/64\n0001 = SPI Master mode, clock = FOSC/16\n0000 = SPI Master mode, clock = FOSC/4\nNote:\nBit combinations not specifically listed here are either reserved or implemented in I 2 C mode only.",
    "bit 3-0 SSPM3:SSPM0: Master Synchronous Serial Port Mode Select bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "18.3.2 OPERATION\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control  bits  (SSPCON1<5:0>)  and  SSPSTAT<7:6>. These control bits allow the following to be specified:\n- \u00b7 Master mode (SCK is the clock output)\nreading the data that was just received. Any write to the SSPBUF register during transmission/reception of data will be ignored and the write collision detect bit, WCOL (SSPCON1<7>), will be set. User software must clear the WCOL bit so that it can be determined if the following write(s) to the SSPBUF  register completed successfully.\n\u00b7 Slave mode (SCK is the clock input)\n\u00b7 Clock Polarity (Idle state of SCK)\n\u00b7 Data Input Sample Phase (middle or end of data output time)\n\u00b7 Clock Edge (output data on rising/falling edge of SCK)\n\u00b7 Clock Rate (Master mode only)\n\u00b7 Slave Select mode (Slave mode only)",
    "18.3.2 OPERATION\nThe MSSP consists of a transmit/receive shift register (SSPSR) and a buffer register (SSPBUF). The SSPSR shifts the data in and out of the device, MSb first. The SSPBUF holds the data that was written to the SSPSR until the received data is ready. Once the 8 bits of data have been received, that byte is moved to the SSPBUF register. Then the buffer full detect bit, BF (SSPSTAT<0>) and the interrupt  flag  bit,  SSPIF,  are set. This double-buffering of the received data (SSPBUF) allows the next byte to start reception before",
    "18.3.2 OPERATION\nWhen the application software is expecting to receive valid data, the SSPBUF should be read before the next byte of data to transfer is written to the SSPBUF. Buffer full  bit,  BF  (SSPSTAT<0>),  indicates  when  SSPBUF has been loaded with the received data (transmission is complete). When the SSPBUF is read, the BF bit is cleared. This data may be irrelevant if the SPI is only a transmitter.  Generally,  the  MSSP  interrupt  is  used  to determine when the transmission/reception has completed. The SSPBUF must be read and/or written. If the interrupt method is not going to be used, then software polling can be done to ensure that a write collision does not  occur.  Example 18-1  shows  the  loading  of  the SSPBUF (SSPSR) for data transmission.\nThe SSPSR is not directly readable or writable and can only be accessed by addressing the SSPBUF register. Additionally,  the  MSSP  Status  register  (SSPSTAT) indicates the various status conditions.",
    "EXAMPLE 18-1: LOADING THE SSPBUF (SSPSR) REGISTER\nLOOP, 1 = BTFSS. LOOP, 2 = SSPSTAT, BF. LOOP, 3 = ;Has data been received (transmit complete)?. , 1 = BRA. , 2 = LOOP. , 3 = ;No. , 1 = MOVF. , 2 = SSPBUF, W. , 3 = ;WREG reg = contents of SSPBUF. , 1 = MOVWF. , 2 = RXDATA. , 3 = ;Save in user RAM, if data is meaningful. , 1 = MOVF. , 2 = TXDATA, W. , 3 = ;W reg = contents of TXDATA. , 1 = MOVWF. , 2 = SSPBUF. , 3 = ;New data to xmit",
    "18.3.4 TYPICAL CONNECTION\nTo  enable  the  serial  port,  MSSP  Enable  bit,  SSPEN (SSPCON1<5>), must be set. To reset or reconfigure SPI  mode,  clear the SSPEN  bit,  re-initialize the SSPCON registers and then set the SSPEN bit. This configures the SDI, SDO, SCK and SS pins as serial port  pins.  For  the  pins  to  behave  as  the  serial  port function, some must have their data direction bits (in the TRIS register) appropriately programmed as follows:\n\u00b7 SDI is automatically controlled by the SPI module\n\u00b7 SDO must have TRISC<5> bit cleared\n\u00b7 SCK (Master mode) must have TRISC<3> bit cleared\n\u00b7 SCK (Slave mode) must have TRISC<3> bit set\n\u00b7 SS must have TRISF<7> bit set\nAny  serial  port  function  that  is  not  desired  may  be overridden  by  programming  the  corresponding  data direction (TRIS) register to the opposite value.",
    "FIGURE 18-2: SPI\u2122 MASTER/SLAVE CONNECTION\nFigure 18-2 shows a typical connection between two microcontrollers. The  master controller (Processor 1) initiates the data transfer by sending the SCK signal. Data  is  shifted  out  of  both  shift  registers  on  their programmed clock edge and latched on the opposite edge of the clock. Both processors should be programmed to the same Clock Polarity (CKP), then both  controllers  would  send  and  receive  data  at  the same time. Whether the data is meaningful (or dummy data) depends on the application software. This leads to three scenarios for data transmission:\n\u00b7 Master sends data - Slave sends dummy data \uf020 \uf020\n\u00b7 Master sends data - Slave sends data \uf020 \uf020\n\u00b7 Master sends dummy data - Slave sends data \uf020 \uf020",
    "18.3.5 MASTER MODE\nThe master can initiate the data transfer at any time because it controls the SCK. The master determines when  the  slave (Processor 2, Figure 18-2) is to broadcast data by the software protocol.\nIn  Master  mode,  the  data  is  transmitted/received  as soon as the SSPBUF register is written to. If the SPI is only  going  to  receive,  the  SDO  output  could  be  disabled (programmed as an input). The SSPSR register will continue to shift in the signal present on the SDI pin at the programmed  clock  rate.  As  each  byte is received, it will be loaded into the SSPBUF register as if  a  normal  received  byte  (interrupts  and  status  bits appropriately  set).  This  could  be  useful  in  receiver applications as a 'Line Activity Monitor' mode.\nThe clock polarity is selected by appropriately programming the CKP bit (SSPCON1<4>). This then, would  give  waveforms  for  SPI  communication  as shown  in  Figure 18-3,  Figure 18-5  and  Figure 18-6, where the MSB is transmitted first. In Master mode, the SPI clock rate (bit rate) is user programmable to be one of the following:",
    "18.3.5 MASTER MODE\n\u00b7 FOSC/4 (or TCY)\n\u00b7 FOSC/16 (or 4 \u00b7 TCY)\n\u00b7 FOSC/64 (or 16 \u00b7 TCY)\n\u00b7 Timer2 output/2\nThis  allows  a  maximum  data  rate  (at  40  MHz)  of 10.00 Mbps.\nFigure 18-3  shows  the  waveforms  for  Master  mode.",
    "18.3.6 SLAVE MODE\nIn Slave mode, the data is transmitted and received as the external clock pulses appear on SCK. When the last bit is latched, the SSPIF interrupt flag bit is set.\nWhile in Slave mode, the external clock is supplied by the external clock source on the SCK pin. This external clock must meet the minimum high and low times as specified in the electrical specifications.\nBefore  enabling  the  module  in  SPI  Slave  mode,  the clock line must match the proper Idle state. The clock line can be observed by reading the SCK pin. The Idle state is determined by the CKP bit (SSPCON1<4>).\nWhile in  Sleep  mode,  the  slave  can  transmit/receive data. When a byte is received, the device will wake-up from Sleep.",
    "18.3.7 SLAVE SELECT SYNCHRONIZATION\nThe SS pin allows  a  Synchronous Slave mode.  The SPI must be in Slave mode with SS pin control enabled (SSPCON1<3:0> = 04h). The pin must not be driven low for the SS pin to function as an input. The data latch must be high. When the SS pin is low, transmission and reception are enabled and the SDO pin is driven. When the SS pin goes high, the SDO pin is no longer driven even if in the middle of a transmitted byte and becomes a  floating  output.  External  pull-up/pull-down  resistors may be desirable depending on the application.\nNote 1: When the SPI is in Slave mode with SS pin control enabled (SSPCON<3:0> = 0100 ), the SPI module will reset if the SS pin is set to VDD.\n2: If the SPI is used in Slave mode with CKE set,  then  the  SS  pin  control  must  be enabled.\nWhen the SPI module resets, the bit counter is forced to ' 0 '. This can be done by either forcing the SS pin to a high level or clearing the SSPEN bit.",
    "18.3.7 SLAVE SELECT SYNCHRONIZATION\nTo emulate two-wire communication, the SDO pin can be connected to the SDI pin. When the SPI needs to operate as a receiver, the SDO pin can be configured as an input. This disables transmissions from the SDO. The SDI can always be left as an input (SDI function) since it cannot create a bus conflict.\nFIGURE 18-4: SLAVE SYNCHRONIZATION WAVEFORM",
    "PIC18F6525/6621/8525/8621\nFIGURE 18-6:\n1\nSPI\u2122 MODE WAVEFORM (SLAVE MODE WITH CKE =  )",
    "18.3.10 BUS MODE COMPATIBILITY\nIn Master mode, all module clocks are halted and the transmission/reception will remain in that state until the device wakes from Sleep. After the device returns to normal  mode,  the  module  will  continue  to  transmit/ receive data.\nIn Slave mode, the SPI Transmit/Receive Shift register operates asynchronously to the device. This allows the device  to  be  placed  in  Sleep  mode  and  data  to  be shifted  into  the  SPI  Transmit/Receive  Shift  register. When all 8 bits have been received, the MSSP interrupt flag bit will be set and if enabled, will wake the device from Sleep.",
    "18.3.9 EFFECTS OF A RESET\nTable 18-1 shows the compatibility between the standard  SPI  modes  and  the  states  of  the  CKP  and CKE control bits.\nTABLE 18-1: SPI\u2122 BUS MODES\n\n0, 0, Control Bits State.CKP = 0. 0, 0, Control Bits State.CKE = 1. 0, 1, Control Bits State.CKP = 0. 0, 1, Control Bits State.CKE = 0. 1, 0, Control Bits State.CKP = 1. 1, 0, Control Bits State.CKE = 1. 1, 1, Control Bits State.CKP = 1. 1, 1, Control Bits State.CKE = 0\nA Reset disables the MSSP module and terminates the current transfer.\nThere is also a SMP bit which controls when the data is sampled.",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\n2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other Resets = 1111. TRISC, Value on all other Resets = 1111. TRISF, Bit 7 =",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\nTRISF7. TRISF, Bit 6 = TRISF6. TRISF, Bit 5 = TRISF5. TRISF, Bit 4 = TRISF4. TRISF, Bit 3 = TRISF3. TRISF, Bit 2 = TRISF2. TRISF, Bit 1 = TRISF1. TRISF, Bit 0 = TRISF0. TRISF, Value on POR, BOR = 1111. TRISF, Value on POR, BOR = 1111. TRISF, Value on all other Resets = 1111. TRISF, Value on all other Resets = 1111. SSPBUF, Bit 7 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\n0 = MSSP Receive Buffer/Transmit Register. SSPBUF, Value on POR, BOR = xxxx. SSPBUF, Value on POR, BOR = xxxx. SSPBUF, Value on all other Resets = uuuu. SSPBUF, Value on all other Resets = uuuu. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 = SSPM1. SSPCON1, Bit 0 = SSPM0. SSPCON1, Value on POR, BOR = 0000. SSPCON1, Value on POR, BOR = 0000. SSPCON1, Value on all other Resets = 0000. SSPCON1, Value on all other Resets = 0000. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 =",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\nCKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR, BOR = 0000. SSPSTAT, Value on POR, BOR = 0000. SSPSTAT, Value on all other Resets = 0000. SSPSTAT, Value on all other Resets = 0000\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the MSSP in SPI\u2122 mode.\nNote 1:\n- Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "18.4.1 REGISTERS\nThe MSSP module in I 2 C  mode  fully  implements  all master  and  slave  functions  (including  general  call support) and provides interrupts on Start and Stop bits in hardware to determine a free bus (multi-master function).  The  MSSP  module  implements  the  standard mode  specifications, as well as 7-bit and  10-bit addressing.\nTwo pins are used for data transfer:\n\u00b7 Serial clock (SCL) - RC3/SCK/SCL\n\u00b7 Serial data (SDA) - RC4/SDI/SDA\nThe user must configure these pins as inputs or outputs through the TRISC<4:3> bits.",
    "FIGURE 18-7: MSSP BLOCK DIAGRAM (I 2 C\u2122 MODE)\nThe MSSP module has six registers for I 2 C operation. These are:\n\u00b7 MSSP Control Register 1 (SSPCON1)\n\u00b7 MSSP Control Register 2 (SSPCON2)\n\u00b7 MSSP Status Register (SSPSTAT)\n\u00b7 Serial Receive/Transmit Buffer Register (SSPBUF)\n\u00b7 MSSP Shift Register (SSPSR) - Not directly accessible\n\u00b7 MSSP Address Register (SSPADD)\nSSPCON1, SSPCON2 and SSPSTAT are the control and  status  registers in I 2 C mode  operation.  The SSPCON1 and SSPCON2 registers are readable and writable. The lower 6 bits of the SSPSTAT are readonly.  The  upper  two  bits  of  the  SSPSTAT  are  read/ write.\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to or read from.",
    "FIGURE 18-7: MSSP BLOCK DIAGRAM (I 2 C\u2122 MODE)\nSSPADD  register  holds  the  slave  device  address when  the  MSSP  is  configured  in  I 2 C  Slave  mode. When  the  MSSP  is  configured  in  Master  mode,  the lower  seven  bits  of  SSPADD  act  as  the  Baud  Rate Generator reload value.\nIn receive operations, SSPSR and SSPBUF together create a double-buffered receiver. When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.\nDuring  transmission,  the  SSPBUF  is  not  doublebuffered. A write to SSPBUF will write to both SSPBUF and SSPSR.\nbit 6",
    "REGISTER 18-3: SSPSTAT: MSSP STATUS REGISTER (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "bit 7 SMP: Slew Rate Control bit\nIn Master or Slave mode:\n1 = Slew rate control disabled for Standard Speed mode (100 kHz and 1 MHz)\n0 = Slew rate control enabled for High Speed mode (400 kHz)\nCKE:\nSMBus Select bit\nIn Master or Slave mode:\n1 = Enable SMBus specific inputs\n0 = Disable SMBus specific inputs",
    "Reserved\nIn Slave mode:\n1 = Indicates that the last byte received or transmitted was data\n0 = Indicates that the last byte received or transmitted was address",
    "bit 4 P: Stop bit\n1 = Indicates that a Stop bit has been detected last\n0 = Stop bit was not detected last\nNote: This bit is cleared on Reset and when SSPEN is cleared.",
    "bit 3 S: Start bit\n1 = Indicates that a Start bit has been detected last\n0 = Start bit was not detected last\nNote: This bit is cleared on Reset and when SSPEN is cleared.",
    "In Slave mode:\n1 = Read\n0 = Write\nNote: This bit holds the R/W bit information following the last address match. This bit is only valid from the address match to the next Start bit, Stop bit or not ACK bit.",
    "In Master mode:\n1 = Transmit is in progress\n0 = Transmit is not in progress\nNote:\nORing this bit with SEN, RSEN, PEN, RCEN or ACKEN will indicate if the MSSP is in Idle mode.",
    "bit 1 UA: Update Address bit (10-bit Slave mode only)\n1 = Indicates that the user needs to update the address in the SSPADD register\n0 = Address does not need to be updated",
    "bit 0 BF: Buffer Full Status bit\nIn Transmit mode:\n1 = SSPBUF is full\n0 = SSPBUF is empty\nIn Receive mode:\n1 = SSPBUF is full (does not include the ACK and Stop bits)\n0 = SSPBUF is empty (does not include the ACK and Stop bits)",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 18-4: SSPCON1: MSSP CONTROL REGISTER 1 (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0",
    "In Master Transmit mode:\n1 = A write to the SSPBUF register was attempted while the I 2 C conditions were not valid for a transmission to be started (must be cleared in software)\n0 = No collision",
    "In Slave Transmit mode:\n1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision\nIn Receive mode (Master or Slave modes):\nThis is a 'don't care' bit.",
    "bit 6 SSPOV: Receive Overflow Indicator bit\nIn Receive mode:\n1 = A byte is received while the SSPBUF register is still holding the previous byte (must be cleared in software)\n0 = No overflow\nIn Transmit mode:\nThis is a 'don't care' bit in Transmit mode.",
    "bit 5 SSPEN: Master Synchronous Serial Port Enable bit\n- 1 = Enables the serial port and configures the SDA and SCL pins as the serial port pins\n0\n= Disables serial port and configures these pins as I/O port pins\nNote:\nWhen enabled,  the  SDA  and  SCL  pins  must  be  properly  configured  as  input  or output.",
    "In Slave mode:\n1 = Release clock\n0 = Holds clock low (clock stretch), used to ensure data setup time\nIn Master mode:\nUnused in this mode.",
    "bit 3-0 SSPM3:SSPM0: Master Synchronous Serial Port Mode Select bits\n1111 = I 2 C Slave mode, 10-bit address with Start and Stop bit interrupts enabled\n1011 = I 2 C Firmware Controlled Master mode (Slave Idle)\n1110 = I 2 C Slave mode, 7-bit address with Start and Stop bit interrupts enabled\n1000 = I 2 C Master mode, clock = FOSC/(4 * (SSPADD + 1))\n0110 = I 2 C Slave mode, 7-bit address\n0111 = I 2 C Slave mode, 10-bit address\nNote: Bit combinations not specifically listed here are either reserved or implemented in SPI mode only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 18-5: SSPCON2: MSSP CONTROL REGISTER 2 (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. GCEN, 1 = ACKSTAT. GCEN, 2 = ACKDT. GCEN, 3 = ACKEN. GCEN, 4 = RCEN. GCEN, 5 = PEN. GCEN, 6 = RSEN. GCEN, 7 = SEN\nbit 7\nbit 0\nbit 7 GCEN: General Call Enable bit (Slave mode only)\n1 = Enable interrupt when a general call address (0000h) is received in the SSPSR\n0 = General call address disabled",
    "bit 6 ACKSTAT: Acknowledge Status bit (Master Transmit mode only)\n1 = Acknowledge was not received from slave\n0 = Acknowledge was received from slave\nbit 5 ACKDT: Acknowledge Data bit (Master Receive mode only)\n1 = Not Acknowledge\n0 = Acknowledge\nNote:\nValue that will be transmitted when the user initiates an Acknowledge sequence at the end of a receive.",
    "bit 4 ACKEN: Acknowledge Sequence Enable bit (Master Receive mode only)\n= Initiate Acknowledge sequence on SDA and SCL pins and transmit ACKDT data bit.\n1 Automatically cleared by hardware.\n0 = Acknowledge sequence Idle",
    "bit 3 RCEN: Receive Enable bit (Master mode only)\n1 = Enables Receive mode for I 2 C\n0 = Receive Idle\nbit 2 PEN: Stop Condition Enable bit (Master mode only)\n1 = Initiate Stop condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Stop condition Idle",
    "bit 1 RSEN: Repeated Start Condition Enable bit (Master mode only)\n1 = Initiate Repeated Start condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Repeated Start condition Idle\nbit 0 SEN: Start Condition Enable/Stretch Enable bit",
    "In Master mode:\n1 = Initiate Start condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Start condition Idle",
    "In Slave mode:\n1 = Clock stretching is enabled for both slave transmit and slave receive (stretch enabled)\n0 = Clock stretching is disabled\nNote:\nFor bits ACKEN, RCEN, PEN, RSEN, SEN: If the I 2 C module is not in the Idle mode, this bit may not be set (no spooling) and the SSPBUF may not be written (or writes to the SSPBUF are disabled).",
    "Legend:\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR,  = '0' = Bit is cleared. -n = Value at POR,  = x = Bit is unknown",
    "18.4.3.1 Addressing\nThe  MSSP  module  functions  are  enabled  by  setting MSSP Enable bit, SSPEN (SSPCON<5>).\nThe SSPCON1 register allows control of the I 2 C operation. Four mode selection bits (SSPCON<3:0>) allow one of the following I 2 C modes to be selected:\n\u00b7 I 2 C Master mode, clock = (FOSC/4) x (SSPADD + 1)\n\u00b7 I 2 C Slave mode (7-bit address)\n\u00b7 I 2 C Slave mode (10-bit address)\n\u00b7 I 2 C Slave mode (7-bit address), with Start and Stop bit interrupts enabled\n\u00b7 I 2 C Slave mode (10-bit address), with Start and Stop bit interrupts enabled\n\u00b7 I 2 C firmware controlled master operation, slave is Idle\nSelection  of  any  I 2 C  mode  with  the  SSPEN  bit  set, forces  the  SCL  and  SDA  pins  to  be  open-drain, provided  these  pins  are  programmed  to  inputs  by setting  the appropriate TRISC bits. To ensure proper operation  of  the  module,  pull-up  resistors  must  be provided externally to the SCL and SDA pins.",
    "18.4.3 SLAVE MODE\nIn Slave mode, the SCL and SDA pins must be configured as inputs (TRISC<4:3> set). The MSSP module will override the input state with the output data when required (slave-transmitter).\nThe I 2 C Slave mode hardware will always generate an interrupt  on  an  address  match.  Through  the  mode select  bits,  the  user  can  also  choose  to  interrupt  on Start and Stop bits\nWhen an address is matched, or the data transfer after an address match is received, the hardware automatically will generate the Acknowledge (ACK) pulse and load  the  SSPBUF  register  with  the  received  value currently in the SSPSR register.\nAny combination of the following conditions will cause the MSSP module not to give this ACK pulse:\n\u00b7 The buffer full bit BF (SSPSTAT<0>) was set before the transfer was received.\n\u00b7 The overflow bit SSPOV (SSPCON<6>) was set before the transfer was received.",
    "18.4.3 SLAVE MODE\nIn  this  case,  the  SSPSR register value is not loaded into the SSPBUF, but bit SSPIF (PIR1<3>) is set. The BF bit is cleared by reading the SSPBUF register, while bit SSPOV is cleared through software.\nThe SCL clock input must have a minimum high and low for proper operation. The high and low times of the I 2 C  specification,  as  well  as  the  requirement  of  the MSSP module, are shown in timing parameter 100 and parameter 101.\nOnce the MSSP module has been enabled, it waits for a Start condition to occur. Following the Start condition, the  8-bits  are  shifted  into  the  SSPSR  register.  All incoming bits are sampled with the rising edge of the clock (SCL) line. The value of register SSPSR<7:1> is compared to the value of the  SSPADD register. The address is compared on the falling edge of the eighth clock (SCL) pulse. If the addresses match and the BF and SSPOV bits are clear, the following events occur:",
    "18.4.3 SLAVE MODE\n1. The  SSPSR  register  value  is  loaded  into  the SSPBUF register.\n2. The buffer full bit BF is set.\n3. An ACK pulse is generated.\n4. MSSP Interrupt  Flag  bit,  SSPIF  (PIR1<3>),  is set  (interrupt  is  generated,  if  enabled)  on  the falling edge of the ninth SCL pulse.\nIn 10-bit Address mode, two address bytes need to be received  by  the  slave.  The  five  Most  Significant  bits (MSbs) of the first address byte specify if this is a 10-bit address. Bit R/W (SSPSTAT<2>) must specify a write so the slave device will receive the second address byte. For a 10-bit address, the first byte would equal ' 11110 A9 A8 0 ', where ' A9 ' and ' A8 ' are the two MSbs of the address. The sequence of events for 10-bit address is as follows, with steps 7 through 9 for the slave-transmitter:",
    "18.4.3 SLAVE MODE\n1. Receive first (high) byte of address (bits SSPIF, BF and UA (SSPSTAT<1>) are set).\n2. Update the SSPADD register with second (low) byte of address (clears bit UA and releases the SCL line).\n3. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n4. Receive  second  (low)  byte  of  address  (bits SSPIF, BF and UA are set).\n5. Update the SSPADD register with the first (high) byte of address. If match releases SCL line, this will clear bit UA.\n6. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n7. Receive Repeated Start condition.\n8. Receive first (high) byte of address (bits SSPIF and BF are set).\n9. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.",
    "18.4.3.3 Transmission\nWhen the R/W bit of the address byte is clear and an address  match  occurs,  the  R/W  bit  of  the  SSPSTAT register is cleared. The received address is loaded into the  SSPBUF  register  and  the  SDA  line  is  held  low (ACK).\nWhen the address byte overflow condition exists, then the no Acknowledge (ACK) pulse is given. An overflow condition is defined as either bit BF (SSPSTAT<0>) is set, or bit SSPOV (SSPCON1<6>) is set.\nAn MSSP interrupt is generated for each data transfer byte.  Flag  bit,  SSPIF  (PIR1<3>),  must  be  cleared  in software. The SSPSTAT register is used to determine the status of the byte.\nIf  SEN is enabled (SSPCON1<0> = 1 ),  RC3/SCK/SCL will be  held  low  (clock  stretch)  following  each  data transfer. The clock must be released by setting bit CKP (SSPCON<4>). See Section 18.4.4 'Clock Stretching' for more detail.",
    "18.4.3.3 Transmission\nWhen the R/W bit of the incoming address byte is set and  an  address  match  occurs,  the  R/W  bit  of  the SSPSTAT  register  is  set.  The  received  address  is loaded into the SSPBUF register. The ACK pulse will be sent on the ninth bit and pin RC3/SCK/SCL is held low  regardless  of  SEN  (see Section 18.4.4  'Clock Stretching' for  more detail). By stretching the clock, the master will be unable to assert another clock pulse until the slave is done preparing the transmit data. The transmit data must be loaded into the SSPBUF register which also loads the SSPSR register. Then pin RC3/ SCK/SCL  should  be  enabled  by  setting  bit,  CKP (SSPCON1<4>). The eight data bits are shifted out on the falling edge of the SCL input. This ensures that the SDA  signal is valid during the SCL  high time (Figure 18-9).",
    "18.4.3.3 Transmission\nThe ACK pulse from the master-receiver is latched on the rising edge of the ninth SCL input pulse. If the SDA line is high  (not  ACK),  then  the  data  transfer  is complete. In this case, when the ACK is latched by the slave, the slave logic is reset (resets SSPSTAT register) and the slave monitors for another occurrence of the Start bit. If the SDA line was low (ACK), the next transmit data must be loaded into the SSPBUF register. Again, pin RC3/SCK/SCL must be enabled by setting bit CKP.\nAn MSSP interrupt is generated for each data transfer byte. The SSPIF bit must be cleared in software and the SSPSTAT register is used to determine the status of the byte. The SSPIF bit is set on the falling edge of the ninth clock pulse.",
    "18.4.4 CLOCK STRETCHING\nBoth 7-bit and 10-bit Slave modes implement automatic clock stretching during a transmit sequence.",
    "18.4.4.3 Clock Stretching for 7-bit Slave Transmit Mode\nThe SEN bit (SSPCON2<0>) allows clock stretching to be  enabled  during  receives.  Setting  SEN  will  cause the  SCL  pin  to  be  held  low  at  the  end  of  each  data receive sequence.",
    "18.4.4.1 Clock Stretching for 7-bit Slave Receive Mode (SEN = 1 )\nIn 7-bit Slave Receive mode, on the falling edge of the ninth clock at the end of the ACK sequence if the BF bit  is  set,  the  CKP  bit  in  the  SSPCON1  register  is automatically  cleared,  forcing  the  SCL  output  to  be held low. The CKP being cleared to ' 0 '  will assert the SCL line low. The CKP bit must be set in the user's ISR before reception is allowed to continue. By holding the SCL line low, the user has time to service the ISR and  read  the  contents  of  the  SSPBUF  before  the master device can initiate another receive sequence. This  will  prevent  buffer  overruns  from  occurring  (see Figure 18-13).",
    "18.4.4.1 Clock Stretching for 7-bit Slave Receive Mode (SEN = 1 )\nNote 1: If the  user  reads  the  contents  of  the SSPBUF  before  the  falling  edge  of  the ninth clock, thus clearing the BF bit, the CKP  bit  will  not  be  cleared  and  clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software regardless of the state of the BF bit. The user should be careful to clear the BF bit in the ISR before the next receive sequence in order to prevent an overflow condition.",
    "18.4.4.2 Clock Stretching for 10-bit Slave Receive Mode (SEN = 1 )\nIn  10-bit  Slave  Receive  mode  during  the  address sequence,  clock  stretching  automatically  takes  place but CKP is not cleared. During this time, if the UA bit is set  after  the  ninth  clock,  clock  stretching  is  initiated. The UA bit is set after receiving the upper byte of the 10-bit address and following the receive of the second byte of the 10-bit address with the R/W bit cleared to ' 0 '. The release of the clock line occurs upon updating SSPADD.  Clock  stretching  will  occur  on  each  data receive sequence as described in 7-bit mode.",
    "Note:\nIf the user polls the UA bit and clears it by updating the SSPADD register before the falling edge of the ninth clock occurs and if the user hasn't cleared the BF bit by reading the SSPBUF register before that time, then the CKP bit will still NOT be asserted low.  Clock  stretching  on  the  basis  of  the state  of  the  BF  bit  only  occurs  during  a data sequence, not an address sequence.\n7-bit Slave Transmit mode implements clock stretching by  clearing  the  CKP  bit  after  the  falling  edge  of  the ninth clock if the BF bit is clear. This occurs regardless of the state of the SEN bit.\nThe user's ISR must set the CKP bit before transmission  is  allowed  to  continue.  By  holding  the  SCL  line low, the user has time to service the ISR and load the contents of the SSPBUF before the master device can initiate another transmit sequence (see Figure 18-9).\nNote 1: If the user loads the contents of SSPBUF, setting the BF bit before the falling edge of the  ninth  clock,  the  CKP  bit  will  not  be cleared and clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software regardless of the state of the BF bit.",
    "18.4.4.4 Clock Stretching for 10-bit Slave Transmit Mode\nIn  10-bit  Slave  Transmit  mode,  clock  stretching  is controlled during the first two address sequences by the  state  of  the  UA  bit,  just  as  it  is  in  10-bit  Slave Receive  mode. The  first  two  addresses  are  followed by a third address sequence which contains the highorder bits of the 10-bit address and the R/W bit set to ' 1 '. After the third address sequence is performed, the UA  bit  is  not  set,  the  module  is  now  configured  in Transmit  mode  and  clock  stretching  is  controlled  by the  BF  flag  as  in  7-bit  Slave  Transmit  mode  (see Figure 18-11).",
    "PIC18F6525/6621/8525/8621\n18.4.4.5 Clock Synchronization and the CKP bit\nWhen the CKP bit is cleared, the SCL output is forced to ' 0 '. However, clearing the CKP bit will not assert the SCL  output  low  until the SCL  output  is already sampled low. Therefore, the CKP bit will not assert the SCL  line  until  an  external  I 2 C  master  device  has already  asserted  the  SCL  line.  The  SCL  output  will remain  low  until  the  CKP  bit  is  set  and  all  other devices  on  the  I 2 C  bus  have  deasserted  SCL.  This ensures that a write to the CKP bit will not violate the minimum high time requirement for SCL (see Figure 18-12).",
    "18.4.5 GENERAL CALL ADDRESS SUPPORT\nThe addressing procedure for the I 2 C bus is such that the  first  byte  after  the  Start  condition  usually  determines which device will be the slave addressed by the master. The exception is the general call address which can address all devices. When this address is used, all devices should, in theory, respond with an Acknowledge.\nThe  general  call  address  is  one  of  eight  addresses reserved for specific purposes by the I 2 C protocol. It consists of all ' 0 's with R/W = 0 .\nThe  general  call  address  is  recognized  when  the General Call Enable bit (GCEN) is enabled (SSPCON2<7> set). Following a Start bit detect, 8 bits are shifted into the SSPSR  and  the  address  is compared against the SSPADD. It is also compared to the general call address and fixed in hardware.\nIf  the  general  call  address  matches,  the  SSPSR  is transferred to the SSPBUF, the BF flag bit is set (eighth bit) and on the falling edge of the ninth bit (ACK bit), the SSPIF interrupt flag bit is set.",
    "18.4.5 GENERAL CALL ADDRESS SUPPORT\nWhen  the  interrupt  is  serviced,  the  source  for  the interrupt can be checked by reading the contents of the SSPBUF. The value can be used to determine if the address was device specific or a general call address.\nIn 10-bit mode, the SSPADD is required to be updated for the second half of the address to match and the UA bit is set (SSPSTAT<1>). If the general call address is sampled when the GCEN bit is set, while the slave is configured  in  10-bit  Address  mode,  then  the  second half of the address is not necessary, the UA bit will not be set and the slave will begin receiving data after the Acknowledge (Figure 18-15).",
    "Note:\nMaster  mode  is  enabled  by  setting  and  clearing  the appropriate SSPM bits in SSPCON1 and by setting the SSPEN bit. In Master mode, the SCL and SDA lines are manipulated by the MSSP hardware.\nMaster  mode  of  operation  is  supported  by  interrupt generation on the detection of the Start and Stop conditions. The Stop (P) and Start (S) bits are cleared from a Reset or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set or the bus is Idle, with both the S and P bits clear.\nThe  MSSP  module,  when  configured  in I 2 C Master mode, does not allow queueing of  events.  For  instance,  the  user  is  not allowed  to  initiate  a  Start  condition  and immediately write the SSPBUF register to initiate transmission before the Start condition  is  complete.  In  this  case,  the SSPBUF  will  not  be  written  to  and  the WCOL bit will be set, indicating that a write to the SSPBUF did not occur.\nIn Firmware Controlled Master mode, user code conducts all I 2 C bus operations based on Start and Stop bit conditions.\nOnce  Master  mode  is  enabled,  the  user  has  six options.",
    "Note:\n1. Assert a Start condition on SDA and SCL.\n2. Assert a Repeated Start condition on SDA and SCL.\n3. Write to the SSPBUF register initiating transmission of data/address.\n4. Configure the I 2 C port to receive data.\n5. Generate an Acknowledge condition at the end of a received byte of data.\n6. Generate a Stop condition on SDA and SCL.",
    "FIGURE 18-16: MSSP BLOCK DIAGRAM (I 2 C\u2122 MASTER MODE)\nThe following events will cause MSSP Interrupt Flag bit, SSPIF, to be set (MSSP interrupt, if enabled):\n\u00b7 Start condition\n\u00b7 Stop condition\n\u00b7 Data transfer byte transmitted/received\n\u00b7 Acknowledge transmit\n\u00b7 Repeated Start",
    "18.4.6.1 I 2 C Master Mode Operation\nA typical transmit sequence would go as follows:\nThe  master  device  generates  all  of  the  serial  clock pulses and the Start and Stop conditions.   A transfer is ended with a Stop condition or with a Repeated Start condition.  Since the Repeated Start condition is also the beginning of the next serial transfer, the I 2 C bus will not be released.\nIn Master  Transmitter  mode,  serial  data  is  output through SDA, while SCL outputs the serial clock. The first byte transmitted contains the slave address of the receiving device (7 bits) and the Read/Write (R/W) bit. In this case, the R/W bit will be logic ' 0 '. Serial data is transmitted 8 bits at a time. After each byte is transmitted,  an  Acknowledge  bit  is  received.  Start  and  Stop conditions are output to indicate the beginning and the end of a serial transfer.",
    "18.4.6.1 I 2 C Master Mode Operation\nIn Master Receive mode, the first byte transmitted contains  the  slave  address  of  the  transmitting  device (7 bits) and the R/W bit. In this case, the R/W bit will be logic ' 1 '. Thus, the first byte transmitted is a 7-bit slave address followed by a ' 1 ' to indicate receive bit. Serial data is received via SDA, while SCL outputs the serial clock. Serial data is received 8 bits at a time. After each byte  is  received,  an  Acknowledge  bit  is  transmitted. Start  and  Stop  conditions  indicate  the  beginning  and end of transmission.\nThe Baud Rate Generator used for the SPI mode operation is used to set the SCL clock frequency for either 100  kHz,  400  kHz  or  1  MHz  I 2 C  operation.  See Section 18.4.7  'Baud  Rate  Generator' for more detail.",
    "18.4.6.1 I 2 C Master Mode Operation\n1. The user generates a Start condition by setting the Start Enable bit, SEN (SSPCON2<0>).\n2. SSPIF is set. The MSSP module will wait the required  start  time  before  any  other  operation takes place.\n3. The  user  loads  the  SSPBUF  with  the  slave address to transmit.\n4. Address is shifted out of the SDA pin until all 8 bits are transmitted.\n5. The MSSP module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).\n6. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.\n7. The user loads the SSPBUF with eight bits of data.\n8. Data is shifted out of the SDA pin until all 8 bits are transmitted.\n9. The MSSP module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).",
    "18.4.6.1 I 2 C Master Mode Operation\n10. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.\n11. The user generates a Stop condition by setting the Stop Enable bit, PEN (SSPCON2<2>).\n12. Interrupt is generated once the Stop condition is complete.",
    "18.4.7 BAUD RATE GENERATOR\nIn I 2 C Master mode, the Baud Rate Generator (BRG) reload  value  is  placed  in  the  lower  7  bits  of  the SSPADD register (Figure 18-17). When a write occurs to SSPBUF, the Baud Rate Generator will automatically begin counting. The BRG counts down to ' 0 ' and stops until another reload has taken place. The BRG count is decremented twice per instruction cycle (TCY) on the Q2 and Q4 clocks. In I 2 C  Master  mode,  the  BRG  is reloaded automatically.\nOnce the given operation is complete (i.e., transmission of the last data bit is followed by ACK), the internal clock will automatically stop counting and the SCL pin will remain in its last state.\nTable 18-3 demonstrates clock rates based on instruction  cycles  and  the  BRG  value  loaded  into SSPADD.",
    "TABLE 18-3: I 2 C\u2122 CLOCK RATE w/BRG\n40 MHz, FCY = 10 MHz. 40 MHz, FCY*2 = 20 MHz. 40 MHz, BRG Value = 18h. 40 MHz, FSCL (2 Rollovers of BRG) = 400 kHz (1). 40 MHz, FCY = 10 MHz. 40 MHz, FCY*2 = 20 MHz. 40 MHz, BRG Value = 1Fh. 40 MHz, FSCL (2 Rollovers of BRG) = 312.5 kHz. 40 MHz, FCY = 10 MHz. 40 MHz, FCY*2 = 20 MHz. 40 MHz, BRG Value = 63h. 40 MHz, FSCL (2 Rollovers of BRG) = 100 kHz. 16 MHz, FCY = 4 MHz. 16 MHz, FCY*2 = 8 MHz. 16 MHz, BRG Value = 09h. 16 MHz, FSCL (2 Rollovers of BRG) = 400 kHz (1). 16 MHz, FCY = 4 MHz. 16 MHz, FCY*2 = 8 MHz. 16 MHz, BRG Value = 0Ch. 16 MHz, FSCL (2 Rollovers",
    "TABLE 18-3: I 2 C\u2122 CLOCK RATE w/BRG\nof BRG) = 308 kHz. 16 MHz, FCY = 4 MHz. 16 MHz, FCY*2 = 8 MHz. 16 MHz, BRG Value = 27h. 16 MHz, FSCL (2 Rollovers of BRG) = 100 kHz. 4 MHz, FCY = 1 MHz. 4 MHz, FCY*2 = 2 MHz. 4 MHz, BRG Value = 02h. 4 MHz, FSCL (2 Rollovers of BRG) = 333 kHz (1). 4 MHz, FCY = 1 MHz. 4 MHz, FCY*2 = 2 MHz. 4 MHz, BRG Value = 09h. 4 MHz, FSCL (2 Rollovers of BRG) = 100 kHz. 4 MHz, FCY = 1 MHz. 4 MHz, FCY*2 = 2 MHz. 4 MHz, BRG Value = 00h. 4 MHz, FSCL (2 Rollovers of BRG) = 1 MHz (1)",
    "TABLE 18-3: I 2 C\u2122 CLOCK RATE w/BRG\nNote 1: The I 2 C interface does not conform to the 400 kHz I 2 C specification (which applies to rates greater than 100 kHz) in all details, but may be used with care where higher rates are required by the application.",
    "18.4.7.1 Clock Arbitration\nClock arbitration occurs when the master, during any receive,  transmit  or  Repeated  Start/Stop  condition, deasserts  the  SCL  pin  (SCL  allowed  to  float  high). When the SCL pin is allowed to float high, the Baud Rate  Generator  (BRG)  is  suspended  from  counting until the SCL pin is actually sampled high. When the\nSCL pin is sampled high, the Baud Rate Generator is reloaded  with  the  contents  of  SSPADD<6:0>  and begins counting. This ensures that the SCL high time will always be at least one BRG rollover count in the event that the clock is held low by an external device (Figure 18-18).",
    "18.4.8 I 2 C MASTER MODE START CONDITION TIMING\nTo  initiate  a  Start  condition,  the  user  sets  the  Start condition enable bit, SEN (SSPCON2<0>). If the SDA and  SCL  pins  are  sampled  high,  the  Baud  Rate Generator is reloaded with the contents of SSPADD<6:0> and starts its count. If SCL and SDA are both  sampled  high  when  the  Baud  Rate  Generator times out (TBRG), the SDA pin is driven low. The action of the SDA being driven low while SCL is high is the Start condition and causes the S bit (SSPSTAT<3>) to be  set.  Following  this,  the  Baud  Rate  Generator  is reloaded  with  the  contents  of  SSPADD<6:0>  and resumes  its  count.  When  the  Baud  Rate  Generator times out (TBRG), the SEN bit (SSPCON2<0>) will be automatically  cleared  by  hardware,  the  Baud  Rate Generator is suspended, leaving the SDA line held low and the Start condition is complete.\nNote:",
    "18.4.8 I 2 C MASTER MODE START CONDITION TIMING\nIf  at  the  beginning  of  the  Start  condition, the SDA and SCL pins are already sampled low, or if during the Start condition, the SCL line is sampled low before the SDA line  is  driven  low,  a  bus  collision  occurs, the Bus Collision Interrupt Flag, BCLIF, is set, the Start condition is aborted and the I 2 C module is reset into its Idle state.",
    "18.4.8.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Start sequence is in progress, the WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).",
    "Note:\nBecause queueing of events is not allowed,  writing  to  the  lower  5  bits  of SSPCON2  is  disabled until the Start condition is complete.",
    "18.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nA Repeated Start condition occurs when the RSEN bit (SSPCON2<1>) is programmed high and the I 2 C logic module is in the Idle state. When the RSEN bit is set, the SCL pin is asserted low. When the SCL pin is sampled low, the Baud Rate Generator is loaded with the contents of SSPADD<5:0> and begins counting. The SDA pin is released (brought high) for one Baud Rate Generator count (TBRG). When the Baud Rate Generator times out, if SDA is sampled high, the SCL pin will be deasserted (brought high). When SCL is sampled high,  the  Baud  Rate  Generator  is  reloaded  with  the contents of SSPADD<6:0> and begins counting. SDA and  SCL  must  be  sampled  high  for  one  TBRG.  This action  is  then  followed  by  assertion  of  the  SDA  pin (SDA = 0 ) for one TBRG while SCL is high. Following this, the RSEN bit (SSPCON2<1>) will be automatically cleared  and  the  Baud  Rate  Generator  will  not",
    "18.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nbe reloaded, leaving the SDA pin held low. As soon as a Start condition is detected on the SDA and SCL pins, the S bit (SSPSTAT<3>) will be set. The SSPIF bit will not be set until the Baud Rate Generator has timed out.\nNote 1: If  RSEN is programmed while any other event is in progress, it will not take effect.\n2: A bus collision during the Repeated Start condition occurs if:\n\u00b7 SDA is sampled low when SCL goes from low-to-high.\n\u00b7 SCL goes low before SDA is asserted low. This may indicate that another master is attempting to transmit a data ' 1 '.\nImmediately following the SSPIF bit getting set, the user may write the SSPBUF with the 7-bit address in 7-bit mode, or the default first address in 10-bit mode. After the  first eight  bits  are  transmitted  and  an  ACK  is received, the user may then transmit an additional eight bits of address (10-bit mode) or eight bits of data (7-bit mode).",
    "18.4.9.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Repeated Start sequence  is  in  progress,  the  WCOL  is  set  and  the contents of the buffer are unchanged (the write doesn't occur).\nNote:\nBecause queueing of events is not allowed,  writing  of  the  lower  5  bits  of SSPCON2 is disabled until the Repeated Start condition is complete.",
    "18.4.10 I 2 C MASTER MODE TRANSMISSION\nTransmission  of  a  data  byte,  a  7-bit  address  or  the other half of a 10-bit address is accomplished by simply writing a value to the SSPBUF register. This action will set the buffer full flag bit, BF and allow the Baud Rate Generator to begin counting and start the next transmission. Each bit of address/data will be shifted out onto the SDA pin after the falling edge of SCL is asserted (see data hold time specification parameter 106).  SCL  is  held  low  for  one  Baud  Rate Generator rollover count (TBRG). Data should be valid before  SCL  is  released  high  (see  data  setup  time specification  parameter  107).  When  the  SCL  pin  is released high, it is held that way for TBRG. The data on the SDA pin must remain stable for that duration and some hold time after the next falling edge of SCL. After the eighth bit is shifted out (the falling edge of the eighth clock), the BF flag is cleared and the master releases SDA. This allows the slave device being addressed to respond with an ACK bit during the ninth bit time if an address  match  occurred,  or  if  data  was  received properly.",
    "18.4.10 I 2 C MASTER MODE TRANSMISSION\nThe status of ACK is written into the ACKDT bit on the falling edge of the ninth clock. If the master receives an Acknowledge, the Acknowledge status bit, ACKSTAT, is cleared. If not, the bit is set. After the ninth clock, the SSPIF bit is set and the master clock (Baud Rate Generator) is suspended until the next data byte is loaded into the SSPBUF, leaving SCL low and SDA unchanged (Figure 18-21).",
    "18.4.10 I 2 C MASTER MODE TRANSMISSION\nAfter the write to the SSPBUF, each bit of address will be shifted out on the falling edge of SCL until all seven address bits  and  the  R/W  bit  are  completed.  On  the falling edge of the eighth clock, the master will deassert the  SDA  pin,  allowing  the  slave  to  respond  with  an Acknowledge. On the falling edge of the ninth clock, the master will sample the SDA pin to see if the address was recognized by a slave. The status of the ACK bit is loaded into the ACKSTAT status bit (SSPCON2<6>). Following the falling edge of the ninth clock transmission of the address, the SSPIF is set, the BF flag is cleared and the Baud Rate Generator is turned off until another write to the SSPBUF takes place, holding SCL low and allowing SDA to float.",
    "18.4.10.1 BF Status Flag\nIn  Transmit  mode,  the  BF  bit  (SSPSTAT<0>)  is  set when the CPU writes to SSPBUF and is cleared when all 8 bits are shifted out.",
    "18.4.10.2 WCOL Status Flag\nIf  the  user  writes  the  SSPBUF  when  a  transmit  is already in progress (i.e., SSPSR is still shifting out a data byte), the WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).\nWCOL must be cleared in software.",
    "18.4.10.3 ACKSTAT Status Flag\nIn Transmit mode, the ACKSTAT bit (SSPCON2<6>) is cleared  when  the  slave  has  sent  an  Acknowledge (ACK = 0 ) and is set when the slave does not Acknowledge (ACK = 1 ). A slave sends an Acknowledge when it has recognized its address (including a general call), or when the slave has properly received its data.",
    "18.4.11 I 2 C MASTER MODE RECEPTION\nMaster mode reception is enabled by programming the receive enable bit, RCEN (SSPCON2<3>).",
    "Note:\nThe MSSP module must be in an Idle state before the RCEN bit is set or the RCEN bit will be disregarded.\nThe Baud Rate Generator begins counting and on each rollover, the state of the SCL pin changes (high-to-low/ low-to-high) and data is shifted into the SSPSR. After the falling edge of the eighth clock, the receive enable flag is automatically  cleared,  the  contents  of  the SSPSR are loaded into the SSPBUF, the BF flag bit is set,  the  SSPIF  flag  bit  is  set  and  the  Baud  Rate Generator  is  suspended  from  counting,  holding  SCL low. The MSSP is now in Idle state awaiting the next command. When the buffer is read by the CPU, the BF flag  bit  is  automatically  cleared.  The  user  can  then send an Acknowledge bit at the end of reception by setting the Acknowledge sequence enable bit, ACKEN (SSPCON2<4>).",
    "18.4.11.1 BF Status Flag\nIn receive operation, the BF bit is set when an address or data byte is loaded into SSPBUF from SSPSR. It is cleared when the SSPBUF register is read.",
    "18.4.11.2 SSPOV Status Flag\nIn receive operation, the SSPOV bit is set when 8 bits are  received  into  the  SSPSR  and  the  BF  flag  bit  is already set from a previous reception.",
    "18.4.11.3 WCOL Status Flag\nIf the  user  writes  the  SSPBUF  when  a  receive  is already in progress (i.e., SSPSR is still shifting in a data byte), the WCOL bit is set and the contents of the buffer are unchanged (the write doesn't occur).",
    "18.4.13 STOP CONDITION TIMING\nAn  Acknowledge  sequence  is  enabled  by  setting  the Acknowledge sequence enable bit, ACKEN (SSPCON2<4>). When this  bit  is  set,  the  SCL  pin  is pulled low and the contents of the Acknowledge data bit are presented on the SDA pin. If the user wishes to generate an Acknowledge, then the ACKDT bit should be cleared. If not, the user should set the ACKDT bit before starting  an  Acknowledge  sequence.  The  Baud  Rate Generator  then  counts  for  one  rollover  period  (TBRG) and the SCL pin is deasserted (pulled high). When the SCL pin is  sampled high (clock  arbitration),  the  Baud Rate Generator counts for TBRG. The SCL pin is then pulled low. Following this, the ACKEN bit is automatically cleared, the Baud Rate Generator is turned off and the MSSP module then goes into Idle mode (Figure 18-23).",
    "18.4.12.1 WCOL Status Flag\nIf the user writes the SSPBUF when an Acknowledge sequence is  in  progress,  then  WCOL  is  set  and  the contents of the buffer are unchanged (the write doesn't occur).\nA Stop bit is asserted on the SDA pin at the end of a receive/transmit by setting the Stop sequence enable bit,  PEN  (SSPCON2<2>).  At  the  end  of  a  receive/ transmit, the SCL line is held low after the falling edge of the ninth clock. When the PEN bit is set, the master will  assert  the  SDA  line  low.  When  the  SDA  line  is sampled low, the Baud Rate Generator is reloaded and counts  down  to  ' 0 '.  When  the  Baud  Rate  Generator times out, the SCL pin will  be brought  high  and one TBRG (Baud Rate Generator rollover count) later, the SDA pin will be deasserted. When the SDA pin is sampled high while SCL is high, the P bit (SSPSTAT<4>) is set. A TBRG later, the PEN bit is cleared and the SSPIF bit is set (Figure 18-24).",
    "18.4.13.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Stop sequence is in progress, then the WCOL bit is set and the contents  of  the  buffer  are  unchanged  (the  write  doesn't occur).",
    "18.4.14 SLEEP OPERATION\nWhile  in  Sleep  mode,  the  I 2 C  module  can  receive addresses  or  data  and  when  an  address  match  or complete  byte  transfer  occurs,  wake  the  processor from Sleep (if the MSSP interrupt is enabled).",
    "18.4.15 EFFECT OF A RESET\nA Reset disables the MSSP module and terminates the current transfer.",
    "18.4.16 MULTI-MASTER MODE\nIn Multi-Master mode, the interrupt generation on the detection of the  Start  and  Stop  conditions  allows  the determination of when the bus is free. The Stop (P) and Start  (S)  bits  are  cleared  from  a  Reset  or  when  the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit (SSPSTAT<4>) is set, or the bus is Idle with both the S and P bits clear. When the bus is busy, enabling the MSSP interrupt will generate the interrupt when the Stop condition occurs.\nIn multi-master  operation,  the  SDA  line  must  be monitored for arbitration to see if the signal level is the expected  output  level.  This  check  is  performed  in hardware with the result placed in the BCLIF bit.\nThe states where arbitration can be lost are:\n\u00b7 Address Transfer\n\u00b7 Data Transfer\n\u00b7 A Start Condition\n\u00b7 A Repeated Start Condition\n\u00b7 An Acknowledge Condition",
    "18.4.16 MULTI-MASTER MODE\nMulti-Master mode support is achieved by bus arbitration. When the master outputs address/data bits onto the SDA pin, arbitration takes place when the master outputs  a  ' 1 '  on  SDA,  by  letting  SDA  float  high  and another master asserts a ' 0 '. When the SCL pin floats high,  data  should  be  stable.  If  the  expected  data  on SDA is a ' 1 ' and the data sampled on the SDA pin = 0 , then a bus collision has taken place. The master will set the Bus Collision Interrupt Flag, BCLIF and reset the I 2 C port to its Idle state (Figure 18-25).\nIf  a  transmit  was  in  progress  when  the  bus  collision occurred,  the  transmission  is  halted,  the  BF  flag  is cleared, the SDA and SCL lines are deasserted and the SSPBUF can be written to. When the user services the bus collision  Interrupt  Service  Routine  and  if  the  I 2 C bus  is  free,  the  user  can  resume  communication  by asserting a Start condition.",
    "18.4.16 MULTI-MASTER MODE\nIf a Start, Repeated  Start, Stop or Acknowledge condition was  in progress  when  the  bus  collision occurred,  the  condition  is  aborted,  the  SDA  and  SCL lines are deasserted and the respective control bits in the SSPCON2 register are cleared. When the user services the bus collision Interrupt Service Routine and if the I 2 C bus is free, the user can resume communication by asserting a Start condition.\nThe master will continue to monitor the SDA and SCL pins. If a Stop condition occurs, the SSPIF bit will be set.\nA write  to  the  SSPBUF  will  start  the  transmission  of data  at  the  first  data  bit  regardless  of  where  the transmitter left off when the bus collision occurred.\nIn Multi-Master mode, the interrupt generation on the detection of Start and Stop conditions allows the determination of when the bus is free. Control of the I 2 C bus can be taken when the P bit is  set  in  the  SSPSTAT register,  or  the  bus  is  Idle  and  the  S  and  P  bits  are cleared.",
    "18.4.17.1 Bus Collision During a Start Condition\nDuring a Start condition, a bus collision occurs if:\na) SDA or SCL are sampled low at the beginning of the Start condition (Figure 18-26).\nb) SCL is sampled low before SDA is asserted low (Figure 18-27).\nIf  the  SDA  pin  is  sampled  low  during  this  count,  the BRG  is  reset  and  the  SDA  line  is  asserted  early (Figure 18-28). If, however, a ' 1 ' is sampled on the SDA pin, the SDA pin is asserted low at the end of the BRG count. The Baud Rate Generator is then reloaded and counts down to ' 0 ' and during this time, if the SCL pin is sampled as ' 0 ', a bus collision does not occur. At the end of the BRG count, the SCL pin is asserted low.\nDuring a Start  condition,  both the  SDA  and the  SCL pins are monitored.\nIf the SDA pin is already low, or the SCL pin is already low, then all of the following occur:",
    "18.4.17.1 Bus Collision During a Start Condition\n\u00b7 the Start condition is aborted,\n\u00b7 the BCLIF flag is set and\n\u00b7 the MSSP module is reset to its Idle state (Figure 18-26).\nThe Start condition begins with the SDA and SCL pins deasserted. When the SDA pin is sampled high, the Baud  Rate  Generator  is  loaded  from  SSPADD<6:0> and counts down to ' 0 '. If the SCL pin is sampled low while SDA is high, a bus collision occurs because it is assumed that another master is attempting to drive a data ' 1 ' during the Start condition.\nThe reason that bus collision is not a factor during a Start condition is that no two bus masters can assert a Start condition at the exact  same  time.  Therefore,  one  master will  always  assert  SDA  before  the  other. This condition does  not cause  a bus collision because the two masters must be allowed to arbitrate the first address following the Start condition. If the address is the same, arbitration must be allowed to continue  into  the  data  portion,  Repeated Start or Stop conditions.",
    "18.4.17.2 Bus Collision During a Repeated Start Condition\nDuring  a  Repeated  Start  condition,  a  bus  collision occurs if:\n- a) A low level is sampled on SDA when SCL goes from low level to high level.\nIf SDA is low, a bus collision has occurred (i.e., another master is attempting to transmit a data ' 0 ', Figure 18-29). If SDA is sampled high, the BRG is reloaded and begins counting. If SDA goes from high-to-low before the BRG times  out,  no  bus  collision  occurs  because  no  two masters can assert SDA at exactly the same time.\n- b) SCL  goes  low  before  SDA  is  asserted  low, indicating  that  another master is attempting to transmit a data ' 1 '.\nWhen the user deasserts SDA and the pin is allowed to float high, the BRG is loaded with SSPADD<6:0> and counts down to ' 0 '. The SCL pin is then deasserted and when sampled high, the SDA pin is sampled.",
    "18.4.17.2 Bus Collision During a Repeated Start Condition\nIf SCL goes from high-to-low before the BRG times out and SDA has not already been asserted, a bus collision occurs.  In  this  case,  another  master  is  attempting  to transmit a data ' 1 ' during the Repeated Start condition, see Figure 18-30.\nIf, at the end of the BRG time-out, both SCL and SDA are still high, the SDA pin is driven low and the BRG is reloaded and begins counting. At the end of the count regardless of the status of the SCL pin, the SCL pin is driven low and the Repeated Start condition is complete.",
    "18.4.17.3 Bus Collision During a Stop Condition\nBus collision occurs during a Stop condition if:\na) After  the  SDA  pin  has  been  deasserted  and allowed to float high, SDA is sampled low after the BRG has timed out.\nb) After the SCL pin is deasserted, SCL is sampled low before SDA goes high.\nThe  Stop  condition  begins  with  SDA  asserted  low. When SDA is sampled low, the SCL pin is allowed to float. When the pin is sampled high (clock arbitration), the Baud Rate Generator is loaded with SSPADD<6:0> and counts down to ' 0 '. After the BRG times out, SDA is sampled. If SDA is sampled low, a bus collision has occurred. This is due to another master attempting to drive  a  data  ' 0 ' (Figure 18-31).  If  the  SCL  pin  is sampled low before SDA is allowed to float high, a bus collision occurs. This is another case of another master attempting to drive a data ' 0 ' (Figure 18-32).",
    "FIGURE 18-31: BUS COLLISION DURING A STOP CONDITION (CASE 1)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nSDA asserted low\nSDA sampled low after TBRG, set BCLIF\n' 0 '\n'\n0\n'",
    "FIGURE 18-32: BUS COLLISION DURING A STOP CONDITION (CASE 2)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nAssert SDA\nSCL goes low before SDA goes high, set BCLIF\n' 0 '\n' 0 '",
    "TABLE 18-4: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR",
    "TABLE 18-4: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\n= 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP.",
    "TABLE 18-4: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\nIPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other Resets = 1111. TRISC, Value on all other Resets = 1111.",
    "TABLE 18-4: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\nTRISF, Bit 7 = TRISF7. TRISF, Bit 6 = TRISF6. TRISF, Bit 5 = TRISF5. TRISF, Bit 4 = TRISF4. TRISF, Bit 3 = TRISF3. TRISF, Bit 2 = TRISF2. TRISF, Bit 1 = TRISF1. TRISF, Bit 0 = TRISF0. TRISF, Value on POR, BOR = 1111. TRISF, Value on POR, BOR = 1111. TRISF, Value on all other Resets = 1111. TRISF, Value on all other Resets = 1111. SSPBUF, Bit 7 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = MSSP Receive Buffer/Transmit",
    "TABLE 18-4: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\nRegister. SSPBUF, Bit 0 = MSSP Receive Buffer/Transmit Register. SSPBUF, Value on POR, BOR = xxxx. SSPBUF, Value on POR, BOR = xxxx. SSPBUF, Value on all other Resets = uuuu. SSPBUF, Value on all other Resets = uuuu. SSPADD, Bit 7 = MSSPAddress Register in I 2 CSlave mode. MSSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 6 = MSSPAddress Register in I 2 CSlave mode. MSSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 5 = MSSPAddress Register in I 2 CSlave mode. MSSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 4 = MSSPAddress Register in I 2 CSlave mode. MSSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 3 = MSSPAddress Register",
    "TABLE 18-4: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\nin I 2 CSlave mode. MSSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 2 = MSSPAddress Register in I 2 CSlave mode. MSSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 1 = MSSPAddress Register in I 2 CSlave mode. MSSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 0 = MSSPAddress Register in I 2 CSlave mode. MSSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Value on POR, BOR = 0000. SSPADD, Value on POR, BOR = 0000. SSPADD, Value on all other Resets = 0000. SSPADD, Value on all other Resets = 0000. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3",
    "TABLE 18-4: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\n= SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 = SSPM1. SSPCON1, Bit 0 = SSPM0. SSPCON1, Value on POR, BOR = 0000. SSPCON1, Value on POR, BOR = 0000. SSPCON1, Value on all other Resets = 0000. SSPCON1, Value on all other Resets = 0000. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR, BOR = 0000. SSPSTAT, Value on POR, BOR = 0000. SSPSTAT, Value on all other Resets = 0000. SSPSTAT, Value on all other Resets = 0000",
    "TABLE 18-4: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the MSSP in I C\u2122 mode. 2 Note 1: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "19.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\nThe pins of USART1 and USART2 are multiplexed with the functions of PORTC (RC6/TX1/CK1 and RC7/RX1/ DT1) and PORTG (RG1/TX2/CK2 and RG2/RX2/DT2), respectively.  In  order  to  configure  these  pins  as  an EUSART:\nThe  Enhanced  Universal  Synchronous  Asynchronous Receiver Transmitter (EUSART) module is one of the two  serial  I/O  modules.  (USART  is  also  known  as  a Serial Communications Interface or SCI.) The EUSART can be configured as a full-duplex asynchronous system that can communicate with peripheral devices, such as CRT terminals and personal computers. It can also be configured  as  a  half-duplex  synchronous  system  that can communicate with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs, etc.",
    "19.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\nThe Enhanced USART module implements additional features, including automatic baud rate detection and calibration, automatic wake-up on Sync Break reception and 12-bit Break character transmit. These make it ideally suited for use in Local Interconnect Network bus (LIN bus) systems.\nThe  EUSART  can  be  configured  in  the  following modes:",
    "19.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\n\u00b7 Asynchronous (full duplex) with:\n-Auto-Wake-up on character reception\n-Auto-Baud calibration\n-12-bit Break character transmission\n\u00b7 Synchronous - Master (half duplex) with selectable clock polarity\n\u00b7 Synchronous - Slave (half duplex) with selectable clock polarity\n\u00b7 For USART1:\n-bit SPEN (RCSTA1<7>) must be set (= 1 )\n-bit TRISC<7> must be set (= 1 )\n-bit TRISC<6> must be cleared (= 0 ) for Asynchronous and Synchronous Master modes\n-bit TRISC<6> must be set (= 1 ) for Synchronous Slave mode\n\u00b7 For USART2:\n-bit SPEN (RCSTA2<7>) must be set (= 1 )\n-bit TRISG<2> must be set (= 1 )\n-bit TRISG<1> must be cleared (= 0 ) for Asynchronous and Synchronous Master modes",
    "19.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\n-bit TRISC<6> must be set (= 1 ) for Synchronous Slave mode",
    "Note:\nThe  EUSART  control  will  automatically reconfigure the pin from input to output as needed.\nThe  operation  of  each  Enhanced  USART  module  is controlled through three registers:\n\u00b7 Transmit Status and Control (TXSTAx)\n\u00b7 Receive Status and Control (RCSTAx)\n\u00b7 Baud Rate Control (BAUDCONx)\nThese are detailed on the following pages in Register 19-1, Register 19-2 and Register 19-3, respectively.\nThroughout  this  section,  references  to register and bit names that may be associated with a specific EUSART module are referred to generically by the use of 'x' in place of the specific module  number. Thus, 'RCSTAx' might refer to the Receive Status register for either USART1 or USART2",
    "TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R-1. R/W-0, 7 = R/W-0. CSRC, 1 = TX9. CSRC, 2 = TXEN. CSRC, 3 = SYNC. CSRC, 4 = SENDB. CSRC, 5 = BRGH. CSRC, 6 = TRMT. CSRC, 7 = TX9D\nbit 7\nbit 0\nCSRC: Clock Source Select bit\nAsynchronous mode:\nDon't care.\nSynchronous mode:\n1 = Master mode (clock generated internally from BRG)\n- 0 = Slave mode (clock from external source)",
    "bit 6 TX9: 9-bit Transmit Enable bit\n1 = Selects 9-bit transmission\n0 = Selects 8-bit transmission\nTXEN:\nTransmit Enable bit\n1 = Transmit enabled\n0 = Transmit disabled\nNote:\nSREN/CREN overrides TXEN in Sync mode.",
    "bit 4 SYNC: EUSART Mode Select bit\n- 1 = Synchronous mode\n0 = Asynchronous mode",
    "bit 3 SENDB: Send Break Character bit\nAsynchronous mode:\n1 = Send sync break on next transmission (cleared by hardware upon completion)\n0 = Sync break transmission completed\nSynchronous mode:\nDon't care.",
    "bit 2 BRGH: High Baud Rate Select bit\nAsynchronous mode:\n1 = High speed\n0 = Low speed\nSynchronous mode:\nUnused in this mode.",
    "bit 1 TRMT: Transmit Shift Register Status bit\n1 = TSR empty\n0 = TSR full\nTX9D: 9th bit of Transmit Data\nCan be address/data bit or a parity bit.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "bit 7\nbit 5",
    "REGISTER 19-2: RCSTAx: RECEIVE STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-x. SPEN, 1 = RX9. SPEN, 2 = SREN. SPEN, 3 = CREN. SPEN, 4 = ADDEN. SPEN, 5 = FERR. SPEN, 6 = OERR. SPEN, 7 = RX9D\nbit 7\nbit 0",
    "bit 7 SPEN:\nSerial Port Enable bit\n1 = Serial port enabled (configures RXx/DTx and TXx/CKx pins as serial port pins)\n0 = Serial port disabled (held in Reset)",
    "bit 6\nRX9: 9-bit Receive Enable bit\n1 = Selects 9-bit reception\n0 = Selects 8-bit reception",
    "bit 5 SREN: Single Receive Enable bit\nAsynchronous mode:\nDon't care.\nSynchronous mode - Master:\n1 = Enables single receive\n0 = Disables single receive\nThis bit is cleared after reception is complete.\nSynchronous mode - Slave:\nDon't care.",
    "bit 4 CREN: Continuous Receive Enable bit\nAsynchronous mode:\n1 = Enables receiver\n0 = Disables receiver\nSynchronous mode:\n1 = Enables continuous receive until enable bit CREN is cleared (CREN overrides SREN)\n0 = Disables continuous receive",
    "bit 3 ADDEN: Address Detect Enable bit\nAsynchronous mode 9-bit (RX9 = 1 ):\n1 = Enables address detection, enables interrupt and loads the receive buffer when RSR<8> is set\n0 = Disables address detection, all bytes are received and ninth bit can be used as parity bit\nAsynchronous mode 9-bit (RX9 = 0\n- ):\nDon't care.",
    "bit 2 FERR: Framing Error bit\n1 = Framing error (can be updated by reading RCREGx register and receive next valid byte)\n0 = No framing error",
    "bit 1 OERR: Overrun Error bit\n1 = Overrun error (can be cleared by clearing bit CREN)\n0 = No overrun error",
    "bit 0 RX9D: 9th bit of Received Data\nThis can be address/data bit or a parity bit and must be calculated by user firmware.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "BAUDCONx: BAUD RATE CONTROL REGISTER\nU-0, 1 = R-1. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = U-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = RCIDL. -, 2 = -. -, 3 = SCKP. -, 4 = BRG16. -, 5 = -. -, 6 = WUE. -, 7 = ABDEN\nbit 7\nbit 0",
    "bit 6 RCIDL : Receive Operation Idle Status bit\n1 = Receive operation is Idle\n0 = Receive operation is active",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nSCKP\n: Synchronous Clock Polarity Select bit\nAsynchronous mode:\nUnused in this mode.\nSynchronous mode:\n1 = Idle state for clock (CKx) is a high level\n0 = Idle state for clock (CKx) is a low level\nBRG16: 16-bit Baud Rate Register Enable bit\n1 = 16-bit Baud Rate Generator - SPBRGHx and SPBRGx\n0 = 8-bit Baud Rate Generator - SPBRGx only (Compatible mode), SPBRGHx value ignored",
    "bit 2 Unimplemented: Read as ' 0 '\nbit 1\nWUE:\nWake-up Enable bit\nAsynchronous mode:\n1 = EUSART will continue to sample the RXx pin - interrupt generated on falling edge; bit cleared in hardware on following rising edge\n0 = RXx pin not monitored or rising edge detected\nSynchronous mode:\nUnused in this mode.",
    "Asynchronous mode:\n1 = Enable baud rate measurement on the next character - requires reception of a Sync field (55h); cleared in hardware upon completion\n0 = Baud rate measurement disabled or completed\nSynchronous mode:\nUnused in this mode.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "19.1 EUSART Baud Rate Generator (BRG)\nThe BRG is a dedicated 8-bit or 16-bit generator that supports  both  the  Asynchronous  and  Synchronous modes of the EUSART. By default, the BRG operates in 8-bit mode; setting the BRG16 bit (BAUDCONx<3>) selects 16-bit mode.\nthis,  the  error  in  baud  rate  can  be  determined.  An example calculation is shown in Example 19-1. Typical baud rates and error values for the various Asynchronous  modes  are  shown  in  Table 19-2.  It  may  be advantageous to use the high baud rate (BRGH = 1 ) or the  16-bit  BRG  to  reduce  the  baud  rate  error,  or achieve a slow baud rate for a fast oscillator frequency.",
    "19.1 EUSART Baud Rate Generator (BRG)\nThe  SPBRGHx:SPBRGx  register  pair  controls  the period of a free running timer. In Asynchronous mode, bits BRGH (TXSTAx<2>) and BRG16 also control the baud rate. In Synchronous mode, bit BRGH is ignored. Table 19-1  shows the formula for computation of the baud  rate  for  different  EUSART  modes  which  only apply in Master mode (internally generated clock).\nGiven  the  desired  baud  rate  and  FOSC,  the  nearest integer value for the SPBRGHx:SPBRGx registers can be calculated using the formulas in Table 19-1. From\nWriting a new value to the SPBRGHx:SPBRGx registers causes the BRG timer to be reset (or cleared). This ensures  the  BRG does not wait  for  a  timer  overflow before outputting the new baud rate.",
    "19.1.1 SAMPLING\nThe data on the RXx pin (either RC7/RX1/DT1 or RG2/ RX2/DT2) is sampled three times by a majority detect circuit to determine if a high or a low level is present at the RXx pin.",
    "TABLE 19-1: BAUD RATE FORMULAS\n0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[64 (n + 1)]. 0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 1. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 1. 0,",
    "TABLE 19-1: BAUD RATE FORMULAS\nBRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 0. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 1. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]\nLegend: x = Don't care, n = value of SPBRGHx:SPBRGx register pair",
    "EXAMPLE 19-1: CALCULATING BAUD RATE ERROR\nFor a device with FOSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, 8-bit BRG: Desired Baud Rate = FOSC/(64 ([SPBRGHx:SPBRGx] + 1))\nSolving for SPBRGHx:SPBRGx:\nX = ((FOSC/Desired Baud Rate)/64) - 1\n= ((16000000/9600)/64) - 1\n= [25.042] = 25\nCalculated Baud Rate = 16000000/(64 (25 + 1))\n- = 9615\nError\n= (Calculated Baud Rate - Desired Baud Rate)/Desired Baud Rate\n= (9615 - 9600)/9600 = 0.16%",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nTXSTAx, Bit 7 = CSRC. TXSTAx, Bit 6 = TX9. TXSTAx, Bit 5 = TXEN. TXSTAx, Bit 4 = SYNC. TXSTAx, Bit 3 = SENDB. TXSTAx, Bit 2 = BRGH. TXSTAx, Bit 1 = TRMT. TXSTAx, Bit 0 = TX9D. TXSTAx, Value on POR, BOR = 0000. TXSTAx, Value on POR, BOR = 0010. TXSTAx, Value on all other Resets = 0000. TXSTAx, Value on all other Resets = 0010. RCSTAx, Bit 7 = SPEN. RCSTAx, Bit 6 = RX9. RCSTAx, Bit 5 = SREN. RCSTAx, Bit 4 = CREN. RCSTAx, Bit 3 = ADDEN. RCSTAx, Bit 2 = FERR. RCSTAx, Bit 1 = OERR. RCSTAx, Bit 0 = RX9D. RCSTAx, Value on POR, BOR = 0000. RCSTAx, Value on POR, BOR",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\n= 000x. RCSTAx, Value on all other Resets = 0000. RCSTAx, Value on all other Resets = 000x. BAUDCONx, Bit 7 = -. BAUDCONx, Bit 6 = RCIDL. BAUDCONx, Bit 5 = -. BAUDCONx, Bit 4 = SCKP. BAUDCONx, Bit 3 = BRG16. BAUDCONx, Bit 2 = -. BAUDCONx, Bit 1 = WUE. BAUDCONx, Bit 0 = ABDEN. BAUDCONx, Value on POR, BOR = -1-0. BAUDCONx, Value on POR, BOR = 0-00. BAUDCONx, Value on all other Resets = -1-0. BAUDCONx, Value on all other Resets = 0-00. SPBRGHx, Bit 7 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 6 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 5 = Enhanced USARTx Baud Rate Generator Register High",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nByte. SPBRGHx, Bit 4 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 3 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 2 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 1 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 0 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGx, Bit 7 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 6 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 5 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 4 = Enhanced USARTx Baud Rate Generator Register Low Byte.",
    "TABLE 19-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nSPBRGx, Bit 3 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 2 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 1 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 0 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on all other Resets = 0000. SPBRGx, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used by the BRG.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 1.221. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 255. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n64. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 , BRG16",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 31. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 15. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K)",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 9615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 15. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 7. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n-. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 ,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 4. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 52.083. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -9.58. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 2. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 104.167. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -9.58. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 2. 115.2, SYNC = 0 , BRGH = 0",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 78.125. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -32.18. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 0.3, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 1201.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 12. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 2.4, SYNC",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 8.929. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -6.99. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 6. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.SPBRG value (decimal) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 20.833. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 2. 19.2, SYNC = 0 , BRGH",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -45.75. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.615.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = 21. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 55555. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 1",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 ,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.SPBRG value (decimal) = 12. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 ,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 8332. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 4165. 0.3, SYNC = 0 , BRGH = 0 ,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nRate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 2082. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 1041. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200. 1.2,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -0.03. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 520. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 415. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 2.402. 2.4, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 40.000 MHz.% Error = 0.06. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.399. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 259. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 259. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 129.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 0 ,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nRate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 55555. 57.6,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 20.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.04. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 415. 0.3, SYNC = 0 , BRGH = 0 , BRG16",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1.FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K)",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 9.6, SYNC",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n4.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 ,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 33332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.00.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 16665. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 8332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 300.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.01. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 6665. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 8332.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 4165. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 2.400.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 4165. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 2082.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.402. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.06. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 1040. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 832. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.606. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.06. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n9.596. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal)",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 259. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 19.193. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -0.03.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 520. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 259. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 19.231.",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 103. 57.6,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 57.803. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.35. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 172. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 57.471. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.22. 57.6, SYNC",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 86. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 57142. 57.6, SYNC =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 0.79. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 34. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 114.943. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -0.22. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 86. 115.2, SYNC = 0 ,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 116.279. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.94. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 42. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 117647. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -2.12. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 16",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.01. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 3332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.04. 0.3,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 1665. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.04. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 832. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.04. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 415. 1.2, SYNC = 0 ,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 1",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n, BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 415. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 207. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 ,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 103. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 9.6, SYNC = 0 , BRGH = 1 ,",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 12. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n, BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 58.824. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 2.12. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 16. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 55555. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 8. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 111.111. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 4.000 MHz.% Error = -3.55. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC =",
    "TABLE 19-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "19.1.2 AUTO-BAUD RATE DETECT\nThe Enhanced USART module supports the automatic detection and calibration of baud rate. This feature is active only in Asynchronous mode and while the WUE bit is clear.\nas a 16-bit counter. This allows the user to verify that no carry occurred for 8-bit modes by checking for 00h in the SPBRGHx register. Refer to Table 19-4 for counter clock rates to the BRG.\nThe  automatic  baud  rate  measurement  sequence (Figure 19-1) begins whenever a Start bit is received and the ABDEN  bit is set. The calculation is self-averaging.\nIn the Auto-Baud Rate Detect (ABD) mode, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RXx signal, the RXx signal is timing the BRG. In  ABD  mode,  the  internal  Baud  Rate  Generator  is used as a counter to time the bit period of the incoming serial byte stream.",
    "19.1.2 AUTO-BAUD RATE DETECT\nOnce the ABDEN bit is set, the state machine will clear the BRG and look for a Start bit. The Auto-Baud Rate Detect must  receive a byte with the value 55h (ASCII 'U', which is also the LIN bus Sync character), in order to calculate the proper bit rate. The measurement is taken over both a low and a high bit time in order to minimize any effects caused by asymmetry of the  incoming  signal.  After  a  Start  bit,  the  SPBRGx begins counting up using the preselected clock source on the first rising edge of RXx. After eight bits on the RXx pin or the fifth rising edge, an accumulated value totalling the proper BRG period is left in the SPBRGHx:SPBRGx register pair. Once the 5th edge is seen  (this  should  correspond  to  the  Stop  bit),  the ABDEN bit is automatically cleared.",
    "19.1.2 AUTO-BAUD RATE DETECT\nWhile  the  ABD  sequence  takes  place,  the  EUSART state machine is held in Idle. The RCxIF interrupt is set once the fifth rising edge on RXx is detected. The value in the RCREGx needs to be read to clear the RC1IF interrupt. RCREGx content should be discarded.\nNote 1: If the WUE bit is set with the ABDEN bit, Auto-Baud Rate Detection will occur  on the byte following the Break character.\n2: It is up to the user to determine that the incoming character baud rate is within the range of the selected BRG clock source. Some combinations of oscillator frequency and  EUSART baud rates are not possible due to bit error rates. Overall system timing and communication baud rates  must  be  taken  into  consideration when using the Auto-Baud Rate Detection feature.\nTABLE 19-4: BRG COUNTER CLOCK RATES",
    "19.1.2 AUTO-BAUD RATE DETECT\nWhile calibrating the baud rate period, the BRG registers are clocked at 1/8th the preconfigured clock rate. Note  that  the  BRG  clock  will  be  configured  by  the BRG16 and BRGH bits. Independent of the BRG16 bit setting, both the SPBRGx and SPBRGHx will be used\n0, BRGH = 0. 0, BRG Counter Clock = FOSC/512. 0, BRGH = 1. 0, BRG Counter Clock = FOSC/128. 1, BRGH = 0. 1, BRG Counter Clock = FOSC/128. 1, BRGH = 1. 1, BRG Counter Clock = FOSC/32\nNote:\nDuring the ABD sequence, SPBRGx and SPBRGHx  are  both  used  as  a  16-bit counter, independent of BRG16 setting.",
    "19.2 EUSART Asynchronous Mode\nThe Asynchronous mode of operation is selected by clearing the SYNC bit (TXSTAx<4>). In this mode, the EUSART uses standard non-return-to-zero (NRZ) format (one Start bit, eight or nine data bits and one Stop bit). The most common data format is 8 bits. An on-chip dedicated  8-bit/16-bit  Baud  Rate  Generator  can  be used to derive standard baud rate frequencies from the oscillator.\nThe EUSART transmits and receives the LSb first. The EUSART module's transmitter and receiver are functionally independent but use the same data format and baud rate. The Baud Rate Generator produces a clock, either x16 or x64 of the bit shift rate depending on  the  BRGH  and  BRG16  bits  (TXSTAx<2>  and BAUDCONx<3>).  Parity  is  not supported by the hardware  but  can  be  implemented  in  software  and stored as the 9th data bit.\nWhen operating in Asynchronous mode, the EUSART module consists of the following important elements:",
    "19.2 EUSART Asynchronous Mode\n\u00b7 Baud Rate Generator\n\u00b7 Sampling Circuit\n\u00b7 Asynchronous Transmitter\n\u00b7 Asynchronous Receiver\n\u00b7 Auto-Wake-up on Sync Break Character\n\u00b7 12-bit Break Character Transmit\n\u00b7 Auto-Baud Rate Detection",
    "19.2.1 EUSART ASYNCHRONOUS TRANSMITTER\nOnce the TXREGx register transfers the data to the TSR register  (occurs  in  one  TCY),  the  TXREGx  register  is empty and flag bit TXxIF is set. This interrupt can be enabled/disabled  by setting/clearing  enable  bit  TXxIE. Flag  bit  TXxIF  will  be  set  regardless  of  the  state  of enable bit TXxIE and cannot be cleared in software. Flag bit  TXxIF is not cleared immediately upon loading the Transmit Buffer register, TXREGx. TXxIF becomes valid in the second instruction cycle following the load instruction.  Polling  TXxIF  immediately  following  a  load  of TXREGx will return invalid results.\nWhile flag bit TXxIF indicates the status of the TXREGx register,  another  bit,  TRMT  (TXSTAx<1>),  shows  the status of the TSR register. Status bit TRMT is a read-only bit which is set when the TSR register is empty. No interrupt logic is tied to this bit so the user has to poll this bit in order to determine if the TSR register is empty.",
    "19.2.1 EUSART ASYNCHRONOUS TRANSMITTER\nNote 1: The TSR register is not mapped in data memory so it is not available to the user.\n2: Flag  bit  TXxIF  is  set  when  enable  bit TXEN is set.\nTo set up an Asynchronous Transmission:\n1. Initialize  the  SPBRGHx:SPBRGx  registers  for the  appropriate  baud  rate.  Set  or  clear  the BRGH and BRG16 bits, as required, to achieve the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit TXxIE.",
    "19.2.1 EUSART ASYNCHRONOUS TRANSMITTER\nThe  EUSART transmitter  block  diagram  is  shown  in Figure 19-2. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The Shift register obtains its data from the Read/Write Transmit Buffer register, TXREGx. The TXREGx register is loaded with data in software. The TSR register is not loaded until the Stop bit  has  been  transmitted  from  the  previous  load.  As soon as the Stop bit is transmitted, the TSR is loaded with new data from the TXREGx register (if available).\n4. If  9-bit  transmission is desired, set transmit bit TX9. Can be used as address/data bit.\n5. Enable  the  transmission  by  setting  bit  TXEN which will also set bit TXxIF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Load  data to the TXREGx  register (starts transmission).\nIf using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 19-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR,",
    "TABLE 19-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nBOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP.",
    "TABLE 19-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nIPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = TMR4IF. PIR3, Bit 2 = CCP5IF. PIR3, Bit 1 = CCP4IF. PIR3, Bit 0 = CCP3IF. PIR3, Value on POR, BOR = --00. PIR3, Value on POR, BOR = 0000. PIR3, Value on all other Resets = --00. PIR3, Value on all other Resets = 0000.",
    "TABLE 19-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nPIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 = TMR4IE. PIE3, Bit 2 = CCP5IE. PIE3, Bit 1 = CCP4IE. PIE3, Bit 0 = CCP3IE. PIE3, Value on POR, BOR = --00. PIE3, Value on POR, BOR = 0000. PIE3, Value on all other Resets = --00. PIE3, Value on all other Resets = 0000. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = TMR4IP. IPR3, Bit 2 = CCP5IP. IPR3, Bit 1 = CCP4IP. IPR3, Bit 0 = CCP3IP. IPR3, Value on POR, BOR = --11.",
    "TABLE 19-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nIPR3, Value on POR, BOR = 1111. IPR3, Value on all other Resets = --11. IPR3, Value on all other Resets = 1111. RCSTAx, Bit 7 = SPEN. RCSTAx, Bit 6 = RX9. RCSTAx, Bit 5 = SREN. RCSTAx, Bit 4 = CREN. RCSTAx, Bit 3 = ADDEN. RCSTAx, Bit 2 = FERR. RCSTAx, Bit 1 = OERR. RCSTAx, Bit 0 = RX9D. RCSTAx, Value on POR, BOR = 0000. RCSTAx, Value on POR, BOR = 000x. RCSTAx, Value on all other Resets = 0000. RCSTAx, Value on all other Resets = 000x. TXREGx, Bit 7 = Enhanced USARTx Transmit Register. TXREGx, Bit 6 = Enhanced USARTx Transmit Register. TXREGx, Bit 5 = Enhanced USARTx Transmit Register. TXREGx, Bit 4 = Enhanced USARTx Transmit",
    "TABLE 19-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nRegister. TXREGx, Bit 3 = Enhanced USARTx Transmit Register. TXREGx, Bit 2 = Enhanced USARTx Transmit Register. TXREGx, Bit 1 = Enhanced USARTx Transmit Register. TXREGx, Bit 0 = Enhanced USARTx Transmit Register. TXREGx, Value on POR, BOR = 0000. TXREGx, Value on POR, BOR = 0000. TXREGx, Value on all other Resets = 0000. TXREGx, Value on all other Resets = 0000. TXSTAx, Bit 7 = CSRC. TXSTAx, Bit 6 = TX9. TXSTAx, Bit 5 = TXEN. TXSTAx, Bit 4 = SYNC. TXSTAx, Bit 3 = SENDB. TXSTAx, Bit 2 = BRGH. TXSTAx, Bit 1 = TRMT. TXSTAx, Bit 0 = TX9D. TXSTAx, Value on POR, BOR = 0000. TXSTAx, Value on POR, BOR = 0010. TXSTAx, Value on all other Resets =",
    "TABLE 19-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\n0000. TXSTAx, Value on all other Resets = 0010. BAUDCONx, Bit 7 = -. BAUDCONx, Bit 6 = RCIDL. BAUDCONx, Bit 5 = -. BAUDCONx, Bit 4 = SCKP. BAUDCONx, Bit 3 = BRG16. BAUDCONx, Bit 2 = -. BAUDCONx, Bit 1 = WUE. BAUDCONx, Bit 0 = ABDEN. BAUDCONx, Value on POR, BOR = -1-0. BAUDCONx, Value on POR, BOR = 0-00. BAUDCONx, Value on all other Resets = -1-0. BAUDCONx, Value on all other Resets = 0-00. SPBRGHx, Bit 7 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 6 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 5 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 4 = Enhanced",
    "TABLE 19-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nUSARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 3 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 2 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 1 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 0 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGx, Bit 7 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 6 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 5 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 4 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 3 = Enhanced",
    "TABLE 19-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nUSARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 2 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 1 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 0 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on all other Resets = 0000. SPBRGx, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented locations read as ' 0 '. Shaded cells are not used for asynchronous transmission.\nNote 1:\nEnabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "19.2.2 EUSART ASYNCHRONOUS RECEIVER\nThe receiver block diagram is  shown in Figure 19-5. The data is received on the RXx pin and drives the data recovery block. The data recovery block is actually a high speed shifter operating at x16 times the baud rate, whereas the main receive serial shifter operates at the bit rate or at FOSC. This mode would typically be used in RS-232 systems.\nTo set up an Asynchronous Reception:",
    "19.2.2 EUSART ASYNCHRONOUS RECEIVER\n1. Initialize  the  SPBRGHx:SPBRGx  registers  for the  appropriate  baud  rate.  Set  or  clear  the BRGH and BRG16 bits, as required, to achieve the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit RCxIE.\n4. If 9-bit reception is desired, set bit RX9.\n5. Enable the reception by setting bit CREN.\n6. Flag  bit  RCxIF  will  be  set  when  reception  is complete and an interrupt will  be  generated  if enable bit RCxIE was set.\n7. Read the RCSTAx register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n8. Read  the  8-bit  received  data  by  reading  the RCREGx register.\n9. If any error occurred, clear the error by clearing enable bit CREN.",
    "19.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\nThis mode would typically be used in RS-485 systems. To  set  up  an  Asynchronous  Reception  with  Address Detect Enable:",
    "19.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize  the  SPBRGHx:SPBRGx  registers  for the  appropriate  baud  rate.  Set  or  clear  the BRGH and BRG16 bits, as required, to achieve the desired baud rate.\n2. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n3. If interrupts are required, set the RCEN bit and select the desired priority level with the RCxIP bit.\n4. Set the RX9 bit to enable 9-bit reception.\n5. Set the ADDEN bit to enable address detect.\n6. Enable reception by setting the CREN bit.\n7. The  RCxIF  bit  will  be  set  when  reception  is complete. The interrupt will be Acknowledged if the RCxIE and GIE bits are set.\n8. Read the RCSTAx register to determine if any error occurred during reception, as well as read bit 9 of data (if applicable).\n9. Read  RCREGx  to  determine  if  the  device  is being addressed.\n10. If any error occurred, clear the CREN bit.",
    "19.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n11. If  the  device  has  been  addressed,  clear  the ADDEN bit  to  allow  all  received  data  into  the receive buffer and interrupt the CPU.\n10. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 19-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR,",
    "TABLE 19-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nBOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP.",
    "TABLE 19-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nIPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = TMR4IF. PIR3, Bit 2 = CCP5IF. PIR3, Bit 1 = CCP4IF. PIR3, Bit 0 = CCP3IF. PIR3, Value on POR, BOR = --00. PIR3, Value on POR, BOR = 0000. PIR3, Value on all other Resets = --00. PIR3, Value on all other Resets = 0000.",
    "TABLE 19-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nPIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 = TMR4IE. PIE3, Bit 2 = CCP5IE. PIE3, Bit 1 = CCP4IE. PIE3, Bit 0 = CCP3IE. PIE3, Value on POR, BOR = --00. PIE3, Value on POR, BOR = 0000. PIE3, Value on all other Resets = --00. PIE3, Value on all other Resets = 0000. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = TMR4IP. IPR3, Bit 2 = CCP5IP. IPR3, Bit 1 = CCP4IP. IPR3, Bit 0 = CCP3IP. IPR3, Value on POR, BOR = --11.",
    "TABLE 19-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nIPR3, Value on POR, BOR = 1111. IPR3, Value on all other Resets = --11. IPR3, Value on all other Resets = 1111. RCSTAx, Bit 7 = SPEN. RCSTAx, Bit 6 = RX9. RCSTAx, Bit 5 = SREN. RCSTAx, Bit 4 = CREN. RCSTAx, Bit 3 = ADDEN. RCSTAx, Bit 2 = FERR. RCSTAx, Bit 1 = OERR. RCSTAx, Bit 0 = RX9D. RCSTAx, Value on POR, BOR = 0000. RCSTAx, Value on POR, BOR = 000x. RCSTAx, Value on all other Resets = 0000. RCSTAx, Value on all other Resets = 000x. RCREGx, Bit 7 = Enhanced USARTx Receive Register. RCREGx, Bit 6 = Enhanced USARTx Receive Register. RCREGx, Bit 5 = Enhanced USARTx Receive Register. RCREGx, Bit 4 = Enhanced USARTx Receive",
    "TABLE 19-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nRegister. RCREGx, Bit 3 = Enhanced USARTx Receive Register. RCREGx, Bit 2 = Enhanced USARTx Receive Register. RCREGx, Bit 1 = Enhanced USARTx Receive Register. RCREGx, Bit 0 = Enhanced USARTx Receive Register. RCREGx, Value on POR, BOR = 0000. RCREGx, Value on POR, BOR = 0000. RCREGx, Value on all other Resets = 0000. RCREGx, Value on all other Resets = 0000. TXSTAx, Bit 7 = CSRC. TXSTAx, Bit 6 = TX9. TXSTAx, Bit 5 = TXEN. TXSTAx, Bit 4 = SYNC. TXSTAx, Bit 3 = SENDB. TXSTAx, Bit 2 = BRGH. TXSTAx, Bit 1 = TRMT. TXSTAx, Bit 0 = TX9D. TXSTAx, Value on POR, BOR = 0000. TXSTAx, Value on POR, BOR = 0010. TXSTAx, Value on all other Resets =",
    "TABLE 19-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\n0000. TXSTAx, Value on all other Resets = 0010. BAUDCONx, Bit 7 = -. BAUDCONx, Bit 6 = RCIDL. BAUDCONx, Bit 5 = -. BAUDCONx, Bit 4 = SCKP. BAUDCONx, Bit 3 = BRG16. BAUDCONx, Bit 2 = -. BAUDCONx, Bit 1 = WUE. BAUDCONx, Bit 0 = ABDEN. BAUDCONx, Value on POR, BOR = -1-0. BAUDCONx, Value on POR, BOR = 0-00. BAUDCONx, Value on all other Resets = -1-0. BAUDCONx, Value on all other Resets = 0-00. SPBRGHx, Bit 7 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 6 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 5 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 4 = Enhanced",
    "TABLE 19-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nUSARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 3 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 2 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 1 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 0 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGx, Bit 7 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 6 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 5 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 4 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 3 = Enhanced",
    "TABLE 19-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nUSARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 2 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 1 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 0 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on all other Resets = 0000. SPBRGx, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented locations read as ' 0 '. Shaded cells are not used for asynchronous reception.\nNote 1:\nEnabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "19.2.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nDuring  Sleep  mode,  all  clocks  to  the  EUSART  are suspended. Because of this, the Baud Rate Generator is  inactive  and  a  proper  byte  reception  cannot  be performed. The Auto-Wake-up feature allows the controller to wake-up due to activity on the RXx/DTx line, while the EUSART is operating in Asynchronous mode.\nThe  Auto-Wake-up  feature  is  enabled  by  setting  the WUE bit (BAUDCONx<1>). Once set, the typical receive sequence  on  RXx/DTx  is  disabled  and  the  EUSART remains in an Idle state, monitoring for a wake-up event independent  of  the  CPU  mode.  A  wake-up  event consists of a high-to-low transition on the RXx/DTx line. (This  coincides  with  the  start  of  a  Sync  Break  or  a Wake-up Signal character for the LIN protocol.)",
    "19.2.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nFollowing a wake-up event, the module generates an RC1IF  interrupt.  The  interrupt  is  generated  synchronously  to  the  Q  clocks  in  normal  operating  modes (Figure 19-7)  and  asynchronously,  if  the  device  is  in Sleep  mode  (Figure 19-8).  The  interrupt  condition  is cleared by reading the RCREGx register.\nThe WUE bit is automatically cleared once a low-to-high transition  is  observed  on  the  RXx  line  following  the wake-up event. At this point, the EUSART module is in Idle mode and returns to normal operation. This signals to the user that the Sync Break event is over.",
    "19.2.4.1 Special Considerations Using Auto-Wake-up\nSince  auto-wake-up  functions  by  sensing  rising  edge transitions  on  RXx/DTx,  information  with  any  state changes before the Stop bit may signal a false end-of- character  and  cause  data  or  framing  errors.  To  work properly,  therefore,  the  initial  character  in  the  transmission must be all ' 0 's. This can be 00h (8 bytes) for standard RS-232 devices, or 000h (12 bits) for LIN bus.\nOscillator start-up time must  also  be  considered, especially in applications using oscillators with longer start-up  intervals  (i.e.,  XT  or  HS  mode).  The  Sync Break (or Wake-up Signal) character must be of sufficient length and be followed by a sufficient interval to allow  enough  time  for  the  selected  oscillator  to  start and provide proper initialization of the EUSART.",
    "19.2.4.2 Special Considerations Using the WUE Bit\nThe timing of WUE and RCxIF events may cause some confusion when it comes to determining the validity of received data. As noted, setting the WUE bit places the EUSART in an Idle mode. The wake-up event causes a receive interrupt by setting the RCxIF bit. The WUE bit is cleared after this when a rising edge is seen on RXx/DTx.  The  interrupt  condition  is  then  cleared  by reading the  RCREGx register.  Ordinarily,  the  data  in RCREGx will be dummy data and should be discarded.\nThe fact that the WUE bit has been cleared (or is still set) and the RCxIF flag is set should not be used as an indicator of the integrity of the data in RCREGx. Users should  consider  implementing  a  parallel  method  in firmware to verify received data integrity.\nTo assure that no actual data is lost, check the RCIDL bit to verify that a receive operation is not in process. If a receive operation is not occurring, the WUE bit may then be set just prior to entering the Sleep mode.",
    "FIGURE 19-8: AUTO-WAKE-UP BIT (WUE) TIMINGS DURING SLEEP\nNote 1: If the wake-up event requires long oscillator warm-up time, the auto-clear of the WUE bit can occur while the stposc signal is still active. This sequence should not depend on the presence of Q clocks.\n- 2: The EUSART remains in Idle while the WUE bit is set.",
    "19.2.5 BREAK CHARACTER SEQUENCE\n- 1. Configure the EUSART for the desired mode.\nThe  Enhanced  USART  module  has  the  capability  of sending  the  special  Break  character  sequences  that are  required  by  the  LIN  bus  standard.  The  Break character transmit consists of a Start bit, followed by twelve ' 0 ' bits and a Stop bit. The frame Break character is sent  whenever  the  SENDB  and  TXEN  bits (TXSTAx<3>  and  TXSTAx<5>)  are  set  while  the Transmit Shift register is loaded with data. Note that the value of data written to TXREGx will be ignored and all ' 0 's will be transmitted.\nThe SENDB bit is automatically reset by hardware after the corresponding Stop bit is sent. This allows the user to preload the transmit FIFO with the next transmit byte following the Break  character  (typically, the Sync character in the LIN specification).\nNote that the data value written to the TXREGx for the Break character is ignored. The write simply serves the purpose of initiating the proper sequence.\nThe TRMT bit indicates when the transmit operation is active or Idle, just as it does during normal transmission.  See  Figure 19-9  for  the  timing  of  the  Break character sequence.",
    "19.2.5.1 Break and Sync Transmit Sequence\nThe  following  sequence  will  send  a  message  frame header made up of a Break, followed by an auto-baud Sync  byte.  This  sequence  is  typical  of  a  LIN  bus master.\n2. Set  the  TXEN  and  SENDB  bits  to  set  up  the Break character.\n3. Load the TXREGx with a dummy character to initiate transmission (the value is ignored).\n4. Write '55h' to TXREGx  to  load the Sync character into the transmit FIFO buffer.\n5. After the Break has been sent, the SENDB bit is reset  by  hardware.  The  Sync  character  now transmits in the preconfigured mode.\nWhen the TXREGx becomes empty, as indicated by the  TXxIF,  the  next  data  byte  can  be  written  to TXREGx.",
    "19.2.6 RECEIVING A BREAK CHARACTER\nThe  Enhanced  USART  module can  receive  a  Break character in two ways.\nThe first method forces configuration of the baud rate at a frequency of 9/13 the typical speed. This allows for the  Stop  bit  transition  to  be  at  the  correct  sampling location (13 bits for Break versus Start bit and 8 data bits for typical data).\nThe  second  method  uses  the  Auto-Wake-up  feature described in Section 19.2.4 'Auto-Wake-up on Sync Break  Character' . By enabling this feature, the EUSART will sample the next two transitions on RXx/ DTx, cause an RCxIF interrupt and  receive  the next data byte followed by another interrupt.\nNote  that  following  a  Break  character,  the  user  will typically  want  to  enable  the  Auto-Baud  Rate  Detect feature. For both methods, the user can set the ABD bit once the TXxIF interrupt is observed.",
    "19.3 EUSART Synchronous Master Mode\nThe Synchronous Master mode is entered by setting the CSRC bit (TXSTAx<7>). In this mode, the data is transmitted in a half-duplex manner (i.e., transmission and reception do not occur at the same time). When transmitting  data,  the  reception  is  inhibited  and  vice versa.  Synchronous  mode  is  entered  by  setting  bit SYNC  (TXSTAx<4>).  In  addition,  enable  bit  SPEN (RCSTAx<7>) is set in order to configure the TXx and RXx  pins to CKx  (clock) and DTx  (data) lines, respectively.\nThe Master mode indicates that the processor transmits the master clock on the CKx line. Clock polarity is selected with the SCKP bit (BAUDCONx<4>); setting SCKP sets the Idle state on CKx as high, while clearing the bit sets the Idle state as low. This option is provided to support Microwire devices with this module.",
    "19.3.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\nOnce the TXREGx register transfers  the  data  to  the TSR register (occurs in one TCYCLE), the TXREGx is empty and interrupt bit TXxIF is set. The interrupt can be  enabled/disabled  by  setting/clearing  enable  bit TXxIE. Flag bit TXxIF will be set regardless of the state of enable bit TXxIE and cannot be cleared in software. It  will  reset  only  when  new  data  is  loaded  into  the TXREGx register.\nWhile flag bit TXxIF indicates the status of the TXREGx register,  another  bit,  TRMT  (TXSTAx<1>),  shows  the status of the TSR register. TRMT is a read-only bit which is set when the TSR is empty. No interrupt logic is tied to this bit so the user has to poll this bit in order to determine  if  the  TSR  register  is  empty.  The  TSR  is  not mapped in data memory so it is not available to the user.\nTo set up a Synchronous Master Transmission:",
    "19.3.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\n- 1. Initialize  the  SPBRGHx:SPBRGx  registers  for the  appropriate  baud  rate.  Set  or  clear  the BRG16 bit, as required, to achieve the desired baud rate.\nThe  EUSART transmitter  block  diagram  is  shown  in Figure 19-2. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The Shift register obtains its data from the Read/Write Transmit Buffer register, TXREGx. The TXREGx register is loaded with data in software. The TSR register is not loaded until the last bit  has  been  transmitted  from  the  previous  load.  As soon as the last bit is transmitted, the TSR is loaded with new data from the TXREGx (if available).",
    "19.3.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN and CSRC.\n3. If interrupts are desired, set enable bit TXxIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable the transmission by setting bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREGx register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 19-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR,",
    "TABLE 19-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nBOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP.",
    "TABLE 19-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nIPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = TMR4IF. PIR3, Bit 2 = CCP5IF. PIR3, Bit 1 = CCP4IF. PIR3, Bit 0 = CCP3IF. PIR3, Value on POR, BOR = --00. PIR3, Value on POR, BOR = 0000. PIR3, Value on all other Resets = --00. PIR3, Value on all other Resets = 0000.",
    "TABLE 19-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nPIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 = TMR4IE. PIE3, Bit 2 = CCP5IE. PIE3, Bit 1 = CCP4IE. PIE3, Bit 0 = CCP3IE. PIE3, Value on POR, BOR = --00. PIE3, Value on POR, BOR = 0000. PIE3, Value on all other Resets = --00. PIE3, Value on all other Resets = 0000. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = TMR4IP. IPR3, Bit 2 = CCP5IP. IPR3, Bit 1 = CCP4IP. IPR3, Bit 0 = CCP3IP. IPR3, Value on POR, BOR = --11.",
    "TABLE 19-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nIPR3, Value on POR, BOR = 1111. IPR3, Value on all other Resets = --11. IPR3, Value on all other Resets = 1111. RCSTAx, Bit 7 = SPEN. RCSTAx, Bit 6 = RX9. RCSTAx, Bit 5 = SREN. RCSTAx, Bit 4 = CREN. RCSTAx, Bit 3 = ADDEN. RCSTAx, Bit 2 = FERR. RCSTAx, Bit 1 = OERR. RCSTAx, Bit 0 = RX9D. RCSTAx, Value on POR, BOR = 0000. RCSTAx, Value on POR, BOR = 000x. RCSTAx, Value on all other Resets = 0000. RCSTAx, Value on all other Resets = 000x. TXREGx, Bit 7 = Enhanced USARTx Transmit Register. TXREGx, Bit 6 = Enhanced USARTx Transmit Register. TXREGx, Bit 5 = Enhanced USARTx Transmit Register. TXREGx, Bit 4 = Enhanced USARTx Transmit",
    "TABLE 19-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nRegister. TXREGx, Bit 3 = Enhanced USARTx Transmit Register. TXREGx, Bit 2 = Enhanced USARTx Transmit Register. TXREGx, Bit 1 = Enhanced USARTx Transmit Register. TXREGx, Bit 0 = Enhanced USARTx Transmit Register. TXREGx, Value on POR, BOR = 0000. TXREGx, Value on POR, BOR = 0000. TXREGx, Value on all other Resets = 0000. TXREGx, Value on all other Resets = 0000. TXSTAx, Bit 7 = CSRC. TXSTAx, Bit 6 = TX9. TXSTAx, Bit 5 = TXEN. TXSTAx, Bit 4 = SYNC. TXSTAx, Bit 3 = SENDB. TXSTAx, Bit 2 = BRGH. TXSTAx, Bit 1 = TRMT. TXSTAx, Bit 0 = TX9D. TXSTAx, Value on POR, BOR = 0000. TXSTAx, Value on POR, BOR = 0010. TXSTAx, Value on all other Resets =",
    "TABLE 19-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\n0000. TXSTAx, Value on all other Resets = 0010. BAUDCONx, Bit 7 = -. BAUDCONx, Bit 6 = RCIDL. BAUDCONx, Bit 5 = -. BAUDCONx, Bit 4 = SCKP. BAUDCONx, Bit 3 = BRG16. BAUDCONx, Bit 2 = -. BAUDCONx, Bit 1 = WUE. BAUDCONx, Bit 0 = ABDEN. BAUDCONx, Value on POR, BOR = -1-0. BAUDCONx, Value on POR, BOR = 0-00. BAUDCONx, Value on all other Resets = -1-0. BAUDCONx, Value on all other Resets = 0-00. SPBRGHx, Bit 7 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 6 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 5 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 4 = Enhanced",
    "TABLE 19-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nUSARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 3 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 2 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 1 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 0 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGx, Bit 7 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 6 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 5 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 4 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 3 = Enhanced",
    "TABLE 19-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nUSARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 2 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 1 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 0 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on all other Resets = 0000. SPBRGx, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master transmission.\nNote 1:\n- Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "19.3.2 EUSART SYNCHRONOUS MASTER RECEPTION\nOnce  Synchronous  mode  is  selected,  reception  is enabled by setting either the Single Receive Enable bit, SREN  (RCSTAx<5>),  or  the  Continuous  Receive Enable bit, CREN (RCSTAx<4>). Data is sampled on the RXx pin on the falling edge of the clock.\nIf enable bit SREN is set, only a single word is received. If enable bit CREN is set, the reception is continuous until CREN is cleared. If both bits are set, then CREN takes precedence.\nTo set up a Synchronous Master Reception:",
    "19.3.2 EUSART SYNCHRONOUS MASTER RECEPTION\n1. Initialize  the  SPBRGHx:SPBRGx  registers  for the  appropriate  baud  rate.  Set  or  clear  the BRG16 bit, as required, to achieve the desired baud rate.\n3. Ensure bits CREN and SREN are clear.\n4. If interrupts are desired, set enable bit RCxIE.\n5. If 9-bit reception is desired, set bit RX9.\n6. If  a  single reception is required, set bit SREN. For continuous reception, set bit CREN.\n7. Interrupt flag bit RCxIF will be set when reception  is  complete  and  an  interrupt  will  be generated if the enable bit RCxIE was set.\n8. Read the RCSTAx register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n9. Read  the  8-bit  received  data  by  reading  the RCREGx register.\n10. If any error occurred, clear the error by clearing bit CREN.\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN and CSRC.",
    "19.3.2 EUSART SYNCHRONOUS MASTER RECEPTION\n11. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 19-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR,",
    "TABLE 19-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nBOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP.",
    "TABLE 19-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nIPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = TMR4IF. PIR3, Bit 2 = CCP5IF. PIR3, Bit 1 = CCP4IF. PIR3, Bit 0 = CCP3IF. PIR3, Value on POR, BOR = --00. PIR3, Value on POR, BOR = 0000. PIR3, Value on all other Resets = --00. PIR3, Value on all other Resets = 0000.",
    "TABLE 19-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nPIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 = TMR4IE. PIE3, Bit 2 = CCP5IE. PIE3, Bit 1 = CCP4IE. PIE3, Bit 0 = CCP3IE. PIE3, Value on POR, BOR = --00. PIE3, Value on POR, BOR = 0000. PIE3, Value on all other Resets = --00. PIE3, Value on all other Resets = 0000. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = TMR4IP. IPR3, Bit 2 = CCP5IP. IPR3, Bit 1 = CCP4IP. IPR3, Bit 0 = CCP3IP. IPR3, Value on POR, BOR = --11.",
    "TABLE 19-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nIPR3, Value on POR, BOR = 1111. IPR3, Value on all other Resets = --11. IPR3, Value on all other Resets = 1111. RCSTAx, Bit 7 = SPEN. RCSTAx, Bit 6 = RX9. RCSTAx, Bit 5 = SREN. RCSTAx, Bit 4 = CREN. RCSTAx, Bit 3 = ADDEN. RCSTAx, Bit 2 = FERR. RCSTAx, Bit 1 = OERR. RCSTAx, Bit 0 = RX9D. RCSTAx, Value on POR, BOR = 0000. RCSTAx, Value on POR, BOR = 000x. RCSTAx, Value on all other Resets = 0000. RCSTAx, Value on all other Resets = 000x. RCREGx, Bit 7 = Enhanced USARTx Receive Register. RCREGx, Bit 6 = Enhanced USARTx Receive Register. RCREGx, Bit 5 = Enhanced USARTx Receive Register. RCREGx, Bit 4 = Enhanced USARTx Receive",
    "TABLE 19-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nRegister. RCREGx, Bit 3 = Enhanced USARTx Receive Register. RCREGx, Bit 2 = Enhanced USARTx Receive Register. RCREGx, Bit 1 = Enhanced USARTx Receive Register. RCREGx, Bit 0 = Enhanced USARTx Receive Register. RCREGx, Value on POR, BOR = 0000. RCREGx, Value on POR, BOR = 0000. RCREGx, Value on all other Resets = 0000. RCREGx, Value on all other Resets = 0000. TXSTAx, Bit 7 = CSRC. TXSTAx, Bit 6 = TX9. TXSTAx, Bit 5 = TXEN. TXSTAx, Bit 4 = SYNC. TXSTAx, Bit 3 = SENDB. TXSTAx, Bit 2 = BRGH. TXSTAx, Bit 1 = TRMT. TXSTAx, Bit 0 = TX9D. TXSTAx, Value on POR, BOR = 0000. TXSTAx, Value on POR, BOR = 0010. TXSTAx, Value on all other Resets =",
    "TABLE 19-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\n0000. TXSTAx, Value on all other Resets = 0010. BAUDCONx, Bit 7 = -. BAUDCONx, Bit 6 = RCIDL. BAUDCONx, Bit 5 = -. BAUDCONx, Bit 4 = SCKP. BAUDCONx, Bit 3 = BRG16. BAUDCONx, Bit 2 = -. BAUDCONx, Bit 1 = WUE. BAUDCONx, Bit 0 = ABDEN. BAUDCONx, Value on POR, BOR = -1-0. BAUDCONx, Value on POR, BOR = 0-00. BAUDCONx, Value on all other Resets = -1-0. BAUDCONx, Value on all other Resets = 0-00. SPBRGHx, Bit 7 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 6 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 5 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 4 = Enhanced",
    "TABLE 19-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nUSARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 3 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 2 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 1 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 0 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGx, Bit 7 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 6 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 5 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 4 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 3 = Enhanced",
    "TABLE 19-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nUSARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 2 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 1 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 0 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on all other Resets = 0000. SPBRGx, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master reception.\nNote 1: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "19.4 EUSART Synchronous Slave Mode\nSynchronous  Slave  mode  is  entered  by  clearing  bit CSRC (TXSTAx<7>). This mode differs from the Synchronous Master mode in that the shift clock is supplied externally  at  the  CKx  pin  (instead  of  being  supplied internally  in  Master mode). This allows the device to transfer or receive data while in any low-power mode.",
    "19.4.1 EUSART SYNCHRONOUS SLAVE TRANSMIT\nThe operation of the Synchronous Master and Slave modes are identical except in the  case  of  the  Sleep mode.\nIf  two words are written to the TXREGx and then the SLEEP instruction is executed, the following will occur:\na) The  first  word  will  immediately  transfer  to  the TSR register and transmit.\nb) The  second  word  will  remain  in  the  TXREGx register.\nc) Flag bit TXxIF will not be set.\nd) When the first word has been shifted out of TSR, the  TXREGx  register  will  transfer  the  second word to the TSR and flag bit TXxIF will now be set.\ne) If enable bit TXxIE is set, the interrupt will wake the  chip  from  Sleep.  If  the  global  interrupt  is enabled, the program will branch to the interrupt vector.",
    "TABLE 19-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR,",
    "TABLE 19-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nBOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP.",
    "TABLE 19-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nIPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = TMR4IF. PIR3, Bit 2 = CCP5IF. PIR3, Bit 1 = CCP4IF. PIR3, Bit 0 = CCP3IF. PIR3, Value on POR, BOR = --00. PIR3, Value on POR, BOR = 0000. PIR3, Value on all other Resets = --00. PIR3, Value on all other Resets = 0000.",
    "TABLE 19-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nPIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 = TMR4IE. PIE3, Bit 2 = CCP5IE. PIE3, Bit 1 = CCP4IE. PIE3, Bit 0 = CCP3IE. PIE3, Value on POR, BOR = --00. PIE3, Value on POR, BOR = 0000. PIE3, Value on all other Resets = --00. PIE3, Value on all other Resets = 0000. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = TMR4IP. IPR3, Bit 2 = CCP5IP. IPR3, Bit 1 = CCP4IP. IPR3, Bit 0 = CCP3IP. IPR3, Value on POR, BOR = --11.",
    "TABLE 19-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nIPR3, Value on POR, BOR = 1111. IPR3, Value on all other Resets = --11. IPR3, Value on all other Resets = 1111. RCSTAx, Bit 7 = SPEN. RCSTAx, Bit 6 = RX9. RCSTAx, Bit 5 = SREN. RCSTAx, Bit 4 = CREN. RCSTAx, Bit 3 = ADDEN. RCSTAx, Bit 2 = FERR. RCSTAx, Bit 1 = OERR. RCSTAx, Bit 0 = RX9D. RCSTAx, Value on POR, BOR = 0000. RCSTAx, Value on POR, BOR = 000x. RCSTAx, Value on all other Resets = 0000. RCSTAx, Value on all other Resets = 000x. TXREGx, Bit 7 = Enhanced USARTx Transmit Register. TXREGx, Bit 6 = Enhanced USARTx Transmit Register. TXREGx, Bit 5 = Enhanced USARTx Transmit Register. TXREGx, Bit 4 = Enhanced USARTx Transmit",
    "TABLE 19-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nRegister. TXREGx, Bit 3 = Enhanced USARTx Transmit Register. TXREGx, Bit 2 = Enhanced USARTx Transmit Register. TXREGx, Bit 1 = Enhanced USARTx Transmit Register. TXREGx, Bit 0 = Enhanced USARTx Transmit Register. TXREGx, Value on POR, BOR = 0000. TXREGx, Value on POR, BOR = 0000. TXREGx, Value on all other Resets = 0000. TXREGx, Value on all other Resets = 0000. TXSTAx, Bit 7 = CSRC. TXSTAx, Bit 6 = TX9. TXSTAx, Bit 5 = TXEN. TXSTAx, Bit 4 = SYNC. TXSTAx, Bit 3 = SENDB. TXSTAx, Bit 2 = BRGH. TXSTAx, Bit 1 = TRMT. TXSTAx, Bit 0 = TX9D. TXSTAx, Value on POR, BOR = 0000. TXSTAx, Value on POR, BOR = 0010. TXSTAx, Value on all other Resets =",
    "TABLE 19-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n0000. TXSTAx, Value on all other Resets = 0010. BAUDCONx, Bit 7 = -. BAUDCONx, Bit 6 = RCIDL. BAUDCONx, Bit 5 = -. BAUDCONx, Bit 4 = SCKP. BAUDCONx, Bit 3 = BRG16. BAUDCONx, Bit 2 = -. BAUDCONx, Bit 1 = WUE. BAUDCONx, Bit 0 = ABDEN. BAUDCONx, Value on POR, BOR = -1-0. BAUDCONx, Value on POR, BOR = 0-00. BAUDCONx, Value on all other Resets = -1-0. BAUDCONx, Value on all other Resets = 0-00. SPBRGHx, Bit 7 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 6 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 5 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 4 = Enhanced",
    "TABLE 19-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nUSARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 3 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 2 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 1 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 0 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGx, Bit 7 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 6 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 5 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 4 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 3 = Enhanced",
    "TABLE 19-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nUSARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 2 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 1 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 0 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on all other Resets = 0000. SPBRGx, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave transmission.\nNote\n- 1: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.\nTo set up a Synchronous Slave Transmission:",
    "TABLE 19-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n1. Enable  the  synchronous  slave  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. Clear bits CREN and SREN.\n3. If interrupts are desired, set enable bit TXxIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable  the  transmission  by  setting  enable  bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREGx register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "19.4.2 EUSART SYNCHRONOUS SLAVE RECEPTION\nTo set up a Synchronous Slave Reception:\nThe operation of the Synchronous Master and Slave modes is identical except in the case of Sleep or any Idle  mode  and  bit  SREN,  which  is  a  'don't  care'  in Slave mode.\nIf  receive is enabled by setting the CREN bit prior to entering Sleep or any Idle mode, then a word may be received while in this Low-Power mode. Once the word is received, the RSR register will transfer the data to the RCREGx register; if the RC1IE enable bit is set, the interrupt generated will wake the chip from Low-Power mode. If the global interrupt is enabled, the program will branch to the interrupt vector.",
    "19.4.2 EUSART SYNCHRONOUS SLAVE RECEPTION\n1. Enable  the  synchronous  master  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. If interrupts are desired, set enable bit RCxIE.\n3. If 9-bit reception is desired, set bit RX9.\n4. To enable reception, set enable bit CREN.\n5. Flag bit RCxIF will be set when reception is complete. An interrupt will be generated if enable bit RCxIE was set.\n6. Read the RCSTAx register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n7. Read  the  8-bit  received  data  by  reading  the RCREGx register.\n8. If any error occurred, clear the error by clearing bit CREN.\n9. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 19-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR,",
    "TABLE 19-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nBOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP.",
    "TABLE 19-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nIPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = TMR4IF. PIR3, Bit 2 = CCP5IF. PIR3, Bit 1 = CCP4IF. PIR3, Bit 0 = CCP3IF. PIR3, Value on POR, BOR = --00. PIR3, Value on POR, BOR = 0000. PIR3, Value on all other Resets = --00. PIR3, Value on all other Resets = 0000.",
    "TABLE 19-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nPIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 = TMR4IE. PIE3, Bit 2 = CCP5IE. PIE3, Bit 1 = CCP4IE. PIE3, Bit 0 = CCP3IE. PIE3, Value on POR, BOR = --00. PIE3, Value on POR, BOR = 0000. PIE3, Value on all other Resets = --00. PIE3, Value on all other Resets = 0000. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = TMR4IP. IPR3, Bit 2 = CCP5IP. IPR3, Bit 1 = CCP4IP. IPR3, Bit 0 = CCP3IP. IPR3, Value on POR, BOR = --11.",
    "TABLE 19-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nIPR3, Value on POR, BOR = 1111. IPR3, Value on all other Resets = --11. IPR3, Value on all other Resets = 1111. RCSTAx, Bit 7 = SPEN. RCSTAx, Bit 6 = RX9. RCSTAx, Bit 5 = SREN. RCSTAx, Bit 4 = CREN. RCSTAx, Bit 3 = ADDEN. RCSTAx, Bit 2 = FERR. RCSTAx, Bit 1 = OERR. RCSTAx, Bit 0 = RX9D. RCSTAx, Value on POR, BOR = 0000. RCSTAx, Value on POR, BOR = 000x. RCSTAx, Value on all other Resets = 0000. RCSTAx, Value on all other Resets = 000x. RCREGx, Bit 7 = Enhanced USARTx Receive Register. RCREGx, Bit 6 = Enhanced USARTx Receive Register. RCREGx, Bit 5 = Enhanced USARTx Receive Register. RCREGx, Bit 4 = Enhanced USARTx Receive",
    "TABLE 19-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nRegister. RCREGx, Bit 3 = Enhanced USARTx Receive Register. RCREGx, Bit 2 = Enhanced USARTx Receive Register. RCREGx, Bit 1 = Enhanced USARTx Receive Register. RCREGx, Bit 0 = Enhanced USARTx Receive Register. RCREGx, Value on POR, BOR = 0000. RCREGx, Value on POR, BOR = 0000. RCREGx, Value on all other Resets = 0000. RCREGx, Value on all other Resets = 0000. TXSTAx, Bit 7 = CSRC. TXSTAx, Bit 6 = TX9. TXSTAx, Bit 5 = TXEN. TXSTAx, Bit 4 = SYNC. TXSTAx, Bit 3 = SENDB. TXSTAx, Bit 2 = BRGH. TXSTAx, Bit 1 = TRMT. TXSTAx, Bit 0 = TX9D. TXSTAx, Value on POR, BOR = 0000. TXSTAx, Value on POR, BOR = 0010. TXSTAx, Value on all other Resets =",
    "TABLE 19-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\n0000. TXSTAx, Value on all other Resets = 0010. BAUDCONx, Bit 7 = -. BAUDCONx, Bit 6 = RCIDL. BAUDCONx, Bit 5 = -. BAUDCONx, Bit 4 = SCKP. BAUDCONx, Bit 3 = BRG16. BAUDCONx, Bit 2 = -. BAUDCONx, Bit 1 = WUE. BAUDCONx, Bit 0 = ABDEN. BAUDCONx, Value on POR, BOR = -1-0. BAUDCONx, Value on POR, BOR = 0-00. BAUDCONx, Value on all other Resets = -1-0. BAUDCONx, Value on all other Resets = 0-00. SPBRGHx, Bit 7 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 6 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 5 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 4 = Enhanced",
    "TABLE 19-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nUSARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 3 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 2 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 1 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Bit 0 = Enhanced USARTx Baud Rate Generator Register High Byte. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on POR, BOR = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGHx, Value on all other Resets = 0000. SPBRGx, Bit 7 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 6 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 5 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 4 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 3 = Enhanced",
    "TABLE 19-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nUSARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 2 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 1 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Bit 0 = Enhanced USARTx Baud Rate Generator Register Low Byte. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on POR, BOR = 0000. SPBRGx, Value on all other Resets = 0000. SPBRGx, Value on all other Resets = 0000\nLegend:\nx\n= unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave reception.\nNote 1:\nEnabled only in Microcontroller mode for PIC18F8525/8621 devices.",
    "20.0 10-BIT ANALOG-TO-DIGITAL CONVERTER (A/D) MODULE\nThe  analog-to-digital (A/D) converter module  has 12 inputs for the PIC18F6525/6621 devices and 16 for the  PIC18F8525/8621  devices.  This  module  allows conversion of an analog input signal to a corresponding 10-bit digital number.\nThe module has five registers:\n\u00b7 A/D Result High Register (ADRESH)\n\u00b7 A/D Result Low Register (ADRESL)\n\u00b7 A/D Control Register 0 (ADCON0)\n\u00b7 A/D Control Register 1 (ADCON1)\n\u00b7 A/D Control Register 2 (ADCON2)\nA new feature for the A/D converter is the addition of programmable acquisition time. This feature allows the user to select a new channel for conversion and setting the GO/DONE bit immediately. When the GO/DONE bit is set, the selected channel is sampled for the programmed  acquisition  time  before  a  conversion  is actually  started.  This  removes  the  firmware  overhead that may have been required to allow for an acquisition (sampling) period (see Register 20-3 and Section 20.5 'A/D Conversions' ).",
    "20.0 10-BIT ANALOG-TO-DIGITAL CONVERTER (A/D) MODULE\nThe ADCON0 register, shown in Register 20-1, controls the operation of the A/D module. The ADCON1 register, shown in Register 20-2, configures the functions of the port pins. The ADCON2 register, shown  in  Register 20-3,  configures  the  A/D  clock source, justification and auto-acquisition time.",
    "REGISTER 20-1: ADCON0: A/D CONTROL REGISTER 0\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = CHS3. -, 3 = CHS2. -, 4 = CHS1. -, 5 = CHS0. -, 6 = GO/DONE. -, 7 = ADON\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-2 CHS3:CHS0: Analog Channel Select bits\n0000 = Channel 0 (AN0)\n0001 = Channel 1 (AN1)\n0010 = Channel 2 (AN2)\n0011 = Channel 3 (AN3)\n0100 = Channel 4 (AN4)\n0101 = Channel 5 (AN5)\n0110 = Channel 6 (AN6)\n0111 = Channel 7 (AN7)",
    "REGISTER 20-1: ADCON0: A/D CONTROL REGISTER 0\n1000 = Channel 8 (AN8)\n1001 = Channel 9 (AN9)\n1010 = Channel 10 (AN10)\n1011 = Channel 11 (AN11)\n1100 = Channel 12 (AN12) (1)\n1101 = Channel 13 (AN13) (1)\n1110 = Channel 14 (AN14) (1)\n1111 = Channel 15 (AN15) (1)\nNote 1: These channels are not available on the PIC18F6525/6621 (64-pin) devices.",
    "bit 1 GO/DONE: A/D Conversion Status bit\nWhen ADON = 1 :\n- 1 = A/D conversion in progress (setting this bit starts the A/D conversion which is automatically cleared by hardware when the A/D conversion is complete)\n0 = A/D conversion not in progress\nADON: A/D On bit\n1 = A/D converter module is enabled\n0 = A/D converter module is disabled",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "ADCON1: A/D CONTROL REGISTER 1\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = VCFG1. -, 3 = VCFG0. -, 4 = PCFG3. -, 5 = PCFG2. -, 6 = PCFG1. -, 7 = PCFG0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-4 VCFG1:VCFG0: Voltage Reference Configuration bits:",
    "ADCON1: A/D CONTROL REGISTER 1\n00, A/D VREF+ = AVDD. 00, A/D VREF- = AVSS. 01, A/D VREF+ = External VREF+. 01, A/D VREF- = AVSS. 10, A/D VREF+ = AVDD. 10, A/D VREF- = External VREF-. 11, A/D VREF+ = External VREF+. 11, A/D VREF- = External VREF-\nbit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits:",
    "ADCON1: A/D CONTROL REGISTER 1\n0000, AN15 = A. 0000, AN14 = A. 0000, AN13 = A. 0000, AN12 = A. 0000, AN11 = A. 0000, AN10 = A. 0000, AN9 = A. 0000, AN8 = A. 0000, AN7 = A. 0000, AN6 = A. 0000, AN5 = A. 0000, AN4 = A. 0000, AN3 = A. 0000, AN2 = A. 0000, AN1 = A. 0000, AN0 = A. 0001, AN15 = D. 0001, AN14 = D. 0001, AN13 = A. 0001, AN12 = A. 0001, AN11 = A. 0001, AN10 = A. 0001, AN9 = A. 0001, AN8 = A. 0001, AN7 = A. 0001, AN6 = A. 0001, AN5 = A. 0001, AN4 = A. 0001, AN3 = A. 0001, AN2 = A. 0001, AN1 =",
    "ADCON1: A/D CONTROL REGISTER 1\nA. 0001, AN0 = A. 0010, AN15 = D. 0010, AN14 = D. 0010, AN13 = D. 0010, AN12 = A. 0010, AN11 = A. 0010, AN10 = A. 0010, AN9 = A. 0010, AN8 = A. 0010, AN7 = A. 0010, AN6 = A. 0010, AN5 = A. 0010, AN4 = A. 0010, AN3 = A. 0010, AN2 = A. 0010, AN1 = A. 0010, AN0 = A. 0011, AN15 = D. 0011, AN14 = D. 0011, AN13 = D. 0011, AN12 = D. 0011, AN11 = A. 0011, AN10 = A. 0011, AN9 = A. 0011, AN8 = A. 0011, AN7 = A. 0011, AN6 = A. 0011, AN5 = A. 0011, AN4 = A. 0011, AN3 = A. 0011,",
    "ADCON1: A/D CONTROL REGISTER 1\nAN2 = A. 0011, AN1 = A. 0011, AN0 = A. 0100, AN15 = D. 0100, AN14 = D. 0100, AN13 = D. 0100, AN12 = D. 0100, AN11 = D. 0100, AN10 = A. 0100, AN9 = A. 0100, AN8 = A. 0100, AN7 = A. 0100, AN6 = A. 0100, AN5 = A. 0100, AN4 = A. 0100, AN3 = A. 0100, AN2 = A. 0100, AN1 = A. 0100, AN0 = A. 0101, AN15 = D. 0101, AN14 = D. 0101, AN13 = D. 0101, AN12 = D. 0101, AN11 = D. 0101, AN10 = D. 0101, AN9 = A. 0101, AN8 = A. 0101, AN7 = A. 0101, AN6 = A. 0101, AN5 = A. 0101, AN4 = A.",
    "ADCON1: A/D CONTROL REGISTER 1\n0101, AN3 = A. 0101, AN2 = A. 0101, AN1 = A. 0101, AN0 = A. 0110, AN15 = D. 0110, AN14 = D. 0110, AN13 = D. 0110, AN12 = D. 0110, AN11 = D. 0110, AN10 = D. 0110, AN9 = D. 0110, AN8 = A. 0110, AN7 = A. 0110, AN6 = A. 0110, AN5 = A. 0110, AN4 = A. 0110, AN3 = A. 0110, AN2 = A. 0110, AN1 = A. 0110, AN0 = A. 0111, AN15 = D. 0111, AN14 = D. 0111, AN13 = D. 0111, AN12 = D. 0111, AN11 = D. 0111, AN10 = D. 0111, AN9 = D. 0111, AN8 = D. 0111, AN7 = A. 0111, AN6 = A. 0111, AN5 =",
    "ADCON1: A/D CONTROL REGISTER 1\nA. 0111, AN4 = A. 0111, AN3 = A. 0111, AN2 = A. 0111, AN1 = A. 0111, AN0 = A. 1000, AN15 = D. 1000, AN14 = D. 1000, AN13 = D. 1000, AN12 = D. 1000, AN11 = D. 1000, AN10 = D. 1000, AN9 = D. 1000, AN8 = D. 1000, AN7 = D. 1000, AN6 = A. 1000, AN5 = A. 1000, AN4 = A. 1000, AN3 = A. 1000, AN2 = A. 1000, AN1 = A. 1000, AN0 = A. 1001, AN15 = D. 1001, AN14 = D. 1001, AN13 = D. 1001, AN12 = D. 1001, AN11 = D. 1001, AN10 = D. 1001, AN9 = D. 1001, AN8 = D. 1001, AN7 = D. 1001, AN6 = D. 1001, AN5 = A. 1001,",
    "ADCON1: A/D CONTROL REGISTER 1\nAN4 = A. 1001, AN3 = A. 1001, AN2 = A. 1001, AN1 = A. 1001, AN0 = A. 1010, AN15 = D. 1010, AN14 = D. 1010, AN13 = D. 1010, AN12 = D. 1010, AN11 = D. 1010, AN10 = D. 1010, AN9 = D. 1010, AN8 = D. 1010, AN7 = D. 1010, AN6 = D. 1010, AN5 = D. 1010, AN4 = A. 1010, AN3 = A. 1010, AN2 = A. 1010, AN1 = A. 1010, AN0 = A. 1011, AN15 = D. 1011, AN14 = D. 1011, AN13 = D. 1011, AN12 = D. 1011, AN11 = D. 1011, AN10 = D. 1011, AN9 = D. 1011, AN8 = D. 1011, AN7 = D. 1011, AN6 = D.",
    "ADCON1: A/D CONTROL REGISTER 1\n1011, AN5 = D. 1011, AN4 = D. 1011, AN3 = A. 1011, AN2 = A. 1011, AN1 = A. 1011, AN0 = A. 1100, AN15 = D. 1100, AN14 = D. 1100, AN13 = D. 1100, AN12 = D. 1100, AN11 = D. 1100, AN10 = D. 1100, AN9 = D. 1100, AN8 = D. 1100, AN7 = D. 1100, AN6 = D. 1100, AN5 = D. 1100, AN4 = D. 1100, AN3 = D. 1100, AN2 = A. 1100, AN1 = A. 1100, AN0 = A. 1101, AN15 = D. 1101, AN14 = D. 1101, AN13 = D. 1101, AN12 = D. 1101, AN11 = D. 1101, AN10 = D. 1101, AN9 = D. 1101, AN8 = D. 1101, AN7 = D. 1101, AN6 = D. 1101, AN5 =",
    "ADCON1: A/D CONTROL REGISTER 1\nD. 1101, AN4 = D. 1101, AN3 = D. 1101, AN2 = D. 1101, AN1 = A. 1101, AN0 = A. 1110, AN15 = D. 1110, AN14 = D. 1110, AN13 = D. 1110, AN12 = D. 1110, AN11 = D. 1110, AN10 = D. 1110, AN9 = D. 1110, AN8 = D. 1110, AN7 = D. 1110, AN6 = D. 1110, AN5 = D. 1110, AN4 = D. 1110, AN3 = D. 1110, AN2 = D. 1110, AN1 = D. 1110, AN0 = A. 1111, AN15 = D. 1111, AN14 = D. 1111, AN13 = D. 1111, AN12 = D. 1111, AN11 = D. 1111, AN10 = D. 1111, AN9 = D. 1111, AN8 = D. 1111, AN7 = D. 1111,",
    "ADCON1: A/D CONTROL REGISTER 1\nAN6 = D. 1111, AN5 = D. 1111, AN4 = D. 1111, AN3 = D. 1111, AN2 = D. 1111, AN1 = D. 1111, AN0 = D\nA = Analog input        D = Digital I/O\nNote: Shaded cells indicate A/D channels available only on PIC18F8525/8621 devices.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "ADCON2: A/D CONTROL REGISTER 2\nR/W-0, 1 = U-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. ADFM, 1 = -. ADFM, 2 = ACQT2. ADFM, 3 = ACQT1. ADFM, 4 = ACQT0. ADFM, 5 = ADCS2. ADFM, 6 = ADCS1. ADFM, 7 = ADCS0\nbit 7\nbit 0",
    "bit 7\nADFM: A/D Result Format Select bit\n1 = Right justified\n0 = Left justified\nbit 6 Unimplemented: Read as ' 0 '\nbit 5-3\nACQT2:ACQT0: A/D Acquisition Time Select bits\n000 = 0 TAD (1)\n001 = 2 TAD\n010 = 4 TAD\n011 = 6 TAD\n100 = 8 TAD\n101 = 12 TAD\n110 = 16 TAD\n111 = 20 TAD",
    "bit 2-0 ADCS2:ADCS0: A/D Conversion Clock Select bits\n000 = FOSC/2\n001 = FOSC/8\n010 = FOSC/32\n011 = FRC (clock derived from A/D RC oscillator) (1)\n100 = FOSC/4\n101 = FOSC/16\n110 = FOSC/64\n111 = FRC (clock derived from A/D RC oscillator) (1)\nNote 1: If the A/D FRC clock source is selected, a delay of one TCY (instruction cycle) is added before the A/D clock starts. This allows the SLEEP instruction to be executed before starting a conversion.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "PIC18F6525/6621/8525/8621\nThe analog reference voltage is software selectable to either the device's positive and negative supply voltage (VDD and VSS), or the voltage level on the RA3/AN3/ VREF+ pin and RA2/AN2/VREF- pin.\nA device Reset forces all registers to their Reset state. This forces the A/D module to be turned off and any conversion is aborted.\nThe A/D converter has a unique feature of being able to  operate  while  the  device  is  in  Sleep  mode.  To operate  in  Sleep,  the  A/D  conversion  clock  must  be derived from the A/D's internal RC oscillator.\nThe output of the sample and hold is the input into the converter  which  generates  the  result  via  successive approximation.",
    "PIC18F6525/6621/8525/8621\nEach port pin associated with the A/D converter can be configured  as  an  analog  input  (RA3  can  also  be  a voltage  reference),  or  as  a  digital  I/O.  The  ADRESH and  ADRESL registers  contain  the  result  of  the  A/D conversion. When the A/D conversion is complete, the result is loaded into the ADRESH/ADRESL registers, the GO/DONE bit (ADCON0 register) is cleared and A/D interrupt flag bit, ADIF, is set. The block diagram of the A/D module is shown in Figure 20-1.\nThe value in the ADRESH/ADRESL  registers  is not modified  for  a  Power-on  Reset.  The  ADRESH/ ADRESL registers will  contain  unknown  data  after  a Power-on Reset.\nAfter the A/D module has been configured as desired, the  selected  channel  must  be  acquired  before  the conversion is started. The analog input channels must have  their  corresponding  TRIS  bits  selected  as  an input. To determine acquisition time, see Section 20.1 'A/D Acquisition Requirements' .  After this acquisition  time  has  elapsed,  the  A/D  conversion  can  be started.",
    "PIC18F6525/6621/8525/8621\nThe following steps should be followed to do an A/D conversion:\n1. Configure the A/D module:\n\u00b7 Configure analog pins, voltage reference and digital I/O (ADCON1)\n\u00b7 Select A/D input channel (ADCON0)\n\u00b7 Select A/D conversion clock (ADCON2)\n\u00b7 Turn on A/D module (ADCON0)",
    "FIGURE 20-2: ANALOG INPUT MODEL\n2. Configure A/D interrupt (if desired):\n\u00b7 Clear ADIF bit\n\u00b7 Set ADIE bit\n\u00b7 Set GIE bit\n3. Wait the required acquisition time (not required in case of auto-acquisition time).\n4. Start conversion:\n\u00b7 Set GO/DONE bit (ADCON0 register)\n5. Wait for A/D conversion to complete, by either: \u00b7 Polling for the GO/DONE bit to be cleared OR\n\u00b7 Waiting for the A/D interrupt\n6. Read A/D Result registers (ADRESH:ADRESL); clear bit ADIF, if required.\n7. For next conversion, go to step 1 or step 2, as required.  The  A/D  conversion  time  per  bit  is defined  as  TAD.  A  minimum  wait  of  2  TAD  is required before the next acquisition starts.",
    "20.1 A/D Acquisition Requirements\nFor the A/D converter to meet its specified accuracy, the charge holding capacitor (CHOLD) must be allowed to fully charge to the input channel voltage level. The analog  input  model  is  shown  in  Figure 20-2.  The source  impedance  (RS)  and  the  internal  sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (VDD). The source impedance affects the offset voltage at the analog input (due to pin leakage current). The maximum  recommended  impedance  for  analog sources is 2.5 k \uf057 .  After the analog input channel is selected  (changed),  this  acquisition  must  be  done before the conversion can be started.\nNote:, 1 = When the conversion is started, the hold- ing capacitor is disconnected from the input pin.",
    "EQUATION 20-1: ACQUISITION TIME\nTACQ, 1 = =. TACQ, 2 = Amplifier Settling Time + Holding Capacitor Charging Time + Temperature Coefficient. , 1 = =. , 2 = TAMP + TC + TCOFF",
    "EQUATION 20-2: A/D MINIMUM CHARGING TIME\nVHOLD or, 1 = =. VHOLD or, 2 = (V REF - (V REF /2048)) \u2022 (1 - e (-Tc/C HOLD(R IC + RSS + RS)) ). Tc, 1 = =. Tc, 2 = -(120 pF)(1 k \uf057 + RSS + RS) ln(1/2047)",
    "EQUATION 20-3: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\nTACQ, 1 = =. TACQ, 2 = TAMP + TC + TCOFF. Temperature coefficient is only required for temperatures > 25 \uf0b0 C., 1 = Temperature coefficient is only required for temperatures > 25 \uf0b0 C.. Temperature coefficient is only required for temperatures > 25 \uf0b0 C., 2 = Temperature coefficient is only required for temperatures > 25 \uf0b0 C.. TACQ, 1 = =. TACQ, 2 = 2 \uf06d s + TC + [(Temp - 25 \uf0b0 C)(0.05 \uf06d s/ \uf0b0 C)]. TC, 1 = =. TC, 2 = -C HOLD (R IC + RSS + RS) ln(1/2047) -120 pF (1 k \uf057 + 7 k \uf057 + 2.5 k \uf057 ) ln(0.0004885) -120 pF (10.5 k \uf057 ) ln(0.0004885) -1.26 \uf06d s (-7.6241) 9.61 \uf06d s. TACQ, 1 = =. TACQ, 2 = 2 \uf06d s + 9.61 \uf06d s + [(50 \uf0b0 C - 25 \uf0b0 C)(0.05 \uf06d s/ \uf0b0 C)] 11.61 \uf06d s",
    "EQUATION 20-3: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\n+ 1.25 \uf06d s 12.86 \uf06d s\nTo calculate the minimum acquisition time, Equation 20-1  may be  used.  This  equation  assumes that 1/2 LSb error is used (1024 steps for the A/D). The 1/2 LSb error is the maximum error allowed for the A/D to meet its specified resolution.\nExample 20-3 shows the calculation  of  the  minimum required  acquisition  time,  TACQ.  This  calculation  is based on the following application system assumptions:\nCHOLD\n= 120 pF\nRs\n= 2.5 k \uf057\uf020\nConversion Error\n\uf0a3 1/2 LSb\nVDD\n= 5V \uf0ae Rss = 7 k \uf057\nTemperature\n= 50 C (system max.) \uf0b0\nVHOLD\n= 0V @ time = 0",
    "20.2 Selecting and Configuring Acquisition Time\nThe  ADCON2  register  allows  the  user  to  select  an acquisition time that occurs each time the GO/DONE bit  is  set.  It  also  gives  users  the  option  to  use  an automatically determined acquisition time.\nAcquisition time may be set with the ACQT2:ACQT0 bits  (ADCON2<5:3>), which provides a range of 2 to 20 TAD. When the GO/DONE bit is set, the A/D module continues to sample the input for the selected acquisition  time,  then  automatically  begins  a  conversion. Since the acquisition time is programmed, there may be  no  need  to  wait  for  an  acquisition  time  between selecting a channel and setting the GO/DONE bit.\nAutomatic acquisition is selected when the ACQT2:ACQT0 = 000 . When the GO/DONE bit is set, sampling is stopped and a conversion begins. The user is responsible for ensuring the required acquisition time has passed  between  selecting the desired input channel and setting the GO/DONE bit. This option is also the default Reset state of the ACQT2:ACQT0 bits and  is  compatible  with  devices  that  do  not  offer programmable acquisition times.",
    "20.3 Selecting the A/D Conversion Clock\nThe A/D conversion time per bit is defined as TAD. The A/D conversion requires 12 TAD per 10-bit conversion. The  source  of  the  A/D  conversion  clock  is  software selectable. There are seven possible options for TAD:\n\u00b7 2 TOSC\n\u00b7 4 TOSC\n\u00b7 8 TOSC\n\u00b7 16 TOSC\n\u00b7 32 TOSC\n\u00b7 64 TOSC\n\u00b7 Internal RC oscillator\nFor correct A/D conversions, the A/D conversion clock (TAD) must be selected to ensure a minimum TAD time of 1.6 \uf06d s.\nTable 20-1 shows the resultant TAD times derived from the  device  operating  frequencies  and  the  A/D  clock source selected.\nIn either case, when the conversion is completed, the GO/DONE bit is cleared, the ADIF flag is set and the A/D  begins  sampling  the  currently  selected  channel again. If  an  acquisition  time  is  programmed,  there  is nothing to indicate if the acquisition time has ended or if the conversion has begun.",
    "TABLE 20-1: TAD vs. DEVICE OPERATING FREQUENCIES\n2 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 000. 2 T OSC, Maximum Device Frequency.PIC18F6525/6621/8525/8621 = 1.25 MHz. 4 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 100. 4 T OSC, Maximum Device Frequency.PIC18F6525/6621/8525/8621 = 2.50 MHz. 8 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 001. 8 T OSC, Maximum Device Frequency.PIC18F6525/6621/8525/8621 = 5.00 MHz. 16 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 101. 16 T OSC, Maximum Device Frequency.PIC18F6525/6621/8525/8621 = 10.0 MHz. 32 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 010. 32 T OSC, Maximum Device",
    "TABLE 20-1: TAD vs. DEVICE OPERATING FREQUENCIES\nFrequency.PIC18F6525/6621/8525/8621 = 20.0 MHz. 64 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 110. 64 T OSC, Maximum Device Frequency.PIC18F6525/6621/8525/8621 = 40.0 MHz. RC, AD Clock Source (T AD).ADCS2:ADCS0 = x11. RC, Maximum Device Frequency.PIC18F6525/6621/8525/8621 = -",
    "20.5 A/D Conversions\nThe  ADCON1,  TRISA,  TRISF  and  TRISH  registers control the operation of the A/D port pins. The port pins needed as analog inputs must have their corresponding TRIS bits set (input). If the TRIS bit is cleared (output), the digital output level (VOH or VOL) will be converted.\nThe A/D operation is independent of the state of the CHS3:CHS0 bits and the TRIS bits.\n- Note 1: When reading  the  port  register,  all  pins configured as analog input channels will read as cleared (a low level). Pins configured as a digital input will convert as an analog input. Analog levels on a digitally configured input will not affect the conversion accuracy.",
    "20.5 A/D Conversions\nFigure 20-3 shows the operation of the A/D converter after the GODONE bit has been set. Clearing the GO/ DONE bit  during  a  conversion  will  abort  the  current conversion. The A/D Result register pair will NOT be updated  with  the  partially  completed  A/D  conversion sample. That is, the ADRESH:ADRESL registers will continue  to  contain  the  value  of  the  last  completed conversion (or the last value written to the ADRESH:ADRESL registers). After the A/D conversion is  aborted,  a  2  TAD  wait  is  required  before  the  next acquisition is started. After this 2 TAD wait, acquisition on the selected channel is automatically started.\nNote:\nThe GO/DONE bit should NOT be set in the same instruction that turns on the A/D.\n- 2: Analog  levels  on  any  pin  defined  as  a digital input may cause the input buffer to consume  current out of the device's specification limits.",
    "20.6 Use of the ECCP2 Trigger\nAn A/D conversion can be started by the special event trigger  of  the  ECCP2  module.  This  requires  that  the CCP2M3:CCP2M0  bits  (CCP2CON<3:0>)  be  programmed as ' 1011 ' and that the A/D module is enabled (ADON bit is set).  When the trigger  occurs,  the GO/ DONE bit will be set, starting the A/D conversion and the  Timer1  (or  Timer3)  counter  will  be  reset  to  zero. Timer1 (or Timer3) is reset to automatically repeat the\nA/D acquisition period with minimal software overhead (moving  ADRESH/ADRESL  to  the  desired  location). The appropriate analog input channel must be selected and the minimum acquisition done before the special event  trigger  sets  the  GO/DONE  bit  and  starts  a conversion.\nIf the A/D module is not enabled (ADON is cleared), the special event trigger will be ignored by the A/D module but will still reset the Timer1 (or Timer3) counter.",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\n= 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP.",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\nIPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = -0-0. PIR2, Value on POR, BOR = 0000. PIR2, Value on all other Resets = -0-0. PIR2, Value on all other Resets = 0000. PIE2, Bit",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\n7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = -0-0. PIE2, Value on POR, BOR = 0000. PIE2, Value on all other Resets = -0-0. PIE2, Value on all other Resets = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = -1-1. IPR2, Value on POR, BOR = 1111.",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\nIPR2, Value on all other Resets = -1-1. IPR2, Value on all other Resets = 1111. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Value on POR, BOR = xxxx. ADRESH, Value on POR, BOR = xxxx. ADRESH, Value on all other Resets = uuuu. ADRESH, Value on all other Resets = uuuu. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte.",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\nADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Value on POR, BOR = xxxx. ADRESL, Value on POR, BOR = xxxx. ADRESL, Value on all other Resets = uuuu. ADRESL, Value on all other Resets = uuuu. ADCON0, Bit 7 = -. ADCON0, Bit 6 = -. ADCON0, Bit 5 = CHS3. ADCON0, Bit 4 = CHS3. ADCON0, Bit 3 = CHS1. ADCON0, Bit 2 = CHS0. ADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = --00. ADCON0, Value on POR, BOR",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\n= 0000. ADCON0, Value on all other Resets = --00. ADCON0, Value on all other Resets = 0000. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = --00. ADCON1, Value on POR, BOR = 0000. ADCON1, Value on all other Resets = --00. ADCON1, Value on all other Resets = 0000. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = -. ADCON2, Bit 5 = ACQT2. ADCON2, Bit 4 = ACQT1. ADCON2, Bit 3 = ACQT0. ADCON2, Bit 2 =",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\nADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Value on POR, BOR = 0-00. ADCON2, Value on POR, BOR = 0000. ADCON2, Value on all other Resets = 0-00. ADCON2, Value on all other Resets = 0000. PORTA, Bit 7 = -. PORTA, Bit 6 = RA6 (2). PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = -x0x. PORTA, Value on POR, BOR = 0000. PORTA, Value on all other Resets = -u0u. PORTA, Value on all other Resets = 0000. TRISA, Bit 7 = -. TRISA, Bit 6 = TRISA6 (2) PORTA Data Direction Register. TRISA,",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\nBit 5 = TRISA6 (2) PORTA Data Direction Register. TRISA, Bit 4 = TRISA6 (2) PORTA Data Direction Register. TRISA, Bit 3 = TRISA6 (2) PORTA Data Direction Register. TRISA, Bit 2 = TRISA6 (2) PORTA Data Direction Register. TRISA, Bit 1 = TRISA6 (2) PORTA Data Direction Register. TRISA, Bit 0 = TRISA6 (2) PORTA Data Direction Register. TRISA, Value on POR, BOR = -111. TRISA, Value on POR, BOR = 1111. TRISA, Value on all other Resets = -111. TRISA, Value on all other Resets = 1111. PORTF, Bit 7 = RF7. PORTF, Bit 6 = RF6. PORTF, Bit 5 = RF5. PORTF, Bit 4 = RF4. PORTF, Bit 3 = RF3. PORTF, Bit 2 = RF2. PORTF, Bit 1 = RF1. PORTF, Bit 0 = RF0. PORTF, Value on POR, BOR = x000.",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\nPORTF, Value on POR, BOR = 0000. PORTF, Value on all other Resets = u000. PORTF, Value on all other Resets = 0000. TRISF, Bit 7 = PORTF Data Direction Control Register. TRISF, Bit 6 = PORTF Data Direction Control Register. TRISF, Bit 5 = PORTF Data Direction Control Register. TRISF, Bit 4 = PORTF Data Direction Control Register. TRISF, Bit 3 = PORTF Data Direction Control Register. TRISF, Bit 2 = PORTF Data Direction Control Register. TRISF, Bit 1 = PORTF Data Direction Control Register. TRISF, Bit 0 = PORTF Data Direction Control Register. TRISF, Value on POR, BOR = 1111. TRISF, Value on POR, BOR = 1111. TRISF, Value on all other Resets = 1111. TRISF, Value on all other Resets = 1111. PORTH (3), Bit 7 = RH7. PORTH (3), Bit 6 = RH6. PORTH (3), Bit 5 = RH5. PORTH (3), Bit 4",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\n= RH4. PORTH (3), Bit 3 = RH3. PORTH (3), Bit 2 = RH2. PORTH (3), Bit 1 = RH1. PORTH (3), Bit 0 = RH0. PORTH (3), Value on POR, BOR = 0000. PORTH (3), Value on POR, BOR = xxxx. PORTH (3), Value on all other Resets = 0000. PORTH (3), Value on all other Resets = uuuu. TRISH (3), Bit 7 = PORTH Data Direction Control Register. TRISH (3), Bit 6 = PORTH Data Direction Control Register. TRISH (3), Bit 5 = PORTH Data Direction Control Register. TRISH (3), Bit 4 = PORTH Data Direction Control Register. TRISH (3), Bit 3 = PORTH Data Direction Control Register. TRISH (3), Bit 2 = PORTH Data Direction Control Register. TRISH (3), Bit 1 = PORTH Data Direction Control Register. TRISH (3), Bit 0",
    "TABLE 20-2: SUMMARY OF REGISTERS ASSOCIATED WITH A/D\n= PORTH Data Direction Control Register. TRISH (3), Value on POR, BOR = 1111. TRISH (3), Value on POR, BOR = 1111. TRISH (3), Value on all other Resets = 1111. TRISH (3), Value on all other Resets = 1111\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used for A/D conversion.\nNote\n1: Enabled only in Microcontroller mode for PIC18F8525/8621 devices.\n2: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator modes only and read ' 0 ' in all other oscillator modes.\n3: Implemented on PIC18F8525/8621 devices only, otherwise read as ' 0 '.",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "21.0 COMPARATOR MODULE\nThe comparator module contains two analog comparators. The  inputs to the comparators are multiplexed with  the RF1 through RF6 pins. The onchip  Voltage  Reference  ( Section 22.0  'Comparator Voltage Reference Module' ) can also be an input to the comparators.\nThe  CMCON  register,  shown  as  Register 21-1,  controls  the  comparator  input and output multiplexers. A block diagram of the various comparator configurations is shown in Figure 21-1.",
    "CMCON: COMPARATOR CONTROL REGISTER\nR-0, 1 = R-0. R-0, 2 = R/W-0. R-0, 3 = R/W-0. R-0, 4 = R/W-0. R-0, 5 = R/W-0. R-0, 6 = R/W-0. R-0, 7 = R/W-0. C2OUT, 1 = C1OUT. C2OUT, 2 = C2INV. C2OUT, 3 = C1INV. C2OUT, 4 = CIS. C2OUT, 5 = CM2. C2OUT, 6 = CM1. C2OUT, 7 = CM0\nbit 7\nbit 0",
    "bit 7 C2OUT : Comparator 2 Output bit\nWhen C2INV = 0 :\n1 = C2 VIN+ > C2 VIN-\n0 = C2 VIN+ < C2 VIN-\nWhen C2INV = 1 :\n1 = C2 VIN+ < C2 VIN-\n0 = C2 VIN+ > C2 VIN-",
    "bit 6\nC1OUT : Comparator 1 Output bit\nWhen C1INV = 0 :\n1 = C1 VIN+ > C1 VIN-\n0 = C1 VIN+ < C1 VIN-\nWhen C1INV = 1 :\n1 = C1 VIN+ < C1 VIN-\n0 = C1 VIN+ > C1 VIN-",
    "bit 5\nC2INV : Comparator 2 Output Inversion bit\n1 = C2 output inverted\n0 = C2 output not inverted",
    "bit 4\nC1INV : Comparator 1 Output Inversion bit\n1 = C1 output inverted\n0 = C1 output not inverted",
    "bit 3\nCIS : Comparator Input Switch bit\nWhen CM2:CM0 = 110 :\n1 = C1 VIN- connects to RF5/AN10\nC2 VIN- connects to RF3/AN8\n0 = C1 VIN- connects to RF6/AN11\nC2 VIN- connects to RF4/AN9\nbit 2-0 CM2:CM0 : Comparator Mode bits\nFigure 21-1 shows the Comparator modes and the CM2:CM0 bit settings.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "21.1 Comparator Configuration\nThere are eight modes of operation for the comparators.  The  CMCON  register  is  used  to  select  these modes. Figure 21-1 shows the eight possible modes. The TRISF register controls the data direction of the comparator  pins  for  each  mode.  If  the  Comparator mode is changed, the comparator output level may not be valid for the specified mode change delay shown in Section 27.0 'Electrical Characteristics' .\nNote:\nComparator interrupts should be disabled during a Comparator mode change; otherwise, a false interrupt may occur.",
    "21.2 Comparator Operation\nA single comparator is shown in Figure 21-2, along with the  relationship  between  the  analog  input  levels  and the digital output. When the analog input at VIN+ is less than the analog input VIN-, the output of the comparator is a digital low level. When the analog input at VIN+ is greater  than  the  analog  input  VIN-,  the  output  of  the comparator is a digital high level. The shaded areas of the output of the comparator in Figure 21-2 represent the uncertainty due to input offsets and response time.",
    "21.3 Comparator Reference\nAn external or internal reference signal may be used depending  on  the  comparator  operating  mode.  The analog signal present at VIN- is compared to the signal at  VIN+  and  the  digital  output  of  the  comparator  is adjusted accordingly (Figure 21-2).\nFIGURE 21-2: SINGLE COMPARATOR",
    "21.3.1 EXTERNAL REFERENCE SIGNAL\nWhen  external voltage references are used, the comparator module can be configured to have the comparators operate from the same, or different reference sources. However, threshold detector applications may require the same reference. The reference signal must be between VSS and VDD and can be applied to either pin of the comparator(s).",
    "21.3.2 INTERNAL REFERENCE SIGNAL\nThe comparator module also allows the selection of an internally generated voltage reference for the comparators. Section 22.0 'Comparator Voltage Reference Module' contains a detailed description of the comparator voltage reference module that provides this signal. The internal reference signal is used when comparators are in mode CM<2:0> = 110 (Figure 21-1). In this mode, the internal voltage reference is applied to the VIN+ pin of both comparators.",
    "21.4 Comparator Response Time\nResponse time is the minimum time, after selecting a new  reference  voltage  or  input  source,  before  the comparator  output  has  a  valid  level.  If  the  internal reference  is  changed,  the  maximum  delay  of  the internal  voltage  reference  must  be  considered  when using the comparator outputs. Otherwise, the maximum  delay  of  the  comparators  should  be  used ( Section 27.0 'Electrical Characteristics' ).",
    "21.5 Comparator Outputs\nThe comparator outputs are read through the CMCON register.  These  bits  are  read-only.  The  comparator outputs may also be directly output to the RF1 and RF2 I/O pins. When enabled, multiplexors in the output path of the RF1 and RF2 pins will switch and the output of each pin will be the unsynchronized output of the comparator. The uncertainty of each of the comparators is related to the input offset voltage and the response time given  in  the  specifications.  Figure 21-3  shows  the comparator output block diagram.\nThe TRISA bits will still function as an output enable/ disable for the RF1 and RF2 pins while in this mode.\nThe polarity of the comparator outputs can be changed using the C2INV and C1INV bits (CMCON<4:5>).\nNote 1: When reading the Port register, all  pins configured as analog inputs will read as a ' 0 '.  Pins  configured  as  digital  inputs  will convert an analog input according to the Schmitt Trigger input specification.\n2: Analog  levels  on  any  pin  defined  as  a digital input may cause the input buffer to consume more current than is specified.",
    "21.6 Comparator Interrupts\nNote:\nThe comparator interrupt flag is set whenever there is a  change  in  the  output  value  of  either  comparator. Software  will  need  to  maintain  information  about  the status of the output bits, as read from CMCON<7:6>, to determine the actual change that occurred. The CMIF bit (PIR registers) is the comparator interrupt flag. The CMIF bit must be reset by clearing ' 0 '. Since it is also possible  to  write  a  ' 1 ' to  this  register,  a  simulated interrupt may be initiated.\nThe CMIE bit (PIE registers) and the PEIE bit (INTCON register) must be set to enable the interrupt. In addition, the GIE bit must also be set. If any of these bits are clear, the interrupt is not enabled, though the CMIF bit will still be set if an interrupt condition occurs.\nIf a change in the CMCON  register (C1OUT or C2OUT) should occur when a read operation is being executed (start of the Q2 cycle), then the CMIF (PIR registers) interrupt flag may not get set.\nThe user, in the Interrupt Service Routine, can clear the interrupt in the following manner:",
    "21.6 Comparator Interrupts\na) Any  read  or  write  of  CMCON  will  end  the mismatch condition.\nb) Clear flag bit CMIF.\nA mismatch condition will continue to set flag bit CMIF. Reading CMCON will end the mismatch condition and allow flag bit CMIF to be cleared.",
    "21.7 Comparator Operation During Sleep\nWhen a comparator is active and the device is placed in Sleep mode, the comparator remains active and the interrupt  is  functional  if  enabled.  This  interrupt  will wake-up the device from Sleep mode when enabled. While  the  comparator  is  powered  up,  higher  Sleep currents than shown in the power-down current specification  will  occur.  Each  operational  comparator will consume  additional  current,  as  shown  in  the comparator specifications. To minimize power consumption while in Sleep mode, turn off the comparators, CM<2:0> = 111 , before entering Sleep. If the device wakes up from Sleep, the contents of the CMCON register are not affected.",
    "21.8 Effects of a Reset\nA device Reset forces the CMCON register to its Reset state,  causing  the  comparator  module  to  be  in  the comparator Reset mode, CM<2:0> = 000 . This ensures  that  all  potential  inputs  are  analog  inputs. Device  current  is  minimized  when  analog  inputs  are present at Reset time. The  comparators  will be powered down during the Reset interval.",
    "21.9 Analog Input Connection Considerations\nA  simplified  circuit  for  an  analog  input  is  shown  in Figure 21-4. Since the analog pins are connected to a digital output, they have reverse biased diodes to VDD and VSS. The analog input, therefore, must be between VSS and VDD. If the  input  voltage  deviates  from  this range by more than 0.6V in either direction, one of the diodes is forward biased and a latch-up condition may occur.  A  maximum  source  impedance  of  10 k \uf057 is recommended  for  the  analog  sources.  Any  external component connected to an analog input pin, such as a  capacitor  or  a  Zener  diode,  should  have  very  little leakage current.",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nCMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Value on POR = 0000. CMCON, Value on POR = 0000. CMCON, Value on all other Resets = 0000. CMCON, Value on all other Resets = 0000. CVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Value on POR = 0000. CVRCON, Value on POR = 0000. CVRCON, Value on all other Resets = 0000.",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nCVRCON, Value on all other Resets = 0000. INTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR = 0000. INTCON, Value on POR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR = -0-0.",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nPIR2, Value on POR = 0000. PIR2, Value on all other Resets = -0-0. PIR2, Value on all other Resets = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR = -0-0. PIE2, Value on POR = 0000. PIE2, Value on all other Resets = -0-0. PIE2, Value on all other Resets = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\n0 = CCP2IP. IPR2, Value on POR = -1-1. IPR2, Value on POR = 1111. IPR2, Value on all other Resets = -1-1. IPR2, Value on all other Resets = 1111. PORTF, Bit 7 = RF7. PORTF, Bit 6 = RF6. PORTF, Bit 5 = RF5. PORTF, Bit 4 = RF4. PORTF, Bit 3 = RF3. PORTF, Bit 2 = RF2. PORTF, Bit 1 = RF1. PORTF, Bit 0 = RF0. PORTF, Value on POR = x000. PORTF, Value on POR = 0000. PORTF, Value on all other Resets = u000. PORTF, Value on all other Resets = 0000. LATF, Bit 7 = LATF7. LATF, Bit 6 = LATF6. LATF, Bit 5 = LATF5. LATF, Bit 4 = LATF4. LATF, Bit 3 = LATF3. LATF, Bit 2 = LATF2. LATF,",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nBit 1 = LATF1. LATF, Bit 0 = LATF0. LATF, Value on POR = xxxx. LATF, Value on POR = xxxx. LATF, Value on all other Resets = uuuu. LATF, Value on all other Resets = uuuu. TRISF, Bit 7 = TRISF7. TRISF, Bit 6 = TRISF6. TRISF, Bit 5 = TRISF5. TRISF, Bit 4 = TRISF4. TRISF, Bit 3 = TRISF3. TRISF, Bit 2 = TRISF2. TRISF, Bit 1 = TRISF1. TRISF, Bit 0 = TRISF0. TRISF, Value on POR = 1111. TRISF, Value on POR = 1111. TRISF, Value on all other Resets = 1111. TRISF, Value on all other Resets = 1111\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '.\nShaded cells are unused by the comparator module.",
    "22.1 Configuring the Comparator Voltage Reference\nThe comparator voltage reference is a 16-tap resistor ladder  network  that  provides  a  selectable  voltage reference. The resistor ladder is segmented to provide two  ranges  of  CVREF  values  and  has  a  power-down function to conserve power when the reference is not being  used.      The  CVRCON  register  controls  the operation of the reference as shown in Register 22-1. The block diagram is given in Figure 22-1.\nThe  comparator  voltage  reference  can  output  16 distinct  voltage  levels  for  each  range.  The  equations used to calculate the output of the comparator voltage reference are as follows:\nThe  comparator  reference  supply  voltage  can  come from either VDD and VSS, or the external VREF+ and VREF-  that  are  multiplexed  with  RA3  and  RA2.  The comparator reference supply voltage is controlled by the CVRSS bit.\nIf CVRR = 1 :\nCVREF = (CVR<3:0>/24) x CVRSRC\nIf CVRR = 0 :\nCVREF  =  (CVRSRC x 1/4)  +  (CVR<3:0>/32)  x  CVRSRC",
    "22.1 Configuring the Comparator Voltage Reference\nThe settling time of the comparator voltage reference must be considered when changing the CVREF output ( Section 27.0 'Electrical Characteristics' ).",
    "REGISTER 22-1: CVRCON: COMPARATOR VOLTAGE REFERENCE CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. CVREN, 1 = CVROE (1). CVREN, 2 = CVRR. CVREN, 3 = CVRSS. CVREN, 4 = CVR3. CVREN, 5 = CVR2. CVREN, 6 = CVR1. CVREN, 7 = CVR0\nbit 7\nbit 0\nbit 7\nCVREN : Comparator Voltage Reference Enable bit\n1 = CVREF circuit powered on\n0 = CVREF circuit powered down",
    "bit 6\nCVROE : Comparator VREF Output Enable bit (1)\n1 = CVREF voltage level is also output on the RF5/AN10/CVREF pin\n0 = CVREF voltage is disconnected from the RF5/AN10/CVREF pin\nNote 1:\nIf enabled for output, RF5 must also be configured as an input by setting TRISF<5> to ' 1 '.",
    "bit 5 CVRR\n: Comparator VREF Range Selection bit\n1 = 0.00 CVRSRC to 0.667 CVRSRC, with CVRSRC/24 step size (low range)\n0 = 0.25 CVRSRC to 0.75 CVRSRC, with CVRSRC/32 step size (high range)",
    "bit 4 CVRSS : Comparator VREF Source Selection bit\n1 = Comparator reference source, CVRSRC = VREF+ - VREF-\n0 = Comparator reference source, CVRSRC = AVDD - AVSS\nbit 3-0\nCVR3:CVR0:\nComparator VREF Value Selection bits (0\n\uf0a3\nVR3:VR0\n\uf0a3\n15)\nWhen CVRR = 1 :\nCVREF = (CVR<3:0>/ 24)   (CVRSRC) \uf0b7\nWhen CVRR = 0 :\nCVREF = 1/4   (CVRSRC) + (CVR3:CVR0/32)   (CVRSRC) \uf0b7 \uf0b7",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "22.4 Effects of a Reset\nThe full range of voltage reference cannot be realized due to the construction of the module. The transistors on the top and bottom of the resistor ladder network (Figure 22-1) keep CVREF from approaching the reference  source  rails.  The  voltage  reference  is  derived from the reference source; therefore, the CVREF output changes  with  fluctuations  in  that  source.  The  tested absolute  accuracy  of  the  voltage  reference  can  be found in Section 27.0 'Electrical Characteristics' .",
    "22.3 Operation During Sleep\nWhen  the  device  wakes  up  from  Sleep  through  an interrupt or a Watchdog Timer time-out, the contents of the  CVRCON  register  are  not  affected.  To  minimize current consumption  in Sleep mode,  the  voltage reference should be disabled.\nA  device  Reset  disables  the  voltage  reference  by clearing  bit  CVREN  (CVRCON<7>).  This  Reset  also disconnects the reference from the RA2 pin by clearing bit CVROE  (CVRCON<6>)  and  selects  the  highvoltage  range  by  clearing  bit  CVRR  (CVRCON<5>). The VRSS value select bits, CVRCON<3:0>, are also cleared.",
    "22.5 Connection Considerations\nThe voltage reference module operates independently of the comparator module. The output of the reference generator  may  be  connected  to  the  RF5  pin  if  the TRISF<5> bit is set and the CVROE bit is set. Enabling the voltage reference output onto the RF5 pin configured  as  a  digital  input  will  increase  current consumption. Connecting RF5 as a digital output with VRSS enabled will also increase current consumption.\nThe RF5 pin can be used as a simple D/A output with limited drive capability. Due to the limited current drive capability, a  buffer  must  be  used  on  the  voltage reference  output  for  external  connections  to  VREF. Figure 22-2 shows an example buffering technique.",
    "TABLE 22-1: REGISTERS ASSOCIATED WITH COMPARATOR VOLTAGE REFERENCE\nCVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Value on POR = 0000 0000. CVRCON, Value on all other Resets = 0000 0000. CMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Value on POR = 0000 0000. CMCON, Value on all other Resets = 0000 0000. TRISF, Bit 7 = TRISF7. TRISF, Bit 6 = TRISF6. TRISF, Bit 5 =",
    "TABLE 22-1: REGISTERS ASSOCIATED WITH COMPARATOR VOLTAGE REFERENCE\nTRISF5. TRISF, Bit 4 = TRISF4. TRISF, Bit 3 = TRISF3. TRISF, Bit 2 = TRISF2. TRISF, Bit 1 = TRISF1. TRISF, Bit 0 = TRISF0. TRISF, Value on POR = 1111 1111. TRISF, Value on all other Resets = 1111 1111\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '.\nShaded cells are not used with the comparator voltage reference.",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "23.0 LOW-VOLTAGE DETECT\nIn  many  applications,  the  ability  to  determine  if  the device voltage (VDD) is below a specified voltage level is  a  desirable  feature.  A  window  of  operation  for  the application can be created, where the application software can do 'housekeeping tasks' before the device voltage  exits  the  valid  operating  range.  This  can  be done using the Low-Voltage Detect module.\nThe Low-Voltage Detect circuitry is completely under software control. This allows the circuitry to be 'turned off' by  the  software  which  minimizes  the  current consumption for the device.\nThis  module  is  a  software  programmable  circuitry, where  a  device  voltage  trip  point  can  be  specified. When the voltage of the device becomes lower then the specified point, an interrupt flag is set. If the interrupt is enabled, the program execution will branch to the interrupt vector address and the software can then respond to that interrupt source.",
    "23.0 LOW-VOLTAGE DETECT\nFigure 23-1 shows a possible application voltage curve (typically for batteries). Over time, the device voltage decreases. When the device voltage equals voltage VA, the  LVD  logic  generates  an  interrupt.  This  occurs  at time  TA.  The  application  software  then  has  the  time, until the device voltage is no longer in valid operating range, to shutdown the system. Voltage point VB is the minimum  valid  operating  voltage  specification.  This occurs at time TB. The difference TB - TA is the total time for shutdown.",
    "FIGURE 23-1: TYPICAL LOW-VOLTAGE DETECT APPLICATION\nThe  block  diagram  for  the  LVD  module  is  shown  in Figure 23-2.  A  comparator  uses  an  internally  generated  reference  voltage  as  the  set  point.  When  the selected tap output of the device voltage crosses the set point (is lower than), the LVDIF bit is set.\nEach  node  in  the  resistor  divider  represents  a  'trip point' voltage. The 'trip point' voltage is the minimum supply voltage level at which the device can operate before the LVD module asserts an interrupt. When the supply  voltage  is  equal  to  the  trip  point,  the  voltage tapped  off  of  the  resistor  array  is  equal  to  the  1.2V internal  reference  voltage  generated  by  the  voltage reference module. The comparator then generates an interrupt  signal  setting  the  LVDIF  bit.  This  voltage  is software programmable to any one of 16 values (see Figure 23-2). The trip point is selected by programming the LVDL3:LVDL0 bits (LVDCON<3:0>).",
    "PIC18F6525/6621/8525/8621\nThe LVD module has an additional feature that allows the user to supply the trip voltage to the module from an  external  source.  This  mode  is  enabled  when  bits LVDL3:LVDL0 are set to ' 1111 '. In this state, the comparator input is multiplexed from the external input pin,\nLVDIN (Figure 23-3). This gives users flexibility because it allows them to configure the Low-Voltage Detect  interrupt  to  occur  at  any  voltage  in  the  valid operating range.",
    "23.1 Control Register\nThe Low-Voltage Detect\nControl\nregister\n(Register 23-1)\ncontrols\nthe\noperation\nof the\nLow-Voltage Detect circuitry.",
    "REGISTER 23-1: LVDCON: LOW-VOLTAGE DETECT CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = R-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-1. U-0, 6 = R/W-0. U-0, 7 = R/W-1. -, 1 = -. -, 2 = IRVST. -, 3 = LVDEN. -, 4 = LVDL3. -, 5 = LVDL2. -, 6 = LVDL1. -, 7 = LVDL0\nbit 7\nbit 0",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5 IRVST: Internal Reference Voltage Stable Flag bit\n1 = Indicates that the Low-Voltage Detect logic will generate the interrupt flag at the specified voltage range\n0 = Indicates  that  the  Low-Voltage  Detect  logic  will  not  generate  the  interrupt  flag  at  the specified voltage range and the LVD interrupt should not be enabled",
    "bit 4 LVDEN: Low-Voltage Detect Power Enable bit\n1 = Enables LVD, powers up LVD circuit\n0 = Disables LVD, powers down LVD circuit",
    "bit 3-0 LVDL3:LVDL0: Low-Voltage Detection Limit bits\n1111 = External analog input is used (input comes from the LVDIN pin)\n1110 = 4.45V-4.83V\n1101 = 4.16V-4.5V\n1100 = 3.96V-4.3V\n1011 = 3.76V-3.92V\n1010 = 3.57V-3.87V\n1001 = 3.47V-3.75V\n1000 = 3.27V-3.55V\n0111 = 2.98V-3.22V\n0110 = 2.77V-3.01V\n0101 = 2.67V-2.89V\n0100 = 2.48V-2.68V\n0011 = 2.37V-2.57V\n0010 = 2.18V-2.36V\n0001 = 1.98V-2.14V\n0000 = Reserved\nNote:\nLVDL3:LVDL0 modes, which result in a trip point below the valid operating voltage of the device, are not tested.",
    "bit 3-0 LVDL3:LVDL0: Low-Voltage Detection Limit bits\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "23.2 Operation\nDepending on the power source for the device voltage, the voltage normally decreases relatively slowly. This means  that  the  LVD  module  does  not  need  to  be constantly operating. To decrease the current requirements, the LVD circuitry only needs to be enabled for short periods where the voltage is checked. After doing the check, the LVD module may be disabled.\nEach time that the LVD module is enabled, the circuitry requires some time to stabilize. After the circuitry has stabilized, all status flags may be cleared. The module will then indicate the proper state of the system.\nThe  following  steps  are  needed  to  set  up  the  LVD module:",
    "23.2 Operation\n1. Write the value to the LVDL3:LVDL0  bits (LVDCON  register)  which  selects  the  desired LVD trip point.\n2. Ensure  that  LVD  interrupts  are  disabled  (the LVDIE bit is cleared or the GIE bit is cleared).\n3. Enable the LVD module (set the LVDEN bit in the LVDCON register).\n4. Wait for the LVD module to stabilize (the IRVST bit to become set).\n5. Clear  the  LVD  interrupt  flag,  which  may  have falsely  become  set,  until  the  LVD  module  has stabilized (clear the LVDIF bit).\n6. Enable the LVD interrupt (set the LVDIE and the GIE bits).\nFigure 23-4  shows  typical  waveforms  that  the  LVD module may be used to detect.",
    "23.3 Operation During Sleep\nThe internal reference voltage of the LVD module may be used by other internal  circuitry (the  Programmable Brown-out Reset). If these circuits are disabled (lower current consumption), the reference voltage circuit requires a time to become stable before a low-voltage condition can be reliably detected. This time is invariant of system clock speed. This start-up time is specified in electrical  specification  parameter  36.  The  low-voltage interrupt flag will not be enabled until a stable reference voltage is reached. Refer to the waveform in Figure 23-4.",
    "23.2.2 CURRENT CONSUMPTION\nWhen the module is enabled, the LVD comparator and voltage divider are enabled and will consume static current. The voltage divider can be tapped from multiple places in the resistor array. Total current consumption, when  enabled,  is  specified  in  electrical  specification parameter D022B.\nWhen enabled, the LVD circuitry continues to operate during  Sleep.  If  the  device  voltage  crosses  the  trip point,  the  LVDIF  bit  will  be  set  and  the  device  will wake-up  from  Sleep.  Device  execution  will  continue from  the  interrupt  vector  address  if  interrupts  have been globally enabled.",
    "23.4 Effects of a Reset\nA device Reset forces all registers to their Reset state. This forces the LVD module to be turned off.",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "24.0 SPECIAL FEATURES OF THE CPU\nThere  are  several  features  intended  to  maximize system reliability, minimize cost through elimination of external components, provide power-saving operating modes and offer code protection. These are:\n\u00b7 Oscillator Selection\n\u00b7 Reset\n-Power-on Reset (POR)\n-Power-up Timer (PWRT)\n-Oscillator Start-up Timer (OST)\n-Brown-out Reset (BOR)\n\u00b7 Interrupts\n\u00b7 Watchdog Timer (WDT)\n\u00b7 Sleep\n\u00b7 Code Protection\n\u00b7 ID Locations\n\u00b7 In-Circuit Serial Programming\nSleep  mode  is  designed  to  offer  a  very  low  current power-down mode. The user can wake-up from Sleep through external Reset, Watchdog Timer wake-up, or through an interrupt. Several oscillator options are also made available to allow the part to fit the application. The RC oscillator option saves system cost, while the LP crystal option saves power. A set of configuration bits is used to select various options.",
    "24.1 Configuration Bits\nThe configuration bits can be programmed (read as ' 0 ') or  left  unprogrammed  (read  as ' 1 '),  to  select  various device configurations. These bits are mapped, starting at program memory location 300000h.\nThe user will note that address 300000h is beyond the user program memory space. In fact, it belongs to the configuration memory space (300000h through 3FFFFFh)  which  can  only  be  accessed  using  table reads and table writes.\nAll PIC18F6525/6621/8525/8621 devices have a Watchdog Timer which is permanently enabled via the configuration bits, or software controlled. It runs off its own RC oscillator for added reliability. There are two timers that offer necessary delays on power-up. One is the Oscillator Start-up Timer (OST), intended to keep the chip in Reset until the crystal oscillator is stable. The  other  is the Power-up  Timer  (PWRT)  which provides a fixed delay on power-up only, designed to keep  the part in Reset while the power  supply stabilizes. With these two timers on-chip, most applications need no external Reset circuitry.",
    "24.1 Configuration Bits\nProgramming the Configuration registers is done in a manner similar to programming the Flash memory. The EECON1 register WR bit starts a self-timed write to the Configuration  register.  In  normal  operation  mode,  a TBLWT instruction,  with  the  TBLPTR  pointed  to  the Configuration  register,  sets  up  the  address  and  the data for the Configuration register write. Setting the WR bit starts a long write to the Configuration register. The Configuration registers are written a byte at a time. To write or erase a configuration cell, a TBLWT instruction can write a ' 1 ' or a ' 0 ' into the cell.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n300001h, File Name = CONFIG1H. 300001h, Bit 7 = -. 300001h, Bit 6 = -. 300001h, Bit 5 = OSCSEN. 300001h, Bit 4 = -. 300001h, Bit 3 = FOSC3. 300001h, Bit 2 = FOSC2. 300001h, Bit 1 = FOSC1. 300001h, Bit 0 = FOSC0. 300001h, Default/ Unprogrammed Value = --1- 1111. 300002h, File Name = CONFIG2L. 300002h, Bit 7 = -. 300002h, Bit 6 = -. 300002h, Bit 5 = -. 300002h, Bit 4 = -. 300002h, Bit 3 = BORV1. 300002h, Bit 2 = BORV0. 300002h, Bit 1 = BOR. 300002h, Bit 0 = PWRTEN. 300002h, Default/ Unprogrammed Value = ---- 1111.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n300003h, File Name = CONFIG2H. 300003h, Bit 7 = -. 300003h, Bit 6 = -. 300003h, Bit 5 = -. 300003h, Bit 4 = WDTPS3. 300003h, Bit 3 = WDTPS2. 300003h, Bit 2 = WDTPS1. 300003h, Bit 1 = WDTPS0. 300003h, Bit 0 = WDTEN. 300003h, Default/ Unprogrammed Value = ---1 1111. 300004h (1), File Name = CONFIG3L. 300004h (1), Bit 7 = WAIT. 300004h (1), Bit 6 = -. 300004h (1), Bit 5 = -. 300004h (1), Bit 4 = -. 300004h (1), Bit 3 = -. 300004h (1), Bit 2 = -. 300004h (1), Bit 1 = PM1. 300004h (1),",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\nBit 0 = PM0. 300004h (1), Default/ Unprogrammed Value = 1--- --11. 300005h, File Name = CONFIG3H. 300005h, Bit 7 = MCLRE. 300005h, Bit 6 = -. 300005h, Bit 5 = -. 300005h, Bit 4 = -. 300005h, Bit 3 = -. 300005h, Bit 2 = -. 300005h, Bit 1 = ECCPMX (1). 300005h, Bit 0 = CCP2MX. 300005h, Default/ Unprogrammed Value = 1--- --11. 300006h, File Name = CONFIG4L. 300006h, Bit 7 = DEBUG. 300006h, Bit 6 = -. 300006h, Bit 5 = -. 300006h, Bit 4 = -. 300006h, Bit 3 = -. 300006h, Bit 2 = LVP. 300006h, Bit 1 = -.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n300006h, Bit 0 = STVREN. 300006h, Default/ Unprogrammed Value = 1--- -1-1. 300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3 (2). 300008h, Bit 2 = CP2. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300008h, Default/ Unprogrammed Value = ---- 1111. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n300009h, Bit 0 = -. 300009h, Default/ Unprogrammed Value = 11-- ----. 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4 = -. 30000Ah, Bit 3 = WRT3 (2). 30000Ah, Bit 2 = WRT2. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Ah, Default/ Unprogrammed Value = ---- 1111. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Bh, Default/",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\nUnprogrammed Value = 111- ----. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3 (2). 30000Ch, Bit 2 = EBTR2. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Ch, Default/ Unprogrammed Value = ---- 1111. 30000Dh, File Name = CONFIG7H. 30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -. 30000Dh, Default/ Unprogrammed Value = -1-- ----. 3FFFFEh,",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\nFile Name = DEVID1. 3FFFFEh, Bit 7 = DEV2. 3FFFFEh, Bit 6 = DEV1. 3FFFFEh, Bit 5 = DEV0. 3FFFFEh, Bit 4 = REV4. 3FFFFEh, Bit 3 = REV3. 3FFFFEh, Bit 2 = REV2. 3FFFFEh, Bit 1 = REV1. 3FFFFEh, Bit 0 = REV0. 3FFFFEh, Default/ Unprogrammed Value = (Note 3). 3FFFFFh, File Name = DEVID2. 3FFFFFh, Bit 7 = DEV10. 3FFFFFh, Bit 6 = DEV9. 3FFFFFh, Bit 5 = DEV8. 3FFFFFh, Bit 4 = DEV7. 3FFFFFh, Bit 3 = DEV6. 3FFFFFh, Bit 2 = DEV5. 3FFFFFh, Bit 1 = DEV4. 3FFFFFh, Bit 0 = DEV3. 3FFFFFh, Default/ Unprogrammed Value = 0000 1010\nLegend:",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\nx = unknown, u = unchanged, - = unimplemented. Shaded cells are unimplemented, read as ' 0\n'.\nNote\n1: Unimplemented in PIC18F6525/6621 devices; maintain this bit set.\n2: Unimplemented in PIC18FX525 devices; maintain this bit set.\n3: See Register 24-13 for DEVID1 values.",
    "CONFIG1H: CONFIGURATION REGISTER 1 HIGH (BYTE ADDRESS 300001h)\nU-0, 1 = U-0. U-0, 2 = R/P-1. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = OSCSEN. -, 3 = -. -, 4 = FOSC3. -, 5 = FOSC2. -, 6 = FOSC1. -, 7 = FOSC0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5\nOSCSEN : Oscillator System Clock Switch Enable bit\n1 = Oscillator system clock switch option is disabled (main oscillator is source)\n0 = Timer1 oscillator system clock switch option is enabled (oscillator switching is enabled)",
    "bit 3-0 FOSC3:FOSC0 : Oscillator Selection bits\n1111 = RC oscillator with OSC2 configured as RA6\n1110 = HS oscillator with SW enabled 4x PLL\n1101 = EC oscillator with OSC2 configured as RA6 and SW enabled 4x PLL\n1100 = EC oscillator with OSC2 configured as RA6 and HW enabled 4x PLL\n1011 = Reserved; do not use\n1010 = Reserved; do not use\n1001 = Reserved; do not use\n1000 = Reserved; do not use\n0111 = RC oscillator with OSC2 configured as RA6\n0110 = HS oscillator with HW enabled 4x PLL\n0101 = EC oscillator with OSC2 configured as RA6\n0100 = EC oscillator with OSC2 configured as divide by 4 clock output\n0011 = RC oscillator with OSC2 configured as divide by 4 clock output\n0010 = HS oscillator\n0001 = XT oscillator\n0000 = LP oscillator",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state\nREGISTER 24-2:",
    "CONFIG2L: CONFIGURATION REGISTER 2 LOW (BYTE ADDRESS 300002h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = BORV1. -, 5 = BORV0. -, 6 = BOR. -, 7 = PWRTEN\nbit 7\nbit 0\nbit 7-4 Unimplemented: Read as ' 0 '\nbit 3-2 BORV1:BORV0: Brown-out Reset Voltage bits\n11 = VBOR set to 2.0V\n10 = VBOR set to 2.7V\n01 = VBOR set to 4.2V\n00 = VBOR set to 4.5V",
    "bit 1 BOR: Brown-out Reset Enable bit\n1 = Brown-out Reset enabled\n0 = Brown-out Reset disabled\nbit 0\nPWRTEN: Power-up Timer Enable bit\n1 = PWRT disabled\n0 = PWRT enabled\nLegend:, 1 = Legend:. R = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 24-3: CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/P-1. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = WDTPS3. -, 4 = WDTPS2. -, 5 = WDTPS1. -, 6 = WDTPS0. -, 7 = WDTEN\nbit 7\nbit 0\nbit 7-5 Unimplemented: Read as ' 0 '\nbit 4-1 WDTPS2:WDTPS0: Watchdog Timer Postscaler Select bits\n1111 = 1:32768\n1110 = 1:16384\n1101 = 1:8192\n1100 = 1:4096\n1011 = 1:2048\n1010 = 1:1024\n1001 = 1:512\n1000 = 1:256",
    "REGISTER 24-3: CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\n0111 = 1:128\n0110 = 1:64\n0101 = 1:32\n0100 = 1:16\n0011 = 1:8\n0010 = 1:4\n0001 = 1:2\n0000 = 1:1",
    "bit 0 WDTEN: Watchdog Timer Enable bit\n1 = WDT enabled\n0 = WDT disabled (control is placed on the SWDTEN bit)",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "PIC18F6525/6621/8525/8621\nREGISTER 24-4:",
    "CONFIG3L: CONFIGURATION REGISTER 3 LOW (BYTE ADDRESS 300004h) (1)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = U-0. R/P-1, 6 = R/P-1. R/P-1, 7 = R/P-1. WAIT, 1 = -. WAIT, 2 = -. WAIT, 3 = -. WAIT, 4 = -. WAIT, 5 = -. WAIT, 6 = PM1. WAIT, 7 = PM0\nbit 7\nbit 0",
    "bit 7 WAIT: External Bus Data Wait Enable bit\n1 = Wait selections unavailable for table reads and table writes\n0 = Wait  selections  for  table  reads  and  table  writes  are  determined  by  WAIT1:WAIT0  bits (MEMCOM<5:4>)\nbit 6-2 Unimplemented: Read as ' 0\n'\nbit 1-0 PM1:PM0: Processor Mode Select bits\n11 = Microcontroller mode\n10 = Microprocessor mode\n01 = Microprocessor with Boot Block mode\n00 = Extended Microcontroller mode\nNote 1: This register is unimplemented for PIC18F6525/6621 devices; maintain these bits set.",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-5: CONFIG3H: CONFIGURATION REGISTER 3 HIGH (BYTE ADDRESS 300005h)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = U-0. R/P-1, 6 = R/P-1. R/P-1, 7 = R/P-1. MCLRE (1), 1 = -. MCLRE (1), 2 = -. MCLRE (1), 3 = -. MCLRE (1), 4 = -. MCLRE (1), 5 = -. MCLRE (1), 6 = ECCPMX (2). MCLRE (1), 7 = CCP2MX\nbit 7\nbit 0\nbit 7 MCLRE: MCLR Enable bit (1)\n1 = MCLR pin enabled, RG5 input pin disabled\n0 = RG5 input enabled, MCLR disabled",
    "bit 1 ECCPMX: ECCP Mux bit (2)\n1 = ECCP1 (P1B/P1C) and ECCP3 (P3B/P3C) PWM outputs are multiplexed with RE6 through RE3\n0 = ECCP1 (P1B/P1C) and ECCP3 (P3B/P3C) PWM outputs are multiplexed with RH7 through RH4",
    "bit 0 CCP2MX: ECCP2 Mux bit\nIn Microcontroller mode:\n1 = ECCP2 input/output is multiplexed with RC1\n0 = ECCP2 input/output is multiplexed with RE7",
    "In Microprocessor, Microprocessor with Boot Block and Extended Microcontroller modes\n(PIC18F8525/8621 devices only):\n1 = ECCP2 input/output is multiplexed with RC1\n0 = ECCP2 input/output is multiplexed with RB3\nNote 1: If MCLR is disabled, either disable Low-Voltage ICSP or hold RB5/KBI1/PGM low to ensure proper entry into ICSP mode.\n2: This register is unimplemented for PIC18F6525/6621 devices; maintain these bits set.\nLegend:, 1 = Legend:. R = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "CONFIG4L: CONFIGURATION REGISTER 4 LOW (BYTE ADDRESS 300006h)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = R/P-1. R/P-1, 6 = U-0. R/P-1, 7 = R/P-1. DEBUG, 1 = -. DEBUG, 2 = -. DEBUG, 3 = -. DEBUG, 4 = -. DEBUG, 5 = LVP. DEBUG, 6 = -. DEBUG, 7 = STVREN\nbit 7\nbit 0",
    "bit 7 DEBUG: Background Debugger Enable bit\n1 = Background debugger disabled. RB6 and RB7 configured as general purpose I/O pins.\n0 = Background debugger enabled. RB6 and RB7 are dedicated to in-circuit debug.",
    "bit 6-3 Unimplemented: Read as ' 0 '\nbit 2 LVP: Low-Voltage ICSP Enable bit\n1 = Low-Voltage ICSP enabled\n0 = Low-Voltage ICSP disabled\nbit 1 Unimplemented: Read as ' 0 '\nbit 0 STVREN: Stack Full/Underflow Reset Enable bit\n1 = Stack full/underflow will cause Reset\n0 = Stack full/underflow will not cause Reset",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-7: CONFIG5L: CONFIGURATION REGISTER 5 LOW (BYTE ADDRESS 300008h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = CP3 (1). -, 5 = CP2. -, 6 = CP1. -, 7 = CP0\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3 CP3: Code Protection bit (1)\n1 = Block 3 (00C000-00FFFFh) not code-protected\n0 = Block 3 (00C000-00FFFFh) code-protected\nNote 1: Unimplemented in PIC18FX525 devices; maintain this bit set.",
    "bit 2 CP2: Code Protection bit\n1 = Block 2 (008000-00BFFFh) not code-protected\n0 = Block 2 (008000-00BFFFh) code-protected",
    "bit 1 CP1: Code Protection bit\n1 = Block 1 (004000-007FFFh) not code-protected\n0 = Block 1 (004000-007FFFh) code-protected",
    "bit 0 CP0: Code Protection bit\n1 = Block 0 (000800-003FFFh) not code-protected\n0 = Block 0 (000800-003FFFh) code-protected",
    "Legend:\nR = Readable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "PIC18F6525/6621/8525/8621\nREGISTER 24-8:",
    "CONFIG5H: CONFIGURATION REGISTER 5 HIGH (BYTE ADDRESS 300009h)\nR/C-1, 1 = R/C-1. R/C-1, 2 = U-0. R/C-1, 3 = U-0. R/C-1, 4 = U-0. R/C-1, 5 = U-0. R/C-1, 6 = U-0. R/C-1, 7 = U-0. CPD, 1 = CPB. CPD, 2 = -. CPD, 3 = -. CPD, 4 = -. CPD, 5 = -. CPD, 6 = -. CPD, 7 = -\nbit 7\nbit 0\nbit 7\nCPD: Data EEPROM Code Protection bit\n1 = Data EEPROM not code-protected\n0 = Data EEPROM code-protected\nbit 6 CPB: Boot Block Code Protection bit\n1 = Boot block (000000-0007FFh) not code-protected\n0 = Boot block (000000-0007FFh) code-protected",
    "bit 5-0 Unimplemented: Read as ' 0 '\nLegend:, 1 = Legend:. R = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 24-9: CONFIG6L: CONFIGURATION REGISTER 6 LOW (BYTE ADDRESS 30000Ah)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = WRT3 (1). -, 5 = WRT2. -, 6 = WRT1. -, 7 = WRT0\nbit 7\nbit 0\nbit 7-4 Unimplemented: Read as ' 0 '\nbit 3\nWRT3:\nWrite Protection bit\n(1)\n1 = Block 3 (00C000-00FFFFh) not write-protected\n0 = Block 3 (00C000-00FFFFh) write-protected\nNote 1: Unimplemented in PIC18FX525 devices; maintain this bit set.",
    "bit 2 WRT2: Write Protection bit\n1 = Block 2 (008000-00BFFFh) not write-protected\n0 = Block 2 (008000-00BFFFh) write-protected",
    "bit 1 WRT1: Write Protection bit\n1 = Block 1 (004000-007FFFh) not write-protected\n0 = Block 1 (004000-007FFFh) write-protected",
    "bit 0 WR0: Write Protection bit\n1 = Block 0 (000800-003FFFh) not write-protected\n0 = Block 0 (000800-003FFFh) write-protected",
    "Legend:\nR = Readable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-10: CONFIG6H: CONFIGURATION REGISTER 6 HIGH (BYTE ADDRESS 30000Bh)\nR/C-1, 1 = R/C-1. R/C-1, 2 = R/C-1. R/C-1, 3 = U-0. R/C-1, 4 = U-0. R/C-1, 5 = U-0. R/C-1, 6 = U-0. R/C-1, 7 = U-0. WRTD, 1 = WRTB. WRTD, 2 = WRTC. WRTD, 3 = -. WRTD, 4 = -. WRTD, 5 = -. WRTD, 6 = -. WRTD, 7 = -\nbit 7\nbit 0",
    "bit 7 WRTD: Data EEPROM Write Protection bit\n1 = Data EEPROM not write-protected\n0 = Data EEPROM write-protected",
    "bit 6 WRTB: Boot Block Write Protection bit\n1 = Boot block (000000-0007FFh) not write-protected\n0 = Boot block (000000-0007FFh) write-protected\nbit 5 WRTC: Configuration Register Write Protection bit\n1 = Configuration registers (300000-3000FFh) not write-protected\n0 = Configuration registers (300000-3000FFh) write-protected",
    "bit 4-0 Unimplemented: Read as ' 0 '\nLegend:, 1 = Legend:. R = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 24-11: CONFIG7L: CONFIGURATION REGISTER 7 LOW (BYTE ADDRESS 30000Ch)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = EBTR3 (1). -, 5 = EBTR2. -, 6 = EBTR1. -, 7 = EBTR0\nbit 7\nbit 0",
    "bit 3\nEBTR3: Table Read Protection bit (1)\n1 = Block 3 (00C000-00FFFFh) not protected from table reads executed in other blocks\n0 = Block 3 (00C000-00FFFFh) protected from table reads executed in other blocks\nNote 1: Unimplemented in PIC18FX525 devices; maintain this bit set.",
    "bit 2 EBTR2: Table Read Protection bit\n1 = Block 2 (008000-00BFFFh) not protected from table reads executed in other blocks\n0 = Block 2 (008000-00BFFFh) protected from table reads executed in other blocks",
    "bit 1 EBTR1: Table Read Protection bit\n1 = Block 1 (004000-007FFFh) not protected from table reads executed in other blocks\n0\n= Block 1 (004000-007FFFh) protected from table reads executed in other blocks",
    "bit 0 EBTR0: Table Read Protection bit\n1 = Block 0 (000800-003FFFh) not protected from table reads executed in other blocks\n0 = Block 0 (000800-003FFFh) protected from table reads executed in other blocks",
    "Legend:\nR = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 24-12: CONFIG7H: CONFIGURATION REGISTER 7 HIGH (BYTE ADDRESS 30000Dh)\nU-0, 1 = R/C-1. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = U-0. -, 1 = EBTRB. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = -\nbit 7\nbit 0",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6 EBTRB: Boot Block Table Read Protection bit\n1 = Boot block (000000-0007FFh) not protected from table reads executed in other blocks\n0 = Boot block (000000-0007FFh) protected from table reads executed in other blocks",
    "Legend:\nR = Readable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-13: DEVID1: DEVICE ID REGISTER 1 FOR PIC18F6525/6621/8525/8621 DEVICES (ADDRESS 3FFFFEh)\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV2, 1 = DEV1. DEV2, 2 = DEV0. DEV2, 3 = REV4. DEV2, 4 = REV3. DEV2, 5 = REV2. DEV2, 6 = REV1. DEV2, 7 = REV0\nbit 7\nbit 0",
    "bit 7-5 DEV2:DEV0: Device ID bits\n100 = PIC18F8621\n101 = PIC18F6621\n110 = PIC18F8525\n111 = PIC18F6525",
    "bit 4-0 REV4:REV0: Revision ID bits\nThese bits are used to indicate the device revision.",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-14: DEVID2: DEVICE ID REGISTER 2 FOR PIC18F6525/6621/8525/8621 DEVICES (ADDRESS 3FFFFFh)\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-1. R-0, 5 = R-0. R-0, 6 = R-1. R-0, 7 = R-0. DEV10, 1 = DEV9. DEV10, 2 = DEV8. DEV10, 3 = DEV7. DEV10, 4 = DEV6. DEV10, 5 = DEV5. DEV10, 6 = DEV4. DEV10, 7 = DEV3\nbit 7\nbit 0",
    "bit 7-0 DEV10:DEV3: Device ID bits\nThese bits are used with the DEV2:DEV0 bits in the Device ID Register 1 to identify the part number.\n0000 1010 = PIC18F6525/6621/8525/8621",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "24.2 Watchdog Timer (WDT)\nThe  Watchdog  Timer  is  a  free  running  on-chip  RC oscillator which does not require any external components. This RC oscillator is  separate from  the RC oscillator of the OSC1/CLKI pin. That means that the WDT will run even if the clock on the OSC1/CLKI and  OSC2/CLKO/RA6  pins  of  the  device  has  been stopped, for example,  by  execution of a SLEEP instruction.\nDuring normal operation, a WDT time-out generates a device Reset (Watchdog Timer Reset). If the device is in Sleep mode, a WDT time-out causes the device to wake-up and continue with normal operation (Watchdog Timer wake-up). The TO bit in the RCON register will be cleared upon a WDT time-out.\nThe WDT time-out period values may be found in the Electrical  Specifications  section  under  parameter  31. Values for the WDT postscaler may be assigned using the configuration bits.",
    "24.2 Watchdog Timer (WDT)\nNote 1: The CLRWDT and SLEEP instructions clear the WDT  and  the  postscaler  if assigned to the WDT and prevent it from timing out and generating a device Reset condition.\n2: When a CLRWDT instruction  is  executed and  the  postscaler  is  assigned  to  the WDT, the postscaler count will be cleared but the postscaler assignment  is  not changed.\nThe Watchdog Timer is enabled or disabled by a device configuration bit, WDTEN (CONFIG2H<0>). If WDTEN is set, software execution may not disable this function. When WDTEN is cleared, the SWDTEN bit enables or disables the operation of the WDT.",
    "24.2.1 CONTROL REGISTER\nRegister 24-15 shows the WDTCON register. This is a readable and writable register which contains a control bit  that  allows  software  to  override  the  WDT  enable configuration  bit  only  when  the  configuration  bit  has disabled the WDT.",
    "REGISTER 24-15: WDTCON: WATCHDOG TIMER CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = SWDTEN\nbit 7\nbit 0",
    "bit 7-1 Unimplemented : Read as ' 0 '\nbit 0\nSWDTEN: Software Controlled Watchdog Timer Enable bit\n1 = Watchdog Timer is on\n0 = Watchdog Timer is turned off (if CONFIG2H<0> = 0 )",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "24.2.2 WDT POSTSCALER\nThe WDT has a postscaler that can extend the WDT Reset period. The postscaler is selected at the time of the  device  programming  by  the  value  written  to  the CONFIG2H Configuration register.",
    "TABLE 24-2: SUMMARY OF REGISTERS ASSOCIATED WITH THE WATCHDOG TIMER\n\nLegend: Shaded cells are not used by the Watchdog Timer.",
    "TABLE 24-2: SUMMARY OF REGISTERS ASSOCIATED WITH THE WATCHDOG TIMER\nCONFIG2H, Bit 7 = -. CONFIG2H, Bit 6 = -. CONFIG2H, Bit 5 = -. CONFIG2H, Bit 4 = WDTPS3. CONFIG2H, Bit 3 = WDTPS2. CONFIG2H, Bit 2 = WDTPS2. CONFIG2H, Bit 1 = WDTPS0. CONFIG2H, Bit 0 = WDTEN. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. WDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN",
    "24.3 Power-Down Mode (Sleep)\nPower-down mode is entered by executing a SLEEP instruction.\nOther  peripherals  cannot  generate  interrupts  since during Sleep, no on-chip clocks are present.\nIf  enabled,  the  Watchdog  Timer  will  be  cleared  but keeps running, the PD bit (RCON<3>) is cleared, the TO (RCON<4>) bit  is  set  and  the  oscillator  driver  is turned off. The I/O ports maintain the status they had before  the SLEEP instruction  was  executed  (driving high, low or high-impedance).\nFor lowest current consumption in this mode, place all I/O pins at either VDD or VSS, ensure no external circuitry is drawing current from the I/O pin, power-down the A/D and disable external clocks. Pull all I/O pins that are high-impedance inputs, high or low externally, to avoid switching currents caused by floating inputs. The T0CKI input should also be at VDD or VSS for lowest current consumption. The contribution from on-chip pull-ups on PORTB should be considered.\nThe MCLR pin must be at a logic high level (VIHMC).",
    "24.3.1 WAKE-UP FROM SLEEP\nThe device can wake-up from Sleep through one of the following events:\n1. External Reset input on MCLR pin.\n2. Watchdog Timer wake-up (if WDT was enabled).\n3. Interrupt  from  INTx  pin,  RB  port  change  or  a peripheral interrupt.\nThe following peripheral interrupts can wake the device from Sleep:\n1. PSP read or write.\n2. TMR1 interrupt. Timer1 must be operating as an asynchronous counter.\n3. TMR3 interrupt. Timer3 must be operating as an asynchronous counter.\n4. CCP Capture mode interrupt (Capture will not occur).\n5. MSSP (Start/Stop) bit detect interrupt.\n6. MSSP transmit or receive in Slave mode (SPI/I 2 C).\n7. USART RXx or TXx (Synchronous Slave mode).\n8. A/D conversion (when A/D clock source is RC).\n9. EEPROM write operation complete.\n10. LVD interrupt.",
    "24.3.1 WAKE-UP FROM SLEEP\nExternal  MCLR Reset will cause a device Reset. All other events are considered a continuation of program execution and will cause a 'wake-up'. The TO and PD bits in the RCON register can be used to determine the cause of the device Reset. The PD bit, which is set on power-up, is cleared when Sleep is invoked. The TO bit is  cleared  if  a  WDT  time-out  occurred  (and  caused wake-up).\nWhen the SLEEP instruction is being executed, the next instruction  (PC  +  2)  is  prefetched.  For  the  device  to wake-up through an interrupt event, the corresponding interrupt enable bit must be set (enabled). Wake-up is regardless of the state of the GIE bit. If the GIE bit is clear (disabled), the device continues execution at the instruction after the SLEEP instruction. If the GIE bit is set (enabled), the device executes the instruction after the SLEEP instruction and  then  branches  to  the interrupt address. In cases where the execution of the instruction  following  Sleep is  not  desirable,  the  user should have a NOP after the SLEEP instruction.",
    "24.3.2 WAKE-UP USING INTERRUPTS\nWhen global interrupts are disabled (GIE cleared) and any interrupt  source  has  both  its  interrupt  enable  bit and interrupt flag bit set, one of the following will occur:\n\u00b7 If an interrupt condition (interrupt flag bit and interrupt enable bits are set) occurs before the execution of a SLEEP instruction, the SLEEP instruction will complete as a NOP . Therefore, the WDT and WDT postscaler will not be cleared, the TO bit will not be set and PD bits will not be cleared.\n\u00b7 If the interrupt condition occurs during or after the execution of a SLEEP instruction, the device will immediately wake-up from Sleep. The SLEEP instruction will be completely executed before the wake-up. Therefore, the WDT and WDT postscaler will be cleared, the TO bit will be set and the PD bit will be cleared.\nEven if the flag bits were checked before executing a SLEEP instruction,  it  may  be  possible  for  flag  bits  to become set before the SLEEP instruction completes. To determine whether a SLEEP instruction executed, test the PD bit. If the PD bit is set, the SLEEP instruction was executed as a NOP .",
    "24.3.2 WAKE-UP USING INTERRUPTS\nTo ensure that the WDT  is  cleared, a CLRWDT instruction should be executed before a SLEEP instruction.",
    "FIGURE 24-2: WAKE-UP FROM SLEEP THROUGH INTERRUPT (1,2)\nNote\n1: XT, HS or LP Oscillator mode assumed.\n2: GIE = 1 assumed. In this case, after wake-up, the processor jumps to the interrupt routine. If GIE = 0 , execution will continue in-line.\n3: TOST = 1024 TOSC (drawing not to scale). This delay will not occur for RC and EC Oscillator modes.\n4: CLKO is not available in these oscillator modes but shown here for timing reference.",
    "24.4 Program Verification and Code Protection\nEach  of  the  blocks  has  three  code  protection  bits associated with them. They are:\nThe  overall  structure  of  the  code  protection  on  the PIC18 Flash devices differs significantly from other PIC devices.\n\u00b7 Code-Protect bit (CPn)\n\u00b7 Write-Protect bit (WRTn)\n\u00b7 External Block Table Read bit (EBTRn)\nThe user program memory is divided on binary boundaries into four blocks of 16 Kbytes each. The first block is further  divided  into  a  boot  block  of  2048  bytes  and  a second block (Block 0) of 14 Kbytes.\nFigure 24-3 shows the program memory organization for  48  and  64-Kbyte  devices  and  the  specific  code protection bit  associated with each block. The actual locations of the bits are summarized in Table 24-3.",
    "FIGURE 24-3: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F6525/6621/8525/8621 DEVICES\nBoot Block, MEMORY SIZE/DEVICE.64 Kbytes (PIC18FX621) = Boot Block. Boot Block, Address Range = 000000h 0007FFh. Boot Block, Block Code Protection.Controlled By: = CPB, WRTB, EBTRB. Block 0, MEMORY SIZE/DEVICE.64 Kbytes (PIC18FX621) = Block 0. Block 0, Address Range = 000800h 003FFFh. Block 0, Block Code Protection.Controlled By: = CP0, WRT0, EBTR0. Block 1, MEMORY SIZE/DEVICE.64 Kbytes (PIC18FX621) = Block 1. Block 1, Address Range = 004000h 007FFFh. Block 1, Block Code Protection.Controlled By: = CP1, WRT1, EBTR1. Block 2, MEMORY SIZE/DEVICE.64 Kbytes (PIC18FX621) = Block 2. Block 2, Address Range = 008000h 00BFFFh. Block 2, Block",
    "FIGURE 24-3: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F6525/6621/8525/8621 DEVICES\nCode Protection.Controlled By: = CP2, WRT2, EBTR2. Unimplemented, read ' 0 ', MEMORY SIZE/DEVICE.64 Kbytes (PIC18FX621) = Block 3. Unimplemented, read ' 0 ', Address Range = 00C000h 00FFFFh. Unimplemented, read ' 0 ', Block Code Protection.Controlled By: = CP3, WRT3, EBTR3",
    "TABLE 24-3: SUMMARY OF REGISTERS ASSOCIATED WITH CODE PROTECTION\n300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3 (1). 300008h, Bit 2 = CP2. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4 =",
    "TABLE 24-3: SUMMARY OF REGISTERS ASSOCIATED WITH CODE PROTECTION\n-. 30000Ah, Bit 3 = WRT3 (1). 30000Ah, Bit 2 = WRT2. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3 (1). 30000Ch, Bit 2 = EBTR2. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Dh, File",
    "TABLE 24-3: SUMMARY OF REGISTERS ASSOCIATED WITH CODE PROTECTION\nName = CONFIG7H. 30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -\nLegend: Shaded cells are unimplemented.\nNote 1: Unimplemented in PIC18FX525 devices.",
    "24.4.1 PROGRAM MEMORY CODE PROTECTION\nThe user memory may be read to or written from any location  using  the  table  read  and  table  write  instructions. The Device ID register may be read with table reads.  The  Configuration  registers  may  be  read  and written with the table read and table write instructions.\nIn user mode, the CPn bits have no direct effect. CPn bits inhibit external reads and writes. A block of user memory  may  be  protected  from  table  writes  if  the WRTn configuration bit is ' 0 '.  The EBTRn bits control table  reads.  For  a  block  of  user  memory  with  the EBTRn  bit  set  to  ' 0 ', a  table  read  instruction  that executes from within that block is allowed to read. A\ntable read instruction that executes from a location outside of that block is not allowed to read and will result in  reading  ' 0 's. Figures 24-4  through 24-6  illustrate table write and table read protection.\nNote:",
    "24.4.1 PROGRAM MEMORY CODE PROTECTION\nCode protection bits may only be written to a ' 0 '  from a ' 1 '  state. It  is  not  possible to write  a  ' 1 '  to  a  bit  in  the  ' 0 '  state.  Code protection bits are only set to ' 1 '  by a full chip erase or block erase function. The full chip erase and block erase functions can only  be  initiated  via  ICSP  or  an  external programmer.",
    "FIGURE 24-4: TABLE WRITE (WRTn) DISALLOWED\nPC = 008FFEh, Program Memory.003FFFh TBLWT* = TBLWT*. PC = 008FFEh, Program Memory.000000h 0007FFh 000800h = 007FFFh 008000h 00BFFFh. PC = 008FFEh, Configuration Bit Settings.WRTB,EBTRB = 11 WRT0,EBTR0 = WRT2,EBTR2 = 11. , Program Memory.003FFFh TBLWT* = . , Program Memory.000000h 0007FFh 000800h = 00C000h 00FFFFh. , Configuration Bit Settings.WRTB,EBTRB = 11 WRT0,EBTR0 = WRT3,EBTR3 = 11. Results: All table writes disabled to Block n whenever WRTn = 0 ., Program Memory.003FFFh TBLWT* = Results: All table writes disabled to Block n whenever WRTn = 0 .. Results: All table writes disabled to Block n whenever WRTn = 0",
    "FIGURE 24-4: TABLE WRITE (WRTn) DISALLOWED\n., Program Memory.000000h 0007FFh 000800h = Results: All table writes disabled to Block n whenever WRTn = 0 .. Results: All table writes disabled to Block n whenever WRTn = 0 ., Configuration Bit Settings.WRTB,EBTRB = 11 WRT0,EBTR0 = Results: All table writes disabled to Block n whenever WRTn = 0 .",
    "FIGURE 24-5: EXTERNAL BLOCK TABLE READ (EBTRn) DISALLOWED\nTBLPTR = 000FFFh, Program Memory = . TBLPTR = 000FFFh, Program Memory = 0007FFh 000800h 000000h. TBLPTR = 000FFFh, Configuration Bit Settings = WRTB,EBTRB = 11 WRT0,EBTR0. PC = 004FFEh, Program Memory = TBLRD*. PC = 004FFEh, Program Memory = . PC = 004FFEh, Configuration Bit Settings = WRT1,EBTR1 = 11. Results: All table reads from TABLAT register returns, Program Memory = external blocks to Block a value of ' 0 '.. Results: All table reads from TABLAT register returns, Program Memory = are disabled 00BFFFh 00C000h 00FFFFh. Results: All table reads from TABLAT register returns, Configuration Bit Settings = WRT3,EBTR3 = 11 whenever EBTRn = 0",
    "FIGURE 24-6: EXTERNAL BLOCK TABLE READ (EBTRn) ALLOWED\nTBLPTR = 000FFFh PC = 003FFEh, Program Memory 000000h = TBLRD*. TBLPTR = 000FFFh PC = 003FFEh,  = 0007FFh 000800h 003FFFh 004000h 007FFFh 008000h. TBLPTR = 000FFFh PC = 003FFEh, Configuration Bit Settings = WRTB,EBTRB WRT0,EBTR0 = 10 WRT1,EBTR1 = 11 WRT2,EBTR2 = 11. Results: Table reads permitted within Block n, even when EBTRBn = 0 . TABLAT register returns the value of the data at the location TBLPTR., Program Memory 000000h = Results: Table reads permitted within Block n, even when EBTRBn = 0 . TABLAT register returns the value of the data at the location TBLPTR.. Results: Table reads permitted within Block n, even when EBTRBn = 0 . TABLAT register returns the value of the data at the location TBLPTR.,",
    "FIGURE 24-6: EXTERNAL BLOCK TABLE READ (EBTRn) ALLOWED\n= Results: Table reads permitted within Block n, even when EBTRBn = 0 . TABLAT register returns the value of the data at the location TBLPTR.. Results: Table reads permitted within Block n, even when EBTRBn = 0 . TABLAT register returns the value of the data at the location TBLPTR., Configuration Bit Settings = Results: Table reads permitted within Block n, even when EBTRBn = 0 . TABLAT register returns the value of the data at the location TBLPTR.",
    "24.4.3 CONFIGURATION REGISTER PROTECTION\nThe entire  data  EEPROM  is  protected  from  external reads and writes by two bits: CPD and WRTD. CPD inhibits  external  reads  and  writes  of  data  EEPROM. WRTD inhibits external writes to data EEPROM. The CPU can continue to read data EEPROM regardless of the protection bit settings.\nThe  Configuration  registers  can  be  write-protected. The WRTC bit controls protection of the Configuration registers. In user mode, the WRTC bit is readable only. WRTC  can  only  be  written  via  ICSP  or  an  external programmer.",
    "24.5 ID Locations\nEight memory locations (200000h-200007h) are designated as ID locations where the user can store checksum  or  other  code  identification numbers.  These locations are accessible during normal execution through the TBLRD and TBLWT instructions, or during program/verify. The ID locations can be read when the device is code-protected.",
    "24.6 In-Circuit Serial Programming\u2122 (ICSP\u2122)\nPIC18F6525/6621/8525/8621 microcontrollers can be serially programmed while in the end application circuit. This is simply done with two lines for clock and data and  three  other  lines  for  power,  ground  and  the programming voltage. This allows customers to manufacture boards with unprogrammed devices and then program the microcontroller just before shipping the product. This also allows the most recent firmware or a custom firmware to be programmed.",
    "24.7 In-Circuit Debugger\nWhen the DEBUG  bit in Configuration register, CONFIG4L,  is  programmed  to  a  ' 0 ', the  in-circuit debugger functionality is enabled. This function allows simple debugging functions when used with MPLAB \u00ae IDE. When the microcontroller has this feature enabled, some of the resources are not available for general  use.  Table 24-4  shows  which  features  are consumed by the background debugger.",
    "TABLE 24-4: DEBUGGER RESOURCES\nStack, RB6, RB7 = 2 levels. Program Memory, RB6, RB7 = 512 bytes. Data Memory, RB6, RB7 = 10 bytes\nTo  use  the  in-circuit  debugger  function  of  the  microcontroller, the design must implement In-Circuit Serial Programming connections to MCLR/VPP, VDD, GND, RB7 and RB6. This will interface to the in-circuit debugger module available from Microchip or one of the third party development tool companies.",
    "24.8 Low-Voltage ICSP Programming\nThe  LVP  bit  in  Configuration  register,  CONFIG4L, enables Low-Voltage  ICSP programming. This  mode allows the microcontroller to be programmed via ICSP using a VDD source in the operating voltage range. This only means that VPP does not have to be brought to VIHH, but can instead be left at the normal operating voltage. In this mode, the RB5/KBI1/PGM pin is dedicated to the programming function and ceases to be a general purpose I/O pin. During programming, VDD is applied to the MCLR/VPP pin. To enter Programming mode, VDD must be applied to the RB5/KBI1/PGM pin provided the LVP bit is set. The LVP bit defaults to a ' 1 ' from the factory.",
    "24.8 Low-Voltage ICSP Programming\nNote 1: The High-Voltage Programming mode is always available, regardless of the state of  the  LVP  bit,  by  applying  VIHH  to  the MCLR pin.\n2: While  in  Low-Voltage  ICSP  mode,  the RB5  pin  can  no  longer  be  used  as  a general  purpose  I/O  pin  and  should  be held low during normal operation.\n3: When using Low-Voltage ICSP Programming (LVP) and the pull-ups on PORTB are enabled, bit 5 in the TRISB register must be cleared to disable the pull-up on RB5 and ensure the proper operation of the device.\n4: If  the  device  Master  Clear  is  disabled, verify that either of the following is done to ensure proper entry into ICSP mode:\na.) disable Low-Voltage Programming (CONFIG4L<2> = 0 ); or\nb.) make certain that RB5/KBI1/PGM is held low during entry into ICSP.",
    "24.8 Low-Voltage ICSP Programming\nIf Low-Voltage Programming mode is not used, the LVP bit  can  be  programmed  to  a  ' 0 '  and  RB5/KBI1/PGM becomes a digital I/O pin. However, the LVP bit may only  be  programmed  when  programming  is  entered with VIHH on MCLR/VPP.\nIt should be noted that once the LVP bit is programmed to  ' 0 ',  only  the  High-Voltage  Programming  mode  is available  and  only  High-Voltage  Programming  mode can be used to program the device.\nWhen  using  Low-Voltage  ICSP,  the  part  must  be supplied 4.5V to 5.5V if a bulk erase will be executed. This includes reprogramming of the code-protect bits from an on-state to off-state. For all other cases of LowVoltage  ICSP,  the  part  may  be  programmed  at  the normal operating voltage. This means unique user IDs or user code can be reprogrammed or added.",
    "25.0 INSTRUCTION SET SUMMARY\nThe PIC18 instruction set adds many enhancements to the previous PIC \u00ae  instruction sets, while maintaining an easy migration from these PIC instruction sets.\nMost instructions are a single program memory word (16 bits), but there are three instructions that require two program memory locations.\nEach single-word instruction  is  a 16-bit word  divided into an opcode, which specifies the instruction type and one  or  more  operands,  which  further  specify  the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18 instruction set summary in Table 25-2 lists byte-oriented , bit-oriented , literal and control operations. Table 25-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')\nThe  file  register  designator  'f'  specifies  which  file register is to be used by the instruction.",
    "25.0 INSTRUCTION SET SUMMARY\nThe  destination  designator  'd'  specifies  where  the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result  is  placed  in  the  file  register  specified  in  the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "25.0 INSTRUCTION SET SUMMARY\n\u00b7 A program memory address (specified by 'n')\n\u00b7 The mode of the call or return instructions (specified by 's')\n\u00b7 The mode of the table read and table write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll  instructions  are  a  single  word,  except  for  three double-word instructions. These  three instructions were  made  double-word  instructions  so  that  all  the required information is available in these 32 bits. In the second word, the 4 MSbs are ' 1 's. If this second word is executed as an instruction (by itself), it will execute as a NOP .\nAll  single-word  instructions  are  executed  in  a  single instruction cycle unless a conditional test is true, or the program counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles with the additional instruction cycle(s) executed as a NOP .\nThe double-word instructions execute in two instruction cycles.",
    "25.0 INSTRUCTION SET SUMMARY\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \uf06d s. If a conditional test is true or the program counter is changed as a result of an instruction,  the  instruction  execution  time  is  2 \uf06d s. Two-word branch instructions (if true) would take 3 \uf06d s.\nFigure 25-1 shows the general formats that the instructions can have.\nAll examples use the format ' nnh ' to represent a hexadecimal  number,  where  ' h ' signifies  a  hexadecimal digit.\nThe  Instruction  Set  Summary,  shown  in  Table 25-2, lists the instructions recognized  by  the  Microchip MPASM TM  Assembler.\nSection 25.1 'Instruction Set' provides a description of each instruction.",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\na, Description = RAM access bit a = 0 : RAM location in Access RAM (BSR register is ignored) a = 1 : RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7).. BSR, Description = Bank Select Register. Used to select the current RAM bank.. d, Description = Destination select bit d = 0 : store result in WREG d = 1 : store result in file register f. dest, Description = Destination either the WREG register or the specified register file location.. f, Description = 8-bit register file address (0x00 to 0xFF).. fs, Description = 12-bit register file address (0x000 to 0xFFF). This is the source address.. fd, Description = 12-bit register file address (0x000 to 0xFFF). This is the destination address.. k, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value).. label, Description = Label name.. mm, Description = The",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\nmode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions: No change to register (such as TBLPTR with table reads and writes). *, Description = Post-Increment register (such as TBLPTR with table reads and writes). *+, Description = Post-Decrement register (such as TBLPTR with table reads and writes). +*, Description = Pre-Increment register (such as TBLPTR with table reads and writes). n, Description = The relative address (2's complement number) for relative branch instructions, or the direct address for call/ branch and return instructions.. PRODH, Description = Product of Multiply High Byte.. PRODL, Description = Product of Multiply Low Byte.. s, Description = Fast Call/Return mode select bit s = 0 : do not update into/from shadow registers s = 1 : certain registers loaded into/from shadow registers (Fast mode). u, Description = Unused or unchanged.. WREG, Description = Working register (accumulator).. x, Description = Don't care (' 0 '",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\nor ' 1 ') The assembler will generate code with x = 0 . It is the recommended form of use for compatibility with all Microchip software tools.. TBLPTR, Description = 21-bit Table Pointer (points to a Program Memory location).. TABLAT, Description = 8-bit Table Latch.. TOS, Description = Top-of-Stack.. PC, Description = Program Counter.. PCL, Description = Program Counter Low Byte.. PCH, Description = Program Counter High Byte.. PCLATH, Description = Program Counter High Byte Latch.. PCLATU, Description = Program Counter Upper Byte Latch.. GIE, Description = Global Interrupt Enable bit.. WDT, Description = Watchdog Timer.. TO, Description = Time-out bit.. PD, Description = Power-down bit.. [ ], Description = Optional.. ( ), Description = Contents.. \uf0ae < >, Description = Assigned to. Register bit field.. \uf0ce, Description = In the set of.. italics, Description = User defined term (font is courier).",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nBYTE-ORIENTED FILE REGISTER OPERATIONS, Mnemonic,.Operands = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Description.Description = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Cycles.Cycles = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = . BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = . BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = . BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.LSb = . BYTE-ORIENTED FILE REGISTER OPERATIONS, Status Affected.Status Affected = . BYTE-ORIENTED FILE REGISTER OPERATIONS, Notes.Notes = . ADDWF, Mnemonic,.Operands = f, d, a. ADDWF, Description.Description = Add WREG and f. ADDWF, Cycles.Cycles = 1. ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word.MSb = 01da. ADDWF, 16-Bit Instruction Word. = ffff. ADDWF,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n16-Bit Instruction Word.LSb = ffff. ADDWF, Status Affected.Status Affected = C, DC, Z, OV, N. ADDWF, Notes.Notes = 1, 2. ADDWFC, Mnemonic,.Operands = f, d, a. ADDWFC, Description.Description = Add WREG and Carry bit to f. ADDWFC, Cycles.Cycles = 1. ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word.MSb = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status Affected.Status Affected = C, DC, Z, OV, N. ADDWFC, Notes.Notes = 1, 2. ANDWF, Mnemonic,.Operands = f, d, a. ANDWF, Description.Description = AND WREG with f. ANDWF, Cycles.Cycles = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nANDWF, 16-Bit Instruction Word.MSb = 01da. ANDWF, 16-Bit Instruction Word. = ffff. ANDWF, 16-Bit Instruction Word.LSb = ffff. ANDWF, Status Affected.Status Affected = Z, N. ANDWF, Notes.Notes = 1,2. CLRF, Mnemonic,.Operands = f, a. CLRF, Description.Description = Clear f. CLRF, Cycles.Cycles = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word.MSb = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status Affected.Status Affected = Z. CLRF, Notes.Notes = 2. COMF, Mnemonic,.Operands = f, d, a. COMF, Description.Description = Complement f. COMF, Cycles.Cycles = . COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nWord.MSb = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status Affected.Status Affected = Z, N. COMF, Notes.Notes = 1, 2. CPFSEQ, Mnemonic,.Operands = f, a. CPFSEQ, Description.Description = Compare f with WREG, skip = 1 1. CPFSEQ, Cycles.Cycles = (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word.MSb = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status Affected.Status Affected = None. CPFSEQ, Notes.Notes = 4. CPFSGT, Mnemonic,.Operands = f, a. CPFSGT, Description.Description = Compare f with WREG, skip > 1. CPFSGT, Cycles.Cycles =",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n(2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word.MSb = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status Affected.Status Affected = None. CPFSGT, Notes.Notes = 4. CPFSLT, Mnemonic,.Operands = f, a. CPFSLT, Description.Description = Compare f with WREG, skip < 1. CPFSLT, Cycles.Cycles = (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word.MSb = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status Affected.Status Affected = None. CPFSLT, Notes.Notes = 1, 2. DECF, Mnemonic,.Operands = f, d, a.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nDECF, Description.Description = Decrement f. DECF, Cycles.Cycles = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word.MSb = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status Affected.Status Affected = C, DC, Z, OV, N. DECF, Notes.Notes = 1, 2, 3, 4. DECFSZ, Mnemonic,.Operands = f, d, a. DECFSZ, Description.Description = Decrement f, Skip if 0. DECFSZ, Cycles.Cycles = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word.MSb = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status Affected.Status Affected = None. DECFSZ,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nNotes.Notes = 1, 2, 3, 4. DCFSNZ, Mnemonic,.Operands = f, d, a. DCFSNZ, Description.Description = Decrement f, Skip if Not 0. DCFSNZ, Cycles.Cycles = (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word.MSb = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ, 16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status Affected.Status Affected = None. DCFSNZ, Notes.Notes = 1, 2. INCF, Mnemonic,.Operands = f, d, a. INCF, Description.Description = Increment f. INCF, Cycles.Cycles = 1 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word.MSb = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb =",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nffff. INCF, Status Affected.Status Affected = C, DC, Z, OV, N. INCF, Notes.Notes = 1, 2, 3, 4. INCFSZ, Mnemonic,.Operands = f, d, a. INCFSZ, Description.Description = Increment f, Skip if 0. INCFSZ, Cycles.Cycles = 1 (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word.MSb = 11da. INCFSZ, 16-Bit Instruction Word. = ffff. INCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status Affected.Status Affected = None. INCFSZ, Notes.Notes = 4. INFSNZ, Mnemonic,.Operands = f, d, a. INFSNZ, Description.Description = Increment f, Skip if Not 0. INFSNZ, Cycles.Cycles = 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n16-Bit Instruction Word.MSb = 10da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status Affected.Status Affected = None. INFSNZ, Notes.Notes = 1, 2. IORWF, Mnemonic,.Operands = f, d, a. IORWF, Description.Description = Inclusive OR WREG with f. IORWF, Cycles.Cycles = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word.MSb = 00da. IORWF, 16-Bit Instruction Word. = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status Affected.Status Affected = Z, N. IORWF, Notes.Notes = 1, 2. MOVF, Mnemonic,.Operands = f, d, a. MOVF, Description.Description = Move f. MOVF, Cycles.Cycles = .",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nMOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word.MSb = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status Affected.Status Affected = Z, N. MOVF, Notes.Notes = 1. MOVFF, Mnemonic,.Operands = f s , f d. MOVFF, Description.Description = Move f s (source) to 1st word f d (destination)2nd word 1 2. MOVFF, Cycles.Cycles = . MOVFF, 16-Bit Instruction Word.MSb = 1100 1111. MOVFF, 16-Bit Instruction Word.MSb = ffff ffff. MOVFF, 16-Bit Instruction Word. = ffff ffff. MOVFF, 16-Bit Instruction Word.LSb = ffff ffff. MOVFF, Status Affected.Status Affected = None. MOVFF, Notes.Notes = . MOVWF, Mnemonic,.Operands =",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nf, a. MOVWF, Description.Description = Move WREG to f. MOVWF, Cycles.Cycles = 1. MOVWF, 16-Bit Instruction Word.MSb = 0110. MOVWF, 16-Bit Instruction Word.MSb = 111a. MOVWF, 16-Bit Instruction Word. = ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff. MOVWF, Status Affected.Status Affected = None. MOVWF, Notes.Notes = . MULWF, Mnemonic,.Operands = f, a. MULWF, Description.Description = Multiply WREG with f. MULWF, Cycles.Cycles = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word.MSb = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status Affected.Status Affected = None.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nMULWF, Notes.Notes = . NEGF, Mnemonic,.Operands = f, a. NEGF, Description.Description = Negate f. NEGF, Cycles.Cycles = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word.MSb = 110a. NEGF, 16-Bit Instruction Word. = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status Affected.Status Affected = C, DC, Z, OV, N. NEGF, Notes.Notes = 1, 2. RLCF, Mnemonic,.Operands = f, d, a. RLCF, Description.Description = Rotate Left f through Carry. RLCF, Cycles.Cycles = 1. RLCF, 16-Bit Instruction Word.MSb = 0011. RLCF, 16-Bit Instruction Word.MSb = 01da. RLCF, 16-Bit Instruction Word. = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nAffected.Status Affected = C, Z, N. RLCF, Notes.Notes = . RLNCF, Mnemonic,.Operands = f, d, a. RLNCF, Description.Description = Rotate Left f (No Carry). RLNCF, Cycles.Cycles = 1. RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word.MSb = 01da. RLNCF, 16-Bit Instruction Word. = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status Affected.Status Affected = Z, N. RLNCF, Notes.Notes = 1, 2. RRCF, Mnemonic,.Operands = f, d, a. RRCF, Description.Description = Rotate Right f through Carry. RRCF, Cycles.Cycles = 1. RRCF, 16-Bit Instruction Word.MSb = 0011. RRCF, 16-Bit Instruction Word.MSb = 00da. RRCF, 16-Bit Instruction",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nWord. = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status Affected.Status Affected = C, Z, N. RRCF, Notes.Notes = . RRNCF, Mnemonic,.Operands = f, d, a. RRNCF, Description.Description = Rotate Right f (No Carry). RRNCF, Cycles.Cycles = 1. RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word.MSb = 00da. RRNCF, 16-Bit Instruction Word. = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff. RRNCF, Status Affected.Status Affected = Z, N. RRNCF, Notes.Notes = . SETF, Mnemonic,.Operands = f, a. SETF, Description.Description = Set f. SETF, Cycles.Cycles = 1. SETF, 16-Bit Instruction Word.MSb = 0110. SETF, 16-Bit Instruction Word.MSb = 100a. SETF,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n16-Bit Instruction Word. = ffff. SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status Affected.Status Affected = None. SETF, Notes.Notes = . SUBFWB, Mnemonic,.Operands = f, d, a. SUBFWB, Description.Description = Subtract f from WREG with borrow. SUBFWB, Cycles.Cycles = 1. SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word.MSb = 01da. SUBFWB, 16-Bit Instruction Word. = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff. SUBFWB, Status Affected.Status Affected = C, DC, Z, OV, N. SUBFWB, Notes.Notes = 1, 2. SUBWF, Mnemonic,.Operands = f, d, a. SUBWF, Description.Description = Subtract WREG from f. SUBWF, Cycles.Cycles = 1. SUBWF,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n16-Bit Instruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word.MSb = 11da. SUBWF, 16-Bit Instruction Word. = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status Affected.Status Affected = C, DC, Z, OV, N. SUBWF, Notes.Notes = . SUBWFB, Mnemonic,.Operands = f, d, a. SUBWFB, Description.Description = Subtract WREG from f with borrow. SUBWFB, Cycles.Cycles = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction Word.MSb = 10da. SUBWFB, 16-Bit Instruction Word. = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status Affected.Status Affected = C, DC, Z, OV, N. SUBWFB, Notes.Notes = 1, 2. SWAPF, Mnemonic,.Operands = f, d,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\na. SWAPF, Description.Description = Swap nibbles in f. SWAPF, Cycles.Cycles = 1. SWAPF, 16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word.MSb = 10da. SWAPF, 16-Bit Instruction Word. = ffff. SWAPF, 16-Bit Instruction Word.LSb = ffff. SWAPF, Status Affected.Status Affected = None. SWAPF, Notes.Notes = 4. TSTFSZ, Mnemonic,.Operands = f, a. TSTFSZ, Description.Description = Test f, skip if 0. TSTFSZ, Cycles.Cycles = 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word.MSb = 0110. TSTFSZ, 16-Bit Instruction Word.MSb = 011a. TSTFSZ, 16-Bit Instruction Word. = ffff. TSTFSZ, 16-Bit Instruction Word.LSb = ffff. TSTFSZ, Status Affected.Status Affected = None. TSTFSZ, Notes.Notes = 1, 2. XORWF,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nMnemonic,.Operands = f, d, a. XORWF, Description.Description = Exclusive OR WREG with f. XORWF, Cycles.Cycles = 1. XORWF, 16-Bit Instruction Word.MSb = 0001. XORWF, 16-Bit Instruction Word.MSb = 10da. XORWF, 16-Bit Instruction Word. = ffff. XORWF, 16-Bit Instruction Word.LSb = ffff. XORWF, Status Affected.Status Affected = Z, N. XORWF, Notes.Notes = . BIT-ORIENTED FILE REGISTER OPERATIONS, Mnemonic,.Operands = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Description.Description = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Cycles.Cycles = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n16-Bit Instruction Word. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.LSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Status Affected.Status Affected = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Notes.Notes = BIT-ORIENTED FILE REGISTER OPERATIONS. BCF, Mnemonic,.Operands = f, b, a. BCF, Description.Description = Bit Clear f. BCF, Cycles.Cycles = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word.MSb = bbba. BCF, 16-Bit Instruction Word. = ffff. BCF, 16-Bit Instruction Word.LSb = ffff. BCF, Status Affected.Status Affected = None. BCF, Notes.Notes = 1, 2. BSF, Mnemonic,.Operands = f, b, a. BSF, Description.Description = Bit Set f. BSF, Cycles.Cycles = 1. BSF, 16-Bit Instruction Word.MSb = 1000.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nBSF, 16-Bit Instruction Word.MSb = bbba. BSF, 16-Bit Instruction Word. = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status Affected.Status Affected = None. BSF, Notes.Notes = 1, 2. BTFSC, Mnemonic,.Operands = f, b, a. BTFSC, Description.Description = Bit Test f, Skip if Clear. BTFSC, Cycles.Cycles = 1 (2 or 3). BTFSC, 16-Bit Instruction Word.MSb = 1011. BTFSC, 16-Bit Instruction Word.MSb = bbba. BTFSC, 16-Bit Instruction Word. = ffff. BTFSC, 16-Bit Instruction Word.LSb = ffff. BTFSC, Status Affected.Status Affected = None. BTFSC, Notes.Notes = 3, 4. BTFSS, Mnemonic,.Operands = f, b, a. BTFSS, Description.Description = Bit Test f, Skip if Set. BTFSS, Cycles.Cycles = 1",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\n(2 or 3). BTFSS, 16-Bit Instruction Word.MSb = 1010. BTFSS, 16-Bit Instruction Word.MSb = bbba. BTFSS, 16-Bit Instruction Word. = ffff. BTFSS, 16-Bit Instruction Word.LSb = ffff. BTFSS, Status Affected.Status Affected = None. BTFSS, Notes.Notes = 3, 4. BTG, Mnemonic,.Operands = f, b, a. BTG, Description.Description = Bit Toggle f. BTG, Cycles.Cycles = 1. BTG, 16-Bit Instruction Word.MSb = 0111. BTG, 16-Bit Instruction Word.MSb = bbba. BTG, 16-Bit Instruction Word. = ffff. BTG, 16-Bit Instruction Word.LSb = ffff. BTG, Status Affected.Status Affected = None. BTG, Notes.Notes = 1, 2",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as an input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, 'd' = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nCONTROL OPERATIONS, Mnemonic,.Operands = CONTROL OPERATIONS. CONTROL OPERATIONS, Description.Description = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles.Cycles = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected. = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes.Notes = CONTROL OPERATIONS. BC, Mnemonic,.Operands = n. BC, Description.Description = Branch if Carry 1. BC, Cycles.Cycles = (2). BC, 16-Bit Instruction Word.MSb = 1110. BC, 16-Bit Instruction Word. = 0010. BC, 16-Bit Instruction Word. = nnnn. BC, 16-Bit Instruction Word.LSb = nnnn. BC, Status Affected. = None. BC, Notes.Notes = . BN, Mnemonic,.Operands = n. BN, Description.Description = Branch if Negative 1. BN, Cycles.Cycles =",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n(2). BN, 16-Bit Instruction Word.MSb = 1110. BN, 16-Bit Instruction Word. = 0110. BN, 16-Bit Instruction Word. = nnnn. BN, 16-Bit Instruction Word.LSb = nnnn. BN, Status Affected. = None. BN, Notes.Notes = . BNC, Mnemonic,.Operands = n. BNC, Description.Description = Branch if Not Carry 1. BNC, Cycles.Cycles = (2). BNC, 16-Bit Instruction Word.MSb = 1110. BNC, 16-Bit Instruction Word. = 0011. BNC, 16-Bit Instruction Word. = nnnn. BNC, 16-Bit Instruction Word.LSb = nnnn. BNC, Status Affected. = None. BNC, Notes.Notes = . BNN, Mnemonic,.Operands = n. BNN, Description.Description = Branch if Not Negative 1. BNN, Cycles.Cycles = (2). BNN, 16-Bit Instruction Word.MSb = 1110. BNN,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n16-Bit Instruction Word. = 0111. BNN, 16-Bit Instruction Word. = nnnn. BNN, 16-Bit Instruction Word.LSb = nnnn. BNN, Status Affected. = None. BNN, Notes.Notes = . BNOV, Mnemonic,.Operands = n. BNOV, Description.Description = Branch if Not Overflow 1. BNOV, Cycles.Cycles = (2). BNOV, 16-Bit Instruction Word.MSb = 1110. BNOV, 16-Bit Instruction Word. = 0101. BNOV, 16-Bit Instruction Word. = nnnn. BNOV, 16-Bit Instruction Word.LSb = nnnn. BNOV, Status Affected. = None. BNOV, Notes.Notes = . BNZ, Mnemonic,.Operands = n. BNZ, Description.Description = Branch if Not Zero 2. BNZ, Cycles.Cycles = . BNZ, 16-Bit Instruction Word.MSb = 1110. BNZ, 16-Bit Instruction Word. = 0001. BNZ, 16-Bit Instruction Word.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= nnnn. BNZ, 16-Bit Instruction Word.LSb = nnnn. BNZ, Status Affected. = None. BNZ, Notes.Notes = . BOV, Mnemonic,.Operands = n. BOV, Description.Description = Branch if Overflow 1. BOV, Cycles.Cycles = (2). BOV, 16-Bit Instruction Word.MSb = 1110. BOV, 16-Bit Instruction Word. = 0100. BOV, 16-Bit Instruction Word. = nnnn. BOV, 16-Bit Instruction Word.LSb = nnnn. BOV, Status Affected. = None. BOV, Notes.Notes = . BRA, Mnemonic,.Operands = n. BRA, Description.Description = Branch Unconditionally 1. BRA, Cycles.Cycles = (2). BRA, 16-Bit Instruction Word.MSb = 1101. BRA, 16-Bit Instruction Word. = 0nnn. BRA, 16-Bit Instruction Word. = nnnn. BRA, 16-Bit Instruction Word.LSb = nnnn.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nBRA, Status Affected. = None. BRA, Notes.Notes = . BZ, Mnemonic,.Operands = n. BZ, Description.Description = Branch if Zero 1. BZ, Cycles.Cycles = (2). BZ, 16-Bit Instruction Word.MSb = 1110. BZ, 16-Bit Instruction Word. = 0000. BZ, 16-Bit Instruction Word. = nnnn. BZ, 16-Bit Instruction Word.LSb = nnnn. BZ, Status Affected. = None. BZ, Notes.Notes = . CALL, Mnemonic,.Operands = n, s. CALL, Description.Description = Call subroutine 1st word 2nd word 2. CALL, Cycles.Cycles = . CALL, 16-Bit Instruction Word.MSb = 1110. CALL, 16-Bit Instruction Word. = 110s. CALL, 16-Bit Instruction Word. = kkkk. CALL, 16-Bit Instruction Word.LSb = kkkk. CALL, Status Affected. = None. CALL, Notes.Notes = . CLRWDT,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = -. CLRWDT, Description.Description = Clear Watchdog Timer 1. CLRWDT, Cycles.Cycles = . CLRWDT, 16-Bit Instruction Word.MSb = 0000. CLRWDT, 16-Bit Instruction Word. = 0000. CLRWDT, 16-Bit Instruction Word. = 0000. CLRWDT, 16-Bit Instruction Word.LSb = 0100. CLRWDT, Status Affected. = TO, PD. CLRWDT, Notes.Notes = . DAW, Mnemonic,.Operands = -. DAW, Description.Description = Decimal Adjust WREG 1. DAW, Cycles.Cycles = . DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word.LSb = 0111. DAW, Status Affected. = C. DAW, Notes.Notes = . GOTO, Mnemonic,.Operands =",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nn. GOTO, Description.Description = Go to address 1st word 2nd word 2. GOTO, Cycles.Cycles = . GOTO, 16-Bit Instruction Word.MSb = 1110 1111. GOTO, 16-Bit Instruction Word. = 1111 kkkk. GOTO, 16-Bit Instruction Word. = kkkk kkkk. GOTO, 16-Bit Instruction Word.LSb = kkkk kkkk. GOTO, Status Affected. = None. GOTO, Notes.Notes = . NOP, Mnemonic,.Operands = -. NOP, Description.Description = No Operation 1. NOP, Cycles.Cycles = . NOP, 16-Bit Instruction Word.MSb = 0000. NOP, 16-Bit Instruction Word. = 0000. NOP, 16-Bit Instruction Word. = 0000. NOP, 16-Bit Instruction Word.LSb = 0000. NOP, Status Affected. = None. NOP, Notes.Notes = . NOP, Mnemonic,.Operands = -. NOP, Description.Description = No Operation 1.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNOP, Cycles.Cycles = . NOP, 16-Bit Instruction Word.MSb = 1111. NOP, 16-Bit Instruction Word. = xxxx. NOP, 16-Bit Instruction Word. = xxxx. NOP, 16-Bit Instruction Word.LSb = xxxx. NOP, Status Affected. = None. NOP, Notes.Notes = 4. POP, Mnemonic,.Operands = -. POP, Description.Description = Pop top of return stack (TOS). POP, Cycles.Cycles = . POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word.LSb = 0110. POP, Status Affected. = None. POP, Notes.Notes = . PUSH, Mnemonic,.Operands = -. PUSH, Description.Description = Push top of return stack (TOS) 1 1. PUSH, Cycles.Cycles = . PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nWord. = 0000. PUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word.LSb = 0101. PUSH, Status Affected. = None. PUSH, Notes.Notes = . RCALL, Mnemonic,.Operands = n. RCALL, Description.Description = Relative Call 2. RCALL, Cycles.Cycles = . RCALL, 16-Bit Instruction Word.MSb = 1101. RCALL, 16-Bit Instruction Word. = 1nnn. RCALL, 16-Bit Instruction Word. = nnnn. RCALL, 16-Bit Instruction Word.LSb = nnnn. RCALL, Status Affected. = None. RCALL, Notes.Notes = . RESET, Mnemonic,.Operands = . RESET, Description.Description = Software device Reset 1. RESET, Cycles.Cycles = . RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word. = 0000. RESET, 16-Bit Instruction Word. = 1111. RESET, 16-Bit Instruction Word.LSb = 1111. RESET, Status Affected.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= All. RESET, Notes.Notes = . RETFIE, Mnemonic,.Operands = s. RETFIE, Description.Description = Return from interrupt enable 2. RETFIE, Cycles.Cycles = . RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word. = 0000. RETFIE, 16-Bit Instruction Word. = 0001. RETFIE, 16-Bit Instruction Word.LSb = 000s. RETFIE, Status Affected. = GIE/GIEH, PEIE/GIEL. RETFIE, Notes.Notes = . RETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG 2. RETLW, Cycles.Cycles = . RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word. = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nAffected. = None. RETLW, Notes.Notes = . RETURN, Mnemonic,.Operands = s. RETURN, Description.Description = Return from Subroutine 2. RETURN, Cycles.Cycles = . RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word. = 0000. RETURN, 16-Bit Instruction Word. = 0001. RETURN, 16-Bit Instruction Word.LSb = 001s. RETURN, Status Affected. = None. RETURN, Notes.Notes = . SLEEP, Mnemonic,.Operands = -. SLEEP, Description.Description = Go into Standby mode 1. SLEEP, Cycles.Cycles = . SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word.LSb = 0011. SLEEP, Status Affected. = TO, PD. SLEEP, Notes.Notes = ",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as an input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, 'd' = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nLITERAL OPERATIONS, Mnemonic,.Operands = LITERAL OPERATIONS. LITERAL OPERATIONS, Description.Description = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles.Cycles = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected.Status Affected = LITERAL OPERATIONS. LITERAL OPERATIONS,  = LITERAL OPERATIONS. ADDLW, Mnemonic,.Operands = k. ADDLW, Description.Description = Add literal and WREG. ADDLW, Cycles.Cycles = 1. ADDLW, 16-Bit Instruction Word.MSb = 0000. ADDLW, 16-Bit Instruction Word.MSb = 1111. ADDLW, 16-Bit Instruction Word. = kkkk. ADDLW, 16-Bit Instruction Word.LSb = kkkk. ADDLW, Status Affected.Status Affected = C, DC, Z, OV, N. ADDLW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . ANDLW, Mnemonic,.Operands = k. ANDLW, Description.Description = AND literal with WREG. ANDLW, Cycles.Cycles = 1. ANDLW, 16-Bit Instruction Word.MSb = 0000. ANDLW, 16-Bit Instruction Word.MSb = 1011. ANDLW, 16-Bit Instruction Word. = kkkk. ANDLW, 16-Bit Instruction Word.LSb = kkkk. ANDLW, Status Affected.Status Affected = Z, N. ANDLW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . IORLW, Mnemonic,.Operands = k. IORLW, Description.Description = Inclusive OR literal with WREG. IORLW, Cycles.Cycles = 1. IORLW, 16-Bit Instruction Word.MSb = 0000. IORLW, 16-Bit Instruction Word.MSb = 1001. IORLW, 16-Bit Instruction Word. = kkkk. IORLW, 16-Bit Instruction Word.LSb = kkkk. IORLW, Status Affected.Status Affected = Z, N. IORLW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . LFSR, Mnemonic,.Operands = f, k. LFSR, Description.Description = Move literal (12-bit) 2nd word to FSRx 1st word. LFSR, Cycles.Cycles = 2. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word. = 00ff. LFSR, 16-Bit Instruction Word.LSb = kkkk. LFSR, Status Affected.Status Affected = None. LFSR,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . MOVLB, Mnemonic,.Operands = k. MOVLB, Description.Description = Move literal to BSR<3:0>. MOVLB, Cycles.Cycles = 1. MOVLB, 16-Bit Instruction Word.MSb = 0000. MOVLB, 16-Bit Instruction Word.MSb = 0001. MOVLB, 16-Bit Instruction Word. = 0000. MOVLB, 16-Bit Instruction Word.LSb = kkkk kkkk. MOVLB, Status Affected.Status Affected = None. MOVLB,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . MOVLW, Mnemonic,.Operands = k. MOVLW, Description.Description = Move literal to WREG. MOVLW, Cycles.Cycles = 1. MOVLW, 16-Bit Instruction Word.MSb = 0000. MOVLW, 16-Bit Instruction Word.MSb = 1110. MOVLW, 16-Bit Instruction Word. = kkkk. MOVLW, 16-Bit Instruction Word.LSb = . MOVLW, Status Affected.Status Affected = None. MOVLW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . MULLW, Mnemonic,.Operands = k. MULLW, Description.Description = Multiply literal with WREG. MULLW, Cycles.Cycles = 1. MULLW, 16-Bit Instruction Word.MSb = 0000. MULLW, 16-Bit Instruction Word.MSb = 1101. MULLW, 16-Bit Instruction Word. = kkkk. MULLW, 16-Bit Instruction Word.LSb = kkkk. MULLW, Status Affected.Status Affected = None. MULLW,  = . RETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected.Status Affected = None. RETLW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . SUBLW, Mnemonic,.Operands = k. SUBLW, Description.Description = Subtract WREG from literal. SUBLW, Cycles.Cycles = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000. SUBLW, 16-Bit Instruction Word.MSb = 1000. SUBLW, 16-Bit Instruction Word. = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected.Status Affected = C, DC, Z, OV, N. SUBLW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . XORLW, Mnemonic,.Operands = k. XORLW, Description.Description = Exclusive OR literal with WREG. XORLW, Cycles.Cycles = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word.MSb = 1010. XORLW, 16-Bit Instruction Word. = kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected.Status Affected = Z, N. XORLW,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Mnemonic,.Operands = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Description.Description = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Cycles.Cycles = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word. = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.LSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Status Affected.Status Affected = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. TBLRD*, Mnemonic,.Operands = TBLRD*. TBLRD*, Description.Description = Table Read. TBLRD*, Cycles.Cycles = 2. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected.Status Affected = None. TBLRD*,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLRD*+, Mnemonic,.Operands = TBLRD*+. TBLRD*+, Description.Description = Table Read with post-increment. TBLRD*+, Cycles.Cycles = . TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected.Status Affected = None. TBLRD*+,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLRD*-, Mnemonic,.Operands = TBLRD*-. TBLRD*-, Description.Description = Table Read with post-decrement. TBLRD*-, Cycles.Cycles = . TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected.Status Affected = None. TBLRD*-,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLRD+*, Mnemonic,.Operands = TBLRD+*. TBLRD+*, Description.Description = Table Read with pre-increment. TBLRD+*, Cycles.Cycles = . TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected.Status Affected = None. TBLRD+*,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT*, Mnemonic,.Operands = TBLWT*. TBLWT*, Description.Description = Table Write. TBLWT*, Cycles.Cycles = 2 (5). TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status Affected.Status Affected = None. TBLWT*,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT*+, Mnemonic,.Operands = TBLWT*+. TBLWT*+, Description.Description = Table Write with post-increment. TBLWT*+, Cycles.Cycles = . TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected.Status Affected = None. TBLWT*+,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT*-, Mnemonic,.Operands = TBLWT*-. TBLWT*-, Description.Description = Table Write with post-decrement. TBLWT*-, Cycles.Cycles = . TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected.Status Affected = None. TBLWT*-,",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT+*, Mnemonic,.Operands = TBLWT+*. TBLWT+*, Description.Description = Table Write with pre-increment. TBLWT+*, Cycles.Cycles = . TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word.LSb = 1111. TBLWT+*, Status Affected.Status Affected = None. TBLWT+*,  = ",
    "TABLE 25-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as an input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, 'd' = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "25.1 Instruction Set\nSyntax:, Add Literal to W = [ label ] ADDLW. Syntax:, Add Literal to W = [ label ] ADDLW. Syntax:, Add Literal to W = k. Syntax:, Add Literal to W = k. Operands:, Add Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Add Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Add Literal to W = . Operands:, Add Literal to W = . Operation:, Add Literal to W = (W) + k \uf0ae W. Operation:, Add Literal to W = (W) + k \uf0ae W. Operation:, Add Literal to W = . Operation:, Add Literal to W = . Status Affected:, Add Literal to W = N, OV, C, DC, Z. Status Affected:, Add Literal to W = N, OV, C, DC, Z. Status Affected:, Add Literal to W = . Status Affected:, Add Literal to W = . Encoding:, Add Literal to W = 0000. Encoding:, Add Literal to W = 1111. Encoding:, Add Literal to W = kkkk. Encoding:, Add Literal to W = kkkk.",
    "25.1 Instruction Set\nDescription:, Add Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, Add Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, Add Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, Add Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Words:, Add Literal to W = 1. Words:, Add Literal to W = . Words:, Add Literal to W = . Words:, Add Literal to W = . Cycles:, Add Literal to W = 1. Cycles:, Add Literal to W = . Cycles:, Add Literal to W = . Cycles:, Add Literal to W = . Q Cycle Activity:, Add Literal to W = . Q Cycle Activity:, Add Literal to W = . Q Cycle Activity:, Add Literal to W = . Q Cycle Activity:, Add Literal to W = . Q1, Add Literal to W =",
    "25.1 Instruction Set\nQ2. Q1, Add Literal to W = Q3. Q1, Add Literal to W = . Q1, Add Literal to W = Q4. Decode, Add Literal to W = Read literal 'k'. Decode, Add Literal to W = Process Data. Decode, Add Literal to W = . Decode, Add Literal to W = Write to W. Example:, Add Literal to W = ADDLW. Example:, Add Literal to W = 0x15. Example:, Add Literal to W = . Example:, Add Literal to W = . Before Instruction, Add Literal to W = Before Instruction. Before Instruction, Add Literal to W = . Before Instruction, Add Literal to W = . Before Instruction, Add Literal to W = . W = After Instruction W =, Add Literal to W = 0x10 0x25. W = After Instruction W =, Add Literal to W = . W = After Instruction W =, Add Literal to W = . W = After Instruction W =, Add Literal to W = ",
    "25.1 Instruction Set\nSyntax:, Add Wto f = [ label ] ADDWF. Syntax:, Add Wto f = [ label ] ADDWF. Syntax:, Add Wto f = f [,d [,a] f [,d [,a]. Syntax:, Add Wto f = f [,d [,a] f [,d [,a]. Operands:, Add Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Add Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Add Wto f = . Operands:, Add Wto f = . Operation:, Add Wto f = (W) + (f) \uf0ae dest. Operation:, Add Wto f = (W) + (f) \uf0ae dest. Operation:, Add Wto f = . Operation:, Add Wto f = . Status Affected:, Add Wto f = N, OV, C, DC, Z. Status Affected:, Add Wto f = N, OV, C, DC, Z. Status Affected:, Add Wto",
    "25.1 Instruction Set\nf = . Status Affected:, Add Wto f = . Encoding:, Add Wto f = 0010. Encoding:, Add Wto f = 01da. Encoding:, Add Wto f = ffff. Encoding:, Add Wto f = ffff. Description:, Add Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, Add Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, Add Wto f = Add Wto register 'f'. If 'd'",
    "25.1 Instruction Set\nis ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, Add Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Words:, Add Wto f = 1. Words:, Add Wto f = 1. Words:, Add Wto f = . Words:, Add Wto f = . Cycles:, Add Wto f = 1. Cycles:, Add Wto f = 1. Cycles:, Add Wto f = . Cycles:, Add Wto f = . Q Cycle Activity:, Add Wto f = Q Cycle Activity:. Q Cycle Activity:, Add",
    "25.1 Instruction Set\nWto f = Q Cycle Activity:. Q Cycle Activity:, Add Wto f = . Q Cycle Activity:, Add Wto f = . Q1, Add Wto f = Q2. Q1, Add Wto f = Q3. Q1, Add Wto f = . Q1, Add Wto f = Q4. Decode, Add Wto f = Read register 'f'. Decode, Add Wto f = Process Data. Decode, Add Wto f = . Decode, Add Wto f = Write to destination. Example:, Add Wto f = ADDWF. Example:, Add Wto f = REG, 0,. Example:, Add Wto f = 0. Example:, Add Wto f = . Before Instruction, Add Wto f = Before Instruction. Before Instruction, Add Wto f = . Before Instruction, Add Wto f = . Before Instruction, Add Wto f = . W REG, Add Wto f = = 0x17 =. W REG, Add Wto f = . W REG, Add Wto f = . W REG, Add Wto f = . , Add Wto f =",
    "25.1 Instruction Set\n0xC2. , Add Wto f = . , Add Wto f = . , Add Wto f = . After Instruction, Add Wto f = After Instruction. After Instruction, Add Wto f = . After Instruction, Add Wto f = . After Instruction, Add Wto f = . W, Add Wto f = = 0xD9. W, Add Wto f = . W, Add Wto f = . W, Add Wto f = . REG, Add Wto f = = 0xC2. REG, Add Wto f = . REG, Add Wto f = . REG, Add Wto f = ",
    "Add W and Carry bit to f\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:",
    "Add W and Carry bit to f\nSyntax:, AND Literal with W = [ label ] ANDLW. Syntax:, AND Literal with W = [ label ] ANDLW. Syntax:, AND Literal with W = k. Syntax:, AND Literal with W = . Operands:, AND Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND Literal with W = . Operands:, AND Literal with W = . Operation:, AND Literal with W = (W) .AND. k \uf0ae W. Operation:, AND Literal with W = (W) .AND. k \uf0ae W. Operation:, AND Literal with W = . Operation:, AND Literal with W = . Status Affected:, AND Literal with W = N, Z. Status Affected:, AND Literal with W = N, Z. Status Affected:, AND Literal with W = . Status Affected:, AND Literal with W = . Encoding:, AND Literal with W = 0000. Encoding:, AND Literal with W = 1011. Encoding:, AND Literal with W = kkkk. Encoding:, AND Literal with W = kkkk. Description:, AND Literal with W = The contents",
    "Add W and Carry bit to f\nof Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Words:, AND Literal with W = 1. Words:, AND Literal with W = . Words:, AND Literal with W = . Words:, AND Literal with W = . Cycles:, AND Literal with W = 1. Cycles:, AND Literal with W = . Cycles:, AND Literal with W = . Cycles:, AND Literal with W = . Q Cycle Activity: Q1, AND Literal with W = Q2. Q Cycle Activity: Q1, AND Literal with W = Q3. Q Cycle Activity: Q1, AND Literal with W = . Q Cycle Activity: Q1, AND Literal with W =",
    "Add W and Carry bit to f\nQ4. Decode, AND Literal with W = Read literal 'k'. Decode, AND Literal with W = Process Data. Decode, AND Literal with W = . Decode, AND Literal with W = Write to W\nCycles:\n[ label ] ADDWFC      f [,d [,a]\n0 \uf0a3 f \uf0a3 255\nd \uf0ce\uf020 [0,1]\na \uf0ce\uf020 [0,1]\n(W) + (f) + (C) \uf0ae dest\nN, OV, C, DC, Z\n0010\n00da ffff\nffff\nAdd W, the Carry flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "Example:\nADDWFC\nREG, 0, 1\nBefore Instruction\nCarry bit =\n1\nREG\n=\n0x02\nW\n=\n0x4D\nAfter Instruction\nCarry bit\n=\n0\nREG\n=\n0x02\nW\n=\n0x50\nANDLW\nBefore Instruction\nW\n=\n0xA3\nAfter Instruction\nW\n=\n0x03\n0x5F",
    "PIC18F6525/6621/8525/8621\nSyntax:, AND Wwith f = [ label ] ANDWF. Syntax:, AND Wwith f = [ label ] ANDWF. Syntax:, AND Wwith f = f [,d [,a]. Syntax:, AND Wwith f = f [,d [,a]. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operands:, AND Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1]. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Operation:, AND Wwith f = (W) .AND. (f) \uf0ae dest. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f =",
    "PIC18F6525/6621/8525/8621\nN, Z. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Encoding:, AND Wwith f = 0001. Encoding:, AND Wwith f = 01da. Encoding:, AND Wwith f = ffff. Encoding:, AND Wwith f = ffff. Description:, AND Wwith f = The contents of Ware ANDed with. Description:, AND Wwith f = The contents of Ware ANDed with. Description:, AND Wwith f = The contents of Ware ANDed with. Description:, AND Wwith f = The contents of Ware ANDed with\nregister 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'd' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:",
    "PIC18F6525/6621/8525/8621\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nANDWF\nBefore Instruction\nW\n=\n0x17 0xC2\nREG\n=\nAfter Instruction\nW\n=\n0x02\nREG\n=\n0xC2\nREG, 0, 0",
    "PIC18F6525/6621/8525/8621\nBC, 1 = BC. BC, 2 = Branch if Carry. BC, 3 = Branch if Carry. BC, 4 = Branch if Carry. BC, 5 = Branch if Carry. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] BC n. Syntax:, 3 = [ label ] BC n. Syntax:, 4 = [ label ] BC n. Syntax:, 5 = [ label ] BC n. Operands:, 1 = Operands:. Operands:, 2 = -128 \uf0a3 n \uf0a3 127. Operands:, 3 = -128 \uf0a3 n \uf0a3 127. Operands:, 4 = -128 \uf0a3 n \uf0a3 127. Operands:, 5 = -128 \uf0a3 n \uf0a3 127. Operation:, 1 = Operation:. Operation:, 2 = if Carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 3 = if Carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 4 = if Carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 5 = if Carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Status",
    "PIC18F6525/6621/8525/8621\nAffected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 1110. Encoding:, 3 = 1110. Encoding:, 4 = 0010. Encoding:, 5 = nnnn. Description:, 1 = Description:. Description:, 2 = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 3 = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 4 = If",
    "PIC18F6525/6621/8525/8621\nthe Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 5 = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1(2). Cycles:, 3 = 1(2). Cycles:, 4 = 1(2). Cycles:, 5 = 1(2). Q Cycle Activity: If, 1 = Q Cycle Activity: If. Q Cycle Activity:",
    "PIC18F6525/6621/8525/8621\nIf, 2 = . Q Cycle Activity: If, 3 = . Q Cycle Activity: If, 4 = . Q Cycle Activity: If, 5 = . Jump:, 1 = Jump:. Jump:, 2 = . Jump:, 3 = . Jump:, 4 = . Jump:, 5 = . , 1 = Q1. , 2 = Q2. , 3 = Q2. , 4 = Q3. , 5 = . , 1 = Decode. , 2 = Read literal 'n'. , 3 = Read literal 'n'. , 4 = Process Data. , 5 = Process Data. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation. , 5 = No operation. If No Jump:, 1 = If No Jump:. If No Jump:, 2 = . If No Jump:, 3 = . If No Jump:, 4 = . If No Jump:, 5 = . , 1 = Q1. , 2 = Q2. , 3 = Q2. , 4 = Q3. , 5 = Q3. , 1 = Decode. , 2 = Read",
    "PIC18F6525/6621/8525/8621\nliteral 'n'. , 3 = Read literal 'n'. , 4 = Process Data. , 5 = Process Data. Example:, 1 = Example:. Example:, 2 = HERE. Example:, 3 = HERE. Example:, 4 = BC. Example:, 5 = 5. , 1 = Before Instruction PC. , 2 = Before Instruction PC. , 3 = =. , 4 = address. , 5 = (HERE). , 1 = If Carry = PC =. , 2 = If Carry = PC =. , 3 = . , 4 = 1; address. , 5 = (HERE. , 1 = If Carry = PC =. , 2 = If Carry = PC =. , 3 = . , 4 = 0; address (HERE. , 5 = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Bit Clear f = [ label ] BCF. Syntax:, Bit Clear f = [ label ] BCF. Syntax:, Bit Clear f = f,b[,a]. Syntax:, Bit Clear f = f,b[,a]. Syntax:, Bit Clear f = f,b[,a]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = . Operands:, Bit Clear f = . Operands:, Bit Clear f = . Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = . Operation:, Bit Clear f = . Operation:, Bit Clear f = . Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = . Status Affected:, Bit Clear f = . Status Affected:, Bit Clear f = . Encoding:, Bit Clear",
    "PIC18F6525/6621/8525/8621\nf = 1001. Encoding:, Bit Clear f = bbba. Encoding:, Bit Clear f = bbba. Encoding:, Bit Clear f = ffff. Encoding:, Bit Clear f = ffff. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value",
    "PIC18F6525/6621/8525/8621\n(default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Words:, Bit Clear f = . Words:, Bit Clear f = . Words:, Bit Clear f = . Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = . Cycles:, Bit Clear f = . Cycles:, Bit Clear f = . Q Cycle Activity: Q1, Bit Clear f = Q2. Q Cycle Activity: Q1,",
    "PIC18F6525/6621/8525/8621\nBit Clear f = . Q Cycle Activity: Q1, Bit Clear f = Q3. Q Cycle Activity: Q1, Bit Clear f = Q3. Q Cycle Activity: Q1, Bit Clear f = Q4. Decode, Bit Clear f = Read register 'f'. Decode, Bit Clear f = Read register 'f'. Decode, Bit Clear f = Process Data. Decode, Bit Clear f = Process Data. Decode, Bit Clear f = Write register 'f'. Example:, Bit Clear f = BCF. Example:, Bit Clear f = FLAG_REG,. Example:, Bit Clear f = FLAG_REG,. Example:, Bit Clear f = 7, 0. Example:, Bit Clear f = 7, 0. Before Instruction FLAG_REG =, Bit Clear f = Before Instruction FLAG_REG =. Before Instruction FLAG_REG =, Bit Clear f = 0xC7. Before Instruction FLAG_REG =, Bit Clear f = 0xC7. Before Instruction FLAG_REG =, Bit Clear f = . Before Instruction FLAG_REG =, Bit Clear f = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, BN = Syntax:. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Operands:, BN = Operands:. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operation:, BN = Operation:. Operation:, Branch if Negative = if Negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if Negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if Negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if Negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, BN = Status Affected:. Status Affected:, Branch if",
    "PIC18F6525/6621/8525/8621\nNegative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Encoding:, BN = Encoding:. Encoding:, Branch if Negative = 1110. Encoding:, Branch if Negative = 1110. Encoding:, Branch if Negative = 0110. Encoding:, Branch if Negative = nnnn. Description:, BN = Description:. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction..",
    "PIC18F6525/6621/8525/8621\nDescription:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, BN = Words:. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Cycles:, BN = Cycles:. Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch",
    "PIC18F6525/6621/8525/8621\nif Negative = 1(2). Q Cycle Activity: If, BN = Q Cycle Activity: If. Q Cycle Activity: If, Branch if Negative = . Q Cycle Activity: If, Branch if Negative = . Q Cycle Activity: If, Branch if Negative = . Q Cycle Activity: If, Branch if Negative = . Jump:, BN = Jump:. Jump:, Branch if Negative = . Jump:, Branch if Negative = . Jump:, Branch if Negative = . Jump:, Branch if Negative = . , BN = Q1. , Branch if Negative = Q2. , Branch if Negative = Q2. , Branch if Negative = Q3. , Branch if Negative = . , BN = Decode. , Branch if Negative = Read literal 'n'. , Branch if Negative = Read literal 'n'. , Branch if Negative = Process Data. , Branch if Negative = Process Data. , BN = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. If No Jump:, BN = If No Jump:. If No Jump:, Branch",
    "PIC18F6525/6621/8525/8621\nif Negative = . If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . , BN = Q1. , Branch if Negative = Q2. , Branch if Negative = Q2. , Branch if Negative = Q3. , Branch if Negative = Q3. , BN = Decode. , Branch if Negative = Read literal 'n'. , Branch if Negative = Read literal 'n'. , Branch if Negative = Process Data. , Branch if Negative = Process Data. Example:, BN = Example:. Example:, Branch if Negative = HERE. Example:, Branch if Negative = HERE. Example:, Branch if Negative = BN. Example:, Branch if Negative = Jump. , BN = Before Instruction PC. , Branch if Negative = Before Instruction PC. , Branch if Negative = =. , Branch if Negative = address. , Branch if Negative = (HERE). , BN = If Negative = PC =. , Branch if Negative = If Negative = PC =. , Branch if Negative = . , Branch if Negative = 1; address. , Branch if Negative =",
    "PIC18F6525/6621/8525/8621\n(Jump). , BN = If Negative = PC. , Branch if Negative = If Negative = PC. , Branch if Negative = =. , Branch if Negative = 0; address. , Branch if Negative = (HERE",
    "PIC18F6525/6621/8525/8621\nSyntax:, BNC = Syntax:. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Operands:, BNC = Operands:. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operation:, BNC = Operation:. Operation:, Branch if Not Carry = if Carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, BNC = Status Affected:. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Encoding:, BNC =",
    "PIC18F6525/6621/8525/8621\nEncoding:. Encoding:, Branch if Not Carry = 1110. Encoding:, Branch if Not Carry = 0011. Encoding:, Branch if Not Carry = nnnn. Description:, BNC = Description:. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have",
    "PIC18F6525/6621/8525/8621\nincremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, BNC = Words:. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Cycles:, BNC = Cycles:. Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Q Cycle Activity: If, BNC = Q Cycle Activity: If. Q Cycle Activity: If, Branch if Not Carry = . Q Cycle Activity: If, Branch if Not Carry = . Q Cycle Activity: If, Branch if Not Carry = . Jump:, BNC = Jump:. Jump:, Branch if Not Carry = . Jump:, Branch if Not Carry = . Jump:, Branch if Not Carry = . , BNC = Q1. , Branch if Not Carry = Q2. , Branch if Not Carry = Q3. , Branch if Not Carry = . , BNC =",
    "PIC18F6525/6621/8525/8621\nDecode. , Branch if Not Carry = Read literal 'n'. , Branch if Not Carry = Process Data. , Branch if Not Carry = Process Data. , BNC = No operation. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. If No Jump:, BNC = If No Jump:. If No Jump:, Branch if Not Carry = . If No Jump:, Branch if Not Carry = . If No Jump:, Branch if Not Carry = . , BNC = Q1. , Branch if Not Carry = Q2. , Branch if Not Carry = Q3. , Branch if Not Carry = Q3. , BNC = Decode. , Branch if Not Carry = Read literal 'n'. , Branch if Not Carry = Process Data. , Branch if Not Carry = Process Data. Example:, BNC = Example:. Example:, Branch if Not Carry = HERE. Example:, Branch if Not Carry = BNC. Example:, Branch if Not Carry = Jump. , BNC = Before Instruction PC. , Branch if Not Carry = =. , Branch",
    "PIC18F6525/6621/8525/8621\nif Not Carry = address. , Branch if Not Carry = (HERE). , BNC = If Carry PC. , Branch if Not Carry = = 0; =. , Branch if Not Carry = address (Jump). , Branch if Not Carry = . , BNC = If Carry PC. , Branch if Not Carry = = 1; =. , Branch if Not Carry = address (HERE. , Branch if Not Carry = + 2)",
    "PIC18F6525/6621/8525/8621\nSyntax:, BNN = Syntax:. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Operands:, BNN = Operands:. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operation:, BNN = Operation:. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 +",
    "PIC18F6525/6621/8525/8621\n2n \uf0ae PC. Status Affected:, BNN = Status Affected:. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Encoding:, BNN = Encoding:. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 0111. Encoding:, Branch if Not Negative = nnnn nnnn. Description:, BNN = Description:. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the",
    "PIC18F6525/6621/8525/8621\nPC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, BNN = Words:. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Cycles:, BNN =",
    "PIC18F6525/6621/8525/8621\nCycles:. Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Q Cycle Activity: If, BNN = Q Cycle Activity: If. Q Cycle Activity: If, Branch if Not Negative = . Q Cycle Activity: If, Branch if Not Negative = . Q Cycle Activity: If, Branch if Not Negative = . Q Cycle Activity: If, Branch if Not Negative = . Jump:, BNN = Jump:. Jump:, Branch if Not Negative = . Jump:, Branch if Not Negative = . Jump:, Branch if Not Negative = . Jump:, Branch if Not Negative = . , BNN = Q1. , Branch if Not Negative = Q2. , Branch if Not Negative = Q2. , Branch if Not Negative = Q3. , Branch if Not Negative = Q4. , BNN = Decode. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative",
    "PIC18F6525/6621/8525/8621\n= Process Data. , Branch if Not Negative = Write to PC. , BNN = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. If No Jump:, BNN = If No Jump:. If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . , BNN = Q1. , Branch if Not Negative = Q2. , Branch if Not Negative = Q2. , Branch if Not Negative = Q3. , Branch if Not Negative = Q4. , BNN = Decode. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Process Data. , Branch if Not Negative = No operation. Example:, BNN = Example:. Example:, Branch if Not Negative = HERE. Example:, Branch if Not Negative = HERE. Example:, Branch if Not Negative",
    "PIC18F6525/6621/8525/8621\n= BNN. Example:, Branch if Not Negative = Jump. , BNN = Before Instruction PC. , Branch if Not Negative = Before Instruction PC. , Branch if Not Negative = =. , Branch if Not Negative = address. , Branch if Not Negative = (HERE). , BNN = . , Branch if Not Negative = . , Branch if Not Negative = Instruction. , Branch if Not Negative = Instruction. , Branch if Not Negative = . , BNN = If Negative = PC. , Branch if Not Negative = If Negative = PC. , Branch if Not Negative = =. , Branch if Not Negative = 0; address. , Branch if Not Negative = (Jump). , BNN = If Negative = PC =. , Branch if Not Negative = If Negative = PC =. , Branch if Not Negative = . , Branch if Not Negative = 1; address (HERE. , Branch if Not Negative = + 2)",
    "PIC18F6525/6621/8525/8621\nSyntax:, BNOV = Syntax:. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Operands:, BNOV = Operands:. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operation:, BNOV = Operation:. Operation:, Branch if Not Overflow = if Overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if Overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if Overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow",
    "PIC18F6525/6621/8525/8621\n= if Overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, BNOV = Status Affected:. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Encoding:, BNOV = Encoding:. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 0101. Encoding:, Branch if Not Overflow = nnnn. Description:, BNOV = Description:. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ',",
    "PIC18F6525/6621/8525/8621\nthen the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, BNOV = Words:. Words:, Branch if Not Overflow = 1. Words:, Branch if Not",
    "PIC18F6525/6621/8525/8621\nOverflow = 1. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Cycles:, BNOV = Cycles:. Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Q Cycle Activity:, BNOV = Q Cycle Activity:. Q Cycle Activity:, Branch if Not Overflow = . Q Cycle Activity:, Branch if Not Overflow = . Q Cycle Activity:, Branch if Not Overflow = . Q Cycle Activity:, Branch if Not Overflow = . , BNOV = . , Branch if Not Overflow = If Jump:. , Branch if Not Overflow = If Jump:. , Branch if Not Overflow = If Jump:. , Branch if Not Overflow = If Jump:. , BNOV = Q1. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q3. , Branch if",
    "PIC18F6525/6621/8525/8621\nNot Overflow = . , BNOV = Decode. , Branch if Not Overflow = Read literal 'n'. , Branch if Not Overflow = Read literal 'n'. , Branch if Not Overflow = Process Data. , Branch if Not Overflow = Process Data. , BNOV = No operation. , Branch if Not Overflow = No operation. , Branch if Not Overflow = No operation. , Branch if Not Overflow = No operation. , Branch if Not Overflow = No operation. If No Jump:, BNOV = If No Jump:. If No Jump:, Branch if Not Overflow = . If No Jump:, Branch if Not Overflow = . If No Jump:, Branch if Not Overflow = . If No Jump:, Branch if Not Overflow = . , BNOV = Q1. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q3. , Branch if Not Overflow = Q3. , BNOV = Decode. , Branch if Not Overflow = Read literal 'n'. , Branch if Not Overflow = Read literal",
    "PIC18F6525/6621/8525/8621\n'n'. , Branch if Not Overflow = Process Data. , Branch if Not Overflow = Process Data. Example:, BNOV = Example:. Example:, Branch if Not Overflow = HERE. Example:, Branch if Not Overflow = HERE. Example:, Branch if Not Overflow = BNOV. Example:, Branch if Not Overflow = Jump. , BNOV = Before Instruction PC. , Branch if Not Overflow = Before Instruction PC. , Branch if Not Overflow = =. , Branch if Not Overflow = address. , Branch if Not Overflow = (HERE). , BNOV = After Instruction If Overflow PC. , Branch if Not Overflow = After Instruction If Overflow PC. , Branch if Not Overflow = = =. , Branch if Not Overflow = 0; address. , Branch if Not Overflow = (Jump). , BNOV = If Overflow = PC =. , Branch if Not Overflow = If Overflow = PC =. , Branch if Not Overflow = . , Branch if Not Overflow = 1; address. , Branch if Not Overflow = (HERE",
    "PIC18F6525/6621/8525/8621\nSyntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Zero = if Zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if Zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if Zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if Zero bit is ' 0 ' (PC) + 2 +",
    "PIC18F6525/6621/8525/8621\n2n \uf0ae PC. Operation:, Branch if Not Zero = if Zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Encoding:, Branch if Not Zero = 1110. Encoding:, Branch if Not Zero = 0001. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The",
    "PIC18F6525/6621/8525/8621\n2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the",
    "PIC18F6525/6621/8525/8621\nPC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity:",
    "PIC18F6525/6621/8525/8621\nIf Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q1, Branch if Not Zero = Q2. Q1, Branch if Not Zero = Q2. Q1, Branch if Not Zero = Q3. Q1, Branch if Not Zero = . Q1, Branch if Not Zero = Q4. , Branch if Not Zero = Decode. , Branch if Not Zero = Read literal 'n' Process Data. , Branch if Not Zero = Read literal 'n' Process Data. , Branch if Not Zero = Read literal 'n' Process Data. , Branch if Not Zero = Write to PC. , Branch if Not Zero = No operation. , Branch if Not Zero = No operation No operation. , Branch if Not Zero = No operation No operation. , Branch if Not Zero = No operation No operation. , Branch if Not Zero = No operation. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:.",
    "PIC18F6525/6621/8525/8621\nIf No Jump:, Branch if Not Zero = If No Jump:. , Branch if Not Zero = Q1. , Branch if Not Zero = Q2 Q3. , Branch if Not Zero = Q2 Q3. , Branch if Not Zero = Q2 Q3. , Branch if Not Zero = Q4. , Branch if Not Zero = Decode. , Branch if Not Zero = Read literal 'n' Process Data. , Branch if Not Zero = Read literal 'n' Process Data. , Branch if Not Zero = Read literal 'n' Process Data. , Branch if Not Zero = No operation. Example:, Branch if Not Zero = Example:. Example:, Branch if Not Zero = HERE. Example:, Branch if Not Zero = BNZ. Example:, Branch if Not Zero = Jump. Example:, Branch if Not Zero = . Before Instruction PC, Branch if Not Zero = Before Instruction PC. Before Instruction PC, Branch if Not Zero = = address. Before Instruction PC, Branch if Not Zero = . Before Instruction PC, Branch if Not Zero = (HERE). Before Instruction PC, Branch if Not Zero = . After Instruction, Branch if Not Zero",
    "PIC18F6525/6621/8525/8621\n= After Instruction. After Instruction, Branch if Not Zero = After Instruction. After Instruction, Branch if Not Zero = After Instruction. After Instruction, Branch if Not Zero = After Instruction. After Instruction, Branch if Not Zero = After Instruction. , Branch if Not Zero = If Zero = PC. , Branch if Not Zero = 0; address (Jump). , Branch if Not Zero = 0; address (Jump). , Branch if Not Zero = 0; address (Jump). , Branch if Not Zero = . , Branch if Not Zero = If Zero PC. , Branch if Not Zero = = 1; = address (HERE + 2). , Branch if Not Zero = = 1; = address (HERE + 2). , Branch if Not Zero = = 1; = address (HERE + 2). , Branch if Not Zero = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Unconditional Branch = [ label ] BRA n. Syntax:, Unconditional Branch = [ label ] BRA n. Syntax:, Unconditional Branch = [ label ] BRA n. Syntax:, Unconditional Branch = [ label ] BRA n. Operands:, Unconditional Branch = -1024 \uf0a3 n \uf0a3 1023. Operands:, Unconditional Branch = -1024 \uf0a3 n \uf0a3 1023. Operands:, Unconditional Branch = -1024 \uf0a3 n \uf0a3 1023. Operands:, Unconditional Branch = -1024 \uf0a3 n \uf0a3 1023. Operation:, Unconditional Branch = (PC) + 2 + 2n \uf0ae PC. Operation:, Unconditional Branch = (PC) + 2 + 2n \uf0ae PC. Operation:, Unconditional Branch = (PC) + 2 + 2n \uf0ae PC. Operation:, Unconditional Branch = (PC) + 2 + 2n \uf0ae PC. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Encoding:, Unconditional",
    "PIC18F6525/6621/8525/8621\nBranch = 1101. Encoding:, Unconditional Branch = 0nnn. Encoding:, Unconditional Branch = nnnn. Encoding:, Unconditional Branch = nnnn. Description:, Unconditional Branch = Add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Unconditional Branch = Add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Unconditional Branch = Add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Unconditional Branch = Add the 2's complement number '2n' to the PC. Since",
    "PIC18F6525/6621/8525/8621\nthe PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Words:, Unconditional Branch = 1. Words:, Unconditional Branch = 1. Words:, Unconditional Branch = 1. Words:, Unconditional Branch = 1. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Q Cycle Activity:, Unconditional Branch = . Q Cycle Activity:, Unconditional Branch = . Q Cycle Activity:, Unconditional Branch = . Q Cycle Activity:, Unconditional Branch = . Q1, Unconditional Branch = Q2. Q1, Unconditional Branch = Q3. Q1, Unconditional Branch = . Q1, Unconditional Branch = Q4. Decode, Unconditional Branch = Read literal 'n' Process Data Write to PC No operation No operation No operation. Decode, Unconditional Branch = Read literal 'n' Process Data Write",
    "PIC18F6525/6621/8525/8621\nto PC No operation No operation No operation. Decode, Unconditional Branch = Read literal 'n' Process Data Write to PC No operation No operation No operation. Decode, Unconditional Branch = Read literal 'n' Process Data Write to PC No operation No operation No operation. Example:, Unconditional Branch = HERE. Example:, Unconditional Branch = BRA. Example:, Unconditional Branch = Jump. Example:, Unconditional Branch = . Before Instruction PC, Unconditional Branch = = address. Before Instruction PC, Unconditional Branch = (HERE). Before Instruction PC, Unconditional Branch = . Before Instruction PC, Unconditional Branch = . After Instruction PC =, Unconditional Branch = address. After Instruction PC =, Unconditional Branch = (Jump). After Instruction PC =, Unconditional Branch = . After Instruction PC =, Unconditional Branch = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Bit Set f = [ label ] BSF. Syntax:, Bit Set f = [ label ] BSF. Syntax:, Bit Set f = f,b[,a]. Syntax:, Bit Set f = f,b[,a]. Syntax:, Bit Set f = f,b[,a]. Operands:, Bit Set f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Set f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Set f = . Operands:, Bit Set f = . Operands:, Bit Set f = . Operation:, Bit Set f = 1 \uf0ae f<b>. Operation:, Bit Set f = 1 \uf0ae f<b>. Operation:, Bit Set f = . Operation:, Bit Set f = . Operation:, Bit Set f = . Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = . Status Affected:, Bit Set f = . Status Affected:, Bit Set f = . Encoding:, Bit Set",
    "PIC18F6525/6621/8525/8621\nf = 1000. Encoding:, Bit Set f = bbba. Encoding:, Bit Set f = ffff. Encoding:, Bit Set f = . Encoding:, Bit Set f = ffff. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b'",
    "PIC18F6525/6621/8525/8621\nin register 'f' is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Bit Set f = 1. Words:, Bit Set f = 1. Words:, Bit Set f = . Words:, Bit Set f = . Words:, Bit Set f = . Cycles:, Bit Set f = 1. Cycles:, Bit Set f = 1. Cycles:, Bit Set f = . Cycles:, Bit Set f = . Cycles:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle",
    "PIC18F6525/6621/8525/8621\nActivity:, Bit Set f = . Q1, Bit Set f = Q2. Q1, Bit Set f = Q2. Q1, Bit Set f = Q3. Q1, Bit Set f = Q3. Q1, Bit Set f = Q4. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Process Data. Decode, Bit Set f = Process Data. Decode, Bit Set f = Write register 'f'. Example: BSF, Bit Set f = Example: BSF. Example: BSF, Bit Set f = FLAG_REG,. Example: BSF, Bit Set f = FLAG_REG,. Example: BSF, Bit Set f = 7, 1. Example: BSF, Bit Set f = 7, 1. Before Instruction FLAG_REG = After Instruction, Bit Set f = Before Instruction FLAG_REG = After Instruction. Before Instruction FLAG_REG = After Instruction, Bit Set f = 0x0A. Before Instruction FLAG_REG = After Instruction, Bit Set f =",
    "PIC18F6525/6621/8525/8621\n0x0A. Before Instruction FLAG_REG = After Instruction, Bit Set f = . Before Instruction FLAG_REG = After Instruction, Bit Set f = ",
    "Bit Test File, Skip if Clear\nSyntax:\n[ label ]  BTFSC   f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b \uf0a3 7\na \uf0ce\uf020 [0,1]\nOperation:\nskip if (f<b>) = 0\nStatus Affected:\nNone\nEncoding:\n1011\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped.\nIf bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Bit Test File, Skip if Set\nSyntax:\n[ label ]  BTFSS  f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b < 7\na \uf0ce\uf020 [0,1]\nOperation:\nskip if (f<b>) = 1\nStatus Affected:\nNone\nEncoding:\n1010\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped.\nIf bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution, is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation\nIf skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE\nFALSE\nTRUE\nBTFSC\n:\n:\nFLAG, 1, 0\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf FLAG<1>\n=\n0;\nPC\n=\naddress (TRUE)\nIf FLAG<1>\n=\n1;\nPC\n=\naddress (FALSE)\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation\nIf skip:\nQ1\nNo\nQ2\nNo\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation\nQ4",
    "Q Cycle Activity:\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE\nBTFSS\nFLAG, 1, 0\nFALSE\nTRUE\n:\n:\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf FLAG<1>\n=\n0;\nPC\n=\naddress (FALSE)\nIf FLAG<1>\n=\n1;\nPC\n=\naddress\n(TRUE)",
    "PIC18F6525/6621/8525/8621\nSyntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f =",
    "PIC18F6525/6621/8525/8621\n(f<b>) \uf0ae f<b>. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Encoding:, Bit Toggle f = 0111. Encoding:, Bit Toggle f = bbba. Encoding:, Bit Toggle f = ffff. Encoding:, Bit Toggle f = ffff. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit",
    "PIC18F6525/6621/8525/8621\nToggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Q Cycle Activity: Q1, Bit Toggle f = Q2. Q Cycle Activity: Q1, Bit Toggle f =",
    "PIC18F6525/6621/8525/8621\nQ3. Q Cycle Activity: Q1, Bit Toggle f = Q4. Q Cycle Activity: Q1, Bit Toggle f = Q4. Decode, Bit Toggle f = Read register 'f'. Decode, Bit Toggle f = Process Data. Decode, Bit Toggle f = Write register 'f'. Decode, Bit Toggle f = Write register 'f'. Example:, Bit Toggle f = BTG. Example:, Bit Toggle f = PORTC, 4,. Example:, Bit Toggle f = 0. Example:, Bit Toggle f = . Before Instruction: PORTC =, Bit Toggle f = 0111. Before Instruction: PORTC =, Bit Toggle f = 0101 [0x75]. Before Instruction: PORTC =, Bit Toggle f = . Before Instruction: PORTC =, Bit Toggle f = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, BOV = Syntax:. Syntax:, Branch if Overflow = [ label ] BOV n. Syntax:, Branch if Overflow = [ label ] BOV n. Syntax:, Branch if Overflow = [ label ] BOV n. Syntax:, Branch if Overflow = [ label ] BOV n. Operands:, BOV = Operands:. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operation:, BOV = Operation:. Operation:, Branch if Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow = if Overflow bit is ' 1 ' (PC)",
    "PIC18F6525/6621/8525/8621\n+ 2 + 2n \uf0ae PC. Status Affected:, BOV = Status Affected:. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Encoding:, BOV = Encoding:. Encoding:, Branch if Overflow = 1110. Encoding:, Branch if Overflow = 1110. Encoding:, Branch if Overflow = 0100. Encoding:, Branch if Overflow = nnnn nnnn. Description:, BOV = Description:. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to",
    "PIC18F6525/6621/8525/8621\nthe PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, BOV = Words:. Words:, Branch if Overflow = 1. Words:, Branch if Overflow = 1. Words:, Branch if Overflow = 1. Words:, Branch if Overflow =",
    "PIC18F6525/6621/8525/8621\n1. Cycles:, BOV = Cycles:. Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Q Cycle Activity: If, BOV = Q Cycle Activity: If. Q Cycle Activity: If, Branch if Overflow = . Q Cycle Activity: If, Branch if Overflow = . Q Cycle Activity: If, Branch if Overflow = . Q Cycle Activity: If, Branch if Overflow = . Jump:, BOV = Jump:. Jump:, Branch if Overflow = . Jump:, Branch if Overflow = . Jump:, Branch if Overflow = . Jump:, Branch if Overflow = . , BOV = Q1. , Branch if Overflow = Q2. , Branch if Overflow = Q2. , Branch if Overflow = Q3. , Branch if Overflow = Q4. , BOV = Decode. , Branch if Overflow = Read literal 'n'. , Branch if Overflow = Read literal",
    "PIC18F6525/6621/8525/8621\n'n'. , Branch if Overflow = Process Data. , Branch if Overflow = Write to PC. , BOV = No operation. , Branch if Overflow = No operation. , Branch if Overflow = No operation. , Branch if Overflow = No operation. , Branch if Overflow = No operation. If No Jump:, BOV = If No Jump:. If No Jump:, Branch if Overflow = . If No Jump:, Branch if Overflow = . If No Jump:, Branch if Overflow = . If No Jump:, Branch if Overflow = . , BOV = Q1. , Branch if Overflow = Q2. , Branch if Overflow = Q2. , Branch if Overflow = Q3. , Branch if Overflow = Q4. , BOV = Decode. , Branch if Overflow = Read literal 'n'. , Branch if Overflow = Read literal 'n'. , Branch if Overflow = Process Data. , Branch if Overflow = No operation. Example:, BOV = Example:. Example:, Branch if Overflow = HERE. Example:, Branch if Overflow =",
    "PIC18F6525/6621/8525/8621\nHERE. Example:, Branch if Overflow = BOV. Example:, Branch if Overflow = Jump. , BOV = Before Instruction PC. , Branch if Overflow = Before Instruction PC. , Branch if Overflow = =. , Branch if Overflow = address. , Branch if Overflow = (HERE). , BOV = After Instruction If Overflow. , Branch if Overflow = After Instruction If Overflow. , Branch if Overflow = = =. , Branch if Overflow = 1; address. , Branch if Overflow = (Jump). , BOV = If Overflow = PC. , Branch if Overflow = If Overflow = PC. , Branch if Overflow = =. , Branch if Overflow = 0; address (HERE. , Branch if Overflow = + 2)",
    "Branch if Zero\nSyntax:\n[ label ]  BZ    n\nOperands:\n-128 \uf0a3 n \uf0a3 127\nOperation:\nif Zero bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1110\n0000\nnnnn\nnnnn\nDescription:\nIf the Zero bit is ' 1 ', then the program will branch.\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nQ1\nDecode\nQ2\nRead literal\nQ3\nProcess\n'n'\nData",
    "Example:\nPC, HERE.Before Instruction = =. PC,  = address. PC, BZ Jump. = (HERE). After Instruction, HERE.Before Instruction = After Instruction. After Instruction,  = . After Instruction, BZ Jump. = . If Zero PC, HERE.Before Instruction = = =. If Zero PC,  = 1; address. If Zero PC, BZ Jump. = (Jump). If Zero PC, HERE.Before Instruction = = =. If Zero PC,  = 0; address. If Zero PC, BZ Jump. = (HERE + 2)\nQ4\nNo operation",
    "Example:\nCALL, 1 = CALL. CALL, 2 = Subroutine Call. CALL, 3 = Subroutine Call. CALL, 4 = Subroutine Call. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] CALL k [,s]. Syntax:, 3 = [ label ] CALL k [,s]. Syntax:, 4 = [ label ] CALL k [,s]. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, 3 = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, 4 = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operation:, 1 = Operation:. Operation:, 2 = (PC) + 4 \uf0ae TOS; k \uf0ae PC<20:1> if s = 1 (W) \uf0ae WS; (STATUS) \uf0ae STATUSS; \uf0ae. Operation:, 3 = (PC) + 4 \uf0ae TOS; k \uf0ae PC<20:1> if s = 1 (W) \uf0ae WS; (STATUS) \uf0ae STATUSS; \uf0ae. Operation:, 4 = (PC) + 4 \uf0ae TOS; k \uf0ae PC<20:1> if s",
    "Example:\n= 1 (W) \uf0ae WS; (STATUS) \uf0ae STATUSS; \uf0ae. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding: 1st word (k<7:0>), 1 = Encoding: 1st word (k<7:0>). Encoding: 1st word (k<7:0>), 2 = 1110. Encoding: 1st word (k<7:0>), 3 = 110s k 19 kkk. Encoding: 1st word (k<7:0>), 4 = k 7 kkk kkkk. Description:, 1 = Description:. Description:, 2 = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, STATUS and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. is a two-cycle",
    "Example:\ninstruction.. Description:, 3 = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, STATUS and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. is a two-cycle instruction.. Description:, 4 = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, STATUS and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. is a two-cycle instruction.. Words:, 1 = Words:. Words:, 2 = 2. Words:, 3 = 2. Words:, 4 = 2. Cycles:, 1",
    "Example:\n= Cycles:. Cycles:, 2 = 2. Cycles:, 3 = 2. Cycles:, 4 = 2. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = Q3. , 1 = Decode. , 2 = Read literal 'k'<7:0>,. , 3 = Push PC to stack. , 4 = Push PC to stack. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation\nHERE\nCALL   THERE,1\nBefore Instruction\nPC\n=\naddress\n(HERE)\nAfter Instruction\nPC\n=\naddress\n(THERE)\nTOS\n=\naddress\n(HERE + 4)\nWS\n=\nW\nBSRS\n=\nBSR\nSTATUSS=\nSTATUS",
    "PIC18F6525/6621/8525/8621\nSyntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operation:, Clear f = 000h \uf0ae f; 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f; 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f; 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f; 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f; 1 \uf0ae Z. Status Affected:, Clear f =",
    "PIC18F6525/6621/8525/8621\nZ. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Encoding:, Clear f = 0110. Encoding:, Clear f = 101a. Encoding:, Clear f = 101a. Encoding:, Clear f = ffff. Encoding:, Clear f = ffff. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value.",
    "PIC18F6525/6621/8525/8621\nIf 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f",
    "PIC18F6525/6621/8525/8621\n= . Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q1, Clear f = Q2. Q1, Clear f = . Q1, Clear f = Q3. Q1, Clear f = . Q1, Clear f = Q4. Decode, Clear f = Read register 'f'. Decode, Clear f = Read register 'f'. Decode, Clear f = Process Data. Decode, Clear f = Process Data. Decode, Clear f = Write register 'f'. Example:, Clear f = . Example:, Clear f = . Example:, Clear f = FLAG_REG,1. Example:, Clear f = . Example:, Clear f = . , Clear f = CLRF. , Clear f = . , Clear f = . , Clear f = . , Clear f = . Before Instruction, Clear f = Before Instruction. Before Instruction, Clear f = 0x5A. Before Instruction, Clear f = 0x5A. Before Instruction, Clear f = 0x5A. Before Instruction, Clear f =",
    "PIC18F6525/6621/8525/8621\n0x5A. FLAG_REG = After Instruction FLAG_REG =, Clear f = FLAG_REG = After Instruction FLAG_REG =. FLAG_REG = After Instruction FLAG_REG =, Clear f = . FLAG_REG = After Instruction FLAG_REG =, Clear f = . FLAG_REG = After Instruction FLAG_REG =, Clear f = . FLAG_REG = After Instruction FLAG_REG =, Clear f = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT; 000h \uf0ae WDT postscaler; 1 \uf0ae TO;. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT; 000h \uf0ae WDT postscaler; 1 \uf0ae TO;. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT; 000h \uf0ae WDT postscaler; 1 \uf0ae TO;. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT; 000h \uf0ae WDT postscaler; 1 \uf0ae TO;. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer",
    "PIC18F6525/6621/8525/8621\n= TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = . Encoding:, Clear Watchdog Timer = 0000. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Words:, Clear Watchdog",
    "PIC18F6525/6621/8525/8621\nTimer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = Q3. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = Process Data. Example: CLRWDT, Clear Watchdog Timer = Example: CLRWDT.",
    "PIC18F6525/6621/8525/8621\nExample: CLRWDT, Clear Watchdog Timer = Example: CLRWDT. Example: CLRWDT, Clear Watchdog Timer = Example: CLRWDT. Example: CLRWDT, Clear Watchdog Timer = Example: CLRWDT. Before Instruction WDT Counter, Clear Watchdog Timer = Before Instruction WDT Counter. Before Instruction WDT Counter, Clear Watchdog Timer = = ?. Before Instruction WDT Counter, Clear Watchdog Timer = . Before Instruction WDT Counter, Clear Watchdog Timer = . After Instruction WDT Counter, Clear Watchdog Timer = After Instruction WDT Counter. After Instruction WDT Counter, Clear Watchdog Timer = =. After Instruction WDT Counter, Clear Watchdog Timer = 0x00. After Instruction WDT Counter, Clear Watchdog Timer = 0x00. WDT Postscaler TO, Clear Watchdog Timer = WDT Postscaler TO. WDT Postscaler TO, Clear Watchdog Timer = = =. WDT Postscaler TO, Clear Watchdog Timer = 0 1. WDT Postscaler TO, Clear Watchdog Timer = 0 1. PD, Clear Watchdog Timer",
    "PIC18F6525/6621/8525/8621\n= PD. PD, Clear Watchdog Timer = =. PD, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = 1",
    "PIC18F6525/6621/8525/8621\nSyntax:, Complement f = [ label ] COMF. Syntax:, Complement f = [ label ] COMF. Syntax:, Complement f = f [,d [,a]. Syntax:, Complement f = f [,d [,a]. Operands:, Complement f = 0 \uf0a3 f \uf0a3 255. Operands:, Complement f = 0 \uf0a3 f \uf0a3 255. Operands:, Complement f = . Operands:, Complement f = . , Complement f = d \uf0ce [0,1]. , Complement f = d \uf0ce [0,1]. , Complement f = . , Complement f = . , Complement f = a \uf0ce [0,1]. , Complement f = a \uf0ce [0,1]. , Complement f = . , Complement f = . Operation:, Complement f = \uf0ae dest ( f ). Operation:, Complement f = \uf0ae dest ( f ). Operation:, Complement f = . Operation:, Complement f = . Status Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z. Status Affected:, Complement f = . Status Affected:, Complement f = . Encoding:, Complement f = 0001.",
    "PIC18F6525/6621/8525/8621\nEncoding:, Complement f = 11da. Encoding:, Complement f = ffff. Encoding:, Complement f = ffff. Description:, Complement f = The contents of register 'f' are. Description:, Complement f = The contents of register 'f' are. Description:, Complement f = The contents of register 'f' are. Description:, Complement f = The contents of register 'f' are\ncomplemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "PIC18F6525/6621/8525/8621\nSyntax:, Compare f with W, Skip if f = W = [ label ] CPFSEQ. Syntax:, Compare f with W, Skip if f = W = [ label ] CPFSEQ. Syntax:, Compare f with W, Skip if f = W = f [,a]. Syntax:, Compare f with W, Skip if f = W = . Operands:, Compare f with W, Skip if f = W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f = W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f = W = . Operands:, Compare f with W, Skip if f = W = . Operation:, Compare f with W, Skip if f = W = (f) - (W); skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, Skip if f = W = (f) - (W); skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, Skip",
    "PIC18F6525/6621/8525/8621\nif f = W = . Operation:, Compare f with W, Skip if f = W = . Status Affected:, Compare f with W, Skip if f = W = None. Status Affected:, Compare f with W, Skip if f = W = . Status Affected:, Compare f with W, Skip if f = W = . Status Affected:, Compare f with W, Skip if f = W = . Encoding:, Compare f with W, Skip if f = W = 0110. Encoding:, Compare f with W, Skip if f = W = 001a. Encoding:, Compare f with W, Skip if f = W = ffff. Encoding:, Compare f with W, Skip if f = W = ffff. Description:, Compare f with W, Skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR",
    "PIC18F6525/6621/8525/8621\nvalue. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Compare f with W, Skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Compare f with W, Skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be",
    "PIC18F6525/6621/8525/8621\nselected as per the BSR value (default).. Description:, Compare f with W, Skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Compare f with W, Skip if f = W = 1. Words:, Compare f with W, Skip if f = W = 1. Words:, Compare f with W, Skip if f = W = 1. Words:, Compare f with W, Skip if f = W = 1. Cycles:, Compare f with W, Skip if f = W = 1(2). Cycles:, Compare f with W, Skip if f = W = 1(2). Cycles:, Compare f with W, Skip if f = W =",
    "PIC18F6525/6621/8525/8621\n1(2). Cycles:, Compare f with W, Skip if f = W = 1(2)",
    "Example:\nCOMF\nREG, 0, 0\nBefore Instruction\nREG\n=\nAfter Instruction\nREG\nW\n=\n=\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. skip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation.",
    "Q Cycle Activity:\nNo operation, Q4 = No operation\nExample:\nHERE     CPFSEQ REG, 0\nNEQUAL   :\nEQUAL    :\nBefore Instruction\nPC Address\n=\nHERE\nW\n=\n?\nREG\n=\n?\nAfter Instruction\nIf REG\n=\nW;\nPC\n=\nAddress (EQUAL)\nIf REG\n\uf0b9\nW;\nPC\n= Address\n(NEQUAL)\n0x13\n0x13\n0xEC",
    "Compare f with W, Skip if f > W\nSyntax:\n[ label ]   CPFSGT    f [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce [0,1]\nOperation:\n(f) \uf02d\uf020\uf028 W);\nskip if (f) > (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n010a\nffff\nffff\nDescription:\nCompares the contents of data memory location 'f' to the contents of the W by performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG  then the fetched , instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. skip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation.",
    "Q Cycle Activity:\nNo operation, Q4 = No operation\nExample:\nHERE      CPFSGT REG, 0\nNGREATER  :\nGREATER   :\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nW\n=\n?\nAfter Instruction\nIf REG\n\uf03e\nW;\nPC\n=\nAddress\n(GREATER)\nIf REG \uf0a3\nW;\nPC =\nAddress\n(NGREATER)",
    "Q Cycle Activity:\nSyntax:, Compare f with W, Skip if f < W = [ label ] CPFSLT. Syntax:, Compare f with W, Skip if f < W = [ label ] CPFSLT. Syntax:, Compare f with W, Skip if f < W = f [,a]. Syntax:, Compare f with W, Skip if f < W = . Operands:, Compare f with W, Skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f < W = . Operands:, Compare f with W, Skip if f < W = . Operation:, Compare f with W, Skip if f < W = (f) - \uf020\uf028 W); skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, Skip if f < W = (f) - \uf020\uf028 W); skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, Skip if f < W = . Operation:, Compare f with W,",
    "Q Cycle Activity:\nSkip if f < W = . Status Affected:, Compare f with W, Skip if f < W = None. Status Affected:, Compare f with W, Skip if f < W = None. Status Affected:, Compare f with W, Skip if f < W = . Status Affected:, Compare f with W, Skip if f < W = . Encoding:, Compare f with W, Skip if f < W = 0110. Encoding:, Compare f with W, Skip if f < W = 000a. Encoding:, Compare f with W, Skip if f < W = ffff. Encoding:, Compare f with W, Skip if f < W = ffff. Description:, Compare f with W, Skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden",
    "Q Cycle Activity:\n(default).. Description:, Compare f with W, Skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).. Description:, Compare f with W, Skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).. Description:, Compare f with W, Skip if f < W = Compares the contents of data",
    "Q Cycle Activity:\nmemory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).. Words:, Compare f with W, Skip if f < W = 1. Words:, Compare f with W, Skip if f < W = . Words:, Compare f with W, Skip if f < W = . Words:, Compare f with W, Skip if f < W = . Cycles:, Compare f with W, Skip if f < W = 1(2). Cycles:, Compare f with W, Skip if f < W = . Cycles:, Compare f with W, Skip if f < W = . Cycles:, Compare f with W, Skip if f < W = . , Compare f with W, Skip if f < W = Note:. , Compare f with W, Skip if f < W = 3 cycles if skip and",
    "Q Cycle Activity:\nfollowed by a 2-word instruction.. , Compare f with W, Skip if f < W = 3 cycles if skip and followed by a 2-word instruction.. , Compare f with W, Skip if f < W = 3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. skip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation.",
    "Q Cycle Activity:\nNo operation, Q4 = No operation\nExample:\nHERE    CPFSLT REG, 1\nNLESS   :\nLESS    :\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nW\n=\n?\nAfter Instruction\nIf REG\n<\nW;\nPC\n=\nAddress\n(LESS)\nIf REG\n\uf0b3\nW;\nPC\n=\nAddress (NLESS)",
    "PIC18F6525/6621/8525/8621\nSyntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1 ] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0> If [W<7:4> > 9] or [C = 1 ] then ( W<7:4>) + 6 \uf0ae W<7:4>; else (W<7:4>) \uf0ae W<7:4>. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC =",
    "PIC18F6525/6621/8525/8621\n1 ] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0> If [W<7:4> > 9] or [C = 1 ] then ( W<7:4>) + 6 \uf0ae W<7:4>; else (W<7:4>) \uf0ae W<7:4>. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1 ] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0> If [W<7:4> > 9] or [C = 1 ] then ( W<7:4>) + 6 \uf0ae W<7:4>; else (W<7:4>) \uf0ae W<7:4>. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1 ] then (W<3:0>) + 6 \uf0ae W<3:0>; else (",
    "PIC18F6525/6621/8525/8621\nW<3:0>) \uf0ae W<3:0> If [W<7:4> > 9] or [C = 1 ] then ( W<7:4>) + 6 \uf0ae W<7:4>; else (W<7:4>) \uf0ae W<7:4>. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0111. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W resulting from the earlier addition of two variables (each in packed BCD format)",
    "PIC18F6525/6621/8525/8621\nand produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Q Cycle Activity: Q1, Decimal Adjust WRegister = Q2. Q Cycle Activity: Q1, Decimal Adjust WRegister = Q3. Q Cycle Activity: Q1, Decimal Adjust WRegister = Q3. Q Cycle Activity:",
    "PIC18F6525/6621/8525/8621\nQ1, Decimal Adjust WRegister = Q4. Decode, Decimal Adjust WRegister = Read. Decode, Decimal Adjust WRegister = Process. Decode, Decimal Adjust WRegister = Process. Decode, Decimal Adjust WRegister = Write W",
    "Example 1:\nDAW\nBefore Instruction\nW\n=\n0xA5\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n=\n0x05\nC\n=\n1\nDC\n=\n0",
    "Example 1:\nSyntax:, Decrement f = [ label ] DECF f [,d [,a]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Decrement f = (f) - 1 \uf0ae dest.",
    "Example 1:\nOperation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Encoding:, Decrement f = 0000. Encoding:, Decrement f = 01da. Encoding:, Decrement f = ffff. Encoding:, Decrement f = ffff. Encoding:, Decrement f = ffff. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If",
    "Example 1:\n'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a'",
    "Example 1:\n= 1 , then the bank will be selected as per the BSR value (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f =",
    "Example 1:\n1. Words:, Decrement f = 1. Words:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q1, Decrement f = . Q1, Decrement f = . Q1, Decrement f = . Q1, Decrement f = . Q1, Decrement f = . , Decrement f = Q2. , Decrement f = Q2. , Decrement f = Q3. , Decrement f = Q3. , Decrement f = Q4. Decode, Decrement f = Read register 'f'. Decode, Decrement f = Read register 'f'. Decode, Decrement f =",
    "Example 1:\nProcess Data. Decode, Decrement f = Process Data. Decode, Decrement f = Write to destination. Example:, Decrement f = DECF. Example:, Decrement f = CNT, 1,. Example:, Decrement f = CNT, 1,. Example:, Decrement f = 0. Example:, Decrement f = . Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. CNT, Decrement f = =. CNT, Decrement f = 0x01. CNT, Decrement f = 0x01. CNT, Decrement f = . CNT, Decrement f = . Z, Decrement f = =. Z, Decrement f = 0. Z, Decrement f = 0. Z, Decrement f = . Z, Decrement f = . After Instruction, Decrement f = After Instruction. After Instruction, Decrement f =",
    "Example 1:\nAfter Instruction. After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. CNT Z, Decrement f = = =. CNT Z, Decrement f = 0x00 1. CNT Z, Decrement f = 0x00 1. CNT Z, Decrement f = . CNT Z, Decrement f = ",
    "Example 2:\nBefore Instruction\nW\n=\n0xCE\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n=\n0x34\nC\n=\n1\nDC\n=\n0\nQ2",
    "PIC18F6525/6621/8525/8621\nSyntax:, Decrement f, Skip if 0 = [ label ] DECFSZ. Syntax:, Decrement f, Skip if 0 = [ label ] DECFSZ. Syntax:, Decrement f, Skip if 0 = f [,d [,a]]. Syntax:, Decrement f, Skip if 0 = f [,d [,a]]. Operands:, Decrement f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if 0 = . Operands:, Decrement f, Skip if 0 = . Operation:, Decrement f, Skip if 0 = (f) - 1 \uf0ae dest; skip if result = 0. Operation:, Decrement f, Skip if 0 = (f) - 1 \uf0ae dest; skip if result = 0. Operation:, Decrement f, Skip if 0 = . Operation:, Decrement f, Skip",
    "PIC18F6525/6621/8525/8621\nif 0 = . Status Affected:, Decrement f, Skip if 0 = None. Status Affected:, Decrement f, Skip if 0 = None. Status Affected:, Decrement f, Skip if 0 = . Status Affected:, Decrement f, Skip if 0 = . Encoding:, Decrement f, Skip if 0 = 0010. Encoding:, Decrement f, Skip if 0 = 11da. Encoding:, Decrement f, Skip if 0 = ffff. Encoding:, Decrement f, Skip if 0 = ffff\nDescription:",
    "PIC18F6525/6621/8525/8621\nThe contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:",
    "Q Cycle Activity:\nQ1\nDecode\n3 cycles if skip and followed by a 2-word instruction.\nQ3\nQ4\nRead register 'f'\nProcess\nData\nWrite to destination",
    "If skip:\nNo operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nHERE      DECFSZ   CNT, 1, 1\nGOTO     LOOP\nCONTINUE",
    "If skip:\nAfter Instruction, Before Instruction.= = After Instruction. After Instruction, Before Instruction.Address (HERE) = After Instruction. CNT, Before Instruction.= = =. CNT, Before Instruction.Address (HERE) = CNT - 1. If CNT, Before Instruction.= = =. If CNT, Before Instruction.Address (HERE) = 0;. PC, Before Instruction.= = =. PC, Before Instruction.Address (HERE) = Address (CONTINUE). If CNT, Before Instruction.= = \uf0b9. If CNT, Before Instruction.Address (HERE) = 0;. PC, Before Instruction.= = =. PC, Before Instruction.Address (HERE) = Address (HERE + 2)",
    "If skip:\nSyntax:, DCFSNZ = Syntax:. Syntax:, Decrement f, Skip if Not 0 = [ label ] DCFSNZ. Syntax:, Decrement f, Skip if Not 0 = [ label ] DCFSNZ. Syntax:, Decrement f, Skip if Not 0 = [ label ] DCFSNZ. Syntax:, Decrement f, Skip if Not 0 = f [,d [,a]. Operands:, DCFSNZ = Operands:. Operands:, Decrement f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if Not 0 = . Operation:, DCFSNZ = Operation:. Operation:, Decrement f, Skip if Not 0 = (f) - 1 \uf0ae dest; skip if result \uf0b9 0. Operation:, Decrement f,",
    "If skip:\nSkip if Not 0 = (f) - 1 \uf0ae dest; skip if result \uf0b9 0. Operation:, Decrement f, Skip if Not 0 = (f) - 1 \uf0ae dest; skip if result \uf0b9 0. Operation:, Decrement f, Skip if Not 0 = . Status Affected:, DCFSNZ = Status Affected:. Status Affected:, Decrement f, Skip if Not 0 = None. Status Affected:, Decrement f, Skip if Not 0 = None. Status Affected:, Decrement f, Skip if Not 0 = None. Status Affected:, Decrement f, Skip if Not 0 = . Encoding:, DCFSNZ = Encoding:. Encoding:, Decrement f, Skip if Not 0 = 0100. Encoding:, Decrement f, Skip if Not 0 = 0100. Encoding:, Decrement f, Skip if Not 0 = 11da. Encoding:, Decrement f, Skip if Not 0 = ffff. Description:, DCFSNZ = Description:. Description:, Decrement f, Skip if Not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result",
    "If skip:\nis placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR. Description:, Decrement f, Skip if Not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR. Description:, Decrement",
    "If skip:\nf, Skip if Not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR. Description:, Decrement f, Skip if Not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the",
    "If skip:\nBSR value. If 'a' = 1 , then the bank will be selected as per the BSR. Words:, DCFSNZ = Words:. Words:, Decrement f, Skip if Not 0 = 1. Words:, Decrement f, Skip if Not 0 = 1. Words:, Decrement f, Skip if Not 0 = 1. Words:, Decrement f, Skip if Not 0 = . Cycles:, DCFSNZ = Cycles:. Cycles:, Decrement f, Skip if Not 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, Skip if Not 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, Skip if Not 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, Skip if Not 0 = 1(2) Note: 3 cycles if skip and followed. Q Cycle Activity:, DCFSNZ = Q Cycle Activity:. Q Cycle Activity:, Decrement f, Skip if Not 0 = Q3. Q Cycle Activity:, Decrement f, Skip if Not 0 =",
    "If skip:\nQ3. Q Cycle Activity:, Decrement f, Skip if Not 0 = Q3. Q Cycle Activity:, Decrement f, Skip if Not 0 = Q3. , DCFSNZ = Q1. , Decrement f, Skip if Not 0 = Q2. , Decrement f, Skip if Not 0 = Q2. , Decrement f, Skip if Not 0 = . , Decrement f, Skip if Not 0 = . , DCFSNZ = Decode. , Decrement f, Skip if Not 0 = Read register 'f'. , Decrement f, Skip if Not 0 = Read register 'f'. , Decrement f, Skip if Not 0 = Process Data. , Decrement f, Skip if Not 0 = Process Data. If skip:, DCFSNZ = If skip:. If skip:, Decrement f, Skip if Not 0 = . If skip:, Decrement f, Skip if Not 0 = . If skip:, Decrement f, Skip if Not 0 = . If skip:, Decrement f, Skip if Not 0 = . , DCFSNZ = Q1. , Decrement",
    "If skip:\nf, Skip if Not 0 = Q2. , Decrement f, Skip if Not 0 = Q2. , Decrement f, Skip if Not 0 = Q3. , Decrement f, Skip if Not 0 = Q3. , DCFSNZ = No operation. , Decrement f, Skip if Not 0 = No operation. , Decrement f, Skip if Not 0 = No operation. , Decrement f, Skip if Not 0 = No operation. , Decrement f, Skip if Not 0 = No operation. If skip and followed by 2-word instruction:, DCFSNZ = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if Not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if Not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if Not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement",
    "If skip:\nf, Skip if Not 0 = If skip and followed by 2-word instruction:. , DCFSNZ = Q1. , Decrement f, Skip if Not 0 = Q2. , Decrement f, Skip if Not 0 = Q2. , Decrement f, Skip if Not 0 = Q3. , Decrement f, Skip if Not 0 = Q3. , DCFSNZ = No operation. , Decrement f, Skip if Not 0 = No operation. , Decrement f, Skip if Not 0 = No operation. , Decrement f, Skip if Not 0 = No operation. , Decrement f, Skip if Not 0 = No operation. , DCFSNZ = No operation. , Decrement f, Skip if Not 0 = No operation. , Decrement f, Skip if Not 0 = No operation. , Decrement f, Skip if Not 0 = No operation. , Decrement f, Skip if Not 0 = No operation. Example:, DCFSNZ = Example:. Example:, Decrement f, Skip if Not 0 = HERE ZERO NZERO. Example:, Decrement f, Skip if Not 0 = HERE ZERO",
    "If skip:\nNZERO. Example:, Decrement f, Skip if Not 0 = DCFSNZ : :. Example:, Decrement f, Skip if Not 0 = TEMP,. , DCFSNZ = TEMP. , Decrement f, Skip if Not 0 = =. , Decrement f, Skip if Not 0 = ?. , Decrement f, Skip if Not 0 = ?. , Decrement f, Skip if Not 0 = . After Instruction, DCFSNZ = After Instruction. After Instruction, Decrement f, Skip if Not 0 = . After Instruction, Decrement f, Skip if Not 0 = . After Instruction, Decrement f, Skip if Not 0 = . After Instruction, Decrement f, Skip if Not 0 = . , DCFSNZ = TEMP. , Decrement f, Skip if Not 0 = =. , Decrement f, Skip if Not 0 = TEMP - 1,. , Decrement f, Skip if Not 0 = TEMP - 1,. , Decrement f, Skip if Not 0 = . , DCFSNZ = If TEMP PC. , Decrement f, Skip if Not 0 =",
    "If skip:\n=. , Decrement f, Skip if Not 0 = 0;. , Decrement f, Skip if Not 0 = 0;. , Decrement f, Skip if Not 0 = . , DCFSNZ = If TEMP. , Decrement f, Skip if Not 0 = = \uf0b9. , Decrement f, Skip if Not 0 = Address (ZERO) 0;. , Decrement f, Skip if Not 0 = Address (ZERO) 0;. , Decrement f, Skip if Not 0 = . , DCFSNZ = PC. , Decrement f, Skip if Not 0 = =. , Decrement f, Skip if Not 0 = Address. , Decrement f, Skip if Not 0 = Address. , Decrement f, Skip if Not 0 = (NZERO)",
    "PIC18F6525/6621/8525/8621\nSyntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Encoding: 1st word (k<7:0>) 2nd",
    "PIC18F6525/6621/8525/8621\nword(k<19:8>), Unconditional Branch = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = 1111 k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = kkkk 0 kkkk 8. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:,",
    "PIC18F6525/6621/8525/8621\nUnconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch =",
    "PIC18F6525/6621/8525/8621\nQ Cycle Activity:. Q1, Unconditional Branch = Q2. Q1, Unconditional Branch = Q3. Q1, Unconditional Branch = Q4. Q1, Unconditional Branch = Q4. Decode, Unconditional Branch = Read literal 'k'<7:0>,. Decode, Unconditional Branch = No operation. Decode, Unconditional Branch = Read literal 'k'<19:8>, Write to PC. Decode, Unconditional Branch = Read literal 'k'<19:8>, Write to PC. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. Example:, Unconditional Branch = GOTO THERE. Example:, Unconditional Branch = GOTO THERE. Example:, Unconditional Branch = GOTO THERE. Example:, Unconditional Branch = GOTO THERE. After Instruction PC =, Unconditional Branch = . After Instruction PC =, Unconditional Branch = . After Instruction",
    "PIC18F6525/6621/8525/8621\nPC =, Unconditional Branch = . After Instruction PC =, Unconditional Branch = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Increment f = [ label ] INCF f [,d [,a]. Syntax:, Increment f = [ label ] INCF f [,d [,a]. Syntax:, Increment f = [ label ] INCF f [,d [,a]. Syntax:, Increment f = [ label ] INCF f [,d [,a]. Syntax:, Increment f = [ label ] INCF f [,d [,a]. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. , Increment f = a \uf0ce [0,1]. , Increment f = a \uf0ce [0,1]. , Increment f = a \uf0ce",
    "PIC18F6525/6621/8525/8621\n[0,1]. , Increment f = a \uf0ce [0,1]. , Increment f = a \uf0ce [0,1]. Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = (f) + 1 \uf0ae dest. Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = C, DC, N, OV, Z. Encoding:, Increment f = 0010. Encoding:, Increment f = 10da. Encoding:, Increment f =",
    "PIC18F6525/6621/8525/8621\nffff. Encoding:, Increment f = ffff. Encoding:, Increment f = ffff. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:,",
    "PIC18F6525/6621/8525/8621\nIncrement f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed",
    "PIC18F6525/6621/8525/8621\nin W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Increment f = 1. Words:, Increment f = 1. Words:, Increment f = 1. Words:, Increment f = 1. Words:, Increment f = 1. Cycles:, Increment f = 1. Cycles:, Increment f = 1. Cycles:, Increment f = 1. Cycles:, Increment f = 1. Cycles:, Increment f = 1. Q Cycle Activity:, Increment f = . Q Cycle Activity:, Increment f = . Q Cycle Activity:, Increment f = . Q Cycle Activity:, Increment f = . Q Cycle Activity:, Increment f = . Q1, Increment f = Q2. Q1,",
    "PIC18F6525/6621/8525/8621\nIncrement f = . Q1, Increment f = Q3. Q1, Increment f = Q4. Q1, Increment f = Q4. Decode, Increment f = . Decode, Increment f = Read register 'f'. Decode, Increment f = Process Data. Decode, Increment f = Write to destination. Decode, Increment f = Write to destination. Example:, Increment f = . Example:, Increment f = INCF. Example:, Increment f = CNT, 1,. Example:, Increment f = . Example:, Increment f = . Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = Before Instruction. CNT, Increment f = = =. CNT, Increment f = 0xFF. CNT, Increment f = . CNT, Increment",
    "PIC18F6525/6621/8525/8621\nf = . CNT, Increment f = . , Increment f = Z. , Increment f = 0. , Increment f = . , Increment f = . , Increment f = . , Increment f = C. , Increment f = = ?. , Increment f = . , Increment f = . , Increment f = . , Increment f = DC =. , Increment f = ?. , Increment f = . , Increment f = . , Increment f = . After Instruction, Increment f = After Instruction. After Instruction, Increment f = After Instruction. After Instruction, Increment f = After Instruction. After Instruction, Increment f = After Instruction. After Instruction, Increment f = After Instruction. , Increment f = CNT =. , Increment f = 0x00 1. , Increment f = . , Increment f = . , Increment f = . , Increment f = Z. , Increment f = =. , Increment",
    "PIC18F6525/6621/8525/8621\nf = . , Increment f = . , Increment f = . , Increment f = C. , Increment f = = 1. , Increment f = . , Increment f = . , Increment f = . , Increment f = DC. , Increment f = = 1. , Increment f = . , Increment f = . , Increment f = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Increment f, Skip if 0 = [ label ]. Syntax:, Increment f, Skip if 0 = INCFSZ. Syntax:, Increment f, Skip if 0 = f [,d [,a]. Syntax:, Increment f, Skip if 0 = . Operands:, Increment f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if 0 = . Operands:, Increment f, Skip if 0 = . Operation:, Increment f, Skip if 0 = (f) + 1 \uf0ae dest; skip if result = 0. Operation:, Increment f, Skip if 0 = (f) + 1 \uf0ae dest; skip if result = 0. Operation:, Increment f, Skip if 0 = . Operation:, Increment f, Skip if 0 = . Status Affected:, Increment f, Skip if 0",
    "PIC18F6525/6621/8525/8621\n= None. Status Affected:, Increment f, Skip if 0 = None. Status Affected:, Increment f, Skip if 0 = . Status Affected:, Increment f, Skip if 0 = . Encoding:, Increment f, Skip if 0 = 0011. Encoding:, Increment f, Skip if 0 = 11da. Encoding:, Increment f, Skip if 0 = ffff. Encoding:, Increment f, Skip if 0 = ffff. Description:, Increment f, Skip if 0 = The contents of register 'f' are. Description:, Increment f, Skip if 0 = The contents of register 'f' are. Description:, Increment f, Skip if 0 = The contents of register 'f' are. Description:, Increment f, Skip if 0 = The contents of register 'f' are",
    "PIC18F6525/6621/8525/8621\nThe contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:",
    "Q Cycle Activity:\nQ1\nDecode\n1(2)\nNote:\nQ2\n3 cycles if skip and followed by a 2-word instruction.\nQ3\nQ4\nRead register 'f'\nProcess\nData\nWrite to destination",
    "If skip:\nNo operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation\nNo\nNo operation\nNo\nNo operation\nNo\nQ4\nNo operation\nNo operation\noperation operation\noperation\nExample:\nHERE    INCFSZ   CNT, 1, 0\nNZERO   :\nZERO    :\nAfter Instruction, = = After Instruction. After Instruction, Address = After Instruction. After Instruction, (HERE) = After Instruction. CNT, = = =. CNT, Address = CNT + 1. CNT, (HERE) = . If CNT, = = =. If CNT, Address = 0;. If CNT, (HERE) = . PC, = = =. PC, Address = Address. PC, (HERE) = (ZERO). If CNT, = = \uf0b9. If CNT, Address = 0;. If CNT, (HERE) = . PC, = = =. PC, Address = Address. PC, (HERE) = (NZERO)",
    "If skip:\nSyntax:, Increment f, Skip if Not 0 = Syntax:. Syntax:, Increment f, Skip if Not 0 = [ label ] INFSNZ. Syntax:, Increment f, Skip if Not 0 = [ label ] INFSNZ. Syntax:, Increment f, Skip if Not 0 = f [,d [,a]. Syntax:, Increment f, Skip if Not 0 = f [,d [,a]. Operands:, Increment f, Skip if Not 0 = Operands:. Operands:, Increment f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if Not 0 = . Operands:, Increment f, Skip if Not 0 = . Operation:, Increment f, Skip if Not 0 = Operation:. Operation:, Increment f, Skip if Not 0 = (f) + 1 \uf0ae dest; skip if result \uf0b9 0. Operation:,",
    "If skip:\nIncrement f, Skip if Not 0 = (f) + 1 \uf0ae dest; skip if result \uf0b9 0. Operation:, Increment f, Skip if Not 0 = . Operation:, Increment f, Skip if Not 0 = . Status Affected:, Increment f, Skip if Not 0 = Status Affected:. Status Affected:, Increment f, Skip if Not 0 = None. Status Affected:, Increment f, Skip if Not 0 = None. Status Affected:, Increment f, Skip if Not 0 = . Status Affected:, Increment f, Skip if Not 0 = . Encoding:, Increment f, Skip if Not 0 = Encoding:. Encoding:, Increment f, Skip if Not 0 = 0100 10da. Encoding:, Increment f, Skip if Not 0 = 0100 10da. Encoding:, Increment f, Skip if Not 0 = ffff. Encoding:, Increment f, Skip if Not 0 = ffff. Description:, Increment f, Skip if Not 0 = Description:. Description:, Increment f, Skip if Not 0 = The contents of register 'f' are",
    "If skip:\nincremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR. Description:, Increment f, Skip if Not 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will",
    "If skip:\nbe selected as per the BSR. Description:, Increment f, Skip if Not 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR. Description:, Increment f, Skip if Not 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is '",
    "If skip:\n0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR. Words:, Increment f, Skip if Not 0 = Words:. Words:, Increment f, Skip if Not 0 = 1. Words:, Increment f, Skip if Not 0 = 1. Words:, Increment f, Skip if Not 0 = . Words:, Increment f, Skip if Not 0 = . Cycles:, Increment f, Skip if Not 0 = Cycles:. Cycles:, Increment f, Skip if Not 0 = 1(2). Cycles:, Increment f, Skip if Not 0 = 1(2). Cycles:, Increment f, Skip if Not 0 = . Cycles:, Increment f, Skip if Not 0 = . , Increment f, Skip if Not 0 = . , Increment f, Skip if Not 0 = Note:. , Increment f, Skip if Not 0 = 3 cycles if skip and followed by a 2-word instruction.. , Increment f, Skip if Not 0 =",
    "If skip:\n3 cycles if skip and followed by a 2-word instruction.. , Increment f, Skip if Not 0 = 3 cycles if skip and followed by a 2-word instruction.. Q Cycle Activity:, Increment f, Skip if Not 0 = Q Cycle Activity:. Q Cycle Activity:, Increment f, Skip if Not 0 = Q Cycle Activity:. Q Cycle Activity:, Increment f, Skip if Not 0 = Q Cycle Activity:. Q Cycle Activity:, Increment f, Skip if Not 0 = Q Cycle Activity:. Q Cycle Activity:, Increment f, Skip if Not 0 = Q Cycle Activity:. , Increment f, Skip if Not 0 = Q1. , Increment f, Skip if Not 0 = Q2. , Increment f, Skip if Not 0 = Q2. , Increment f, Skip if Not 0 = Q3. , Increment f, Skip if Not 0 = Q4. , Increment f, Skip if Not 0 = Decode. , Increment f, Skip if Not 0 = Read register 'f'. , Increment f, Skip if Not 0 = Read register",
    "If skip:\n'f'. , Increment f, Skip if Not 0 = Process Data. , Increment f, Skip if Not 0 = Write to destination. If skip:, Increment f, Skip if Not 0 = If skip:. If skip:, Increment f, Skip if Not 0 = If skip:. If skip:, Increment f, Skip if Not 0 = If skip:. If skip:, Increment f, Skip if Not 0 = If skip:. If skip:, Increment f, Skip if Not 0 = If skip:. , Increment f, Skip if Not 0 = Q1. , Increment f, Skip if Not 0 = Q2. , Increment f, Skip if Not 0 = Q2. , Increment f, Skip if Not 0 = Q3. , Increment f, Skip if Not 0 = Q4. , Increment f, Skip if Not 0 = No operation. , Increment f, Skip if Not 0 = No operation. , Increment f, Skip if Not 0 = No operation. , Increment f, Skip if Not 0 = No operation. , Increment",
    "If skip:\nf, Skip if Not 0 = No operation. If skip and followed by 2-word instruction:, Increment f, Skip if Not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Increment f, Skip if Not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Increment f, Skip if Not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Increment f, Skip if Not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Increment f, Skip if Not 0 = If skip and followed by 2-word instruction:. , Increment f, Skip if Not 0 = Q1. , Increment f, Skip if Not 0 = Q2. , Increment f, Skip if Not 0 = Q2. , Increment f, Skip if Not 0 = Q3. , Increment f, Skip if Not 0 = Q4. , Increment f, Skip if Not 0 = No",
    "If skip:\noperation. , Increment f, Skip if Not 0 = No operation. , Increment f, Skip if Not 0 = No operation. , Increment f, Skip if Not 0 = No operation. , Increment f, Skip if Not 0 = No operation. , Increment f, Skip if Not 0 = No. , Increment f, Skip if Not 0 = . , Increment f, Skip if Not 0 = . , Increment f, Skip if Not 0 = No. , Increment f, Skip if Not 0 = No. , Increment f, Skip if Not 0 = . , Increment f, Skip if Not 0 = No. , Increment f, Skip if Not 0 = No. , Increment f, Skip if Not 0 = operation. , Increment f, Skip if Not 0 = operation. , Increment f, Skip if Not 0 = operation. , Increment f, Skip if Not 0 = operation. , Increment f, Skip if Not 0 = operation. , Increment f, Skip if Not 0 = . , Increment f, Skip if Not 0 = . Example:,",
    "If skip:\nIncrement f, Skip if Not 0 = Example:. Example:, Increment f, Skip if Not 0 = HERE INFSNZ ZERO. Example:, Increment f, Skip if Not 0 = HERE INFSNZ ZERO. Example:, Increment f, Skip if Not 0 = REG,. Example:, Increment f, Skip if Not 0 = 1, 0. Before Instruction, Increment f, Skip if Not 0 = Before Instruction. Before Instruction, Increment f, Skip if Not 0 = Before Instruction. Before Instruction, Increment f, Skip if Not 0 = Before Instruction. Before Instruction, Increment f, Skip if Not 0 = Before Instruction. Before Instruction, Increment f, Skip if Not 0 = Before Instruction. , Increment f, Skip if Not 0 = PC. , Increment f, Skip if Not 0 = =. , Increment f, Skip if Not 0 = Address. , Increment f, Skip if Not 0 = (HERE). , Increment f, Skip if Not 0 = . After Instruction, Increment f, Skip if Not 0 = After Instruction. After Instruction, Increment",
    "If skip:\nf, Skip if Not 0 = After Instruction. After Instruction, Increment f, Skip if Not 0 = After Instruction. After Instruction, Increment f, Skip if Not 0 = After Instruction. After Instruction, Increment f, Skip if Not 0 = After Instruction. , Increment f, Skip if Not 0 = REG. , Increment f, Skip if Not 0 = =. , Increment f, Skip if Not 0 = REG + 1. , Increment f, Skip if Not 0 = . , Increment f, Skip if Not 0 = . , Increment f, Skip if Not 0 = If REG. , Increment f, Skip if Not 0 = \uf0b9. , Increment f, Skip if Not 0 = 0;. , Increment f, Skip if Not 0 = . , Increment f, Skip if Not 0 = . , Increment f, Skip if Not 0 = PC If REG. , Increment f, Skip if Not 0 = = =. , Increment f, Skip if Not 0 = Address 0;. , Increment f, Skip if Not 0 = (NZERO). , Increment f,",
    "If skip:\nSkip if Not 0 = . , Increment f, Skip if Not 0 = PC. , Increment f, Skip if Not 0 = =. , Increment f, Skip if Not 0 = Address. , Increment f, Skip if Not 0 = (ZERO). , Increment f, Skip if Not 0 = ",
    "Inclusive OR Literal with W\nSyntax:\n[ label ]    IORLW   k\nOperands:\n0 \uf0a3 k \uf0a3 255\nOperation:\n(W) .OR. k \uf0ae W\nStatus Affected:\nN, Z\nEncoding:\n0000\n1001\nkkkk\nkkkk\nDescription:\nThe contents of W are ORed with the eight-bit literal 'k'. The result is placed in W.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral 'k'\nProcess\nData\nWrite to W",
    "Example:\nIORLW\n0x35\nBefore Instruction\nW\n=\n0x9A\nAfter Instruction\nW = 0xBF",
    "Example:\nSyntax:, Inclusive OR Wwith f = [ label ] IORWF. Syntax:, Inclusive OR Wwith f = [ label ] IORWF. Syntax:, Inclusive OR Wwith f = f [,d [,a]. Syntax:, Inclusive OR Wwith f = f [,d [,a]. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Inclusive OR Wwith f = . Operands:, Inclusive OR Wwith f = . Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N,",
    "Example:\nZ. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Encoding:, Inclusive OR Wwith f = 0001. Encoding:, Inclusive OR Wwith f = 00da. Encoding:, Inclusive OR Wwith f = ffff. Encoding:, Inclusive OR Wwith f = ffff. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be",
    "Example:\nselected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Inclusive OR Wwith f = 1.",
    "Example:\nWords:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Q Cycle Activity:, Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Wwith f = Q Cycle Activity:. Q1, Inclusive OR Wwith f = Q2. Q1, Inclusive OR Wwith f = Q3. Q1, Inclusive OR Wwith f = . Q1, Inclusive OR Wwith f = Q4. Decode, Inclusive OR Wwith f = Read register 'f'. Decode, Inclusive OR Wwith f = Process Data. Decode, Inclusive OR Wwith f = Process Data. Decode, Inclusive OR Wwith f = Write to destination. Example:, Inclusive OR Wwith f = IORWF.",
    "Example:\nExample:, Inclusive OR Wwith f = RESULT, 0,. Example:, Inclusive OR Wwith f = 1. Example:, Inclusive OR Wwith f = . Before Instruction, Inclusive OR Wwith f = Before Instruction. Before Instruction, Inclusive OR Wwith f = Before Instruction. Before Instruction, Inclusive OR Wwith f = Before Instruction. Before Instruction, Inclusive OR Wwith f = Before Instruction. RESULT W, Inclusive OR Wwith f = = 0x13 = 0x91. RESULT W, Inclusive OR Wwith f = . RESULT W, Inclusive OR Wwith f = . RESULT W, Inclusive OR Wwith f = . After Instruction RESULT = W =, Inclusive OR Wwith f = 0x13 0x93. After Instruction RESULT = W =, Inclusive OR Wwith f = . After Instruction RESULT = W =, Inclusive OR Wwith f = . After Instruction RESULT = W =, Inclusive OR Wwith f = \nQ Cycle Activity:",
    "PIC18F6525/6621/8525/8621\nSyntax:, Load FSR = [ label ] LFSR. Syntax:, Load FSR = . Syntax:, Load FSR = f,k. Syntax:, Load FSR = . Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operation:, Load FSR = k \uf0ae FSRf. Operation:, Load FSR = k \uf0ae FSRf. Operation:, Load FSR = k \uf0ae FSRf. Operation:, Load FSR = k \uf0ae FSRf. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Encoding:, Load FSR = 1110 1111. Encoding:, Load FSR = 1110 0000. Encoding:, Load FSR = 00ff k 7 kkk. Encoding:, Load FSR =",
    "PIC18F6525/6621/8525/8621\nk 11 kkk kkkk. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Words:, Load FSR = 2. Words:, Load FSR = 2. Words:, Load FSR = 2. Words:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2",
    "PIC18F6525/6621/8525/8621\nDecode, Q2 = Read literal 'k' MSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' MSB to FSRfH. Decode, Q2 = Read literal 'k' LSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' to FSRfL\nExample:\nLFSR 2, 0x3AB\nAfter Instruction\nFSR2H\n=\n0x03\nFSR2L\n=\n0xAB",
    "PIC18F6525/6621/8525/8621\nSyntax:, Move f = [ label ]. Syntax:, Move f = MOVF. Syntax:, Move f = f [,d [,a]. Syntax:, Move f = . Operands:, Move f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] \uf0ce. Operands:, Move f = . Operands:, Move f = . Operands:, Move f = . Operation:, Move f = f \uf0ae dest. Operation:, Move f = . Operation:, Move f = . Operation:, Move f = . Status Affected:, Move f = N, Z. Status Affected:, Move f = . Status Affected:, Move f = . Status Affected:, Move f = . Encoding:, Move f = 0101. Encoding:, Move f = 00da. Encoding:, Move f = ffff. Encoding:, Move f = ffff\nDescription:",
    "PIC18F6525/6621/8525/8621\nThe contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write W\nExample:\nMOVF   REG, 0, 0\nBefore Instruction\nREG\n=\n0x22\nW\n=\n0xFF\nAfter Instruction\nREG\n=\n0x22\nW\n=\n0x22\nMOVFF",
    "Move f to f\nSyntax:\n[\nlabel\n]    MOVFF   f ,f\ns\nd\nOperands:\n0\n\uf0a3\nf\ns\n\uf0a3\n4095\n0\n\uf0a3\nf\nd\n\uf0a3\n4095\nOperation:\n(f s ) \uf0ae f d\nStatus Affected:\nNone\nEncoding:\n1st word (source) 2nd word (destin.)\n1100\n1111\nffff\nffff\nffff\nffff\nffff s\nffff d\nDescription:\nThe contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f ' can be anywhere s in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh.\nEither source or destination can be W\n(a useful special situation). MOVFF is particularly useful for buffer or an I/O port).\ntransferring a data memory location to a peripheral register (such as the transmit\nThe MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.\nWords:\n2\nCycles:\n2 (3)\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4",
    "Move f to f\nDecode, 1 = Read register 'f' (src). Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f' (dest)\nExample:\nMOVFF   REG1, REG2\nBefore Instruction\nREG1\n= 0x33\nREG2\n=\n0x11\nAfter Instruction\nREG1\n= 0x33\nREG2\n=\n0x33",
    "Move f to f\nSyntax:, Move Literal to Low Nibble in BSR = [ label ] MOVLB k. Syntax:, Move Literal to Low Nibble in BSR = [ label ] MOVLB k. Syntax:, Move Literal to Low Nibble in BSR = [ label ] MOVLB k. Operands:, Move Literal to Low Nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to Low Nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to Low Nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operation:, Move Literal to Low Nibble in BSR = k \uf0ae BSR. Operation:, Move Literal to Low Nibble in BSR = k \uf0ae BSR. Operation:, Move Literal to Low Nibble in BSR = k \uf0ae BSR. Status Affected:, Move Literal to Low Nibble in BSR = None. Status Affected:, Move Literal to Low Nibble in BSR = None. Status Affected:, Move Literal to Low Nibble in BSR = None. Encoding:, Move Literal to Low Nibble in BSR = 0000. Encoding:, Move Literal to Low Nibble in BSR = 0001 kkkk.",
    "Move f to f\nEncoding:, Move Literal to Low Nibble in BSR = kkkk. Description:, Move Literal to Low Nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move Literal to Low Nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move Literal to Low Nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Words:, Move Literal to Low Nibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Q Cycle Activity: Q1, Move Literal to Low Nibble in BSR = Q2. Q Cycle Activity: Q1, Move Literal to Low Nibble in BSR = Q3. Q Cycle",
    "Move f to f\nActivity: Q1, Move Literal to Low Nibble in BSR = Q4. Decode, Move Literal to Low Nibble in BSR = Read literal 'k'. Decode, Move Literal to Low Nibble in BSR = Process Data. Decode, Move Literal to Low Nibble in BSR = Write literal 'k' to BSR\nExample:\nMOVLB\n5\nBefore Instruction\nBSR register\n= 0x02\nAfter Instruction\nBSR register\n= 0x05",
    "PIC18F6525/6621/8525/8621\nSyntax:, Move Literal to W = [ label ]. Syntax:, Move Literal to W = MOVLW. Syntax:, Move Literal to W = k. Syntax:, Move Literal to W = . Operands:, Move Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to W = . Operands:, Move Literal to W = . Operation:, Move Literal to W = k \uf0ae W. Operation:, Move Literal to W = k \uf0ae W. Operation:, Move Literal to W = . Operation:, Move Literal to W = . Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = . Status Affected:, Move Literal to W = . Encoding:, Move Literal to W = 0000. Encoding:, Move Literal to W = 1110. Encoding:, Move Literal to W = kkkk. Encoding:, Move Literal to W = kkkk. Description:, Move Literal to W = The eight-bit literal 'k' is loaded into W..",
    "PIC18F6525/6621/8525/8621\nDescription:, Move Literal to W = The eight-bit literal 'k' is loaded into W.. Description:, Move Literal to W = The eight-bit literal 'k' is loaded into W.. Description:, Move Literal to W = The eight-bit literal 'k' is loaded into W.. Words:, Move Literal to W = 1. Words:, Move Literal to W = . Words:, Move Literal to W = . Words:, Move Literal to W = . Cycles:, Move Literal to W = 1. Cycles:, Move Literal to W = . Cycles:, Move Literal to W = . Cycles:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q1, Move Literal to W = Q2. Q1, Move Literal to W = Q3. Q1, Move Literal to W = . Q1, Move Literal to W = Q4. Decode, Move Literal to W = Read literal 'k'.",
    "PIC18F6525/6621/8525/8621\nDecode, Move Literal to W = Process Data. Decode, Move Literal to W = . Decode, Move Literal to W = Write to W. Example:, Move Literal to W = MOVLW. Example:, Move Literal to W = 0x5A. Example:, Move Literal to W = . Example:, Move Literal to W = . After Instruction, Move Literal to W = After Instruction. After Instruction, Move Literal to W = . After Instruction, Move Literal to W = . After Instruction, Move Literal to W = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Move Wto f = [ label ] MOVWF. Syntax:, Move Wto f = [ label ] MOVWF. Syntax:, Move Wto f = f [,a]. Syntax:, Move Wto f = f [,a]. Operands:, Move Wto f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Move Wto f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Move Wto f = . Operands:, Move Wto f = . Operation:, Move Wto f = (W) \uf0ae f. Operation:, Move Wto f = (W) \uf0ae f. Operation:, Move Wto f = . Operation:, Move Wto f = . Status Affected:, Move Wto f = None. Status Affected:, Move Wto f = None. Status Affected:, Move Wto f = . Status Affected:, Move Wto f = . Encoding:, Move Wto f = 0110. Encoding:, Move Wto f = 111a. Encoding:, Move Wto f = ffff. Encoding:, Move",
    "PIC18F6525/6621/8525/8621\nWto f = ffff. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value",
    "PIC18F6525/6621/8525/8621\n(default).. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Move Wto f = 1. Words:, Move Wto f = 1. Words:, Move Wto f = . Words:, Move Wto f = . Cycles:, Move Wto f = 1. Cycles:, Move Wto f = 1. Cycles:, Move Wto f = . Cycles:, Move Wto f = . Q Cycle Activity:, Move Wto f = Q Cycle Activity:. Q Cycle Activity:, Move Wto f = Q Cycle Activity:. Q Cycle Activity:, Move Wto f = . Q Cycle Activity:, Move Wto f = . Q1, Move Wto f = Q2. Q1, Move Wto f = Q3. Q1, Move Wto f =",
    "PIC18F6525/6621/8525/8621\n. Q1, Move Wto f = Q4. Decode, Move Wto f = Read register 'f'. Decode, Move Wto f = Process Data. Decode, Move Wto f = . Decode, Move Wto f = Write register 'f'. Example:, Move Wto f = MOVWF. Example:, Move Wto f = REG, 0. Example:, Move Wto f = . Example:, Move Wto f = . Before Instruction, Move Wto f = Before Instruction. Before Instruction, Move Wto f = . Before Instruction, Move Wto f = . Before Instruction, Move Wto f = . W REG, Move Wto f = = 0x4F = 0xFF. W REG, Move Wto f = . W REG, Move Wto f = . W REG, Move Wto f = . After Instruction, Move Wto f = After Instruction. After Instruction, Move Wto f = . After Instruction, Move Wto f = . After Instruction, Move Wto f = . W REG, Move Wto f = = 0x4F =",
    "PIC18F6525/6621/8525/8621\n0x4F. W REG, Move Wto f = . W REG, Move Wto f = . W REG, Move Wto f = ",
    "Multiply Literal with W\nSyntax:\n[ label\n]    MULLW     k\nOperands:\n0 \uf0a3 k \uf0a3 255\nOperation:\n(W) x k \uf0ae PRODH:PRODL\nStatus Affected:\nNone\nEncoding:\n0000\n1101\nkkkk\nkkkk\nDescription:\nAn unsigned multiplication is carried out between the contents of W and the 8-bit literal 'k'. The 16-bit result is placed in PRODH:PRODL register pair. PRODH contains the high byte. W is unchanged.\nNone of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral 'k'\nProcess Data\nWrite registers PRODH: PRODL",
    "Example:\nMULLW   0xC4\nBefore Instruction\nW\n=\n0xE2\nPRODH\n=\n?\nPRODL\n=\n?\nAfter Instruction\nW\n= 0xE2\nPRODH\n=\n0xAD\nPRODL\n=\n0x08",
    "Multiply W with f\nSyntax:\n[\nlabel\n]    MULWF     f [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce [0,1]\nOperation:\n(W) x (f) \uf0ae PRODH:PRODL\nStatus Affected:\nNone\nEncoding:\n0000\n001a\nffff\nffff\nDescription:\nAn unsigned multiplication is carried out between the contents of W and the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte.\nBoth W and 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess Data\nWrite registers PRODH: PRODL",
    "Multiply W with f\nBefore Instruction, MULWF = . Before Instruction, REG, = . W, MULWF = =. W, REG, = 0xC4. REG, MULWF = =. REG, REG, = 0xB5. PRODH, MULWF = =. PRODH, REG, = ?. PRODL, MULWF = =. PRODL, REG, = ?. After Instruction, MULWF = . After Instruction, REG, = . W, MULWF = =. W, REG, = 0xC4. REG, MULWF = =. REG, REG, = 0xB5. PRODH, MULWF = =. PRODH, REG, = 0x8A. PRODL, MULWF = =. PRODL, REG, = 0x94",
    "PIC18F6525/6621/8525/8621\nSyntax:, Negate f = [ label ]. Syntax:, Negate f = NEGF. Syntax:, Negate f = f [,a]. Syntax:, Negate f = . Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C,",
    "PIC18F6525/6621/8525/8621\nDC, Z. Encoding:, Negate f = 0110. Encoding:, Negate f = 110a. Encoding:, Negate f = ffff. Encoding:, Negate f = ffff. Description:, Negate f = Location 'f' is negated using 2's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using 2's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using 2's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ',",
    "PIC18F6525/6621/8525/8621\nthe Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using 2's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Q Cycle Activity:, Negate f = . Q Cycle Activity:, Negate f = . Q Cycle Activity:, Negate f = . Q Cycle Activity:, Negate f = . Q1 Decode, Negate f = Q2 Read. Q1",
    "PIC18F6525/6621/8525/8621\nDecode, Negate f = Q3. Q1 Decode, Negate f = Q3. Q1 Decode, Negate f = Q4. Example:, Negate f = register 'f'. Example:, Negate f = Process Data. Example:, Negate f = Process Data. Example:, Negate f = Write register 'f'. , Negate f = NEGF. , Negate f = REG, 1. , Negate f = REG, 1. , Negate f = . Before Instruction REG =, Negate f = 0011. Before Instruction REG =, Negate f = 1010 [0x3A]. Before Instruction REG =, Negate f = 1010 [0x3A]. Before Instruction REG =, Negate f = . After Instruction REG =, Negate f = 1100. After Instruction REG =, Negate f = 0110 [0xC6]. After Instruction REG =, Negate f = 0110 [0xC6]. After Instruction REG =, Negate f = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Encoding:, No Operation = 0000 1111. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation..",
    "PIC18F6525/6621/8525/8621\nWords:, No Operation = 1. Words:, No Operation = 1. Words:, No Operation = 1. Words:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Q Cycle Activity: Q1, No Operation = Q2. Q Cycle Activity: Q1, No Operation = Q3. Q Cycle Activity: Q1, No Operation = . Q Cycle Activity: Q1, No Operation = Q4. Decode, No Operation = No operation. Decode, No Operation = No operation. Decode, No Operation = . Decode, No Operation = No operation",
    "Example:\nNone.",
    "Pop Top of Return Stack\nSyntax:, 1 = [ label ] POP. Syntax:, 2 = [ label ] POP. Syntax:, 3 = [ label ] POP. Syntax:, 4 = [ label ] POP. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = (TOS) \uf0ae bit bucket. Operation:, 2 = (TOS) \uf0ae bit bucket. Operation:, 3 = (TOS) \uf0ae bit bucket. Operation:, 4 = (TOS) \uf0ae bit bucket. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Encoding:, 4 = 0110. Description:, 1 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 2 = The TOS value is",
    "Pop Top of Return Stack\npulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 3 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 4 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = .",
    "Pop Top of Return Stack\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Q1, 4 = Q4. Decode, 1 = No operation. Decode, 2 = POP TOS value. Decode, 3 = No operation. Decode, 4 = No operation. Example:, 1 = POP. Example:, 2 = POP. Example:, 3 = POP. Example:, 4 = POP. Before Instruction TOS, 1 = Before Instruction TOS. Before Instruction TOS, 2 = . Before Instruction TOS, 3 = . Before Instruction TOS, 4 = . Stack (1 level down)=, 1 = Stack (1 level down)=. Stack (1 level down)=, 2 = 014332h. Stack (1 level down)=, 3 = 014332h. Stack (1 level down)=, 4 = 014332h. After Instruction TOS =, 1 = After Instruction TOS =. After Instruction TOS =, 2 = 014332h. After Instruction TOS =, 3 = 014332h. After Instruction TOS =, 4 = 014332h",
    "Pop Top of Return Stack\nSyntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operation:, Push Top of Return Stack = (PC + 2) \uf0ae TOS. Operation:, Push Top of Return Stack = (PC + 2) \uf0ae TOS. Operation:, Push Top of Return Stack = (PC + 2) \uf0ae TOS. Operation:, Push Top of Return Stack = (PC + 2) \uf0ae TOS. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return",
    "Pop Top of Return Stack\nStack = 0000. Encoding:, Push Top of Return Stack = . Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Words:, Push Top of Return Stack = 1.",
    "Pop Top of Return Stack\nWords:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Q Cycle Activity:, Push Top of Return Stack = . Q Cycle Activity:, Push Top of Return Stack = . Q Cycle Activity:, Push Top of Return Stack = . Q Cycle Activity:, Push Top of Return Stack = . Q1, Push Top of Return Stack = Q2. Q1, Push Top of Return Stack = Q2. Q1, Push Top of Return Stack = Q3. Q1, Push Top of Return Stack = Q4. Decode, Push Top of Return Stack = PUSH PC + 2 onto. Decode, Push Top of Return Stack = PUSH PC + 2 onto. Decode, Push Top of Return Stack = No operation. Decode, Push Top of Return Stack = No operation. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH.",
    "Pop Top of Return Stack\nExample:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. TOS, Push Top of Return Stack = TOS. TOS, Push Top of Return Stack = =. TOS, Push Top of Return Stack = 00345Ah. TOS, Push Top of Return Stack = . PC, Push Top of Return Stack = PC. PC, Push Top of Return Stack = =. PC, Push Top of Return Stack = 000124h. PC, Push Top of Return Stack = . After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. PC, Push Top of Return Stack = PC. PC, Push Top of Return Stack = =. PC, Push Top of Return Stack = 000126h. PC, Push Top of Return Stack = .",
    "Pop Top of Return Stack\nTOS, Push Top of Return Stack = TOS. TOS, Push Top of Return Stack = =. TOS, Push Top of Return Stack = 000126h. TOS, Push Top of Return Stack = . Stack, Push Top of Return Stack = (1 level down)=. Stack, Push Top of Return Stack = (1 level down)=. Stack, Push Top of Return Stack = 00345Ah. Stack, Push Top of Return Stack = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Relative Call = [ label ] RCALL. Syntax:, Relative Call = [ label ] RCALL. Syntax:, Relative Call = n. Syntax:, Relative Call = . Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = . Operands:, Relative Call = . Operation:, Relative Call = (PC) + 2 \uf0ae TOS; (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS; (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = . Operation:, Relative Call = . Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Encoding:, Relative Call = 1101. Encoding:, Relative Call = 1nnn. Encoding:, Relative Call = nnnn. Encoding:, Relative Call = nnnn\nDescription:",
    "PIC18F6525/6621/8525/8621\nSubroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.\nWords:\nCycles:\n1\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'n' Push PC to stack. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nPC, HERE. = =. PC, RCALL Jump. = Address (HERE). After Instruction, HERE. = . After Instruction, RCALL Jump. = . PC, HERE. = =. PC, RCALL Jump. = Address (Jump). TOS, HERE. = =. TOS, RCALL Jump. = Address (HERE + 2)",
    "PIC18F6525/6621/8525/8621\nSyntax:, Reset = [ label ]. Syntax:, Reset = RESET. Syntax:, Reset = RESET. Syntax:, Reset = RESET. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Encoding:, Reset = 0000. Encoding:, Reset = 0000. Encoding:, Reset = 1111. Encoding:, Reset = 1111. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset",
    "PIC18F6525/6621/8525/8621\nin software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q1, Reset = Q2. Q1, Reset = Q3. Q1, Reset = . Q1, Reset = Q4. Decode, Reset = Start Reset. Decode, Reset = No operation. Decode, Reset = . Decode, Reset = No operation",
    "RESET\nAfter Instruction\nRegisters =\nReset Value\nFlags*\n=\nReset Value",
    "Return from Interrupt\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\n[\nlabel\n]    RETFIE   [s]\ns \uf0ce [0,1]\n(TOS) \uf0ae PC;\n1 \uf0ae GIE/GIEH or PEIE/GIEL\nif s =\n1\n(WS) \uf0ae W;\n(STATUSS)\n\uf0ae\nSTATUS;\n(BSRS)\n\uf0ae BSR;\nPCLATU, PCLATH are unchanged\nGIE/GIEH, PEIE/GIEL.\n0000\n0000\n0001\n000s\nReturn from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs (default).\n1\n2",
    "Return from Interrupt\nSyntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operation:, Return Literal to W = k \uf0ae W; (TOS) \uf0ae PC; PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W; (TOS) \uf0ae PC; PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W; (TOS) \uf0ae PC; PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W; (TOS) \uf0ae PC; PCLATU, PCLATH are unchanged. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to",
    "Return from Interrupt\nW = None. Status Affected:, Return Literal to W = None. Encoding:, Return Literal to W = 0000. Encoding:, Return Literal to W = 1100. Encoding:, Return Literal to W = kkkk. Encoding:, Return Literal to W = kkkk. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high",
    "Return from Interrupt\naddress latch (PCLATH) remains unchanged.. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q1, Return Literal to W = Q2. Q1, Return Literal to W = Q3. Q1, Return Literal to W = . Q1, Return Literal to W = Q4. Decode, Return Literal to W = Read literal 'k'. Decode, Return Literal to W = Process Data. Decode, Return Literal to W = . Decode, Return Literal to W = Pop PC from stack, Write to W. No operation, Return Literal to W = No",
    "Return from Interrupt\noperation. No operation, Return Literal to W = No operation. No operation, Return Literal to W = . No operation, Return Literal to W = No operation\nQ Cycle Activity:\nDecode, Q2 = No operation. Decode, Q3 = No operation. Decode, Q4 = Pop PC from stack Set GIEH or GIEL. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nRETFIE  1\nAfter Interrupt\nPC\n=\nTOS\nW\n=\nWS\nBSR\n=\nBSRS\nSTATUS\n=\nSTATUSS\nGIE/GIEH, PEIE/GIEL\n=\n1",
    "Example:\nCALL TABLE\n; W contains table\n; offset value\n; W now has\n; table value\n:\nTABLE\nADDWF PCL\n; W = offset\nRETLW k0\n; Begin table\nRETLW k1 ;\n:\n:\nRETLW kn\n; End of table\nBefore Instruction\nW\n= 0x07\nAfter Instruction\nW =\nvalue of kn",
    "Return from Subroutine\nSyntax:\n[\nlabel\n]    RETURN   [s]\nOperands:\ns \uf0ce [0,1]\nOperation:\n(TOS) \uf0ae PC;\nif s = 1\n(WS) \uf0ae W;\n(STATUSS) \uf0ae STATUS;\n(BSRS) \uf0ae BSR;\nPCLATU, PCLATH are unchanged\nStatus Affected:\nNone\nEncoding:\n0000\n0000\n0001\n001s\nDescription:\nReturn from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's' = 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs (default).\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nNo\noperation\nProcess Data\nPop PC from stack\nNo\noperation\nNo\noperation\nNo\noperation\nNo operation\nExample:\nRETURN\nAfter Interrupt PC = TOS",
    "Return from Subroutine\nSyntax:, Rotate Left f through Carry = [ label ]. Syntax:, Rotate Left f through Carry = RLCF. Syntax:, Rotate Left f through Carry = f [,d [,a]. Syntax:, Rotate Left f through Carry = . Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>; (f<7>) \uf0ae C; (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>; (f<7>) \uf0ae C; (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry =",
    "Return from Subroutine\n(f<n>) \uf0ae dest<n + 1>; (f<7>) \uf0ae C; (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>; (f<7>) \uf0ae C; (C) \uf0ae dest<0>. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Encoding:, Rotate Left f through Carry = 0011. Encoding:, Rotate Left f through Carry = 01da. Encoding:, Rotate Left f through Carry = ffff. Encoding:, Rotate Left f through Carry = ffff. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If",
    "Return from Subroutine\n'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Rotate Left f through Carry = The",
    "Return from Subroutine\ncontents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Q Cycle Activity: Q1, Rotate Left f through Carry = Q2. Q Cycle Activity: Q1, Rotate Left f through Carry = Q3 Q4. Q Cycle Activity: Q1, Rotate Left f through Carry = Q3 Q4. Q Cycle Activity: Q1, Rotate Left f through Carry = Q3 Q4.",
    "Return from Subroutine\nDecode, Rotate Left f through Carry = Read register 'f'. Decode, Rotate Left f through Carry = Process Data Write to destination. Decode, Rotate Left f through Carry = Process Data Write to destination. Decode, Rotate Left f through Carry = Process Data Write to destination. Example:, Rotate Left f through Carry = RLCF. Example:, Rotate Left f through Carry = REG,. Example:, Rotate Left f through Carry = 0, 0. Example:, Rotate Left f through Carry = . Before Instruction = 0110, Rotate Left f through Carry = Before Instruction = 0110. Before Instruction = 0110, Rotate Left f through Carry = Before Instruction = 0110. Before Instruction = 0110, Rotate Left f through Carry = Before Instruction = 0110. Before Instruction = 0110, Rotate Left f through Carry = Before Instruction = 0110. REG C, Rotate Left f through Carry = 1110 = 0. REG C, Rotate Left f through Carry = . REG C, Rotate Left f through Carry = . REG C, Rotate Left f through Carry = . REG W, Rotate Left f through Carry = = 1110 = 1100 = 1. REG W, Rotate Left f through Carry =",
    "Return from Subroutine\n0110 1100. REG W, Rotate Left f through Carry = . REG W, Rotate Left f through Carry = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Rotate Left f (No Carry) = [ label ]. Syntax:, Rotate Left f (No Carry) = RLNCF. Syntax:, Rotate Left f (No Carry) = f [,d [,a]. Syntax:, Rotate Left f (No Carry) = f [,d [,a]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>; (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n +",
    "PIC18F6525/6621/8525/8621\n1>; (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>; (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>; (f<7>) \uf0ae dest<0>. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Encoding:, Rotate Left f (No Carry) = 0100. Encoding:, Rotate Left f (No Carry) = 01da. Encoding:, Rotate Left f (No Carry) = ffff. Encoding:, Rotate Left f (No Carry) = ffff. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0",
    "PIC18F6525/6621/8525/8621\n', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is",
    "PIC18F6525/6621/8525/8621\n' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. , Rotate Left f (No Carry) = . , Rotate Left f (No Carry) = register. , Rotate Left f (No Carry) = register. , Rotate Left f (No Carry) = . Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f",
    "PIC18F6525/6621/8525/8621\n(No Carry) = . Words:, Rotate Left f (No Carry) = . Words:, Rotate Left f (No Carry) = . Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Q Cycle Activity: Q1, Rotate Left f (No Carry) = Q2. Q Cycle Activity: Q1, Rotate Left f (No Carry) = Q3. Q Cycle Activity: Q1, Rotate Left f (No Carry) = Q4. Q Cycle Activity: Q1, Rotate Left f (No Carry) = Q4. Decode, Rotate Left f (No Carry) = Read register 'f'. Decode, Rotate Left f (No Carry) = Process Data. Decode, Rotate Left f (No Carry) = Write to. Decode, Rotate Left f (No Carry) = Write to. Before Instruction REG =, Rotate Left f (No Carry) = 1010. Before Instruction REG =, Rotate Left f (No Carry) =",
    "PIC18F6525/6621/8525/8621\n1011. Before Instruction REG =, Rotate Left f (No Carry) = . Before Instruction REG =, Rotate Left f (No Carry) = . After Instruction REG =, Rotate Left f (No Carry) = 0101. After Instruction REG =, Rotate Left f (No Carry) = 0111. After Instruction REG =, Rotate Left f (No Carry) = . After Instruction REG =, Rotate Left f (No Carry) = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]. Syntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]. Syntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]. Syntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>; (f<0>) \uf0ae C; (C) \uf0ae dest<7>.",
    "PIC18F6525/6621/8525/8621\nOperation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>; (f<0>) \uf0ae C; (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>; (f<0>) \uf0ae C; (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>; (f<0>) \uf0ae C; (C) \uf0ae dest<7>. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff. Description:, Rotate Right f through Carry = The",
    "PIC18F6525/6621/8525/8621\ncontents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated",
    "PIC18F6525/6621/8525/8621\none bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Words:, Rotate",
    "PIC18F6525/6621/8525/8621\nRight f through Carry = 1. Words:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q1, Rotate Right f through Carry = Q2. Q1, Rotate Right f through Carry = Q3. Q1, Rotate Right f through Carry = Q3. Q1, Rotate Right f through Carry = Q4. Decode, Rotate Right f through Carry = Read register 'f'. Decode, Rotate Right f through Carry = Process Data. Decode, Rotate Right f through Carry = Process Data. Decode, Rotate Right f through Carry = Write to destination. Example:, Rotate Right f through Carry = RRCF. Example:,",
    "PIC18F6525/6621/8525/8621\nRotate Right f through Carry = REG,. Example:, Rotate Right f through Carry = 0,. Example:, Rotate Right f through Carry = 0. Before Instruction 1110, Rotate Right f through Carry = Before Instruction 1110. Before Instruction 1110, Rotate Right f through Carry = Before Instruction 1110. Before Instruction 1110, Rotate Right f through Carry = Before Instruction 1110. Before Instruction 1110, Rotate Right f through Carry = Before Instruction 1110. REG, Rotate Right f through Carry = = = 0. REG, Rotate Right f through Carry = 0110. REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . W, Rotate Right f through Carry = . W, Rotate Right f through Carry = 0011. W, Rotate Right f through Carry = . W, Rotate Right f through Carry = . After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. REG, Rotate Right f through Carry = = 1110. REG, Rotate Right f through Carry",
    "PIC18F6525/6621/8525/8621\n= 0110. REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . , Rotate Right f through Carry = = 0111 0. , Rotate Right f through Carry = . , Rotate Right f through Carry = . , Rotate Right f through Carry = . C, Rotate Right f through Carry = =. C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Rotate Right f (No Carry) = [ label ] RRNCF f [,d [,a]. Syntax:, Rotate Right f (No Carry) = [ label ] RRNCF f [,d [,a]. Syntax:, Rotate Right f (No Carry) = [ label ] RRNCF f [,d [,a]. Syntax:, Rotate Right f (No Carry) = [ label ] RRNCF f [,d [,a]. Operands:, Rotate Right f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>;",
    "PIC18F6525/6621/8525/8621\n(f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>; (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>; (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>; (f<0>) \uf0ae dest<7>. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = . Status Affected:, Rotate Right f (No Carry) = . Status Affected:, Rotate Right f (No Carry) = . Encoding:, Rotate Right f (No Carry) = 0100. Encoding:, Rotate Right f (No Carry) = 00da. Encoding:, Rotate Right f (No Carry) = ffff. Encoding:, Rotate Right f (No Carry) = ffff. Description:, Rotate Right f (No",
    "PIC18F6525/6621/8525/8621\nCarry) = The contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default). register f. Description:, Rotate Right f (No Carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default). register f. Description:, Rotate Right f (No Carry) = The contents of register 'f'",
    "PIC18F6525/6621/8525/8621\nare rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default). register f. Description:, Rotate Right f (No Carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default). register f. Words:, Rotate Right f (No Carry) = 1. Words:, Rotate Right f (No Carry) = . Words:,",
    "PIC18F6525/6621/8525/8621\nRotate Right f (No Carry) = . Words:, Rotate Right f (No Carry) = . Cycles:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = . Cycles:, Rotate Right f (No Carry) = . Cycles:, Rotate Right f (No Carry) = . Q Cycle Activity: Q1, Rotate Right f (No Carry) = Q2. Q Cycle Activity: Q1, Rotate Right f (No Carry) = Q3. Q Cycle Activity: Q1, Rotate Right f (No Carry) = Q3. Q Cycle Activity: Q1, Rotate Right f (No Carry) = Q4. Decode, Rotate Right f (No Carry) = Read register 'f'. Decode, Rotate Right f (No Carry) = Process Data. Decode, Rotate Right f (No Carry) = Process Data. Decode, Rotate Right f (No Carry) = Write to destination. Example 1:, Rotate Right f (No Carry) = RRNCF. Example 1:, Rotate Right f (No Carry) = REG,. Example 1:, Rotate Right f (No",
    "PIC18F6525/6621/8525/8621\nCarry) = 1, 0. Example 1:, Rotate Right f (No Carry) = . Before Instruction REG = 1101, Rotate Right f (No Carry) = Before Instruction REG = 1101. Before Instruction REG = 1101, Rotate Right f (No Carry) = 0111. Before Instruction REG = 1101, Rotate Right f (No Carry) = . Before Instruction REG = 1101, Rotate Right f (No Carry) = . REG, Rotate Right f (No Carry) = = 1110. REG, Rotate Right f (No Carry) = 1011. REG, Rotate Right f (No Carry) = . REG, Rotate Right f (No Carry) = . After Instruction, Rotate Right f (No Carry) = After Instruction. After Instruction, Rotate Right f (No Carry) = . After Instruction, Rotate Right f (No Carry) = . After Instruction, Rotate Right f (No Carry) = . Example 2:, Rotate Right f (No Carry) = RRNCF. Example 2:, Rotate Right f (No Carry) = REG,. Example 2:, Rotate Right f (No Carry) = 0, 0. Example 2:,",
    "PIC18F6525/6621/8525/8621\nRotate Right f (No Carry) = . Before Instruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = . Before Instruction, Rotate Right f (No Carry) = . Before Instruction, Rotate Right f (No Carry) = . W REG, Rotate Right f (No Carry) = = ? =. W REG, Rotate Right f (No Carry) = . W REG, Rotate Right f (No Carry) = . W REG, Rotate Right f (No Carry) = . After Instruction, Rotate Right f (No Carry) = After Instruction. After Instruction, Rotate Right f (No Carry) = . After Instruction, Rotate Right f (No Carry) = . After Instruction, Rotate Right f (No Carry) = . W, Rotate Right f (No Carry) = = 1110. W, Rotate Right f (No Carry) = 1011. W, Rotate Right f (No Carry) = . W, Rotate Right f (No Carry) = . REG, Rotate Right f (No Carry) = = 1101. REG, Rotate Right f (No Carry) = 0111. REG, Rotate Right f",
    "PIC18F6525/6621/8525/8621\n(No Carry) = . REG, Rotate Right f (No Carry) = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Set f = [ label ] SETF f [,a]. Syntax:, Set f = [ label ] SETF f [,a]. Syntax:, Set f = [ label ] SETF f [,a]. Syntax:, Set f = [ label ] SETF f [,a]. Operands:, Set f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Set f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Set f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Set f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operation:, Set f = FFh \uf0ae f. Operation:, Set f = FFh \uf0ae f. Operation:, Set f = FFh \uf0ae f. Operation:, Set f = FFh \uf0ae f. Status Affected:, Set f = None. Status Affected:, Set f = None. Status Affected:, Set f = None. Status Affected:, Set f = None. Encoding:, Set f = 0110. Encoding:, Set f = 100a. Encoding:, Set f = ffff. Encoding:,",
    "PIC18F6525/6621/8525/8621\nSet f = ffff. Description:, Set f = The contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank will be selected,",
    "PIC18F6525/6621/8525/8621\noverriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Set f = 1. Words:, Set f = 1. Words:, Set f = 1. Words:, Set f = 1. Cycles:, Set f = 1. Cycles:, Set f = 1. Cycles:, Set f = 1. Cycles:, Set f = 1. Q Cycle Activity:, Set f = . Q Cycle Activity:, Set f = . Q Cycle Activity:, Set f = . Q Cycle Activity:, Set f = . Q1, Set f = Q2. Q1, Set f = . Q1, Set f = Q3. Q1, Set f = Q4. Decode, Set f = . Decode, Set f = Read register 'f'. Decode, Set f = Process Data. Decode, Set f = Write register 'f'. Example:, Set f = . Example:, Set f = . Example:, Set f = . Example:, Set f = . , Set f = . , Set",
    "PIC18F6525/6621/8525/8621\nf = SETF. , Set f = REG,1. , Set f = . Before Instruction 0x5A, Set f = Before Instruction 0x5A. Before Instruction 0x5A, Set f = Before Instruction 0x5A. Before Instruction 0x5A, Set f = Before Instruction 0x5A. Before Instruction 0x5A, Set f = Before Instruction 0x5A. , Set f = . , Set f = =. , Set f = . , Set f = . , Set f = REG. , Set f = . , Set f = . , Set f = . After Instruction REG =, Set f = After Instruction REG =. After Instruction REG =, Set f = 0xFF. After Instruction REG =, Set f = . After Instruction REG =, Set f = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, SLEEP = Syntax:. Syntax:, Enter Sleep Mode = [ label ]. Syntax:, Enter Sleep Mode = SLEEP. Syntax:, Enter Sleep Mode = SLEEP. Operands:, SLEEP = Operands:. Operands:, Enter Sleep Mode = None. Operands:, Enter Sleep Mode = . Operands:, Enter Sleep Mode = . Operation:, SLEEP = Operation:. Operation:, Enter Sleep Mode = 00h \uf0ae WDT; 0 \uf0ae WDT postscaler; 1 \uf0ae TO; 0 \uf0ae PD. Operation:, Enter Sleep Mode = 00h \uf0ae WDT; 0 \uf0ae WDT postscaler; 1 \uf0ae TO; 0 \uf0ae PD. Operation:, Enter Sleep Mode = 00h \uf0ae WDT; 0 \uf0ae WDT postscaler; 1 \uf0ae TO; 0 \uf0ae PD. Status Affected:, SLEEP = Status Affected:. Status Affected:, Enter Sleep Mode = TO, PD. Status Affected:, Enter Sleep Mode = . Status Affected:, Enter Sleep Mode = . Encoding:, SLEEP = Encoding:. Encoding:, Enter Sleep Mode = 0000. Encoding:, Enter Sleep Mode = 0000. Encoding:, Enter Sleep Mode = 0000. Description:, SLEEP =",
    "PIC18F6525/6621/8525/8621\nDescription:. Description:, Enter Sleep Mode = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep Mode = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep Mode = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Words:, SLEEP = Words:. Words:, Enter Sleep Mode = 1. Words:, Enter Sleep Mode = . Words:, Enter Sleep Mode = . Cycles:, SLEEP = Cycles:. Cycles:, Enter Sleep Mode = 1. Cycles:, Enter Sleep Mode = . Cycles:, Enter Sleep Mode =",
    "PIC18F6525/6621/8525/8621\n. Q Cycle Activity:, SLEEP = Q Cycle Activity:. Q Cycle Activity:, Enter Sleep Mode = Q2. Q Cycle Activity:, Enter Sleep Mode = . Q Cycle Activity:, Enter Sleep Mode = . , SLEEP = Q1. , Enter Sleep Mode = . , Enter Sleep Mode = Q3. , Enter Sleep Mode = Q3. , SLEEP = Decode. , Enter Sleep Mode = No operation. , Enter Sleep Mode = Process. , Enter Sleep Mode = Process",
    "SLEEP\nBefore Instruction\nTO\n=\n?\nPD\n=\n?\nAfter Instruction\nTO\n=\n1 \u2020\nPD\n=\n0\n- \u2020   If WDT causes wake-up, this bit is cleared.",
    "SLEEP\nSyntax:, Subtract f from Wwith Borrow = [ label ] SUBFWB f [,d [,a]. Syntax:, Subtract f from Wwith Borrow = [ label ] SUBFWB f [,d [,a]. Syntax:, Subtract f from Wwith Borrow = [ label ] SUBFWB f [,d [,a]. Syntax:, Subtract f from Wwith Borrow = [ label ] SUBFWB f [,d [,a]. Syntax:, Subtract f from Wwith Borrow = [ label ] SUBFWB f [,d [,a]. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce",
    "SLEEP\n[0,1]. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Status Affected:, Subtract f from Wwith Borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith Borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith Borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith Borrow = N, OV,",
    "SLEEP\nC, DC, Z. Status Affected:, Subtract f from Wwith Borrow = N, OV, C, DC, Z. Encoding:, Subtract f from Wwith Borrow = 0101 01da ffff ffff Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in 'f' (default). If 'a' is ' 0 ', the Bank will be selected, over- the BSR value. If 'a' is ' 1 ', then bank will be selected as per the value (default).. Encoding:, Subtract f from Wwith Borrow = 0101 01da ffff ffff Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in 'f' (default). If 'a' is ' 0 ', the Bank will be selected, over- the BSR",
    "SLEEP\nvalue. If 'a' is ' 1 ', then bank will be selected as per the value (default).. Encoding:, Subtract f from Wwith Borrow = 0101 01da ffff ffff Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in 'f' (default). If 'a' is ' 0 ', the Bank will be selected, over- the BSR value. If 'a' is ' 1 ', then bank will be selected as per the value (default).. Encoding:, Subtract f from Wwith Borrow = 0101 01da ffff ffff Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in 'f' (default). If 'a' is ' 0 ', the Bank will be selected, over- the BSR value. If",
    "SLEEP\n'a' is ' 1 ', then bank will be selected as per the value (default).. Encoding:, Subtract f from Wwith Borrow = 0101 01da ffff ffff Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in 'f' (default). If 'a' is ' 0 ', the Bank will be selected, over- the BSR value. If 'a' is ' 1 ', then bank will be selected as per the value (default).. , Subtract f from Wwith Borrow = register Access riding the BSR 1 1. , Subtract f from Wwith Borrow = register Access riding the BSR 1 1. , Subtract f from Wwith Borrow = register Access riding the BSR 1 1. , Subtract f from Wwith Borrow = register Access riding the BSR 1 1. , Subtract f from Wwith Borrow = register Access riding the BSR 1 1. Cycles:, Subtract f from Wwith Borrow = .",
    "SLEEP\nCycles:, Subtract f from Wwith Borrow = . Cycles:, Subtract f from Wwith Borrow = . Cycles:, Subtract f from Wwith Borrow = . Cycles:, Subtract f from Wwith Borrow = . Q Cycle Activity:, Subtract f from Wwith Borrow = . Q Cycle Activity:, Subtract f from Wwith Borrow = . Q Cycle Activity:, Subtract f from Wwith Borrow = . Q Cycle Activity:, Subtract f from Wwith Borrow = . Q Cycle Activity:, Subtract f from Wwith Borrow = . Q1, Subtract f from Wwith Borrow = . Q1, Subtract f from Wwith Borrow = . Q1, Subtract f from Wwith Borrow = . Q1, Subtract f from Wwith Borrow = . Q1, Subtract f from Wwith Borrow = . , Subtract f from Wwith Borrow = Q2. , Subtract f from Wwith Borrow = Q2. , Subtract f from Wwith Borrow = Q3. , Subtract f from Wwith Borrow = Q3. , Subtract f from Wwith Borrow =",
    "SLEEP\nQ4. Decode, Subtract f from Wwith Borrow = Read register 'f'. Decode, Subtract f from Wwith Borrow = Read register 'f'. Decode, Subtract f from Wwith Borrow = Process Data. Decode, Subtract f from Wwith Borrow = Process Data. Decode, Subtract f from Wwith Borrow = Write to destination. Example 1:, Subtract f from Wwith Borrow = SUBFWB. Example 1:, Subtract f from Wwith Borrow = SUBFWB. Example 1:, Subtract f from Wwith Borrow = REG, 1, 0. Example 1:, Subtract f from Wwith Borrow = REG, 1, 0. Example 1:, Subtract f from Wwith Borrow = . Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = . Before Instruction, Subtract f from Wwith Borrow = . Before Instruction, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = 3.",
    "SLEEP\nREG, Subtract f from Wwith Borrow = 3. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = 2. W, Subtract f from Wwith Borrow = 2. W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = 1. After Instruction, Subtract f from Wwith Borrow = 1. After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . REG W, Subtract f from Wwith Borrow = FF 2. REG",
    "SLEEP\nW, Subtract f from Wwith Borrow = FF 2. REG W, Subtract f from Wwith Borrow = . REG W, Subtract f from Wwith Borrow = . REG W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = 0. C, Subtract f from Wwith Borrow = 0. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . , Subtract f from Wwith Borrow = 0. , Subtract f from Wwith Borrow = 0. , Subtract f from Wwith Borrow = . , Subtract f from Wwith Borrow = . , Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = 1 ;. N, Subtract f from Wwith",
    "SLEEP\nBorrow = 1 ;. N, Subtract f from Wwith Borrow = result is negative. N, Subtract f from Wwith Borrow = result is negative. N, Subtract f from Wwith Borrow = . Example 2:, Subtract f from Wwith Borrow = . Example 2:, Subtract f from Wwith Borrow = . Example 2:, Subtract f from Wwith Borrow = REG, 0, 0. Example 2:, Subtract f from Wwith Borrow = REG, 0, 0. Example 2:, Subtract f from Wwith Borrow = . SUBFWB Before Instruction, Subtract f from Wwith Borrow = SUBFWB Before Instruction. SUBFWB Before Instruction, Subtract f from Wwith Borrow = SUBFWB Before Instruction. SUBFWB Before Instruction, Subtract f from Wwith Borrow = . SUBFWB Before Instruction, Subtract f from Wwith Borrow = . SUBFWB Before Instruction, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = 2. REG, Subtract f from Wwith Borrow = 2. REG, Subtract",
    "SLEEP\nf from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = 5. W, Subtract f from Wwith Borrow = 5. W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = 1. C, Subtract f from Wwith Borrow = 1. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . After Instruction REG, Subtract f from Wwith Borrow = . After Instruction REG, Subtract f from Wwith Borrow = . After Instruction REG, Subtract f from Wwith Borrow = . After Instruction REG, Subtract f from Wwith Borrow = . After Instruction REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = 2 3. W, Subtract f from Wwith Borrow = 2 3. W,",
    "SLEEP\nSubtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = 1. C, Subtract f from Wwith Borrow = 1. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = 0. Z, Subtract f from Wwith Borrow = 0. Z, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = 0 ;. N, Subtract f from Wwith Borrow = 0 ;. N, Subtract f from Wwith Borrow = result is positive. N, Subtract f from Wwith Borrow = result is positive. N, Subtract f from Wwith Borrow = . Example 3:, Subtract f from Wwith Borrow = Example 3:. Example 3:, Subtract f from",
    "SLEEP\nWwith Borrow = REG, 1,. Example 3:, Subtract f from Wwith Borrow = REG, 1,. Example 3:, Subtract f from Wwith Borrow = 0. Example 3:, Subtract f from Wwith Borrow = 0. SUBFWB Before Instruction, Subtract f from Wwith Borrow = SUBFWB Before Instruction. SUBFWB Before Instruction, Subtract f from Wwith Borrow = SUBFWB Before Instruction. SUBFWB Before Instruction, Subtract f from Wwith Borrow = . SUBFWB Before Instruction, Subtract f from Wwith Borrow = . SUBFWB Before Instruction, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = 1. REG, Subtract f from Wwith Borrow = 1. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = 2. W, Subtract f from Wwith Borrow = 2. W, Subtract f from Wwith Borrow = .",
    "SLEEP\nW, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = 0. C, Subtract f from Wwith Borrow = 0. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = 0 2. REG, Subtract f from Wwith Borrow = 0 2. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W C, Subtract f from Wwith Borrow = . W C, Subtract f from Wwith Borrow = . W C, Subtract f from Wwith Borrow = . W",
    "SLEEP\nC, Subtract f from Wwith Borrow = . W C, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = 1 1. Z, Subtract f from Wwith Borrow = 1 1. Z, Subtract f from Wwith Borrow = result is zero. Z, Subtract f from Wwith Borrow = result is zero. Z, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = ; 0. N, Subtract f from Wwith Borrow = ; 0. N, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Subtract Wfrom Literal = [ label ] SUBLW k. Syntax:, Subtract Wfrom Literal = [ label ] SUBLW k. Syntax:, Subtract Wfrom Literal = [ label ] SUBLW k. Syntax:, Subtract Wfrom Literal = [ label ] SUBLW k. Syntax:, Subtract Wfrom Literal = [ label ] SUBLW k. Operands:, Subtract Wfrom Literal = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Subtract Wfrom Literal = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Subtract Wfrom Literal = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Subtract Wfrom Literal = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Subtract Wfrom Literal = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operation:, Subtract Wfrom Literal = k - (W) \uf0ae\uf020 W. Operation:, Subtract Wfrom Literal = k - (W) \uf0ae\uf020 W. Operation:, Subtract Wfrom Literal = k - (W) \uf0ae\uf020 W. Operation:, Subtract Wfrom Literal = k -",
    "PIC18F6525/6621/8525/8621\n(W) \uf0ae\uf020 W. Operation:, Subtract Wfrom Literal = k - (W) \uf0ae\uf020 W. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Encoding:, Subtract Wfrom Literal = 0000. Encoding:, Subtract Wfrom Literal = 1000. Encoding:, Subtract Wfrom Literal = kkkk. Encoding:, Subtract Wfrom Literal = kkkk. Encoding:, Subtract Wfrom Literal = kkkk. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in",
    "PIC18F6525/6621/8525/8621\nW.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:,",
    "PIC18F6525/6621/8525/8621\nSubtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q1, Subtract Wfrom Literal = Q2. Q1, Subtract Wfrom Literal = Q2. Q1, Subtract Wfrom Literal = Q3. Q1, Subtract Wfrom Literal = Q4. Q1, Subtract Wfrom Literal = Q4. Decode, Subtract Wfrom Literal = Read literal 'k'. Decode, Subtract Wfrom Literal = Read literal 'k'. Decode, Subtract Wfrom Literal = Process Data. Decode, Subtract Wfrom Literal =",
    "PIC18F6525/6621/8525/8621\nWrite to W. Decode, Subtract Wfrom Literal = Write to W. Example 1:, Subtract Wfrom Literal = SUBLW. Example 1:, Subtract Wfrom Literal = SUBLW. Example 1:, Subtract Wfrom Literal = 0x02. Example 1:, Subtract Wfrom Literal = . Example 1:, Subtract Wfrom Literal = . Before Instruction W, Subtract Wfrom Literal = . Before Instruction W, Subtract Wfrom Literal = . Before Instruction W, Subtract Wfrom Literal = . Before Instruction W, Subtract Wfrom Literal = . Before Instruction W, Subtract Wfrom Literal = . C Instruction, Subtract Wfrom Literal = 1 ?. C Instruction, Subtract Wfrom Literal = 1 ?. C Instruction, Subtract Wfrom Literal = 1 ?. C Instruction, Subtract Wfrom Literal = 1 ?. C Instruction, Subtract Wfrom Literal = 1 ?. W, Subtract Wfrom Literal = 1.",
    "PIC18F6525/6621/8525/8621\nW, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = 1 ; result is positive 0. C, Subtract Wfrom Literal = 1 ; result is positive 0. C, Subtract Wfrom Literal = 1 ; result is positive 0. C, Subtract Wfrom Literal = 1 ; result is positive 0. C, Subtract Wfrom Literal = 1 ; result is positive 0. Z, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = 0. N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . Example",
    "PIC18F6525/6621/8525/8621\n2:, Subtract Wfrom Literal = SUBLW 0x02. Example 2:, Subtract Wfrom Literal = SUBLW 0x02. Example 2:, Subtract Wfrom Literal = SUBLW 0x02. Example 2:, Subtract Wfrom Literal = SUBLW 0x02. Example 2:, Subtract Wfrom Literal = SUBLW 0x02. Before Instruction, Subtract Wfrom Literal = . Before Instruction, Subtract Wfrom Literal = . Before Instruction, Subtract Wfrom Literal = . Before Instruction, Subtract Wfrom Literal = . Before Instruction, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = 2 ?. C, Subtract Wfrom Literal = 2 ?. C, Subtract Wfrom Literal = 2 ?. C, Subtract Wfrom Literal = 2 ?. C, Subtract Wfrom Literal = 2 ?. After Instruction, Subtract Wfrom Literal = . After Instruction, Subtract",
    "PIC18F6525/6621/8525/8621\nWfrom Literal = . After Instruction, Subtract Wfrom Literal = . After Instruction, Subtract Wfrom Literal = . After Instruction, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = 0. W, Subtract Wfrom Literal = ; result is zero. W, Subtract Wfrom Literal = ; result is zero. W, Subtract Wfrom Literal = ; result is zero. W, Subtract Wfrom Literal = ; result is zero. C Z, Subtract Wfrom Literal = 1 1 0. C Z, Subtract Wfrom Literal = 1 1 0. C Z, Subtract Wfrom Literal = 1 1 0. C Z, Subtract Wfrom Literal = 1 1 0. C Z, Subtract Wfrom Literal = 1 1 0. N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal",
    "PIC18F6525/6621/8525/8621\n= . 3:, Subtract Wfrom Literal = SUBLW 0x02. 3:, Subtract Wfrom Literal = SUBLW 0x02. 3:, Subtract Wfrom Literal = SUBLW 0x02. 3:, Subtract Wfrom Literal = SUBLW 0x02. 3:, Subtract Wfrom Literal = SUBLW 0x02. Example, Subtract Wfrom Literal = . Example, Subtract Wfrom Literal = . Example, Subtract Wfrom Literal = . Example, Subtract Wfrom Literal = . Example, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = 3 ?. C, Subtract Wfrom Literal = 3 ?. C, Subtract Wfrom Literal = 3 ?. C, Subtract Wfrom Literal = 3 ?. C, Subtract Wfrom Literal = 3 ?. After Instruction, Subtract Wfrom Literal = . After Instruction, Subtract Wfrom Literal = . After",
    "PIC18F6525/6621/8525/8621\nInstruction, Subtract Wfrom Literal = . After Instruction, Subtract Wfrom Literal = . After Instruction, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = FF. W, Subtract Wfrom Literal = ; (2's complement). W, Subtract Wfrom Literal = ; (2's complement). W, Subtract Wfrom Literal = ; (2's complement). W, Subtract Wfrom Literal = ; (2's complement). C, Subtract Wfrom Literal = 0 0. C, Subtract Wfrom Literal = 0 0. C, Subtract Wfrom Literal = 0 0. C, Subtract Wfrom Literal = 0 0. C, Subtract Wfrom Literal = 0 0. Z, Subtract Wfrom Literal = 1. Z, Subtract Wfrom Literal = 1. Z, Subtract Wfrom Literal = 1. Z, Subtract Wfrom Literal = 1. Z, Subtract Wfrom Literal =",
    "PIC18F6525/6621/8525/8621\n1. , Subtract Wfrom Literal = . , Subtract Wfrom Literal = ; result is negative. , Subtract Wfrom Literal = ; result is negative. , Subtract Wfrom Literal = ; result is negative. , Subtract Wfrom Literal = ; result is negative. N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = ",
    "PIC18F6525/6621/8525/8621\nSyntax:, Subtract Wfrom f = [ label ]. Syntax:, Subtract Wfrom f = SUBWF. Syntax:, Subtract Wfrom f = f [,d [,a]. Syntax:, Subtract Wfrom f = f [,d [,a]. Syntax:, Subtract Wfrom f = f [,d [,a]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Subtract Wfrom f =",
    "PIC18F6525/6621/8525/8621\n(f) - (W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = (f) - (W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = (f) - (W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = (f) - (W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = (f) - (W) \uf0ae\uf020 dest. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Encoding:, Subtract Wfrom f = 0101. Encoding:, Subtract Wfrom f = 11da. Encoding:,",
    "PIC18F6525/6621/8525/8621\nSubtract Wfrom f = ffff. Encoding:, Subtract Wfrom f = ffff. Encoding:, Subtract Wfrom f = . Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the",
    "PIC18F6525/6621/8525/8621\nBSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a'",
    "PIC18F6525/6621/8525/8621\nis ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f =",
    "PIC18F6525/6621/8525/8621\n1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Q Cycle Activity: Q1, Subtract Wfrom f = Q2. Q Cycle Activity: Q1, Subtract Wfrom f = Q2. Q Cycle Activity: Q1, Subtract Wfrom f = Q3. Q Cycle Activity: Q1, Subtract Wfrom f = Q4 Write to. Q Cycle Activity: Q1, Subtract Wfrom f = . , Subtract Wfrom f = SUBWF. , Subtract Wfrom f = SUBWF. , Subtract Wfrom f = 1, 0. , Subtract Wfrom f = 1, 0. , Subtract Wfrom f = . Example 1:, Subtract Wfrom f = . Example 1:, Subtract Wfrom f = . Example 1:, Subtract Wfrom f = REG,. Example 1:, Subtract Wfrom f = REG,. Example 1:,",
    "PIC18F6525/6621/8525/8621\nSubtract Wfrom f = . Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = . Before Instruction, Subtract Wfrom f = . Before Instruction, Subtract Wfrom f = . REG =, Subtract Wfrom f = 3. REG =, Subtract Wfrom f = 3. REG =, Subtract Wfrom f = . REG =, Subtract Wfrom f = . REG =, Subtract Wfrom f = . W =, Subtract Wfrom f = 2. W =, Subtract Wfrom f = 2. W =, Subtract Wfrom f = . W =, Subtract Wfrom f = . W =, Subtract Wfrom f = . C = After, Subtract Wfrom f = ?. C = After, Subtract Wfrom f = ?. C = After, Subtract Wfrom f = . C = After,",
    "PIC18F6525/6621/8525/8621\nSubtract Wfrom f = . C = After, Subtract Wfrom f = . Instruction REG, Subtract Wfrom f = . Instruction REG, Subtract Wfrom f = . Instruction REG, Subtract Wfrom f = . Instruction REG, Subtract Wfrom f = . Instruction REG, Subtract Wfrom f = . W =, Subtract Wfrom f = 1 2 ;. W =, Subtract Wfrom f = 1 2 ;. W =, Subtract Wfrom f = . W =, Subtract Wfrom f = . W =, Subtract Wfrom f = . C =, Subtract Wfrom f = 1. C =, Subtract Wfrom f = 1. C =, Subtract Wfrom f = result is positive. C =, Subtract Wfrom f = result is positive. C =, Subtract Wfrom f = . Z = N, Subtract Wfrom f = 0 0. Z = N, Subtract Wfrom f",
    "PIC18F6525/6621/8525/8621\n= 0 0. Z = N, Subtract Wfrom f = . Z = N, Subtract Wfrom f = . Z = N, Subtract Wfrom f = . Example, Subtract Wfrom f = . Example, Subtract Wfrom f = . Example, Subtract Wfrom f = REG, 0, 0. Example, Subtract Wfrom f = REG, 0, 0. Example, Subtract Wfrom f = . 2:, Subtract Wfrom f = SUBWF. 2:, Subtract Wfrom f = SUBWF. 2:, Subtract Wfrom f = . 2:, Subtract Wfrom f = . 2:, Subtract Wfrom f = . REG = W, Subtract Wfrom f = 2 2. REG = W, Subtract Wfrom f = 2 2. REG = W, Subtract Wfrom f = . REG = W, Subtract Wfrom f = . REG = W, Subtract Wfrom f =",
    "PIC18F6525/6621/8525/8621\n. C =, Subtract Wfrom f = ?. C =, Subtract Wfrom f = ?. C =, Subtract Wfrom f = . C =, Subtract Wfrom f = . C =, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . REG =, Subtract Wfrom f = 2. REG =, Subtract Wfrom f = 2. REG =, Subtract Wfrom f = . REG =, Subtract Wfrom f = . REG =, Subtract Wfrom f = . W =, Subtract Wfrom f = 0. W =, Subtract Wfrom f = 0. W =, Subtract Wfrom f = is zero. W =, Subtract Wfrom f = is zero. W =,",
    "PIC18F6525/6621/8525/8621\nSubtract Wfrom f = . C =, Subtract Wfrom f = 1 ;. C =, Subtract Wfrom f = result. C =, Subtract Wfrom f = . C =, Subtract Wfrom f = . C =, Subtract Wfrom f = . Z = N, Subtract Wfrom f = 1 0. Z = N, Subtract Wfrom f = 1 0. Z = N, Subtract Wfrom f = . Z = N, Subtract Wfrom f = . Z = N, Subtract Wfrom f = . 3:, Subtract Wfrom f = . 3:, Subtract Wfrom f = . 3:, Subtract Wfrom f = . 3:, Subtract Wfrom f = . 3:, Subtract Wfrom f = . , Subtract Wfrom f = SUBWF Instruction. , Subtract Wfrom f = SUBWF Instruction. , Subtract Wfrom f = . ,",
    "PIC18F6525/6621/8525/8621\nSubtract Wfrom f = . , Subtract Wfrom f = . Example, Subtract Wfrom f = . Example, Subtract Wfrom f = . Example, Subtract Wfrom f = . Example, Subtract Wfrom f = . Example, Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = REG, 1, 0. , Subtract Wfrom f = REG, 1, 0. , Subtract Wfrom f = . REG =, Subtract Wfrom f = 1. REG =, Subtract Wfrom f = 1. REG =, Subtract Wfrom f = . REG =, Subtract Wfrom f = . REG =, Subtract Wfrom f = . W = C, Subtract Wfrom f = 2. W = C, Subtract Wfrom f = . W = C, Subtract Wfrom f = . W = C,",
    "PIC18F6525/6621/8525/8621\nSubtract Wfrom f = . W = C, Subtract Wfrom f = . REG =, Subtract Wfrom f = ?. REG =, Subtract Wfrom f = ?. REG =, Subtract Wfrom f = . REG =, Subtract Wfrom f = . REG =, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = FFh. After Instruction, Subtract Wfrom f = FFh. After Instruction, Subtract Wfrom f = complement). After Instruction, Subtract Wfrom f = complement). After Instruction, Subtract Wfrom f = . W C, Subtract Wfrom f = = 2 0. W C, Subtract Wfrom f = = 2 0. W C, Subtract Wfrom f = ;(2's. W C, Subtract Wfrom f = ;(2's. W C, Subtract Wfrom f = . Z, Subtract Wfrom f = = =.",
    "PIC18F6525/6621/8525/8621\nZ, Subtract Wfrom f = = =. Z, Subtract Wfrom f = . Z, Subtract Wfrom f = . Z, Subtract Wfrom f = . N, Subtract Wfrom f = 0 = 1. N, Subtract Wfrom f = 0 = 1. N, Subtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = ",
    "Subtract W from f with Borrow\nSyntax:\n[ label ]\nSUBWFB    f [,d [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n(f) - (W) - (C) \uf0ae\uf020 dest\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0101\n10da\nffff\nffff\nDescription:\nSubtract W and the Carry flag (borrow) from register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:",
    "Subtract W from f with Borrow\nExample 1: SUBWFB, Q2.Read register 'f' = Example 1: SUBWFB. Example 1: SUBWFB, Q3. = . Example 1: SUBWFB, Process.Data = REG, 1,. Example 1: SUBWFB, Q4 Write.to destination = 0. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3. = . Before Instruction, Process.Data = . Before Instruction, Q4 Write.to destination = . REG, Q2.Read register 'f' = =. REG, Q3. = 0x19. REG, Process.Data = (0001. REG, Q4 Write.to destination = 1001). W, Q2.Read register 'f' = =. W, Q3. = 0x0D. W, Process.Data = (0000. W, Q4 Write.to destination = 1101). C, Q2.Read register 'f' = =. C, Q3. = 1. C, Process.Data = . C, Q4 Write.to destination = . After Instruction, Q2.Read register",
    "Subtract W from f with Borrow\n'f' = After Instruction. After Instruction, Q3. = . After Instruction, Process.Data = . After Instruction, Q4 Write.to destination = . REG, Q2.Read register 'f' = =. REG, Q3. = 0x0C. REG, Process.Data = (0000. REG, Q4 Write.to destination = 1011). W, Q2.Read register 'f' = =. W, Q3. = 0x0D. W, Process.Data = (0000. W, Q4 Write.to destination = 1101). C, Q2.Read register 'f' = =. C, Q3. = 1. C, Process.Data = . C, Q4 Write.to destination = . Z, Q2.Read register 'f' = =. Z, Q3. = 0. Z, Process.Data = . Z, Q4 Write.to destination = . N, Q2.Read register 'f' = =. N, Q3. = 0. N, Process.Data = ; result is. N, Q4 Write.to destination = positive. Example",
    "Subtract W from f with Borrow\n2:, Q2.Read register 'f' = . Example 2:, Q3. = SUBWFB. Example 2:, Process.Data = REG, 0,. Example 2:, Q4 Write.to destination = . Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3. = . Before Instruction, Process.Data = . Before Instruction, Q4 Write.to destination = . REG, Q2.Read register 'f' = =. REG, Q3. = 0x1B. REG, Process.Data = (0001. REG, Q4 Write.to destination = 1011). W, Q2.Read register 'f' = =. W, Q3. = 0x1A. W, Process.Data = (0001 1010). W, Q4 Write.to destination = . C, Q2.Read register 'f' = =. C, Q3. = 0. C, Process.Data = . C, Q4 Write.to destination = . After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3. = . After",
    "Subtract W from f with Borrow\nInstruction, Process.Data = . After Instruction, Q4 Write.to destination = . REG, Q2.Read register 'f' = =. REG, Q3. = 0x1B. REG, Process.Data = (0001 1011). REG, Q4 Write.to destination = . W, Q2.Read register 'f' = =. W, Q3. = 0x00. W, Process.Data = . W, Q4 Write.to destination = . C, Q2.Read register 'f' = =. C, Q3. = 1. C, Process.Data = . C, Q4 Write.to destination = . Z, Q2.Read register 'f' = =. Z, Q3. = 1. Z, Process.Data = ; result is zero. Z, Q4 Write.to destination = . N, Q2.Read register 'f' = =. N, Q3. = 0. N, Process.Data = . N, Q4 Write.to destination = . Example 3:, Q2.Read register 'f' = . Example 3:, Q3. =",
    "Subtract W from f with Borrow\nSUBWFB. Example 3:, Process.Data = REG, 1,. Example 3:, Q4 Write.to destination = 0. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3. = . Before Instruction, Process.Data = . Before Instruction, Q4 Write.to destination = . REG, Q2.Read register 'f' = =. REG, Q3. = 0x03. REG, Process.Data = (0000. REG, Q4 Write.to destination = 0011). W, Q2.Read register 'f' = =. W, Q3. = 0x0E. W, Process.Data = (0000 1101). W, Q4 Write.to destination = . C, Q2.Read register 'f' = =. C, Q3. = 1. C, Process.Data = . C, Q4 Write.to destination = . After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3. = . After Instruction, Process.Data = . After Instruction, Q4 Write.to destination = . REG,",
    "Subtract W from f with Borrow\nQ2.Read register 'f' = =. REG, Q3. = 0xF5. REG, Process.Data = (1111 0100). REG, Q4 Write.to destination = . , Q2.Read register 'f' = . , Q3. = . , Process.Data = ; [2's comp]. , Q4 Write.to destination = . W, Q2.Read register 'f' = =. W, Q3. = 0x0E. W, Process.Data = (0000 1101). W, Q4 Write.to destination = . C, Q2.Read register 'f' = =. C, Q3. = 0. C, Process.Data = . C, Q4 Write.to destination = . Z, Q2.Read register 'f' = =. Z, Q3. = 0. Z, Process.Data = . Z, Q4 Write.to destination = . N, Q2.Read register 'f' = =. N, Q3. = 1. N, Process.Data = ; result is. N, Q4 Write.to destination =",
    "Subtract W from f with Borrow\nnegative\nSyntax:, Swap f = [ label ]. Syntax:, Swap f = SWAPF. Syntax:, Swap f = f [,d [,a]. Syntax:, Swap f = . Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>; (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>; (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>; (f<7:4>) \uf0ae dest<3:0>.",
    "Subtract W from f with Borrow\nOperation:, Swap f = (f<3:0>) \uf0ae dest<7:4>; (f<7:4>) \uf0ae dest<3:0>. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Encoding:, Swap f = 0011. Encoding:, Swap f = 10da. Encoding:, Swap f = ffff. Encoding:, Swap f = ffff\nDescription:\nThe upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:",
    "Subtract W from f with Borrow\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "Example:\nSWAPF\nREG, 1, 0\nBefore Instruction\nREG\n=\n0x53\nAfter Instruction\nREG\n=\n0x35",
    "PIC18F6525/6621/8525/8621\nTBLRD, 1 = TBLRD. TBLRD, 2 = Table Read. TBLRD, 3 = Table Read. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, 3 = [ label ] TBLRD ( *; *+; *-; +*). Operands:, 1 = Operands:. Operands:, 2 = None. Operands:, 3 = None. Operation:, 1 = Operation:. Operation:, 2 = if TBLRD* (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change if TBLRD*+ (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR if TBLRD*- (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR if TBLRD+* (TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT. Operation:,",
    "PIC18F6525/6621/8525/8621\n3 = if TBLRD* (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change if TBLRD*+ (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR if TBLRD*- (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR if TBLRD+* (TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Description:, 1 = Description:. Description:, 2 = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has",
    "PIC18F6525/6621/8525/8621\na 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement \u2022 pre-increment. Description:, 3 = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement \u2022 pre-increment. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 =",
    "PIC18F6525/6621/8525/8621\n1. Cycles:, 1 = Cycles:. Cycles:, 2 = 2. Cycles:, 3 = 2. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 1 = Decode. , 2 = No operation. , 3 = No operation. , 1 = No operation. , 2 = No operation (Read Program Memory). , 3 = No operation",
    "Table Read (Continued)\nExample 1:, 1 = TBLRD *+. Example 1:, 2 = ;. Example 1:, 3 = . Before Instruction, 1 = Before Instruction. Before Instruction, 2 = =. Before Instruction, 3 = 0x55. TABLAT TBLPTR, 1 = TABLAT TBLPTR. TABLAT TBLPTR, 2 = =. TABLAT TBLPTR, 3 = 0x00A356. MEMORY(0x00A356), 1 = MEMORY(0x00A356). MEMORY(0x00A356), 2 = =. MEMORY(0x00A356), 3 = 0x34. After Instruction TABLAT, 1 = After Instruction TABLAT. After Instruction TABLAT, 2 = =. After Instruction TABLAT, 3 = 0x34. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 0x00A357. Example 2:, 1 = TBLRD +*. Example 2:, 2 = ;. Example 2:, 3 = . Before Instruction TABLAT, 1 = Before Instruction TABLAT. Before Instruction TABLAT, 2 =",
    "Table Read (Continued)\n=. Before Instruction TABLAT, 3 = 0xAA. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 0x01A357. MEMORY(0x01A357), 1 = MEMORY(0x01A357). MEMORY(0x01A357), 2 = = =. MEMORY(0x01A357), 3 = 0x12 0x34. MEMORY(0x01A358) After Instruction, 1 = MEMORY(0x01A358) After Instruction. MEMORY(0x01A358) After Instruction, 2 = =. MEMORY(0x01A358) After Instruction, 3 = 0x34. TABLAT, 1 = TABLAT. TABLAT, 2 = =. TABLAT, 3 = 0x01A358. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = . TBLPTR, 3 = ",
    "Table Write\nSyntax:\nOperands:\nOperation:\nStatus Affected: Encoding:\nDescription:\n[\nlabel\n]\nTBLWT ( *; *+; *-; +*)\nNone if TBLWT*\nTBLPTR - No Change\n(TABLAT)\n\uf0ae\nHolding Register;\nif TBLWT*+\n(TBLPTR) + 1\n(TABLAT)\n\uf0ae\nHolding Register;\n\uf0ae\nTBLPTR\nif TBLWT*-\n(TBLPTR) - 1\n(TABLAT)\n\uf0ae\nHolding Register;\n\uf0ae\nif TBLWT+*\n(TABLAT)\nTBLPTR\n(TBLPTR) + 1\n\uf0ae\nTBLPTR;\n\uf0ae\nHolding Register\nNone\n0000, 1 = 0000. 0000, 2 = 0000. 0000, 3 = 11nn. , 1 = . , 2 = . , 3 = nn=0 *. , 1 = . , 2 = . , 3 = =1 *+. , 1 = . , 2 = . , 3 = =2 *-. , 1 = . , 2 = . , 3 = =3 +*",
    "Table Write\nThis instruction uses the 3 LSBs of TBLPTR to determine which of the 8 holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to Section 5.0 'Flash Program Memory' for additional details on programming Flash memory.)\nThe TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MByte address range. The LSB of the TBLPTR selects which byte of the program memory location to access.\nTBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of\nProgram Memory Word",
    "Table Write\nWords:, Table Write (Continued) = 1. Words:, Table Write (Continued) = 1. Words:, Table Write (Continued) = 1. Words:, Table Write (Continued) = 1. Cycles:, Table Write (Continued) = 2. Cycles:, Table Write (Continued) = 2. Cycles:, Table Write (Continued) = 2. Cycles:, Table Write (Continued) = 2. Q Cycle Activity:, Table Write (Continued) = Q Cycle Activity:. Q Cycle Activity:, Table Write (Continued) = Q Cycle Activity:. Q Cycle Activity:, Table Write (Continued) = Q Cycle Activity:. Q Cycle Activity:, Table Write (Continued) = Q Cycle Activity:. , Table Write (Continued) = Q1. , Table Write (Continued) = Q2. , Table Write (Continued) = Q3. , Table Write (Continued) = Q4. , Table Write (Continued) = Decode. , Table Write (Continued) = No operation. , Table Write (Continued) = No operation. , Table Write (Continued) = No operation. , Table Write (Continued) = No operation. , Table Write (Continued) = No operation (Read",
    "Table Write\nTABLAT). , Table Write (Continued) = No operation. , Table Write (Continued) = No operation (Write to Holding Register ). Example 1:, Table Write (Continued) = Example 1:. Example 1:, Table Write (Continued) = TBLWT *+;. Example 1:, Table Write (Continued) = TBLWT *+;. Example 1:, Table Write (Continued) = TBLWT *+;. Before Instruction, Table Write (Continued) = Before Instruction. Before Instruction, Table Write (Continued) = Before Instruction. Before Instruction, Table Write (Continued) = Before Instruction. Before Instruction, Table Write (Continued) = Before Instruction. , Table Write (Continued) = TABLAT. , Table Write (Continued) = TABLAT. , Table Write (Continued) = 0x55. , Table Write (Continued) = 0x55. , Table Write (Continued) = TBLPTR. , Table Write (Continued) = TBLPTR. , Table Write (Continued) = 0x00A356. , Table Write (Continued) = 0x00A356. , Table Write (Continued) = HOLDING REGISTER (0x00A356). ,",
    "Table Write\nTable Write (Continued) = HOLDING REGISTER (0x00A356). , Table Write (Continued) = 0xFF. , Table Write (Continued) = 0xFF. After Instructions (table write completion) =, Table Write (Continued) = After Instructions (table write completion) =. After Instructions (table write completion) =, Table Write (Continued) = After Instructions (table write completion) =. After Instructions (table write completion) =, Table Write (Continued) = After Instructions (table write completion) =. After Instructions (table write completion) =, Table Write (Continued) = After Instructions (table write completion) =. , Table Write (Continued) = TABLAT. , Table Write (Continued) = TABLAT. , Table Write (Continued) = 0x55. , Table Write (Continued) = 0x55. , Table Write (Continued) = TBLPTR. , Table Write (Continued) = TBLPTR. , Table Write (Continued) = 0x00A357. , Table Write (Continued) = 0x00A357. , Table Write (Continued) = HOLDING REGISTER (0x00A356). , Table Write (Continued) = HOLDING REGISTER",
    "Table Write\n(0x00A356). , Table Write (Continued) = 0x55. , Table Write (Continued) = 0x55. Example 2:, Table Write (Continued) = Example 2:. Example 2:, Table Write (Continued) = TBLWT +*;. Example 2:, Table Write (Continued) = TBLWT +*;. Example 2:, Table Write (Continued) = TBLWT +*;. Before Instruction, Table Write (Continued) = Before Instruction. Before Instruction, Table Write (Continued) = Before Instruction. Before Instruction, Table Write (Continued) = Before Instruction. Before Instruction, Table Write (Continued) = Before Instruction. , Table Write (Continued) = TABLAT. , Table Write (Continued) = TABLAT. , Table Write (Continued) = 0x34. , Table Write (Continued) = 0x34. , Table Write (Continued) = TBLPTR. , Table Write (Continued) = TBLPTR. , Table Write (Continued) = 0x01389A. , Table Write (Continued) = 0x01389A. , Table Write (Continued) = HOLDING REGISTER (0x01389A).",
    "Table Write\n, Table Write (Continued) = HOLDING REGISTER (0x01389A). , Table Write (Continued) = 0xFF. , Table Write (Continued) = 0xFF. , Table Write (Continued) = HOLDING REGISTER (0x01389B). , Table Write (Continued) = HOLDING REGISTER (0x01389B). , Table Write (Continued) = 0xFF. , Table Write (Continued) = 0xFF. After Instruction (table write completion), Table Write (Continued) = After Instruction (table write completion). After Instruction (table write completion), Table Write (Continued) = After Instruction (table write completion). After Instruction (table write completion), Table Write (Continued) = After Instruction (table write completion). After Instruction (table write completion), Table Write (Continued) = After Instruction (table write completion). , Table Write (Continued) = TABLAT. , Table Write (Continued) = TABLAT. , Table Write (Continued) = 0x34. , Table Write (Continued) = 0x34. , Table Write (Continued) = TBLPTR. , Table Write (Continued) = TBLPTR. , Table Write",
    "Table Write\n(Continued) = 0x01389B. , Table Write (Continued) = 0x01389B. , Table Write (Continued) = HOLDING REGISTER (0x01389A). , Table Write (Continued) = HOLDING REGISTER (0x01389A). , Table Write (Continued) = 0xFF. , Table Write (Continued) = 0xFF. , Table Write (Continued) = HOLDING REGISTER (0x01389B). , Table Write (Continued) = HOLDING REGISTER (0x01389B). , Table Write (Continued) = 0x34. , Table Write (Continued) = 0x34\nThe TBLWT instruction can modify the value of TBLPTR as follows:\n\u00b7 no change\n\u00b7 post-increment\n\u00b7 post-decrement\n\u00b7 pre-increment\nQ2\nQ3\nQ4\nRead register 'f'\nProcess\nData\nNo operation",
    "If skip:\nNo operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nHERE    TSTFSZ  CNT, 1\nNZERO   :\nZERO    :",
    "Before Instruction\nPC =, 1 = Address (HERE). After Instruction, 1 = After Instruction. If CNT =, 1 = 0x00,. PC =, 1 = Address (ZERO). If CNT \uf0b9, 1 = 0x00,. PC =, 1 = Address (NZERO)\nQ4",
    "PIC18F6525/6621/8525/8621\nSyntax:, Test f, Skip if 0 = [ label ]. Syntax:, Test f, Skip if 0 = TSTFSZ. Syntax:, Test f, Skip if 0 = f [,a]. Syntax:, Test f, Skip if 0 = . Operands:, Test f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = skip if f = 0. Status Affected:, Test f, Skip if 0 = None. Status Affected:, Test f, Skip if 0 = None. Status Affected:, Test f, Skip if 0 = None.",
    "PIC18F6525/6621/8525/8621\nStatus Affected:, Test f, Skip if 0 = None. Encoding:, Test f, Skip if 0 = 0110. Encoding:, Test f, Skip if 0 = 011a. Encoding:, Test f, Skip if 0 = ffff. Encoding:, Test f, Skip if 0 = ffff. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Description:, Test",
    "PIC18F6525/6621/8525/8621\nf, Skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = 1. Cycles:, Test f, Skip if 0 = 1(2). Cycles:, Test f, Skip if 0 =",
    "PIC18F6525/6621/8525/8621\n1(2). Cycles:, Test f, Skip if 0 = 1(2). Cycles:, Test f, Skip if 0 = 1(2)",
    "PIC18F6525/6621/8525/8621\nSyntax:, Exclusive OR Literal with W = [ label ] XORLW. Syntax:, Exclusive OR Literal with W = [ label ] XORLW. Syntax:, Exclusive OR Literal with W = k. Syntax:, Exclusive OR Literal with W = k. Operands:, Exclusive OR Literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR Literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR Literal with W = . Operands:, Exclusive OR Literal with W = . Operation:, Exclusive OR Literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR Literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR Literal with W = . Operation:, Exclusive OR Literal with W = . Status Affected:, Exclusive OR Literal with W = N, Z. Status Affected:, Exclusive OR Literal with W = N, Z. Status Affected:, Exclusive OR Literal with W = . Status Affected:, Exclusive OR Literal with W = . Encoding:, Exclusive OR Literal with W = 0000. Encoding:, Exclusive OR Literal with W = 1010. Encoding:, Exclusive",
    "PIC18F6525/6621/8525/8621\nOR Literal with W = kkkk. Encoding:, Exclusive OR Literal with W = kkkk. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Words:, Exclusive OR Literal with W = 1. Words:, Exclusive OR Literal with W = . Words:, Exclusive OR Literal with W = . Words:, Exclusive OR Literal with W = . Cycles:, Exclusive OR Literal with W = 1. Cycles:, Exclusive OR Literal with W = . Cycles:, Exclusive OR Literal with W = . Cycles:, Exclusive OR Literal with W = . Q Cycle Activity:",
    "PIC18F6525/6621/8525/8621\nQ1, Exclusive OR Literal with W = Q2. Q Cycle Activity: Q1, Exclusive OR Literal with W = Q3. Q Cycle Activity: Q1, Exclusive OR Literal with W = . Q Cycle Activity: Q1, Exclusive OR Literal with W = Q4. Decode, Exclusive OR Literal with W = Read literal 'k'. Decode, Exclusive OR Literal with W = Process Data. Decode, Exclusive OR Literal with W = . Decode, Exclusive OR Literal with W = Write to W\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode",
    "Example:\nXORLW\n0xAF\nBefore Instruction\nW\n=\n0xB5\nAfter Instruction\nW = 0x1A",
    "PIC18F6525/6621/8525/8621\nSyntax:, Exclusive OR Wwith f = [ label ]. Syntax:, Exclusive OR Wwith f = XORWF. Syntax:, Exclusive OR Wwith f = f [,d. Syntax:, Exclusive OR Wwith f = [,a]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR.",
    "PIC18F6525/6621/8525/8621\n(f) \uf0ae\uf020 dest. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Encoding:, Exclusive OR Wwith f = 0001. Encoding:, Exclusive OR Wwith f = 10da. Encoding:, Exclusive OR Wwith f = ffff. Encoding:, Exclusive OR Wwith f = ffff. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If",
    "PIC18F6525/6621/8525/8621\n'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1",
    "PIC18F6525/6621/8525/8621\n', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Exclusive OR Wwith f = . Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = . Words:, Exclusive OR Wwith f = . Cycles:, Exclusive OR Wwith f = . Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = . Cycles:, Exclusive OR Wwith f = . Q Cycle Activity:, Exclusive OR Wwith f = . Q Cycle Activity:, Exclusive OR Wwith f = . Q Cycle Activity:, Exclusive OR Wwith f = . Q Cycle Activity:, Exclusive OR Wwith f = . Q1, Exclusive OR Wwith f = Q2. Q1, Exclusive OR Wwith f = Q3. Q1, Exclusive OR Wwith f = . Q1, Exclusive OR Wwith f = Q4.",
    "PIC18F6525/6621/8525/8621\nDecode, Exclusive OR Wwith f = . Decode, Exclusive OR Wwith f = Read register 'f'. Decode, Exclusive OR Wwith f = Process Data. Decode, Exclusive OR Wwith f = Write to destination. Example: XORWF, Exclusive OR Wwith f = Example: XORWF. Example: XORWF, Exclusive OR Wwith f = REG,. Example: XORWF, Exclusive OR Wwith f = 1, 0. Example: XORWF, Exclusive OR Wwith f = . Before Instruction, Exclusive OR Wwith f = Before Instruction. Before Instruction, Exclusive OR Wwith f = . Before Instruction, Exclusive OR Wwith f = . Before Instruction, Exclusive OR Wwith f = . REG W, Exclusive OR Wwith f = = =. REG W, Exclusive OR Wwith f = 0xAF 0xB5. REG W, Exclusive OR Wwith f = . REG W, Exclusive OR Wwith f = . After Instruction, Exclusive OR Wwith f = After Instruction. After Instruction, Exclusive OR Wwith f = . After Instruction, Exclusive OR Wwith f = . After",
    "PIC18F6525/6621/8525/8621\nInstruction, Exclusive OR Wwith f = . , Exclusive OR Wwith f = REG. , Exclusive OR Wwith f = . , Exclusive OR Wwith f = . , Exclusive OR Wwith f = . , Exclusive OR Wwith f = . , Exclusive OR Wwith f = 0x1A. , Exclusive OR Wwith f = . , Exclusive OR Wwith f = . W, Exclusive OR Wwith f = = =. W, Exclusive OR Wwith f = 0xB5. W, Exclusive OR Wwith f = . W, Exclusive OR Wwith f = ",
    "26.0 DEVELOPMENT SUPPORT\nThe  PIC \u00ae   microcontrollers  are  supported  with  a  full range of hardware and software development tools:",
    "26.1 MPLAB Integrated Development Environment Software\n\u00b7 Integrated Development Environment\n-MPLAB \u00ae  IDE Software\n\u00b7 Assemblers/Compilers/Linkers\n-MPASM TM  Assembler\n-MPLAB C17 and MPLAB C18 C Compilers\n-MPLINK TM  Object Linker/ MPLIB TM  Object Librarian\n-MPLAB C30 C Compiler\n-MPLAB ASM30 Assembler/Linker/Library\n\u00b7 Simulators\n-MPLAB SIM Software Simulator\n-MPLAB dsPIC30 Software Simulator\n\u00b7 Emulators\n-MPLAB ICE 2000 In-Circuit Emulator\n-MPLAB ICE 4000 In-Circuit Emulator\n\u00b7 In-Circuit Debugger\n-MPLAB ICD 2\n\u00b7 Device Programmers\n-PRO MATE \u00ae  II Universal Device Programmer\n-PICSTART \u00ae  Plus Development Programmer\n-MPLAB PM3 Device Programmer\n\u00b7 Low-Cost Demonstration Boards\n-PICDEM TM  1 Demonstration Board\n-PICDEM.net TM  Demonstration Board\n-PICDEM 2 Plus Demonstration Board\n-PICDEM 3 Demonstration Board\n-PICDEM 4 Demonstration Board\n-PICDEM 17 Demonstration Board\n-PICDEM 18R Demonstration Board\n-PICDEM LIN Demonstration Board\n-PICDEM USB Demonstration Board\n\u00b7 Evaluation Kits\n-KEELOQ \u00ae  Evaluation and Programming Tools",
    "26.1 MPLAB Integrated Development Environment Software\n-PICDEM MSC\n-microID \u00ae  Developer Kits\n-CAN\n-PowerSmart \u00ae  Developer Kits\n-Analog\nThe MPLAB IDE software brings an ease of software development previously unseen in the 8/16-bit microcontroller  market.  The  MPLAB  IDE  is  a  Windows \u00ae based application that contains:\n\u00b7 An interface to debugging tools\n-simulator\n-programmer (sold separately)\n-emulator (sold separately)\n-in-circuit debugger (sold separately)\n\u00b7 A full-featured editor with color coded context\n\u00b7 A multiple project manager\n\u00b7 Customizable data windows with direct edit of contents\n\u00b7 High-level source code debugging\n\u00b7 Mouse over variable inspection\n\u00b7 Extensive on-line help\nThe MPLAB IDE allows you to:\n\u00b7 Edit your source files (either assembly or C)\n\u00b7 One touch assemble (or compile) and download to PIC emulator and simulator tools (automatically updates all project information)\n\u00b7 Debug using:\n-source files (assembly or C)\n-mixed assembly and C\n-machine code",
    "26.1 MPLAB Integrated Development Environment Software\nMPLAB  IDE  supports  multiple  debugging  tools  in  a single development paradigm, from the cost effective simulators,  through  low-cost  in-circuit  debuggers,  to full-featured  emulators.  This  eliminates  the  learning curve when upgrading to tools with increasing flexibility and power.",
    "26.2 MPASM Assembler\nThe  MPASM  assembler  is  a  full-featured,  universal macro assembler for all PIC MCUs.\nThe MPASM assembler generates relocatable object files for the MPLINK object linker, Intel \u00ae standard HEX files, MAP files to detail memory usage and symbol reference, absolute LST files that contain source lines and generated machine code and COFF files for debugging.\nThe MPASM assembler features include:\n\u00b7 Integration into MPLAB IDE projects\n\u00b7 User defined macros to streamline assembly code\n\u00b7 Conditional assembly for multi-purpose source files\n\u00b7 Directives that allow complete control over the assembly process",
    "26.6 MPLAB ASM30 Assembler, Linker and Librarian\nThe MPLAB C17 and MPLAB C18 Code Development Systems are complete ANSI C compilers for Microchip's  PIC17CXXX  and  PIC18CXXX  family  of microcontrollers.  These  compilers  provide  powerful integration capabilities, superior code optimization and ease of use not found with other compilers.\nFor easy source level debugging, the compilers provide symbol information that is optimized to the MPLAB IDE debugger.",
    "26.4 MPLINK Object Linker/ MPLIB Object Librarian\nThe MPLINK object linker combines relocatable objects  created  by  the  MPASM  assembler  and  the MPLAB C17 and MPLAB C18 C compilers. It can link relocatable  objects  from  precompiled  libraries,  using directives from a linker script.\nThe MPLIB object librarian manages the creation and modification of library files of precompiled code. When a routine from a library is called from a source file, only the modules that contain that routine will be linked in with  the  application.  This  allows  large  libraries  to  be used efficiently in many different applications.\nThe object linker/library features include:\n\u00b7 Efficient linking of single libraries instead of many smaller files\n\u00b7 Enhanced code maintainability by grouping related modules together\n\u00b7 Flexible creation of libraries with easy module listing, replacement, deletion and extraction",
    "26.5 MPLAB C30 C Compiler\nThe MPLAB C30 C compiler is a full-featured, ANSI compliant, optimizing compiler that translates standard ANSI C programs into dsPIC30F assembly language source.  The  compiler  also  supports  many  command line options  and  language  extensions  to  take  full advantage of the dsPIC30F device hardware capabilities and  afford  fine control of the  compiler  code generator.\nMPLAB  C30  is  distributed  with  a  complete  ANSI  C standard  library.  All  library  functions  have  been  validated and conform to the ANSI C library standard. The library includes functions for string manipulation, dynamic  memory  allocation,  data  conversion,  timekeeping and math functions (trigonometric, exponential and hyperbolic). The compiler provides symbolic information  for  high-level  source  debugging  with  the MPLAB IDE.\nMPLAB ASM30 assembler produces relocatable machine  code  from  symbolic  assembly  language  for dsPIC30F  devices.  MPLAB  C30  compiler  uses  the assembler  to  produce  it's  object  file.  The  assembler generates  relocatable  object  files  that  can  then  be archived or linked with other relocatable object files and archives to create an executable file. Notable features of the assembler include:",
    "26.5 MPLAB C30 C Compiler\n\u00b7 Support for the entire dsPIC30F instruction set\n\u00b7 Support for fixed-point and floating-point data\n\u00b7 Command line interface\n\u00b7 Rich directive set\n\u00b7 Flexible macro language\n\u00b7 MPLAB IDE compatibility",
    "26.7 MPLAB SIM Software Simulator\nThe MPLAB SIM software simulator allows code development in a PC hosted environment by simulating the PIC series microcontrollers on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a file, or user defined key press, to any pin. The execution can be  performed  in  Single-Step,  Execute  Until  Break  or Trace mode.\nThe  MPLAB  SIM  simulator  fully  supports  symbolic debugging  using  the  MPLAB  C17  and  MPLAB  C18 C Compilers, as well as the MPASM assembler. The software simulator offers the flexibility to develop and debug  code  outside  of  the  laboratory  environment, making it an excellent, economical software development tool.",
    "26.8 MPLAB SIM30 Software Simulator\nThe  MPLAB  SIM30  software  simulator  allows  code development in a PC hosted environment by simulating the dsPIC30F series microcontrollers on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a file, or user defined key press, to any of the pins.\nThe MPLAB SIM30 simulator fully supports symbolic debugging  using  the  MPLAB  C30  C  Compiler  and MPLAB ASM30 assembler. The simulator runs in either a Command Line mode for automated tasks, or from MPLAB IDE. This high-speed simulator is designed to debug,  analyze  and  optimize  time  intensive  DSP routines.",
    "26.9 MPLAB ICE 2000 High-Performance Universal In-Circuit Emulator\nThe MPLAB ICE 2000 universal in-circuit emulator is intended to provide the product development engineer with a complete microcontroller design tool set for PIC microcontrollers. Software control of the MPLAB ICE 2000  in-circuit  emulator  is  advanced  by  the  MPLAB Integrated  Development  Environment,  which  allows editing,  building,  downloading and  source  debugging from a single environment.\nThe MPLAB ICE 2000 is a full-featured emulator system with enhanced trace, trigger and data monitoring features. Interchangeable processor modules allow the system to be easily reconfigured for emulation of different processors.  The  universal  architecture of the MPLAB  ICE  in-circuit  emulator  allows  expansion  to support new PIC microcontrollers.\nThe MPLAB ICE 2000 in-circuit emulator system has been designed as a real-time emulation system with advanced  features  that  are  typically  found  on  more expensive  development  tools.  The  PC  platform  and Microsoft \u00ae Windows  32-bit  operating  system  were chosen  to  best  make  these  features  available  in  a simple, unified application.",
    "26.10 MPLAB ICE 4000 High-Performance Universal In-Circuit Emulator\nThe MPLAB ICE 4000 universal in-circuit emulator is intended to provide the product development engineer with a complete microcontroller design tool set for highend  PIC  microcontrollers.  Software  control  of  the MPLAB  ICE  in-circuit  emulator  is  provided  by  the MPLAB Integrated Development Environment, which allows editing, building, downloading and source debugging from a single environment.\nThe MPLAB ICD 4000 is a premium emulator system, providing  the  features  of  MPLAB ICE  2000,  but  with increased  emulation  memory  and  high-speed  performance  for  dsPIC30F  and  PIC18XXXX  devices.  Its advanced emulator features include complex triggering and timing, up to 2 Mb of emulation memory and the ability to view variables in real-time.\nThe MPLAB ICE 4000 in-circuit emulator system has been designed as a real-time emulation system with advanced  features  that  are  typically  found  on  more expensive  development  tools.  The  PC  platform  and Microsoft Windows  32-bit operating system were chosen  to  best  make  these  features  available  in  a simple, unified application.",
    "26.11 MPLAB ICD 2 In-Circuit Debugger\nMicrochip's  In-Circuit  Debugger,  MPLAB  ICD  2,  is  a powerful, low-cost, run-time development tool, connecting to the host PC via an RS-232 or high-speed USB  interface.  This  tool  is  based  on  the  Flash  PIC MCUs and can be used to develop for these and other PIC microcontrollers. The MPLAB ICD 2 utilizes the incircuit debugging capability built into the Flash devices. This  feature,  along  with  Microchip's  In-Circuit  Serial Programming TM  (ICSP TM ) protocol, offers cost effective in-circuit Flash debugging from the graphical user interface of the MPLAB Integrated Development Environment. This enables a designer to develop and debug  source  code  by  setting  breakpoints,  singlestepping  and  watching  variables,  CPU  status  and peripheral registers. Running at full speed enables testing  hardware  and  applications  in  real-time.  MPLAB ICD 2 also serves as a development programmer for selected PIC devices.",
    "26.12 PRO MATE II Universal Device Programmer\nThe PRO MATE II is a universal, CE compliant device programmer with programmable voltage verification at VDDMIN and VDDMAX for maximum reliability. It features an  LCD  display  for  instructions  and  error  messages and a modular detachable socket assembly to support various  package  types.  In  Stand-Alone  mode,  the PRO MATE II device programmer can read, verify and program PIC devices without a PC connection. It can also set code protection in this mode.",
    "26.13 MPLAB PM3 Device Programmer\nThe MPLAB PM3 is a universal, CE compliant device programmer with programmable voltage verification at VDDMIN and VDDMAX for maximum reliability. It features a large  LCD display  (128  x  64)  for  menus  and  error messages and a modular detachable socket assembly to  support various package types. The ICSP\u2122 cable assembly  is  included  as  a  standard  item.  In  StandAlone mode, the MPLAB PM3 device programmer can read,  verify  and  program  PIC  devices  without  a  PC connection. It can also set code protection in this mode. MPLAB PM3 connects to the host PC via an RS-232 or USB cable. MPLAB PM3 has high-speed communications and optimized algorithms for quick programming of large memory devices and incorporates an SD/MMC card for file storage and secure data applications.",
    "26.14 PICSTART Plus Development Programmer\nThe PICSTART Plus development programmer is an easy-to-use,  low-cost,  prototype  programmer.  It  connects  to  the  PC  via  a  COM  (RS-232)  port.  MPLAB Integrated Development Environment software makes using the programmer simple and efficient. The PICSTART  Plus  development  programmer  supports most  PIC  devices  up  to  40  pins.  Larger  pin  count devices,  such  as  the  PIC16C92X  and  PIC17C76X, may  be  supported with an adapter socket. The PICSTART  Plus  development  programmer  is CE compliant.",
    "26.15 PICDEM 1 PIC MCU Demonstration Board\nThe PICDEM 1 demonstration board demonstrates the capabilities of the PIC16C5X (PIC16C54 to PIC16C58A), PIC16C61, PIC16C62X, PIC16C71, PIC16C8X, PIC17C42, PIC17C43 and PIC17C44. All necessary  hardware  and  software  is  included  to  run basic  demo  programs.  The  sample  microcontrollers provided with the PICDEM 1 demonstration board can be programmed with a PRO MATE II device programmer or  a  PICSTART  Plus  development  programmer. The PICDEM 1 demonstration board can be connected to  the  MPLAB  ICE  in-circuit  emulator  for  testing.  A prototype area extends the circuitry for additional application components. Features include an RS-232 interface, a potentiometer for simulated analog input, push button switches and eight LEDs.",
    "26.16 PICDEM.net Internet/Ethernet Demonstration Board\nThe PICDEM.net demonstration board is an Internet/ Ethernet  demonstration  board  using  the  PIC18F452 microcontroller and TCP/IP firmware. The board supports any 40-pin DIP device that conforms to the standard pinout used by the PIC16F877 or PIC18C452. This kit  features  a  user  friendly  TCP/IP stack, web  server with HTML,  a 24L256  Serial EEPROM for  Xmodem  download  to  web  pages  into Serial  EEPROM,  ICSP/MPLAB  ICD  2  interface  connector, an Ethernet interface, RS-232 interface and a 16  x  2  LCD  display.  Also  included  is  the  book  and CD-ROM 'TCP/IP Lean, Web Servers for Embedded Systems,' by Jeremy Bentham",
    "26.17 PICDEM 2 Plus Demonstration Board\nThe  PICDEM  2  Plus  demonstration  board  supports many  18,  28  and  40-pin  microcontrollers,  including PIC16F87X and  PIC18FXX2 devices.  All  the  necessary hardware and software is included to run the demonstration programs. The sample  microcontrollers provided with the PICDEM 2 demonstration board can be programmed with a PRO MATE II device programmer,  PICSTART  Plus  development  programmer,  or MPLAB ICD 2 with a Universal Programmer Adapter. The MPLAB ICD 2 and MPLAB ICE in-circuit emulators may also be used with the PICDEM 2 demonstration board to test firmware. A prototype area extends the circuitry for additional application  components. Some of  the features include an RS-232 interface, a 2 x 16 LCD display, a piezo speaker, an on-board temperature sensor, four LEDs and sample PIC18F452 and PIC16F877 Flash microcontrollers.",
    "26.18 PICDEM 3 PIC16C92X Demonstration Board\nThe  PICDEM  3  demonstration  board  supports  the PIC16C923 and PIC16C924 in the PLCC package. All the necessary hardware and software is included to run the demonstration programs.",
    "26.19 PICDEM 4 8/14/18-Pin Demonstration Board\nThe PICDEM 4 can be used to demonstrate the capabilities of the  8, 14  and  18-pin  PIC16XXXX  and PIC18XXXX  MCUs,  including  the  PIC16F818/819, PIC16F87/88, PIC16F62XA and the PIC18F1320 family  of  microcontrollers.  PICDEM  4  is  intended  to showcase the  many  features  of  these  low  pin  count parts,  including  LIN  and  Motor  Control  using  ECCP. Special provisions are made for low-power operation with the supercapacitor circuit and jumpers allow onboard  hardware  to  be  disabled  to  eliminate  current draw in this mode. Included on the demo board are provisions for Crystal, RC or Canned Oscillator modes, a five volt regulator for use with a nine volt wall adapter or",
    "26.19 PICDEM 4 8/14/18-Pin Demonstration Board\nbattery, DB-9 RS-232 interface, ICD connector for programming via ICSP and development with MPLAB ICD 2, 2 x 16 liquid crystal display, PCB footprints for H-Bridge motor driver, LIN transceiver and EEPROM. Also included are: header for expansion, eight LEDs, four potentiometers, three push buttons and a prototyping area. Included with the kit is a PIC16F627A and a  PIC18F1320.  Tutorial  firmware  is  included  along with the User's Guide.",
    "26.20 PICDEM 17 Demonstration Board\nThe PICDEM 17 demonstration board is an evaluation board  that  demonstrates  the  capabilities  of  several Microchip microcontrollers, including PIC17C752, PIC17C756A,  PIC17C762  and  PIC17C766.  A  programmed sample is included. The PRO MATE II device programmer, or the PICSTART Plus development programmer, can be used to reprogram the device for user tailored  application  development.  The  PICDEM  17 demonstration board supports program download and execution  from  external  on-board  Flash  memory.  A generous prototype area is available for user hardware expansion.",
    "26.21 PICDEM 18R PIC18C601/801 Demonstration Board\nThe PICDEM 18R demonstration board serves to assist development of the PIC18C601/801 family of Microchip microcontrollers. It  provides  hardware implementation of both 8-bit Multiplexed/Demultiplexed and  16-bit Memory  modes.  The  board  includes  2  Mb  external Flash memory and 128 Kb SRAM memory, as well as serial EEPROM, allowing access to the wide range of memory types supported by the PIC18C601/801.",
    "26.22 PICDEM LIN PIC16C43X Demonstration Board\nThe powerful LIN hardware and software kit includes a series of boards and three PIC microcontrollers. The small footprint PIC16C432 and PIC16C433 are used as  slaves  in  the  LIN  communication  and  feature  onboard LIN transceivers. A PIC16F874 Flash microcontroller serves as the master. All three microcontrollers  are  programmed  with  firmware  to  provide LIN bus communication.",
    "26.23 PICkit TM 1 Flash Starter Kit\nA complete 'development system in a box', the PICkit\u2122 Flash  Starter  Kit  includes  a  convenient  multi-section board for programming, evaluation and development of 8/14-pin Flash PIC \u00ae  microcontrollers. Powered via USB, the board operates under a simple Windows GUI. The PICkit 1 Starter Kit includes the User's Guide (on CD ROM), PICkit 1  tutorial  software  and  code  for  various applications. Also included are MPLAB \u00ae  IDE (Integrated Development Environment) software, software and hardware 'Tips 'n Tricks for 8-pin Flash PIC \u00ae Microcontrollers' Handbook and a USB interface cable. Supports all current 8/14-pin Flash PIC microcontrollers, as well as many future planned devices.",
    "26.24 PICDEM USB PIC16C7X5 Demonstration Board\nThe PICDEM USB Demonstration Board shows off the capabilities  of  the  PIC16C745  and  PIC16C765  USB microcontrollers.  This  board  provides  the  basis  for future USB products.",
    "26.25 Evaluation and Programming Tools\nIn addition to the PICDEM series of circuits, Microchip has a line of evaluation kits and demonstration software for these products.\n\u00b7 KEELOQ evaluation and programming tools for Microchip's HCS Secure Data Products\n\u00b7 CAN developers kit for automotive network applications\n\u00b7 Analog design boards and filter design software\n\u00b7 PowerSmart battery charging evaluation/ calibration kits\n\u00b7 IrDA \u00ae  development kit\n\u00b7 microID development and rfLab TM  development software\n\u00b7 SEEVAL \u00ae  designer kit for memory evaluation and endurance calculations\n\u00b7 PICDEM MSC demo boards for Switching mode power supply, high-power IR driver, delta sigma ADC and flow rate sensor\nCheck the Microchip web page and the latest Product Selector Guide for the complete list of demonstration and evaluation kits.",
    "PIC18F6525/6621/8525/8621\nNOTES:",
    "27.0 ELECTRICAL CHARACTERISTICS\nAbsolute Maximum Ratings (\u2020)\nAmbient temperature under bias.............................................................................................................-40\u00b0C to +125\u00b0C",
    "27.0 ELECTRICAL CHARACTERISTICS\nStorage temperature .............................................................................................................................. -65\u00b0C to +150\u00b0C\nVoltage on any pin with respect to VSS (except VDD, MCLR and RA4) .......................................... -0.3V to (VDD + 0.3V)",
    "27.0 ELECTRICAL CHARACTERISTICS\nVoltage on VDD with respect to VSS  .........................................................................................................  -0.3V to +5.5V\nVoltage on MCLR with respect to VSS (Note 2)\n......................................................................................... 0V to +13.25V",
    "27.0 ELECTRICAL CHARACTERISTICS\nVoltage on RA4 with respect to VSS............................................................................................................... 0V to +8.5V\nTotal power dissipation (Note 1)",
    "27.0 ELECTRICAL CHARACTERISTICS\n...............................................................................................................................1.0W",
    "27.0 ELECTRICAL CHARACTERISTICS\nMaximum current out of VSS pin ...........................................................................................................................300 mA",
    "27.0 ELECTRICAL CHARACTERISTICS\nMaximum current into VDD pin ..............................................................................................................................250 mA\nInput clamp current, IIK (VI < 0 or VI > VDD)\n\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e \uf0b1\n20 mA\nOutput clamp current, IOK (VO < 0 or VO > VDD)\n\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e \uf0b1\n20 mA",
    "27.0 ELECTRICAL CHARACTERISTICS\nMaximum output current sunk by any I/O pin..........................................................................................................25 mA\nMaximum output current sourced by any I/O pin ....................................................................................................25 mA",
    "27.0 ELECTRICAL CHARACTERISTICS\nMaximum current sunk by all ports .......................................................................................................................200 mA \uf020\nMaximum current sourced by all ports ..................................................................................................................200 mA",
    "27.0 ELECTRICAL CHARACTERISTICS\nNote 1:\n- Power dissipation is calculated as follows:\nPdis = VDD x {IDD -\uf0e5 IOH} + \uf0e5 {(VDD - VOH) x IOH} + \uf0e5 (VOL x IOL)\n- 2: Voltage spikes below VSS at the MCLR/VPP pin, inducing currents greater than 80 mA, may cause latch-up. Thus, a series resistor of 50-100 \uf057 should be used when applying a 'low' level to the MCLR/VPP pin, rather than pulling this pin directly to VSS.\n\u2020 NOTICE: Stresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure to maximum rating conditions for extended periods may affect device reliability.",
    "FIGURE 27-1:\nPIC18F6525/6621/8525/8621 VOLTAGE-FREQUENCY GRAPH (INDUSTRIAL, EXTENDED)",
    "27.1 DC Characteristics: Supply Voltage PIC18F6525/6621/8525/8621 (Industrial, Extended)\nPIC18LF6X2X/8X2X (Industrial)\nPIC18LF6X2X/8X2X\n(Industrial)\nPIC18F6525/6621/8525/8621\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "27.1 DC Characteristics: Supply Voltage PIC18F6525/6621/8525/8621 (Industrial, Extended)\nD001, Symbol = VDD. D001, Characteristic = Supply Voltage. D001, Min = Supply Voltage. D001, Typ = Supply Voltage. D001, Max = Supply Voltage. D001, Units = Supply Voltage. D001, Conditions = Supply Voltage. , Symbol = . , Characteristic = PIC18LF6X2X/8X2X. , Min = 2.0. , Typ = -. , Max = 5.5. , Units = V. , Conditions = . , Symbol = . , Characteristic = PIC18F6525/6621/8525/ 8621. , Min = 4.2. , Typ = -. , Max = 5.5. , Units = V. , Conditions = . D001A, Symbol = AVDD. D001A, Characteristic = Analog Supply Voltage. D001A, Min = -0.3. D001A, Typ = -. D001A, Max = +0.3. D001A, Units = V.",
    "27.1 DC Characteristics: Supply Voltage PIC18F6525/6621/8525/8621 (Industrial, Extended)\nD001A, Conditions = . D002, Symbol = VDR. D002, Characteristic = RAM Data Retention Voltage (1). D002, Min = 1.5. D002, Typ = -. D002, Max = -. D002, Units = V. D002, Conditions = . D003, Symbol = VPOR. D003, Characteristic = VDD Start Voltage to ensure internal Power-on Reset signal. D003, Min = -. D003, Typ = -. D003, Max = 0.7. D003, Units = V. D003, Conditions = See Section 3.1 'Power-on Reset (POR)' for details. D004, Symbol = SVDD. D004, Characteristic = VDD Rise Rate to ensure internal Power-on Reset signal. D004, Min = 0.05. D004, Typ = -. D004, Max = -. D004, Units = V/ms. D004, Conditions",
    "27.1 DC Characteristics: Supply Voltage PIC18F6525/6621/8525/8621 (Industrial, Extended)\n= See Section 3.1 'Power-on Reset (POR)' for details. D005, Symbol = VBOR. D005, Characteristic = Brown-out Reset Voltage. D005, Min = Brown-out Reset Voltage. D005, Typ = Brown-out Reset Voltage. D005, Max = Brown-out Reset Voltage. D005, Units = Brown-out Reset Voltage. D005, Conditions = Brown-out Reset Voltage. , Symbol = . , Characteristic = BORV1:BORV0 = 11. , Min = 1.96. , Typ = -. , Max = 2.18. , Units = V. , Conditions = . , Symbol = . , Characteristic = BORV1:BORV0 = 10. , Min = 2.64. , Typ = -. , Max = 2.92. , Units = V. , Conditions = . , Symbol = . , Characteristic = BORV1:BORV0 = 01. , Min = 4.11. , Typ = -. ,",
    "27.1 DC Characteristics: Supply Voltage PIC18F6525/6621/8525/8621 (Industrial, Extended)\nMax = 4.55. , Units = V. , Conditions = . , Symbol = . , Characteristic = BORV1:BORV0 = 00. , Min = 4.41. , Typ = -. , Max = 4.87. , Units = V. , Conditions = \nLegend:\nShading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in Sleep mode or during a device Reset without losing RAM data.",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\nPIC18LF6X2X/8X2X\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18F6525/6621/8525/8621\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\n, Device = Power-Down Current (I PD ) (1). , Typ = Power-Down Current (I PD ) (1). , Max = Power-Down Current (I PD ) (1). , Units = Power-Down Current (I PD ) (1). , Conditions = Power-Down Current (I PD ) (1). , Conditions = Power-Down Current (I PD ) (1). , Device = PIC18LF6X2X/8X2X. , Typ = 0.2. , Max = 1. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V, (Sleep mode). , Device = PIC18LF6X2X/8X2X. , Typ = 0.2. , Max = 1. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V, (Sleep mode). , Device =",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\nPIC18LF6X2X/8X2X. , Typ = 5.0. , Max = 10. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V, (Sleep mode). , Device = PIC18LF6X2X/8X2X. , Typ = 0.4. , Max = 1. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V, (Sleep mode). , Device = PIC18LF6X2X/8X2X. , Typ = 0.4. , Max = 1. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V, (Sleep mode). , Device = PIC18LF6X2X/8X2X. , Typ = 3.0. , Max = 18. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD =",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\n3.0V, (Sleep mode). , Device = All devices. , Typ = 0.7. , Max = 2. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V, (Sleep mode). , Device = All devices. , Typ = 0.7. , Max = 2. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V, (Sleep mode). , Device = All devices. , Typ = 15. , Max = 32. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V, (Sleep mode)",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\nLegend: Shading of rows is to assist in readability of the table.\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: The band gap reference is a shared resource used by both BOR and LVD modules. Enabling both modules will consume less than the specified sum current of the modules.",
    "27.2 DC Characteristics: Power-Down and Supply Current\nPIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nPIC18LF6X2X/8X2X\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18F6525/6621/8525/8621\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "27.2 DC Characteristics: Power-Down and Supply Current\nD010, Device = Supply Current (I DD) (2,3). D010, Typ = Supply Current (I DD) (2,3). D010, Max = Supply Current (I DD) (2,3). D010, Units = Supply Current (I DD) (2,3). D010, Conditions = Supply Current (I DD) (2,3). D010, Conditions = Supply Current (I DD) (2,3). D010, Conditions = Supply Current (I DD) (2,3). , Device = PIC18LF6X2X/8X2X. , Typ = 300. , Max = 500. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = 300. , Typ = . , Max = 500. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 1 MHZ, EC",
    "27.2 DC Characteristics: Power-Down and Supply Current\noscillator. , Device = 850. , Typ = . , Max = 1000. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = PIC18LF6X2X/8X2X. , Typ = 500. , Max = 900. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = 500. , Typ = . , Max = 900. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = 1. , Typ = . , Max = 1.5. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = All",
    "27.2 DC Characteristics: Power-Down and Supply Current\ndevices. , Typ = 1. , Max = 2. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = 1. , Typ = . , Max = 2. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = 1.3. , Typ = . , Max = 3. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = PIC18LF6X2X/8X2X. , Typ = 1. , Max = 2. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz, EC oscillator. , Device = 1. , Typ = . , Max",
    "27.2 DC Characteristics: Power-Down and Supply Current\n= 2. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz, EC oscillator. , Device = 1.5. , Typ = . , Max = 2.5. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz, EC oscillator. , Device = PIC18LF6X2X/8X2X. , Typ = 1.5. , Max = 2. , Units = mA. , Conditions = -40\u00b0C. , Conditions = . , Conditions = FOSC = 4 MHz, EC oscillator. , Device = 1.5. , Typ = . , Max = 2. , Units = mA. , Conditions = +25\u00b0C. , Conditions = . , Conditions = FOSC = 4 MHz, EC oscillator. , Device = 2. , Typ = . , Max = 2.5. , Units = mA. , Conditions = +85\u00b0C.",
    "27.2 DC Characteristics: Power-Down and Supply Current\n, Conditions = . , Conditions = FOSC = 4 MHz, EC oscillator. , Device = All devices. , Typ = 3. , Max = 5. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHz, EC oscillator. , Device = 3. , Typ = . , Max = 5. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHz, EC oscillator. , Device = 4. , Typ = . , Max = 6. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHz, EC oscillator\nLegend:\nShading of rows is to assist in readability of the table.\nNote",
    "27.2 DC Characteristics: Power-Down and Supply Current\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "27.2 DC Characteristics: Power-Down and Supply Current\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: The band gap reference is a shared resource used by both BOR and LVD modules. Enabling both modules will consume less than the specified sum current of the modules.",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nPIC18LF6X2X/8X2X\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\nPIC18F6525/6621/8525/8621\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\n, Device = Supply Current (I DD) (2,3). , Typ = Supply Current (I DD) (2,3). , Max = Supply Current (I DD) (2,3). , Units = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Device = PIC18F6525/6621/8525/ 8621. , Typ = 13. , Max = 27. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 4.2V. , Conditions = . , Device = PIC18F6525/6621/8525/ 8621. , Typ = 15. , Max = 27. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 4.2V. , Conditions =",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\n. , Device = PIC18F6525/6621/8525/ 8621. , Typ = 19. , Max = 29. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 4.2V. , Conditions = . , Device = PIC18F6525/6621/8525/ 8621. , Typ = 17. , Max = 31. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = PIC18F6525/6621/8525/ 8621. , Typ = 21. , Max = 31. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = PIC18F6525/6621/8525/ 8621. , Typ = 23. , Max = 34. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\n= 5.0V. , Conditions = . , Device = PIC18F6525/6621/8525/ 8621. , Typ = 20. , Max = 34. , Units = mA. , Conditions = -40\u00b0C. , Conditions = FOSC = EC oscillator. , Conditions = . , Device = PIC18F6525/6621/8525/ 8621. , Typ = 24. , Max = 34. , Units = mA. , Conditions = +25\u00b0C. , Conditions = FOSC = EC oscillator. , Conditions = . , Device = PIC18F6525/6621/8525/ 8621. , Typ = 29. , Max = 44. , Units = mA. , Conditions = +85\u00b0C. , Conditions = FOSC = EC oscillator. , Conditions = . , Device = PIC18F6525/6621/8525/ 8621. , Typ = 28. , Max = 46. , Units =",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nmA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = PIC18F6525/6621/8525/ 8621. , Typ = 33. , Max = 46. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = PIC18F6525/6621/8525/ 8621. , Typ = 40. , Max = 51. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . D014, Device = PIC18LF6X2X/8X2X. D014, Typ = 27. D014, Max = 45. D014, Units = \uf06d A. D014, Conditions = -10\u00b0C. D014, Conditions = FOSC Timer1. D014, Conditions = . D014, Device =",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nPIC18LF6X2X/8X2X. D014, Typ = 30. D014, Max = 50. D014, Units = \uf06d A. D014, Conditions = +25\u00b0C. D014, Conditions = FOSC Timer1. D014, Conditions = . D014, Device = PIC18LF6X2X/8X2X. D014, Typ = 32. D014, Max = 54. D014, Units = \uf06d A. D014, Conditions = +70\u00b0C. D014, Conditions = FOSC Timer1. D014, Conditions = . D014, Device = PIC18LF6X2X/8X2X. D014, Typ = 33. D014, Max = 55. D014, Units = \uf06d A. D014, Conditions = -10\u00b0C. D014, Conditions = VDD = 3.0V. D014, Conditions = .",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nD014, Device = PIC18LF6X2X/8X2X. D014, Typ = 36. D014, Max = 60. D014, Units = \uf06d A. D014, Conditions = +25\u00b0C. D014, Conditions = VDD = 3.0V. D014, Conditions = . D014, Device = PIC18LF6X2X/8X2X. D014, Typ = 39. D014, Max = 65. D014, Units = \uf06d A. D014, Conditions = +70\u00b0C. D014, Conditions = VDD = 3.0V. D014, Conditions = . D014, Device = All devices. D014, Typ = 75. D014, Max = 125. D014, Units = \uf06d A. D014, Conditions = -10\u00b0C. D014, Conditions = VDD = 5.0V. D014, Conditions = .",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nD014, Device = All devices. D014, Typ = 90. D014, Max = 150. D014, Units = \uf06d A. D014, Conditions = +25\u00b0C. D014, Conditions = VDD = 5.0V. D014, Conditions = . D014, Device = All devices. D014, Typ = 113. D014, Max = 188. D014, Units = \uf06d A. D014, Conditions = +70\u00b0C. D014, Conditions = VDD = 5.0V. D014, Conditions = \nLegend: Shading of rows is to assist in readability of the table.",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: The band gap reference is a shared resource used by both BOR and LVD modules. Enabling both modules will consume less than the specified sum current of the modules.",
    "27.2 DC Characteristics: Power-Down and Supply Current\nPIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nPIC18LF6X2X/8X2X\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F6525/6621/8525/8621\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "27.2 DC Characteristics: Power-Down and Supply Current\nD022 ( \uf044 I WDT), Device = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Typ = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Max = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Units = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Conditions = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Conditions = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Conditions = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I",
    "27.2 DC Characteristics: Power-Down and Supply Current\nAD). D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = <1. D022 ( \uf044 I WDT), Max = 2.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = -40 \uf0b0 C. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Conditions = VDD = 2.0V. D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = <1. D022 ( \uf044 I WDT), Max = 2. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +25 \uf0b0 C. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Conditions = VDD = 2.0V. D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 5. D022 ( \uf044 I",
    "27.2 DC Characteristics: Power-Down and Supply Current\nWDT), Max = 20. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +85 \uf0b0 C. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Conditions = VDD = 2.0V. D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 3. D022 ( \uf044 I WDT), Max = 10. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = -40 \uf0b0 C. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Conditions = VDD = 3.0V. D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 3. D022 ( \uf044 I WDT), Max = 20. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +25 \uf0b0 C. D022 ( \uf044 I",
    "27.2 DC Characteristics: Power-Down and Supply Current\nWDT), Conditions = . D022 ( \uf044 I WDT), Conditions = VDD = 3.0V. D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 10. D022 ( \uf044 I WDT), Max = 35. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +85 \uf0b0 C. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Conditions = VDD = 3.0V. D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 12. D022 ( \uf044 I WDT), Max = 25. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = -40 \uf0b0 C. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Conditions = VDD = 5.0V. D022 ( \uf044 I WDT), Device = Watchdog Timer.",
    "27.2 DC Characteristics: Power-Down and Supply Current\nD022 ( \uf044 I WDT), Typ = 15. D022 ( \uf044 I WDT), Max = 35. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +25 \uf0b0 C. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Conditions = VDD = 5.0V. D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 20. D022 ( \uf044 I WDT), Max = 50. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +85 \uf0b0 C. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Conditions = VDD = 5.0V. D022A ( \uf044 I BOR), Device = Brown-out Reset (4). D022A ( \uf044 I BOR), Typ = 55. D022A ( \uf044 I BOR), Max = 115. D022A ( \uf044 I",
    "27.2 DC Characteristics: Power-Down and Supply Current\nBOR), Units = \uf06d A. D022A ( \uf044 I BOR), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022A ( \uf044 I BOR), Conditions = . D022A ( \uf044 I BOR), Conditions = VDD = 3.0V. D022A ( \uf044 I BOR), Device = Brown-out Reset (4). D022A ( \uf044 I BOR), Typ = 105. D022A ( \uf044 I BOR), Max = 175. D022A ( \uf044 I BOR), Units = \uf06d A. D022A ( \uf044 I BOR), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022A ( \uf044 I BOR), Conditions = . D022A ( \uf044 I BOR), Conditions = VDD = 5.0V. D022B ( \uf044 I LVD ), Device = Low-Voltage Detect (4). D022B ( \uf044 I LVD ), Typ = 45. D022B ( \uf044 I LVD ), Max = 125. D022B ( \uf044 I LVD ), Units = \uf06d A. D022B",
    "27.2 DC Characteristics: Power-Down and Supply Current\n( \uf044 I LVD ), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions = . D022B ( \uf044 I LVD ), Conditions = VDD = 2.0V. D022B ( \uf044 I LVD ), Device = Low-Voltage Detect (4). D022B ( \uf044 I LVD ), Typ = 45. D022B ( \uf044 I LVD ), Max = 150. D022B ( \uf044 I LVD ), Units = \uf06d A. D022B ( \uf044 I LVD ), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions = . D022B ( \uf044 I LVD ), Conditions = VDD = 3.0V. D022B ( \uf044 I LVD ), Device = Low-Voltage Detect (4). D022B ( \uf044 I LVD ), Typ = 45. D022B ( \uf044 I LVD ), Max = 225. D022B ( \uf044 I LVD ), Units = \uf06d A. D022B ( \uf044 I LVD ), Conditions = -40 \uf0b0 C to",
    "27.2 DC Characteristics: Power-Down and Supply Current\n+85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions = . D022B ( \uf044 I LVD ), Conditions = VDD = 5.0V. D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 20. D025 ( \uf044 I OSCB), Max = 27. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = -10 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 2.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1. D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 20. D025 ( \uf044 I OSCB), Max = 30. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +25 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 2.0V. D025 ( \uf044 I",
    "27.2 DC Characteristics: Power-Down and Supply Current\nOSCB), Conditions = 32 kHz on Timer1. D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 25. D025 ( \uf044 I OSCB), Max = 35. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +70 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = . D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1. D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 22. D025 ( \uf044 I OSCB), Max = 60. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = -10 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 3.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1. D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025",
    "27.2 DC Characteristics: Power-Down and Supply Current\n( \uf044 I OSCB), Typ = 22. D025 ( \uf044 I OSCB), Max = 65. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +25 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = . D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1. D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 25. D025 ( \uf044 I OSCB), Max = 75. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +70 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = . D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1. D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 30. D025 ( \uf044 I OSCB), Max = 75. D025 ( \uf044 I OSCB), Units = \uf06d A. D025",
    "27.2 DC Characteristics: Power-Down and Supply Current\n( \uf044 I OSCB), Conditions = -10 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 5.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1. D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 30. D025 ( \uf044 I OSCB), Max = 85. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +25 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 5.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1. D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 35. D025 ( \uf044 I OSCB), Max = 100. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +70 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = .",
    "27.2 DC Characteristics: Power-Down and Supply Current\nD025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1. D026 ( \uf044 I AD), Device = A/D Converter. D026 ( \uf044 I AD), Typ = <1. D026 ( \uf044 I AD), Max = 2. D026 ( \uf044 I AD), Units = \uf06d A. D026 ( \uf044 I AD), Conditions = +25 \uf0b0 C. D026 ( \uf044 I AD), Conditions = VDD = 2.0V. D026 ( \uf044 I AD), Conditions = A/D on, not converting. D026 ( \uf044 I AD), Device = A/D Converter. D026 ( \uf044 I AD), Typ = <1. D026 ( \uf044 I AD), Max = 2. D026 ( \uf044 I AD), Units = \uf06d A. D026 ( \uf044 I AD), Conditions = +25 \uf0b0 C. D026 ( \uf044 I AD), Conditions = VDD = 3.0V. D026 ( \uf044 I AD), Conditions = A/D on, not converting. D026 ( \uf044 I AD), Device = A/D Converter. D026",
    "27.2 DC Characteristics: Power-Down and Supply Current\n( \uf044 I AD), Typ = <1. D026 ( \uf044 I AD), Max = 2. D026 ( \uf044 I AD), Units = \uf06d A. D026 ( \uf044 I AD), Conditions = +25 \uf0b0 C. D026 ( \uf044 I AD), Conditions = VDD = 5.0V. D026 ( \uf044 I AD), Conditions = A/D on, not converting\nLegend:\nShading of rows is to assist in readability of the table.\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.",
    "27.2 DC Characteristics: Power-Down and Supply Current\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: The band gap reference is a shared resource used by both BOR and LVD modules. Enabling both modules will consume less than the specified sum current of the modules.",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\nDC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3\uf020 TA \uf0a3 +125\u00b0C for extended",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\n, Symbol = VIL. , Characteristic = Input Low Voltage I/O ports:. , Min = . , Max = . , Units = . , Conditions = . D030, Symbol = . D030, Characteristic = with TTL buffer. D030, Min = VSS. D030, Max = 0.15 VDD. D030, Units = V. D030, Conditions = VDD < 4.5V. D030A, Symbol = . D030A, Characteristic = . D030A, Min = -. D030A, Max = 0.8. D030A, Units = V. D030A, Conditions = 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V. D031, Symbol = . D031, Characteristic = with Schmitt Trigger buffer RC3 and RC4. D031, Min = VSS. D031, Max = 0.2 VDD. D031, Units = V. D031,",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\nConditions = . D032, Symbol = . D032, Characteristic = MCLR. D032, Min = VSS. D032, Max = 0.3 VDD. D032, Units = V. D032, Conditions = . , Symbol = . , Characteristic = . , Min = VSS. , Max = 0.2 VDD. , Units = V. , Conditions = . D033, Symbol = . D033, Characteristic = OSC1. D033, Min = VSS. D033, Max = 0.3 VDD. D033, Units = V. D033, Conditions = HS, HS+PLL modes. D033A, Symbol = . D033A, Characteristic = OSC1. D033A, Min = VSS. D033A, Max = 0.2 VDD. D033A, Units = V. D033A, Conditions = RC, EC modes. D033B, Symbol",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\n= . D033B, Characteristic = OSC1. D033B, Min = VSS. D033B, Max = 0.3. D033B, Units = V. D033B, Conditions = XT, LP modes. D034, Symbol = . D034, Characteristic = T1OSI. D034, Min = VSS. D034, Max = 0.3. D034, Units = V. D034, Conditions = . , Symbol = VIH. , Characteristic = Input High Voltage. , Min = . , Max = . , Units = . , Conditions = . D040, Symbol = . D040, Characteristic = with TTL buffer. D040, Min = 0.25 VDD + 0.8V. D040, Max = VDD. D040, Units = V. D040, Conditions = VDD < 4.5V. D040A, Symbol = . D040A, Characteristic",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\n= . D040A, Min = 2.0. D040A, Max = VDD. D040A, Units = V. D040A, Conditions = 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V. D041, Symbol = . D041, Characteristic = with Schmitt Trigger buffer RC3 and RC4. D041, Min = 0.8 VDD 0.7 VDD. D041, Max = VDD VDD. D041, Units = V V. D041, Conditions = . D042, Symbol = . D042, Characteristic = MCLR, OSC1 (EC mode). D042, Min = 0.8 VDD. D042, Max = VDD. D042, Units = V. D042, Conditions = . D043, Symbol = . D043, Characteristic = OSC1. D043, Min = 0.7 VDD. D043, Max =",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\nVDD. D043, Units = V. D043, Conditions = HS, HS+PLL modes. D043A, Symbol = . D043A, Characteristic = OSC1. D043A, Min = 0.8 VDD. D043A, Max = VDD. D043A, Units = V. D043A, Conditions = EC mode. D043B, Symbol = . D043B, Characteristic = OSC1. D043B, Min = 0.9 VDD. D043B, Max = VDD. D043B, Units = V. D043B, Conditions = RC mode (1). D043C, Symbol = . D043C, Characteristic = OSC1. D043C, Min = 1.6. D043C, Max = VDD. D043C, Units = V. D043C, Conditions = XT, LP modes. D044,",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\nSymbol = . D044, Characteristic = T13CKI. D044, Min = 1.6. D044, Max = VDD. D044, Units = V. D044, Conditions = . , Symbol = I IL. , Characteristic = Input Leakage Current (2,3). , Min = . , Max = . , Units = . , Conditions = . D060, Symbol = . D060, Characteristic = I/O ports. D060, Min = -. D060, Max = \uf0b1 1. D060, Units = \uf06d A. D060, Conditions = VSS \uf0a3\uf020 VPIN \uf0a3\uf020 VDD, Pin at high-impedance. D061, Symbol = . D061, Characteristic = MCLR. D061, Min = -. D061, Max = \uf0b1 5. D061, Units = \uf06d A. D061, Conditions = VSS \uf0a3\uf020 VPIN \uf0a3\uf020 VDD. D063, Symbol = . D063,",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\nCharacteristic = OSC1. D063, Min = -. D063, Max = \uf0b1 5. D063, Units = \uf06d A. D063, Conditions = VSS \uf0a3\uf020 VPIN \uf0a3\uf020 VDD. D070, Symbol = I PU I PURB. D070, Characteristic = Weak Pull-up Current PORTB weak pull-up current. D070, Min = 50. D070, Max = 400. D070, Units = \uf06d A. D070, Conditions = VDD = 5V, VPIN = VSS",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial)\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PIC \u00ae  device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nDC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3\uf020 TA \uf0a3 +125\u00b0C for extended",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nD080, Symbol = VOL. D080, Characteristic = Output Low Voltage I/O ports. D080, Min = -. D080, Max = 0.6. D080, Units = V. D080, Conditions = I OL = 8.5 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D080A, Symbol = . D080A, Characteristic = . D080A, Min = -. D080A, Max = 0.6. D080A, Units = V. D080A, Conditions = I OL = 7.0 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D083, Symbol = . D083, Characteristic = OSC2/CLKO (RC mode). D083, Min = -. D083, Max = 0.6. D083, Units = V.",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nD083, Conditions = I OL = 1.6 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D083A, Symbol = . D083A, Characteristic = . D083A, Min = -. D083A, Max = 0.6. D083A, Units = V. D083A, Conditions = I OL = 1.2 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D090, Symbol = VOH. D090, Characteristic = Output High Voltage (3) I/O ports. D090, Min = VDD - 0.7. D090, Max = -. D090, Units = V. D090, Conditions = I OH = -3.0 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D090A, Symbol = . D090A, Characteristic",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\n= . D090A, Min = VDD - 0.7. D090A, Max = -. D090A, Units = V. D090A, Conditions = I OH = -2.5 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D092, Symbol = . D092, Characteristic = OSC2/CLKO (RC mode). D092, Min = VDD - 0.7. D092, Max = -. D092, Units = V. D092, Conditions = I OH = -1.3 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D092A, Symbol = . D092A, Characteristic = . D092A, Min = VDD - 0.7. D092A, Max = -. D092A, Units = V.",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\nD092A, Conditions = I OH = -1.0 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D150, Symbol = VOD. D150, Characteristic = Open-Drain High Voltage. D150, Min = -. D150, Max = 8.5. D150, Units = V. D150, Conditions = RA4 pin. D100 (4), Symbol = COSC2. D100 (4), Characteristic = on Output Pins OSC2 pin. D100 (4), Min = -. D100 (4), Max = 15. D100 (4), Units = pF. D100 (4), Conditions = In XT, HS and LP modes when external clock is used to drive OSC1. D101, Symbol = CIO. D101, Characteristic = All I/O pins and OSC2 (in RC mode). D101, Min =",
    "27.3 DC Characteristics: PIC18F6525/6621/8525/8621 (Industrial, Extended) PIC18LF6X2X/8X2X (Industrial) (Continued)\n-. D101, Max = 50. D101, Units = pF. D101, Conditions = To meet the AC Timing Specifications. D102, Symbol = CB. D102, Characteristic = SCL, SDA. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = In I 2 C\u2122mode\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PIC \u00ae  device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.",
    "TABLE 27-1: COMPARATOR SPECIFICATIONS\nOperating Conditions: 3.0V < VDD < 5.5V, -40\u00b0C < TA < +125\u00b0C (unless otherwise stated)",
    "TABLE 27-1: COMPARATOR SPECIFICATIONS\nD300, Sym = VIOFF. D300, Characteristics = Input Offset Voltage. D300, Min = -. D300, Typ = \u00b15.0. D300, Max = \u00b110. D300, Units = mV. D300, Comments = . D301, Sym = VICM. D301, Characteristics = Input Common Mode Voltage. D301, Min = 0. D301, Typ = -. D301, Max = VDD - 1.5. D301, Units = V. D301, Comments = . D302, Sym = CMRR. D302, Characteristics = Common Mode Rejection Ratio. D302, Min = 55. D302, Typ = -. D302, Max = -. D302, Units = dB. D302, Comments = . 300 300A, Sym = TRESP. 300 300A, Characteristics = Response Time (1). 300 300A, Min = -. 300 300A, Typ = 150. 300 300A, Max = 400 600. 300 300A, Units = ns",
    "TABLE 27-1: COMPARATOR SPECIFICATIONS\nns. 300 300A, Comments = PIC18F6525/6621/ 8525/8621 PIC18LF6X2X/8X2X. 301, Sym = TMC2OV. 301, Characteristics = Comparator Mode Change to Output Valid. 301, Min = -. 301, Typ = -. 301, Max = 10. 301, Units = \uf06d s. 301, Comments = \nNote 1: Response time measured with one comparator input at (VDD - 1.5)/2 while the other input transitions from VSS to VDD.",
    "TABLE 27-2: VOLTAGE REFERENCE SPECIFICATIONS\nOperating Conditions: 3.0V < VDD < 5.5V, -40\u00b0C < TA < +125\u00b0C (unless otherwise stated)",
    "TABLE 27-2: VOLTAGE REFERENCE SPECIFICATIONS\nD310, Sym = VRES. D310, Characteristics = Resolution. D310, Min = VDD /24. D310, Typ = -. D310, Max = VDD /32. D310, Units = LSb. D310, Comments = . D311, Sym = VRAA. D311, Characteristics = Absolute Accuracy. D311, Min = -. D311, Typ = -. D311, Max = 1/2. D311, Units = LSb. D311, Comments = . D312, Sym = VRUR. D312, Characteristics = Unit Resistor Value (R). D312, Min = -. D312, Typ = 2k. D312, Max = -. D312, Units = \uf057. D312, Comments = . 310, Sym = T SET. 310, Characteristics = Settling Time (1). 310, Min = -. 310, Typ = -. 310, Max = 10. 310, Units = \uf06d s. 310, Comments = ",
    "TABLE 27-2: VOLTAGE REFERENCE SPECIFICATIONS\nNote 1: Settling time measured while VRR = 1 and VR<3:0> transitions from 0000 to 1111 .",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nLOW-VOLTAGE DETECT CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 0000. D420, Min = -. D420, Typ\u2020 = -. D420, Max = -. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 0001. D420, Min = 1.96. D420, Typ\u2020 = 2.06. D420, Max = 2.16. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 0010. D420, Min = 2.16. D420, Typ\u2020 = 2.27. D420, Max = 2.38.",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 0011. D420, Min = 2.35. D420, Typ\u2020 = 2.47. D420, Max = 2.59. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 0100. D420, Min = 2.46. D420, Typ\u2020 = 2.58. D420, Max = 2.71. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 0101. D420, Min = 2.64.",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Typ\u2020 = 2.78. D420, Max = 2.92. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 0110. D420, Min = 2.75. D420, Typ\u2020 = 2.89. D420, Max = 3.03. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 0111. D420, Min = 2.95. D420, Typ\u2020 = 3.10. D420, Max = 3.26. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low.",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Characteristic = LVV = 1000. D420, Min = 3.24. D420, Typ\u2020 = 3.41. D420, Max = 3.58. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 1001. D420, Min = 3.43. D420, Typ\u2020 = 3.61. D420, Max = 3.79. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 1010. D420, Min = 3.53. D420, Typ\u2020 = 3.72. D420, Max = 3.91. D420, Units = V. D420, Conditions = . D420, Symbol =",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nVLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 1011. D420, Min = 3.72. D420, Typ\u2020 = 3.92. D420, Max = 4.12. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 1100. D420, Min = 3.92. D420, Typ\u2020 = 4.13. D420, Max = 4.33. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 1101. D420, Min = 4.11. D420, Typ\u2020 = 4.33. D420, Max = 4.55.",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage on VDD transition high-to-low. D420, Characteristic = LVV = 1110. D420, Min = 4.41. D420, Typ\u2020 = 4.64. D420, Max = 4.87. D420, Units = V. D420, Conditions = . D423, Symbol = VBG. D423, Characteristic = Band Gap Reference Voltage Value. D423, Characteristic = Band Gap Reference Voltage Value. D423, Min = -. D423, Typ\u2020 = 1.22. D423, Max = -. D423, Units = V. D423, Conditions = \n- \u2020 Production tested at TAMB = 25\u00b0C. Specifications over temp. limits ensured by characterization.",
    "Standard Operating Conditions (unless otherwise stated)\nDC Characteristics\nOperating temperature -40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "Standard Operating Conditions (unless otherwise stated)\n, Sym = . , Characteristic = Internal Program Memory Programming Specifications. , Min = . , Typ\u2020 = . , Max = . , Units = . , Conditions = . D110, Sym = VPP. D110, Characteristic = Voltage on MCLR/VPP pin. D110, Min = 9.00. D110, Typ\u2020 = -. D110, Max = 13.25. D110, Units = V. D110, Conditions = (Note 2). D112, Sym = I PP. D112, Characteristic = Current into MCLR/VPP pin. D112, Min = -. D112, Typ\u2020 = -. D112, Max = 300. D112, Units = \uf06d A. D112, Conditions = . D113, Sym = I DDP. D113, Characteristic = Supply Current during Programming. D113, Min = -. D113, Typ\u2020 = -. D113, Max = 1.0. D113, Units = mA. D113, Conditions = . , Sym = . , Characteristic",
    "Standard Operating Conditions (unless otherwise stated)\n= Data EEPROM Memory. , Min = . , Typ\u2020 = . , Max = . , Units = . , Conditions = . D120, Sym = ED. D120, Characteristic = Byte Endurance. D120, Min = 100K 10K. D120, Typ\u2020 = 1M 100K. D120, Max = - -. D120, Units = E/W E/W. D120, Conditions = -40 \uf0b0 C to +85 \uf0b0 C -40 \uf0b0 C to +125 \uf0b0 C. D121, Sym = VDRW. D121, Characteristic = VDD for Read/Write. D121, Min = VMIN. D121, Typ\u2020 = -. D121, Max = 5.5. D121, Units = V. D121, Conditions = Using EECON to read/write VMIN = Minimum operating voltage. D122, Sym = TDEW. D122, Characteristic = Erase/Write Cycle Time. D122, Min = -. D122, Typ\u2020 = 4. D122, Max = -. D122, Units",
    "Standard Operating Conditions (unless otherwise stated)\n= ms. D122, Conditions = . D123, Sym = TRETD. D123, Characteristic = Characteristic Retention. D123, Min = 40. D123, Typ\u2020 = -. D123, Max = -. D123, Units = Year. D123, Conditions = Provided no other specifications are violated. D124, Sym = TREF. D124, Characteristic = Number of Total Erase/Write Cycles before Refresh (1). D124, Min = 1M 100K. D124, Typ\u2020 = 10M 1M. D124, Max = - -. D124, Units = E/W E/W. D124, Conditions = -40\u00b0C to +85\u00b0C -40 \uf0b0 C to +125 \uf0b0 C. , Sym = . , Characteristic = Program Flash Memory. , Min = . , Typ\u2020 = . , Max = . , Units = . , Conditions = . D130, Sym = EP. D130, Characteristic = Cell Endurance. D130, Min = 10K 1K. D130, Typ\u2020 =",
    "Standard Operating Conditions (unless otherwise stated)\n100K 10K. D130, Max = - -. D130, Units = E/W E/W. D130, Conditions = -40 \uf0b0 C to +85 \uf0b0 C -40 \uf0b0 C to +125 \uf0b0 C. D131, Sym = VPR. D131, Characteristic = VDD for Read. D131, Min = VMIN. D131, Typ\u2020 = -. D131, Max = 5.5. D131, Units = V. D131, Conditions = VMIN = Minimum operating voltage. D132, Sym = VIE. D132, Characteristic = VDD for Block Erase. D132, Min = 4.5. D132, Typ\u2020 = -. D132, Max = 5.5. D132, Units = V. D132, Conditions = Using ICSP\u2122 port. D132A, Sym = VIW. D132A, Characteristic = VDD for Externally Timed Erase or Write. D132A, Min = 4.5. D132A, Typ\u2020 = -. D132A, Max =",
    "Standard Operating Conditions (unless otherwise stated)\n5.5. D132A, Units = V. D132A, Conditions = Using ICSP port. D132B, Sym = VPEW. D132B, Characteristic = VDD for Self-Timed Write and Row Erase. D132B, Min = VMIN. D132B, Typ\u2020 = -. D132B, Max = 5.5. D132B, Units = V. D132B, Conditions = VMIN = Minimum operating voltage. D133, Sym = TIE. D133, Characteristic = ICSP Block Erase Cycle Time. D133, Min = -. D133, Typ\u2020 = 4. D133, Max = -. D133, Units = ms. D133, Conditions = VDD > 4.5V. D133A, Sym = TIW. D133A, Characteristic = ICSP Erase or Write Cycle Time (externally timed). D133A, Min = 1. D133A, Typ\u2020 = -. D133A, Max = -. D133A, Units = ms.",
    "Standard Operating Conditions (unless otherwise stated)\nD133A, Conditions = VDD > 4.5V. D133A, Sym = TIW. D133A, Characteristic = Self-Timed Write Cycle Time. D133A, Min = -. D133A, Typ\u2020 = 2. D133A, Max = -. D133A, Units = ms. D133A, Conditions = . D134, Sym = TRETD. D134, Characteristic = Characteristic Retention. D134, Min = 40. D134, Typ\u2020 = -. D134, Max = -. D134, Units = Year. D134, Conditions = Provided no other specifications are violated\n\u2020 Data in 'Typ' column is at 5.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: Refer to Section 7.8 'Using the Data EEPROM' for a more detailed discussion on data EEPROM endurance.\n2: Required only if Low-Voltage Programming is disabled.",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nThe  timing  parameter  symbols  have  been  created following one of the following formats:",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nT, 1. TppS2ppS.2. TppS = T. T, 3. T CC: ST.4. Ts = . T, (I 2 C specifications only) 2.(I C specifications only) = . F, 1. TppS2ppS.2. TppS = Frequency. F, 3. T CC: ST.4. Ts = T. F, (I 2 C specifications only) 2.(I C specifications only) = Time. Lowercase letters (pp) and their meanings:, 1. TppS2ppS.2. TppS = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, 3. T CC: ST.4. Ts = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, (I 2 C specifications only) 2.(I C specifications only) = Lowercase letters (pp) and their meanings:. pp, 1. TppS2ppS.2. TppS = pp. pp, 3. T CC: ST.4. Ts = . pp, (I 2 C specifications only)",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\n2.(I C specifications only) = . cc, 1. TppS2ppS.2. TppS = CCP1. cc, 3. T CC: ST.4. Ts = osc. cc, (I 2 C specifications only) 2.(I C specifications only) = OSC1. ck, 1. TppS2ppS.2. TppS = CLKO. ck, 3. T CC: ST.4. Ts = rd. ck, (I 2 C specifications only) 2.(I C specifications only) = RD. cs, 1. TppS2ppS.2. TppS = CS. cs, 3. T CC: ST.4. Ts = rw. cs, (I 2 C specifications only) 2.(I C specifications only) = RD or WR. di, 1. TppS2ppS.2. TppS = SDI. di, 3. T CC: ST.4. Ts = sc. di, (I 2 C specifications only) 2.(I C specifications only) = SCK. do, 1. TppS2ppS.2. TppS = SDO. do, 3. T",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nCC: ST.4. Ts = ss. do, (I 2 C specifications only) 2.(I C specifications only) = SS. dt, 1. TppS2ppS.2. TppS = Data in. dt, 3. T CC: ST.4. Ts = t0. dt, (I 2 C specifications only) 2.(I C specifications only) = T0CKI. io, 1. TppS2ppS.2. TppS = I/O port. io, 3. T CC: ST.4. Ts = t1. io, (I 2 C specifications only) 2.(I C specifications only) = T1CKI. mc, 1. TppS2ppS.2. TppS = MCLR. mc, 3. T CC: ST.4. Ts = wr. mc, (I 2 C specifications only) 2.(I C specifications only) = WR. Uppercase letters and their meanings:, 1. TppS2ppS.2. TppS = Uppercase letters and their meanings:. Uppercase letters and their meanings:, 3. T CC: ST.4. Ts = Uppercase letters and their",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nmeanings:. Uppercase letters and their meanings:, (I 2 C specifications only) 2.(I C specifications only) = Uppercase letters and their meanings:. S, 1. TppS2ppS.2. TppS = S. S, 3. T CC: ST.4. Ts = . S, (I 2 C specifications only) 2.(I C specifications only) = . F, 1. TppS2ppS.2. TppS = Fall. F, 3. T CC: ST.4. Ts = P. F, (I 2 C specifications only) 2.(I C specifications only) = Period. H, 1. TppS2ppS.2. TppS = High. H, 3. T CC: ST.4. Ts = R. H, (I 2 C specifications only) 2.(I C specifications only) = Rise. I, 1. TppS2ppS.2. TppS = Invalid (High-impedance). I, 3. T CC: ST.4. Ts = V. I, (I 2 C specifications only) 2.(I C specifications only) = Valid. L, 1.",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nTppS2ppS.2. TppS = Low. L, 3. T CC: ST.4. Ts = Z. L, (I 2 C specifications only) 2.(I C specifications only) = High-impedance. I 2 C only, 1. TppS2ppS.2. TppS = I 2 C only. I 2 C only, 3. T CC: ST.4. Ts = . I 2 C only, (I 2 C specifications only) 2.(I C specifications only) = . AA, 1. TppS2ppS.2. TppS = output access. AA, 3. T CC: ST.4. Ts = High. AA, (I 2 C specifications only) 2.(I C specifications only) = High. BUF, 1. TppS2ppS.2. TppS = Bus free. BUF, 3. T CC: ST.4. Ts = Low. BUF, (I 2 C specifications only) 2.(I C specifications only) = Low. T CC: ST (I 2 C specifications only), 1. TppS2ppS.2. TppS = T CC: ST",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\n(I 2 C specifications only). T CC: ST (I 2 C specifications only), 3. T CC: ST.4. Ts = T CC: ST (I 2 C specifications only). T CC: ST (I 2 C specifications only), (I 2 C specifications only) 2.(I C specifications only) = T CC: ST (I 2 C specifications only). CC, 1. TppS2ppS.2. TppS = CC. CC, 3. T CC: ST.4. Ts = . CC, (I 2 C specifications only) 2.(I C specifications only) = . HD, 1. TppS2ppS.2. TppS = Hold. HD, 3. T CC: ST.4. Ts = SU. HD, (I 2 C specifications only) 2.(I C specifications only) = Setup. ST, 1. TppS2ppS.2. TppS = ST. ST, 3. T CC: ST.4. Ts = ST. ST, (I 2 C specifications only) 2.(I C specifications only) = ST. DAT, 1. TppS2ppS.2. TppS",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\n= DATA input hold. DAT, 3. T CC: ST.4. Ts = STO. DAT, (I 2 C specifications only) 2.(I C specifications only) = Stop condition. STA, 1. TppS2ppS.2. TppS = Start condition. STA, 3. T CC: ST.4. Ts = . STA, (I 2 C specifications only) 2.(I C specifications only) = ",
    "27.4.2 TIMING CONDITIONS\nThe temperature and voltages specified in Table 27-5 apply  to  all  timing  specifications,  unless  otherwise noted. Figure 27-4 specifies the load conditions for the timing specifications.",
    "TABLE 27-5: TEMPERATURE AND VOLTAGE SPECIFICATIONS - AC\nAC CHARACTERISTICS, 1 = Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3\uf020 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended Operating voltage VDD range as described in DC spec Section 27.1 and Section 27.3 . LF parts operate for industrial temperatures only.",
    "FIGURE 27-4: LOAD CONDITIONS FOR DEVICE TIMING SPECIFICATIONS\nVDD /2 CL RL VSS, Load condition 2 = VSS for all pins except OSC2/CLKO and including D and E outputs as ports",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\n1A, Symbol = FOSC. 1A, Characteristic = External CLKI Frequency (1) Oscillator Frequency (1). 1A, Min = DC DC DC DC 0.1 4 4 4 5. 1A, Max = 25 40 25 4 4 25 10 6.25 33. 1A, Units = MHz MHz MHz MHz MHz MHz MHz MHz kHz. 1A, Conditions = EC, ECIO (2) (-40\u00baC to +85\u00baC) EC, ECIO EC, ECIO (+85\u00baC to +125\u00baC) RC oscillator XT oscillator HS oscillator HS + PLL oscillator HS + PLL oscillator (2) LP Oscillator mode. 1, Symbol = T OSC. 1, Characteristic = External CLKI Period (1) Oscillator Period (1). 1, Min = 25 40 40 250 250 40 100 160 30. 1, Max = - - - - 10,000 250 250 250 200. 1, Units = ns ns ns ns ns ns ns ns \uf06d s. 1, Conditions = EC, ECIO EC, ECIO (2) EC,",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\nECIO (+85\u00baC to +125\u00baC) RC oscillator XT oscillator HS oscillator HS + PLL oscillator HS + PLL oscillator (2). 2, Symbol = T CY. 2, Characteristic = Instruction Cycle Time (1). 2, Min = 100. 2, Max = -. 2, Units = ns. 2, Conditions = T CY = 4/F OSC. 3, Symbol = TosL, TosH. 3, Characteristic = External Clock in (OSC1) High or Low Time. 3, Min = 30 2.5 10. 3, Max = - - -. 3, Units = ns \uf06d s ns. 3, Conditions = XT oscillator LP oscillator HS oscillator. 4, Symbol = TosR, TosF. 4, Characteristic = External Clock in (OSC1) Rise or Fall Time. 4, Min = - - -. 4, Max = 20 50 7.5. 4, Units = ns ns ns. 4, Conditions = XT oscillator LP oscillator HS oscillator",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\nNote 1: Instruction cycle period (TCY) equals four times the input oscillator time base period for all configurations except PLL. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min.' values with an external clock applied to the OSC1/CLKI pin. When an external clock input is used, the 'max.' cycle time limit is 'DC' (no clock) for all devices.\n2: PIC18F6525/6621/8525/8621 devices using external memory interface.",
    "TABLE 27-7: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2 TO 5.5V)\n, Sym = FOSC. , Characteristic = Oscillator Frequency Range. , Min = 4. , Typ\u2020 = -. , Max = 10. , Units = MHz. , Conditions = HS mode. , Sym = FSYS. , Characteristic = On-Chip VCO System Frequency. , Min = 16. , Typ\u2020 = -. , Max = 40. , Units = MHz. , Conditions = HS mode. , Sym = t rc. , Characteristic = PLL Start-up Time (Lock Time). , Min = -. , Typ\u2020 = -. , Max = 2. , Units = ms. , Conditions = . , Sym = \uf044 CLK. , Characteristic = CLKO Stability (Jitter). , Min = -2. , Typ\u2020 = -. , Max = +2. , Units = %. , Conditions = \n- \u2020 Data in 'Typ' column is at 5V, 25 C, unless otherwise stated. These parameters are for design guidance \uf0b0 only and are not tested.",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\n10, Symbol = TosH2ckL. 10, Characteristic = OSC1 \uf0ad to CLKO \uf0af. 10, Characteristic = OSC1 \uf0ad to CLKO \uf0af. 10, Min = -. 10, Typ = 75. 10, Max = 200. 10, Units = ns. 10, Conditions = (Note 1). 11, Symbol = TosH2ckH. 11, Characteristic = OSC1 \uf0ad to CLKO \uf0ad. 11, Characteristic = OSC1 \uf0ad to CLKO \uf0ad. 11, Min = -. 11, Typ = 75. 11, Max = 200. 11, Units = ns. 11, Conditions = (Note 1). 12, Symbol = TckR. 12, Characteristic = CLKO Rise Time. 12, Characteristic = CLKO Rise Time. 12, Min = -. 12, Typ = 35. 12, Max = 100. 12, Units = ns. 12, Conditions = (Note 1). 13, Symbol = TckF. 13, Characteristic = CLKO Fall Time. 13, Characteristic = CLKO Fall Time. 13, Min = -. 13, Typ = 35. 13, Max = 100. 13, Units = ns.",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\n13, Conditions = (Note 1). 14, Symbol = TckL2ioV. 14, Characteristic = CLKO \uf0af to Port Out Valid. 14, Characteristic = CLKO \uf0af to Port Out Valid. 14, Min = -. 14, Typ = -. 14, Max = 0.5 T CY + 20. 14, Units = ns. 14, Conditions = (Note 1). 15, Symbol = TioV2ckH. 15, Characteristic = Port In Valid before CLKO \uf0ad. 15, Characteristic = Port In Valid before CLKO \uf0ad. 15, Min = 0.25 T CY + 25. 15, Typ = -. 15, Max = -. 15, Units = ns. 15, Conditions = (Note 1). 16, Symbol = TckH2ioI. 16, Characteristic = Port In Hold after CLKO \uf0ad. 16, Characteristic = Port In Hold after CLKO \uf0ad. 16, Min = 0. 16, Typ = -. 16, Max = -. 16, Units = ns. 16, Conditions = (Note 1). 17, Symbol = TosH2ioV. 17, Characteristic = OSC1 \uf0ad (Q1 cycle) to",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\nPort Out Valid. 17, Characteristic = OSC1 \uf0ad (Q1 cycle) to Port Out Valid. 17, Min = -. 17, Typ = 50. 17, Max = 150. 17, Units = ns. 17, Conditions = . 18, Symbol = TosH2ioI. 18, Characteristic = OSC1 \uf0ad (Q2 cycle) to Port Input Invalid (I/O in hold time). 18, Characteristic = PIC18F6525/6621/ 8525/8621. 18, Min = 100. 18, Typ = -. 18, Max = -. 18, Units = ns. 18, Conditions = . 18A, Symbol = . 18A, Characteristic = . 18A, Characteristic = PIC18LF6X2X/8X2X. 18A, Min = 200. 18A, Typ = -. 18A, Max = -. 18A, Units = ns. 18A, Conditions = . 19, Symbol = TioV2osH. 19, Characteristic = Port Input Valid to OSC1 \uf0ad\uf020 (I/O in setup time). 19, Characteristic = Port Input Valid to OSC1 \uf0ad\uf020",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\n(I/O in setup time). 19, Min = 0. 19, Typ = -. 19, Max = -. 19, Units = ns. 19, Conditions = . 20, Symbol = TioR. 20, Characteristic = Port Output Rise Time. 20, Characteristic = PIC18F6525/6621/ 8525/8621. 20, Min = -. 20, Typ = 10. 20, Max = 25. 20, Units = ns. 20, Conditions = . 20A, Symbol = . 20A, Characteristic = . 20A, Characteristic = PIC18LF6X2X/8X2X. 20A, Min = -. 20A, Typ = -. 20A, Max = 60. 20A, Units = ns. 20A, Conditions = . 21, Symbol = TioF. 21, Characteristic = Port Output Fall Time. 21, Characteristic = PIC18F6525/6621/ 8525/8621. 21, Min = -. 21, Typ = 10. 21, Max = 25. 21, Units = ns. 21, Conditions = . 21A, Symbol = . 21A,",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\nCharacteristic = . 21A, Characteristic = PIC18LF6X2X/8X2X. 21A, Min = -. 21A, Typ = -. 21A, Max = 60. 21A, Units = ns. 21A, Conditions = \n\u2020 These parameters are asynchronous events not related to any internal clock edges.\nNote 1: Measurements are taken in RC mode, where CLKO output is 4 x TOSC.",
    "PIC18F6525/6621/8525/8621\n22\u2020, Symbol = TINP. 22\u2020, Characteristic = INT pin High or Low Time. 22\u2020, Min = T CY. 22\u2020, Typ = -. 22\u2020, Max = -. 22\u2020, Units = ns. 22\u2020, Conditions = . 23\u2020, Symbol = TRBP. 23\u2020, Characteristic = RB7:RB4 Change INT High or Low Time. 23\u2020, Min = T CY. 23\u2020, Typ = -. 23\u2020, Max = -. 23\u2020, Units = ns. 23\u2020, Conditions = . 24\u2020, Symbol = TRCP. 24\u2020, Characteristic = RC7:RC4 Change INT High or Low Time. 24\u2020, Min = 20. 24\u2020, Typ = . 24\u2020, Max = . 24\u2020, Units = ns. 24\u2020, Conditions = \n- \u2020 These parameters are asynchronous events not related to any internal clock edges.\nNote 1: Measurements are taken in RC mode, where CLKO output is 4 x TOSC.",
    "TABLE 27-9: PROGRAM MEMORY READ TIMING REQUIREMENTS\n150, Symbol = TadV2alL. 150, Characteristics = Address Out Valid to ALE \uf0af\uf020 (address setup time). 150, Min = 0.25 T CY - 10. 150, Typ = -. 150, Max = -. 150, Units = ns. 151, Symbol = TalL2adl. 151, Characteristics = ALE \uf0af to Address Out Invalid (address hold time). 151, Min = 5. 151, Typ = -. 151, Max = -. 151, Units = ns. 155, Symbol = TalL2oeL. 155, Characteristics = ALE \uf020\uf0af to OE \uf0af. 155, Min = 10. 155, Typ = 0.125 T CY. 155, Max = -. 155, Units = ns. 160, Symbol = TadZ2oeL. 160, Characteristics = AD high-Z to OE \uf0af\uf020 (bus release to OE). 160, Min = 0. 160, Typ = -. 160, Max = -. 160, Units = ns. 161, Symbol = ToeH2adD. 161, Characteristics = OE \uf0ad to AD Driven. 161, Min = 0.125 T CY - 5. 161, Typ = -. 161,",
    "TABLE 27-9: PROGRAM MEMORY READ TIMING REQUIREMENTS\nMax = -. 161, Units = ns. 162, Symbol = TadV2oeH. 162, Characteristics = LS Data Valid before OE \uf0ad\uf020 (data setup time). 162, Min = 20. 162, Typ = -. 162, Max = -. 162, Units = ns. 163, Symbol = ToeH2adl. 163, Characteristics = OE \uf0ad to Data In Invalid (data hold time). 163, Min = 0. 163, Typ = -. 163, Max = -. 163, Units = ns. 164, Symbol = TalH2alL. 164, Characteristics = ALE Pulse Width. 164, Min = -. 164, Typ = 0.25 T CY. 164, Max = -. 164, Units = ns. 165, Symbol = ToeL2oeH. 165, Characteristics = OE Pulse Width. 165, Min = 0.5 T CY - 5. 165, Typ = 0.5 T CY. 165, Max = -. 165, Units = ns. 166, Symbol = TalH2alH. 166, Characteristics = ALE \uf0ad to ALE \uf0ad (cycle time). 166, Min = 40 ns. 166, Typ",
    "TABLE 27-9: PROGRAM MEMORY READ TIMING REQUIREMENTS\n= T CY. 166, Max = -. 166, Units = ns",
    "PIC18F6525/6621/8525/8621\n167, Symbol = Tacc. 167, Characteristics = Address Valid to Data Valid. 167, Min = 0.75 T CY - 25. 167, Typ = -. 167, Max = -. 167, Units = ns. 168, Symbol = Toe. 168, Characteristics = OE \uf0af to Data Valid. 168, Min = . 168, Typ = -. 168, Max = 0.5 T CY - 25. 168, Units = ns. 169, Symbol = TalL2oeH. 169, Characteristics = ALE \uf020\uf0af to OE \uf0ad. 169, Min = 0.625 T CY - 10. 169, Typ = -. 169, Max = 0.625 T CY + 10. 169, Units = ns. 171, Symbol = TalH2csL. 171, Characteristics = Chip Enable Active to ALE \uf0af. 171, Min = -. 171, Typ = -. 171, Max = 10. 171, Units = ns. 171A, Symbol = TubL2oeH. 171A, Characteristics = AD Valid to Chip Enable Active. 171A, Min = 0.25 T CY - 20. 171A, Typ = -. 171A, Max",
    "PIC18F6525/6621/8525/8621\n= -. 171A, Units = ns",
    "TABLE 27-10: PROGRAM MEMORY WRITE TIMING REQUIREMENTS\n150, Symbol = TadV2alL. 150, Characteristics = Address Out Valid to ALE \uf0af\uf020 (address setup time). 150, Min = 0.25 T CY - 10. 150, Typ = -. 150, Max = -. 150, Units = ns. 151, Symbol = TalL2adl. 151, Characteristics = ALE \uf0af to Address Out Invalid (address hold time). 151, Min = 5. 151, Typ = -. 151, Max = -. 151, Units = ns. 153, Symbol = TwrH2adl. 153, Characteristics = WRn \uf0ad to Data Out Invalid (data hold time). 153, Min = 5. 153, Typ = -. 153, Max = -. 153, Units = ns. 154, Symbol = TwrL. 154, Characteristics = WRn Pulse Width. 154, Min = 0.5 T CY - 5. 154, Typ = 0.5 T CY. 154, Max = -. 154, Units = ns. 156, Symbol = TadV2wrH. 156, Characteristics = Data Valid before WRn \uf0ad\uf020 (data setup time). 156, Min = 0.5 T CY - 10.",
    "TABLE 27-10: PROGRAM MEMORY WRITE TIMING REQUIREMENTS\n156, Typ = -. 156, Max = -. 156, Units = ns. 157, Symbol = TbsV2wrL. 157, Characteristics = Byte Select Valid before WRn \uf0af\uf020 (byte select setup time). 157, Min = 0.25 T CY. 157, Typ = -. 157, Max = -. 157, Units = ns. 157A, Symbol = TwrH2bsI. 157A, Characteristics = WRn \uf0ad to Byte Select Invalid (byte select hold time). 157A, Min = 0.125 T CY - 5. 157A, Typ = -. 157A, Max = -. 157A, Units = ns. 166, Symbol = TalH2alH. 166, Characteristics = ALE \uf0ad to ALE \uf0ad (cycle time). 166, Min = -. 166, Typ = T CY. 166, Max = -. 166, Units = ns",
    "PIC18F6525/6621/8525/8621\n171, Symbol = TalH2csL. 171, Characteristics = Chip Enable Active to ALE \uf0af. 171, Min = -. 171, Typ = -. 171, Max = 10. 171, Units = ns. 171A, Symbol = TubL2oeH. 171A, Characteristics = AD Valid to Chip Enable Active. 171A, Min = 0.25 T CY - 20. 171A, Typ = -. 171A, Max = -. 171A, Units = ns",
    "TABLE 27-11: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\n30, Symbol = TmcL. 30, Characteristic = MCLR Pulse Width (low). 30, Min = 2. 30, Typ = -. 30, Max = -. 30, Units = \uf06d s. 30, Conditions = . 31, Symbol = TWDT. 31, Characteristic = Watchdog Timer Time-out Period (no postscaler). 31, Min = 7. 31, Typ = 18. 31, Max = 33. 31, Units = ms. 31, Conditions = . 32, Symbol = T OST. 32, Characteristic = Oscillation Start-up Timer Period. 32, Min = 1024 T OSC. 32, Typ = -. 32, Max = 1024 T OSC. 32, Units = -. 32, Conditions = T OSC = OSC1 period. 33, Symbol = TPWRT. 33, Characteristic = Power-up Timer Period. 33, Min = 28. 33, Typ = 72. 33, Max = 132. 33, Units = ms. 33, Conditions = . 34, Symbol =",
    "TABLE 27-11: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\nTIOZ. 34, Characteristic = I/O High-impedance from MCLRLow or Watchdog Timer Reset. 34, Min = -. 34, Typ = 2. 34, Max = -. 34, Units = \uf06d s. 34, Conditions = . 35, Symbol = TBOR. 35, Characteristic = Brown-out Reset Pulse Width. 35, Min = 200. 35, Typ = -. 35, Max = -. 35, Units = \uf06d s. 35, Conditions = VDD \uf0a3 BVDD (see D005). 36, Symbol = TIRVST. 36, Characteristic = Time for Internal Reference Voltage to become stable. 36, Min = -. 36, Typ = 20. 36, Max = 50. 36, Units = \uf06d s. 36, Conditions = . 37, Symbol = TLVD. 37, Characteristic = Low-Voltage Detect Pulse Width. 37, Min = 200. 37, Typ = -. 37, Max = -. 37, Units = \uf06d s. 37, Conditions = VDD \uf0a3 VLVD",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n40, Symbol = Tt0H. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = No prescaler. 40, Min = 0.5 T CY + 20. 40, Max = -. 40, Units = ns. 40, Conditions = . 40, Symbol = Tt0H. 40, Characteristic = . 40, Characteristic = . 40, Characteristic = With prescaler. 40, Min = 10. 40, Max = -. 40, Units = ns. 40, Conditions = . 41, Symbol = Tt0L. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = No prescaler. 41, Min = 0.5 T CY + 20. 41, Max = -. 41, Units = ns. 41, Conditions = . 41, Symbol = Tt0L. 41, Characteristic = . 41, Characteristic = . 41, Characteristic = With prescaler. 41, Min = 10. 41, Max = -. 41, Units = ns. 41, Conditions = . 42, Symbol =",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nTt0P. 42, Characteristic = T0CKI Period. 42, Characteristic = T0CKI Period. 42, Characteristic = No prescaler. 42, Min = T CY + 10. 42, Max = -. 42, Units = ns. 42, Conditions = . 42, Symbol = Tt0P. 42, Characteristic = . 42, Characteristic = . 42, Characteristic = With prescaler. 42, Min = Greater of: 20 ns or T CY + 40 N. 42, Max = -. 42, Units = ns. 42, Conditions = N = prescale value (1, 2, 4,..., 256). 45, Symbol = Tt1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Synchronous, no prescaler. 45, Characteristic = Synchronous, no prescaler. 45, Min = 0.5 T CY + 20. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Synchronous, with prescaler.",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n45, Characteristic = PIC18F6525/6621/ 8525/8621. 45, Min = 10. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Synchronous, with prescaler. 45, Characteristic = PIC18LF6X2X/8X2X. 45, Min = 25. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18F6525/6621/ 8525/8621. 45, Min = 30. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18LF6X2X/8X2X. 45, Min = 50. 45, Max = -. 45,",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nUnits = ns. 45, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Synchronous, no prescaler. 46, Characteristic = Synchronous, no prescaler. 46, Min = 0.5 T CY + 5. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18F6525/6621/ 8525/8621. 46, Min = 10. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18LF6X2X/8X2X. 46, Min = 25. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic =",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nT13CKI Low Time. 46, Characteristic = Asynchronous. 46, Characteristic = PIC18F6525/6621/ 8525/8621. 46, Min = 30. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Asynchronous. 46, Characteristic = PIC18LF6X2X/8X2X. 46, Min = TBD. 46, Max = TBD. 46, Units = ns. 46, Conditions = . 47, Symbol = Tt1P. 47, Characteristic = T13CKI Input Period. 47, Characteristic = Synchronous. 47, Characteristic = Synchronous. 47, Min = Greater of: 20 ns or T CY + 40 N. 47, Max = -. 47, Units = ns. 47, Conditions = N = prescale value (1, 2, 4, 8). 47, Symbol = Tt1P. 47, Characteristic = . 47, Characteristic = Asynchronous. 47, Characteristic =",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nAsynchronous. 47, Min = 60. 47, Max = -. 47, Units = ns. 47, Conditions = . 47, Symbol = Ft1. 47, Characteristic = T13CKI Oscillator Input Frequency Range. 47, Characteristic = T13CKI Oscillator Input Frequency Range. 47, Characteristic = T13CKI Oscillator Input Frequency Range. 47, Min = DC. 47, Max = 50. 47, Units = kHz. 47, Conditions = . 48, Symbol = Tcke2tmrI. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Min = 2 T OSC. 48, Max = 7 T OSC. 48, Units = -. 48, Conditions = \nLegend:\nTBD = To Be Determined",
    "TABLE 27-13: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL ECCP/CCP MODULES)\n50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = No prescaler. 50, Characteristic = No prescaler. 50, Min = 0.5 T CY + 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = With prescaler. 50, Characteristic = PIC18F6525/6621/ 8525/8621. 50, Min = 10. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = With prescaler. 50, Characteristic = PIC18LF6X2X/8X2X. 50, Min = 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = No prescaler. 51, Characteristic = No",
    "TABLE 27-13: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL ECCP/CCP MODULES)\nprescaler. 51, Min = 0.5 T CY + 20. 51, Max = -. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = With prescaler. 51, Characteristic = PIC18F6525/6621/ 8525/8621. 51, Min = 10. 51, Max = -. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = With prescaler. 51, Characteristic = PIC18LF6X2X/8X2X. 51, Min = 20. 51, Max = -. 51, Units = ns. 51, Conditions = . 52, Symbol = TccP. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Min = 3 T CY + 40 N. 52, Max = -. 52, Units = ns. 52, Conditions = N",
    "TABLE 27-13: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL ECCP/CCP MODULES)\n= prescale value (1,4 or 16). 53, Symbol = TccR. 53, Characteristic = CCPx Output Rise Time. 53, Characteristic = CCPx Output Rise Time. 53, Characteristic = PIC18F6525/6621/ 8525/8621. 53, Min = -. 53, Max = 25. 53, Units = ns. 53, Conditions = . 53, Symbol = TccR. 53, Characteristic = . 53, Characteristic = . 53, Characteristic = PIC18LF6X2X/8X2X. 53, Min = -. 53, Max = 45. 53, Units = ns. 53, Conditions = . 54, Symbol = TccF. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = PIC18F6525/6621/ 8525/8621. 54, Min = -. 54, Max = 25. 54, Units = ns. 54, Conditions = . 54, Symbol = TccF. 54, Characteristic = . 54, Characteristic = . 54, Characteristic",
    "TABLE 27-13: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL ECCP/CCP MODULES)\n= PIC18LF6X2X/8X2X. 54, Min = -. 54, Max = 45. 54, Units = ns. 54, Conditions = ",
    "TABLE 27-14: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F8525/8621)\n62, Symbol = TdtV2wrH. 62, Characteristic = Data In Valid before WR \uf0ad or CS \uf0ad (setup time). 62, Characteristic = Data In Valid before WR \uf0ad or CS \uf0ad (setup time). 62, Min = 20 25. 62, Max = - -. 62, Units = ns ns. 62, Conditions = Extended Temp. range. 63, Symbol = TwrH2dtI. 63, Characteristic = WR \uf0ad or CS \uf0ad to Data-in Invalid (hold time). 63, Characteristic = PIC18F6525/6621/ 8525/8621. 63, Min = 20. 63, Max = -. 63, Units = ns. 63, Conditions = . 63, Symbol = TwrH2dtI. 63, Characteristic = . 63, Characteristic = PIC18LF6X2X/8X2X. 63, Min = 35. 63, Max = -. 63, Units = ns. 63, Conditions = . 64, Symbol = TrdL2dtV. 64, Characteristic = RD \uf0af and CS \uf0af to Data-out Valid. 64, Characteristic = RD \uf0af and CS \uf0af to Data-out Valid. 64,",
    "TABLE 27-14: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F8525/8621)\nMin = - -. 64, Max = 80 90. 64, Units = ns ns. 64, Conditions = Extended Temp. range. 65, Symbol = TrdH2dtI. 65, Characteristic = RD \uf0ad or CS \uf0af to Data-out Invalid. 65, Characteristic = RD \uf0ad or CS \uf0af to Data-out Invalid. 65, Min = 10. 65, Max = 30. 65, Units = ns. 65, Conditions = . 66, Symbol = TibfINH. 66, Characteristic = Inhibit of the IBF Flag bit being cleared from WR \uf0ad or CS \uf0ad. 66, Characteristic = Inhibit of the IBF Flag bit being cleared from WR \uf0ad or CS \uf0ad. 66, Min = -. 66, Max = 3 T CY. 66, Units = . 66, Conditions = ",
    "FIGURE 27-14: EXAMPLE SPI\u2122 MASTER MODE TIMING (CKE = 0\n)",
    "TABLE 27-15: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 0 )\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = . 71A, Characteristic = . 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK Input Low Time. 72, Characteristic = Continuous. 72, Min = 1.25 T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = . 72A, Characteristic =",
    "TABLE 27-15: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 0 )\n(Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1)\nNote 1:\nRequires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "PIC18F6525/6621/8525/8621\n73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output",
    "PIC18F6525/6621/8525/8621\nRise Time. 75, Characteristic = PIC18F6525/6621/ 8525/8621. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18LF6X2X/8X2X. 75, Min = -. 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18F6525/6621/ 8525/8621. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic",
    "PIC18F6525/6621/8525/8621\n= PIC18LF6X2X/8X2X. 78, Min = -. 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18F6525/6621/ 8525/8621. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18LF6X2X/8X2X. 80, Min = -. 80, Max = 100. 80, Units = ns. 80, Conditions = \nNote",
    "PIC18F6525/6621/8525/8621\n1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "FIGURE 27-15: EXAMPLE SPI\u2122 MASTER MODE TIMING (CKE = 1\n)",
    "TABLE 27-16: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 1\n)\n71, Symbol = TscH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = TscH. 71A, Characteristic = SCK Input High Time (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK Input Low Time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25 T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = TscL. 72A, Characteristic = SCK Input Low Time (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1).",
    "TABLE 27-16: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 1\n73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic",
    "TABLE 27-16: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 1\n= SDO Data Output Rise Time. 75, Characteristic = PIC18F6525/6621/ 8525/8621. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18LF6X2X/8X2X. 75, Min = . 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18F6525/6621/ 8525/8621. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise",
    "TABLE 27-16: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 1\nTime (Master mode). 78, Characteristic = PIC18LF6X2X/8X2X. 78, Min = . 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18F6525/6621/ 8525/8621. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18LF6X2X/8X2X. 80, Min = . 80, Max = 100. 80, Units",
    "TABLE 27-16: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 1\n= ns. 80, Conditions = . 81, Symbol = TdoV2scH, TdoV2scL. 81, Characteristic = SDO Data Output Setup to SCK Edge. 81, Characteristic = SDO Data Output Setup to SCK Edge. 81, Min = T CY. 81, Max = -. 81, Units = ns. 81, Conditions = \nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "FIGURE 27-16: EXAMPLE SPI\u2122 SLAVE MODE TIMING (CKE = 0\n)",
    "TABLE 27-17: EXAMPLE SPI\u2122 MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n)",
    "TABLE 27-17: EXAMPLE SPI\u2122 MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = TscH. 71A, Characteristic = SCK Input High Time (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK Input Low Time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25 T CY + 30. 72, Max = -. 72, Units = ns. 72,",
    "TABLE 27-17: EXAMPLE SPI\u2122 MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nConditions = . 72A, Symbol = TscL. 72A, Characteristic = SCK Input Low Time (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL,",
    "TABLE 27-17: EXAMPLE SPI\u2122 MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nTscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18F6525/6621/ 8525/8621. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18F6525/6621/ 8525/8621. 75, Min = . 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol =",
    "TABLE 27-17: EXAMPLE SPI\u2122 MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nTssH2doZ. 77, Characteristic = SS \uf0ad to SDO Output High-impedance. 77, Characteristic = SS \uf0ad to SDO Output High-impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18F6525/6621/ 8525/8621. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18F6525/6621/ 8525/8621. 78, Min = . 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns.",
    "TABLE 27-17: EXAMPLE SPI\u2122 MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n79, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18F6525/6621/ 8525/8621. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18F6525/6621/ 8525/8621. 80, Min = . 80, Max = 100. 80, Units = ns. 80, Conditions = . 83, Symbol = TscH2ssH, TscL2ssH. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Min = 1.5 T CY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = \nNote",
    "TABLE 27-17: EXAMPLE SPI\u2122 MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "FIGURE 27-17: EXAMPLE SPI\u2122 SLAVE MODE TIMING (CKE = 1\n)",
    "TABLE 27-18: EXAMPLE SPI\u2122 SLAVE MODE REQUIREMENTS (CKE = 1\n)\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71 71A, Symbol = TscH. 71 71A, Characteristic = SCK Input High Time (Slave mode). 71 71A, Characteristic = Continuous. 71 71A, Min = 1.25 T CY + 30. 71 71A, Max = -. 71 71A, Units = ns. 71 71A, Conditions = . , Symbol = . , Characteristic = . , Characteristic = Single Byte. , Min = 40. , Max = -. , Units = ns. , Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK Input Low Time. 72, Characteristic = Continuous. 72, Min = 1.25 T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = . 72A, Characteristic = (Slave",
    "TABLE 27-18: EXAMPLE SPI\u2122 SLAVE MODE REQUIREMENTS (CKE = 1\nmode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18F6525/6621/ 8525/8621. 75, Min",
    "TABLE 27-18: EXAMPLE SPI\u2122 SLAVE MODE REQUIREMENTS (CKE = 1\n= -. 75, Max = 25. 75, Units = ns. 75, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18LF6X2X/8X2X. , Min = . , Max = 45. , Units = ns. , Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = TssH2doZ. 77, Characteristic = SS \uf0ad to SDO Output High-impedance. 77, Characteristic = SS \uf0ad to SDO Output High-impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18F6525/6621/ 8525/8621. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . ,",
    "TABLE 27-18: EXAMPLE SPI\u2122 SLAVE MODE REQUIREMENTS (CKE = 1\nSymbol = . , Characteristic = . , Characteristic = PIC18LF6X2X/8X2X. , Min = -. , Max = 45. , Units = ns. , Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDOData Output Valid after SCK Edge. 80, Characteristic = PIC18F6525/6621/ 8525/8621. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18LF6X2X/8X2X. , Min = -. , Max = 100. , Units = ns. , Conditions = ",
    "TABLE 27-18: EXAMPLE SPI\u2122 SLAVE MODE REQUIREMENTS (CKE = 1\nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "PIC18F6525/6621/8525/8621\n82, Symbol = TssL2doV. 82, Characteristic = SDO Data Output Valid after SS \uf0af Edge. 82, Characteristic = PIC18F6525/6621/ 8525/8621. 82, Min = -. 82, Max = 50. 82, Units = ns. 82, Conditions = . 82, Symbol = TssL2doV. 82, Characteristic = . 82, Characteristic = PIC18LF6X2X/8X2X. 82, Min = -. 82, Max = 100. 82, Units = ns. 82, Conditions = . 83, Symbol = TscH2ssH, TscL2ssH. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Characteristic = . 83, Min = 1.5 T CY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = \nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "TABLE 27-19: I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 4700. 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. , Symbol = . , Characteristic = . , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = . 91, Symbol = THD: STA. 91, Characteristic = Start Condition. 91, Characteristic = 100 kHz mode. 91, Min = 4000. 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first. , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = clock pulse is generated. 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition. 92, Characteristic = 100 kHz mode. 92, Min = 4700. 92, Max = -. 92, Units = ns. 92, Conditions = . , Symbol = . ,",
    "TABLE 27-19: I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\nCharacteristic = Setup Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = . 93, Symbol = THD: STO. 93, Characteristic = Stop Condition. 93, Characteristic = 100 kHz mode. 93, Min = 4000. 93, Max = -. 93, Units = ns. 93, Conditions = . , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = ",
    "TABLE 27-20: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 4.0. 100, Max = -. 100, Units = \uf06d s. 100, Conditions = PIC18F6525/6621/8525/ 8621 must operate at a minimum of 1.5 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 0.6. 100, Max = -. 100, Units = \uf06d s. 100, Conditions = PIC18F6525/6621/8525/ 8621 must operate at a minimum of 10 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = MSSP module. 100, Min = 1.5 T CY. 100, Max = -. 100, Units = . 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 4.7. 101, Max = -. 101, Units = \uf06d s. 101, Conditions =",
    "TABLE 27-20: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\nPIC18F6525/6621/8525/ 8621 must operate at a minimum of 1.5 MHz. 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 400 kHz mode. 101, Min = 1.3. 101, Max = -. 101, Units = \uf06d s. 101, Conditions = PIC18F6525/6621/8525/ 8621 must operate at a minimum of 10 MHz. 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = MSSP module. 101, Min = 1.5 T CY. 101, Max = -. 101, Units = . 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units =",
    "TABLE 27-20: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\nns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = . 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 4.7. 90, Max = -. 90, Units = \uf06d s. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 0.6. 90, Max = -. 90, Units = \uf06d s.",
    "TABLE 27-20: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min = 4.0. 91, Max = -. 91, Units = \uf06d s. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 0.6. 91, Max = -. 91, Units = \uf06d s. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = \uf06d s. 106, Conditions = . 107, Symbol = T",
    "TABLE 27-20: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\nSU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 4.7. 92, Max = -. 92, Units = \uf06d s. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 0.6. 92, Max = -. 92, Units = \uf06d s. 92, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max =",
    "TABLE 27-20: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n3500. 109, Units = ns. 109, Conditions = (Note 1). 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 400 kHz mode. 109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = (Note 1). 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = \uf06d s. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = \uf06d s. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus Capacitive Loading. D102, Characteristic = Bus Capacitive Loading. D102, Min = -. D102, Max = 400.",
    "TABLE 27-20: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\nD102, Units = pF. D102, Conditions = \nNote 1: As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2: A Fast mode I 2 C\u2122 bus device can be used in a Standard mode I 2 C bus system but the requirement TSU:DAT \uf0b3 250 ns must then be met. This will automatically be the case if the device does not stretch the low period of the SCL signal. If such a device does stretch the low period of the SCL signal, it must output the next data bit to the SDA line.\nTR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification) before the SCL line is released.",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n\nNote 1: Maximum pin capacitance = 10 pF for all I 2 C pins.",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min = 2(T",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\nOSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = .",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n92, Conditions = ns. 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 93, Symbol = THD: STO. 93, Characteristic = Stop Condition Hold Time. 93, Characteristic = 100 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = . 93, Symbol = THD: STO. 93, Characteristic = Stop Condition Hold Time. 93, Characteristic = 400 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93,",
    "TABLE 27-21: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\nMax = -. 93, Units = ns. 93, Conditions = . 93, Symbol = THD: STO. 93, Characteristic = Stop Condition Hold Time. 93, Characteristic = 1 MHz mode (1). 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = ",
    "TABLE 27-22: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 1 MHz mode (1). 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low",
    "TABLE 27-22: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nTime. 101, Characteristic = 400 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 1 MHz mode (1). 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA",
    "TABLE 27-22: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nand SCL Rise Time. 102, Characteristic = 1 MHz mode (1). 102, Min = -. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 1 MHz mode (1). 103, Min = -. 103, Max = 100. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400",
    "TABLE 27-22: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\npF. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min = 2(T",
    "TABLE 27-22: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nOSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD: DAT.",
    "TABLE 27-22: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n106, Characteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = ms. 106, Conditions = . 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 1 MHz mode (1). 106, Min = TBD. 106, Max = -. 106, Units = ns. 106, Conditions = . 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 1 MHz mode (1). 107, Min = TBD. 107, Max =",
    "TABLE 27-22: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n-. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500.",
    "TABLE 27-22: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n109, Units = ns. 109, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 400 kHz mode. 109, Min = -. 109, Max = 1000. 109, Units = ns. 109, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 1 MHz mode (1). 109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = . 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free",
    "TABLE 27-22: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nTime. 110, Characteristic = 1 MHz mode (1). 110, Min = TBD. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB Bus Capacitive. D102, Characteristic = CB Bus Capacitive. D102, Characteristic = Loading -. D102, Min = Loading -. D102, Max = 400. D102, Units = pF. D102, Conditions = \nLegend:\nTBD = To Be Determined\nNote",
    "TABLE 27-22: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n1: Maximum pin capacitance = 10 pF for all I 2 C\u2122 pins.\n2: A Fast mode I 2 C bus device can be used in a Standard mode I 2 C bus system but parameter #107 \uf0b3 250 ns must then be met. This will automatically be the case if the device does not stretch the low period of the SCL signal. If such a device does stretch the low period of the SCL signal, it must output the next data bit to the SDA line, parameter #102.+ parameter #107 = 1000 + 250 = 1250 ns (for 100 kHz mode), before the SCL line is released.",
    "TABLE 27-23: EUSART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n120, Symbol = TckH2dtV. 120, Characteristic = SYNC XMIT (Master and Slave) Clock High to Data Out Valid. 120, Characteristic = PIC18F6525/6621/ 8525/8621. 120, Min = -. 120, Max = 40. 120, Units = ns. 120, Conditions = . 120, Symbol = TckH2dtV. 120, Characteristic = SYNC XMIT (Master and Slave) Clock High to Data Out Valid. 120, Characteristic = PIC18LF6X2X/8X2X. 120, Min = -. 120, Max = 100. 120, Units = ns. 120, Conditions = . 121, Symbol = Tckrf. 121, Characteristic = Clock Out Rise Time and Fall Time (Master mode). 121, Characteristic = PIC18F6525/6621/ 8525/8621. 121, Min = -. 121, Max = 20. 121, Units = ns. 121, Conditions = . 121, Symbol = Tckrf. 121, Characteristic = Clock Out Rise Time and Fall Time (Master mode). 121, Characteristic =",
    "TABLE 27-23: EUSART SYNCHRONOUS TRANSMISSION REQUIREMENTS\nPIC18LF6X2X/8X2X. 121, Min = -. 121, Max = 50. 121, Units = ns. 121, Conditions = . 122, Symbol = Tdtrf. 122, Characteristic = Data Out Rise Time and Fall Time. 122, Characteristic = PIC18F6525/6621/ 8525/8621. 122, Min = -. 122, Max = 20. 122, Units = ns. 122, Conditions = . 122, Symbol = Tdtrf. 122, Characteristic = Data Out Rise Time and Fall Time. 122, Characteristic = PIC18LF6X2X/8X2X. 122, Min = -. 122, Max = 50. 122, Units = ns. 122, Conditions = ",
    "TABLE 27-24: EUSART SYNCHRONOUS RECEIVE REQUIREMENTS\n125, Symbol = TdtV2ckl. 125, Characteristic = SYNC RCV (Master and Slave) Data Hold before CKx \uf0af (DTx hold time). 125, Min = 10. 125, Max = -. 125, Units = ns. 125, Conditions = . 126, Symbol = TckL2dtl. 126, Characteristic = Data Hold after CKx \uf0af (DTx hold time). 126, Min = 15. 126, Max = -. 126, Units = ns. 126, Conditions = ",
    "PIC18LF6X2X/8X2X (INDUSTRIAL)\nA01, Symbol = NR. A01, Characteristic = Resolution. A01, Characteristic = Resolution. A01, Min = - -. A01, Typ = - -. A01, Max = 10 TBD. A01, Units = bit bit. A01, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A03, Symbol = EIL. A03, Characteristic = Integral Linearity Error. A03, Characteristic = Integral Linearity Error. A03, Min = - -. A03, Typ = - -. A03, Max = <\u00b11 TBD. A03, Units = LSb LSb. A03, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A04, Symbol = EDL. A04, Characteristic = Differential Linearity Error. A04, Characteristic = Differential Linearity Error. A04, Min = - -. A04, Typ = - -. A04, Max = <\u00b11 TBD.",
    "PIC18LF6X2X/8X2X (INDUSTRIAL)\nA04, Units = LSb LSb. A04, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A05, Symbol = EFS. A05, Characteristic = Full Scale Error. A05, Characteristic = Full Scale Error. A05, Min = - -. A05, Typ = - -. A05, Max = <\u00b11 TBD. A05, Units = LSb LSb. A05, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A06, Symbol = EOFF. A06, Characteristic = Offset Error. A06, Characteristic = Offset Error. A06, Min = - -. A06, Typ = - -. A06, Max = <\u00b11 TBD. A06, Units = LSb LSb. A06, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A10, Symbol = -. A10, Characteristic =",
    "PIC18LF6X2X/8X2X (INDUSTRIAL)\nMonotonicity. A10, Characteristic = Monotonicity. A10, Min = guaranteed (3). A10, Typ = guaranteed (3). A10, Max = guaranteed (3). A10, Units = -. A10, Conditions = VSS \uf0a3 VAIN \uf0a3 VREF. A20 A20A, Symbol = VREF. A20 A20A, Characteristic = Reference Voltage (V REFH - VREFL ). A20 A20A, Characteristic = Reference Voltage (V REFH - VREFL ). A20 A20A, Min = 0V 3V. A20 A20A, Typ = - -. A20 A20A, Max = - -. A20 A20A, Units = V V. A20 A20A, Conditions = For 10-bit resolution. A21, Symbol = VREFH. A21, Characteristic = Reference Voltage High. A21, Characteristic = Reference Voltage High. A21, Min = AVSS. A21, Typ = -. A21, Max = AVDD + 0.3V. A21, Units = V. A21, Conditions",
    "PIC18LF6X2X/8X2X (INDUSTRIAL)\n= . A22, Symbol = VREFL. A22, Characteristic = Reference Voltage Low. A22, Characteristic = Reference Voltage Low. A22, Min = AVSS - 0.3V. A22, Typ = -. A22, Max = AVDD. A22, Units = V. A22, Conditions = . A25, Symbol = VAIN. A25, Characteristic = Analog Input Voltage. A25, Characteristic = Analog Input Voltage. A25, Min = AVSS - 0.3V. A25, Typ = -. A25, Max = VREF + 0.3V. A25, Units = V. A25, Conditions = . A30, Symbol = ZAIN. A30, Characteristic = Recommended Impedance of Analog Voltage Source. A30, Characteristic = Recommended Impedance of Analog Voltage Source. A30, Min = -. A30, Typ = -. A30, Max = 10.0. A30, Units = k \uf057. A30, Conditions = . A40, Symbol = I AD. A40, Characteristic = A/D Conversion Current (V DD). A40, Characteristic",
    "PIC18LF6X2X/8X2X (INDUSTRIAL)\n= PIC18F6525/6621/ 8525/8621. A40, Min = -. A40, Typ = 180. A40, Max = -. A40, Units = \uf06d A. A40, Conditions = Average current consumption when A/D is on (Note 1). A40, Symbol = I AD. A40, Characteristic = A/D Conversion Current (V DD). A40, Characteristic = PIC18LF6X2X/8X2X. A40, Min = -. A40, Typ = 90. A40, Max = -. A40, Units = \uf06d A. A40, Conditions = Average current consumption when A/D is on (Note 1). A50, Symbol = I REF. A50, Characteristic = VREF Input Current (Note 2). A50, Characteristic = VREF Input Current (Note 2). A50, Min = - -. A50, Typ = - -. A50, Max = 5 150. A50, Units = \uf06d A \uf06d A. A50, Conditions = During VAIN acquisition. During A/D conversion cycle.\nLegend:",
    "PIC18LF6X2X/8X2X (INDUSTRIAL)\nTBD = To Be Determined\nNote 1: When A/D is off, it will not consume any current other than minor leakage current. The power-down current spec includes any such leakage from the A/D module. VREF current is from RA2/AN2/VREF- and RA3/AN3/VREF+ pins or AVDD and AVSS pins, whichever is selected as reference input.\n2: Vss \uf0a3 VAIN \uf0a3 VREF\n3: The A/D conversion result never decreases with an increase in the input voltage and has no missing codes.",
    "FIGURE 27-24: A/D CONVERSION TIMING\nNote 1: If the A/D clock source is selected as RC, a time of TCY is added before the A/D clock starts.\nThis allows the SLEEP instruction to be executed.\n2: This is a minimal RC delay (typically 100 ns) which also disconnects the holding capacitor from the analog input.",
    "TABLE 27-26: A/D CONVERSION REQUIREMENTS\n130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18F6525/6621/ 8525/8621. 130, Min = 1.6. 130, Max = 20 (5). 130, Units = \uf06d s. 130, Conditions = T OSC based, VREF \uf0b3 3.0V. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18LF6X2X/8X2X. 130, Min = 3.0. 130, Max = 20 (5). 130, Units = \uf06d s. 130, Conditions = T OSC based, VREF full range. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18F6525/6621/ 8525/8621. 130, Min = 2.0. 130, Max = 6.0. 130, Units = \uf06d s. 130, Conditions = A/D RC mode. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic =",
    "TABLE 27-26: A/D CONVERSION REQUIREMENTS\nPIC18LF6X2X/8X2X. 130, Min = 3.0. 130, Max = 9.0. 130, Units = \uf06d s. 130, Conditions = A/D RC mode. 131, Symbol = T CNV. 131, Characteristic = Conversion Time (not including acquisition time) (Note 1). 131, Characteristic = Conversion Time (not including acquisition time) (Note 1). 131, Min = 11. 131, Max = 12. 131, Units = T AD. 131, Conditions = . 132, Symbol = T ACQ. 132, Characteristic = Acquisition Time (Note 3). 132, Characteristic = Acquisition Time (Note 3). 132, Min = 15 10. 132, Max = - -. 132, Units = \uf06d s \uf06d s. 132, Conditions = -40 \uf0b0 C \uf0a3 Temp \uf0a3 +125 \uf0b0 C 0 \uf0b0 C \uf0a3 Temp \uf0a3 +125 \uf0b0 C. 135, Symbol = T SWC. 135, Characteristic = Switching Time from Convert \uf0ae Sample. 135, Characteristic = Switching Time from Convert \uf0ae Sample. 135, Min = -. 135, Max = (Note 4). 135, Units = . 135, Conditions = . 136, Symbol = T AMP. 136, Characteristic =",
    "TABLE 27-26: A/D CONVERSION REQUIREMENTS\nAmplifier Settling Time (Note 2). 136, Characteristic = Amplifier Settling Time (Note 2). 136, Min = 1. 136, Max = -. 136, Units = \uf06d s. 136, Conditions = This may be used if the 'new' input voltage has not changed by more than 1 LSb (i.e., 5 mV@5.12V) from the last sampled voltage (as stated on CHOLD).\nNote 1: ADRES register may be read on the following TCY cycle.\n2: See Section 20.0 '10-Bit Analog-to-Digital Converter (A/D) Module' for minimum conditions when input voltage has changed more than 1 LSb.\n3: The time for the holding capacitor to acquire the 'New' input voltage when the voltage changes full scale after the conversion (AVDD to AVSS, or AVSS to AVDD). The source impedance (RS) on the input channels is 50 \uf057 .\n4: On the next Q4 cycle of the device clock.\n5: The time of the A/D clock period is dependent on the device frequency and the TAD clock divider.\nNOTES:",
    "28.0 DC AND AC CHARACTERISTICS GRAPHS AND TABLES\nNote:\nThe graphs and tables provided following this note are a statistical summary based on a limited number of samples and are provided for informational purposes only. The performance characteristics listed herein are not tested or guaranteed. In some graphs or tables, the data presented may be outside the specified operating range (e.g., outside specified power supply range) and therefore, outside the warranted range.\n'Typical' represents the mean of the distribution at 25 C. 'Maximum' or 'minimum' represents (mean + 3 \uf0b0 \uf073 ) or (mean - 3 \uf073 ) respectively, where \uf073 is a standard deviation, over the whole temperature range.\nFIGURE 28-1: TYPICAL IDD vs. FOSC OVER VDD (HS MODE)\nFIGURE 28-2: MAXIMUM IDD vs. FOSC OVER VDD (HS MODE)",
    "PIC18F6525/6621/8525/8621\nFIGURE 28-3: TYPICAL IDD vs. FOSC OVER VDD (HS/PLL MODE)\nFIGURE 28-4: MAXIMUM IDD vs. FOSC OVER VDD (HS/PLL MODE)\nFIGURE 28-5:\nTYPICAL IDD vs. FOSC OVER VDD (XT MODE)\nFIGURE 28-6: MAXIMUM IDD vs. FOSC OVER VDD (XT MODE)",
    "FIGURE 28-7: TYPICAL IDD vs. FOSC OVER VDD (LP MODE) ,\nFIGURE 28-8: MAXIMUM IDD vs. FOSC OVER VDD (LP MODE)",
    "PIC18F6525/6621/8525/8621\nFIGURE 28-9: TYPICAL IDD vs. FOSC OVER VDD (EC MODE)\nFIGURE 28-10: MAXIMUM IDD vs. FOSC OVER VDD (EC MODE)\nFIGURE 28-12: AVERAGE FOSC vs. VDD FOR VARIOUS Rs (RC MODE, C = 20 pF, TEMP = 25\u00b0C)\nFIGURE 28-14: AVERAGE FOSC vs. VDD FOR VARIOUS Rs (RC MODE, C = 300 pF, TEMP = 25\u00b0C)\nFIGURE 28-16: TYPICAL AND MAXIMUM \uf044 IBOR vs. VDD OVER TEMPERATURE, VBOR = 2.00-2.16V\nFIGURE 28-17: IT1OSC vs. VDD (SLEEP MODE, TIMER1 AND OSCILLATOR ENABLED)\nFIGURE 28-18: IPD vs. VDD (SLEEP MODE, WDT ENABLED)\nFIGURE 28-19: TYPICAL, MINIMUM AND MAXIMUM WDT PERIOD vs. VDD\nFIGURE 28-20: \uf044 ILVD vs. VDD OVER TEMPERATURE, VLVD = 4.5-4.78V",
    "PIC18F6525/6621/8525/8621\nFIGURE 28-22: TYPICAL, MINIMUM AND MAXIMUM VOH vs. IOH (VDD = 3V, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 28-24: TYPICAL AND MAXIMUM VOL vs. IOL (VDD = 3V, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 28-25: MINIMUM AND MAXIMUM VIN vs. VDD (ST INPUT, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 28-26: MINIMUM AND MAXIMUM VIN vs. VDD (TTL INPUT, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 28-27: MINIMUM AND MAXIMUM VIN vs. VDD (I 2 C INPUT, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 28-28: A/D NONLINEARITY vs. VREFH (VDD = VREFH, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 28-29: A/D NONLINEARITY vs. VREFH (VDD = 5V, -40 C TO +125 C) \uf0b0 \uf0b0\nNOTES:",
    "Example\nLegend: XX...X Y YY WW NNN 3 e, 1 = Customer-specific information Year code (last digit of calendar year) Year code (last 2 digits of calendar year) Week code (week of January 1 is week '01') Alphanumeric traceability code Pb-free JEDEC designator for Matte Tin (Sn) This package is Pb-free. The Pb-free JEDEC designator ( ) can be found on the outer packaging for this package. 3 e. : In the event the full Microchip part number cannot be marked on one line, it will be carried over to the next line, thus limiting the number of available characters for customer-specific information., 1 = : In the event the full Microchip part number cannot be marked on one line, it will be carried over to the next line, thus limiting the number of available characters for customer-specific information.",
    "29.2 Package Details\nThe following sections give the technical details of the packages.",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNumber of Pins, Dimension Limits = n. Number of Pins, INCHES.MIN = 64. Number of Pins, INCHES.NOM = 64. Number of Pins, INCHES.MAX = 64. Number of Pins, MILLIMETERS*.MIN = 64. Number of Pins, MILLIMETERS*.NOM = 64. Number of Pins, MILLIMETERS*.MAX = 64. Pitch, Dimension Limits = p. Pitch, INCHES.MIN = . Pitch, INCHES.NOM = .020. Pitch, INCHES.MAX = . Pitch, MILLIMETERS*.MIN = . Pitch, MILLIMETERS*.NOM = 0.50. Pitch, MILLIMETERS*.MAX = . Pins per Side, Dimension Limits = n1. Pins per Side, INCHES.MIN = . Pins per Side, INCHES.NOM = 16. Pins per Side, INCHES.MAX = . Pins per Side, MILLIMETERS*.MIN = . Pins per Side, MILLIMETERS*.NOM = 16. Pins per Side, MILLIMETERS*.MAX = . Overall Height, Dimension Limits = A. Overall",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nHeight, INCHES.MIN = .039. Overall Height, INCHES.NOM = .043. Overall Height, INCHES.MAX = .047. Overall Height, MILLIMETERS*.MIN = 1.00. Overall Height, MILLIMETERS*.NOM = 1.10. Overall Height, MILLIMETERS*.MAX = 1.20. Molded Package Thickness, Dimension Limits = A2. Molded Package Thickness, INCHES.MIN = .037. Molded Package Thickness, INCHES.NOM = .039. Molded Package Thickness, INCHES.MAX = .041. Molded Package Thickness, MILLIMETERS*.MIN = 0.95. Molded Package Thickness, MILLIMETERS*.NOM = 1.00. Molded Package Thickness, MILLIMETERS*.MAX = 1.05. Standoff, Dimension Limits = A1. Standoff, INCHES.MIN = .002. Standoff, INCHES.NOM = .006. Standoff, INCHES.MAX = .010. Standoff, MILLIMETERS*.MIN = 0.05. Standoff,",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nMILLIMETERS*.NOM = 0.15. Standoff, MILLIMETERS*.MAX = 0.25. Foot Length, Dimension Limits = L. Foot Length, INCHES.MIN = .018. Foot Length, INCHES.NOM = .024. Foot Length, INCHES.MAX = .030. Foot Length, MILLIMETERS*.MIN = 0.45. Foot Length, MILLIMETERS*.NOM = 0.60. Foot Length, MILLIMETERS*.MAX = 0.75. Footprint (Reference), Dimension Limits = (F). Footprint (Reference), INCHES.MIN = . Footprint (Reference), INCHES.NOM = .039. Footprint (Reference), INCHES.MAX = . Footprint (Reference), MILLIMETERS*.MIN = . Footprint (Reference), MILLIMETERS*.NOM = 1.00. Footprint (Reference), MILLIMETERS*.MAX = . Foot Angle, Dimension Limits = \u03c6. Foot Angle, INCHES.MIN = 0. Foot Angle, INCHES.NOM = 3.5. Foot",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nAngle, INCHES.MAX = 7. Foot Angle, MILLIMETERS*.MIN = 0. Foot Angle, MILLIMETERS*.NOM = 3.5. Foot Angle, MILLIMETERS*.MAX = 7. Overall Width, Dimension Limits = E. Overall Width, INCHES.MIN = .463. Overall Width, INCHES.NOM = .472. Overall Width, INCHES.MAX = .482. Overall Width, MILLIMETERS*.MIN = 11.75. Overall Width, MILLIMETERS*.NOM = 12.00. Overall Width, MILLIMETERS*.MAX = 12.25. Overall Length, Dimension Limits = D. Overall Length, INCHES.MIN = .463. Overall Length, INCHES.NOM = .472. Overall Length, INCHES.MAX = .482. Overall Length, MILLIMETERS*.MIN = 11.75. Overall Length, MILLIMETERS*.NOM = 12.00. Overall Length, MILLIMETERS*.MAX = 12.25. Molded Package Width, Dimension Limits = E1. Molded Package Width,",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nINCHES.MIN = .390. Molded Package Width, INCHES.NOM = .394. Molded Package Width, INCHES.MAX = .398. Molded Package Width, MILLIMETERS*.MIN = 9.90. Molded Package Width, MILLIMETERS*.NOM = 10.00. Molded Package Width, MILLIMETERS*.MAX = 10.10. Molded Package Length, Dimension Limits = D1. Molded Package Length, INCHES.MIN = .390. Molded Package Length, INCHES.NOM = .394. Molded Package Length, INCHES.MAX = .398. Molded Package Length, MILLIMETERS*.MIN = 9.90. Molded Package Length, MILLIMETERS*.NOM = 10.00. Molded Package Length, MILLIMETERS*.MAX = 10.10. Lead Thickness, Dimension Limits = c. Lead Thickness, INCHES.MIN = .005. Lead Thickness, INCHES.NOM = .007. Lead Thickness, INCHES.MAX = .009. Lead Thickness, MILLIMETERS*.MIN = 0.13. Lead Thickness,",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nMILLIMETERS*.NOM = 0.18. Lead Thickness, MILLIMETERS*.MAX = 0.23. Lead Width, Dimension Limits = B. Lead Width, INCHES.MIN = .007. Lead Width, INCHES.NOM = .009. Lead Width, INCHES.MAX = .011. Lead Width, MILLIMETERS*.MIN = 0.17. Lead Width, MILLIMETERS*.NOM = 0.22. Lead Width, MILLIMETERS*.MAX = 0.27. Pin 1 Corner Chamfer, Dimension Limits = CH. Pin 1 Corner Chamfer, INCHES.MIN = .025. Pin 1 Corner Chamfer, INCHES.NOM = .035. Pin 1 Corner Chamfer, INCHES.MAX = .045. Pin 1 Corner Chamfer, MILLIMETERS*.MIN = 0.64. Pin 1 Corner Chamfer, MILLIMETERS*.NOM = 0.89. Pin 1 Corner Chamfer, MILLIMETERS*.MAX = 1.14. Mold Draft Angle Top, Dimension Limits",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n= \u03b1. Mold Draft Angle Top, INCHES.MIN = 5. Mold Draft Angle Top, INCHES.NOM = 10. Mold Draft Angle Top, INCHES.MAX = 15. Mold Draft Angle Top, MILLIMETERS*.MIN = 5. Mold Draft Angle Top, MILLIMETERS*.NOM = 10. Mold Draft Angle Top, MILLIMETERS*.MAX = 15. Mold Draft Angle Bottom, Dimension Limits = \u03b2. Mold Draft Angle Bottom, INCHES.MIN = 5. Mold Draft Angle Bottom, INCHES.NOM = 10. Mold Draft Angle Bottom, INCHES.MAX = 15. Mold Draft Angle Bottom, MILLIMETERS*.MIN = 5. Mold Draft Angle Bottom, MILLIMETERS*.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS*.MAX = 15\n*Controlling Parameter\nNotes:\nshall not exceed .010\" (0.254mm) per side. Dimensions D1 and E1 do not include mold flash or protrusions.  Mold flash or protrusions\nJEDEC Equivalent:  MS-026 Drawing No. C04-085",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNumber of Pins, Units.Dimension Limits = n. Number of Pins, INCHES.MIN = 80. Number of Pins, INCHES.NOM = 80. Number of Pins, INCHES.MAX = 80. Number of Pins, MILLIMETERS*.MIN = 80. Number of Pins, MILLIMETERS*.NOM = 80. Number of Pins, MILLIMETERS*.MAX = 80. Pitch, Units.Dimension Limits = p. Pitch, INCHES.MIN = . Pitch, INCHES.NOM = .020. Pitch, INCHES.MAX = . Pitch, MILLIMETERS*.MIN = . Pitch, MILLIMETERS*.NOM = 0.50. Pitch, MILLIMETERS*.MAX = . Pins per Side, Units.Dimension Limits = n1. Pins per Side, INCHES.MIN = . Pins per Side, INCHES.NOM = 20. Pins per Side, INCHES.MAX = . Pins per Side, MILLIMETERS*.MIN = . Pins per Side, MILLIMETERS*.NOM = 20. Pins per Side, MILLIMETERS*.MAX = . Overall Height,",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nUnits.Dimension Limits = A. Overall Height, INCHES.MIN = .039. Overall Height, INCHES.NOM = .043. Overall Height, INCHES.MAX = .047. Overall Height, MILLIMETERS*.MIN = 1.00. Overall Height, MILLIMETERS*.NOM = 1.10. Overall Height, MILLIMETERS*.MAX = 1.20. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, INCHES.MIN = .037. Molded Package Thickness, INCHES.NOM = .039. Molded Package Thickness, INCHES.MAX = .041. Molded Package Thickness, MILLIMETERS*.MIN = 0.95. Molded Package Thickness, MILLIMETERS*.NOM = 1.00. Molded Package Thickness, MILLIMETERS*.MAX = 1.05. Standoff, Units.Dimension Limits = A1. Standoff, INCHES.MIN = .002. Standoff, INCHES.NOM = .004. Standoff, INCHES.MAX = .006. Standoff,",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nMILLIMETERS*.MIN = 0.05. Standoff, MILLIMETERS*.NOM = 0.10. Standoff, MILLIMETERS*.MAX = 0.15. Foot Length, Units.Dimension Limits = L. Foot Length, INCHES.MIN = .018. Foot Length, INCHES.NOM = .024. Foot Length, INCHES.MAX = .030. Foot Length, MILLIMETERS*.MIN = 0.45. Foot Length, MILLIMETERS*.NOM = 0.60. Foot Length, MILLIMETERS*.MAX = 0.75. Footprint (Reference), Units.Dimension Limits = (F). Footprint (Reference), INCHES.MIN = . Footprint (Reference), INCHES.NOM = .039. Footprint (Reference), INCHES.MAX = . Footprint (Reference), MILLIMETERS*.MIN = . Footprint (Reference), MILLIMETERS*.NOM = 1.00. Footprint (Reference), MILLIMETERS*.MAX = . Foot Angle, Units.Dimension Limits = \u03c6. Foot Angle,",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nINCHES.MIN = 0. Foot Angle, INCHES.NOM = 3.5. Foot Angle, INCHES.MAX = 7. Foot Angle, MILLIMETERS*.MIN = 0. Foot Angle, MILLIMETERS*.NOM = 3.5. Foot Angle, MILLIMETERS*.MAX = 7. Overall Width, Units.Dimension Limits = E. Overall Width, INCHES.MIN = .541. Overall Width, INCHES.NOM = .551. Overall Width, INCHES.MAX = .561. Overall Width, MILLIMETERS*.MIN = 13.75. Overall Width, MILLIMETERS*.NOM = 14.00. Overall Width, MILLIMETERS*.MAX = 14.25. Overall Length, Units.Dimension Limits = D. Overall Length, INCHES.MIN = .541. Overall Length, INCHES.NOM = .551. Overall Length, INCHES.MAX = .561. Overall Length, MILLIMETERS*.MIN = 13.75. Overall Length, MILLIMETERS*.NOM = 14.00. Overall Length,",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nMILLIMETERS*.MAX = 14.25. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, INCHES.MIN = .463. Molded Package Width, INCHES.NOM = .472. Molded Package Width, INCHES.MAX = .482. Molded Package Width, MILLIMETERS*.MIN = 11.75. Molded Package Width, MILLIMETERS*.NOM = 12.00. Molded Package Width, MILLIMETERS*.MAX = 12.25. Molded Package Length, Units.Dimension Limits = D1. Molded Package Length, INCHES.MIN = .463. Molded Package Length, INCHES.NOM = .472. Molded Package Length, INCHES.MAX = .482. Molded Package Length, MILLIMETERS*.MIN = 11.75. Molded Package Length, MILLIMETERS*.NOM = 12.00. Molded Package Length, MILLIMETERS*.MAX = 12.25. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, INCHES.MIN = .004. Lead Thickness, INCHES.NOM =",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n.006. Lead Thickness, INCHES.MAX = .008. Lead Thickness, MILLIMETERS*.MIN = 0.09. Lead Thickness, MILLIMETERS*.NOM = 0.15. Lead Thickness, MILLIMETERS*.MAX = 0.20. Lead Width, Units.Dimension Limits = B. Lead Width, INCHES.MIN = .007. Lead Width, INCHES.NOM = .009. Lead Width, INCHES.MAX = .011. Lead Width, MILLIMETERS*.MIN = 0.17. Lead Width, MILLIMETERS*.NOM = 0.22. Lead Width, MILLIMETERS*.MAX = 0.27. Pin 1 Corner Chamfer, Units.Dimension Limits = CH. Pin 1 Corner Chamfer, INCHES.MIN = .025. Pin 1 Corner Chamfer, INCHES.NOM = .035. Pin 1 Corner Chamfer, INCHES.MAX = .045. Pin 1 Corner Chamfer, MILLIMETERS*.MIN = 0.64. Pin 1 Corner Chamfer,",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nMILLIMETERS*.NOM = 0.89. Pin 1 Corner Chamfer, MILLIMETERS*.MAX = 1.14. Mold Draft Angle Top, Units.Dimension Limits = \u03b1. Mold Draft Angle Top, INCHES.MIN = 5. Mold Draft Angle Top, INCHES.NOM = 10. Mold Draft Angle Top, INCHES.MAX = 15. Mold Draft Angle Top, MILLIMETERS*.MIN = 5. Mold Draft Angle Top, MILLIMETERS*.NOM = 10. Mold Draft Angle Top, MILLIMETERS*.MAX = 15. Mold Draft Angle Bottom, Units.Dimension Limits = \u03b2. Mold Draft Angle Bottom, INCHES.MIN = 5. Mold Draft Angle Bottom, INCHES.NOM = 10. Mold Draft Angle Bottom, INCHES.MAX = 15. Mold Draft Angle Bottom, MILLIMETERS*.MIN = 5. Mold Draft Angle Bottom, MILLIMETERS*.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS*.MAX = 15\n*Controlling Parameter\nNotes:",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nshall not exceed .010\" (0.254mm) per side. Dimensions D1 and E1 do not include mold flash or protrusions.  Mold flash or protrusions\nJEDEC Equivalent:  MS-026 Drawing No. C04-092\nNOTES:",
    "Revision A (July 2003)\nAPPENDIX B:\nDEVICE DIFFERENCES\nOriginal  data  sheet  for  PIC18F6525/6621/8525/8621 family.",
    "Revision B (August 2004)\nThis revision includes updates to the Electrical Specifications in Section 27.0 , the DC and AC Characteristics Graphs and Tables in Section 28.0 have been added and includes minor corrections to the data sheet text.",
    "Revision C (January 2013)\nAdded a note to each package outline drawing.",
    "TABLE B-1: DEVICE DIFFERENCES\nOn-chip Program Memory (Kbytes), PIC18F6525 = 48K. On-chip Program Memory (Kbytes), PIC18F6621 = 64K. On-chip Program Memory (Kbytes), PIC18F8525 = 48K. On-chip Program Memory (Kbytes), PIC18F8621 = 64K. I/O Ports, PIC18F6525 = Ports A, B, C, D, E, F, G. I/O Ports, PIC18F6621 = Ports A, B, C, D, E, F, G. I/O Ports, PIC18F8525 = Ports A, B, C, D, E, F, G, H, J. I/O Ports, PIC18F8621 = Ports A, B, C, D, E, F, G, H, J. A/D Channels, PIC18F6525 = 12. A/D Channels, PIC18F6621 = 12. A/D Channels, PIC18F8525 = 16. A/D Channels, PIC18F8621 = 16. External Memory Interface,",
    "TABLE B-1: DEVICE DIFFERENCES\nPIC18F6525 = No. External Memory Interface, PIC18F6621 = No. External Memory Interface, PIC18F8525 = Yes. External Memory Interface, PIC18F8621 = Yes. Package Types, PIC18F6525 = 64-pin TQFP. Package Types, PIC18F6621 = 64-pin TQFP. Package Types, PIC18F8525 = 80-pin TQFP. Package Types, PIC18F8621 = 80-pin TQFP\nThe differences between the devices listed in this data sheet are shown in Table B-1.",
    "APPENDIX C: CONVERSION CONSIDERATIONS\nThis  appendix  discusses  the  considerations  for  converting from previous versions of a device to the ones listed in this data sheet. Typically, these changes are due to the differences in the process technology used. An  example  of  this  type  of  conversion  is  from  a PIC17C756 to a PIC18F8720.",
    "APPENDIX D: MIGRATION FROM MID-RANGE TO ENHANCED DEVICES\nNot Applicable\nA detailed discussion of the  differences between  the mid-range  MCU  devices  (i.e.,  PIC16CXXX)  and  the enhanced  devices  (i.e.,  PIC18FXXX)  is  provided  in AN716,  'Migrating  Designs  from  PIC16C74A/74B  to PIC18C442 .'  The  changes  discussed,  while  device specific,  are  generally  applicable  to  all  mid-range  to enhanced device migrations.\nThis Application Note is available as Literature Number DS00716.",
    "PIC18F6525/6621/8525/8621\nAPPENDIX E:\nMIGRATION FROM HIGH-END TO ENHANCED DEVICES\nA detailed discussion of the migration pathway and differences  between  the  high-end  MCU  devices  (i.e., PIC17CXXX) and the enhanced devices (i.e., PIC18FXXXX) is provided in AN726, 'PIC17CXXX to PIC18CXXX Migration .'\nThis Application Note is available as Literature Number DS00726.\nNOTES:",
    "A\nA/D.................................................................................... 233",
    "A\nAcquisition Requirements ........................................., 1 = 238. Acquisition Time........................................................, 1 = 238. ADCON0 Register....................................................., 1 = 233. , 1 = 233. ADCON1 Register..................................................... ADCON2",
    "A\nRegister....................................................., 1 = 233. Register............................................., 1 = 233, 236. ADRESH, 1 = ............................................. 233, 236. ADRESL Register Analog Port Pins, 1 = 128. ....................................................... Analog Port Pins,",
    "A\nConfiguring..................................., 1 = 240. Associated Register Summary.................................., 1 = 241. Automatic Acquisition Time......................................., 1 = 239. Calculating Minimum Required Acquisition Time ..............................................., 1 = 238. Configuring the Module............................................., 1 = 237. Conversion Clock (T AD)",
    "A\n............................................, 1 = 239. Conversion Status (GO/DONE Bit), 1 = ........................... 236. Conversion TAD Cycles............................................., 1 = 240. Conversions.............................................................., 1 = 240. Converter Characteristics .........................................,",
    "A\n1 = 354. Converter Interrupt, Configuring, 1 = ............................... 237. ECCP2 Special Event Trigger..................................., 1 = 241. Equations.................................................................., 1 = 238. Minimum Charging Time..........................................., 1 = 238. Selecting and Configuring, 1 = 239. Acquisition Time",
    "A\n............................................... Special Event Trigger (ECCP), 1 = .................................. 160. TAD vs. Device Operating Frequencies (table)..........................................., 1 = 239. Absolute Maximum Ratings .............................................., 1 = 323. AC (Timing) Characteristics",
    "A\n.............................................., 1 = 335. Load Conditions for Device Timing Specifications........................................, 1 = 336 335. Parameter Symbology .............................................. Temperature and Voltage Specifications...................................................., 1 = 336. Timing Conditions",
    "A\n....................................................., 1 = 336. ACKSTAT ......................................................................... ......................................................, 1 = 203. ACKSTAT Status Flag, 1 = 203. ADCON0",
    "A\nRegister............................................................., 1 = 233. GO/DONE Bit............................................................, 1 = 236. ADCON1 Register............................................................., 1 = 233. ADCON2",
    "A\nRegister............................................................., 1 = 233. ADDLW............................................................................., 1 = 281. ADDWF............................................................................., 1 = 281.",
    "A\nADDWFC.......................................................................... ADRESH Register....................................................., 1 = 282 233, 236. ADRESL Register, 1 = . , 1 = 233,. ..................................................... Analog-to-Digital Converter. See A/D., 1 = 236.",
    "A\nANDLW............................................................................. ANDWF............................................................................., 1 = 282 283. Assembler MPASM, 1 = 317 225. Auto-Wake-up on Sync Break, 1 = . Assembler...................................................",
    "A\nCharacter.........................., 1 = . B Baud Rate BC....................................................................................., 1 = Generator........................................................ 199 283 284 203.",
    "A\nBCF................................................................................... BF, 1 = . ..................................................................................... BF Status, 1 = . Flag, 1 = . , 1 = ..................................................................",
    "A\n203\nBlock Diagrams",
    "A\n16-Bit Byte Select, 1 = Mode............................................. 75. 16-Bit Byte Write Mode..............................................., 1 = 73. 16-Bit Word Write Mode............................................., 1 = 74. A/D............................................................................, 1 = 236. Analog",
    "A\nInput Model..................................................., 1 = 237. Baud Rate Generator, 1 = ............................................... 199. Capture Mode Operation.........................................., 1 = 151. Comparator Analog Input Model..............................., 1 = 247. Comparator I/O Operating Modes, 1 = ............................ 244. Comparator",
    "A\nOutput..................................................., 1 = 246. Comparator Voltage Reference................................, 1 = 250. Comparator Voltage Reference Output Buffer Example....................................., 1 = 251. Compare Mode Operation........................................, 1 = 152. Enhanced",
    "A\nPWM........................................................, 1 = 161. EUSART Receive....................................................., 1 = 223. EUSART Transmit...................................................., 1 = 221. Low-Voltage Detect (LVD)........................................, 1 = 254. Low-Voltage Detect with External",
    "A\nInput...................., 1 = 254. MCLR/VPP/RG5 Pin.................................................., 1 = 121. MSSP (I 2 C Master Mode)........................................., 1 = 197. MSSP (I 2 C Mode)....................................................., 1 = 182. MSSP (SPI Mode), 1 =",
    "A\n.................................................... 173. On-Chip Reset Circuit................................................., 1 = 29. PIC18F6525/6621, 1 = ........................................................ 9 ...................................................... 10. PIC18F8525/8621 PLL",
    "A\n............................................................................., 1 = 23. Port/LAT/TRIS Operation ........................................., 1 = 103. PORTC (Peripheral Output Override)......................., 1 = 109. PORTD and PORTE (Parallel Slave Port)................, 1 = 128. PORTD in I/O Port Mode.........................................., 1 =",
    "A\n111. PORTD in System Bus Mode..................................., 1 = 112. PORTE in I/O Mode.................................................., 1 = 115. PORTE in System Bus Mode..................................., 1 = 115. PORTG (Peripheral Output Override), 1 = ...................... 120. PORTJ in I/O Mode.................................................., 1 = 125. PWM Operation",
    "A\n(Simplified), 1 = ..................................... 154. RA3:RA0 and RA5 Pins............................................, 1 = 104 104. RA4/T0CKI Pin ........................................................., 1 = ......................................... 104. RA6 Pin (Enabled as I/O) RB2:RB0",
    "A\nPins..........................................................., 1 = 107. RB3 Pin ...................................................................., 1 = 107. RB7:RB4 Pins..........................................................., 1 = 106. Reads from Flash Program Memory .........................., 1 = 65. RF1/AN6/C2OUT",
    "A\nand RF2/AN7/C1OUT Pins.......... ............................................, 1 = 117. RF6:RF3 and RF0 Pins, 1 = 118. RF7 Pin....................................................................., 1 = 118. RH3:RH0 Pins in I/O Mode......................................., 1 = 122. RH3:RH0 Pins in System Bus Mode........................, 1",
    "A\n= 123. RH7:RH4 Pins in I/O Mode....................................... RJ4:RJ0 Pins in System Bus Mode.........................., 1 = 122 126. RJ7:RJ6 Pins in System Bus Mode.........................., 1 = 126. Single Comparator...................................................., 1 = 245. Table Read Operation, 1 =",
    "A\n................................................ 61. Table Write Operation, 1 = ................................................ 62 67. Table Writes to Flash Program Memory..................... Timer0 in 16-Bit Mode .............................................., 1 = 132. Timer0 in 8-Bit, 1 = 132. Mode................................................ Timer1",
    "A\n......................................................................, 1 = 136. Timer1 (16-Bit Read/Write, 1 = Mode)............................. 136. Timer2 ......................................................................, 1 = 142",
    "PIC18F6525/6621/8525/8621\nTimer3......................................................................., 1 = 144. Timer3 (16-Bit Read/Write Mode)............................., 1 = 144. Timer4......................................................................., 1 = 148. Watchdog",
    "PIC18F6525/6621/8525/8621\nTimer........................................................, 1 = 268. BN....................................................................................., 1 = 284. BNC, 1 = .................................................................................. 285.",
    "PIC18F6525/6621/8525/8621\nBNN, 1 = .................................................................................. 285. BNOV................................................................................",
    "PIC18F6525/6621/8525/8621\nBNZ..................................................................................., 1 = 286 286. BOR. See Brown-out Reset., 1 = . BOV .................................................................................., 1 = 289.",
    "PIC18F6525/6621/8525/8621\nBRA..................................................................................., 1 = 287. Break Character (12-Bit) Transmit and Receive, 1 = ............... 226. BRG. See Baud Rate Generator. (BOR).............................................., 1 = . Brown-out Reset, 1 = 30, 259.",
    "PIC18F6525/6621/8525/8621\nBSF..................................................................................., 1 = 287. BTFSC, 1 = .............................................................................. 288. BTFSS, 1 =",
    "PIC18F6525/6621/8525/8621\n.............................................................................. 288. BTG..................................................................................., 1 = 289. BZ, 1 =",
    "PIC18F6525/6621/8525/8621\n..................................................................................... 290. C, 1 = . C Compilers, 1 = . MPLAB C17.............................................................., 1 = 318. MPLAB C18.............................................................., 1 = 318.",
    "PIC18F6525/6621/8525/8621\nMPLAB C30.............................................................., 1 = 318. CALL................................................................................., 1 = 290. Capture (CCP Module) ....................................................., 1 = 151. Associated Registers",
    "PIC18F6525/6621/8525/8621\n................................................, 1 = 153 151. CCP Pin Configuration.............................................. CCPR4H:CCPR4L Registers...................................., 1 = 151. Software Interrupt ....................................................., 1 = 151. Timer1/Timer3 Mode",
    "PIC18F6525/6621/8525/8621\nSelection................................., 1 = 151. Capture (ECCP Module)..................................................., 1 = 160. Capture/Compare/PWM (CCP)........................................., 1 = 149. Capture Mode. See Capture. CCP Mode and Timer, 1 = Resources............................. 150. CCPRxH",
    "PIC18F6525/6621/8525/8621\nRegister....................................................., 1 = 150. CCPRxL Register......................................................, 1 = 150. Compare Mode. See Compare. Interconnect Configurations......................................, 1 = 150. Module, 1 = . Configuration................................................, 1 = 150. PWM Mode. See",
    "PIC18F6525/6621/8525/8621\nPWM. Clocking Scheme/Instruction, 1 = Cycle .................................... 44 291. CLRF................................................................................. CLRWDT..........................................................................., 1 = . , 1 = 291. Code Examples, 1 = . 16 x 16 Signed Multiply Routine, 1 =",
    "PIC18F6525/6621/8525/8621\n................................. 86 .............................. 16 x 16 Unsigned Multiply Routine, 1 = 86. 8 x 8 Signed Multiply Routine ....................................., 1 = 85. 8 x 8 Unsigned Multiply Routine, 1 = ................................. 85. Changing Between Capture Prescalers.................... Offset Value...................., 1 = 151. Computed GOTO Using an, 1 = 46. Data EEPROM",
    "PIC18F6525/6621/8525/8621\nRead.................................................., 1 = 81. Data EEPROM Refresh Routine................................. Data EEPROM Write, 1 = 82 81. .................................................. Erasing a Flash Program Memory Row......................, 1 = 66. Fast Register",
    "PIC18F6525/6621/8525/8621\nStack....................................................., 1 = 44. How to Clear RAM (Bank 1) Using Indirect Addressing ............................................., 1 = 56. Implementing a Real-Time Clock Using a Timer1 Interrupt Service ..................................., 1 = 138. Initializing PORTA..................................................... Initializing",
    "PIC18F6525/6621/8525/8621\nPORTB....................................................., 1 = 103. , 1 = 106. Initializing PORTC....................................................., 1 = 109. Initializing PORTD....................................................., 1 = 111",
    "PIC18F6525/6621/8525/8621\nInitializing PORTE, 1 = .................................................... 114. Initializing PORTF....................................................., 1 = 117. Initializing PORTG...................................................., 1 = 120. Initializing PORTH...................................................., 1 =",
    "PIC18F6525/6621/8525/8621\n122. Initializing PORTJ....................................................., 1 = 125. Loading the SSPBUF (SSPSR) Register, 1 = ................. 176. Reading a Flash Program Memory Word..................., 1 = 65. Saving STATUS, WREG and BSR Registers in RAM....................................., 1 = 102. Writing to Flash Program Memory........................, 1 = 68-69. Code",
    "PIC18F6525/6621/8525/8621\nProtection........................................................, 1 = 259, 270. Associated Registers................................................, 1 = 271. Configuration Register Protection............................., 1 = 273. Data EEPROM ........................................................., 1 = 273. Program",
    "PIC18F6525/6621/8525/8621\nMemory......................................................, 1 = 271. COMF..............................................................................., 1 = 292. Comparator......................................................................., 1 = 243. , 1 =",
    "PIC18F6525/6621/8525/8621\n................. 247. Analog Input Connection Considerations, 1 = . Associated Registers................................................, 1 = 248. Configuration ............................................................, 1 = 244. Effects of a Reset .....................................................",
    "PIC18F6525/6621/8525/8621\n.................................................................., 1 = 247. Interrupts, 1 = 246. Operation.................................................................., 1 = 245. Operation During Sleep............................................, 1 = 247.",
    "PIC18F6525/6621/8525/8621\nOutputs....................................................................., 1 = 245. Reference................................................................., 1 = 245. External Signal Internal Signal, 1 = ................................................. 245",
    "PIC18F6525/6621/8525/8621\n.................................................. 245. Response Time, 1 = ........................................................ 245. Comparator Specifications................................................, 1 = 332. Comparator Voltage Reference........................................, 1 = 249. Accuracy and",
    "PIC18F6525/6621/8525/8621\nError..................................................., 1 = 250. Associated Registers................................................, 1 = 251. Configuring ..............................................................., 1 = 249. Connection Considerations ....................................................., 1 =",
    "PIC18F6525/6621/8525/8621\n...................................... 250. Effects of a Reset, 1 = 250 250. Operation During Sleep............................................, 1 = 152. Compare (CCP Module) ................................................... Associated Registers................................................, 1 = 153. CCP Pin Configuration",
    "PIC18F6525/6621/8525/8621\n............................................., 1 = 152. , 1 = 152. CCPR1 Register....................................................... Software Interrupt, 1 = 152. ....................................................., 1 = . Special Event Trigger ..............................................., 1 = 152. Timer1/Timer3 Mode Selection, 1",
    "PIC18F6525/6621/8525/8621\n= ................................ 152 160. Compare (ECCP Module)................................................. Special Event Trigger ..............................., 1 = 137, 145, 160. Configuration Bits ............................................................., 1 = 259. Context Saving During",
    "PIC18F6525/6621/8525/8621\nInterrupts......................................, 1 = 102. Control Registers, 1 = . EECON1 and EECON2.............................................., 1 = 62. TABLAT (Table Latch) Register, 1 = ................................. 64. TBLPTR (Table Pointer) Register..............................., 1 = 64. Conversion",
    "PIC18F6525/6621/8525/8621\nConsiderations..............................................., 1 = 378. CPFSEQ..........................................................................., 1 = 292. CPFSGT..........................................................................., 1 = 293.",
    "PIC18F6525/6621/8525/8621\nCPFSLT............................................................................, 1 = 293",
    "D\nData EEPROM Memory......................................................, 1 = 79. Associated Registers.................................................., 1 = 83. EEADR Register........................................................., 1 = 79. EEADRH Register ......................................................, 1 = 79. EECON1 Register",
    "D\n......................................................, 1 = 79. EECON2 Register ......................................................, 1 = 79. Operation During Code-Protect.................................., 1 = 82. Protection Against Spurious Write.............................., 1 = 82",
    "PIC18F6525/6621/8525/8621\nReading......................................................................., 1 = 81. Using..........................................................................., 1 = 82. Write Verify, 1 = ................................................................. 82. Writing",
    "PIC18F6525/6621/8525/8621\nTo...................................................................., 1 = 81. Data Memory......................................................................., 1 = 47. General Purpose Registers........................................., 1 = 47. Map for PIC18F6X2X/8X2X Devices, 1 =",
    "PIC18F6525/6621/8525/8621\n.......................... 48. Special Function Registers, 1 = ......................................... 47. DAW.................................................................................., 1 = 294. DC and AC Characteristics Graphs and Tables ..................................................., 1 = 357. DC Characteristics, 1 =",
    "PIC18F6525/6621/8525/8621\n............................................................ 330. Power-Down and Supply Current, 1 = ............................. 326. Supply Voltage.........................................................., 1 = 325.",
    "PIC18F6525/6621/8525/8621\nDCFSNZ............................................................................, 1 = 295. DECF, 1 = ................................................................................ 294.",
    "PIC18F6525/6621/8525/8621\nDECFSZ............................................................................, 1 = 295. Demonstration Boards, 1 = . PICDEM 1................................................................., 1 = 320. PICDEM 17..............................................................., 1 = 321. PICDEM 18R,",
    "PIC18F6525/6621/8525/8621\n1 = ............................................................ 321. PICDEM 2 Plus ........................................................., 1 = 320. PICDEM 3................................................................., 1 = 320. PICDEM",
    "PIC18F6525/6621/8525/8621\n4................................................................., 1 = 320. PICDEM LIN, 1 = ............................................................. 321. PICDEM USB............................................................, 1 = 321. PICDEM.net Internet/Ethernet",
    "PIC18F6525/6621/8525/8621\n.................................., 1 = 320. Development Support ......................................................., 1 = 317. Device Differences............................................................, 1 = 377. Direct Addressing................................................................, 1 = 57. Direct",
    "PIC18F6525/6621/8525/8621\nAddressing........................................................, 1 = 55",
    "E\nECCP\nCapture and Compare Modes................................... 160\nStandard PWM Mode................................................ 160\nElectrical Characteristics................................................... 323\nEnhanced Capture/Compare/PWM (ECCP) .....................157\nand Program Memory modes ................................... 158\nCapture Mode.\nSee\nCapture (ECCP Module).",
    "E\nOutputs and Configuration ........................................ 158\nPin Configurations for ECCP1 .................................. 158\nPin Configurations for ECCP2 .................................. 159\nPin Configurations for ECCP3 .................................. 159\nPWM Mode.\nSee\nPWM (ECCP Module).\nTimer Resources....................................................... 160",
    "E\nUse with CCP4 and CCP5........................................ 158\nEnhanced PWM Mode.\nSee\nPWM (ECCP Module).\nEnhanced Universal Synchronous Asynchronous\nReceiver Transmitter (EUSART)............................... 213\nErrata .................................................................................... 5\nEUSART",
    "E\nAsynchronous Mode ................................................. 221\n12-Bit Break Transmit and Receive .................. 226\nAssociated Registers, Receive ......................... 224\nAssociated Registers, Transmit ........................ 222\nAuto-Wake-up on Sync Break........................... 225",
    "E\nBaud Rate Generator (BRG), 1 = .................................... 217. Associated Registers........................................, 1 = 217. Auto-Baud Rate Detect....................................., 1 = 220. Baud Rate Error, Calculating............................, 1 = 217. Baud Rates, Asynchronous Modes, 1 = .................. 218. High Baud Rate Select (BRGH Bit), 1 = .................. 217.",
    "E\nSampling..........................................................., 1 = 217. Synchronous Master Mode......................................., 1 = 227. Associated Registers, Receive........................., 1 = 230. Associated Registers, Transmit........................, 1 = 228. Reception, 1 = ......................................................... 229. Transmission, 1 =",
    "E\n.................................................... 227. Synchronous Slave Mode........................................., 1 = 231. Associated Registers, Receive........................., 1 = 232. Associated Registers, Transmit........................, 1 = 231. Reception ........................................................., 1 = 232. Transmission",
    "E\n...................................................., 1 = 231. Evaluation and Programming Tools.................................., 1 = 321. Extended Microcontroller Mode.........................................., 1 = 71. External Memory Interface.................................................., 1 = 71. 16-Bit Byte Select",
    "E\nMode............................................., 1 = 75. 16-Bit Byte Write Mode..............................................., 1 = 73. 16-Bit Mode ................................................................, 1 = 73. 16-Bit Mode Timing....................................................., 1 = 76. 16-Bit Word Write Mode",
    "E\n............................................., 1 = 74. PIC18F8X2X External Bus - I/O Port Functions..............................................., 1 = 72. Program Memory Modes and External Memory Interface................................................, 1 = 71. F, 1 = . Flash Program Memory......................................................, 1 = 61. Associated",
    "E\nRegisters.................................................., 1 = 69. Control Registers........................................................, 1 = 62. Erase Sequence........................................................., 1 = 66. Erasing",
    "E\n......................................................................., 1 = 66. Operation During Code-Protect, 1 = .................................. 69. Reading, 1 = ...................................................................... 65. Table Pointer, 1 = . Boundaries Based on Operation, 1 = ........................ 64. Table Pointer Boundaries",
    "E\n..........................................., 1 = 64. Table Reads and Table Writes, 1 = ................................... 61. Write Sequence.........................................................., 1 = 67. Writing To, 1 = ................................................................... 67. Protection Against Spurious",
    "E\nWrites...................., 1 = 69. Unexpected Termination ...................................., 1 = 69. Write Verify, 1 = ......................................................... 69. G, 1 = . General Call Address Support.........................................., 1 = 196.",
    "E\nGOTO..............................................................................., 1 = 296. H, 1 = . Hardware Multiplier............................................................., 1 = 85. Introduction................................................................., 1 = 85.",
    "E\nOperation...................................................................., 1 = 85. Performance Comparison..........................................., 1 = 85\nReceiver............................................................ 223\nSetting Up 9-Bit Mode with\nAddress Detect ......................................... 223",
    "E\nTransmitter........................................................ 221",
    "I\nI/O Ports............................................................................, 1 = 103. I 2 C Mode, 1 = . Associated Registers, 1 = ................................................ 212. General Call Address Support, 1 = .................................. 196. Master Mode Operation, 1 = ..........................................................",
    "I\n198. Master Mode Transmit Sequence............................., 1 = 198. Read/Write Bit Information (R/W Bit) Serial Clock (RC3/SCK/SCL)...................................., 1 = ................ 186, 187. ID Locations .............................................................., 1 = 187. , 1 = 259, 274.",
    "I\nINCF.................................................................................., 1 = 296. INCFSZ............................................................................., 1 = 297. In-Circuit Debugger..........................................................., 1 = 274. Resources",
    "I\n(table)......................................................, 1 = 274. In-Circuit Serial Programming (ICSP), 1 = ....................... 259, 274. Indirect Addressing ............................................................., 1 = 57 ............................................. INDF and FSR Registers, 1 = 56. Operation",
    "I\n...................................................................., 1 = 56. Indirect Addressing Operation............................................., 1 = 57. Indirect File Operand..........................................................., 1 = 47.",
    "I\nINFSNZ............................................................................., 1 = 297. Initialization Conditions for All Registers......................., 1 = 32-36. Instruction Flow/Pipelining .................................................., 1 = 45. Instruction Set, 1 = .",
    "I\nADDLW....................................................................., 1 = 281. ADDWF....................................................................., 1 = 281. ADDWFC.................................................................., 1 = 282.",
    "I\nANDLW....................................................................., 1 = 282. ANDWF..................................................................... BC............................................................................., 1 = 283 283.",
    "I\nBCF..........................................................................., 1 = 284. BN............................................................................., 1 = 284. BNC, 1 = .......................................................................... 285. BNN, 1 =",
    "I\n.......................................................................... 285. BNOV........................................................................, 1 = 286. BNZ..........................................................................., 1 = 286. BOV",
    "I\nBRA..........................................................................., 1 = .......................................................................... 289 287. BSF..........................................................................., 1 = 287. BTFSC, 1 =",
    "I\n...................................................................... 288. BTFSS, 1 = ...................................................................... 288. BTG..........................................................................., 1 = 289. BZ",
    "I\n............................................................................., 1 = 290. CALL........................................................................., 1 = 290. CLRF........................................................................., 1 = 291.",
    "I\nCLRWDT..................................................................., 1 = 291. COMF ......................................................................., 1 = 292. CPFSEQ..................................................................., 1 = 292. CPFSGT, 1 =",
    "I\n................................................................... 293. CPFSLT, 1 = .................................................................... 293. DAW.........................................................................., 1 = 294. DCFSNZ, 1 =",
    "I\n................................................................... 295. DECF, 1 = 294. ........................................................................ DECFSZ...................................................................., 1 = 295. Firmware",
    "I\nInstructions................................................, 1 = 275. General Format........................................................., 1 = 277. GOTO ......................................................................., 1 = 296.",
    "I\nINCF.........................................................................., 1 = 296. INCFSZ....................................................................., 1 = 297 297. INFSNZ....................................................................., 1 =",
    "I\n...................................................................... 298. IORLW, 1 = . IORWF......................................................................, 1 = 298. LFSR........................................................................., 1 = 299",
    "I\nMOVF......................................................................., 1 = 299. MOVFF....................................................................., 1 = 300. MOVLB....................................................................., 1 = 300.",
    "I\nMOVLW...................................................................., 1 = 301. MOVWF...................................................................., 1 = 301. MULLW....................................................................., 1 = 302.",
    "I\nMULWF....................................................................., 1 = 302. NEGF........................................................................, 1 = 303. NOP.........................................................................., 1 = 303. Opcode Field",
    "I\nDescriptions........................................ POP.........................................................................., 1 = 276. PUSH........................................................................, 1 = 304.",
    "I\nRCALL......................................................................, 1 = 305. RESET......................................................................, 1 = 305. RETFIE....................................................................., 1 = 306.",
    "I\nRETLW....................................................................., 1 = 306. RETURN..................................................................., 1 = 307. RLCF ........................................................................, 1 = 307.",
    "I\nRLNCF......................................................................, 1 = 308. RRCF........................................................................, 1 = 308. RRNCF....................................................................., 1 = 309. SETF, 1 =",
    "I\n........................................................................ 309. SLEEP......................................................................, 1 = 310. SUBFWB, 1 = .................................................................. 310.",
    "I\nSUBLW....................................................................., 1 = 311. SUBWF....................................................................., 1 = 311 312. SWAPF....................................................................., 1 = 312.",
    "I\nTBLRD......................................................................, 1 = 313. TBLWT, 1 = ..................................................................... 314. TSTFSZ...................................................................., 1 = 315. XORLW, 1 =",
    "I\n.................................................................... 315. XORWF...................................................................., 1 = 316. Summary Table ........................................................, 1 = 278. INT Interrupt (RB3/INT3:RB0/INT0). See Interrupt Sources., 1 = INT Interrupt (RB3/INT3:RB0/INT0). See Interrupt Sources..",
    "I\nINTCON Registers.............................................................. 2, 1 = 89. Inter-Integrated Circuit. See I C. Interrupt Logic (diagram) ...................................................., 1 = 88. Interrupt Sources, 1 = .............................................................. 259. A/D Conversion",
    "I\nComplete........................................, 1 = 237. Capture Complete (CCP).........................................., 1 = 151. Compare Complete (CCP)........................................, 1 = 152. INT0.........................................................................., 1 = 102. Interrupt-on-Change",
    "I\n(RB7:RB4)..............................., 1 = 106. PORTB, Interrupt-on-Change..................................., 1 = 102. RB3/INT3:RB0/INT0/FLT0 Pins, External................., 1 = 102. TMR0........................................................................ TMR0",
    "I\nOverflow........................................................., 1 = 102 133. TMR1 Overflow................................................., 1 = 135, 137. TMR2 to PR2 Match, 1 = 142. ................................................. TMR2 to PR2 Match (PWM)....................., 1 = 141, 154, 160. TMR3",
    "I\nOverflow................................................., 1 = 143, 145. TMR4 to PR4 Match ................................................., 1 = 148. TMR4 to PR4 Match (PWM)....................................., 1 = 147. Interrupts.............................................................................,",
    "I\n1 = 87. Control Registers........................................................, 1 = 89. Enable Registers, 1 = ........................................................ 95. Flag Registers............................................................., 1 = 92. Priority Registers",
    "I\n........................................................ Reset Control Registers............................................, 1 = 98 101. IORLW.............................................................................., 1 = 298.",
    "I\nIORWF.............................................................................., 1 = 298. IPR Registers......................................................................, 1 = 98",
    "K\nKey Features, 1 = . Easy Migration, 1 = .............................................................. 7. Expanded Memory........................................................, 1 = 7. External Memory Interface............................................, 1 = 7. Other Special Features ................................................., 1 = 7. L, 1 = .",
    "K\nLFSR................................................................................., 1 = 299. Low-Voltage Detect..........................................................., 1 = 253. Characteristics, 1 = .......................................................... 333. Converter Characteristics, 1 =",
    "K\n......................................... 333. Effects of a Reset...................................................... .................................................................., 1 = 257. Operation, 1 = 256. Current Consumption........................................, 1 = 257. During Sleep",
    "K\n....................................................., 1 = 257. Reference Voltage Set Point............................., 1 = 257. Typical Application ...................................................., 1 = 253. Low-Voltage ICSP Programming Low-Voltage Detect., 1 = ...................................... 274. LVD. See, 1 = . M, 1 = . Master SSP (MSSP) Module",
    "K\nOverview............................., 1 = 173. Master Synchronous Serial Port (MSSP). See MSSP. Master Synchronous Serial Port. See MSSP, 1 = . Mode Memory Access ................................................, 1 = 40. Memory Maps for PIC18F6X2X/8X2X Program Memory Modes ............................................, 1 = 41. Memory Organization, 1 = . Data Memory",
    "K\n.............................................................., 1 = 47. Program Memory ........................................................, 1 = 39. Modes................................................................., 1 = 39. Memory Programming Requirements",
    "K\nMode..........................................................., 1 = ............................... 334. Microcontroller Microprocessor, 1 = 71 71. Mode.......................................................... Mode................................, 1 = 71. Microprocessor with Boot Block, 1 = 379. Migration from High-End to Enhanced",
    "K\nDevices...................................................., 1 = . Migration from Mid-Range to Enhanced Devices...................................................., 1 = 378. MOVF................................................................................, 1 = 299.",
    "K\nMOVFF.............................................................................., 1 = 300. MOVLB.............................................................................., 1 = 300. MOVLW............................................................................., 1",
    "K\n= 301. MOVWF............................................................................, 1 = 301. MPLAB ASM30 Assembler, Linker, Librarian, 1 = ................... 318. MPLAB ICD 2 In-Circuit Debugger...................................., 1 = 319. MPLAB ICE 2000 High-Performance Universal In-Circuit Emulator ...................................., 1 = 319. MPLAB ICE 4000 High-Performance Universal In-Circuit Emulator",
    "K\n...................................., 1 = 319. MPLAB Integrated Development Environment Software..............................................., 1 = 317. MPLAB PM3 Device Programmer....................................., 1 = 319. MPLINK Object Linker/MPLIB Object Librarian, 1 = ................ 318.",
    "K\nMSSP................................................................................, 1 = 173. ACK Pulse........................................................., 1 = 186, 187. Clock Stretching........................................................, 1 = 192. 10-Bit Slave Receive Mode (SEN = 1).............., 1 = 192. 10-Bit Slave Transmit",
    "K\nMode.............................. =, 1 = 192 1)................ 192. 7-Bit Slave Receive Mode (SEN 7-Bit Slave Transmit Mode................................, 1 = 192. Clock Synchronization and the, 1 = . CKP bit (SEN = 1)............................................., 1 = 193",
    "K\nControl Registers (general)......................................., 1 = 173. Enabling SPI I/O ....................................................... I 2 .................................................................., 1 = 177. C Mode, 1 = 182. Acknowledge Sequence Timing, 1 = ....................... 206 199. Baud Rate Generator Bus Collision, 1 =",
    "K\n........................................ During a Repeated, 1 = . Start Condition.................................., 1 = 210. Bus Collision During a Start Condition ............., 1 = 208. Bus Collision During a Stop Condition.............., 1 = 211. Clock Arbitration ..............................................., 1 = 200. Effect of a Reset..............................................., 1 = 207. I 2 C Clock Rate",
    "K\nw/BRG, 1 = ..................................... 199. Master Mode....................................................., 1 = 197. Reception, 1 = ................................................. 203. Repeated Start Condition Timing, 1 = ............. 202. Start Condition Timing.............................., 1 = 201. Transmission",
    "K\n............................................, 1 = 203. Multi-Master Communication, Bus Arbitration............................, 1 = . Collision and, 1 = 207. Multi-Master Mode............................................, 1 = 207. Registers, 1 = .......................................................... 182. Sleep",
    "K\nOperation................................................, 1 = 207. Stop Condition Timing ......................................, 1 = 206. Module Operation Operation.................................................................., 1 = ..................................................... 186 176. Slave",
    "K\nMode..............................................................., 1 = 186. Addressing........................................................, 1 = 186. Reception, 1 = ......................................................... 187. Transmission, 1 = .................................................... 187. SPI Master",
    "K\nMode......................................................, 1 = 178. SPI Mode.................................................................., 1 = 173. SPI Slave Mode........................................................, 1 = 179. SSPBUF",
    "K\n..................................................................., 1 = 178. SSPSR ....................................................................., 1 = 178. TMR2 Output for Clock Shift............................. TMR4 Output for Clock Shift....................................., 1 = 141, 142 148. Typical Connection",
    "K\n..................................................., 1 = 177. MSSP Module Master/Slave, 1 = Connection................................... 177. SPI MULLW............................................................................., 1 = 302.",
    "K\nMULWF............................................................................., 1 = 302. N, 1 = . NEGF................................................................................, 1 = 303.",
    "K\nNOP.................................................................................., 1 = 303. O, 1 = . Oscillator Configuration, 1 = ...................................................... 21. EC..............................................................................., 1 = 21.",
    "K\nECIO..........................................................................., 1 = 21 ................................................................... ECIO+PLL, 1 = 21. ECIO+SPLL................................................................, 1 = 21.",
    "K\nHS..............................................................................., 1 = 21. HS+PLL......................................................................, 1 = 21. HS+SPLL...................................................................., 1 = 21. LP, 1 =",
    "K\n............................................................................... 21. RC, 1 = .............................................................................. 21. RCIO..........................................................................., 1 = 21.",
    "K\nXT..............................................................................., 1 = 21 259. Oscillator Selection Timer1.............................................., 1 = ........................................................... 135, 137, 145. Oscillator, Oscillator,",
    "K\nTimer3.............................................................., 1 = 143. Oscillator, WDT................................................................., 1 = 267",
    "P\nPackaging, 1 = 373. Details, 1 = ......................................................................... ....................................................................... 374. Marking, 1 = ..................................................................... 373. Parallel Slave Port",
    "P\n(PSP).........................................., 1 = 111, 128. Associated Registers, 1 = ................................................ 130. RE0/AD8/RD/P2D Pin..............................................., 1 = 128. RE1/AD9/WR/P2C Pin.............................................., 1 = 128. RE2/AD10/CS/P2B Pin, 1 =",
    "P\n............................................. 128. Select (PSPMODE Bit), 1 = ..................................... 111, 128. Phase Locked Loop (PLL)..................................................., 1 = 23. PICkit 1 Flash Starter Kit..................................................., 1 = 321. PICSTART Plus Development Programmer, 1 = ..................... 320.",
    "P\nPIE Registers ......................................................................, 1 = 95. Pin Functions, 1 = . AVDD ..........................................................................., 1 = 20. AVSS ..........................................................................., 1 = 20.",
    "P\nMCLR/VPP/RG5, 1 = .......................................................... 11. OSC1/CLKI ................................................................., 1 = 11. OSC2/CLKO/RA6, 1 = ....................................................... 11.",
    "P\nRA0/AN0....................................................................., 1 = 12. RA1/AN1....................................................................., 1 = 12. RA2/AN2/VREF-..........................................................., 1 = 12.",
    "P\nRA3/AN3/VREF+.........................................................., 1 = 12. RA4/T0CKI.................................................................., 1 = 12. RA5/AN4/LVDIN, 1 = ......................................................... 12.",
    "P\nRA6............................................................................., 1 = 12 13. RB0/INT0/FLT0........................................................... RB1/INT1 ...................................................................., 1 = 13. RB2/INT2, 1 =",
    "P\n.................................................................... 13. RB3/INT3/ECCP2/P2A, 1 = ............................................... 13. RB4/KBI0, 1 = 13. ....................................................................",
    "P\nRB5/KBI1/PGM..........................................................., 1 = 13. RB6/KBI2/PGC, 1 = ........................................................... 13. RB7/KBI3/PGD, 1 = ........................................................... 13. RC0/T1OSO/T13CKI",
    "P\n.................................................., 1 = 14. RC1/T1OSI/ECCP2/P2A............................................., 1 = 14. RC2/ECCP1/P1A........................................................, 1 = 14. RC3/SCK/SCL, 1 =",
    "P\n............................................................ 14. RC4/SDI/SDA, 1 = ............................................................. 14. RC5/SDO...................................................................., 1 = 14. RC6/TX1/CK1, 1 =",
    "P\n............................................................. 14. RC7/RX1/DT1............................................................. RD0/AD0/PSP0..........................................................., 1 = 14 15.",
    "P\nRD1/AD1/PSP1..........................................................., 1 = 15. RD2/AD2/PSP2..........................................................., 1 = 15. RD3/AD3/PSP3..........................................................., 1 = 15.",
    "P\nRD4/AD4/PSP4..........................................................., 1 = 15. RD5/AD5/PSP5..........................................................., 1 = 15. RD6/AD6/PSP6..........................................................., 1 = 15.",
    "P\nRD7/AD7/PSP7..........................................................., 1 = 15. RE0/AD8/RD/P2D......................................................., 1 = 16. RE1/AD9/WR/P2C......................................................, 1 = 16. RE2/AD10/CS/P2B, 1 =",
    "P\n..................................................... 16. RE3/AD11/P3C..........................................................., 1 = 16. RE4/AD12/P3B, 1 = ........................................................... 16.",
    "P\nRE5/AD13/P1C..........................................................., 1 = 16. RE6/AD14/P1B ..........................................................., 1 = 16. RE7/AD15/ECCP2/P2A, 1 = .............................................. 16. RF0/AN5",
    "P\n....................................................................., 1 = 17 17. RF1/AN6/C2OUT........................................................ RF2/AN7/C1OUT........................................................, 1 = 17",
    "P\nRF3/AN8....................................................................., 1 = 17. RF4/AN9....................................................................., 1 = 17. RF5/AN10/CVREF, 1 = ....................................................... 17.",
    "P\nRF6/AN11..................................................................., 1 = 17. RF7/SS......................................................................., 1 = 17. RG0/ECCP3/P3A........................................................, 1 = 18.",
    "P\nRG1/TX2/CK2............................................................., 1 = 18. RG2/RX2/DT2............................................................., 1 = 18. RG3/CCP4/P3D.........................................................., 1 = 18.",
    "P\nRG4/CCP5/P1D.........................................................., 1 = 18. RH0/A16....................................................................., 1 = 19. RH1/A17....................................................................., 1 = 19.",
    "P\nRH2/A18....................................................................., 1 = 19. RH3/A19....................................................................., 1 = 19. RH4/AN12/P3C..........................................................., 1 = 19.",
    "P\nRH5/AN13/P3B..........................................................., 1 = 19. RH6/AN14/P1C..........................................................., 1 = 19. RH7/AN15/P1B..........................................................., 1 = 19. RJ0/ALE, 1 =",
    "P\n..................................................................... 20. RJ1/OE......................................................................., 1 = 20 ..................................................................... RJ2/WRL, 1 = 20.",
    "P\nRJ3/WRH...................................................................., 1 = 20 ...................................................................... RJ4/BA0, 1 = 20. RJ5/CE ......................................................................., 1 = 20.",
    "P\nRJ6/LB........................................................................, 1 = 20. RJ7/UB ....................................................................... VDD ............................................................................., 1 = 20 20. VSS",
    "P\n............................................................................., 1 = 20. Pinout I/O Descriptions......................................................., 1 = 11. PIR Registers......................................................................, 1 = 92. PLL Lock",
    "P\nTime-out.............................................................., 1 = 30. Pointer, FSR......................................................................., 1 = 56. POP.................................................................................., 1 = 304. POR. See Power-on Reset., 1 = . PORTA, 1 =",
    "P\n. Associated Registers................................................, 1 = 105. Functions, 1 = .................................................................. 105. LATA Register, 1 = .......................................................... 103. PORTA Register......................................................., 1 =",
    "P\n103. TRISA Register........................................................., 1 = 103. PORTB, 1 = . Associated Registers................................................, 1 = 108. Functions, 1 = .................................................................. 108. LATB Register, 1 =",
    "P\n.......................................................... 106. PORTB Register......................................................., 1 = 106. RB3/INT3:RB0/INT0/FLT0 Pins, External................., 1 = 102. TRISB Register........................................................., 1 = 106. PORTC, 1 = . Associated",
    "P\nRegisters................................................, 1 = 110. Functions, 1 = .................................................................. 110. LATC Register, 1 = .......................................................... 109. PORTC Register......................................................., 1 = 109.",
    "P\nRC3/SCK/SCL Pin...................................................., 1 = 187. TRISC Register........................................................., 1 = 109. PORTD............................................................................., 1 = 128. Associated",
    "P\nRegisters................................................ .................................................................., 1 = 113. Functions, 1 = 113. LATD Register, 1 = .......................................................... 111 111. PORTD Register......................................................., 1 =",
    "P\n111. TRISD Register........................................................., 1 = 111",
    "PIC18F6525/6621/8525/8621\nPORTE",
    "PIC18F6525/6621/8525/8621\nProgram Verification, 1 = ......................................................... 270. Programming, Device Instructions.................................... PSP. See Parallel Slave Port., 1 = 275. Pulse-Width Modulation. See PWM (CCP Module) and PWM (ECCP Module)., 1 = . PUSH................................................................................, 1 = 304. PWM (CCP Module), 1 =",
    "PIC18F6525/6621/8525/8621\n......................................................... 154. Associated Registers................................................, 1 = 156. CCPR4H:CCPR4L Registers ..................................., 1 = 154. Duty Cycle, 1 = ................................................................ 154. Example",
    "PIC18F6525/6621/8525/8621\nFrequencies/Resolutions..........................., 1 = 155. Period ......................................................................., 1 = 154. Setup for PWM Operation ........................................, 1 = 155. TMR2 to PR2 Match........................................., 1 = 141, 154. TMR4 to PR4",
    "PIC18F6525/6621/8525/8621\nMatch................................................., 1 = 147. PWM (ECCP Module)......................................................., 1 = 160. Associated Registers................................................, 1 = 172. CCPR1H:CCPR1L Registers ..................................., 1 = 160. Direction Change in Full-Bridge, 1 = . Output",
    "PIC18F6525/6621/8525/8621\nMode....................................................., 1 = 166. Duty Cycle ................................................................, 1 = 161. Effects of a Reset ....................................................., 1 = 171. Enhanced PWM Auto-Shutdown.............................., 1 = 168. Example",
    "PIC18F6525/6621/8525/8621\nFrequencies/Resolutions..........................., 1 = 161. Full-Bridge Application Example..............................., 1 = 166. Full-Bridge Mode......................................................, 1 = 165. Half-Bridge Mode......................................................, 1 = 163. Half-Bridge Output Mode, 1 = . Applications",
    "PIC18F6525/6621/8525/8621\nExample......................................., 1 = 164. Output Configurations..............................................., 1 = 162. Output Relationships (Active-High), 1 = .......................... 162. Output Relationships (Active-Low) ..........................., 1 = 163. Period",
    "PIC18F6525/6621/8525/8621\n......................................................................., 1 = 160. Programmable Dead-Band Delay............................., 1 = 168. Setup for PWM Operation, 1 = ........................................ 171. Start-up Considerations............................................, 1 = 170. TMR2 to PR2",
    "PIC18F6525/6621/8525/8621\nMatch................................................., 1 = 160",
    "Q\nQ Clock..................................................................... 154, 161",
    "R\nRAM.\nSee\nData Memory.\nRC Oscillator....................................................................... 22\nRCALL.............................................................................. 305\nRCON Registers............................................................... 101",
    "R\nRegister File........................................................................ 47\nRegisters\nADCON0 (A/D Control 0).......................................... 233\nADCON1 (A/D Control 1).......................................... 234\nADCON2 (A/D Control 2).......................................... 235",
    "R\nBAUDCONx (Baud Rate Control)............................. 216\nCCPxCON (Capture/Compare/PWM\nControl - CCP4, CCP5) .................................... 149\nCCPxCON (Capture/Compare/PWM Control -\nECCP1, ECCP2, ECCP3 Modules).................. 157\nCMCON (Comparator Control)................................. 243\nCONFIG1H (Configuration 1 High)........................... 260",
    "R\nCONFIG2H (Configuration 2 High)........................... 261\nCONFIG2L (Configuration 2 Low) ............................ 261\nCONFIG3H (Configuration 3 High)........................... 262\nCONFIG3L (Configuration 3 Low) ...................... 41, 262\nCONFIG4L (Configuration 4 Low) ............................ 263\nCONFIG5H (Configuration 5 High)........................... 264",
    "R\nCONFIG5L (Configuration 5 Low) ............................ 263\nCONFIG6H (Configuration 6 High)........................... 265\nCONFIG6L (Configuration 6 Low) ............................ 264",
    "R\nAnalog Port Pins ......................................................., 1 = 128. Associated Registers ................................................, 1 = 116. Functions .................................................................., 1 = 116. LATE Register..........................................................., 1 =",
    "R\n114. PORTE Register, 1 = ....................................................... 114. PSP Mode Select (PSPMODE Bit), 1 = ................... 111, 128. RE0/AD8/RD/P2D Pin..............................................., 1 = 128. RE1/AD9/WR/P2C Pin.............................................., 1 = 128. RE2/AD10/CS/P2B TRISE",
    "R\nRegister........................................................., 1 = Pin............................................. 128 114. PORTF, 1 = . Associated Registers ................................................, 1 = 119 ................................................................... Functions, 1 = 119. LATF",
    "R\nRegister..........................................................., 1 = 117. PORTF Register, 1 = ....................................................... 117. TRISF Register, 1 = 117. PORTG, 1 = .......................................................... Associated Registers, 1 = ................................................ 121.",
    "R\nFunctions, 1 = .................................................................. 121. LATG Register .........................................................., 1 = 120. PORTG Register......................................................., 1 = 120. TRISG",
    "R\nRegister........................................................., 1 = 120. PORTH, 1 = . Associated Registers ................................................, 1 = 124. Functions, 1 = .................................................................. 124. LATH Register, 1 =",
    "R\n.......................................................... 122. PORTH Register......................................................., 1 = 122. TRISH Register........................................................., 1 = 122. PORTJ, 1 = . Associated Registers, 1 = ................................................ 127. Functions, 1 =",
    "R\n.................................................................. 127. LATJ Register, 1 = ........................................................... 125. PORTJ Register........................................................, 1 = 125. TRISJ",
    "R\nRegister.........................................................., 1 = 125. Postscaler, WDT, 1 = . Assignment (PSA Bit), 1 = ............................................... 133. Rate Select (T0PS2:T0PS0 Bits), 1 = .............................. 133. Switching Between Timer0 and WDT......................., 1 = 133. Power-Down Mode. See Sleep., 1 = . Power-on Reset",
    "R\n(POR)............................................... Oscillator Start-up, 1 = 30, 259 30,. Timer (OST) Power-up Timer (PWRT) ...................................., 1 = .......................... 259 30, 259. Time-out Sequence....................................................., 1 = 30. Prescaler, 1 = .",
    "R\nTimer2....................................................................... Prescaler,, 1 = 161 151. Capture Prescaler, Timer0.............................................................., 1 = ............................................................ 133. Assignment (PSA Bit), 1 =",
    "R\n............................................... 133. Rate Select (T0PS2:T0PS0 Bits) .............................., 1 = 133. Switching Between Timer0 and, 1 = WDT....................... 133. Prescaler, Timer2.............................................................. PRO MATE II Universal Device Programmer, 1 = 154 319. Product Identification System Program Counter, 1 =",
    "R\n........................................... 393. , 1 = ......................... PCL, PCLATH and PCLATU Register, 1 = 44. Program Memory, 1 = . Extended Microcontroller Mode.................................., 1 = 39. Instructions.................................................................., 1 = 45. Two-Word, 1 =",
    "R\n........................................................... 46. Interrupt Vector ........................................................... Map and Stack for, 1 = 39 .................................. PIC18FX525 Map and Stack for PIC18FX621, 1 = 40 40. Microcontroller Mode, 1 = 39. .................................................., 1 = 39. Microprocessor",
    "R\nMode ................................................. Microprocessor with Boot Block Mode........................, 1 = 39. Reset Vector ..............................................................., 1 = 39",
    "PIC18F6525/6621/8525/8621\nCONFIG7H (Configuration, 1 = ........................... 266. 7 High) CONFIG7L (Configuration 7 Low)............................., 1 = 265. CVRCON (Comparator Voltage, 1 = . Reference Control) ........................................... 2................................................., 1 = 249. Device ID Register, 1 = 266. DEVID1 (Device ID Register, 1 =",
    "PIC18F6525/6621/8525/8621\n1)................................. 266. ECCPxAS (ECCP Auto-Shutdown Control).............., 1 = 169. ECCPxDEL (PWM Configuration)............................., 1 = 168. EECON1 (Data EEPROM Control 1) ...................., 1 = 63, 80. INTCON (Interrupt Control)........................................., 1 = 89. INTCON2 (Interrupt Control INTCON3 (Interrupt Control, 1 =",
    "PIC18F6525/6621/8525/8621\n2).................................... 90. 3)...................................., 1 = 91. IPR1 (Peripheral Interrupt Priority 1)..........................., 1 = 98. IPR2 (Peripheral Interrupt Priority 2)..........................., 1 = 99. IPR3 (Peripheral Interrupt Priority 3)........................., 1 = 100. LVDCON (Low-Voltage Detect Control)...................., 1 = 255. MEMCON",
    "PIC18F6525/6621/8525/8621\n(Memory Control)......................................., 1 = 71. OSCCON (Oscillator Control), 1 = ..................................... 25. PIE1 (Peripheral Interrupt Enable 1)..........................., 1 = 95. PIE2 (Peripheral Interrupt Enable, 1 = 2)........................... 96. PIE3 (Peripheral Interrupt Enable, 1 = 3)........................... 97. PIR1 (Peripheral Interrupt Request (Flag)",
    "PIC18F6525/6621/8525/8621\n1)................................................, 1 = 92. PIR2 (Peripheral Interrupt Request (Flag) 2)................................................, 1 = 93. PIR3 (Peripheral Interrupt Request (Flag) 3)................................................, 1 = 94 ..................... 129. PSPCON (Parallel Slave Port Control) RCON (Reset",
    "PIC18F6525/6621/8525/8621\nControl)........................................, 1 = 59, 101. RCSTAx (Receive Status and Control)....................., 1 = 215. SSPCON1 (MSSP Control 1, I 2 C Mode), 1 = 184. .................. SSPCON1 (MSSP Control 1, SPI Mode).................., 1 = 175. SSPCON2 (MSSP Control 2, I 2 C Mode), 1 = .................. 185. SSPSTAT (MSSP Status, I 2 C Mode)........................, 1 = 183. SSPSTAT",
    "PIC18F6525/6621/8525/8621\n(MSSP Status, SPI Mode)......................., 1 = 174. STATUS......................................................................, 1 = 58. STKPTR (Stack Pointer)............................................., 1 = 43. Summary..............................................................., 1 = 51-54.",
    "PIC18F6525/6621/8525/8621\nT0CON (Timer0 Control)..........................................., 1 = 131. T1CON (Timer 1 Control).......................................... T2CON (Timer 2 Control).........................................., 1 = 135 141. T3CON (Timer3 Control)..........................................., 1 = 143. T4CON (Timer 4",
    "PIC18F6525/6621/8525/8621\nControl).........................................., 1 = 147. TXSTAx (Transmit Status and Control), 1 = .................... 214. WDTCON (Watchdog Timer Control), 1 = ....................... 267. RESET..............................................................................",
    "PIC18F6525/6621/8525/8621\nReset..........................................................................., 1 = 305 29, 259. MCLR Reset (normal operation)................................., 1 = 29. MCLR Reset (Sleep)..................................................., 1 = 29. Power-on Reset, 1 =",
    "PIC18F6525/6621/8525/8621\n.......................................................... 29. Programmable Brown-out Reset (BOR), 1 = ..................... 29. RESET Instruction, 1 = ...................................................... 29. Stack Full Reset.........................................................., 1 = 29. Stack Underflow Reset",
    "PIC18F6525/6621/8525/8621\n..............................................., 1 = 29. Watchdog Timer (WDT) Reset...................................., 1 = 29. RETFIE, 1 = ............................................................................. 306. RETLW, 1 = 306.",
    "PIC18F6525/6621/8525/8621\n............................................................................., 1 = 307. RETURN........................................................................... Return Address, 1 = 42. Stack......................................................... and Associated Registers, 1 =",
    "PIC18F6525/6621/8525/8621\n........................................... 43. Revision History, 1 = ................................................................ 377 307. RLCF................................................................................., 1 = 308.",
    "PIC18F6525/6621/8525/8621\nRLNCF.............................................................................. RRCF................................................................................, 1 = 308. RRNCF, 1 =",
    "PIC18F6525/6621/8525/8621\n............................................................................. 309",
    "S\nSCK .................................................................................., 1 = 173. SDI...................................................................................., 1 = 173.",
    "S\nSDO.................................................................................., 1 = 173. Serial Clock, SCK............................................................., 1 = 173. Serial Data In (SDI)..........................................................., 1 = 173. Serial Data Out",
    "S\n(SDO)......................................................, 1 = 173. Serial Peripheral Interface. See SPI Mode. ................................................................................, 1 = . SETF, 1 = 309. Slave Select (SS).............................................................., 1 = 173. Slave Select Synchronization",
    "S\n..........................................., 1 = 179. SLEEP.............................................................................., 1 = 310. Sleep ........................................................................, 1 = 259, 269. Software Simulator (MPLAB SIM), 1 =",
    "S\n.................................... 318. Software Simulator (MPLAB SIM30), 1 = ................................ 318. Special Event Trigger. See Compare (ECCP Mode)., 1 = . Special Event Trigger. See Compare (ECCP Module)., 1 = . Special Features of the CPU............................................, 1 = 259. Configuration Registers...................................., 1 = 260-266. Special Function",
    "S\nRegisters................................................., 1 = 47. Map............................................................................., 1 = 49. SPI Mode, 1 = . Associated Registers................................................, 1 = 181. Bus Mode Compatibility............................................, 1 = 181. Effects of a",
    "S\nReset, 1 = ..................................................... 181. Master Mode............................................................., 1 = 178. Master/Slave Connection ......................................... .............................................................., 1 = 177. Serial Clock, 1 = 173. Serial Data",
    "S\nIn............................................................, 1 = 173. Serial Data Out........................................................., 1 = 173. Slave Mode..............................................................., 1 = 179. Slave",
    "S\nSelect.............................................................., 1 = 173. Slave Select Synchronization..................................., 1 = 179. Sleep Operation........................................................, 1 = 181. SPI Clock.................................................................., 1 = 178.",
    "S\nSS....................................................................................., 1 = 173. SSPOV............................................................................., 1 = 203. SSPOV Status Flag, 1 = .......................................................... 203. SSPSTAT Register R/W Bit",
    "S\n............................................................., 1 = 186, 187. Status Bits, 1 = . Significance and Initialization for RCON Register ............................................., 1 = Condition 31. SUBFWB, 1 = .......................................................................... 310.",
    "S\nSUBLW............................................................................., 1 = 311. SUBWF............................................................................., 1 = 311. SUBWFB, 1 = .......................................................................... 312.",
    "S\nSWAPF............................................................................., 1 = 312. T, 1 = . T0CON Register, 1 = . PSA Bit, 1 = ..................................................................... 133. T0CS Bit, 1 = ................................................................... 133.",
    "S\nT0PS2:T0PS0 Bits...................................................., 1 = 133. T0SE Bit ..................................................................., 1 = 133. Table Pointer Operations (table)........................................., 1 = 64.",
    "S\nTBLRD.............................................................................., 1 = 313 314. TBLWT ............................................................................. Time-out in Various Situations............................................, 1 = 31",
    "PIC18F6525/6621/8525/8621\nTimer0..............................................................................., 1 = 131. 16-Bit Mode Timer Reads and Writes......................., 1 = 133. Associated Registers ................................................, 1 = 133. Clock Source Edge Select (T0SE Bit)......................., 1 = 133. Clock Source Select (T0CS",
    "PIC18F6525/6621/8525/8621\nBit)................................, 1 = 133. Operation .................................................................., 1 = 133. Overflow Interrupt ....................................................., 1 = 133. Prescaler. See Prescaler, Timer0., 1 = .",
    "PIC18F6525/6621/8525/8621\nTimer1..............................................................................., 1 = 135. 16-Bit Read/Write Mode............................................, 1 = 137. Associated Registers ................................................, 1 = 139. Operation, 1 =",
    "PIC18F6525/6621/8525/8621\n.................................................................. 136. Oscillator ..........................................................., 1 = 135, 137. Overflow Interrupt ............................................., 1 = 135, 137. Special Event Trigger (ECCP), 1 = .......................... 137, 160. TMR1H Register",
    "PIC18F6525/6621/8525/8621\n......................................................., 1 = 135. TMR1L Register........................................................, 1 = 135. Use as a Real-Time Clock ........................................, 1 = 138.",
    "PIC18F6525/6621/8525/8621\nTimer2............................................................................... ................................................, 1 = 141. Associated Registers, 1 = 142. MSSP Clock Shift.............................................., 1 = 141, 142. Operation, 1 = 141.",
    "PIC18F6525/6621/8525/8621\n.................................................................., 1 = . Postscaler. See Postscaler, Timer2. PR2 Register............................................., 1 = 141, 154, 160. Prescaler. See Prescaler, Timer2. TMR2 Register.........................................................., 1 = 141 160. TMR2 to PR2 Match Interrupt ...........",
    "PIC18F6525/6621/8525/8621\nTimer3..............................................................................., 1 = 141, 142, 154, 143. Associated Registers ................................................, 1 = 145. Operation .................................................................., 1 = 144. Oscillator",
    "PIC18F6525/6621/8525/8621\n..........................................................., 1 = 143, 145 143,. Overflow Interrupt ............................................., 1 = 145 ................................... Special Event Trigger (ECCP), 1 = 145. TMR3H Register ......................................................., 1 = 143. TMR3L",
    "PIC18F6525/6621/8525/8621\nRegister........................................................, 1 = 143. Timer4..............................................................................., 1 = 147. Associated Registers MSSP Clock Shift......................................................, 1 =",
    "PIC18F6525/6621/8525/8621\n................................................ 148 148. Operation, 1 = 147. .................................................................. Postscaler. See Postscaler, Timer4. PR4 Register............................................................., 1 = 147. Prescaler. See Prescaler, Timer4. TMR4",
    "PIC18F6525/6621/8525/8621\nRegister.........................................................., 1 = 147 147, 148. TMR4 to PR4 Match Interrupt ........................... Diagrams, 1 = 355. Timing A/D, 1 = . Conversion......................................................... Acknowledge Sequence, 1 = ........................................... 206. Asynchronous Reception",
    "PIC18F6525/6621/8525/8621\n.......................................... Asynchronous, 1 = 224. Transmission..................................... Asynchronous Transmission, 1 = 222. (Back to Back)..................................................., 1 = 222. Automatic Baud Rate Calculation Auto-Wake-up Bit (WUE), 1 = 220 225. ............................. During Normal",
    "PIC18F6525/6621/8525/8621\nOperation.............................................. Auto-Wake-up Bit (WUE) During, 1 = ..................... Sleep Baud Rate Generator with Clock Arbitration BRG Reset Due to SDA Arbitration During Start, 1 = 225 ............. 200. Condition......................................., 1 = 209. Brown-out Reset (BOR)............................................ Bus Collision During a Repeated, 1 = 341. Start Condition (Case, 1 = .",
    "PIC18F6525/6621/8525/8621\n1)............................................ Bus Collision During a Repeated Start, 1 = 210. Condition (Case 2)............................................ Bus Collision During a Start, 1 = 210. .........................................., 1 = . Condition (SCL = 0), 1 = 209",
    "PIC18F6525/6621/8525/8621\nBus Collision During a Stop Condition (Case 1)............................................, 1 = 211. Bus Collision During a Stop Condition (Case 2)............................................, 1 = 211. Bus Collision During Start Condition (SDA Only), 1 = ....................................... 208. Bus Collision for Transmit and Acknowledge .................................................... Capture/Compare/PWM, 1 = 207.",
    "PIC18F6525/6621/8525/8621\n(All ECCP/CCP Modules)................................. ..........................................................., 1 = 343. CLKO and I/O, 1 = 338. Clock Synchronization .............................................., 1 = 193 ............................................... 44. Clock/Instruction Cycle EUSART Synchronous Receive (Master/Slave), 1 =",
    "PIC18F6525/6621/8525/8621\n.................................... 353. EUSART Synchronous, 1 = 353. Transmission (Master/Slave)............................ Example SPI Master Mode (CKE = 0), 1 = ...................... 345. Example SPI Master Mode (CKE = 1), 1 = ...................... 346. Example SPI Slave Mode (CKE = 0), 1 = 347. ........................ Example SPI Slave Mode (CKE = 1), 1 = .",
    "PIC18F6525/6621/8525/8621\n........................, 1 = 348. External Clock (All Modes Except PLL).................... External Memory Bus Timing for Sleep, 1 = 337. (Microprocessor Mode)....................................... External Memory Bus Timing for TBLRD, 1 = 77. (Extended Microcontroller Mode) ....................... External Memory Bus Timing for TBLRD, 1 = 76. (Microprocessor Mode).......................................",
    "PIC18F6525/6621/8525/8621\nOutput..........................................., 1 = 76. Full-Bridge PWM, 1 = 165. Half-Bridge Output...................................................., 1 = 163. I 2 C Bus Data............................................................., 1 = 349. I 2 C Bus Start/Stop Bits, 1 =",
    "PIC18F6525/6621/8525/8621\n.............................................. I 2 C Master Mode, 1 = 349. I 2 C Master Mode (7-Bit Reception)........................... I 2 C Master Mode First Start Bit Timing..................... 2, 1 = 205 201. I C Slave Mode (10-Bit Reception, SEN = I 2 C Slave Mode (10-Bit Reception, SEN, 1 = ............ 0) = 1), 1 = 190 ........... 195. I 2 C Slave Mode (10-Bit Transmission) ....................., 1 = . I 2 C Slave Mode (7-Bit Reception, SEN",
    "PIC18F6525/6621/8525/8621\n=, 1 = 191 .............. 0) I 2 C Slave Mode (7-Bit Reception, SEN = 1), 1 = 188 ............. 194. 2 ......................., 1 = 189. I C Slave Mode (7-Bit Transmission) .................................................., 1 = . Low-Voltage Detect, 1 = 256. Master SSP I 2 C Bus Data........................................., 1 = 351. Master SSP I 2 C Bus Start/Stop Bits, 1 =",
    "PIC18F6525/6621/8525/8621\n......................... 351. Parallel Slave Port (PSP).........................................., 1 = 344. Parallel Slave Port (PSP) Read................................ Write, 1 = 130. Parallel Slave Port (PSP) ............................................, 1 = ................................ 129. Program Memory Read Program Memory, 1 = 339 340.",
    "PIC18F6525/6621/8525/8621\nWrite............................................. PWM Auto-Shutdown (PRSEN = 0,, 1 = 170. Auto-Restart Disabled) ..................................... PWM Auto-Shutdown (PRSEN = 1, Auto-Restart Enabled)......................................, 1 = 170 167. PWM Direction Change............................................ PWM Direction Change at Near, 1 = . 100% Duty",
    "PIC18F6525/6621/8525/8621\nCycle.............................................. PWM Output............................................................., 1 = 167. Repeated Start Condition, 1 = 154. ......................................... Reset, Watchdog Timer (WDT),, 1 = 202. Oscillator Start-up Timer (OST) and Power-up Timer (PWRT)..........................., 1 = 341. Send Break Character",
    "PIC18F6525/6621/8525/8621\nSequence............................. Slave Mode General Call Address, 1 = 226. , 1 = 196. Sequence (7 or 10-Bit Address Mode) .............................., 1 = ",
    "PIC18F6525/6621/8525/8621\nSlave Synchronization .............................................., 1 = 179. Slow Rise Time (MCLR Tied to VDD via 1 k \uf057\uf020 Resistor)................................................, 1 = 38. SPI Mode (Master Mode).........................................., 1 = 178. SPI Mode (Slave Mode with CKE = 0) ......................, 1 = 180. SPI Mode (Slave Mode with CKE =, 1 = 1)",
    "PIC18F6525/6621/8525/8621\n...................... 180. Stop Condition Receive or Transmit Mode, 1 = ............... 206. Synchronous Reception (Master Mode, SREN)......................................., 1 = 229. Synchronous Transmission......................................., 1 = 227. Synchronous Transmission (Through TXEN), 1 = ........... 228. Time-out Sequence on POR w/PLL Enabled (MCLR Tied to VDD via 1 k \uf057 Resistor), 1 = ............... 38. Time-out Sequence on Power-up (MCLR Not Tied to",
    "PIC18F6525/6621/8525/8621\nVDD): Case 1 ...................................., 1 = 37. Time-out Sequence on Power-up (MCLR Not Tied to VDD): Case 2 ...................................., 1 = 37. Time-out Sequence on Power-up (MCLR \uf057 Resistor)............................, 1 = 37. Tied to VDD via 1 k Timer0 and Timer1 External Clock ..........................., 1 = 342. Timing for Transition Between Timer1 and OSC1 (EC with PLL Active, SCS1 = 1)..............., 1",
    "PIC18F6525/6621/8525/8621\n= 27. Timing for Transition Between Timer1 and OSC1 (HS with PLL Active, SCS1 = 1)..............., 1 = 27. Transition Between Timer1 and OSC1 (HS, XT, LP)............................................., 1 = 26. Transition Between Timer1 and OSC1 (RC, EC)..................................................., 1 = 28. Transition from OSC1 to Timer1 Oscillator, 1 = ................. 26. Wake-up from Sleep via Interrupt",
    "PIC18F6525/6621/8525/8621\n............................., 1 = 270. Specifications ........................................................, 1 = 337. A/D Conversion Requirements ................................., 1 = 355. Capture/Compare/PWM Requirements, 1 = .................... 343. CLKO and I/O Requirements...................................., 1 = 338. EUSART Synchronous Receive",
    "PIC18F6525/6621/8525/8621\nRequirements...................................................., 1 = 353. EUSART Synchronous Transmission Requirements...................................................., 1 = 353. Example SPI Mode Requirements (Master Mode, CKE = 0) ..................................., 1 = 345. Example SPI Mode Requirements (Master Mode, CKE = 1) ..................................., 1 = 346. Example SPI Mode Requirements (Slave",
    "PIC18F6525/6621/8525/8621\nMode, CKE = 0) ....................................., 1 = 347. Example SPI Slave Mode Requirements (CKE =, 1 = 1)................................... 348",
    "PIC18F6525/6621/8525/8621\nExternal Clock Requirements ..................................., 1 = 337. I 2 C Bus Data Requirements (Slave Mode)..............., 1 = 350. I 2 C Bus Start/Stop Bits Requirements (Slave Mode) ...................................................., 1 = 349. Master SSP I 2 C Bus Data Requirements, 1 = ................. 352. Master SSP I 2 C Bus Start/Stop Bits Requirements ..................................................., 1 =",
    "PIC18F6525/6621/8525/8621\n351. Parallel Slave Port Requirements............................., 1 = 344. PLL Clock ................................................................., 1 = 338. Program Memory Read Requirements....................., 1 = 339. Program Memory Write Requirements, 1 = ..................... 340. Reset, Watchdog Timer, Oscillator Start-up Timer, Power-up Timer and Brown-out Reset, 1 = Requirements ................ 341. Timer0 and Timer1 External Clock Requirements",
    "PIC18F6525/6621/8525/8621\n........................................., 1 = 342. PSPMODE Bit..................................................., 1 = 111, 128. TSTFSZ............................................................................, 1 = 315. Two-Word Instructions Example",
    "PIC18F6525/6621/8525/8621\nCases..........................................................., 1 = 46. TXSTAx Register BRGH Bit .................................................................., 1 = 217. V, 1 = . Voltage Reference Specifications....................................., 1 = 332. W, 1 = . Wake-up from",
    "PIC18F6525/6621/8525/8621\nSleep................................................., 1 = 259, 269. Using Interrupts, 1 = ........................................................ 269. Watchdog Timer (WDT)............................................, 1 = 259, 267. Associated Registers................................................, 1 = 268. Control",
    "PIC18F6525/6621/8525/8621\nRegister........................................................, 1 = 267. Postscaler................................................................., 1 = 268 .................................... Programming Considerations, 1 = 267. RC",
    "PIC18F6525/6621/8525/8621\nOscillator............................................................., 1 = 267. Time-out Period, 1 = ........................................................ 267 206. WCOL......................................................., 1 = 201, 202, 203, 201, 202, 203, 206. WCOL Status",
    "PIC18F6525/6621/8525/8621\nFlag...................................., 1 = ........................................................ WWW, On-Line Support, 1 = 5. X, 1 = . XORLW............................................................................., 1 = 315. XORWF, 1 =",
    "PIC18F6525/6621/8525/8621\n............................................................................ 316",
    "CUSTOMER SUPPORT\nMicrochip provides online support via our WWW site at www.microchip.com. This web site is used as a means to make  files and  information  easily available to customers. Accessible by using your favorite Internet browser, the web site contains the following information:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQ), technical support requests, online discussion groups, Microchip consultant program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "CUSTOMER CHANGE NOTIFICATION SERVICE\nMicrochip's  customer  notification  service  helps  keep customers current on Microchip products. Subscribers will receive  e-mail  notification  whenever  there  are changes,  updates,  revisions  or  errata  related  to  a specified product family or development tool of interest.\nTo register, access the Microchip web site at www.microchip.com. Under 'Support', click on 'Customer Change Notification' and follow the registration instructions.\nUsers  of  Microchip  products  can  receive  assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Field Application Engineer (FAE)\n\u00b7 Technical Support\nCustomers should contact their distributor, representative  or  field  application  engineer  (FAE)  for support. Local sales offices are also available to help customers.  A  listing  of  sales  offices  and  locations  is included in the back of this document.\nTechnical support is available through the web site at: http://microchip.com/support",
    "READER RESPONSE\nIt  is  our  intention  to  provide  you  with  the  best  documentation  possible to ensure  successful  use of your  Microchip product.  If  you  wish  to  provide  your  comments  on  organization,  clarity,  subject  matter,  and  ways  in  which  our documentation  can  better  serve  you,  please  FAX  your  comments  to  the  Technical  Publications  Manager  at (480) 792-4150.\nPlease list the following information, and use this outline to provide us with your comments about this document.\nTO: Technical Publications Manager\nRE: Reader Response\nTotal Pages Sent ________\nFrom: Name\nCompany\nAddress\nCity / State / ZIP / Country\nTelephone: (_______) _________ - _________\nApplication (optional):\nWould you like a reply?       Y         N\nDevice:  PIC18F6525/6621/8525/8621\nLiterature Number:  DS39612C\nQuestions:\nFAX: (______) _________ - _________\n1. What are the best features of this document?\n2. How does this document meet your hardware and software development needs?",
    "READER RESPONSE\n3. Do you find the organization of this document easy to follow? If not, why?\n4. What additions to the document do you think would enhance the structure and subject?\n5. What deletions from the document could be made without affecting the overall usefulness?\n6. Is there any incorrect or misleading information (what and where)?\n7. How would you improve this document?",
    "PIC18F6525/6621/8525/8621 PRODUCT IDENTIFICATION SYSTEM\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.",
    "PIC18F6525/6621/8525/8621 PRODUCT IDENTIFICATION SYSTEM\nDevice, \uf02d = PIC18F6525/6621/8525/8621 (1) , PIC18F6525/6621/8525/8621T (2) ; VDD range 4.2V to 5.5V PIC18LF6X2X/8X2X (1) , PIC18LF6X2X/8X2XT (2) ; VDD range 2.0V to 5.5V. Device, X Temperature Range = PIC18F6525/6621/8525/8621 (1) , PIC18F6525/6621/8525/8621T (2) ; VDD range 4.2V to 5.5V PIC18LF6X2X/8X2X (1) , PIC18LF6X2X/8X2XT (2) ; VDD range 2.0V to 5.5V. Device, /XX Package = PIC18F6525/6621/8525/8621 (1) , PIC18F6525/6621/8525/8621T (2)",
    "PIC18F6525/6621/8525/8621 PRODUCT IDENTIFICATION SYSTEM\n; VDD range 4.2V to 5.5V PIC18LF6X2X/8X2X (1) , PIC18LF6X2X/8X2XT (2) ; VDD range 2.0V to 5.5V. Device, XXX Pattern = PIC18F6525/6621/8525/8621 (1) , PIC18F6525/6621/8525/8621T (2) ; VDD range 4.2V to 5.5V PIC18LF6X2X/8X2X (1) , PIC18LF6X2X/8X2XT (2) ; VDD range 2.0V to 5.5V. Temperature Range, \uf02d = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range, X Temperature Range = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range, /XX Package = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E",
    "PIC18F6525/6621/8525/8621 PRODUCT IDENTIFICATION SYSTEM\n= -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range, XXX Pattern = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Package, \uf02d = PT = TQFP (Thin Quad Flatpack). Package, X Temperature Range = PT = TQFP (Thin Quad Flatpack). Package, /XX Package = PT = TQFP (Thin Quad Flatpack). Package, XXX Pattern = PT = TQFP (Thin Quad Flatpack). Pattern, \uf02d = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, X Temperature Range = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, /XX Package = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, XXX Pattern = QTP, SQTP, Code or Special Requirements (blank otherwise)",
    "Examples:\na) PIC18LF6621-I/PT 301 = Industrial temp., TQFP package, Extended VDD limits, QTP pattern #301.\nb) PIC18F8621-E/PT = Extended temp., TQFP package, standard VDD limits.\nNote 1: F =\nStandard Voltage Range\nLF\n=\nExtended Voltage Range\n2: T = in tape and reel",
    "Note the following details of the code protection feature on Microchip devices:\n\u00b7 Microchip products meet the specification contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is one of the most secure families of its kind on the market today, when used in the intended manner and under normal conditions.\n\u00b7 There are dishonest and possibly illegal methods used to breach the code protection feature. All of these methods, to our knowledge, require using the Microchip products in a manner outside the operating specifications contained in Microchip's Data Sheets. Most likely, the person doing so is engaged in theft of intellectual property.\n\u00b7 Microchip is willing to work with the customer who is concerned about the integrity of their code.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of their code. Code protection does not mean that we are guaranteeing the product as 'unbreakable.'",
    "Note the following details of the code protection feature on Microchip devices:\nCode protection is constantly evolving. We at Microchip are committed to continuously improving the code protection features of our products. Attempts to break Microchip's code protection feature may be a violation of the Digital Millennium Copyright Act. If such acts allow unauthorized access to your software or other copyrighted work, you may have a right to sue for relief under that Act.",
    "Note the following details of the code protection feature on Microchip devices:\nInformation  contained  in  this  publication  regarding  device applications and the like is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure  that  your  application  meets  with  your  specifications. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES  OF  ANY  KIND  WHETHER  EXPRESS  OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION, INCLUDING  BUT  NOT  LIMITED  TO  ITS CONDITION, QUALITY, PERFORMANCE, MERCHANTABILITY OR FITNESS  FOR  PURPOSE . Microchip  disclaims  all  liability arising  from  this  information  and  its  use.  Use  of  Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold  harmless  Microchip  from  any  and  all  damages,  claims, suits,  or  expenses  resulting  from  such  use.  No  licenses  are conveyed, implicitly or otherwise, under any Microchip intellectual property rights.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, dsPIC, FlashFlex, KEELOQ, KEELOQ logo, MPLAB, PIC, PICmicro, PICSTART, PIC 32  logo, rfPIC, SST, SST Logo, SuperFlash and UNI/O are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nFilterLab, Hampshire, HI-TECH C, Linear Active Thermistor, MTP, SEEVAL and The Embedded Control Solutions Company are registered trademarks of Microchip Technology Incorporated in the U.S.A.\nSilicon Storage Technology is a registered trademark of Microchip Technology Inc. in other countries.",
    "Trademarks\nAnalog-for-the-Digital Age, Application Maestro, BodyCom, chipKIT, chipKIT logo, CodeGuard, dsPICDEM, dsPICDEM.net, dsPICworks, dsSPEAK, ECAN, ECONOMONITOR, FanSense, HI-TIDE, In-Circuit Serial Programming, ICSP, Mindi, MiWi, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, mTouch, Omniscient Code Generation, PICC, PICC-18, PICDEM, PICDEM.net, PICkit, PICtail, REAL ICE, rfLAB, Select Mode, SQI, Serial Quad I/O, Total Endurance, TSHARC, UniWinDriver, WiperLock, ZENA and Z-Scale are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nGestIC and ULPP are registered trademarks of Microchip Technology Germany II GmbH & Co. & KG, a subsidiary of Microchip Technology Inc., in other countries.",
    "Trademarks\nAll other trademarks mentioned herein are property of their respective companies.\n\u00a9 2003-2013, Microchip Technology Incorporated, Printed in the U.S.A., All Rights Reserved.\nPrinted on recycled paper.\nISBN: 9781620769645\nMicrochip received ISO/TS-16949:2009 certification for its worldwide headquarters, design and wafer fabrication facilities in Chandler and Tempe, Arizona; Gresham, Oregon and design centers in California and India. The Company's quality system processes and procedures are for its PIC \u00ae MCUs and dsPIC \u00ae  DSCs, KEELOQ \u00ae  code hopping devices, Serial EEPROMs, microperipherals, nonvolatile memory and analog products. In addition, Microchip's quality system for the design and manufacture of development systems is ISO 9001:2000 certified.\nQUALITY MANAGEMENT  SYSTEM CERTIFIED BY DNV == ISO/TS 16949 ==",
    "AMERICAS\nCorporate Office 2355 West Chandler Blvd. Chandler, AZ 85224-6199 Tel: 480-792-7200 Fax: 480-792-7277 Technical Support:\nhttp://www.microchip.com/ support\nWeb Address:\nwww.microchip.com\nAtlanta Duluth, GA Tel: 678-957-9614 Fax: 678-957-1455",
    "Boston\nWestborough, MA Tel: 774-760-0087 Fax: 774-760-0088",
    "Chicago\nItasca, IL Tel: 630-285-0071 Fax: 630-285-0075\nCleveland Independence, OH Tel: 216-447-0464 Fax: 216-447-0643\nDallas Addison, TX Tel: 972-818-7423 Fax: 972-818-2924\nDetroit Farmington Hills, MI Tel: 248-538-2250 Fax: 248-538-2260\nIndianapolis Noblesville, IN Tel: 317-773-8323 Fax: 317-773-5453",
    "Los Angeles\nMission Viejo, CA Tel: 949-462-9523 Fax: 949-462-9608\nSanta Clara Santa Clara, CA Tel: 408-961-6444 Fax: 408-961-6445\nToronto Mississauga, Ontario, Canada Tel: 905-673-0699 Fax: 905-673-6509",
    "ASIA/PACIFIC\nAsia Pacific Office Suites 3707-14, 37th Floor Tower 6, The Gateway Harbour City, Kowloon Hong Kong Tel: 852-2401-1200 Fax: 852-2401-3431\nAustralia - Sydney Tel: 61-2-9868-6733 Fax: 61-2-9868-6755\nChina - Beijing Tel: 86-10-8569-7000 Fax: 86-10-8528-2104\nChina - Chengdu Tel: 86-28-8665-5511 Fax: 86-28-8665-7889\nChina - Chongqing Tel: 86-23-8980-9588 Fax: 86-23-8980-9500\nChina - Hangzhou Tel: 86-571-2819-3187 Fax: 86-571-2819-3189\nChina - Hong Kong SAR Tel: 852-2943-5100 Fax: 852-2401-3431\nChina - Nanjing Tel: 86-25-8473-2460 Fax: 86-25-8473-2470",
    "ASIA/PACIFIC\nChina - Qingdao Tel: 86-532-8502-7355 Fax: 86-532-8502-7205\nChina - Shanghai Tel: 86-21-5407-5533 Fax: 86-21-5407-5066\nChina - Shenyang Tel: 86-24-2334-2829 Fax: 86-24-2334-2393\nChina - Shenzhen Tel: 86-755-8864-2200 Fax: 86-755-8203-1760\nChina - Wuhan Tel: 86-27-5980-5300 Fax: 86-27-5980-5118",
    "China - Xian\nTel: 86-29-8833-7252 Fax: 86-29-8833-7256\nChina - Xiamen Tel: 86-592-2388138 Fax: 86-592-2388130\nChina - Zhuhai\nTel: 86-756-3210040 Fax: 86-756-3210049\nIndia - Bangalore Tel: 91-80-3090-4444 Fax: 91-80-3090-4123\nIndia - New Delhi Tel: 91-11-4160-8631 Fax: 91-11-4160-8632\nIndia - Pune Tel: 91-20-2566-1512 Fax: 91-20-2566-1513\nJapan - Osaka Tel: 81-6-6152-7160 Fax: 81-6-6152-9310\nJapan - Tokyo\nTel: 81-3-6880- 3770\nFax: 81-3-6880-3771\nKorea - Daegu Tel: 82-53-744-4301 Fax: 82-53-744-4302",
    "China - Xian\nKorea - Seoul Tel: 82-2-554-7200 Fax: 82-2-558-5932 or 82-2-558-5934\nMalaysia - Kuala Lumpur Tel: 60-3-6201-9857 Fax: 60-3-6201-9859\nMalaysia - Penang Tel: 60-4-227-8870 Fax: 60-4-227-4068\nPhilippines - Manila Tel: 63-2-634-9065 Fax: 63-2-634-9069",
    "Singapore\nTel: 65-6334-8870 Fax: 65-6334-8850\nTaiwan - Hsin Chu Tel: 886-3-5778-366 Fax: 886-3-5770-955\nTaiwan - Kaohsiung Tel: 886-7-213-7828 Fax: 886-7-330-9305\nTaiwan - Taipei Tel: 886-2-2508-8600 Fax: 886-2-2508-0102",
    "Thailand - Bangkok\nTel: 66-2-694-1351 Fax: 66-2-694-1350",
    "EUROPE\nAustria - Wels Tel: 43-7242-2244-39 Fax: 43-7242-2244-393 Denmark - Copenhagen Tel: 45-4450-2828 Fax: 45-4485-2829\nFrance - Paris Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79\nGermany - Munich Tel: 49-89-627-144-0 Fax: 49-89-627-144-44",
    "Italy - Milan\nTel: 39-0331-742611 Fax: 39-0331-466781",
    "Netherlands - Drunen\nTel: 31-416-690399 Fax: 31-416-690340\nSpain - Madrid Tel: 34-91-708-08-90 Fax: 34-91-708-08-91\nUK - Wokingham Tel: 44-118-921-5869 Fax: 44-118-921-5820",
    "Mouser Electronics\nAuthorized Distributor\nClick to View Pricing, Inventory, Delivery & Lifecycle Information:\nMicrochip:\nPIC18LF6621-I/PT\u00a0 PIC18F6525-E/PT\u00a0 PIC18F6621T-I/PT\u00a0 PIC18F8525-I/PT\u00a0 PIC18F6525-I/PT\u00a0 PIC18F6621-I/PT PIC18F8525T-I/PT\u00a0 PIC18LF6525-I/PT\u00a0 PIC18LF8525-I/PT\u00a0 PIC18LF8621-I/PT\u00a0 PIC18F8621-I/PT"
]
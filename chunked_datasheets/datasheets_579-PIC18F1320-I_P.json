[
    "Peripheral Highlights\n\u00b7 Power Managed modes:\n-Run: CPU on, peripherals on\n-Idle: CPU off, peripherals on\n-Sleep: CPU off, peripherals off\n\u00b7 Power Consumption modes:\n-PRI_RUN: 150 \uf06d A, 1 MHz, 2V\n-PRI_IDLE: 37 \uf06d A, 1 MHz, 2V\n-SEC_RUN: 14 \uf06d A, 32 kHz, 2V\n-SEC_IDLE: 5.8 \uf06d A, 32 kHz, 2V\n-RC_RUN: 110 \uf06d A, 1 MHz, 2V\n-RC_IDLE: 52 \uf06d A, 1 MHz, 2V\n-Sleep: 0.1 \uf06d A, 1 MHz, 2V\n\u00b7 Timer1 Oscillator: 1.1 \uf06d A, 32 kHz, 2V\n\u00b7 Watchdog Timer: 2.1 \uf06d A\n\u00b7 Two-Speed Oscillator Start-up",
    "Oscillators\n\u00b7 Four Crystal modes:\n-LP, XT, HS: up to 25 MHz\n-HSPLL: 4-10 MHz (16-40 MHz internal)\n\u00b7 Two External RC modes, up to 4 MHz\n\u00b7 Two External Clock modes, up to 40 MHz\n\u00b7 Internal Oscillator Block:\n-8 user-selectable frequencies: 31 kHz, 125 kHz, 250 kHz, 500 kHz, 1 MHz, 2 MHz, 4 MHz, 8 MHz\n-125 kHz to 8 MHz calibrated to 1%\n-Two modes select one or two I/O pins\n-OSCTUNE - Allows user to shift frequency\n\u00b7 Secondary Oscillator using Timer1 @ 32 kHz\n\u00b7 Fail-Safe Clock Monitor\n-Allows for safe shutdown if peripheral clock stops\n\u00b7 High Current Sink/Source 25 mA/25 mA\n\u00b7 Three External Interrupts\n\u00b7 Enhanced Capture/Compare/PWM (ECCP) module:\n-One, two or four PWM outputs\n-Selectable polarity\n-Programmable dead time\n-Auto-Shutdown and Auto-Restart\n-Capture is 16-bit, max resolution 6.25 ns (TCY/16)\n-Compare is 16-bit, max resolution 100 ns (TCY)",
    "Oscillators\n\u00b7 Compatible 10-bit, up to 13-Channel Analog-toDigital Converter module (A/D) with Programmable Acquisition Time\n\u00b7 Enhanced USART module:\n-Supports RS-485, RS-232 and LIN 1.2\n-Auto-Wake-up on Start bit\n-Auto-Baud Detect",
    "Special Microcontroller Features\n\u00b7 100,000 Erase/Write Cycle Enhanced Flash Program Memory, typical\n\u00b7 1,000,000 Erase/Write Cycle Data EEPROM Memory, typical\n\u00b7 Flash/Data EEPROM Retention: > 40 years\n\u00b7 Self-Programmable under Software Control\n\u00b7 Priority Levels for Interrupts\n\u00b7 8 x 8 Single-Cycle Hardware Multiplier\n\u00b7 Extended Watchdog Timer (WDT):\n-Programmable period from 41 ms to 131s\n-2% stability over VDD and Temperature\n\u00b7 Single-Supply 5V In-Circuit Serial Programming\u2122 (ICSP\u2122) via Two Pins\n\u00b7 In-Circuit Debug (ICD) via Two Pins\n\u00b7 Wide Operating Voltage Range: 2.0V to 5.5V",
    "Special Microcontroller Features\nPIC18F1220, Program Memory.Flash (bytes) = 4K. PIC18F1220, Program Memory.# Single-Word Instructions = 2048. PIC18F1220, Data Memory.SRAM (bytes) = 256. PIC18F1220, Data Memory.EEPROM (bytes) = 256. PIC18F1220, I/O. = 16. PIC18F1220, 10-bit A/D (ch). = 7. PIC18F1220, ECCP (PWM). = 1. PIC18F1220, EUSART = Y. PIC18F1220, Timers 8/16-bit = 1/3. PIC18F1320, Program Memory.Flash (bytes) = 8K. PIC18F1320, Program Memory.# Single-Word Instructions = 4096. PIC18F1320, Data Memory.SRAM (bytes) = 256. PIC18F1320, Data Memory.EEPROM (bytes) = 256. PIC18F1320, I/O. = 16. PIC18F1320, 10-bit A/D (ch). =",
    "Special Microcontroller Features\n7. PIC18F1320, ECCP (PWM). = 1. PIC18F1320, EUSART = Y. PIC18F1320, Timers 8/16-bit = 1/3",
    "Table of Contents\n1.0, 1 = Device Overview ........................................................................................................................................................................... 1.0, 2 = 5. 2.0, 1 = Oscillator Configurations",
    "Table of Contents\n............................................................................................................................................................. 2.0, 2 = 10. 3.0, 1 = Power Managed Modes",
    "Table of Contents\n.............................................................................................................................................................. 3.0, 2 = 18. 4.0, 1 =",
    "Table of Contents\nReset........................................................................................................................................................................................... 4.0, 2 = 31. 5.0, 1 = Memory",
    "Table of Contents\nOrganization.................................................................................................................................................................. 5.0, 2 = 39. 6.0, 1 = Flash Program",
    "Table of Contents\nMemory............................................................................................................................................................... 6.0, 2 = 55. 7.0, 1 = Data EEPROM",
    "Table of Contents\nMemory.............................................................................................................................................................. 7.0, 2 = 64. 8.0, 1 = 8 x 8 Hardware",
    "Table of Contents\nMultiplier............................................................................................................................................................. 8.0, 2 = 68. 9.0, 1 = Interrupts",
    "Table of Contents\n..................................................................................................................................................................................... 9.0, 2 = 70. 10.0, 1 = I/O Ports",
    "Table of Contents\n...................................................................................................................................................................................... 10.0, 2 = 83. 11.0, 1 = Timer0 Module",
    "Table of Contents\n............................................................................................................................................................................ 11.0, 2 = 95. 12.0, 1 = Timer1 Module",
    "Table of Contents\n............................................................................................................................................................................ 12.0, 2 = 98. 13.0, 1 = Timer2 Module",
    "Table of Contents\n.......................................................................................................................................................................... 13.0, 2 = 104. 14.0, 1 = Timer3 Module",
    "Table of Contents\n.......................................................................................................................................................................... 14.0, 2 = 106. 15.0, 1 = Enhanced Capture/Compare/PWM (ECCP)",
    "Table of Contents\nModule................................................................................................................. 15.0, 2 = 109. 16.0, 1 = Enhanced Addressable Universal Synchronous Asynchronous Receiver Transmitter (EUSART)........................................... 16.0, 2 = 126. 17.0, 1 = 10-Bit Analog-to-Digital Converter (A/D) Module",
    "Table of Contents\n...................................................................................................................... 17.0, 2 = 149. 18.0, 1 = Low-Voltage",
    "Table of Contents\nDetect................................................................................................................................................................... 18.0, 2 = 160. 19.0, 1 = Special Features of the",
    "Table of Contents\nCPU..................................................................................................................................................... 19.0, 2 = 165. 20.0, 1 = Instruction Set",
    "Table of Contents\nSummary........................................................................................................................................................... 20.0, 2 = 184. 21.0, 1 = Development",
    "Table of Contents\nSupport................................................................................................................................................................ 21.0, 2 = 226. 22.0, 1 = Electrical",
    "Table of Contents\nCharacteristics........................................................................................................................................................... 22.0, 2 = 230. 23.0, 1 = DC and AC Characteristics Graphs and",
    "Table of Contents\nTables........................................................................................................................ 23.0, 2 = 262. 24.0, 1 = Packaging",
    "Table of Contents\nInformation............................................................................................................................................................... 24.0, 2 = 280. Appendix A: Revision",
    "Table of Contents\nHistory............................................................................................................................................................., 1 = Appendix A: Revision",
    "Table of Contents\nHistory.............................................................................................................................................................. Appendix A: Revision",
    "Table of Contents\nHistory............................................................................................................................................................., 2 = 290. Appendix B: Device Differences",
    "Table of Contents\n........................................................................................................................................................, 1 = Appendix B: Device Differences",
    "Table of Contents\n......................................................................................................................................................... Appendix B: Device Differences",
    "Table of Contents\n........................................................................................................................................................, 2 = 290. Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 1 = Appendix C: Conversion Considerations",
    "Table of Contents\n............................................................................................................................................ Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 2 = 291. Appendix D: Migration from Baseline to Enhanced",
    "Table of Contents\nDevices.............................................................................................................., 1 = Appendix D: Migration from Baseline to Enhanced Devices............................................................................................................... Appendix D: Migration from Baseline to Enhanced",
    "Table of Contents\nDevices.............................................................................................................., 2 = 291. Appendix E: Migration from Mid-Range to Enhanced Devices.........................................................................................................., 1 = Appendix E: Migration from Mid-Range to Enhanced",
    "Table of Contents\nDevices........................................................................................................... Appendix E: Migration from Mid-Range to Enhanced Devices.........................................................................................................., 2 = 292. Appendix F: Migration from High-End to Enhanced",
    "Table of Contents\nDevices............................................................................................................., 1 = Appendix F: Migration from High-End to Enhanced Devices.............................................................................................................. Appendix F: Migration from High-End to Enhanced",
    "Table of Contents\nDevices............................................................................................................., 2 = 292. The Microchip Web",
    "Table of Contents\nSite....................................................................................................................................................................., 1 = The Microchip Web",
    "Table of Contents\nSite...................................................................................................................................................................... The Microchip Web",
    "Table of Contents\nSite....................................................................................................................................................................., 2 = 293. Customer Change Notification Service",
    "Table of Contents\n.............................................................................................................................................., 1 = Customer Change Notification Service",
    "Table of Contents\n............................................................................................................................................... Customer Change Notification Service",
    "Table of Contents\n.............................................................................................................................................., 2 = 293. Customer",
    "Table of Contents\nSupport.............................................................................................................................................................................., 1 = Customer",
    "Table of Contents\nSupport............................................................................................................................................................................... Customer",
    "Table of Contents\nSupport.............................................................................................................................................................................., 2 = 293. PIC18F1220/1320 Product Identification System",
    "Table of Contents\n.............................................................................................................................., 1 = PIC18F1220/1320 Product Identification System",
    "Table of Contents\n............................................................................................................................... PIC18F1220/1320 Product Identification System",
    "Table of Contents\n.............................................................................................................................., 2 = 294",
    "TO OUR VALUED CUSTOMERS\nIt is our intention to provide our valued customers with the best documentation possible to ensure successful use of your Microchip products. To this end, we will continue to improve our publications to better suit your needs. Our publications will be refined and enhanced as new volumes and updates are introduced.\nIf you have any questions or comments regarding this publication, please contact the Marketing Communications Department via E-mail at docerrors@microchip.com . We welcome your feedback.",
    "Most Current Data Sheet\nTo obtain the most up-to-date version of this data sheet, please register at our Worldwide Web site at:",
    "http://www.microchip.com\nYou can determine the version of a data sheet by examining its literature number found on the bottom outside corner of any page. The last character of the literature number is the version number, (e.g., DS30000000A is version A of document DS30000000).",
    "Errata\nAn errata sheet, describing minor operational differences from the data sheet and recommended workarounds, may exist for current devices. As device/documentation issues become known to us, we will publish an errata sheet. The errata will specify the revision of silicon and revision of document to which it applies.\nTo determine if an errata sheet exists for a particular device, please check with one of the following:\n\u00b7 Microchip's Worldwide Web site; http://www.microchip.com\n\u00b7 Your local Microchip sales office (see last page)\nWhen contacting a sales office, please specify which device, revision of silicon and data sheet (include literature number) you are using.",
    "Customer Notification System\nRegister on our web site at www.microchip.com to receive the most current information on all of our products.",
    "1.0 DEVICE OVERVIEW\nThis document contains device specific information for the following devices:\n\u00b7 PIC18F1220\n\u00b7 PIC18F1320\nThis family offers the advantages of all PIC18 microcontrollers - namely, high computational performance at an economical price - with the addition of high endurance Enhanced Flash program memory. On top of these features,  the  PIC18F1220/1320  family  introduces  design enhancements that make these microcontrollers a logical choice  for many  high-performance,  power  sensitive applications.",
    "1.1.1 POWER MODES\nAll of the devices in the PIC18F1220/1320 family incorporate a range of features that can significantly reduce power consumption during operation. Key items include:\n\u00b7 Alternate  Run  Modes: By  clocking  the  controller from  the  Timer1  source  or  the  internal  oscillator block,  power  consumption  during  code  execution can be reduced by as much as 90%.\n\u00b7 Multiple  Idle  Modes: The  controller  can  also  run with its CPU core disabled, but the peripherals are still active. In these states, power consumption can be reduced even further, to as little as 4% of normal operation requirements.\n\u00b7 On-the-fly Mode Switching: The power managed modes are invoked by user code during operation, allowing the user to incorporate power-saving ideas into their application's software design.\n\u00b7 Lower Consumption in Key Modules: The power requirements  for  both  Timer1  and  the  Watchdog Timer have been reduced by up to 80%, with typical values of 1.1 and 2.1 \uf06d A, respectively.",
    "1.1.2 MULTIPLE OSCILLATOR OPTIONS AND FEATURES\nAll of the devices in the PIC18F1220/1320 family offer nine different oscillator options, allowing users a wide range of choices in developing application hardware. These include:\n\u00b7 Four  Crystal modes,  using  crystals or ceramic resonators.\n\u00b7 Two  External  Clock  modes,  offering  the  option  of using  two  pins  (oscillator  input  and  a  divide-by-4 clock  output),  or  one  pin  (oscillator  input,  with  the second pin reassigned as general I/O).\n\u00b7 Two External  RC Oscillator  modes,  with  the  same pin options as the External Clock modes.\n\u00b7 An  internal oscillator block, which  provides an 8 MHz clock (\u00b12% accuracy) and an INTRC source (approximately 31 kHz, stable over temperature and VDD), as well as a range of six user-selectable clock frequencies (from 125 kHz to 4 MHz) for a total of 8 clock frequencies.\nBesides its availability as a clock source, the internal oscillator block provides a stable reference source that gives the family additional features for robust operation:",
    "1.1.2 MULTIPLE OSCILLATOR OPTIONS AND FEATURES\n\u00b7 Fail-Safe  Clock  Monitor: This  option  constantly monitors the main clock source against a reference signal provided by the internal oscillator. If a clock failure occurs, the controller is switched to the internal oscillator block,  allowing  for  continued  low-speed operation, or a safe application shutdown.\n\u00b7 Two-Speed Start-up: This option allows the internal oscillator to serve as the clock source from Poweron  Reset,  or  wake-up  from  Sleep  mode,  until  the primary  clock  source  is  available.  This  allows  for code execution during what would otherwise be the clock start-up interval and can even allow an application to perform routine background activities and return to Sleep without returning to full-power operation.",
    "1.2 Other Special Features\n\u00b7 Memory Endurance: The Enhanced Flash cells for both program memory and data EEPROM are rated to  last  for  many  thousands  of  erase/write  cycles  up to 100,000 for program memory and 1,000,000 for EEPROM.  Data  retention  without  refresh  is conservatively estimated to be greater than 40 years.\n\u00b7 Self-programmability: These devices can write to their  own  program  memory  spaces  under  internal software  control.  By  using  a  bootloader  routine located in the protected Boot Block at the top of program  memory,  it  becomes  possible  to  create  an application that can update itself in the field.\n\u00b7 Enhanced  CCP  module: In PWM  mode,  this module  provides  1,  2  or  4  modulated  outputs  for controlling half-bridge and full-bridge drivers. Other features include auto-shutdown, for disabling PWM outputs  on  interrupt  or  other  select  conditions  and auto-restart, to reactivate outputs once the condition has cleared.",
    "1.2 Other Special Features\n\u00b7 Enhanced USART: This serial communication module features automatic wake-up on Start bit and automatic baud rate detection and supports RS-232, RS-485  and  LIN  1.2  protocols,  making  it  ideally suited  for  use  in  Local  Interconnect  Network  (LIN) bus applications.\n\u00b7 10-bit  A/D  Converter: This  module  incorporates programmable acquisition time, allowing for a channel  to  be  selected  and  a  conversion  to  be initiated  without  waiting  for  a  sampling  period  and thus, reduce code overhead.\n\u00b7 Extended Watchdog Timer (WDT): This enhanced version  incorporates  a  16-bit  prescaler,  allowing  a time-out range from 4 ms to over two minutes that is stable across operating voltage and temperature.",
    "1.3 Details on Individual Family Members\nDevices in the PIC18F1220/1320 family are available in 18-pin, 20-pin and 28-pin packages. A block diagram for this device family is shown in Figure 1-1.\nThe devices are differentiated from each other only in the amount of on-chip Flash program memory (4 Kbytes for the PIC18F1220 device, 8 Kbytes for the PIC18F1320  device).  These  and  other  features  are summarized in Table 1-1.",
    "TABLE 1-1: DEVICE FEATURES\nOperating Frequency, PIC18F1220 = DC - 40 MHz. Operating Frequency, PIC18F1320 = DC - 40 MHz. Program Memory (Bytes), PIC18F1220 = 4096. Program Memory (Bytes), PIC18F1320 = 8192. Program Memory (Instructions), PIC18F1220 = 2048. Program Memory (Instructions), PIC18F1320 = 4096. Data Memory (Bytes), PIC18F1220 = 256. Data Memory (Bytes), PIC18F1320 = 256. Data EEPROM Memory (Bytes), PIC18F1220 = 256. Data EEPROM Memory (Bytes), PIC18F1320 = 256. Interrupt Sources, PIC18F1220 = 15. Interrupt Sources, PIC18F1320 = 15. I/O Ports, PIC18F1220 = Ports A, B. I/O Ports, PIC18F1320 = Ports A, B. Timers, PIC18F1220 = 4. Timers, PIC18F1320 = 4. Enhanced Capture/Compare/PWM Modules, PIC18F1220 = 1. Enhanced",
    "TABLE 1-1: DEVICE FEATURES\nCapture/Compare/PWM Modules, PIC18F1320 = 1. Serial Communications, PIC18F1220 = Enhanced USART. Serial Communications, PIC18F1320 = Enhanced USART. 10-bit Analog-to-Digital Module, PIC18F1220 = 7 input channels. 10-bit Analog-to-Digital Module, PIC18F1320 = 7 input channels. Resets (and Delays), PIC18F1220 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Resets (and Delays), PIC18F1320 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Programmable Low-Voltage Detect, PIC18F1220 = Yes. Programmable Low-Voltage Detect, PIC18F1320 = Yes. Programmable Brown-out Reset, PIC18F1220 = Yes. Programmable Brown-out Reset, PIC18F1320 = Yes. Instruction Set, PIC18F1220 = 75 Instructions. Instruction Set,",
    "TABLE 1-1: DEVICE FEATURES\nPIC18F1320 = 75 Instructions. Packages, PIC18F1220 = 18-pin SDIP 18-pin SOIC 20-pin SSOP 28-pin QFN. Packages, PIC18F1320 = 18-pin SDIP 18-pin SOIC 20-pin SSOP 28-pin QFN\nA  block  diagram  of  the  PIC18F1220/1320  device architecture is provided in Figure 1-1. The pinouts for this device family are listed in Table 1-2.",
    "FIGURE 1-1: PIC18F1220/1320 BLOCK DIAGRAM\n- 2: OSC1, OSC2, CLKI and CLKO are only available in select oscillator modes and when these pins are not being used as digital I/O. Refer to Section 2.0 'Oscillator Configurations' for additional information.",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS\nMCLR/VPP/RA5 MCLR, Pin Number.PDIP/ SOIC = 4. MCLR/VPP/RA5 MCLR, Pin Number.SSOP = 4. MCLR/VPP/RA5 MCLR, Pin Number.QFN = 1. MCLR/VPP/RA5 MCLR, Pin.Type = I. MCLR/VPP/RA5 MCLR, Buffer Type = ST. MCLR/VPP/RA5 MCLR, Description = Master Clear (input) or programming voltage (input). Master Clear (Reset) input. This pin is an active-low Reset to the device.. VPP RA5, Pin Number.PDIP/ SOIC = . VPP RA5, Pin Number.SSOP = . VPP RA5, Pin Number.QFN = . VPP RA5, Pin.Type = P I. VPP RA5, Buffer Type = - ST. VPP RA5, Description = Programming voltage input. Digital input.. OSC1/CLKI/RA7 OSC1, Pin Number.PDIP/",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS\nSOIC = 16. OSC1/CLKI/RA7 OSC1, Pin Number.SSOP = 18. OSC1/CLKI/RA7 OSC1, Pin Number.QFN = 21. OSC1/CLKI/RA7 OSC1, Pin.Type = I. OSC1/CLKI/RA7 OSC1, Buffer Type = ST. OSC1/CLKI/RA7 OSC1, Description = Oscillator crystal or external clock input. Oscillator crystal input or external clock source input. ST buffer when configured in RC mode, CMOS otherwise.. CLKI, Pin Number.PDIP/ SOIC = . CLKI, Pin Number.SSOP = . CLKI, Pin Number.QFN = . CLKI, Pin.Type = I. CLKI, Buffer Type = CMOS. CLKI, Description = External clock source input. Always associated with pin function OSC1. (See related OSC1/CLKI, OSC2/CLKO pins.). RA7, Pin Number.PDIP/ SOIC",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS\n= . RA7, Pin Number.SSOP = . RA7, Pin Number.QFN = . RA7, Pin.Type = I/O. RA7, Buffer Type = ST. RA7, Description = General purpose I/O pin.. OSC2/CLKO/RA6 OSC2, Pin Number.PDIP/ SOIC = 15. OSC2/CLKO/RA6 OSC2, Pin Number.SSOP = 17. OSC2/CLKO/RA6 OSC2, Pin Number.QFN = 20. OSC2/CLKO/RA6 OSC2, Pin.Type = O. OSC2/CLKO/RA6 OSC2, Buffer Type = -. OSC2/CLKO/RA6 OSC2, Description = Oscillator crystal or clock output. Oscillator crystal output. Connects to crystal or resonator in Crystal Oscillator mode.. CLKO, Pin Number.PDIP/ SOIC = . CLKO, Pin Number.SSOP = . CLKO, Pin",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS\nNumber.QFN = . CLKO, Pin.Type = O. CLKO, Buffer Type = -. CLKO, Description = In RC, EC and INTRC modes, OSC2 pin outputs CLKO, which has 1/4 the frequency of OSC1 and denotes instruction cycle rate.. RA6, Pin Number.PDIP/ SOIC = . RA6, Pin Number.SSOP = . RA6, Pin Number.QFN = . RA6, Pin.Type = I/O. RA6, Buffer Type = ST. RA6, Description = General purpose I/O pin.. , Pin Number.PDIP/ SOIC = . , Pin Number.SSOP = . , Pin Number.QFN = . , Pin.Type = . , Buffer Type = . , Description = PORTA is a bidirectional I/O port.. RA0/AN0 RA0 AN0, Pin Number.PDIP/ SOIC = 1. RA0/AN0 RA0 AN0, Pin Number.SSOP = 1. RA0/AN0 RA0 AN0, Pin",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS\nNumber.QFN = 26. RA0/AN0 RA0 AN0, Pin.Type = I/O I I/O I I I/O I I. RA0/AN0 RA0 AN0, Buffer Type = ST Analog. RA0/AN0 RA0 AN0, Description = Digital I/O. Analog input. RA1/AN1/LVDIN RA1 AN1 LVDIN, Pin Number.PDIP/ SOIC = 2. RA1/AN1/LVDIN RA1 AN1 LVDIN, Pin Number.SSOP = 2. RA1/AN1/LVDIN RA1 AN1 LVDIN, Pin Number.QFN = 27. RA1/AN1/LVDIN RA1 AN1 LVDIN, Pin.Type = I/O I I/O I I I/O I I. RA1/AN1/LVDIN RA1 AN1 LVDIN, Buffer Type = ST Analog. RA1/AN1/LVDIN RA1 AN1 LVDIN, Description = Digital I/O. Analog input",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS\n1.. RA2/AN2/VREF- RA2 AN2 VREF-, Pin Number.PDIP/ SOIC = 6. RA2/AN2/VREF- RA2 AN2 VREF-, Pin Number.SSOP = 7. RA2/AN2/VREF- RA2 AN2 VREF-, Pin Number.QFN = 7. RA2/AN2/VREF- RA2 AN2 VREF-, Pin.Type = I/O I I/O I I I/O I I. RA2/AN2/VREF- RA2 AN2 VREF-, Buffer Type = ST Analog Analog. RA2/AN2/VREF- RA2 AN2 VREF-, Description = Digital I/O. Analog input 2. A/D reference voltage (low) input.. RA3/AN3/VREF+ RA3 AN3 VREF+, Pin Number.PDIP/ SOIC = 7. RA3/AN3/VREF+ RA3 AN3 VREF+, Pin Number.SSOP = 8.",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS\nRA3/AN3/VREF+ RA3 AN3 VREF+, Pin Number.QFN = 8. RA3/AN3/VREF+ RA3 AN3 VREF+, Pin.Type = I/O. RA3/AN3/VREF+ RA3 AN3 VREF+, Buffer Type = ST Analog Analog. RA3/AN3/VREF+ RA3 AN3 VREF+, Description = Digital I/O. Analog input 3. A/D reference voltage (high) input.. RA4/T0CKI RA4 T0CKI, Pin Number.PDIP/ SOIC = 3. RA4/T0CKI RA4 T0CKI, Pin Number.SSOP = 3. RA4/T0CKI RA4 T0CKI, Pin Number.QFN = 28. RA4/T0CKI RA4 T0CKI, Pin.Type = I/O. RA4/T0CKI RA4 T0CKI, Buffer Type = ST/OD ST. RA4/T0CKI RA4 T0CKI, Description = Digital",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS\nI/O. Open-drain when configured as output. Timer0 external clock input. See the MCLR/VPP/RA5 pin.. RA5, Pin Number.PDIP/ SOIC = . RA5, Pin Number.SSOP = . RA5, Pin Number.QFN = . RA5, Pin.Type = . RA5, Buffer Type = . RA5, Description = . RA6, Pin Number.PDIP/ SOIC = . RA6, Pin Number.SSOP = . RA6, Pin Number.QFN = . RA6, Pin.Type = . RA6, Buffer Type = . RA6, Description = See the OSC2/CLKO/RA6 pin.. RA7, Pin Number.PDIP/ SOIC = . RA7, Pin Number.SSOP = . RA7, Pin Number.QFN = . RA7, Pin.Type = . RA7, Buffer Type = . RA7, Description = See the OSC1/CLKI/RA7 pin.\nLegend:\nCMOS\n- = CMOS compatible input or output\nI\nP\n= Input",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS\n= Power\nTTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels\nO = Output\nOD = Open-drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\n, Pin Number.PDIP/ SOIC = 8. , Pin Number.SSOP = 9. , Pin Number.QFN = 9. , Pin.Type = . , Buffer.Type = . , Description = PORTB is a bidirectional I/O port. PORTB can be software programmed for internal weak pull-ups on all inputs.. RB0/AN4/INT0 RB0, Pin Number.PDIP/ SOIC = . RB0/AN4/INT0 RB0, Pin Number.SSOP = . RB0/AN4/INT0 RB0, Pin Number.QFN = . RB0/AN4/INT0 RB0, Pin.Type = I/O. RB0/AN4/INT0 RB0, Buffer.Type = TTL. RB0/AN4/INT0 RB0, Description = Digital I/O.. AN4, Pin Number.PDIP/ SOIC = . AN4, Pin Number.SSOP = . AN4, Pin Number.QFN = . AN4, Pin.Type = I.",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nAN4, Buffer.Type = Analog. AN4, Description = Analog input 4.. INT0, Pin Number.PDIP/ SOIC = . INT0, Pin Number.SSOP = . INT0, Pin Number.QFN = . INT0, Pin.Type = I. INT0, Buffer.Type = ST. INT0, Description = External interrupt 0.. RB1/AN5/TX/CK/INT1, Pin Number.PDIP/ SOIC = 9. RB1/AN5/TX/CK/INT1, Pin Number.SSOP = 10. RB1/AN5/TX/CK/INT1, Pin Number.QFN = 10. RB1/AN5/TX/CK/INT1, Pin.Type = . RB1/AN5/TX/CK/INT1, Buffer.Type = . RB1/AN5/TX/CK/INT1, Description = . RB1, Pin Number.PDIP/ SOIC = . RB1, Pin Number.SSOP = . RB1, Pin Number.QFN = .",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB1, Pin.Type = I/O. RB1, Buffer.Type = TTL. RB1, Description = Digital I/O.. AN5, Pin Number.PDIP/ SOIC = . AN5, Pin Number.SSOP = . AN5, Pin Number.QFN = . AN5, Pin.Type = I. AN5, Buffer.Type = Analog. AN5, Description = Analog input 5.. TX, Pin Number.PDIP/ SOIC = . TX, Pin Number.SSOP = . TX, Pin Number.QFN = . TX, Pin.Type = O. TX, Buffer.Type = -. TX, Description = EUSART asynchronous transmit.. CK, Pin Number.PDIP/ SOIC = . CK, Pin Number.SSOP = . CK, Pin Number.QFN = . CK, Pin.Type = I/O. CK, Buffer.Type = ST. CK, Description = EUSART synchronous clock (see related RX/DT).. INT1, Pin",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PDIP/ SOIC = . INT1, Pin Number.SSOP = . INT1, Pin Number.QFN = . INT1, Pin.Type = . INT1, Buffer.Type = . INT1, Description = 1.. RB2/P1B/INT2, Pin Number.PDIP/ SOIC = . RB2/P1B/INT2, Pin Number.SSOP = . RB2/P1B/INT2, Pin Number.QFN = . RB2/P1B/INT2, Pin.Type = I. RB2/P1B/INT2, Buffer.Type = ST. RB2/P1B/INT2, Description = External interrupt. , Pin Number.PDIP/ SOIC = 17. , Pin Number.SSOP = 19. , Pin Number.QFN = 23. , Pin.Type = . , Buffer.Type = . , Description = . RB2, Pin Number.PDIP/ SOIC = . RB2, Pin Number.SSOP = . RB2, Pin",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.QFN = . RB2, Pin.Type = I/O. RB2, Buffer.Type = TTL. RB2, Description = Digital I/O.. P1B, Pin Number.PDIP/ SOIC = . P1B, Pin Number.SSOP = . P1B, Pin Number.QFN = . P1B, Pin.Type = O. P1B, Buffer.Type = -. P1B, Description = Enhanced CCP1/PWM output.. INT2, Pin Number.PDIP/ SOIC = . INT2, Pin Number.SSOP = . INT2, Pin Number.QFN = . INT2, Pin.Type = I. INT2, Buffer.Type = ST. INT2, Description = External interrupt 2.. RB3/CCP1/P1A, Pin Number.PDIP/ SOIC = 18. RB3/CCP1/P1A, Pin Number.SSOP = 20. RB3/CCP1/P1A, Pin Number.QFN =",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\n24. RB3/CCP1/P1A, Pin.Type = . RB3/CCP1/P1A, Buffer.Type = . RB3/CCP1/P1A, Description = . RB3, Pin Number.PDIP/ SOIC = . RB3, Pin Number.SSOP = . RB3, Pin Number.QFN = . RB3, Pin.Type = I/O. RB3, Buffer.Type = TTL. RB3, Description = Digital I/O.. CCP1, Pin Number.PDIP/ SOIC = . CCP1, Pin Number.SSOP = . CCP1, Pin Number.QFN = . CCP1, Pin.Type = I/O. CCP1, Buffer.Type = ST. CCP1, Description = Capture 1 input/Compare 1 output/PWM 1 output.. P1A, Pin Number.PDIP/ SOIC = . P1A, Pin Number.SSOP = . P1A, Pin Number.QFN = .",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nP1A, Pin.Type = O. P1A, Buffer.Type = -. P1A, Description = Enhanced CCP1/PWM output.. RB4/AN6/RX/DT/KBI0, Pin Number.PDIP/ SOIC = 10. RB4/AN6/RX/DT/KBI0, Pin Number.SSOP = 11. RB4/AN6/RX/DT/KBI0, Pin Number.QFN = 12. RB4/AN6/RX/DT/KBI0, Pin.Type = . RB4/AN6/RX/DT/KBI0, Buffer.Type = . RB4/AN6/RX/DT/KBI0, Description = . RB4, Pin Number.PDIP/ SOIC = . RB4, Pin Number.SSOP = . RB4, Pin Number.QFN = . RB4, Pin.Type = I/O. RB4, Buffer.Type = TTL. RB4, Description = Digital I/O..",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nAN6, Pin Number.PDIP/ SOIC = . AN6, Pin Number.SSOP = . AN6, Pin Number.QFN = . AN6, Pin.Type = I. AN6, Buffer.Type = Analog. AN6, Description = Analog input 6.. RX, Pin Number.PDIP/ SOIC = . RX, Pin Number.SSOP = . RX, Pin Number.QFN = . RX, Pin.Type = I. RX, Buffer.Type = ST. RX, Description = EUSART asynchronous receive.. DT, Pin Number.PDIP/ SOIC = . DT, Pin Number.SSOP = . DT, Pin Number.QFN = . DT, Pin.Type = I/O. DT, Buffer.Type = ST. DT, Description = EUSART synchronous data (see related TX/CK).. KBI0, Pin Number.PDIP/ SOIC = . KBI0, Pin Number.SSOP = . KBI0, Pin",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.QFN = . KBI0, Pin.Type = I. KBI0, Buffer.Type = . KBI0, Description = Interrupt-on-change pin.. RB5/PGM/KBI1, Pin Number.PDIP/ SOIC = . RB5/PGM/KBI1, Pin Number.SSOP = . RB5/PGM/KBI1, Pin Number.QFN = . RB5/PGM/KBI1, Pin.Type = . RB5/PGM/KBI1, Buffer.Type = TTL. RB5/PGM/KBI1, Description = . , Pin Number.PDIP/ SOIC = 11. , Pin Number.SSOP = 12. , Pin Number.QFN = 13. , Pin.Type = . , Buffer.Type = . , Description = . RB5, Pin Number.PDIP/ SOIC = . RB5, Pin Number.SSOP = . RB5, Pin Number.QFN = . RB5, Pin.Type = I/O.",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB5, Buffer.Type = TTL. RB5, Description = Digital I/O.. PGM, Pin Number.PDIP/ SOIC = . PGM, Pin Number.SSOP = . PGM, Pin Number.QFN = . PGM, Pin.Type = I/O. PGM, Buffer.Type = ST. PGM, Description = Low-Voltage ICSP\u2122 Programming enable pin.. KBI1, Pin Number.PDIP/ SOIC = . KBI1, Pin Number.SSOP = . KBI1, Pin Number.QFN = . KBI1, Pin.Type = I. KBI1, Buffer.Type = TTL. KBI1, Description = Interrupt-on-change pin.. RB6/PGC/T1OSO/, Pin Number.PDIP/ SOIC = 12. RB6/PGC/T1OSO/, Pin Number.SSOP = 13. RB6/PGC/T1OSO/, Pin Number.QFN = 15.",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB6/PGC/T1OSO/, Pin.Type = . RB6/PGC/T1OSO/, Buffer.Type = . RB6/PGC/T1OSO/, Description = . T13CKI/P1C/KBI2, Pin Number.PDIP/ SOIC = . T13CKI/P1C/KBI2, Pin Number.SSOP = . T13CKI/P1C/KBI2, Pin Number.QFN = . T13CKI/P1C/KBI2, Pin.Type = I/O. T13CKI/P1C/KBI2, Buffer.Type = TTL. T13CKI/P1C/KBI2, Description = Digital I/O.. RB6 PGC, Pin Number.PDIP/ SOIC = . RB6 PGC, Pin Number.SSOP = . RB6 PGC, Pin Number.QFN = . RB6 PGC, Pin.Type = I/O. RB6 PGC, Buffer.Type = ST. RB6",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPGC, Description = In-Circuit Debugger and ICSP programming clock pin.. T1OSO, Pin Number.PDIP/ SOIC = . T1OSO, Pin Number.SSOP = . T1OSO, Pin Number.QFN = . T1OSO, Pin.Type = O. T1OSO, Buffer.Type = -. T1OSO, Description = Timer1 oscillator output.. T13CKI, Pin Number.PDIP/ SOIC = . T13CKI, Pin Number.SSOP = . T13CKI, Pin Number.QFN = . T13CKI, Pin.Type = I. T13CKI, Buffer.Type = ST. T13CKI, Description = Timer1/Timer3 external clock output.. , Pin Number.PDIP/ SOIC = . , Pin Number.SSOP = . , Pin Number.QFN = . , Pin.Type = . , Buffer.Type = -. , Description = Enhanced CCP1/PWM output.. P1C, Pin Number.PDIP/ SOIC = .",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nP1C, Pin Number.SSOP = . P1C, Pin Number.QFN = . P1C, Pin.Type = O. P1C, Buffer.Type = . P1C, Description = . KBI2, Pin Number.PDIP/ SOIC = . KBI2, Pin Number.SSOP = . KBI2, Pin Number.QFN = . KBI2, Pin.Type = I. KBI2, Buffer.Type = TTL. KBI2, Description = Interrupt-on-change pin.. RB7/PGD/T1OSI/, Pin Number.PDIP/ SOIC = 13. RB7/PGD/T1OSI/, Pin Number.SSOP = 14. RB7/PGD/T1OSI/, Pin Number.QFN = 16. RB7/PGD/T1OSI/, Pin.Type = . RB7/PGD/T1OSI/, Buffer.Type = . RB7/PGD/T1OSI/, Description = .",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nP1D/KBI3 RB7, Pin Number.PDIP/ SOIC = . P1D/KBI3 RB7, Pin Number.SSOP = . P1D/KBI3 RB7, Pin Number.QFN = . P1D/KBI3 RB7, Pin.Type = I/O. P1D/KBI3 RB7, Buffer.Type = TTL. P1D/KBI3 RB7, Description = Digital I/O.. PGD, Pin Number.PDIP/ SOIC = . PGD, Pin Number.SSOP = . PGD, Pin Number.QFN = . PGD, Pin.Type = I/O. PGD, Buffer.Type = ST. PGD, Description = In-Circuit Debugger and ICSP programming data pin.. T1OSI, Pin Number.PDIP/ SOIC = . T1OSI, Pin Number.SSOP = . T1OSI, Pin Number.QFN = . T1OSI, Pin.Type = I. T1OSI,",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = CMOS. T1OSI, Description = Timer1 oscillator input.. P1D, Pin Number.PDIP/ SOIC = . P1D, Pin Number.SSOP = . P1D, Pin Number.QFN = . P1D, Pin.Type = . P1D, Buffer.Type = . P1D, Description = Enhanced CCP1/PWM. KBI3, Pin Number.PDIP/ SOIC = . KBI3, Pin Number.SSOP = . KBI3, Pin Number.QFN = . KBI3, Pin.Type = O I. KBI3, Buffer.Type = - TTL. KBI3, Description = output. Interrupt-on-change pin.. VSS, Pin Number.PDIP/ SOIC = 5. VSS, Pin Number.SSOP = 5, 6. VSS, Pin Number.QFN = 3, 5. VSS, Pin.Type = P. VSS, Buffer.Type = -. VSS, Description = Ground reference",
    "TABLE 1-2: PIC18F1220/1320 PINOUT I/O DESCRIPTIONS (CONTINUED)\nfor logic and I/O pins.. VDD, Pin Number.PDIP/ SOIC = 14. VDD, Pin Number.SSOP = 15, 16. VDD, Pin Number.QFN = 17, 19. VDD, Pin.Type = P. VDD, Buffer.Type = -. VDD, Description = Positive supply for logic and I/O pins.. NC, Pin Number.PDIP/ SOIC = -. NC, Pin Number.SSOP = -. NC, Pin Number.QFN = 18. NC, Pin.Type = -. NC, Buffer.Type = -. NC, Description = No connect.\nLegend:\nTTL = TTL compatible input\nST\n= Schmitt Trigger input with CMOS levels\nO = Output\nOD = Open-drain (no P diode to VDD)\nCMOS\n= CMOS compatible input or output\nI\n= Input\nP\n= Power",
    "2.1 Oscillator Types\nThe  PIC18F1220  and  PIC18F1320  devices  can  be operated in ten different oscillator modes. The user can program  the  Configuration  bits,  FOSC3:FOSC0,  in Configuration Register 1H to select one of these ten modes:\n1. LP\nLow-Power Crystal\n2. XT\nCrystal/Resonator\n3. HS\nHigh-Speed Crystal/Resonator\n4. HSPLL\nHigh-Speed Crystal/Resonator with PLL enabled\n5. RC\nExternal  Resistor/Capacitor  with FOSC/4 output on RA6\n6. RCIO\nExternal Resistor/Capacitor with I/O on RA6\n7. INTIO1\nInternal Oscillator with FOSC/4 output on RA6 and I/O on RA7\n8. INTIO2\nInternal Oscillator with I/O on RA6 and RA7\n9. EC\nExternal Clock with FOSC/4 output\n10. ECIO\nExternal Clock with I/O on RA6",
    "2.2 Crystal Oscillator/Ceramic Resonators\nIn XT, LP, HS or HSPLL Oscillator modes, a crystal or ceramic  resonator  is  connected  to  the  OSC1  and OSC2 pins to establish  oscillation.  Figure 2-1  shows the pin connections.\nThe oscillator design requires the use of a parallel cut crystal.\nNote:, 1 = Use of a series cut crystal may give a frequency out of the crystal manufacturer's specifications.",
    "FIGURE 2-1:\nCRYSTAL/CERAMIC RESONATOR OPERATION (XT, LP, HS OR HSPLL CONFIGURATION)\nNote 1: See Table 2-1 and Table 2-2 for initial values of C1 and C2.\n2: A series resistor (RS) may be required for AT strip cut crystals.\n3: RF varies with the oscillator mode chosen.",
    "TABLE 2-1: CAPACITOR SELECTION FOR CERAMIC RESONATORS\nXT, Typical Capacitor Values Used:.Freq. = 455 kHz. XT, Typical Capacitor Values Used:.OSC1 = 56 pF. XT, Typical Capacitor Values Used:.OSC2 = 56 pF. , Typical Capacitor Values Used:.Freq. = 2.0 MHz. , Typical Capacitor Values Used:.OSC1 = 47 pF. , Typical Capacitor Values Used:.OSC2 = 47 pF. , Typical Capacitor Values Used:.Freq. = 4.0 MHz. , Typical Capacitor Values Used:.OSC1 = 33 pF. , Typical Capacitor Values Used:.OSC2 = 33 pF. HS, Typical Capacitor Values Used:.Freq. = 8.0 MHz. HS, Typical Capacitor Values Used:.OSC1 = 27 pF. HS, Typical Capacitor Values Used:.OSC2 = 27 pF. , Typical Capacitor Values Used:.Freq. = 16.0 MHz. , Typical",
    "TABLE 2-1: CAPACITOR SELECTION FOR CERAMIC RESONATORS\nCapacitor Values Used:.OSC1 = 22 pF. , Typical Capacitor Values Used:.OSC2 = 22 pF\nCapacitor values are for design guidance only.\nThese  capacitors  were  tested  with  the  resonators listed below for basic start-up and operation. These values are not optimized .\nDifferent capacitor values may be required to produce acceptable oscillator operation. The user should test the performance of the oscillator over the expected VDD and temperature range for the application.\nSee  the  notes  following Table 2-2 for additional information.\n455 kHz, Resonators Used: = 4.0 MHz. 2.0 MHz, Resonators Used: = 8.0 MHz. 16.0 MHz, Resonators Used: = 16.0 MHz",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nLP, Crystal Freq..Crystal Freq. = 32 kHz. LP, Typical Capacitor Values Tested:.C1 = 33 pF. LP, Typical Capacitor Values Tested:.C2 = 33 pF. LP, Crystal Freq..Crystal Freq. = 200 kHz. LP, Typical Capacitor Values Tested:.C1 = 15 pF. LP, Typical Capacitor Values Tested:.C2 = 15 pF. XT, Crystal Freq..Crystal Freq. = 1 MHz. XT, Typical Capacitor Values Tested:.C1 = 33 pF. XT, Typical Capacitor Values Tested:.C2 = 33 pF. XT, Crystal Freq..Crystal Freq. = 4 MHz. XT, Typical Capacitor Values Tested:.C1 = 27 pF. XT, Typical Capacitor Values Tested:.C2 = 27 pF. HS, Crystal Freq..Crystal Freq. = 4 MHz. HS, Typical Capacitor Values Tested:.C1 = 27 pF. HS, Typical Capacitor",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nValues Tested:.C2 = 27 pF. HS, Crystal Freq..Crystal Freq. = 8 MHz. HS, Typical Capacitor Values Tested:.C1 = 22 pF. HS, Typical Capacitor Values Tested:.C2 = 22 pF. HS, Crystal Freq..Crystal Freq. = 20 MHz. HS, Typical Capacitor Values Tested:.C1 = 15 pF. HS, Typical Capacitor Values Tested:.C2 = 15 pF\nCapacitor values are for design guidance only.\nThese capacitors were tested with the crystals listed below for basic start-up and operation. These values are not optimized.\nDifferent capacitor values may be required to produce acceptable oscillator operation. The user should test the performance of the oscillator over the expected VDD and temperature range for the application.\nSee  the  notes  following  this  table  for  additional information.\n32 kHz, Crystals Used: = 4 MHz. 200 kHz, Crystals Used: = 8 MHz. 1 MHz, Crystals Used: = 20 MHz",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nNote 1: Higher capacitance increases the stability of oscillator, but also increases the startup time.\n2: When operating below 3V VDD, or when using certain ceramic resonators at any voltage, it may be necessary to use the HS mode or switch to a crystal oscillator.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer  for appropriate values of external components.\n4: RS may be required to avoid overdriving crystals with low drive level specification.\n5: Always verify oscillator performance over the  VDD  and  temperature  range  that  is expected for the application.\nAn external clock source may also be connected to the OSC1 pin in the HS mode, as shown in Figure 2-2.",
    "2.3 HSPLL\nA Phase Locked Loop (PLL) circuit is provided as an option  for  users  who  wish  to  use  a  lower  frequency crystal oscillator circuit, or to clock the device up to its highest rated frequency from a crystal oscillator. This may be useful for customers who are concerned with EMI due to high-frequency crystals.\nThe HSPLL mode makes use of the HS mode oscillator for frequencies up to 10 MHz. A PLL then multiplies the oscillator output frequency by 4 to produce an internal clock frequency up to 40 MHz.\nThe PLL is enabled only when the oscillator Configuration bits are programmed for HSPLL mode. If programmed  for  any  other  mode,  the  PLL  is  not enabled.",
    "2.4 External Clock Input\nThe EC and ECIO Oscillator modes require an external clock source to be connected to the OSC1 pin. There is no  oscillator  start-up  time  required  after  a  Power-on Reset, or after an exit from Sleep mode.\nIn  the  EC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes, or to synchronize other logic. Figure 2-4 shows the pin connections for the EC Oscillator mode.",
    "FIGURE 2-4: EXTERNAL CLOCK INPUT OPERATION (EC CONFIGURATION)\nThe ECIO Oscillator mode functions like the EC mode, except that the OSC2 pin becomes an additional general  purpose  I/O  pin.  The  I/O  pin  becomes  bit  6  of PORTA (RA6). Figure 2-5 shows the pin connections for the ECIO Oscillator mode.",
    "2.5 RC Oscillator\nFor timing insensitive applications, the 'RC'  and 'RCIO'  device  options  offer  additional  cost  savings. The RC oscillator frequency is a function of the supply voltage, the resistor (REXT) and capacitor (CEXT) values and the operating temperature. In addition to this, the oscillator frequency will vary from unit to unit due to normal manufacturing variation. Furthermore, the difference in  lead  frame  capacitance  between  package types  will  also  affect  the  oscillation  frequency,  especially for low CEXT values. The user also needs to take into  account  variation,  due  to  tolerance  of  external R and C components used. Figure 2-6 shows how the R/C combination is connected.\nIn  the  RC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes, or to synchronize other logic.",
    "FIGURE 2-6: RC OSCILLATOR MODE\nThe RCIO Oscillator mode (Figure 2-7) functions like the RC mode, except that the OSC2 pin becomes an additional general purpose I/O pin. The I/O pin becomes bit 6 of PORTA (RA6).",
    "2.6 Internal Oscillator Block\nThe  PIC18F1220/1320  devices  include  an  internal oscillator  block,  which  generates  two  different  clock signals;  either  can  be  used  as  the  system's  clock source.  This  can  eliminate  the  need  for  external oscillator circuits on the OSC1 and/or OSC2 pins.\nThe main output (INTOSC) is an 8 MHz clock source, which can be used to directly drive the system clock. It also drives a postscaler, which can provide a range of clock frequencies from 125 kHz to 4 MHz. The INTOSC  output  is  enabled  when  a  system  clock frequency from 125 kHz to 8 MHz is selected.\nThe  other  clock  source  is  the  internal  RC  oscillator (INTRC), which provides a 31 kHz output. The INTRC oscillator is enabled by selecting the internal oscillator block as the system clock source, or when any of the following are enabled:\n\u00b7 Power-up Timer\n\u00b7 Fail-Safe Clock Monitor\n\u00b7 Watchdog Timer\n\u00b7 Two-Speed Start-up\nThese  features  are  discussed  in  greater  detail  in Section 19.0 'Special Features of the CPU' .",
    "2.6 Internal Oscillator Block\nThe  clock  source  frequency  (INTOSC  direct,  INTRC direct or INTOSC postscaler) is selected by configuring the IRCF bits of the OSCCON register (Register 2-2).",
    "2.6.1 INTIO MODES\nUsing  the  internal  oscillator  as  the  clock  source  can eliminate the need for up to two external oscillator pins, which  can  then  be  used  for  digital  I/O.  Two  distinct configurations are available:\n\u00b7 In INTIO1 mode, the OSC2 pin outputs FOSC/4, while OSC1 functions as RA7 for digital input and output.\n\u00b7 In INTIO2 mode, OSC1 functions as RA7 and OSC2 functions as RA6, both for digital input and output.",
    "2.6.2 INTRC OUTPUT FREQUENCY\nThe internal oscillator block is calibrated at the factory to  produce  an  INTOSC output frequency of 8.0 MHz (see  Table 22-6).  This  changes  the  frequency  of  the INTRC source from its nominal 31.25 kHz. Peripherals and features that depend on the INTRC source will be affected by this shift in frequency.\nOnce set during factory calibration, the INTRC frequency will remain within \u00b12% as temperature and VDD  change  across their full specified operating ranges.",
    "2.6.3 OSCTUNE REGISTER\nThe internal oscillator's output has been calibrated at the factory, but can be adjusted in the user's application. This is done by writing to the OSCTUNE register (Register 2-1). The tuning sensitivity is constant throughout the tuning range.\nWhen the OSCTUNE register is modified, the INTOSC and INTRC frequencies will begin shifting to the new frequency. The  INTRC  clock  will reach the new frequency within 8 clock cycles (approximately 8 * 32 \uf06d s = 256 \uf06d s).  The  INTOSC  clock  will  stabilize within 1 ms. Code execution continues during this shift. There  is  no  indication  that  the  shift  has  occurred. Operation of features that depend on the INTRC clock source frequency, such as the WDT, Fail-Safe Clock Monitor and  peripherals,  will  also  be  affected  by  the change in frequency.",
    "OSCTUNE: OSCILLATOR TUNING REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0/0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = -. -, 2 = . -, 3 = . -, 4 = TUN<5:0>. -, 5 = . -, 6 = . -, 7 = . bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "OSCTUNE: OSCILLATOR TUNING REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' -n/n = Value at POR and BOR/Value at all other Resets = \nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-0\nTUN<5:0>: Frequency Tuning bits\n100000 =  Minimum frequency\n\u2022\n\u2022\n\u2022\n111111 = 000000 =  Oscillator module is running at the factory-calibrated frequency 000001 =\n\u2022\n\u2022\n\u2022\n011110 =\n011111 =  Maximum frequency",
    "2.7 Clock Sources and Oscillator Switching\nLike  previous  PIC18  devices,  the  PIC18F1220/1320 devices include a feature that allows the system clock source to be switched from the main oscillator to an alternate  low-frequency  clock  source.  PIC18F1220/ 1320 devices offer two alternate clock sources. When enabled, these give additional options for switching to the various power managed operating modes.\nEssentially,  there  are  three  clock  sources  for  these devices:\n\u00b7 Primary oscillators\n\u00b7 Secondary oscillators\n\u00b7 Internal oscillator block\nThe primary oscillators include the External Crystal and  Resonator  modes,  the  External  RC  modes,  the External Clock modes and the internal oscillator block. The particular mode is defined on POR by the contents of  Configuration  Register  1H.  The  details  of  these modes are covered earlier in this chapter.\nThe secondary oscillators are those external sources not  connected  to  the  OSC1  or  OSC2  pins.  These sources  may  continue  to  operate  even  after the controller is placed in a power managed mode.",
    "2.7 Clock Sources and Oscillator Switching\nPIC18F1220/1320 devices offer only the Timer1 oscillator as a secondary oscillator. This oscillator, in all power  managed  modes,  is  often  the  time  base  for functions such as a real-time clock.\nMost often, a 32.768 kHz watch crystal is connected between the RB6/T1OSO and RB7/T1OSI pins. Like the LP mode oscillator circuit, loading capacitors are also connected from each pin to ground. These pins are also used during ICSP operations.\nThe Timer1 oscillator is discussed in greater detail in Section 12.2 'Timer1 Oscillator' .\nIn addition to being a primary clock source, the internal oscillator  block is  available  as  a  power  managed mode clock source. The INTRC source is also used as the clock source for several special features, such as the WDT and Fail-Safe Clock Monitor.",
    "2.7 Clock Sources and Oscillator Switching\nThe clock sources for the PIC18F1220/1320 devices are  shown  in  Figure 2-8.  See Section 12.0  'Timer1 Module' for further details of the Timer1 oscillator. See Section 19.1 'Configuration Bits' for  Configuration register details.",
    "2.7.1 OSCILLATOR CONTROL REGISTER\nThe OSCCON register (Register 2-2) controls several aspects of the system  clock's  operation,  both  in  fullpower operation and in power managed modes.\nThe System Clock Select bits, SCS1:SCS0, select the clock source that is used when the device is operating in power managed modes. The available clock sources are the primary clock (defined in Configuration Register 1H), the secondary clock (Timer1 oscillator) and the internal oscillator block. The clock selection has no effect until a SLEEP instruction is executed and the device enters a power managed mode of operation. The SCS bits are cleared on all forms of Reset.",
    "2.7.1 OSCILLATOR CONTROL REGISTER\nThe Internal Oscillator Select bits, IRCF2:IRCF0, select the frequency output of the internal oscillator block that is used to drive the system clock. The choices are the INTRC source, the INTOSC source (8 MHz), or one of the  six  frequencies  derived  from  the  INTOSC  postscaler (125 kHz to 4 MHz). If the internal oscillator block is supplying the system clock, changing the states of these bits will have an immediate change on the internal oscillator's output.\nwhen the internal oscillator block has stabilized and is providing  the  system  clock  in  RC  Clock  modes  or during Two-Speed Start-ups. The T1RUN bit (T1CON<6>) indicates  when  the  Timer1  oscillator  is providing the system clock in Secondary Clock modes. In power managed modes, only one of these three bits will be set at any time. If none of these bits are set, the INTRC is providing  the  system  clock,  or  the  internal oscillator block has just started and is not yet stable.",
    "2.7.1 OSCILLATOR CONTROL REGISTER\nThe IDLEN bit controls the selective shutdown of the controller's CPU in power managed modes. The uses of these bits are discussed in more detail in Section 3.0 'Power Managed Modes' .\n- Note 1: The Timer1 oscillator must be enabled to select  the  secondary  clock  source.  The Timer1 oscillator is enabled by setting the T1OSCEN bit in the Timer1 Control register (T1CON<3>). If the Timer1 oscillator is not enabled, then any attempt to select a secondary clock source when executing  a SLEEP instruction  will  be ignored.\nThe OSTS, IOFS and T1RUN bits indicate which clock source  is  currently  providing  the  system  clock.  The OSTS indicates that the Oscillator Start-up Timer has timed out and the primary clock is providing the system clock in Primary Clock modes. The IOFS bit indicates\n- 2: It is recommended that the Timer1 oscillator be operating and stable before executing  the SLEEP instruction  or  a  very long  delay  may  occur  while  the  Timer1 oscillator starts.",
    "REGISTER 2-2: OSCCON: OSCILLATOR CONTROL REGISTER\nIDLEN, R/W-0/0 = IRCF<2:0>. IDLEN, R/W-1/1 = . IDLEN, R/W-1/1 = . IDLEN, R (1) = OSTS. IDLEN, R-0/0 = IOFS. IDLEN, R/W-0/0 = SCS<1:0>. IDLEN, R/W-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-1/1 = . bit 7, R/W-1/1 = . bit 7, R (1) = . bit 7, R-0/0 = . bit 7, R/W-0/0 = . bit 7, R/W-0/0 = bit 0",
    "REGISTER 2-2: OSCCON: OSCILLATOR CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = ",
    "bit 7 IDLEN: Idle Enable bits\n1 = Idle mode enabled; CPU core is not clocked in power managed modes\n0 = Run mode enabled; CPU core is clocked in Run modes, but not Sleep mode\nbit 6-4\nIRCF<2:0>: Internal Oscillator Frequency Select bits\n111 = 8 MHz (8 MHz source drives clock directly)\n110 = 4 MHz\n101 = 2 MHz\n100 = 1 MHz\n011 = 500 kHz\n010 = 250 kHz\n001 = 125 kHz\n000 = 31 kHz (INTRC source drives clock directly)",
    "bit 3\nOSTS: Oscillator Start-up Time-out Status bit\n1 = Oscillator Start-up Timer time-out has expired; primary oscillator is running\n0 = Oscillator Start-up Timer time-out is running; primary oscillator is not ready\nbit 2 IOFS: INTOSC Frequency Stable bit\n1 = INTOSC frequency is stable\n0 = INTOSC frequency is not stable",
    "bit 1-0\nSCS<1:0>: System Clock Select bits (1)\n1x = Internal oscillator block (RC modes)\n01 =Timer1 oscillator (Secondary modes)\n00 = Primary oscillator (Sleep and PRI_IDLE modes)\nNote 1: Depends on state of the IESO bit in Configuration Register 1H.",
    "2.7.2 OSCILLATOR TRANSITIONS\nThe  PIC18F1220/1320  devices  contain  circuitry  to prevent  clocking  'glitches'  when  switching  between clock  sources.  A  short  pause  in  the  system  clock occurs during the clock switch. The length of this pause is  between  eight  and  nine  clock  periods  of  the  new clock source. This ensures that the new clock source is stable and that its pulse width will not be less than the shortest pulse width of the two clock sources.\nClock  transitions  are  discussed  in  greater  detail  in Section 3.1.2 'Entering Power Managed Modes' .",
    "2.8 Effects of Power Managed Modes on the Various Clock Sources\nWhen  the  device  executes  a SLEEP instruction,  the system  is  switched  to  one  of  the  power  managed modes,  depending  on  the  state  of  the  IDLEN  and SCS1:SCS0  bits of the OSCCON  register. See Section 3.0 'Power Managed Modes' for details.\nWhen PRI_IDLE mode is selected, the designated primary  oscillator  continues  to  run  without  interruption. For  all  other  power  managed  modes,  the  oscillator using the OSC1 pin is disabled. The OSC1 pin (and OSC2 pin, if used by the oscillator) will stop oscillating.\nIn  Secondary  Clock  modes  (SEC_RUN  and  SEC_I-DLE), the Timer1 oscillator is operating and providing the system clock. The Timer1 oscillator may also run in all power managed modes if required to clock Timer1 or Timer3.\nIf  the  Sleep  mode  is  selected,  all  clock  sources  are stopped.  Since  all  the  transistor  switching  currents have been stopped, Sleep mode achieves the lowest current consumption  of  the device (only leakage currents).",
    "2.8 Effects of Power Managed Modes on the Various Clock Sources\nEnabling any on-chip feature that will  operate during Sleep will increase the current consumed during Sleep. The INTRC is required to support WDT operation. The Timer1 oscillator may be operating to support a realtime clock. Other features may be operating that do not require  a  system  clock  source  (i.e.,  INTn  pins,  A/D conversions and others).",
    "2.9 Power-up Delays\nPower-up delays are controlled by two timers, so that no external Reset circuitry is required for most applications.  The  delays  ensure  that  the  device  is  kept  in Reset until the device power supply is stable under normal circumstances and the primary clock is operating and  stable.  For  additional  information  on  power-up delays, see Sections 4.1 through 4.5.\nThe first timer is the Power-up Timer (PWRT), which provides  a  fixed  delay  on  power-up  (parameter  33, Table 22-8)  if  enabled  in  Configuration  Register  2L. The  second  timer  is  the  Oscillator  Start-up  Timer (OST),  intended  to  keep  the  chip  in  Reset  until  the crystal oscillator is stable (LP , XT and HS modes). The OST  does  this  by  counting  1024  oscillator  cycles before allowing the oscillator to clock the device.",
    "2.9 Power-up Delays\nIn Internal Oscillator modes (RC_RUN and RC_IDLE), the internal oscillator block provides the system clock source.  The  INTRC  output  can  be  used  directly  to provide  the  system  clock  and  may  be  enabled  to support  various  special  features,  regardless  of  the power managed mode (see Section 19.2 'Watchdog Timer (WDT)' through Section 19.4 'Fail-Safe Clock Monitor' ). The INTOSC output at 8 MHz may be used directly to clock the system, or may be divided down first. The INTOSC output is disabled if the system clock is provided directly from the INTRC output.\nWhen  the  HSPLL  Oscillator  mode  is  selected,  the device is kept in Reset for an additional 2 ms following the HS mode OST delay, so the PLL can lock to the incoming clock frequency.\nThere is a delay of 5 to 10 \uf06d s following POR while the controller becomes ready to execute instructions. This delay  runs  concurrently  with  any  other  delays.  This may be the only delay that occurs when any of the EC, RC  or  INTIO  modes  are  used  as  the  primary  clock source.",
    "2.9 Power-up Delays\nTABLE 2-3: OSC1 AND OSC2 PIN STATES IN SLEEP MODE\n\nRC, INTIO1, OSC1 Pin = Floating, external resistor should pull high. RC, INTIO1, OSC2 Pin = At logic low (clock/4 output). RCIO, INTIO2, OSC1 Pin = Floating, external resistor should pull high. RCIO, INTIO2, OSC2 Pin = Configured as PORTA, bit 6. ECIO, OSC1 Pin = Floating, pulled by external clock. ECIO, OSC2 Pin = Configured as PORTA, bit 6. EC, OSC1 Pin = Floating, pulled by external clock. EC, OSC2 Pin = At logic low (clock/4 output). LP, XT and HS, OSC1 Pin = Feedback inverter disabled at quiescent voltage level. LP, XT and HS, OSC2 Pin = Feedback inverter disabled at quiescent voltage level\nNote: See Table 4-1 in Section 4.0 'Reset' for time-outs due to Sleep and MCLR Reset.",
    "3.0 POWER MANAGED MODES\nThe PIC18F1220/1320 devices offer a total of six operating  modes  for  more  efficient  power  management (see Table 3-1). These provide a variety of options for selective  power  conservation  in  applications  where resources may be limited (i.e., battery powered devices).\nThere are three categories of power managed modes:\n\u00b7 Sleep mode\n\u00b7 Idle modes\n\u00b7 Run modes\nThese categories define which portions of the device are clocked and sometimes, what speed. The Run and Idle modes may use any of the three available clock sources (primary, secondary or INTOSC multiplexer); the Sleep mode does not use a clock source.",
    "3.0 POWER MANAGED MODES\nThe  clock  switching  feature  offered  in  other  PIC18 devices (i.e., using the Timer1 oscillator in place of the primary oscillator) and the Sleep mode offered by all PIC \u00ae  devices (where all system clocks are stopped) are both offered in the PIC18F1220/1320 devices (SEC_RUN and Sleep modes, respectively). However, additional  power  managed  modes  are  available  that allow  the  user  greater  flexibility  in  determining  what portions of the device are operating. The power managed modes are event driven;  that is,  some specific event  must  occur  for  the  device  to  enter  or  (more particularly) exit these operating modes.\nFor  PIC18F1220/1320  devices,  the  power  managed modes  are  invoked  by  using  the  existing SLEEP instruction. All modes exit to PRI_RUN mode when triggered  by  an  interrupt,  a  Reset  or  a  WDT  time-out (PRI_RUN  mode  is  the  normal  full-power  execution mode; the CPU and peripherals are clocked by the primary  oscillator  source).  In  addition,  power  managed Run  modes  may  also  exit  to  Sleep  mode,  or  their corresponding Idle mode.",
    "3.1 Selecting Power Managed Modes\nSelecting a power managed mode requires deciding if the CPU is to be clocked or not and selecting a clock source. The IDLEN bit controls CPU clocking, while the SCS1:SCS0 bits select a clock source. The individual modes, bit settings, clock sources and affected modules are summarized in Table 3-1.",
    "3.1.1 CLOCK SOURCES\nThe clock source is selected by setting the SCS bits of the OSCCON  register (Register 2-2). Three clock sources  are  available  for  use  in  power  managed  Idle modes: the primary clock (as configured in Configuration Register  1H),  the  secondary  clock  (Timer1  oscillator) and  the  internal  oscillator  block.  The  secondary  and internal  oscillator  block  sources  are  available  for  the power managed modes (PRI_RUN mode is the normal full-power execution mode; the CPU and peripherals are clocked by the primary oscillator source).\n\nTABLE 3-1: POWER MANAGED MODES",
    "3.1.1 CLOCK SOURCES\nSleep, OSCCON Bits.IDLEN <7> = 0. Sleep, OSCCON Bits.SCS1:SCS0 <1:0> = 00. Sleep, Module Clocking.CPU = Off. Sleep, Module Clocking.Peripherals = Off. Sleep, Available Clock and Oscillator Source.Available Clock and Oscillator Source = None - All clocks are disabled. PRI_RUN, OSCCON Bits.IDLEN <7> = 0. PRI_RUN, OSCCON Bits.SCS1:SCS0 <1:0> = 00. PRI_RUN, Module Clocking.CPU = Clocked. PRI_RUN, Module Clocking.Peripherals = Clocked. PRI_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Primary - LP, XT, HS, HSPLL, RC, EC, INTRC (1) This is the normal full-power execution mode.. SEC_RUN, OSCCON Bits.IDLEN <7> = 0. SEC_RUN, OSCCON Bits.SCS1:SCS0 <1:0> = 01.",
    "3.1.1 CLOCK SOURCES\nSEC_RUN, Module Clocking.CPU = Clocked. SEC_RUN, Module Clocking.Peripherals = Clocked. SEC_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Secondary - Timer1 Oscillator. RC_RUN, OSCCON Bits.IDLEN <7> = 0. RC_RUN, OSCCON Bits.SCS1:SCS0 <1:0> = 1x. RC_RUN, Module Clocking.CPU = Clocked. RC_RUN, Module Clocking.Peripherals = Clocked. RC_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Internal Oscillator Block (1). PRI_IDLE, OSCCON Bits.IDLEN <7> = 1. PRI_IDLE, OSCCON Bits.SCS1:SCS0 <1:0> = 00. PRI_IDLE, Module Clocking.CPU = Off. PRI_IDLE, Module Clocking.Peripherals = Clocked. PRI_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Primary",
    "3.1.1 CLOCK SOURCES\n- LP, XT, HS, HSPLL, RC, EC. SEC_IDLE, OSCCON Bits.IDLEN <7> = 1. SEC_IDLE, OSCCON Bits.SCS1:SCS0 <1:0> = 01. SEC_IDLE, Module Clocking.CPU = Off. SEC_IDLE, Module Clocking.Peripherals = Clocked. SEC_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Secondary - Timer1 Oscillator. RC_IDLE, OSCCON Bits.IDLEN <7> = 1. RC_IDLE, OSCCON Bits.SCS1:SCS0 <1:0> = 1x. RC_IDLE, Module Clocking.CPU = Off. RC_IDLE, Module Clocking.Peripherals = Clocked. RC_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Internal Oscillator Block (1)\nNote 1: Includes INTOSC and INTOSC postscaler, as well as the INTRC source.",
    "3.1.2 ENTERING POWER MANAGED MODES\nIn  general,  entry,  exit  and  switching  between  power managed clock sources requires clock source switching. In each case, the sequence of events is the same.\nAny change in the power managed mode begins with loading the OSCCON register and executing a SLEEP instruction.  The  SCS1:SCS0  bits  select  one  of  three power managed clock sources; the primary clock (as defined in Configuration Register 1H), the secondary clock (the Timer1 oscillator) and the internal oscillator block (used in RC modes). Modifying the SCS bits will have no effect until a SLEEP instruction  is  executed. Entry to the power managed mode is triggered by the execution of a SLEEP instruction.",
    "3.1.2 ENTERING POWER MANAGED MODES\nFigure 3-5  shows  how  the  system  is  clocked  while switching from the primary clock to the Timer1 oscillator. When the SLEEP instruction is executed, clocks to the  device  are  stopped  at  the  beginning  of  the  next instruction cycle. Eight clock cycles from the new clock source are counted to synchronize with the new clock source.  After  eight  clock  pulses  from  the  new  clock source are counted, clocks from the new clock source resume clocking the system. The actual length of the pause is between eight and nine clock periods from the new  clock  source.  This  ensures  that  the  new  clock source is stable and that its pulse width will not be less than the shortest pulse width of the two clock sources.",
    "3.1.2 ENTERING POWER MANAGED MODES\nThree bits indicate the current clock source: OSTS and IOFS  in  the  OSCCON  register  and  T1RUN  in  the T1CON register. Only one of these bits will be set while in a power managed mode. When the OSTS bit is set, the primary clock is providing the system clock. When the IOFS bit is set, the INTOSC output is providing a stable 8 MHz clock source and is providing the system clock. When the T1RUN bit is set, the Timer1 oscillator is providing the system clock. If none of these bits are set, then either the INTRC clock source is clocking the system, or the INTOSC source is not yet stable.\nIf the internal oscillator block is configured as the primary clock source in Configuration Register 1H, then both  the  OSTS  and  IOFS  bits  may  be  set  when  in PRI_RUN or PRI_IDLE modes. This indicates that the primary clock (INTOSC output) is generating a stable 8 MHz output. Entering an RC power managed mode (same frequency) would clear the OSTS bit.",
    "3.1.2 ENTERING POWER MANAGED MODES\nNote 1: Caution should be used when modifying a single IRCF bit. If VDD is less than 3V, it is possible to select a higher clock speed than is supported by the low VDD. Improper device  operation may result if the VDD/FOSC specifications are violated.\n2: Executing a SLEEP instruction does not necessarily  place  the  device  into  Sleep mode; executing a SLEEP instruction  is simply a trigger to place the controller into a power managed mode selected by the OSCCON register, one of which is Sleep mode.",
    "3.1.3 MULTIPLE SLEEP COMMANDS\nThe  power  managed  mode  that  is  invoked  with  the SLEEP instruction is determined by the settings of the IDLEN and SCS bits at the time the instruction is executed.  If  another SLEEP instruction  is  executed,  the device will enter the power managed mode specified by these same bits at that time. If the bits have changed, the  device  will  enter  the  new  power  managed  mode specified by the new bit settings.",
    "3.1.4 COMPARISONS BETWEEN RUN AND IDLE MODES\nClock source selection for the Run modes is identical to the corresponding Idle modes. When a SLEEP instruction is executed, the SCS bits in the OSCCON register are  used  to  switch  to  a  different  clock  source.  As  a result, if there is a change of clock source at the time a SLEEP instruction is executed, a clock switch will occur.\nIn Idle modes, the CPU is not clocked and is not running. In Run modes, the CPU is clocked and executing code.  This  difference  modifies  the  operation  of  the WDT when it times out. In Idle modes, a WDT time-out results in a wake from power managed modes. In Run modes, a WDT time-out results in a WDT Reset (see Table 3-2).\nDuring a wake-up from an Idle mode, the CPU starts executing  code  by  entering  the  corresponding  Run mode until the primary clock becomes ready. When the primary clock becomes ready, the clock source is automatically switched to the primary clock. The IDLEN and SCS bits are unchanged during and after the wake-up.",
    "3.1.4 COMPARISONS BETWEEN RUN AND IDLE MODES\nFigure 3-2 shows how the system is clocked during the clock source switch. The example assumes the device was in SEC_IDLE or SEC_RUN mode when a wake is triggered (the primary clock was configured in HSPLL mode).",
    "COMPARISON BETWEEN POWER MANAGED MODES\nSleep, CPU is Clocked by ... = Not clocked (not running). Sleep, WDTTime-out causes a ... = Wake-up. Sleep, Peripherals are Clocked by ... = Not clocked. Sleep, Clock during Wake-up (while primary becomes ready) = None or INTOSC multiplexer if Two-Speed Start-up or Fail-Safe Clock Monitor are enabled. Any Idle mode, CPU is Clocked by ... = Not clocked (not running). Any Idle mode, WDTTime-out causes a ... = Wake-up. Any Idle mode, Peripherals are Clocked by ... = Primary, Secondary or INTOSC multiplexer. Any Idle mode, Clock during Wake-up (while primary becomes ready) = Unchanged from Idle mode (CPU operates as in corresponding Run mode). Any Run mode, CPU is Clocked by ... = Primary or secondary clocks or INTOSC multiplexer. Any Run mode, WDTTime-out causes a ... = Reset. Any Run mode, Peripherals are Clocked by ... = Primary or secondary clocks or INTOSC multiplexer. Any Run",
    "COMPARISON BETWEEN POWER MANAGED MODES\nmode, Clock during Wake-up (while primary becomes ready) = Unchanged from Run mode",
    "3.2 Sleep Mode\nThe power managed Sleep mode in the PIC18F1220/ 1320 devices is identical to that offered in all other PIC microcontrollers.  It  is  entered  by  clearing  the  IDLEN and  SCS1:SCS0  bits  (this  is  the  Reset  state)  and executing the SLEEP instruction. This shuts down the primary  oscillator  and  the  OSTS  bit  is  cleared  (see Figure 3-1).\nIf the Idle Enable bit, IDLEN (OSCCON<7>), is set to a ' 1 ' when a SLEEP instruction is executed, the peripherals  will  be  clocked  from  the  clock  source selected using the SCS1:SCS0 bits; however, the CPU will  not  be  clocked.  Since  the  CPU  is  not  executing instructions, the only exits from any of the Idle modes are by interrupt, WDT time-out or a Reset.",
    "3.2 Sleep Mode\nWhen a wake event occurs in Sleep mode (by interrupt, Reset or WDT time-out), the system will not be clocked until  the  primary  clock  source  becomes  ready  (see Figure 3-2),  or  it  will  be  clocked  from  the  internal oscillator block if either the Two-Speed Start-up or the Fail-Safe Clock Monitor are enabled (see Section 19.0 'Special Features of the CPU' ).  In  either case, the OSTS bit is set when the primary clock is providing the system  clocks.  The  IDLEN  and  SCS  bits  are  not affected by the wake-up.",
    "3.3 Idle Modes\nThe IDLEN bit allows the microcontroller's CPU to be selectively shut down while the peripherals continue to operate. Clearing IDLEN allows the CPU to be clocked. Setting IDLEN disables clocks to the CPU, effectively stopping  program  execution  (see  Register 2-2).  The peripherals  continue  to  be  clocked  regardless  of  the setting of the IDLEN bit.\nThere is one exception to how the IDLEN bit functions. When  all  the  low-power  OSCCON  bits  are  cleared (IDLEN:SCS1:SCS0 = 000 ),  the  device  enters  Sleep mode upon the execution of the SLEEP instruction. This is both the Reset state of the OSCCON register and the setting that selects Sleep mode. This maintains compatibility with other PIC devices that do not offer power managed modes.",
    "3.3 Idle Modes\nWhen a wake event occurs, CPU execution is delayed approximately 10 \uf06d s while it becomes ready to execute code.  When  the  CPU  begins  executing  code,  it  is clocked by the same clock source as was selected in the  power  managed  mode  (i.e.,  when  waking  from RC_IDLE mode, the internal oscillator block will clock the CPU and peripherals until the primary clock source becomes ready - this is essentially RC_RUN mode). This continues until the primary clock source becomes ready.  When  the  primary  clock  becomes  ready,  the OSTS  bit  is  set  and  the  system  clock  source  is switched  to  the  primary  clock  (see  Figure 3-4).  The IDLEN and SCS bits are not affected by the wake-up.\nWhile  in  any  Idle  mode  or  the  Sleep  mode,  a  WDT time-out  will  result  in  a  WDT  wake-up  to  full-power operation.",
    "FIGURE 3-1: TIMING TRANSITION FOR ENTRY TO SLEEP MODE\nQ4 Q3 Q2 Q1 Q1, 1 = Q4 Q3 Q2 Q1 Q1. OSC1, 1 = . CPU, 1 = . Clock, 1 = . Peripheral, 1 = . Clock, 1 = . Sleep, 1 = . Program Counter PC, 1 = PC + 2",
    "FIGURE 3-2: TRANSITION TIMING FOR WAKE FROM SLEEP (HSPLL)\nNote 1: TOST = 1024 TOSC; TPLL = 2 ms (approx). These intervals are not shown to scale.",
    "3.3.1 PRI_IDLE MODE\nThis mode is unique among the three Low-Power Idle modes, in that it does not disable the primary system clock. For timing sensitive applications, this allows for the fastest resumption of device operation with its more accurate primary clock source, since the clock source does not have to 'warm up' or transition from another oscillator.\nWhen a wake event occurs, the CPU is clocked from the  primary  clock  source.  A  delay  of  approximately 10 \uf06d s  is  required  between  the  wake  event  and  code execution starts. This is required to allow the CPU to become ready to execute instructions. After the wakeup, the OSTS bit remains set. The IDLEN and SCS bits are not affected by the wake-up (see Figure 3-4).\nPRI_IDLE mode is entered by setting the IDLEN bit, clearing the SCS bits and executing a SLEEP instruction.  Although  the  CPU  is  disabled,  the  peripherals continue to be clocked from the primary clock source specified in Configuration Register 1H. The OSTS bit remains set in PRI_IDLE mode (see Figure 3-3).",
    "3.3.2 SEC_IDLE MODE\nIn  SEC_IDLE  mode,  the  CPU  is  disabled,  but  the peripherals  continue  to  be  clocked  from  the  Timer1 oscillator. This mode is entered by setting the Idle bit, modifying  bits,  SCS1:SCS0  = 01 and  executing  a SLEEP instruction. When the clock source is switched (see  Figure 3-5)  to  the  Timer1  oscillator,  the  primary oscillator is shut down, the OSTS bit is cleared and the T1RUN bit is set.\nNote:",
    "3.3.2 SEC_IDLE MODE\nWhen a wake event occurs, the peripherals continue to be  clocked  from  the  Timer1  oscillator.  After  a  10 \uf06d s delay following the wake event, the CPU begins executing code, being clocked by the Timer1 oscillator. The microcontroller operates in SEC_RUN mode until the primary clock becomes ready. When the primary clock becomes ready, a clock switchback to the primary clock occurs (see Figure 3-6). When the clock switch is complete, the T1RUN bit is cleared, the OSTS bit is set and the  primary  clock  is  providing  the  system  clock.  The IDLEN and SCS bits are not affected by the wake-up. The Timer1 oscillator continues to run.",
    "3.3.2 SEC_IDLE MODE\nThe  Timer1  oscillator  should  already  be running prior to entering SEC_IDLE mode. If the T1OSCEN bit is not set when the SLEEP instruction  is  executed,  the SLEEP instruction  will be  ignored  and entry to SEC_IDLE mode will not occur. If the  Timer1  oscillator  is  enabled,  but  not yet running, peripheral clocks will be delayed until the oscillator has started; in such situations, initial oscillator operation is far from stable and unpredictable operation may result.",
    "FIGURE 3-5: TIMING TRANSITION FOR ENTRY TO SEC_IDLE MODE\nQ4 Q3 Q2 Q1 Q1, 1 = PC + 2 1 2 3 4 5 6 7 8 Clock Transition. OSC1 T1OSI Clock CPU Clock, 1 = . Peripheral, 1 = . Program PC, 1 = . Counter, 1 = ",
    "FIGURE 3-6: TIMING TRANSITION FOR WAKE FROM SEC_RUN MODE (HSPLL)\nNote 1: TOST = 1024 TOSC; TPLL = 2 ms (approx). These intervals are not shown to scale.",
    "3.3.3 RC_IDLE MODE\nIn RC_IDLE mode, the CPU is disabled, but the peripherals continue to be clocked from the internal oscillator block using the INTOSC multiplexer. This mode allows for controllable power conservation during Idle periods.\nThis mode is entered by setting the IDLEN bit, setting SCS1  (SCS0  is  ignored)  and  executing  a SLEEP instruction.  The  INTOSC multiplexer may be used to select a higher clock frequency by modifying the IRCF bits before executing the SLEEP instruction. When the clock  source  is  switched  to  the  INTOSC  multiplexer (see  Figure 3-7),  the  primary  oscillator  is  shut  down and the OSTS bit is cleared.\nIf  the  IRCF  bits  are  set  to  a  non-zero  value  (thus, enabling the INTOSC output), the IOFS bit becomes set after the INTOSC output becomes stable, in about 1 ms.  Clocks  to  the  peripherals  continue  while  the INTOSC  source  stabilizes.  If  the  IRCF  bits  were previously  at  a  non-zero  value  before  the SLEEP",
    "3.3.3 RC_IDLE MODE\ninstruction was executed and the INTOSC source was already stable, the IOFS bit will remain set. If the IRCF bits are all clear, the INTOSC output is not enabled and the IOFS bit will remain clear; there will be no indication of the current clock source.\nWhen a wake event occurs, the peripherals continue to be clocked from the INTOSC multiplexer. After a 10 \uf06d s delay following the wake event, the CPU begins executing code, being clocked by the INTOSC multiplexer. The microcontroller  operates  in  RC_RUN mode  until the primary clock becomes ready. When the primary clock becomes ready, a clock switchback to the primary clock occurs (see Figure 3-8). When the clock switch is complete, the IOFS bit is cleared, the OSTS bit is set and the  primary  clock  is  providing  the  system  clock. The IDLEN and SCS bits are not affected by the wakeup. The INTRC source will continue to run if either the WDT or the Fail-Safe Clock Monitor is enabled.",
    "FIGURE 3-7: TIMING TRANSITION TO RC_IDLE MODE\nFIGURE 3-8:",
    "TIMING TRANSITION FOR WAKE FROM RC_RUN MODE (RC_RUN TO PRI_RUN)\nNote 1: TOST = 1024 TOSC; TPLL = 2 ms (approx). These intervals are not shown to scale.",
    "3.4 Run Modes\nIf  the  IDLEN bit is clear when a SLEEP instruction is executed, the CPU and peripherals are both clocked from the source selected using the SCS1:SCS0 bits. While these operating modes may not afford the power conservation of Idle or Sleep modes, they do allow the device  to  continue  executing  instructions  by  using  a lower  frequency  clock  source.  RC_RUN  mode  also offers the possibility of executing code at a frequency greater than the primary clock.\nWake-up from a power managed Run mode can be triggered by an interrupt, or any Reset, to return to fullpower operation. As the CPU is executing code in Run modes, several additional exits  from  Run  modes  are possible. They include exit to Sleep mode, exit to a corresponding Idle mode and exit by executing a RESET instruction.  While  the  device  is  in  any  of  the  power managed Run modes, a WDT time-out will result in a WDT Reset.",
    "3.4.1 PRI_RUN MODE\nThe PRI_RUN mode is the normal full-power execution mode. If the SLEEP instruction is never executed, the microcontroller operates in this mode (a SLEEP instruction  is  executed  to  enter  all  other  power  managed modes).  All  other  power  managed  modes  exit  to PRI_RUN mode when an interrupt  or  WDT  time-out occur.\nThere is no entry to PRI_RUN mode. The OSTS bit is set. The IOFS bit may be set if the internal oscillator block is the primary clock source (see Section 2.7.1 'Oscillator Control Register' ).",
    "3.4.2 SEC_RUN MODE\nThe SEC_RUN mode is the compatible mode to the 'clock switching' feature offered in other PIC18 devices.  In  this  mode,  the  CPU  and  peripherals  are clocked from the Timer1 oscillator. This gives users the option of lower power consumption while still using a high accuracy clock source.\nSEC_RUN mode is entered by clearing the IDLEN bit, setting  SCS1:SCS0  = 01 and  executing  a SLEEP instruction. The system clock source is switched to the Timer1 oscillator (see Figure 3-9), the primary oscillator is shut down, the T1RUN bit (T1CON<6>) is set and the OSTS bit is cleared.",
    "Note:\nThe  Timer1  oscillator  should  already  be running prior to entering SEC_RUN mode. If the T1OSCEN bit is not set when the SLEEP instruction  is  executed,  the SLEEP instruction  will be  ignored  and entry to SEC_RUN mode will not occur. If the  Timer1  oscillator  is  enabled,  but  not yet running, system clocks will be delayed until  the  oscillator  has  started;  in  such situations, initial oscillator operation is far from  stable  and  unpredictable  operation may result.\nWhen a wake event occurs, the peripherals and CPU continue to be clocked from the Timer1 oscillator while the  primary  clock  is  started.  When  the  primary  clock becomes ready, a clock switchback to the primary clock occurs (see Figure 3-6). When the clock switch is complete, the T1RUN bit is cleared, the OSTS bit is set and the  primary  clock  is  providing  the  system  clock.  The IDLEN and SCS bits are not affected by the wake-up. The Timer1 oscillator continues to run.",
    "Note:\nFirmware can force an exit from SEC_RUN mode. By clearing the T1OSCEN bit (T1CON<3>), an exit from SEC_RUN back to normal full-power operation is triggered. The Timer1 oscillator will continue  to run and provide the system clock, even though the T1OSCEN bit is cleared. The primary clock is started. When the primary clock becomes ready, a clock switchback to the primary clock occurs (see Figure 3-6). When the clock switch is complete, the Timer1 oscillator is disabled, the T1RUN bit is cleared, the OSTS bit is set and the primary clock is providing the system clock. The IDLEN and SCS bits are not affected by the wake-up.\nFIGURE 3-9: TIMING TRANSITION FOR ENTRY TO SEC_RUN MODE",
    "3.4.3 RC_RUN MODE\nIn RC_RUN  mode,  the  CPU  and  peripherals  are clocked  from  the  internal  oscillator  block  using  the INTOSC  multiplexer  and  the  primary  clock  is  shut down. When using the INTRC source, this mode provides  the  best  power  conservation  of  all  the  Run modes, while still executing code. It works well for user applications which are not highly timing sensitive, or do not require high-speed clocks at all times.\nIf  the  primary  clock  source  is  the  internal  oscillator block (either of the INTIO1 or INTIO2 oscillators), there are no distinguishable differences between PRI_RUN and  RC_RUN  modes  during  execution.  However,  a clock switch delay will occur during entry to and exit from RC_RUN mode. Therefore, if the primary clock source  is  the  internal  oscillator  block,  the  use  of RC_RUN mode is not recommended.",
    "3.4.3 RC_RUN MODE\nThis mode is entered by clearing the IDLEN bit, setting SCS1  (SCS0  is  ignored)  and  executing  a SLEEP instruction. The  IRCF  bits may  select the clock frequency  before  the SLEEP instruction  is  executed. When  the  clock  source  is  switched  to  the  INTOSC multiplexer (see Figure 3-10), the primary oscillator is shut down and the OSTS bit is cleared.\nNote:\nCaution should be used when modifying a single IRCF bit. If VDD is less than 3V, it is possible  to  select  a  higher  clock  speed than is supported by the low VDD. Improper  device  operation  may  result  if the VDD/FOSC specifications are violated.\nIf the IRCF bits are all clear, the INTOSC output is not enabled and the IOFS bit will remain clear; there will be no indication of the current clock source. The INTRC source is providing the system clocks.\nIf the  IRCF  bits  are  changed  from  all  clear  (thus, enabling the INTOSC output), the IOFS bit becomes set after the INTOSC output becomes stable. Clocks to the system continue while the INTOSC source stabilizes, in approximately 1 ms.",
    "3.4.3 RC_RUN MODE\nIf  the  IRCF  bits  were  previously  at  a  non-zero  value before  the SLEEP instruction  was  executed  and  the INTOSC source was already stable, the IOFS bit will remain set.\nThe IRCF bits may be modified at any time to immediately  change  the  system  clock  speed.  Executing  a SLEEP instruction is not required to select a new clock frequency from the INTOSC multiplexer.\nWhen a wake event occurs, the system continues to be clocked from the INTOSC multiplexer while the primary clock  is  started.  When  the  primary  clock  becomes ready, a clock switch to the primary clock occurs (see Figure 3-8).  When  the  clock  switch  is  complete,  the IOFS bit is cleared, the OSTS bit is set and the primary clock  is  providing  the  system  clock.  The  IDLEN  and SCS bits are not affected by the wake-up. The INTRC source  will  continue  to  run  if  either  the  WDT  or  the Fail-Safe Clock Monitor is enabled.",
    "3.4.4 EXIT TO IDLE MODE\nAn  exit  from  a  power  managed  Run  mode  to  its corresponding  Idle  mode  is  executed  by  setting  the IDLEN bit and executing a SLEEP instruction. The CPU is halted at the beginning of the instruction following the SLEEP instruction. There are no changes to any of the clock  source  status  bits  (OSTS,  IOFS  or  T1RUN). While the CPU is halted, the peripherals continue to be clocked from the previously selected clock source.",
    "3.4.5 EXIT TO SLEEP MODE\nAn  exit  from  a  power  managed  Run  mode  to  Sleep mode is executed by clearing the IDLEN and SCS1:SCS0 bits  and  executing  a SLEEP instruction. The code is no different than the method used to invoke Sleep  mode  from  the  normal  operating  (full-power) mode.\nThe  primary  clock  and  internal  oscillator  block  are disabled.  The  INTRC  will  continue  to  operate  if  the WDT is enabled. The Timer1 oscillator will continue to run, if enabled in the T1CON register (Register 12-1). All clock source Status bits are cleared (OSTS, IOFS and T1RUN).",
    "3.5 Wake from Power Managed Modes\nAn exit from any of the power managed modes is triggered by an interrupt, a Reset or a WDT time-out. This section  discusses  the  triggers  that  cause  exits  from power  managed  modes.  The  clocking  subsystem actions are discussed in each of the power managed modes (see Sections 3.2 through 3.4).\nNote:\nIf  application  code  is  timing  sensitive,  it should wait for the  OSTS bit to become set  before  continuing.  Use  the  interval during the low-power exit sequence (before  OSTS  is  set)  to  perform  timing insensitive 'housekeeping' tasks.\nDevice  behavior  during  Low-Power  mode  exits  is summarized in Table 3-3.",
    "3.5.1 EXIT BY INTERRUPT\nAny of the available interrupt sources can cause the device to exit a power managed mode and resume fullpower operation. To enable this functionality, an interrupt source must be enabled by setting its enable bit in one of the INTCON or PIE registers. The exit sequence is initiated when the corresponding interrupt flag bit is set.  On  all  exits  from  Low-Power  mode  by  interrupt, code execution branches to the interrupt vector if the GIE/GIEH  bit  (INTCON<7>)  is  set.  Otherwise,  code execution  continues  or  resumes  without  branching (see Section 9.0 'Interrupts' ).",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nPrimary System Clock (PRI_IDLE mode), Primary System Clock.Primary System Clock = LP, XT, HS. Primary System Clock (PRI_IDLE mode), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = 5-10 \uf06d s (5). Primary System Clock (PRI_IDLE mode), ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = OSTS. Primary System Clock (PRI_IDLE mode), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU and peripherals clocked by primary clock and executing instructions.. Primary System Clock (PRI_IDLE mode), Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. Primary System Clock (PRI_IDLE mode), Primary System Clock.Primary System Clock = HSPLL. Primary System Clock (PRI_IDLE mode), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = 5-10 \uf06d s (5). Primary System Clock (PRI_IDLE mode),",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = OSTS. Primary System Clock (PRI_IDLE mode), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU and peripherals clocked by primary clock and executing instructions.. Primary System Clock (PRI_IDLE mode), Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. Primary System Clock (PRI_IDLE mode), Primary System Clock.Primary System Clock = EC, RC, INTRC (1). Primary System Clock (PRI_IDLE mode), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = 5-10 \uf06d s (5). Primary System Clock (PRI_IDLE mode), ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = -. Primary System Clock (PRI_IDLE mode), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU and peripherals clocked by primary clock and executing",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\ninstructions.. Primary System Clock (PRI_IDLE mode), Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. Primary System Clock (PRI_IDLE mode), Primary System Clock.Primary System Clock = INTOSC (2). Primary System Clock (PRI_IDLE mode), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = 5-10 \uf06d s (5). Primary System Clock (PRI_IDLE mode), ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = IOFS. Primary System Clock (PRI_IDLE mode), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU and peripherals clocked by primary clock and executing instructions.. Primary System Clock (PRI_IDLE mode), Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. T1OSC or INTRC (1), Primary System Clock.Primary System",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nClock = LP, XT, HS. T1OSC or INTRC (1), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = OST. T1OSC or INTRC (1), ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = OSTS. T1OSC or INTRC (1), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU and peripherals clocked by selected power managed mode clock and executing instructions until primary clock source becomes ready.. T1OSC or INTRC (1), Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. T1OSC or INTRC (1), Primary System Clock.Primary System Clock = HSPLL. T1OSC or INTRC (1), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = OST + 2 ms. T1OSC or INTRC (1), ClockReady Status Bit",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\n(OSCCON).ClockReady Status Bit (OSCCON) = OSTS. T1OSC or INTRC (1), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU and peripherals clocked by selected power managed mode clock and executing instructions until primary clock source becomes ready.. T1OSC or INTRC (1), Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. T1OSC or INTRC (1), Primary System Clock.Primary System Clock = EC, RC, INTRC (1). T1OSC or INTRC (1), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = 5-10 \uf06d s (5). T1OSC or INTRC (1), ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = -. T1OSC or INTRC (1), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nand peripherals clocked by selected power managed mode clock and executing instructions until primary clock source becomes ready.. T1OSC or INTRC (1), Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. T1OSC or INTRC (1), Primary System Clock.Primary System Clock = INTOSC (2). T1OSC or INTRC (1), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = 1 ms (4). T1OSC or INTRC (1), ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = IOFS. T1OSC or INTRC (1), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU and peripherals clocked by selected power managed mode clock and executing instructions until primary clock source becomes ready.. T1OSC or INTRC (1), Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nTwo-Speed Start-up (if enabled) (3) .. INTOSC (2), Primary System Clock.Primary System Clock = LP, XT, HS. INTOSC (2), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = OST. INTOSC (2), ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = OSTS. INTOSC (2), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU and peripherals clocked by selected power managed mode clock and executing instructions until primary clock source becomes ready.. INTOSC (2), Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. INTOSC (2), Primary System Clock.Primary System Clock = HSPLL. INTOSC (2), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = OST + 2 ms. INTOSC (2), ClockReady Status Bit (OSCCON).ClockReady Status",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nBit (OSCCON) = OSTS. INTOSC (2), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU and peripherals clocked by selected power managed mode clock and executing instructions until primary clock source becomes ready.. INTOSC (2), Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. INTOSC (2), Primary System Clock.Primary System Clock = EC, RC, INTRC (1). INTOSC (2), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = 5-10 \uf06d s (5). INTOSC (2), ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = -. INTOSC (2), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU and peripherals clocked by selected power managed mode clock and executing instructions until primary clock source becomes ready.. INTOSC (2), Activity during Wake-up from Power Managed Mode.Exit by",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nReset = Not clocked or Two-Speed Start-up (if enabled) (3) .. INTOSC (2), Primary System Clock.Primary System Clock = INTOSC (2). INTOSC (2), Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = None. INTOSC (2), ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = IOFS. INTOSC (2), Activity during Wake-up from Power Managed Mode.Exit by Interrupt = CPU and peripherals clocked by selected power managed mode clock and executing instructions until primary clock source becomes ready.. INTOSC (2), Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. Sleep mode, Primary System Clock.Primary System Clock = LP, XT, HS. Sleep mode, Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = OST. Sleep mode, ClockReady Status Bit (OSCCON).ClockReady Status Bit",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\n(OSCCON) = OSTS. Sleep mode, Activity during Wake-up from Power Managed Mode.Exit by Interrupt = Not clocked or Two-Speed Start-up (if enabled) until primary clock source becomes ready (3) .. Sleep mode, Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. Sleep mode, Primary System Clock.Primary System Clock = HSPLL. Sleep mode, Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = OST + 2 ms. Sleep mode, ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = OSTS. Sleep mode, Activity during Wake-up from Power Managed Mode.Exit by Interrupt = Not clocked or Two-Speed Start-up (if enabled) until primary clock source becomes ready (3) .. Sleep mode, Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. Sleep mode, Primary",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nSystem Clock.Primary System Clock = EC, RC, INTRC (1). Sleep mode, Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = 5-10 \uf06d s (5). Sleep mode, ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = -. Sleep mode, Activity during Wake-up from Power Managed Mode.Exit by Interrupt = Not clocked or Two-Speed Start-up (if enabled) until primary clock source becomes ready (3) .. Sleep mode, Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .. Sleep mode, Primary System Clock.Primary System Clock = INTOSC (2). Sleep mode, Power Managed Mode Exit Delay.Power Managed Mode Exit Delay = 1 ms (4). Sleep mode, ClockReady Status Bit (OSCCON).ClockReady Status Bit (OSCCON) = IOFS. Sleep mode, Activity during Wake-up from Power Managed Mode.Exit by Interrupt = Not clocked or",
    "TABLE 3-3: ACTIVITY AND EXIT DELAY ON WAKE FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nTwo-Speed Start-up (if enabled) until primary clock source becomes ready (3) .. Sleep mode, Activity during Wake-up from Power Managed Mode.Exit by Reset = Not clocked or Two-Speed Start-up (if enabled) (3) .\nNote 1: In this instance, refers specifically to the INTRC clock source.\n2: Includes both the INTOSC 8 MHz source and postscaler derived frequencies.\n3: Two-Speed Start-up is covered in greater detail in Section 19.3 'Two-Speed Start-up' .\n4: Execution continues during the INTOSC stabilization period.\n5: Required delay when waking from Sleep and all Idle modes. This delay runs concurrently with any other required delays (see Section 3.3 'Idle Modes' ).",
    "3.5.2 EXIT BY RESET\nNormally, the device is held in Reset by the Oscillator Start-up Timer (OST) until the primary clock (defined in Configuration  Register  1H)  becomes  ready.  At  that time,  the  OSTS  bit  is  set  and  the  device  begins executing code.\nCode  execution  can  begin  before  the  primary  clock becomes ready. If either the Two-Speed Start-up (see Section 19.3  'Two-Speed  Start-up' ) or Fail-Safe Clock  Monitor  (see Section 19.4  'Fail-Safe  Clock Monitor' )  are  enabled  in  Configuration  Register  1H, the device may begin execution as soon as the Reset source  has  cleared.  Execution  is  clocked  by  the INTOSC  multiplexer  driven  by  the  internal  oscillator block. Since the OSCCON register is cleared following all  Resets,  the  INTRC  clock  source  is  selected.  A higher speed clock may be selected by modifying the IRCF  bits  in the  OSCCON  register.  Execution  is clocked by the internal oscillator block until either the primary  clock  becomes  ready,  or  a  power  managed mode  is  entered  before  the  primary  clock  becomes ready; the primary clock is then shut down.",
    "3.5.3 EXIT BY WDT TIME-OUT\nA WDT time-out will cause different actions, depending on which power managed mode the device is in when the time-out occurs.\nIf the device is not executing code (all Idle modes and Sleep mode), the time-out will result in a wake from the power managed mode (see Sections 3.2 through 3.4).\nIf  the  device  is  executing  code  (all  Run  modes),  the time-out will result in a WDT Reset (see Section 19.2 'Watchdog Timer (WDT)' ).\nThe WDT  timer and postscaler are cleared by executing a SLEEP or CLRWDT instruction, the loss of a currently selected clock source (if the Fail-Safe Clock Monitor is enabled) and modifying the IRCF bits in the OSCCON register if the internal oscillator block is the system clock source.",
    "3.5.4 EXIT WITHOUT AN OSCILLATOR START-UP DELAY\nCertain  exits  from  power  managed  modes  do  not invoke the OST at all. These are:\n\u00b7 PRI_IDLE mode, where the primary clock source is not stopped; or\n\u00b7 the primary clock source is not any of LP, XT, HS or HSPLL modes.\nIn  these cases, the primary clock source either does not  require  an  oscillator  start-up  delay,  since  it  is already  running  (PRI_IDLE),  or  normally  does  not require an oscillator start-up delay (RC, EC and INTIO Oscillator modes).\nHowever, a fixed delay (approximately 10 \uf06d s) following the wake event is required when leaving Sleep and Idle modes. This delay is required for the CPU to prepare for execution. Instruction execution resumes on the first clock cycle following this delay.",
    "3.6 INTOSC Frequency Drift\nThe  factory  calibrates  the  internal  oscillator  block output (INTOSC) for 8 MHz (see Table 22-6). However, this frequency may  drift as VDD  or temperature changes, which can affect the controller operation in a variety of ways.\nIt is possible  to  adjust  the  INTOSC  frequency  by modifying the value in the OSCTUNE register (Register 2-1). This has the side effect that the INTRC clock source frequency is also affected. However, the features that use the INTRC source often do not require an exact frequency. These features include the Fail-Safe Clock Monitor, the Watchdog Timer and the RC_RUN/ RC_IDLE  modes  when  the  INTRC  clock  source  is selected.\nBeing  able  to  adjust  the  INTOSC  requires  knowing when an adjustment is required, in which direction it should  be  made  and  in  some  cases,  how  large  a change  is  needed.  Three  examples  follow  but  other techniques may be used.",
    "3.6.1 EXAMPLE - EUSART\nAn  adjustment  may  be  indicated  when  the  EUSART begins to generate framing errors, or receives data with errors  while  in  Asynchronous  mode.  Framing  errors indicate that the system clock frequency is too high try decrementing the value in the OSCTUNE register to reduce the system clock frequency. Errors in data may suggest  that  the  system  clock  speed  is  too  low  increment OSCTUNE.",
    "3.6.2 EXAMPLE - TIMERS\nThis technique compares system clock speed to some reference clock. Two timers may be used; one timer is clocked  by  the  peripheral  clock,  while  the  other  is clocked  by  a  fixed  reference  source,  such  as  the Timer1 oscillator.\nBoth timers are cleared, but the timer clocked by the reference  generates  interrupts.  When  an  interrupt occurs,  the  internally  clocked  timer  is  read  and  both timers are cleared. If the internally clocked timer value is  greater  than  expected,  then  the  internal  oscillator block is running too fast - decrement OSCTUNE.",
    "3.6.3 EXAMPLE - CCP IN CAPTURE MODE\nA  CCP  module  can  use  free  running  Timer1  (or Timer3), clocked by the internal oscillator block and an external  event  with  a  known  period  (i.e.,  AC  power frequency). The time of the first event is captured in the CCPRxH:CCPRxL registers  and  is  recorded  for  use later.  When  the  second  event  causes  a  capture,  the time of the first event is subtracted from the time of the second event. Since the period of the external event is known,  the  time  difference  between  events  can  be calculated.\nIf the measured  time  is much  greater than the calculated time, the internal oscillator block is running too fast - decrement OSCTUNE. If the measured time is  much  less  than  the  calculated  time,  the  internal oscillator block is running too slow-increment OSCTUNE.",
    "4.0 RESET\nThe  PIC18F1220/1320  devices  differentiate  between various kinds of Reset:\na) Power-on Reset (POR)\nb) MCLR Reset during normal operation\nc) MCLR Reset during Sleep\nd) Watchdog Timer (WDT) Reset (during execution)\ne) Programmable Brown-out Reset (BOR)\nf) RESET Instruction\ng) Stack Full Reset\nh) Stack Underflow Reset\nMost  registers  are  not  affected  by  a  WDT  wake-up, since  this  is  viewed  as  the  resumption  of  normal operation. Status bits from the RCON register (Register 5-2), RI, TO, PD, POR and BOR, are set or cleared  differently  in  different  Reset  situations,  as indicated in Table 4-2. These bits are used in software to determine the nature of the Reset. See Table 4-3 for a full description of the Reset states of all registers.\nA simplified block diagram of the On-Chip Reset Circuit is shown in Figure 4-1.\nThe Enhanced MCU devices have a MCLR noise filter in  the  MCLR  Reset  path.  The  filter  will  detect  and ignore small pulses.",
    "4.0 RESET\nMost registers are unaffected by a Reset. Their status is unknown  on  POR  and  unchanged  by  all  other Resets.  The  other  registers  are  forced  to  a  'Reset state', depending on the type of Reset that occurred.\nThe MCLR pin is not driven low by any internal Resets, including the WDT.\nThe  MCLR  input  provided  by  the  MCLR  pin  can  be disabled with the MCLRE bit in Configuration Register 3H (CONFIG3H<7>).",
    "4.1 Power-on Reset (POR)\nA  Power-on  Reset  pulse  is  generated  on-chip  when VDD rise is detected. To  take  advantage  of  the  POR circuitry, just tie the MCLR pin through a resistor (1k to 10 k \uf057 ) to VDD. This will eliminate external RC components  usually  needed  to  create  a  Power-on  Reset delay. A  minimum  rise  rate  for VDD  is  specified (parameter D004). For a slow rise time, see Figure 4-2.\nWhen the device starts normal operation (i.e., exits the Reset  condition),  device  operating  parameters  (voltage,  frequency,  temperature,  etc.)  must  be  met  to ensure operation. If these conditions are not met, the device  must  be  held  in  Reset  until  the  operating conditions are met.",
    "EXTERNAL POWER-ON RESET CIRCUIT (FOR SLOW VDD POWER-UP)\nNote 1: External Power-on Reset circuit is required only if  the  VDD  power-up  slope  is  too  slow.  The diode D helps discharge the capacitor quickly when VDD powers down.\n2: R < 40 k \uf057 is recommended to make sure that the  voltage  drop  across  R  does  not  violate the device's electrical specification.\n3: R1 \uf0b3 1  k \uf057 will  limit  any  current  flowing into MCLR from external capacitor C, in the event of MCLR/VPP pin breakdown due to Electrostatic Discharge (ESD) or Electrical Overstress (EOS).",
    "4.2 Power-up Timer (PWRT)\nThe Power-up Timer (PWRT) of the PIC18F1220/1320 is an 11-bit counter, which uses the INTRC source as the clock input. This yields a count of 2048 x 32 \uf06d s = 65.6 ms. While the PWRT is counting, the device is held in Reset.\nThe power-up time delay will vary from chip-to-chip due to  VDD,  temperature  and  process  variation.  See  DC parameter 33 for details.\nThe  PWRT  is  enabled  by  clearing  Configuration  bit, PWRTEN.",
    "4.3 Oscillator Start-up Timer (OST)\nThe Oscillator Start-up Timer (OST) provides a 1024 oscillator  cycle  (from  OSC1  input)  delay  after  the PWRT delay is over (parameter 33). This ensures that the  crystal  oscillator  or  resonator  has  started  and stabilized.\nThe OST time-out is invoked only for XT, LP, HS and HSPLL modes and only on Power-on Reset, or on exit from most low-power modes.",
    "4.4 PLL Lock Time-out\nWith  the  PLL  enabled  in  its  PLL  mode,  the  time-out sequence  following a Power-on  Reset  is slightly different from other oscillator modes. A portion of the Power-up Timer is used to provide a fixed time-out that is sufficient for the PLL to lock to the main oscillator frequency. This PLL lock time-out (TPLL) is typically 2 ms and follows the Oscillator Start-up Time-out.",
    "4.5 Brown-out Reset (BOR)\nA Configuration bit, BOR,  can disable (if clear/ programmed), or enable (if set) the Brown-out Reset circuitry. If VDD falls below VBOR (parameter D005) for greater than TBOR (parameter 35), the brown-out situation will reset the chip. A Reset may not occur if VDD falls  below  VBOR  for  less  than  TBOR.  The  chip  will remain in Brown-out Reset until VDD rises above VBOR. If the Power-up Timer is enabled, it will be invoked after VDD  rises  above  VBOR;  it  then  will  keep  the  chip  in Reset for an additional time delay, TPWRT (parameter 33).  If  VDD  drops  below  VBOR  while  the Power-up Timer is running, the chip will go back into a Brown-out Reset and the Power-up Timer will be initialized. Once VDD rises above VBOR, the Power-up Timer will  execute  the  additional  time  delay.  Enabling  BOR Reset does not automatically enable the PWRT.",
    "4.6 Time-out Sequence\nOn  power-up,  the  time-out  sequence  is  as  follows: First, after the POR pulse has cleared, PWRT time-out is invoked (if enabled). Then, the OST is activated. The total time-out will vary based on oscillator configuration and the status of the PWRT. For example, in RC mode with the PWRT disabled, there will be no time-out at all. Figure 4-3, Figure 4-4, Figure 4-5, Figure 4-6 and Figure 4-7 depict time-out sequences on power-up.\nSince the time-outs occur from the POR pulse, if MCLR is kept low long enough, all time-outs will expire. Bringing MCLR  high  will begin execution immediately (Figure 4-5). This is useful for testing purposes or to synchronize more  than one PIC18FXXXX  device operating in parallel.\nTable 4-2 shows the Reset conditions for some Special Function Registers, while Table 4-3 shows the Reset conditions for all the registers.",
    "TABLE 4-1: TIME-OUT IN VARIOUS SITUATIONS\nHSPLL, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1) + 1024 T OSC + 2 ms (2). HSPLL, Power-up (2) and Brown-out.PWRTEN = 1 = 1024 T OSC + 2 ms (2). HSPLL, Exit from Low-Power Mode. = 1024 T OSC + 2 ms (2). HS, XT, LP, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1) + 1024 T OSC. HS, XT, LP, Power-up (2) and Brown-out.PWRTEN = 1 = 1024 T OSC. HS, XT, LP, Exit from Low-Power Mode. = 1024 T OSC. EC, ECIO, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1). EC, ECIO, Power-up (2) and Brown-out.PWRTEN = 1 = 5-10 \uf06d s (3). EC,",
    "TABLE 4-1: TIME-OUT IN VARIOUS SITUATIONS\nECIO, Exit from Low-Power Mode. = 5-10 \uf06d s (3). RC, RCIO, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1). RC, RCIO, Power-up (2) and Brown-out.PWRTEN = 1 = 5-10 \uf06d s (3). RC, RCIO, Exit from Low-Power Mode. = 5-10 \uf06d s (3). INTIO1, INTIO2, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1). INTIO1, INTIO2, Power-up (2) and Brown-out.PWRTEN = 1 = 5-10 \uf06d s (3). INTIO1, INTIO2, Exit from Low-Power Mode. = 5-10 \uf06d s (3)",
    "TABLE 4-1: TIME-OUT IN VARIOUS SITUATIONS\nNote 1: 66 ms (65.5 ms) is the nominal Power-up Timer (PWRT) delay.\n2: 2 ms is the nominal time required for the 4x PLL to lock.\n3: The program memory bias start-up time is always invoked on POR, wake-up from Sleep, or on any exit from power managed mode that disables the CPU and instruction execution.",
    "REGISTER 4-1: OSCCON: OSCILLATOR CONTROL REGISTER\nNote: Refer to Section 5.14 'RCON Register' for bit definitions.\n\nIPEN, U-0 = -. IPEN, U-0 = -. IPEN, R/W-1/1 = RI. IPEN, R/W-1/1 = TO. IPEN, U-0 = PD. IPEN, R/W-1/1 = POR. IPEN, R/W-1/1 = BOR. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-1/1 = bit 7. bit 7, R/W-1/1 = bit 0",
    "REGISTER 4-1: OSCCON: OSCILLATOR CONTROL REGISTER\nR = Readable bit,  = W=Writable. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "TABLE 4-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nPower-on Reset, Program Counter = 0000h. Power-on Reset, RCON Register = 0--1 1100. Power-on Reset, RI = 1. Power-on Reset, TO = 1. Power-on Reset, PD = 1. Power-on Reset, POR = 0. Power-on Reset, BOR = 0. Power-on Reset, STKFUL = 0. Power-on Reset, STKUNF = 0. RESET Instruction, Program Counter = 0000h. RESET Instruction, RCON Register = 0--0 uuuu. RESET Instruction, RI = 0. RESET Instruction, TO = u. RESET Instruction, PD = u. RESET Instruction, POR = u. RESET Instruction, BOR = u. RESET Instruction, STKFUL = u. RESET Instruction, STKUNF = u. Brown-out, Program Counter = 0000h. Brown-out, RCON Register = 0--1 11u-. Brown-out, RI = 1. Brown-out, TO = 1. Brown-out, PD = 1. Brown-out, POR = u.",
    "TABLE 4-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nBrown-out, BOR = 0. Brown-out, STKFUL = u. Brown-out, STKUNF = u. MCLR during Power Managed Run modes, Program Counter = 0000h. MCLR during Power Managed Run modes, RCON Register = 0--u 1uuu. MCLR during Power Managed Run modes, RI = u. MCLR during Power Managed Run modes, TO = 1. MCLR during Power Managed Run modes, PD = u. MCLR during Power Managed Run modes, POR = u. MCLR during Power Managed Run modes, BOR = u. MCLR during Power Managed Run modes, STKFUL = u. MCLR during Power Managed Run modes, STKUNF = u. MCLR during Power Managed Idle modes and Sleep, Program Counter = 0000h. MCLR during Power Managed Idle modes and Sleep, RCON Register = 0--u 10uu. MCLR during Power Managed Idle modes and Sleep, RI = u. MCLR during Power Managed Idle modes and Sleep, TO = 1. MCLR during Power Managed Idle modes and Sleep, PD = 0.",
    "TABLE 4-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nMCLR during Power Managed Idle modes and Sleep, POR = u. MCLR during Power Managed Idle modes and Sleep, BOR = u. MCLR during Power Managed Idle modes and Sleep, STKFUL = u. MCLR during Power Managed Idle modes and Sleep, STKUNF = u. WDT Time-out during Full-Power or Power Managed Run, Program Counter = 0000h. WDT Time-out during Full-Power or Power Managed Run, RCON Register = 0--u 0uuu. WDT Time-out during Full-Power or Power Managed Run, RI = u. WDT Time-out during Full-Power or Power Managed Run, TO = 0. WDT Time-out during Full-Power or Power Managed Run, PD = u. WDT Time-out during Full-Power or Power Managed Run, POR = u. WDT Time-out during Full-Power or Power Managed Run, BOR = u. WDT Time-out during Full-Power or Power Managed Run, STKFUL = u. WDT Time-out during Full-Power or Power Managed Run,",
    "TABLE 4-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nSTKUNF = u. MCLR during Full-Power Execution, Program Counter = . MCLR during Full-Power Execution, RCON Register = . MCLR during Full-Power Execution, RI = . MCLR during Full-Power Execution, TO = . MCLR during Full-Power Execution, PD = . MCLR during Full-Power Execution, POR = . MCLR during Full-Power Execution, BOR = . MCLR during Full-Power Execution, STKFUL = u. MCLR during Full-Power Execution, STKUNF = u. Stack Full Reset (STVR = 1 ), Program Counter = 0000h. Stack Full Reset (STVR = 1 ), RCON Register = 0--u uuuu. Stack Full Reset (STVR = 1 ), RI = u. Stack Full Reset (STVR = 1 ), TO = u. Stack Full Reset (STVR = 1 ), PD = u. Stack Full Reset (STVR = 1 ), POR = u. Stack Full Reset (STVR = 1 ), BOR = u. Stack Full Reset (STVR = 1",
    "TABLE 4-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n), STKFUL = 1. Stack Full Reset (STVR = 1 ), STKUNF = u. Stack Underflow Reset (STVR = 1 ), Program Counter = . Stack Underflow Reset (STVR = 1 ), RCON Register = . Stack Underflow Reset (STVR = 1 ), RI = . Stack Underflow Reset (STVR = 1 ), TO = . Stack Underflow Reset (STVR = 1 ), PD = . Stack Underflow Reset (STVR = 1 ), POR = . Stack Underflow Reset (STVR = 1 ), BOR = . Stack Underflow Reset (STVR = 1 ), STKFUL = u. Stack Underflow Reset (STVR = 1 ), STKUNF = 1. Stack Underflow Error (not an actual Reset, STVR = 0 ), Program Counter = 0000h. Stack Underflow Error (not an actual Reset, STVR = 0 ), RCON Register = u--u uuuu. Stack Underflow Error (not an actual Reset, STVR = 0 ), RI = u. Stack Underflow",
    "TABLE 4-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nError (not an actual Reset, STVR = 0 ), TO = u. Stack Underflow Error (not an actual Reset, STVR = 0 ), PD = u. Stack Underflow Error (not an actual Reset, STVR = 0 ), POR = u. Stack Underflow Error (not an actual Reset, STVR = 0 ), BOR = u. Stack Underflow Error (not an actual Reset, STVR = 0 ), STKFUL = u. Stack Underflow Error (not an actual Reset, STVR = 0 ), STKUNF = 1. WDT Time-out during Power Man- aged Idle or Sleep, Program Counter = PC + 2. WDT Time-out during Power Man- aged Idle or Sleep, RCON Register = u--u 00uu. WDT Time-out during Power Man- aged Idle or Sleep, RI = u. WDT Time-out during Power Man- aged Idle or Sleep, TO = 0. WDT Time-out during Power Man- aged Idle or Sleep, PD = 0. WDT Time-out during Power Man- aged Idle or",
    "TABLE 4-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nSleep, POR = u. WDT Time-out during Power Man- aged Idle or Sleep, BOR = u. WDT Time-out during Power Man- aged Idle or Sleep, STKFUL = u. WDT Time-out during Power Man- aged Idle or Sleep, STKUNF = u. Interrupt Exit from Power Managed modes, Program Counter = PC + 2. Interrupt Exit from Power Managed modes, RCON Register = u--u u0uu. Interrupt Exit from Power Managed modes, RI = u. Interrupt Exit from Power Managed modes, TO = u. Interrupt Exit from Power Managed modes, PD = 0. Interrupt Exit from Power Managed modes, POR = u. Interrupt Exit from Power Managed modes, BOR = u. Interrupt Exit from Power Managed modes, STKFUL = u. Interrupt Exit from Power Managed modes, STKUNF = u\nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 '\nNote 1:",
    "TABLE 4-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n- When the wake-up is due to an interrupt and the GIEH or GIEL bits are set, the PC is loaded with the interrupt vector (0x000008h or 0x000018h).",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTOSU, Applicable Devices = 1220. TOSU, Applicable Devices = 1320. TOSU, Power-on Reset, Brown-out Reset = ---0 0000. TOSU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. TOSU, Wake-up via WDT or Interrupt = ---0 uuuu (3). TOSH, Applicable Devices = 1220. TOSH, Applicable Devices = 1320. TOSH, Power-on Reset, Brown-out Reset = 0000 0000. TOSH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSH, Wake-up via WDT or Interrupt = uuuu uuuu (3). TOSL, Applicable Devices = 1220. TOSL, Applicable Devices = 1320. TOSL, Power-on Reset, Brown-out Reset = 0000 0000. TOSL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSL, Wake-up via WDT or Interrupt = uuuu uuuu",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n(3). STKPTR, Applicable Devices = 1220. STKPTR, Applicable Devices = 1320. STKPTR, Power-on Reset, Brown-out Reset = 00-0 0000. STKPTR, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-0 0000. STKPTR, Wake-up via WDT or Interrupt = uu-u uuuu (3). PCLATU, Applicable Devices = 1220. PCLATU, Applicable Devices = 1320. PCLATU, Power-on Reset, Brown-out Reset = ---0 0000. PCLATU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. PCLATU, Wake-up via WDT or Interrupt = ---u uuuu. PCLATH, Applicable Devices = 1220. PCLATH, Applicable Devices = 1320. PCLATH, Power-on Reset, Brown-out Reset = 0000 0000. PCLATH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPCLATH, Wake-up via WDT or Interrupt = uuuu uuuu. PCL, Applicable Devices = 1220. PCL, Applicable Devices = 1320. PCL, Power-on Reset, Brown-out Reset = 0000 0000. PCL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCL, Wake-up via WDT or Interrupt = PC + 2 (2). TBLPTRU, Applicable Devices = 1220. TBLPTRU, Applicable Devices = 1320. TBLPTRU, Power-on Reset, Brown-out Reset = --00 0000. TBLPTRU, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. TBLPTRU, Wake-up via WDT or Interrupt = --uu uuuu. TBLPTRH, Applicable Devices = 1220. TBLPTRH, Applicable Devices = 1320. TBLPTRH, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRH, MCLR Resets WDT Reset RESET Instruction Stack",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nResets = 0000 0000. TBLPTRH, Wake-up via WDT or Interrupt = uuuu uuuu. TBLPTRL, Applicable Devices = 1220. TBLPTRL, Applicable Devices = 1320. TBLPTRL, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRL, Wake-up via WDT or Interrupt = uuuu uuuu. TABLAT, Applicable Devices = 1220. TABLAT, Applicable Devices = 1320. TABLAT, Power-on Reset, Brown-out Reset = 0000 0000. TABLAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TABLAT, Wake-up via WDT or Interrupt = uuuu uuuu. PRODH, Applicable Devices = 1220. PRODH, Applicable Devices = 1320. PRODH, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODH, MCLR Resets WDT Reset RESET Instruction",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nStack Resets = uuuu uuuu. PRODH, Wake-up via WDT or Interrupt = uuuu uuuu. PRODL, Applicable Devices = 1220. PRODL, Applicable Devices = 1320. PRODL, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODL, Wake-up via WDT or Interrupt = uuuu uuuu. INTCON, Applicable Devices = 1220. INTCON, Applicable Devices = 1320. INTCON, Power-on Reset, Brown-out Reset = 0000 000x. INTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000u. INTCON, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON2, Applicable Devices = 1220. INTCON2, Applicable Devices = 1320. INTCON2, Power-on Reset, Brown-out Reset = 1111 -1-1. INTCON2, MCLR",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nResets WDT Reset RESET Instruction Stack Resets = 1111 -1-1. INTCON2, Wake-up via WDT or Interrupt = uuuu -u-u (1). INTCON3, Applicable Devices = 1220. INTCON3, Applicable Devices = 1320. INTCON3, Power-on Reset, Brown-out Reset = 11-0 0-00. INTCON3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 11-0 0-00. INTCON3, Wake-up via WDT or Interrupt = uu-u u-uu (1). INDF0, Applicable Devices = 1220. INDF0, Applicable Devices = 1320. INDF0, Power-on Reset, Brown-out Reset = N/A. INDF0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF0, Wake-up via WDT or Interrupt = N/A. POSTINC0, Applicable Devices = 1220. POSTINC0, Applicable Devices = 1320. POSTINC0, Power-on Reset, Brown-out Reset",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n= N/A. POSTINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC0, Wake-up via WDT or Interrupt = N/A. POSTDEC0, Applicable Devices = 1220. POSTDEC0, Applicable Devices = 1320. POSTDEC0, Power-on Reset, Brown-out Reset = N/A. POSTDEC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC0, Wake-up via WDT or Interrupt = N/A. PREINC0, Applicable Devices = 1220. PREINC0, Applicable Devices = 1320. PREINC0, Power-on Reset, Brown-out Reset = N/A. PREINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC0, Wake-up via WDT or Interrupt = N/A. PLUSW0, Applicable Devices = 1220. PLUSW0, Applicable Devices = 1320. PLUSW0, Power-on Reset, Brown-out Reset = N/A.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPLUSW0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW0, Wake-up via WDT or Interrupt = N/A. FSR0H, Applicable Devices = 1220. FSR0H, Applicable Devices = 1320. FSR0H, Power-on Reset, Brown-out Reset = ---- 0000. FSR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. FSR0H, Wake-up via WDT or Interrupt = ---- uuuu. FSR0L, Applicable Devices = 1220. FSR0L, Applicable Devices = 1320. FSR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR0L, Wake-up via WDT or Interrupt = uuuu uuuu. WREG, Applicable Devices = 1220. WREG, Applicable Devices = 1320. WREG,",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPower-on Reset, Brown-out Reset = xxxx xxxx. WREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. WREG, Wake-up via WDT or Interrupt = uuuu uuuu. INDF1, Applicable Devices = 1220. INDF1, Applicable Devices = 1320. INDF1, Power-on Reset, Brown-out Reset = N/A. INDF1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF1, Wake-up via WDT or Interrupt = N/A. POSTINC1, Applicable Devices = 1220. POSTINC1, Applicable Devices = 1320. POSTINC1, Power-on Reset, Brown-out Reset = N/A. POSTINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC1, Wake-up via WDT or Interrupt = N/A. POSTDEC1, Applicable Devices = 1220. POSTDEC1, Applicable Devices = 1320. POSTDEC1,",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPower-on Reset, Brown-out Reset = N/A. POSTDEC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC1, Wake-up via WDT or Interrupt = N/A. PREINC1, Applicable Devices = 1220. PREINC1, Applicable Devices = 1320. PREINC1, Power-on Reset, Brown-out Reset = N/A. PREINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC1, Wake-up via WDT or Interrupt = N/A. PLUSW1, Applicable Devices = 1220. PLUSW1, Applicable Devices = 1320. PLUSW1, Power-on Reset, Brown-out Reset = N/A. PLUSW1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW1, Wake-up via WDT or Interrupt = N/A. FSR1H, Applicable Devices = 1220. FSR1H, Applicable Devices = 1320. FSR1H, Power-on Reset,",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nBrown-out Reset = ---- 0000. FSR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. FSR1H, Wake-up via WDT or Interrupt = ---- uuuu. FSR1L, Applicable Devices = 1220. FSR1L, Applicable Devices = 1320. FSR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR1L, Wake-up via WDT or Interrupt = uuuu uuuu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-2 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the Oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: Bit 5 of PORTA is enabled if MCLR is disabled.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBSR, Applicable Devices = 1220. BSR, Applicable Devices = 1320. BSR, Power-on Reset, Brown-out Reset = ---- 0000. BSR, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. BSR, Wake-up via WDT or Interrupt = ---- uuuu. INDF2, Applicable Devices = 1220. INDF2, Applicable Devices = 1320. INDF2, Power-on Reset, Brown-out Reset = N/A. INDF2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF2, Wake-up via WDT or Interrupt = N/A. POSTINC2, Applicable Devices = 1220. POSTINC2, Applicable Devices = 1320. POSTINC2, Power-on Reset, Brown-out Reset = N/A. POSTINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC2, Wake-up via WDT or Interrupt = N/A.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPOSTDEC2, Applicable Devices = 1220. POSTDEC2, Applicable Devices = 1320. POSTDEC2, Power-on Reset, Brown-out Reset = N/A. POSTDEC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC2, Wake-up via WDT or Interrupt = N/A. PREINC2, Applicable Devices = 1220. PREINC2, Applicable Devices = 1320. PREINC2, Power-on Reset, Brown-out Reset = N/A. PREINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC2, Wake-up via WDT or Interrupt = N/A. PLUSW2, Applicable Devices = 1220. PLUSW2, Applicable Devices = 1320. PLUSW2, Power-on Reset, Brown-out Reset = N/A. PLUSW2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW2, Wake-up via WDT or Interrupt = N/A.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFSR2H, Applicable Devices = 1220. FSR2H, Applicable Devices = 1320. FSR2H, Power-on Reset, Brown-out Reset = ---- 0000. FSR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. FSR2H, Wake-up via WDT or Interrupt = ---- uuuu. FSR2L, Applicable Devices = 1220. FSR2L, Applicable Devices = 1320. FSR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR2L, Wake-up via WDT or Interrupt = uuuu uuuu. STATUS, Applicable Devices = 1220. STATUS, Applicable Devices = 1320. STATUS, Power-on Reset, Brown-out Reset = ---x xxxx. STATUS, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---u",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. STATUS, Wake-up via WDT or Interrupt = ---u uuuu. TMR0H, Applicable Devices = 1220. TMR0H, Applicable Devices = 1320. TMR0H, Power-on Reset, Brown-out Reset = 0000 0000. TMR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TMR0H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR0L, Applicable Devices = 1220. TMR0L, Applicable Devices = 1320. TMR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0L, Wake-up via WDT or Interrupt = uuuu uuuu. T0CON, Applicable Devices = 1220. T0CON, Applicable Devices = 1320. T0CON, Power-on",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset = 1111 1111. T0CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. T0CON, Wake-up via WDT or Interrupt = uuuu uuuu. OSCCON, Applicable Devices = 1220. OSCCON, Applicable Devices = 1320. OSCCON, Power-on Reset, Brown-out Reset = 0000 q000. OSCCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 q000. OSCCON, Wake-up via WDT or Interrupt = uuuu qquu. LVDCON, Applicable Devices = 1220. LVDCON, Applicable Devices = 1320. LVDCON, Power-on Reset, Brown-out Reset = --00 0101. LVDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0101. LVDCON, Wake-up via WDT or Interrupt = --uu uuuu. WDTCON, Applicable Devices = 1220. WDTCON, Applicable Devices =",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n1320. WDTCON, Power-on Reset, Brown-out Reset = ---- ---0. WDTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- ---0. WDTCON, Wake-up via WDT or Interrupt = ---- ---u. RCON (4), Applicable Devices = 1220. RCON (4), Applicable Devices = 1320. RCON (4), Power-on Reset, Brown-out Reset = 0--1 11q0. RCON (4), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0--q qquu. RCON (4), Wake-up via WDT or Interrupt = u--u qquu. TMR1H, Applicable Devices = 1220. TMR1H, Applicable Devices = 1320. TMR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. TMR1H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR1L, Applicable Devices = 1220. TMR1L, Applicable Devices = 1320. TMR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1L, Wake-up via WDT or Interrupt = uuuu uuuu. T1CON, Applicable Devices = 1220. T1CON, Applicable Devices = 1320. T1CON, Power-on Reset, Brown-out Reset = 0000 0000. T1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = u0uu uuuu. T1CON, Wake-up via WDT or Interrupt = uuuu uuuu. TMR2, Applicable Devices = 1220. TMR2, Applicable Devices = 1320. TMR2,",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = 0000 0000. TMR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TMR2, Wake-up via WDT or Interrupt = uuuu uuuu. PR2, Applicable Devices = 1220. PR2, Applicable Devices = 1320. PR2, Power-on Reset, Brown-out Reset = 1111 1111. PR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. PR2, Wake-up via WDT or Interrupt = 1111 1111. T2CON, Applicable Devices = 1220. T2CON, Applicable Devices = 1320. T2CON, Power-on Reset, Brown-out Reset = -000 0000. T2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. T2CON, Wake-up via WDT or Interrupt = -uuu uuuu. ADRESH, Applicable Devices = 1220. ADRESH, Applicable Devices = 1320. ADRESH, Power-on",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset = xxxx xxxx. ADRESH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. ADRESH, Wake-up via WDT or Interrupt = uuuu uuuu. ADRESL, Applicable Devices = 1220. ADRESL, Applicable Devices = 1320. ADRESL, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. ADRESL, Wake-up via WDT or Interrupt = uuuu uuuu. ADCON0, Applicable Devices = 1220. ADCON0, Applicable Devices = 1320. ADCON0, Power-on Reset, Brown-out Reset = 00-0 0000. ADCON0, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-0 0000. ADCON0, Wake-up via WDT or Interrupt = uu-u uuuu. ADCON1, Applicable Devices = 1220.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADCON1, Applicable Devices = 1320. ADCON1, Power-on Reset, Brown-out Reset = -000 0000. ADCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. ADCON1, Wake-up via WDT or Interrupt = -uuu uuuu. ADCON2, Applicable Devices = 1220. ADCON2, Applicable Devices = 1320. ADCON2, Power-on Reset, Brown-out Reset = 0-00 0000. ADCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0-00 0000. ADCON2, Wake-up via WDT or Interrupt = u-uu uuuu. CCPR1H, Applicable Devices = 1220. CCPR1H, Applicable Devices = 1320. CCPR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR1H, Wake-up via WDT or Interrupt =",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. CCPR1L, Applicable Devices = 1220. CCPR1L, Applicable Devices = 1320. CCPR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR1L, Wake-up via WDT or Interrupt = uuuu uuuu. CCP1CON, Applicable Devices = 1220. CCP1CON, Applicable Devices = 1320. CCP1CON, Power-on Reset, Brown-out Reset = 0000 0000. CCP1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. CCP1CON, Wake-up via WDT or Interrupt = uuuu uuuu. PWM1CON, Applicable Devices = 1220. PWM1CON, Applicable Devices = 1320. PWM1CON, Power-on Reset, Brown-out Reset = 0000 0000. PWM1CON, MCLR",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets WDT Reset RESET Instruction Stack Resets = 0000 0000. PWM1CON, Wake-up via WDT or Interrupt = uuuu uuuu. ECCPAS, Applicable Devices = 1220. ECCPAS, Applicable Devices = 1320. ECCPAS, Power-on Reset, Brown-out Reset = 0000 0000. ECCPAS, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. ECCPAS, Wake-up via WDT or Interrupt = uuuu uuuu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-2 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the Oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: Bit 5 of PORTA is enabled if MCLR is disabled.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR3H, Applicable Devices = 1220. TMR3H, Applicable Devices = 1320. TMR3H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR3H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR3L, Applicable Devices = 1220. TMR3L, Applicable Devices = 1320. TMR3L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR3L, Wake-up via WDT or Interrupt = uuuu uuuu. T3CON, Applicable Devices = 1220. T3CON, Applicable Devices = 1320. T3CON, Power-on Reset, Brown-out Reset = 0-00 0000. T3CON, MCLR Resets",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset RESET Instruction Stack Resets = u-uu uuuu. T3CON, Wake-up via WDT or Interrupt = u-uu uuuu. SPBRGH, Applicable Devices = 1220. SPBRGH, Applicable Devices = 1320. SPBRGH, Power-on Reset, Brown-out Reset = 0000 0000. SPBRGH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SPBRGH, Wake-up via WDT or Interrupt = uuuu uuuu. SPBRG, Applicable Devices = 1220. SPBRG, Applicable Devices = 1320. SPBRG, Power-on Reset, Brown-out Reset = 0000 0000. SPBRG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SPBRG, Wake-up via WDT or Interrupt = uuuu uuuu. RCREG, Applicable Devices = 1220. RCREG, Applicable Devices = 1320. RCREG, Power-on Reset, Brown-out Reset = 0000",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000. RCREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. RCREG, Wake-up via WDT or Interrupt = uuuu uuuu. TXREG, Applicable Devices = 1220. TXREG, Applicable Devices = 1320. TXREG, Power-on Reset, Brown-out Reset = 0000 0000. TXREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TXREG, Wake-up via WDT or Interrupt = uuuu uuuu. TXSTA, Applicable Devices = 1220. TXSTA, Applicable Devices = 1320. TXSTA, Power-on Reset, Brown-out Reset = 0000 0010. TXSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0010. TXSTA, Wake-up via WDT or Interrupt = uuuu uuuu. RCSTA, Applicable Devices = 1220. RCSTA, Applicable Devices = 1320. RCSTA, Power-on Reset, Brown-out Reset = 0000",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n000x. RCSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000x. RCSTA, Wake-up via WDT or Interrupt = uuuu uuuu. BAUDCTL, Applicable Devices = 1220. BAUDCTL, Applicable Devices = 1320. BAUDCTL, Power-on Reset, Brown-out Reset = -1-1 0-00. BAUDCTL, MCLR Resets WDT Reset RESET Instruction Stack Resets = -1-1 0-00. BAUDCTL, Wake-up via WDT or Interrupt = -u-u u-uu. EEADR, Applicable Devices = 1220. EEADR, Applicable Devices = 1320. EEADR, Power-on Reset, Brown-out Reset = 0000 0000. EEADR, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. EEADR, Wake-up via WDT or Interrupt = uuuu uuuu. EEDATA, Applicable Devices = 1220. EEDATA, Applicable Devices = 1320.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nEEDATA, Power-on Reset, Brown-out Reset = 0000 0000. EEDATA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. EEDATA, Wake-up via WDT or Interrupt = uuuu uuuu. EECON2, Applicable Devices = 1220. EECON2, Applicable Devices = 1320. EECON2, Power-on Reset, Brown-out Reset = 0000 0000. EECON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. EECON2, Wake-up via WDT or Interrupt = 0000 0000. EECON1, Applicable Devices = 1220. EECON1, Applicable Devices = 1320. EECON1, Power-on Reset, Brown-out Reset = xx-0 x000. EECON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = uu-0 u000. EECON1, Wake-up via WDT or Interrupt = uu-0 u000. IPR2, Applicable Devices = 1220.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nIPR2, Applicable Devices = 1320. IPR2, Power-on Reset, Brown-out Reset = 1--1 -11-. IPR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1--1 -11-. IPR2, Wake-up via WDT or Interrupt = u--u -uu-. PIR2, Applicable Devices = 1220. PIR2, Applicable Devices = 1320. PIR2, Power-on Reset, Brown-out Reset = 0--0 -00-. PIR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0--0 -00-. PIR2, Wake-up via WDT or Interrupt = u--u -uu- (1). PIE2, Applicable Devices = 1220. PIE2, Applicable Devices = 1320. PIE2, Power-on Reset, Brown-out Reset = 0--0 -00-. PIE2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0--0 -00-. PIE2, Wake-up via",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = u--u -uu-. IPR1, Applicable Devices = 1220. IPR1, Applicable Devices = 1320. IPR1, Power-on Reset, Brown-out Reset = -111 -111. IPR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -111 -111. IPR1, Wake-up via WDT or Interrupt = -uuu -uuu. PIR1, Applicable Devices = 1220. PIR1, Applicable Devices = 1320. PIR1, Power-on Reset, Brown-out Reset = -000 -000. PIR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 -000. PIR1, Wake-up via WDT or Interrupt = -uuu -uuu (1). PIE1, Applicable Devices = 1220. PIE1, Applicable Devices = 1320. PIE1, Power-on Reset, Brown-out Reset = -000 -000. PIE1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 -000.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIE1, Wake-up via WDT or Interrupt = -uuu -uuu. OSCTUNE, Applicable Devices = 1220. OSCTUNE, Applicable Devices = 1320. OSCTUNE, Power-on Reset, Brown-out Reset = --00 0000. OSCTUNE, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. OSCTUNE, Wake-up via WDT or Interrupt = --uu uuuu. TRISB, Applicable Devices = 1220. TRISB, Applicable Devices = 1320. TRISB, Power-on Reset, Brown-out Reset = 1111 1111. TRISB, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISB, Wake-up via WDT or Interrupt = uuuu uuuu. TRISA (5), Applicable Devices = 1220. TRISA (5), Applicable Devices = 1320. TRISA (5), Power-on Reset, Brown-out Reset = 11-1 1111 (5). TRISA (5), MCLR",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets WDT Reset RESET Instruction Stack Resets = 11-1 1111 (5). TRISA (5), Wake-up via WDT or Interrupt = uu-u uuuu (5). LATB, Applicable Devices = 1220. LATB, Applicable Devices = 1320. LATB, Power-on Reset, Brown-out Reset = xxxx xxxx. LATB, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATB, Wake-up via WDT or Interrupt = uuuu uuuu. LATA (5), Applicable Devices = 1220. LATA (5), Applicable Devices = 1320. LATA (5), Power-on Reset, Brown-out Reset = xx-x xxxx (5). LATA (5), MCLR Resets WDT Reset RESET Instruction Stack Resets = uu-u uuuu (5). LATA (5), Wake-up via WDT or Interrupt = uu-u uuuu (5).",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPORTB, Applicable Devices = 1220. PORTB, Applicable Devices = 1320. PORTB, Power-on Reset, Brown-out Reset = xxxx xxxx. PORTB, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PORTB, Wake-up via WDT or Interrupt = uuuu uuuu. PORTA (5,6), Applicable Devices = 1220. PORTA (5,6), Applicable Devices = 1320. PORTA (5,6), Power-on Reset, Brown-out Reset = xx0x 0000 (5,6). PORTA (5,6), MCLR Resets WDT Reset RESET Instruction Stack Resets = uu0u 0000 (5,6). PORTA (5,6), Wake-up via WDT or Interrupt = uuuu uuuu (5,6)\nLegend:",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-2 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled, depending on the Oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: Bit 5 of PORTA is enabled if MCLR is disabled.",
    "FIGURE 4-3: TIME-OUT SEQUENCE ON POWER-UP (MCLR TIED TO VDD, VDD RISE < TPWRT)\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET",
    "FIGURE 4-4: TIME-OUT SEQUENCE ON POWER-UP (MCLR NOT TIED TO VDD): CASE 1\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET",
    "FIGURE 4-5: TIME-OUT SEQUENCE ON POWER-UP (MCLR NOT TIED TO VDD): CASE 2\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET\nTPWRT\nTOST",
    "FIGURE 4-7: TIME-OUT SEQUENCE ON POR W/PLL ENABLED (MCLR TIED TO VDD)\nNote:\nTOST = 1024 clock cycles.\nTPLL \uf0bb 2 ms max. First three stages of the PWRT timer.",
    "5.0 MEMORY ORGANIZATION\nThere  are  three  memory  types  in  Enhanced  MCU devices. These memory types are:\n\u00b7 Program Memory\n\u00b7 Data RAM\n\u00b7 Data EEPROM\nData  and  program  memory  use  separate  busses, which allows for concurrent access of these types.\nAdditional detailed information for Flash program memory  and  data  EEPROM  is  provided  in Section 6.0 'Flash  Program  Memory' and Section 7.0  'Data EEPROM Memory' , respectively.\nFIGURE 5-1: PROGRAM MEMORY MAP AND STACK FOR PIC18F1220",
    "5.1 Program Memory Organization\nA 21-bit program counter is capable of addressing the 2-Mbyte program memory space. Accessing a location between the physically implemented memory and the 2-Mbyte address will cause a read of all ' 0 's  (a NOP instruction).\nThe PIC18F1220 has 4 Kbytes of Flash memory and can store up to 2,048 single-word instructions.\nThe PIC18F1320 has 8 Kbytes of Flash memory and can store up to 4,096 single-word instructions.\nThe Reset vector address is at 0000h and the interrupt vector addresses are at 0008h and 0018h.\nThe program memory maps for the PIC18F1220 and PIC18F1320  devices  are  shown  in  Figure 5-1  and Figure 5-2, respectively.",
    "FIGURE 5-2:\nPROGRAM MEMORY MAP AND STACK FOR PIC18F1320",
    "5.2 Return Address Stack\nThe return address stack allows any combination of up to  31  program  calls  and  interrupts  to  occur.  The  PC (Program Counter) is pushed onto the stack when a CALL or RCALL instruction is executed, or an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN RETLW , or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit Stack Pointer, with the Stack Pointer initialized to 00000B after all Resets. There is no RAM associated with Stack Pointer, 00000B . This is only a Reset value. During a CALL type instruction, causing a push onto the stack,  the  Stack  Pointer  is  first  incremented  and  the RAM  location pointed to by the Stack Pointer (STKPTR) register is written with the contents of the PC  (already  pointing  to  the  instruction  following  the CALL) .  During  a RETURN type  instruction,  causing  a pop from the stack, the contents of the RAM location pointed to by the STKPTR are transferred to the PC and then the Stack Pointer is decremented.",
    "5.2 Return Address Stack\nThe stack space is not part of either program or data space. The Stack Pointer is readable and writable and the  address  on  the  top  of  the  stack  is  readable  and writable through the top-of-stack Special File Registers. Data can also be pushed to or popped from the stack using the top-of-stack SFRs. Status bits indicate if the stack is full, has overflowed or underflowed.",
    "5.2.1 TOP-OF-STACK ACCESS\nThe top of the stack is  readable  and writable. Three register  locations,  TOSU, TOSH and TOSL, hold the contents  of  the stack  location pointed  to by  the STKPTR  register  (Figure 5-3).  This  allows  users  to implement a software stack if necessary. After a CALL , RCALL or interrupt, the software can read the pushed value by reading the TOSU, TOSH and TOSL registers. These values can be placed on a user defined software stack.  At  return  time,  the  software  can  replace  the TOSU, TOSH and TOSL and do a return.",
    "5.2.2 RETURN STACK POINTER (STKPTR)\nThe STKPTR register (Register 5-1) contains the Stack Pointer value, the STKFUL (Stack Full) Status bit and the STKUNF (Stack Underflow) Status bits. The value of  the  Stack Pointer can be 0 through 31. The Stack Pointer increments before values are pushed onto the stack and decrements after values are popped off the stack. At Reset, the Stack Pointer value will be zero. The user may read and write the Stack Pointer value. This  feature  can  be  used  by  a  Real-Time  Operating System for return stack maintenance.\nAfter the PC is pushed onto the stack 31 times (without popping any values off the stack), the STKFUL bit is set.  The  STKFUL  bit  is  cleared  by  software  or  by  a POR.",
    "5.2.2 RETURN STACK POINTER (STKPTR)\nThe action that takes place when the stack becomes full depends on the state of the STVR (Stack Overflow Reset Enable) Configuration bit. (Refer to Section 19.1 'Configuration Bits' for a description of the device Configuration bits.) If STVR is set (default), the  31st  push  will  push  the  (PC  +  2)  value  onto  the stack,  set the  STKFUL bit and reset the device. The STKFUL bit will remain set and the Stack Pointer will be set to zero.\nIf STVR is cleared, the STKFUL bit will be set on the 31st push and the Stack Pointer will increment to 31. Any additional pushes will not overwrite the 31st push and STKPTR will remain at 31.\nWhen  the  stack  has  been  popped  enough  times  to unload the stack, the next pop will return a value of zero to  the  PC  and sets the STKUNF bit, while the Stack Pointer remains at zero. The STKUNF bit will remain set until cleared by software or a POR occurs.",
    "Note:\nThe user must disable the Global Interrupt Enable bits while accessing the stack to prevent inadvertent stack corruption.\nReturning a value of zero to the PC on an underflow has the effect of vectoring the program  to  the  Reset  vector,  where  the stack conditions can be verified and appropriate actions can be taken. This is not the same as a Reset, as the contents of the SFRs are not affected.",
    "REGISTER 5-1: STKPTR: STACK POINTER REGISTER\nSTKFUL (1), R/C-0/0 = STKUNF (1). STKFUL (1), U-0 = -. STKFUL (1), R/W-0/0 = . STKFUL (1), R/W-0/0 = . STKFUL (1), R/W-0/0 = SP<4:0>. STKFUL (1), R/W-0/0 = . STKFUL (1), R/W-0/0 = . bit 7, R/C-0/0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 7. bit 7, R/W-0/0 = bit 0",
    "REGISTER 5-1: STKPTR: STACK POINTER REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = C = Clearable only bit\nSTKFUL: Stack Full Flag bit (1)\nbit 7\n1 = Stack became full or overflowed\n0 = Stack has not become full or overflowed\nbit 6\nSTKUNF: Stack Underflow Flag bit\n(1)\n1 = Stack Underflow occurred\n0 = Stack Underflow did not occur\nbit 5\nUnimplemented: Read as ' 0 '\nbit 4-0\nSP<4:0>: Stack Pointer Location bits\nNote 1: Bit 7 and bit 6 are cleared by user software or by a POR.",
    "5.2.4 STACK FULL/UNDERFLOW RESETS\nSince the Top-of-Stack (TOS) is readable and writable, the ability to push values onto the stack and pull values off the stack, without disturbing normal program execution, is a desirable option. To push the current PC value onto  the  stack,  a PUSH instruction  can  be  executed. This will increment the Stack Pointer and load the current PC value onto the stack. TOSU, TOSH and TOSL can then be modified to place data or a return address on the stack.\nThe ability to pull the TOS value off of the stack and replace  it  with  the  value  that  was  previously  pushed onto the stack, without disturbing normal execution, is achieved by using the POP instruction. The POP instruction  discards  the  current  TOS  by  decrementing  the Stack  Pointer.  The  previous  value  pushed  onto  the stack then becomes the TOS value.",
    "5.2.4 STACK FULL/UNDERFLOW RESETS\nThese Resets are enabled by programming the STVR bit in Configuration Register 4L. When the STVR bit is cleared, a full or underflow condition will set the appropriate STKFUL or STKUNF bit, but not cause a device Reset. When the STVR bit is set, a full or underflow condition will set the appropriate STKFUL or STKUNF bit  and  then  cause  a  device  Reset.  The  STKFUL  or STKUNF bits  are  cleared  by  the  user  software  or  a Power-on Reset.",
    "5.3 Fast Register Stack\nA 'fast return' option is available for interrupts. A fast register  stack  is  provided  for  the  Status,  WREG  and BSR registers and is only one in depth. The stack is not readable  or  writable  and  is  loaded  with  the  current value of the corresponding register when the processor vectors for an interrupt. The values in the registers are then  loaded  back  into  the  working  registers,  if  the RETFIE, FAST instruction is used to return from the interrupt.\nAll  interrupt  sources  will  push  values  into  the  stack registers.  If  both  low  and  high  priority  interrupts  are enabled, the stack registers cannot be used reliably to return from low priority interrupts. If a high priority interrupt occurs while servicing a low priority interrupt, the stack register values stored by the low priority interrupt will be overwritten. Users must save the key registers in software during a low priority interrupt.\nIf interrupt priority is not used, all interrupts may use the fast register stack for returns from interrupt.",
    "5.3 Fast Register Stack\nIf no interrupts are used, the fast register stack can be used to restore the Status, WREG and BSR registers at the end of a subroutine call. To use the fast register stack  for  a  subroutine  call,  a CALL LABEL, FAST instruction must  be  executed  to  save  the  Status, WREG and BSR registers to the fast register stack. A RETURN, FAST instruction is then executed to restore these registers from the fast register stack.\nExample 5-1 shows a source code example that uses the  fast  register  stack  during  a  subroutine  call  and return.",
    "EXAMPLE 5-1: FAST REGISTER STACK CODE EXAMPLE\nCALL SUB1, FAST, 1 = ;STATUS, WREG, BSR ;SAVED IN FAST REGISTER ;STACK. SUB1 \uf0b7 \uf0b7, 1 = . RETURN, FAST, 1 = ;RESTORE VALUES SAVED ;IN FAST REGISTER STACK",
    "5.4 PCL, PCLATH and PCLATU\nThe Program Counter (PC) specifies the address of the instruction  to  fetch  for  execution.  The  PC  is  21  bits wide. The low byte, known as the PCL register, is both readable and writable. The high byte, or PCH register, contains the PC<15:8> bits and is not directly readable or writable. Updates to the PCH register may be performed through the PCLATH register. The upper byte is called PCU. This register contains the PC<20:16> bits and is not directly readable or writable. Updates to the PCU register may be performed through the PCLATU register.\nThe contents of PCLATH  and  PCLATU  will be transferred  to  the  program  counter  by  any  operation that writes PCL. Similarly, the upper two bytes of the program  counter  will  be  transferred  to  PCLATH  and PCLATU by an operation that reads PCL. This is useful for  computed  offsets  to  the  PC  (see Section 5.8.1 'Computed GOTO' ).",
    "5.4 PCL, PCLATH and PCLATU\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the LSB of PCL is fixed to a value of ' 0 '. The  PC  increments  by  two  to  address  sequential instructions in the program memory.\nThe CALL RCALL , , GOTO and program branch instructions write to the program counter directly. For these instructions, the contents of PCLATH and PCLATU are not transferred to the program counter.",
    "5.5 Clocking Scheme/Instruction Cycle\nThe clock  input  (from  OSC1)  is  internally  divided  by four to generate four non-overlapping quadrature clocks,  namely  Q1,  Q2,  Q3  and  Q4.  Internally,  the Program Counter (PC) is incremented every Q1, the instruction  is  fetched  from  the  program  memory  and latched into the instruction register in Q4. The instruction is decoded and executed during the following Q1 through Q4. The clocks and instruction execution flow are shown in Figure 5-4.",
    "5.6 Instruction Flow/Pipelining\nAn 'Instruction Cycle'  consists  of  four  Q  cycles  (Q1, Q2, Q3 and Q4). The instruction fetch and execute are pipelined such that  fetch takes  one instruction cycle, while  decode  and  execute  takes  another  instruction cycle. However, due to the pipelining, each instruction effectively  executes  in  one  cycle.  If  an  instruction causes the  program counter to  change (e.g., GOTO ), then two cycles are required to complete the instruction (Example 5-2).\nA fetch cycle begins with the Program Counter (PC) incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched into  the  'Instruction  Register'  (IR)  in  cycle  Q1.  This instruction  is  then  decoded  and  executed  during  the Q2, Q3 and Q4 cycles. Data memory is read during Q2 (operand  read)  and  written  during  Q4  (destination write).",
    "EXAMPLE 5-2: INSTRUCTION PIPELINE FLOW\nAll instructions are single cycle, except for any program branches. These take two cycles, since the fetch instruction is 'flushed' from the pipeline, while the new instruction is being fetched and then executed.",
    "5.7 Instructions in Program Memory\nThe program memory is addressed in bytes. Instructions are stored as two bytes or four bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSB = 0 ). Figure 5-5 shows an example of how instruction words are stored in the program memory. To maintain alignment with instruction boundaries, the PC increments in steps of 2 and the LSB  will  always  read  ' 0 ' (see Section 5.4  'PCL, PCLATH and PCLATU' ).",
    "5.7 Instructions in Program Memory\nThe CALL and GOTO instructions  have  the  absolute program memory address embedded into the instruction.  Since  instructions  are  always  stored  on  word boundaries, the data contained in the instruction is a word address. The word address is written to PC<20:1>, which accesses the desired byte address in program memory. Instruction #2 in  Figure 5-5  shows how the instruction ' GOTO 000006h ' is encoded in the program memory. Program branch instructions, which encode a relative address offset, operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions that the PC will be offset by. Section 20.0 'Instruction Set Summary' provides  further  details  of  the  instruction set.",
    "FIGURE 5-5: INSTRUCTIONS IN PROGRAM MEMORY\nProgram Memory\nByte Locations\n\uf0ae\uf020\nInstruction 1:\nInstruction 2:\nMOVLW\n055h\nGOTO\n000006h\nInstruction 3:\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address \uf0af. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. EFh, 1 = 03h. EFh, 2 = 00000Ah. F0h, 1 = 00h. F0h, 2 = 00000Ch. C1h, 1 = 23h. C1h, 2 = 00000Eh. F4h, 1 = 56h. F4h, 2 = 000010h. , 1 = . , 2 = 000012h. , 1 = . , 2 = 000014h\nMOVFF\n123h, 456h",
    "5.7.1 TWO-WORD INSTRUCTIONS\nPIC18F1220/1320 devices have four two-word instructions: MOVFF CALL GOTO , , and LFSR . The second word of these instructions has the 4 MSBs set to ' 1 's and is decoded as a NOP instruction. The lower 12 bits of the second word contain data to be used by the instruction. If the first word of the instruction is executed, the data in the second word is accessed. If the second word of the instruction is executed by itself (first word was skipped), it will execute as a NOP . This action is necessary when the  two-word  instruction  is  preceded  by  a  conditional instruction  that  results  in  a  skip  operation.  A  program example  that  demonstrates  this  concept  is  shown  in Example 5-3.  Refer  to Section 20.0  'Instruction  Set Summary' for further details of the instruction set.",
    "EXAMPLE 5-3: TWO-WORD INSTRUCTIONS\n0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ; is RAM location 0?. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:.Source Code = ; No, skip this word. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = .",
    "EXAMPLE 5-3: TWO-WORD INSTRUCTIONS\n1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; Execute this word as a NOP. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ; continue code. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Object",
    "EXAMPLE 5-3: TWO-WORD INSTRUCTIONS\nCode = Object Code. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. 0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ; is RAM location 0?. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:.Source Code =",
    "EXAMPLE 5-3: TWO-WORD INSTRUCTIONS\n; Yes, execute this word. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; 2nd word of instruction. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ; continue code",
    "5.8 Look-up Tables\nLook-up tables are implemented two ways:\n\u00b7 Computed GOTO\n\u00b7 Table Reads",
    "5.8.1 COMPUTED GOTO\nA computed GOTO is accomplished by adding an offset to the program counter (see Example 5-4).\nA look-up table can be formed  with an ADDWF  PCL instruction and a group of RETLW  0xnn instructions. WREG is loaded with an offset into the  table  before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction executed will be one of the RETLW  0xnn instructions, that returns the value 0xnn to the calling function.\nThe offset  value  (in  WREG)  specifies  the  number  of bytes  that  the  program  counter  should  advance  and should be multiples of 2 (LSB = 0 ).\nIn  this  method,  only  one  data  byte  may  be  stored  in each  instruction  location  and  room  on  the  return address stack is required.",
    "AN OFFSET VALUE\n, 1 = MOVFW CALL. , 2 = OFFSET TABLE. ORG, 1 = 0xnn00. ORG, 2 = . TABLE, 1 = ADDWF. TABLE, 2 = PCL. TABLE, 1 = RETLW. TABLE, 2 = 0xnn. TABLE, 1 = RETLW. TABLE, 2 = 0xnn. TABLE, 1 = RETLW. TABLE, 2 = 0xnn. TABLE, 1 = .. TABLE, 2 = . TABLE, 1 = .. TABLE, 2 = . TABLE, 1 = .. TABLE, 2 = ",
    "5.8.2 TABLE READS/TABLE WRITES\nA  better  method  of  storing  data  in  program  memory allows two bytes of data to be stored in each instruction location.\nLook-up table data may be stored two bytes per program word by using table reads and writes. The Table Pointer (TBLPTR) register specifies the byte address and  the  Table  Latch  (TABLAT)  register  contains  the data that is read from or written to program memory. Data is transferred to/from program memory, one byte at a time.\nThe  table  read/table  write operation  is discussed further in Section 6.1 'Table Reads  and  Table Writes' .",
    "5.9 Data Memory Organization\nThe data memory is implemented as static RAM. Each register  in  the  data  memory  has  a  12-bit  address, allowing up to 4096 bytes of data memory. Figure 5-6 shows the data memory organization for the PIC18F1220/1320 devices.\nThe  data  memory  map  is  divided  into  as  many  as 16 banks that contain 256 bytes each. The lower four bits  of  the  Bank  Select  Register  (BSR<3:0>)  select which bank will be accessed. The upper four bits for the BSR are not implemented.\nThe data memory contains Special Function Registers (SFR)  and  General  Purpose  Registers  (GPR).  The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratch pad operations in the user's application. The SFRs start at the last location of Bank 15 (FFFh) and extend towards F80h. Any remaining space beyond the SFRs in the Bank may be implemented as GPRs. GPRs start at the first location of Bank 0 and grow upwards. Any read of an unimplemented location will read as ' 0 's.",
    "5.9 Data Memory Organization\nThe entire data memory may be accessed directly or indirectly. Direct addressing may require the use of the BSR register. Indirect addressing requires the use of a File Select Register (FSRn) and a corresponding Indirect  File  Operand (INDFn). Each FSR holds a 12-bit address value that can be used to access any location in the Data Memory  map  without banking. See Section 5.12  'Indirect  Addressing, INDF  and  FSR Registers' for indirect addressing details.\nThe instruction  set  and  architecture  allow  operations across all banks. This may be accomplished by indirect addressing or by the use of the MOVFF instruction. The MOVFF instruction  is  a  two-word/two-cycle  instruction that moves a value from one register to another.\nTo  ensure  that  commonly  used  registers  (SFRs  and select  GPRs)  can  be  accessed  in  a  single  cycle, regardless of the current BSR values, an Access Bank is implemented. A segment of Bank 0 and a segment of Bank  15  comprise  the  Access  RAM. Section 5.10 'Access Bank' provides a detailed description of the Access RAM.",
    "5.9.1 GENERAL PURPOSE REGISTER FILE\nEnhanced MCU devices may have banked memory in the GPR area. GPRs are not initialized by a Power-on Reset and are unchanged on all other Resets.\nData RAM is available for use as GPR registers by all instructions.  The  second  half  of  Bank  15  (F80h  to FFFh) contains SFRs. All other banks of data memory contain GPRs, starting with Bank 0.",
    "5.9.2 SPECIAL FUNCTION REGISTERS\nThe Special Function  Registers (SFRs) are registers used by the CPU and peripheral modules for controlling the desired operation of the device. These registers are implemented as static RAM. A list of these registers is given in Table 5-1 and Table 5-2.\nThe SFRs can be classified into two sets: those associated with the 'core' function and those related to the peripheral  functions.  Those  registers  related  to  the 'core' are described in this section, while those related to the operation of the peripheral features are described in the section of that peripheral feature.\nThe SFRs are typically distributed among the peripherals whose functions they control.\nThe unused SFR locations will be unimplemented and read as ' 0 's.",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F1220/1320 DEVICES\nFFFh, Name = TOSU. FFFh, Address = FDFh. FFFh, Name = INDF2 (2). FFFh, Address = FBFh. FFFh, Name = CCPR1H. FFFh, Address = F9Fh. FFFh, Name = IPR1. FFEh, Name = TOSH. FFEh, Address = FDEh. FFEh, Name = POSTINC2 (2). FFEh, Address = FBEh. FFEh, Name = CCPR1L. FFEh, Address = F9Eh. FFEh, Name = PIR1. FFDh, Name = TOSL. FFDh, Address = FDDh. FFDh, Name = POSTDEC2 (2). FFDh, Address = FBDh. FFDh, Name = CCP1CON. FFDh, Address = F9Dh. FFDh, Name = PIE1. FFCh, Name = STKPTR. FFCh, Address = FDCh. FFCh, Name = PREINC2",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F1220/1320 DEVICES\n(2). FFCh, Address = FBCh. FFCh, Name = -. FFCh, Address = F9Ch. FFCh, Name = -. FFBh, Name = PCLATU. FFBh, Address = FDBh. FFBh, Name = PLUSW2 (2). FFBh, Address = FBBh. FFBh, Name = -. FFBh, Address = F9Bh. FFBh, Name = OSCTUNE. FFAh, Name = PCLATH. FFAh, Address = FDAh. FFAh, Name = FSR2H. FFAh, Address = FBAh. FFAh, Name = -. FFAh, Address = F9Ah. FFAh, Name = -. FF9h, Name = PCL. FF9h, Address = FD9h. FF9h, Name = FSR2L. FF9h, Address = FB9h. FF9h, Name = -. FF9h, Address = F99h. FF9h, Name = -. FF8h, Name =",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F1220/1320 DEVICES\nTBLPTRU. FF8h, Address = FD8h. FF8h, Name = STATUS. FF8h, Address = FB8h. FF8h, Name = -. FF8h, Address = F98h. FF8h, Name = -. FF7h, Name = TBLPTRH. FF7h, Address = FD7h. FF7h, Name = TMR0H. FF7h, Address = FB7h. FF7h, Name = PWM1CON. FF7h, Address = F97h. FF7h, Name = -. FF6h, Name = TBLPTRL. FF6h, Address = FD6h. FF6h, Name = TMR0L. FF6h, Address = FB6h. FF6h, Name = ECCPAS. FF6h, Address = F96h. FF6h, Name = -. FF5h, Name = TABLAT. FF5h, Address = FD5h. FF5h, Name",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F1220/1320 DEVICES\n= T0CON. FF5h, Address = FB5h. FF5h, Name = -. FF5h, Address = F95h. FF5h, Name = -. FF4h, Name = PRODH. FF4h, Address = FD4h. FF4h, Name = -. FF4h, Address = FB4h. FF4h, Name = -. FF4h, Address = F94h. FF4h, Name = -. FF3h, Name = PRODL. FF3h, Address = FD3h. FF3h, Name = OSCCON. FF3h, Address = FB3h. FF3h, Name = TMR3H. FF3h, Address = F93h. FF3h, Name = TRISB. FF2h, Name = INTCON. FF2h, Address = FD2h. FF2h, Name = LVDCON. FF2h, Address = FB2h. FF2h, Name = TMR3L.",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F1220/1320 DEVICES\nFF2h, Address = F92h. FF2h, Name = TRISA. FF1h, Name = INTCON2. FF1h, Address = FD1h. FF1h, Name = WDTCON. FF1h, Address = FB1h. FF1h, Name = T3CON. FF1h, Address = F91h. FF1h, Name = -. FF0h, Name = INTCON3. FF0h, Address = FD0h. FF0h, Name = RCON. FF0h, Address = FB0h. FF0h, Name = SPBRGH. FF0h, Address = F90h. FF0h, Name = -. FEFh, Name = INDF0 (2). FEFh, Address = FCFh. FEFh, Name = TMR1H. FEFh, Address = FAFh. FEFh, Name = SPBRG. FEFh, Address = F8Fh. FEFh, Name = -. FEEh,",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F1220/1320 DEVICES\nName = POSTINC0 (2). FEEh, Address = FCEh. FEEh, Name = TMR1L. FEEh, Address = FAEh. FEEh, Name = RCREG. FEEh, Address = F8Eh. FEEh, Name = -. FEDh, Name = POSTDEC0 (2). FEDh, Address = FCDh. FEDh, Name = T1CON. FEDh, Address = FADh. FEDh, Name = TXREG. FEDh, Address = F8Dh. FEDh, Name = -. FECh, Name = PREINC0 (2). FECh, Address = FCCh. FECh, Name = TMR2. FECh, Address = FACh. FECh, Name = TXSTA. FECh, Address = F8Ch. FECh, Name = -. FEBh, Name = PLUSW0 (2). FEBh, Address = FCBh. FEBh, Name = PR2. FEBh, Address = FABh. FEBh, Name = RCSTA. FEBh, Address =",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F1220/1320 DEVICES\nF8Bh. FEBh, Name = -. FEAh, Name = FSR0H. FEAh, Address = FCAh. FEAh, Name = T2CON. FEAh, Address = FAAh. FEAh, Name = BAUDCTL. FEAh, Address = F8Ah. FEAh, Name = LATB. FE9h, Name = FSR0L. FE9h, Address = FC9h. FE9h, Name = -. FE9h, Address = FA9h. FE9h, Name = EEADR. FE9h, Address = F89h. FE9h, Name = LATA. FE8h, Name = WREG. FE8h, Address = FC8h. FE8h, Name = -. FE8h, Address = FA8h. FE8h, Name = EEDATA. FE8h, Address = F88h. FE8h, Name = -. FE7h, Name = INDF1 (2). FE7h, Address = FC7h. FE7h, Name",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F1220/1320 DEVICES\n= -. FE7h, Address = FA7h. FE7h, Name = EECON2. FE7h, Address = F87h. FE7h, Name = -. FE6h, Name = POSTINC1 (2). FE6h, Address = FC6h. FE6h, Name = -. FE6h, Address = FA6h. FE6h, Name = EECON1. FE6h, Address = F86h. FE6h, Name = -. FE5h, Name = POSTDEC1 (2). FE5h, Address = FC5h. FE5h, Name = -. FE5h, Address = FA5h. FE5h, Name = -. FE5h, Address = F85h. FE5h, Name = -. FE4h, Name = PREINC1 (2). FE4h, Address = FC4h. FE4h, Name = ADRESH. FE4h, Address = FA4h. FE4h, Name = -. FE4h, Address =",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F1220/1320 DEVICES\nF84h. FE4h, Name = -. FE3h, Name = PLUSW1 (2). FE3h, Address = FC3h. FE3h, Name = ADRESL. FE3h, Address = FA3h. FE3h, Name = -. FE3h, Address = F83h. FE3h, Name = -. FE2h, Name = FSR1H. FE2h, Address = FC2h. FE2h, Name = ADCON0. FE2h, Address = FA2h. FE2h, Name = IPR2. FE2h, Address = F82h. FE2h, Name = -. FE1h, Name = FSR1L. FE1h, Address = FC1h. FE1h, Name = ADCON1. FE1h, Address = FA1h. FE1h, Name = PIR2. FE1h, Address = F81h. FE1h, Name = PORTB. FE0h, Name = BSR. FE0h,",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F1220/1320 DEVICES\nAddress = FC0h. FE0h, Name = ADCON2. FE0h, Address = FA0h. FE0h, Name = PIE2. FE0h, Address = F80h. FE0h, Name = PORTA\nNote 1: Unimplemented registers are read as ' 0\n'.\n2: This is not a physical register.",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nTOSU, Bit 7 = -. TOSU, Bit 6 = -. TOSU, Bit 5 = -. TOSU, Bit 4 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 3 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 2 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 1 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 0 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Value on POR, BOR = ---0 0000. TOSU, Details on Page: = 34, 40. TOSH, Bit 7 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 6 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 5 = Top-of-Stack High Byte (TOS<15:8>).",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nTOSH, Bit 4 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 3 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 2 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 1 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 0 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Value on POR, BOR = 0000 0000. TOSH, Details on Page: = 34, 40. TOSL, Bit 7 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 6 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 5 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 4 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\n3 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 2 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 1 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 0 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Value on POR, BOR = 0000 0000. TOSL, Details on Page: = 34, 40. STKPTR, Bit 7 = STKFUL. STKPTR, Bit 6 = STKUNF. STKPTR, Bit 5 = -. STKPTR, Bit 4 = Return Stack Pointer. STKPTR, Bit 3 = Return Stack Pointer. STKPTR, Bit 2 = Return Stack Pointer. STKPTR, Bit 1 = Return Stack Pointer. STKPTR, Bit 0 = Return Stack Pointer. STKPTR, Value on POR, BOR = 00-0 0000. STKPTR, Details on Page: =",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\n34, 41. PCLATU, Bit 7 = -. PCLATU, Bit 6 = -. PCLATU, Bit 5 = bit 21 (3). PCLATU, Bit 4 = Holding Register for PC<20:16>. PCLATU, Bit 3 = Holding Register for PC<20:16>. PCLATU, Bit 2 = Holding Register for PC<20:16>. PCLATU, Bit 1 = Holding Register for PC<20:16>. PCLATU, Bit 0 = Holding Register for PC<20:16>. PCLATU, Value on POR, BOR = ---0 0000. PCLATU, Details on Page: = 34, 42. PCLATH, Bit 7 = Holding Register for PC<15:8>. PCLATH, Bit 6 = Holding Register for PC<15:8>. PCLATH, Bit 5 = Holding Register for PC<15:8>. PCLATH, Bit 4 = Holding Register for PC<15:8>. PCLATH, Bit 3 = Holding Register for PC<15:8>.",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nPCLATH, Bit 2 = Holding Register for PC<15:8>. PCLATH, Bit 1 = Holding Register for PC<15:8>. PCLATH, Bit 0 = Holding Register for PC<15:8>. PCLATH, Value on POR, BOR = 0000 0000. PCLATH, Details on Page: = 34, 42. PCL, Bit 7 = PC Low Byte (PC<7:0>). PCL, Bit 6 = PC Low Byte (PC<7:0>). PCL, Bit 5 = PC Low Byte (PC<7:0>). PCL, Bit 4 = PC Low Byte (PC<7:0>). PCL, Bit 3 = PC Low Byte (PC<7:0>). PCL, Bit 2 = PC Low Byte (PC<7:0>). PCL, Bit 1 = PC Low Byte (PC<7:0>). PCL, Bit 0 = PC Low Byte (PC<7:0>). PCL, Value on POR, BOR = 0000",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\n0000. PCL, Details on Page: = 34, 42. TBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit 21. TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on POR, BOR = --00 0000. TBLPTRU, Details on Page: = 34, 58. TBLPTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 6 = Program Memory",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nTable Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Value on POR, BOR = 0000 0000. TBLPTRH, Details on Page: = 34, 58. TBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\n(TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Value on POR, BOR = 0000 0000. TBLPTRL, Details on Page: = 34, 58. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch.",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nTABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on POR, BOR = 0000 0000. TABLAT, Details on Page: = 34, 58. PRODH, Bit 7 = Product Register High Byte. PRODH, Bit 6 = Product Register High Byte. PRODH, Bit 5 = Product Register High Byte. PRODH, Bit 4 = Product Register High Byte. PRODH, Bit 3 = Product Register High Byte. PRODH, Bit 2 = Product Register High Byte. PRODH, Bit 1 = Product Register High Byte. PRODH, Bit 0 = Product Register High Byte. PRODH, Value on POR, BOR = xxxx xxxx. PRODH, Details on Page: = 34, 68. PRODL, Bit 7 = Product Register Low Byte. PRODL, Bit 6 = Product Register Low Byte. PRODL, Bit 5 = Product Register Low Byte. PRODL, Bit 4 = Product Register Low Byte. PRODL, Bit 3 = Product Register",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nLow Byte. PRODL, Bit 2 = Product Register Low Byte. PRODL, Bit 1 = Product Register Low Byte. PRODL, Bit 0 = Product Register Low Byte. PRODL, Value on POR, BOR = xxxx xxxx. PRODL, Details on Page: = 34, 68. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Details on Page: = 34, 72. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = -. INTCON2, Bit 2 =",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nTMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111 -1-1. INTCON2, Details on Page: = 34, 73. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 11-0 0-00. INTCON3, Details on Page: = 34, 74. INDF0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register).",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nINDF0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Value on POR, BOR = N/A. INDF0, Details on Page: = 34, 51. POSTINC0, Bit 7 = Uses contents of FSR0 to address data memory",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\n- value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register).",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nPOSTINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Value on POR, BOR = N/A. POSTINC0, Details on Page: = 34, 51. POSTDEC0, Bit 7 = Uses contents of FSR0 to address data memory- value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 6 = Uses contents of FSR0 to address data memory- value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 5 = Uses contents of FSR0 to address data memory- value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 4 = Uses contents of FSR0 to address data memory- value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 3 = Uses contents of FSR0 to address data memory- value of FSR0",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\npost-decremented (not a physical register). POSTDEC0, Bit 2 = Uses contents of FSR0 to address data memory- value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 1 = Uses contents of FSR0 to address data memory- value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 0 = Uses contents of FSR0 to address data memory- value of FSR0 post-decremented (not a physical register). POSTDEC0, Value on POR, BOR = N/A. POSTDEC0, Details on Page: = 34, 51. PREINC0, Bit 7 = . PREINC0, Bit 6 = . PREINC0, Bit 5 = . PREINC0, Bit 4 = . PREINC0, Bit 3 = . PREINC0, Bit 2 = . PREINC0, Bit 1 = . PREINC0, Bit 0 = . PREINC0, Value on POR, BOR = N/A.",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nPREINC0, Details on Page: = 34, 51. PLUSW0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents of FSR0 to address data memory. PLUSW0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents of FSR0 to address data memory. PLUSW0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents of FSR0 to address data memory. PLUSW0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents of FSR0 to address data memory. PLUSW0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents of FSR0 to address data",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nmemory. PLUSW0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents of FSR0 to address data memory. PLUSW0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents of FSR0 to address data memory. PLUSW0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents of FSR0 to address data memory. PLUSW0, Value on POR, BOR = N/A. PLUSW0, Details on Page: = 34, 51. FSR0H, Bit 7 = -. FSR0H, Bit 6 = -. FSR0H, Bit 5 = -. FSR0H, Bit 4 = -. FSR0H, Bit 3 = - value of FSR0 offset by W(not a physical register). FSR0H, Bit 2 = -",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nvalue of FSR0 offset by W(not a physical register). FSR0H, Bit 1 = - value of FSR0 offset by W(not a physical register). FSR0H, Bit 0 = - value of FSR0 offset by W(not a physical register). FSR0H, Value on POR, BOR = ---- 0000. FSR0H, Details on Page: = 34, 51. FSR0L, Bit 7 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 6 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 5 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 4 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 3 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 2 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 1 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 0 = Indirect Data Memory Address Pointer 0 High. FSR0L, Value on POR, BOR = xxxx",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nxxxx. FSR0L, Details on Page: = 34, 51. WREG, Bit 7 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 6 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 5 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 4 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 3 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 2 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 1 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 0 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Value on POR, BOR = xxxx xxxx. WREG, Details on Page: = 34. INDF1, Bit 7 = Working Register Uses contents. INDF1, Bit 6 = of FSR1 to. INDF1, Bit 5 = address data. INDF1, Bit 4 = memory - value. INDF1, Bit 3 = of FSR1. INDF1, Bit 2 = changed (not. INDF1, Bit 1 =",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\na physical. INDF1, Bit 0 = register). INDF1, Value on POR, BOR = N/A. INDF1, Details on Page: = 34, 51. POSTINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 2 = Uses contents of FSR1 to address data",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nmemory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Value on POR, BOR = N/A. POSTINC1, Details on Page: = 34, 51. POSTDEC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 4 = Uses",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\ncontents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Value on POR, BOR = N/A. POSTDEC1, Details on Page: = 34, 51. PREINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register).",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nPREINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nFSR1 pre-incremented (not a physical register). PREINC1, Value on POR, BOR = N/A. PREINC1, Details on Page: = 34, 51. PLUSW1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\na physical register). PLUSW1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Value on POR, BOR = N/A. PLUSW1, Details on Page: = 34, 51. FSR1H, Bit 7 = -. FSR1H, Bit 6 = -. FSR1H, Bit 5 = -. FSR1H, Bit 4 = -. FSR1H, Bit 3 = Indirect Data Memory Address Pointer 1 High. FSR1H, Bit 2 = Indirect Data Memory Address Pointer 1 High. FSR1H, Bit 1 = Indirect Data Memory Address Pointer 1 High. FSR1H, Bit 0 = Indirect Data Memory Address Pointer 1 High. FSR1H, Value on POR, BOR = ---- 0000. FSR1H, Details on Page: = 34, 51.",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nFSR1L, Bit 7 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 6 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 5 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 4 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 3 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 2 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 1 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 0 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Value on POR, BOR = xxxx xxxx. FSR1L, Details on Page: = 34, 51. BSR, Bit 7 = - - - - Bank Select Register. BSR, Bit 6 = - - - - Bank Select Register. BSR, Bit 5 = - - - - Bank Select Register. BSR, Bit 4 = - - - - Bank Select Register. BSR, Bit 3 = - - - - Bank Select Register.",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nBSR, Bit 2 = - - - - Bank Select Register. BSR, Bit 1 = - - - - Bank Select Register. BSR, Bit 0 = - - - - Bank Select Register. BSR, Value on POR, BOR = ---- 0000. BSR, Details on Page: = 35, 50. INDF2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 2 =",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nUses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Value on POR, BOR = N/A. INDF2, Details on Page: = 35, 51. POSTINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 4 = Uses contents of",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nFSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Value on POR, BOR = N/A. POSTINC2, Details on Page: = 35, 51. POSTDEC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register).",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nPOSTDEC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 0 = Uses contents of FSR2 to address data memory - value of",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nFSR2 post-decremented (not a physical register). POSTDEC2, Value on POR, BOR = N/A. POSTDEC2, Details on Page: = 35, 51. PREINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 2 = Uses contents of",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nFSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Value on POR, BOR = N/A. PREINC2, Details on Page: = 35, 51. PLUSW2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 4 = Uses contents of",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nFSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Value on POR, BOR = N/A. PLUSW2, Details on Page: = 35, 51. FSR2H, Bit 7 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 6 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 5 = - - - - Indirect Data Memory",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nAddress Pointer 2 High. FSR2H, Bit 4 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 3 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 2 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 1 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 0 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Value on POR, BOR = ---- 0000. FSR2H, Details on Page: = 35, 51. FSR2L STATUS, Bit 7 = Indirect Data Memory -. FSR2L STATUS, Bit 6 = Address -. FSR2L STATUS, Bit 5 = Pointer -. FSR2L STATUS, Bit 4 = Low Byte N. FSR2L STATUS, Bit 3 = OV. FSR2L STATUS, Bit 2 = Z. FSR2L STATUS, Bit 1 = DC. FSR2L STATUS, Bit 0 = C. FSR2L",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nSTATUS, Value on POR, BOR = xxxx xxxx ---x xxxx. FSR2L STATUS, Details on Page: = 35, 51 35, 53. TMR0H, Bit 7 = Timer0 Register High Byte. TMR0H, Bit 6 = Timer0 Register High Byte. TMR0H, Bit 5 = Timer0 Register High Byte. TMR0H, Bit 4 = Timer0 Register High Byte. TMR0H, Bit 3 = Timer0 Register High Byte. TMR0H, Bit 2 = Timer0 Register High Byte. TMR0H, Bit 1 = Timer0 Register High Byte. TMR0H, Bit 0 = Timer0 Register High Byte. TMR0H, Value on POR, BOR = 0000 0000. TMR0H, Details on Page: = 35, 97. , Bit 7 = Timer0 Register Low Byte. , Bit 6 = Timer0 Register Low Byte. , Bit 5 = Timer0 Register Low Byte. , Bit 4 = Timer0 Register Low Byte. , Bit 3 = Timer0 Register",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nLow Byte. , Bit 2 = Timer0 Register Low Byte. , Bit 1 = Timer0 Register Low Byte. , Bit 0 = Timer0 Register Low Byte. , Value on POR, BOR = xxxx xxxx. , Details on Page: = 35, 97. TMR0L, Bit 7 = . TMR0L, Bit 6 = . TMR0L, Bit 5 = . TMR0L, Bit 4 = . TMR0L, Bit 3 = . TMR0L, Bit 2 = . TMR0L, Bit 1 = . TMR0L, Bit 0 = . TMR0L, Value on POR, BOR = . TMR0L, Details on Page: = . T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 =",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\nT0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111 1111. T0CON, Details on Page: = 35, 95. OSCCON, Bit 7 = IDLEN. OSCCON, Bit 6 = IRCF2. OSCCON, Bit 5 = IRCF1. OSCCON, Bit 4 = IRCF0. OSCCON, Bit 3 = OSTS. OSCCON, Bit 2 = IOFS. OSCCON, Bit 1 = SCS1. OSCCON, Bit 0 = SCS0. OSCCON, Value on POR, BOR = 0000 q000 --00 0101. OSCCON, Details on Page: = 35, 16. LVDCON WDTCON, Bit 7 = - -. LVDCON WDTCON, Bit 6 = - -. LVDCON WDTCON, Bit 5 = IVRST -. LVDCON WDTCON, Bit 4 = LVDEN -. LVDCON WDTCON, Bit 3 = LVDL3",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\n-. LVDCON WDTCON, Bit 2 = LVDL2 -. LVDCON WDTCON, Bit 1 = LVDL1 -. LVDCON WDTCON, Bit 0 = LVDL0 SWDTEN. LVDCON WDTCON, Value on POR, BOR = . LVDCON WDTCON, Details on Page: = 35, 162 35, 174. RCON, Bit 7 = . RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = . RCON, Bit 0 = BOR. RCON, Value on POR, BOR = --- ---0. RCON, Details on Page: = 33, 54,. , Bit 7 = IPEN. , Bit 6 = . , Bit 5 = . , Bit 4 = . , Bit 3 = . , Bit 2 = . , Bit 1 = POR. , Bit 0 = . , Value on POR, BOR = 0--1",
    "TABLE 5-2: REGISTER FILE SUMMARY (PIC18F1220/1320)\n11q0. , Details on Page: = 81\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: RA6 and associated bits are configured as port pins in RCIO, ECIO and INTIO2 (with port function on RA6) Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: RA7 and associated bits are configured as port pins in INTIO2 Oscillator mode only and read ' 0 ' in all other modes.\n3: Bit 21 of the PC is only available in Test mode and Serial Programming modes.\n4: The RA5 port bit is only available when MCLRE fuse (CONFIG3H<7>) is programmed to ' 0 '. Otherwise, RA5 reads ' 0 '. This bit is read-only.",
    "TABLE 5-2:\nTMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Value on POR, BOR = xxxx xxxx. TMR1H, Value on POR, BOR = xxxx xxxx. TMR1H, Details on Page: = 35, 103. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte.",
    "TABLE 5-2:\nTMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Value on POR, BOR = xxxx xxxx. TMR1L, Value on POR, BOR = xxxx xxxx. TMR1L, Details on Page: = 35, 103. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0000. T1CON, Value on POR, BOR = 0000. T1CON, Details on Page: = 35, 98. TMR2, Bit 7 = Timer2 Register. TMR2,",
    "TABLE 5-2:\nBit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Details on Page: = 35, 104. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. PR2, Details on Page: = 35, 104.",
    "TABLE 5-2:\nT2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Details on Page: = 35, 104. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte.",
    "TABLE 5-2:\nADRESH, Value on POR, BOR = xxxx. ADRESH, Value on POR, BOR = xxxx. ADRESH, Details on Page: = 35, 159. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Value on POR, BOR = xxxx. ADRESL, Value on POR, BOR = xxxx. ADRESL, Details on Page: = 35, 159. ADCON0, Bit 7 = VCFG1. ADCON0, Bit 6 = VCFG0. ADCON0, Bit 5 = -. ADCON0, Bit 4 = CHS2. ADCON0, Bit 3 =",
    "TABLE 5-2:\nCHS1. ADCON0, Bit 2 = CHS0. ADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = 00-0. ADCON0, Value on POR, BOR = 0000. ADCON0, Details on Page: = 35, 150. ADCON1, Bit 7 = -. ADCON1, Bit 6 = PCFG6. ADCON1, Bit 5 = PCFG5. ADCON1, Bit 4 = PCFG4. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = -000. ADCON1, Value on POR, BOR = 0000. ADCON1, Details on Page: = 35, 151. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = -. ADCON2, Bit 5 = ACQT2. ADCON2, Bit 4 =",
    "TABLE 5-2:\nACQT1. ADCON2, Bit 3 = ACQT0. ADCON2, Bit 2 = ADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Value on POR, BOR = 0-00. ADCON2, Value on POR, BOR = 0000. ADCON2, Details on Page: = 35, 152. CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 High",
    "TABLE 5-2:\nByte. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Details on Page: = 35. 110. CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Details on Page: = 35, 110.",
    "TABLE 5-2:\nCCP1CON, Bit 7 = P1M1. CCP1CON, Bit 6 = P1M0. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Details on Page: = 35, 109. PWM1CON, Bit 7 = PRSEN. PWM1CON, Bit 6 = PDC6. PWM1CON, Bit 5 = PDC5. PWM1CON, Bit 4 = PDC4. PWM1CON, Bit 3 = PDC3. PWM1CON, Bit 2 = PDC2. PWM1CON, Bit 1 = PDC1. PWM1CON, Bit 0 =",
    "TABLE 5-2:\nPDC0. PWM1CON, Value on POR, BOR = 0000. PWM1CON, Value on POR, BOR = 0000. PWM1CON, Details on Page: = 35, 121. ECCPAS, Bit 7 = ECCPASE. ECCPAS, Bit 6 = ECCPAS2. ECCPAS, Bit 5 = ECCPAS1. ECCPAS, Bit 4 = ECCPAS0. ECCPAS, Bit 3 = PSSAC1. ECCPAS, Bit 2 = PSSAC0. ECCPAS, Bit 1 = PSSBD1. ECCPAS, Bit 0 = PSSBD0. ECCPAS, Value on POR, BOR = 0000. ECCPAS, Value on POR, BOR = 0000. ECCPAS, Details on Page: = 35, 122. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte.",
    "TABLE 5-2:\nTMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = Timer3 Register High Byte. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on POR, BOR = xxxx. TMR3H, Details on Page: = 36, 108. TMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = Timer3 Register Low Byte. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on",
    "TABLE 5-2:\nPOR, BOR = xxxx. TMR3L, Details on Page: = 36, 108. T3CON, Bit 7 = RD16. T3CON, Bit 6 = -. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0-00. T3CON, Value on POR, BOR = 0000. T3CON, Details on Page: = 36, 106. SPBRGH, Bit 7 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit",
    "TABLE 5-2:\n2 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Details on Page: = 36. SPBRG, Bit 7 = EUSART Baud Rate Generator Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Low Byte. SPBRG, Bit 5 = EUSART Baud Rate Generator Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000.",
    "TABLE 5-2:\nSPBRG, Details on Page: = 36, 130. RCREG, Bit 7 = EUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4 = EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Details on Page: = 36, 138, 137. TXREG, Bit 7 = EUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit Register. TXREG, Bit 5 = EUSART Transmit Register. TXREG, Bit 4 = EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register.",
    "TABLE 5-2:\nTXREG, Bit 0 = EUSART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Details on Page: = 36, 135, 137. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Details on Page: = 36, 127. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR",
    "TABLE 5-2:\n= 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Details on Page: = 36, 128. BAUDCTL, Bit 7 = -. BAUDCTL, Bit 6 = RCIDL. BAUDCTL, Bit 5 = -. BAUDCTL, Bit 4 = SCKP. BAUDCTL, Bit 3 = BRG16. BAUDCTL, Bit 2 = -. BAUDCTL, Bit 1 = WUE. BAUDCTL, Bit 0 = ABDEN. BAUDCTL, Value on POR, BOR = -1-1. BAUDCTL, Value on POR, BOR = 0-00. BAUDCTL, Details on Page: = 36, 129. EEADR, Bit 7 = EEPROM Address Register. EEADR, Bit 6 = EEPROM Address Register. EEADR, Bit 5 = EEPROM Address Register. EEADR, Bit 4 = EEPROM Address Register. EEADR, Bit 3 = EEPROM Address Register. EEADR, Bit 2 = EEPROM Address Register. EEADR, Bit 1 =",
    "TABLE 5-2:\nEEPROM Address Register. EEADR, Bit 0 = EEPROM Address Register. EEADR, Value on POR, BOR = 0000. EEADR, Value on POR, BOR = 0000. EEADR, Details on Page: = 36, 64. EEDATA, Bit 7 = EEPROM Data Register. EEDATA, Bit 6 = EEPROM Data Register. EEDATA, Bit 5 = EEPROM Data Register. EEDATA, Bit 4 = EEPROM Data Register. EEDATA, Bit 3 = EEPROM Data Register. EEDATA, Bit 2 = EEPROM Data Register. EEDATA, Bit 1 = EEPROM Data Register. EEDATA, Bit 0 = EEPROM Data Register. EEDATA, Value on POR, BOR = 0000. EEDATA, Value on POR, BOR = 0000. EEDATA, Details on Page: = 36, 67. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5",
    "TABLE 5-2:\n= EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Value on POR, BOR = 0000. EECON2, Value on POR, BOR = 0000. EECON2, Details on Page: = 36, 56, 64. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on POR, BOR = xx-0.",
    "TABLE 5-2:\nEECON1, Value on POR, BOR = x000. EECON1, Details on Page: = 36, 57, 65. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = -. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = -. IPR2, Value on POR, BOR = 1--1. IPR2, Value on POR, BOR = -11-. IPR2, Details on Page: = 36, 80. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = -. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = -. PIR2, Value on POR, BOR =",
    "TABLE 5-2:\n0--0. PIR2, Value on POR, BOR = -00-. PIR2, Details on Page: = 36, 76. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = -. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = -. PIE2, Value on POR, BOR = 0--0. PIE2, Value on POR, BOR = -00-. PIE2, Details on Page: = 36, 78. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111.",
    "TABLE 5-2:\nIPR1, Value on POR, BOR = -111. IPR1, Details on Page: = 36, 79. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000. PIR1, Value on POR, BOR = -000. PIR1, Details on Page: = 36, 75. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Value on",
    "TABLE 5-2:\nPOR, BOR = -000. PIE1, Details on Page: = 36, 77. OSCTUNE TRISB, Bit 7 = - - TUN5 TUN4 TUN3 TUN2 TUN1 TUN0 Data Direction Control Register for PORTB. OSCTUNE TRISB, Bit 6 = - - TUN5 TUN4 TUN3 TUN2 TUN1 TUN0 Data Direction Control Register for PORTB. OSCTUNE TRISB, Bit 5 = - - TUN5 TUN4 TUN3 TUN2 TUN1 TUN0 Data Direction Control Register for PORTB. OSCTUNE TRISB, Bit 4 = - - TUN5 TUN4 TUN3 TUN2 TUN1 TUN0 Data Direction Control Register for PORTB. OSCTUNE TRISB, Bit 3 = - - TUN5 TUN4 TUN3 TUN2 TUN1 TUN0 Data Direction Control Register for PORTB. OSCTUNE TRISB, Bit 2 = - - TUN5 TUN4 TUN3 TUN2 TUN1 TUN0 Data Direction Control Register for PORTB. OSCTUNE TRISB, Bit 1 = - - TUN5 TUN4 TUN3 TUN2 TUN1 TUN0 Data Direction Control Register for PORTB. OSCTUNE TRISB, Bit 0 = - - TUN5",
    "TABLE 5-2:\nTUN4 TUN3 TUN2 TUN1 TUN0 Data Direction Control Register for PORTB. OSCTUNE TRISB, Value on POR, BOR = --00 1111. OSCTUNE TRISB, Value on POR, BOR = 0000 1111. OSCTUNE TRISB, Details on Page: = 36, 14 36, 94. TRISA, Bit 7 = . TRISA, Bit 6 = . TRISA, Bit 5 = . TRISA, Bit 4 = . TRISA, Bit 3 = . TRISA, Bit 2 = . TRISA, Bit 1 = . TRISA, Bit 0 = . TRISA, Value on POR, BOR = 11-1. TRISA, Value on POR, BOR = 1111. TRISA, Details on Page: = 36, 85. LATB, Bit 7 = TRISA7 (2) TRISA6 (1) - Data Direction Control Register for PORTA Read/Write PORTB Data Latch. LATB, Bit 6 = TRISA7 (2) TRISA6 (1) - Data Direction Control Register for PORTA Read/Write PORTB Data Latch. LATB, Bit 5 = TRISA7 (2)",
    "TABLE 5-2:\nTRISA6 (1) - Data Direction Control Register for PORTA Read/Write PORTB Data Latch. LATB, Bit 4 = TRISA7 (2) TRISA6 (1) - Data Direction Control Register for PORTA Read/Write PORTB Data Latch. LATB, Bit 3 = TRISA7 (2) TRISA6 (1) - Data Direction Control Register for PORTA Read/Write PORTB Data Latch. LATB, Bit 2 = TRISA7 (2) TRISA6 (1) - Data Direction Control Register for PORTA Read/Write PORTB Data Latch. LATB, Bit 1 = TRISA7 (2) TRISA6 (1) - Data Direction Control Register for PORTA Read/Write PORTB Data Latch. LATB, Bit 0 = TRISA7 (2) TRISA6 (1) - Data Direction Control Register for PORTA Read/Write PORTB Data Latch. LATB, Value on POR, BOR = xxxx. LATB, Value on POR, BOR = xxxx. LATB, Details on Page: = 36, 94. LATA, Bit 7 = LATA<7>",
    "TABLE 5-2:\n(2) LATA<6> (1) - Read/Write PORTA Data Latch. LATA, Bit 6 = LATA<7> (2) LATA<6> (1) - Read/Write PORTA Data Latch. LATA, Bit 5 = LATA<7> (2) LATA<6> (1) - Read/Write PORTA Data Latch. LATA, Bit 4 = LATA<7> (2) LATA<6> (1) - Read/Write PORTA Data Latch. LATA, Bit 3 = LATA<7> (2) LATA<6> (1) - Read/Write PORTA Data Latch. LATA, Bit 2 = LATA<7> (2) LATA<6> (1) - Read/Write PORTA Data Latch. LATA, Bit 1 = LATA<7> (2) LATA<6> (1) - Read/Write PORTA Data Latch. LATA, Bit 0 = LATA<7> (2) LATA<6> (1) - Read/Write PORTA Data Latch. LATA, Value on POR, BOR = xx-x.",
    "TABLE 5-2:\nLATA, Value on POR, BOR = xxxx. LATA, Details on Page: = 36, 85. PORTB, Bit 7 = PORTB pins, Write PORTB Data Latch. PORTB, Bit 6 = PORTB pins, Write PORTB Data Latch. PORTB, Bit 5 = PORTB pins, Write PORTB Data Latch. PORTB, Bit 4 = PORTB pins, Write PORTB Data Latch. PORTB, Bit 3 = PORTB pins, Write PORTB Data Latch. PORTB, Bit 2 = PORTB pins, Write PORTB Data Latch. PORTB, Bit 1 = PORTB pins, Write PORTB Data Latch. PORTB, Bit 0 = PORTB pins, Write PORTB Data Latch. PORTB, Value on POR, BOR = xxxx. PORTB, Value on POR, BOR = xxxx. PORTB, Details on Page: = 36, 94. , Bit 7 = Read (2) (1) (4). , Bit 6 = Read (2) (1) (4). , Bit 5 = Read (2) (1) (4). , Bit 4 = Read (2) (1) (4).",
    "TABLE 5-2:\n, Bit 3 = Read (2) (1) (4). , Bit 2 = Read (2) (1) (4). , Bit 1 = Read (2) (1) (4). , Bit 0 = Read (2) (1) (4). , Value on POR, BOR = . , Value on POR, BOR = . , Details on Page: = . PORTA, Bit 7 = RA7 RA6 RA5 Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 6 = RA7 RA6 RA5 Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 5 = RA7 RA6 RA5 Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 4 = RA7 RA6 RA5 Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 3 = RA7 RA6 RA5 Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 2 = RA7 RA6 RA5 Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 1 = RA7 RA6 RA5 Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 0",
    "TABLE 5-2:\n= RA7 RA6 RA5 Read PORTA pins, Write PORTA Data Latch. PORTA, Value on POR, BOR = xx0x. PORTA, Value on POR, BOR = 0000. PORTA, Details on Page: = 36, 85",
    "REGISTER FILE SUMMARY (PIC18F1220/1320) (CONTINUED)\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: RA6 and associated bits are configured as port pins in RCIO, ECIO and INTIO2 (with port function on RA6) Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: RA7 and associated bits are configured as port pins in INTIO2 Oscillator mode only and read ' 0 ' in all other modes.\n3: Bit 21 of the PC is only available in Test mode and Serial Programming modes.\n4: The RA5 port bit is only available when MCLRE fuse (CONFIG3H<7>) is programmed to ' 0 '. Otherwise, RA5 reads ' 0 '. This bit is read-only.",
    "5.10 Access Bank\nThe  Access  Bank  is  an  architectural  enhancement which is very useful for C compiler code optimization. The techniques used by the C compiler may also be useful for programs written in assembly.\nThis data memory region can be used for:\n\u00b7 Intermediate computational values\n\u00b7 Local variables of subroutines\n\u00b7 Faster context saving/switching of variables\n\u00b7 Common variables\n\u00b7 Faster evaluation/control of SFRs (no banking)\nThe Access Bank is comprised of the last 128 bytes in Bank  15  (SFRs)  and  the  first  128  bytes  in  Bank  0. These two sections will be referred to as Access RAM High  and  Access  RAM  Low,  respectively.  Figure 5-6 indicates the Access RAM areas.\nA bit in the instruction word specifies if the operation is to occur in the bank specified by the BSR register or in the Access Bank. This bit is denoted as the 'a' bit (for access bit).\nWhen  forced  in  the  Access  Bank  (a  = 0 ),  the  last address  in  Access  RAM  Low  is  followed  by  the  first address in Access RAM High. Access RAM High maps the Special Function Registers, so these registers can be  accessed  without  any  software  overhead.  This  is useful for testing status flags and modifying control bits.",
    "5.11 Bank Select Register (BSR)\nThe need for a large general purpose memory space dictates a RAM banking scheme. The data memory is partitioned into as many as sixteen banks. When using direct addressing, the BSR should be configured for the desired bank.\nBSR<3:0> holds the upper four bits of the 12-bit RAM address. The BSR<7:4> bits will always read ' 0 's and writes will have no effect (see Figure 5-7).\nA MOVLB instruction has been provided in the instruction set to assist in selecting banks.\nIf the currently selected bank is not implemented, any read will return all ' 0 's and all writes are ignored. The Status register bits will be set/cleared as appropriate for the instruction performed.\nEach  Bank  extends  up  to  FFh  (256  bytes).  All  data memory is implemented as static RAM.\nA MOVFF instruction ignores the BSR, since the 12-bit addresses are embedded into the instruction word.\nSection 5.12  'Indirect  Addressing, INDF  and  FSR Registers' provides a description of indirect addressing, which allows linear addressing of the entire RAM space.",
    "FIGURE 5-7: DIRECT ADDRESSING\nNote\n1: For register file map detail, see Table 5-1.\n2: The access bit of the instruction can be used to force an override of the selected bank (BSR<3:0>) to the registers of the Access Bank.\n3: The MOVFF instruction embeds the entire 12-bit address in the instruction.",
    "5.12 Indirect Addressing, INDF and FSR Registers\nIndirect addressing is a mode of addressing data memory, where the data memory address in the instruction is not fixed. An FSR register is used as a pointer to the data memory location that is to be read or written. Since this pointer is in RAM, the contents can be modified by the program. This can be useful for data tables in the data  memory  and  for  software  stacks.  Figure 5-8 shows how the fetched instruction is modified prior to being executed.\nIndirect  addressing  is  possible  by  using  one  of  the INDF registers. Any instruction, using the INDF register, actually accesses the register pointed to by the File Select Register, FSR. Reading the INDF register itself, indirectly (FSR = 0 ), will read 00h. Writing to the INDF register indirectly, results in a no operation ( NOP ). The FSR register contains a 12-bit address, which is shown in Figure 5-9.\nThe INDFn register is not a physical register. Addressing INDFn  actually  addresses  the  register  whose address is contained in the FSRn register (FSRn is a pointer). This is indirect addressing.",
    "5.12 Indirect Addressing, INDF and FSR Registers\nExample 5-5 shows a simple use of indirect addressing to clear the RAM in Bank 1 (locations 100h-1FFh) in a minimum number of instructions.",
    "HOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nNEXT, 1 = LFSR CLRF. NEXT, 2 = FSR0,0x100 POSTINC0. NEXT, 3 = ; ; Clear INDF ; register then ; inc pointer. , 1 = BTFSS. , 2 = FSR0H, 1. , 3 = ; All done with ; Bank1?. , 1 = GOTO. , 2 = NEXT. , 3 = ; NO, clear next ;. CONTINUE, 1 = CONTINUE. CONTINUE, 2 = CONTINUE. CONTINUE, 3 = YES, continue\nThere are three indirect addressing registers. To address  the  entire  data  memory  space  (4096  bytes), these registers are 12-bit wide. To store the 12 bits of addressing information, two 8-bit registers are required:\n1. FSR0: composed of FSR0H:FSR0L\n2. FSR1: composed of FSR1H:FSR1L\n3. FSR2: composed of FSR2H:FSR2L",
    "HOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nIn  addition,  there  are  registers  INDF0,  INDF1  and INDF2, which are not physically implemented. Reading or writing to these registers activates indirect addressing, with the value in the corresponding FSR register being the address of the data. If an instruction writes a value to INDF0, the value will be written to the address pointed to by FSR0H:FSR0L. A read from INDF1 reads the data from the address pointed to by FSR1H:FSR1L. INDFn can be used in code anywhere an operand can be used.\nIf  INDF0,  INDF1  or  INDF2  are  read  indirectly  via  an FSR,  all  ' 0 's  are  read  (zero  bit  is  set).  Similarly,  if INDF0, INDF1 or INDF2 are written to indirectly, the operation will be equivalent to a NOP instruction and the Status bits are not affected.",
    "5.12.1 INDIRECT ADDRESSING OPERATION\nEach FSR register has an INDF register associated with it, plus four additional register addresses. Performing an operation using one of these five registers determines how the FSR will be modified during indirect addressing.\nWhen data access is performed using one of the five INDFn  locations,  the  address  selected  will  configure the FSRn register to:\n\u00b7 Do nothing to FSRn after an indirect access (no change) - INDFn\n\u00b7 Auto-decrement FSRn after an indirect access (post-decrement) - POSTDECn\n\u00b7 Auto-increment FSRn after an indirect access (post-increment) - POSTINCn\n\u00b7 Auto-increment FSRn before an indirect access (pre-increment) - PREINCn\n\u00b7 Use the value in the WREG register as an offset to FSRn. Do not modify the value of the WREG or the FSRn register after an indirect access (no change) - PLUSWn",
    "5.12.1 INDIRECT ADDRESSING OPERATION\nWhen  using  the  auto-increment  or  auto-decrement features, the effect on the FSR is not reflected in the Status  register.  For  example,  if  the  indirect  address causes the FSR to equal ' 0 ', the Z bit will not be set.\nAuto-incrementing or auto-decrementing an FSR affects all  12  bits.  That  is,  when  FSRnL  overflows  from  an increment, FSRnH will be incremented automatically.\nAdding these features allows the FSRn to be used as a stack pointer, in addition to its uses for table operations in data memory.\nEach  FSR  has  an  address  associated  with  it  that performs  an  indexed  indirect  access.  When  a  data access to this INDFn location (PLUSWn) occurs, the FSRn  is  configured  to  add  the  signed  value  in  the WREG  register  and  the  value  in  FSR  to  form  the address before an indirect access. The FSR value is not changed. The WREG offset range is -128 to +127.",
    "5.12.1 INDIRECT ADDRESSING OPERATION\nIf an FSR register contains a value that points to one of the INDFn, an indirect read will read 00h (zero bit is set), while an indirect write will be equivalent to a NOP (Status bits are not affected).\nIf an indirect addressing write is performed when the target address is an FSRnH or FSRnL register, the data is written to the FSR register, but no pre- or post-increment/ decrement is performed.",
    "5.13 Status Register\nThe STATUS register, shown in Register 5-2, contains the arithmetic status of the ALU. As with any other SFR, it can be the operand for any instruction.\nIf the STATUS register is the destination for an instruction that affects the Z, DC, C, OV or N bits, the results of the instruction are not written; instead, the status is updated according to the instruction performed. Therefore,  the  result  of  an  instruction  with  the  STATUS register as its destination may  be  different than intended. As an example, CLRF STATUS will set the Z bit  and  leave  the  remaining  Status  bits  unchanged (' 000u u1uu ').\nIt is recommended that only BCF BSF SWAPF MOVFF , , , and MOVWF instructions are used to alter the STATUS register, because these instructions do not affect the Z, C, DC, OV or N bits in the STATUS register.\nFor other instructions that do not affect Status bits, see the instruction set summaries in Table 20-1.\nNote:\nThe C and DC bits operate as the borrow and  digit borrow bits, respectively, in subtraction.",
    "REGISTER 5-2: STATUS: STATUS REGISTER\n-, U-0 = -. -, U-0 = -. -, R-1/q = N. -, R-1/q = OV. -, R/W-0/u = Z. -, R/W-0/u = DC. -, R/W-0/u = C. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R-1/q = bit 7. bit 7, R-1/q = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 7. bit 7, R/W-0/u = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nq = Value depends on condition",
    "bit 7-5 Unimplemented: Read as ' 0 '\nbit 4\nN: Negative bit\nThis bit is used for signed arithmetic (2's complement). It indicates whether the result was negative (ALU MSB = 1 ).\n1 = Result was negative\n0 = Result was positive",
    "bit 3\nOV: Overflow bit\nThis bit is used for signed arithmetic (2's complement). It indicates an overflow of the 7-bit magnitude, which causes the sign bit (bit 7) to change state.\n1 = Overflow occurred for signed arithmetic (in this arithmetic operation)\n0 = No overflow occurred",
    "bit 2\nZ: Zero bit\n1 = The result of an arithmetic or logic operation is zero\n0 = The result of an arithmetic or logic operation is not zero\nbit 1\nDC: Digit Carry/Digit Borrow bit ( ADDWF ADDLW SUBLW SUBWF , , , instructions) (1)\n1 = A carry-out from the 4th low-order bit of the result occurred\n0 = No carry-out from the 4th low-order bit of the result\nbit 0\nC: Carry/Borrow bit (1) ( ADDWF ADDLW SUBLW SUBWF , , , instructions) (1)\n1 = A carry-out from the Most Significant bit of the result occurred\n0 = No carry-out from the Most Significant bit of the result occurred\n- Note 1: For Borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand. For rotate ( RRF RLF , ) instructions, this bit is loaded with either the high-order or low-order bit of the source register.",
    "5.14 RCON Register\nThe Reset Control (RCON) register contains flag bits that  allow  differentiation  between  the  sources  of  a device Reset. These flags include the TO, PD, POR, BOR and RI bits. This register is readable and writable.\nNote 1: If the BOR  Configuration bit is set (Brown-out Reset enabled), the BOR bit is ' 1 ' on  a  Power-on  Reset.  After  a Brown-out Reset has occurred, the BOR bit  will  be  cleared  and  must  be  set  by firmware to indicate the occurrence of the next Brown-out Reset.\n2: It  is  recommended  that  the  POR  bit  be set  after  a  Power-on  Reset  has  been detected,  so  that  subsequent  Power-on Resets may be detected.",
    "REGISTER 5-3: RCON: RESET CONTROL REGISTER\nIPEN, U-0 = -. IPEN, U-0 = -. IPEN, R/W-1 = RI. IPEN, R-1 = TO. IPEN, R-1 = PD. IPEN, R/W-0 = POR. IPEN, R/W-0 = BOR. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R-1 = bit 7. bit 7, R-1 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 5-3: RCON: RESET CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = q = Value depends on condition",
    "bit 7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16CXXX Compatibility mode)",
    "bit 6-5 Unimplemented: Read as ' 0 '\nbit 4\nRI: RESET Instruction Flag bit\n1 = The RESET instruction was not executed (set by firmware only)\n0 = The RESET instruction was executed causing a device Reset (must be set in software after a Brown-out Reset occurs)\nbit 3\nTO: Watchdog Time-out Flag bit\n1 = Set by power-up, CLRWDT instruction or SLEEP instruction\n0 = A WDT time-out occurred\nbit 2\nPD: Power-down Detection Flag bit\n1 = Set by power-up or by the CLRWDT instruction\n0 = Cleared by execution of the SLEEP instruction",
    "bit 1\nPOR: Power-on Reset Status bit\n1 = A Power-on Reset has not occurred (set by firmware only)\n0 = A Power-on Reset occurred (must be set in software after a Power-on Reset occurs)\nbit 0\nBOR: Brown-out Reset Status bit\n1 = A Brown-out Reset has not occurred (set by firmware only)\n0 = A Brown-out Reset occurred (must be set in software after a Brown-out Reset occurs)\n- Note 1: For Borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand. For rotate ( RRF RLF , ) instructions, this bit is loaded with either the high-order or low-order bit of the source register.",
    "6.0 FLASH PROGRAM MEMORY\nThe Flash program memory is readable, writable and erasable during normal operation over the entire VDD range.\nA read from program memory is executed on one byte at a time. A write to program memory is executed on blocks of 8 bytes at a time. Program memory is erased in blocks of 64 bytes at a time. A 'Bulk Erase' operation may not be issued from user code.\nWhile writing or erasing program memory, instruction fetches  cease  until  the  operation  is  complete.  The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming timer terminates program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing  a  program  memory location  that  forms  an  invalid  instruction  results  in  a NOP .",
    "6.1 Table Reads and Table Writes\nIn order to read and write program memory, there are two operations that allow the processor to move bytes between  the  program  memory  space  and  the  data RAM:\n\u00b7 Table Read ( TBLRD )\n\u00b7 Table Write ( TBLWT )",
    "FIGURE 6-1: TABLE READ OPERATION\nThe program memory space is 16 bits wide, while the data  RAM  space is  eight  bits  wide.  Table  reads  and table  writes  move  data  between  these  two  memory spaces through an 8-bit register (TABLAT).\nTable  read  operations  retrieve  data  from  program memory  and  place  it  into  TABLAT  in  the  data  RAM space. Figure 6-1 shows the operation of a table read with program memory and data RAM.\nTable write operations store data from TABLAT in the data memory space into holding registers in program memory.  The  procedure  to  write  the  contents  of  the holding  registers  into  program  memory  is  detailed  in Section 6.5  'Writing  to  Flash  Program  Memory' . Figure 6-2  shows  the  operation  of  a  table  write  with program memory and data RAM.\nTable operations work with byte entities. A table block containing data, rather than program instructions, is not required to be word aligned. Therefore, a table block can start and end at any byte address. If a table write is being  used  to  write  executable  code  into  program memory,  program  instructions  will  need  to  be  word aligned (TBLPTRL<0> = 0 ).",
    "FIGURE 6-1: TABLE READ OPERATION\nThe  EEPROM  on-chip  timer  controls  the  write  and erase times. The write and erase voltages are generated by an on-chip charge pump rated to operate over the  voltage  range  of  the  device  for  byte  or  word operations.",
    "6.2 Control Registers\nSeveral control registers are used in conjunction with the TBLRD and TBLWT instructions. These include the:\n\u00b7 EECON1 register\n\u00b7 EECON2 register\nThe WREN bit enables and disables erase and write operations. When set, erase and write operations are allowed. When clear, erase and write operations are disabled - the WR bit cannot be set while the WREN bit is clear. This process helps to prevent accidental writes to memory due to errant (unexpected) code execution.\n\u00b7 TABLAT register\n\u00b7 TBLPTR registers",
    "6.2.1 EECON1 AND EECON2 REGISTERS\nEECON1 is the control register for memory accesses.\nEECON2 is not a physical register. Reading EECON2 will read  all ' 0 's. The  EECON2  register  is  used exclusively in the memory write and erase sequences.\nControl bit, EEPGD, determines if the access will be to program  or  data  EEPROM  memory.  When  clear, operations  will  access  the  data  EEPROM  memory. When set, program memory is accessed.\nControl bit, CFGS, determines if the access will be to the Configuration registers, or to program memory/data EEPROM memory. When set, subsequent operations access Configuration registers. When CFGS is clear, the  EEPGD bit selects  either  program  Flash  or  data EEPROM memory.\nThe FREE bit controls program memory erase operations. When the FREE bit is set, the erase operation is initiated  on  the  next  WR  command.  When  FREE  is clear, only writes are enabled.\nFirmware should keep the WREN bit clear at all times, except when starting erase or write operations. Once firmware  has  set  the  WR  bit,  the  WREN  bit  may  be cleared.  Clearing  the  WREN  bit  will  not  affect  the operation in progress.",
    "6.2.1 EECON1 AND EECON2 REGISTERS\nThe  WRERR  bit  is  set  when  a  write  operation  is interrupted by a Reset. In these situations, the user can check the WRERR bit and rewrite the location. It will be necessary  to  reload  the  data  and  address  registers (EEDATA and EEADR) as these registers have cleared as a result of the Reset.\nControl  bits,  RD  and  WR,  start  read  and  erase/write operations, respectively. These bits are set by firmware and  cleared  by  hardware  at  the  completion  of  the operation.\nThe  RD  bit  cannot  be  set  when  accessing  program memory (EEPGD = 1 ). Program memory is read using table read instructions. See Section 6.3 'Reading the Flash Program Memory' regarding table reads.\nNote:, 1 = Interrupt flag bit, EEIF in the PIR2 register, is set when the write is complete. It must be cleared in software.",
    "REGISTER 6-1: EECON1: EEPROM CONTROL 1 REGISTER\nEEPGD, R/W-x = CFGS. EEPGD, U-0 = -. EEPGD, R/W-0 = FREE. EEPGD, R/W-x = WRERR (1). EEPGD, R/W-0 = WREN. EEPGD, R/S-0 = WR. EEPGD, R/S-0 = RD\nbit 7\nbit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. S = Bit can only be set, 1 = x = Bit is unknown. S = Bit can only be set, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = HC = Bit is cleared by hardware\nbit 7\nEEPGD: Flash Program or Data EEPROM Memory Select bit",
    "REGISTER 6-1: EECON1: EEPROM CONTROL 1 REGISTER\n1 = Access program Flash memory\n0 = Access data EEPROM memory\nbit 6\nCFGS: Flash Program/Data EEPROM or Configuration Select bit\n1 = Accesses Configuration, User ID and Device ID Registers\n0 = Accesses Flash Program or data EEPROM Memory",
    "bit 4 FREE: Flash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation - TBLPTR<5:0> are ignored)\n0 = Perform write only",
    "bit 3 WRERR: EEPROM Error Flag bit (1)\n1\n=\nA write operation was prematurely terminated (any Reset during self-timed programming)\n0 = The write operation completed normally",
    "bit 2\nWREN: Program/Erase Enable bit\n1 = Allows program/erase cycles\n0 = Inhibits programming/erasing of program Flash and data EEPROM",
    "bit 1\nWR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle. (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle completed",
    "bit 0 RD: Read Control bit\n1 = Initiates a memory read\n(Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1 .)\n0 = Read completed",
    "6.2.2 TABLAT - TABLE LATCH REGISTER\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The table latch is used to hold 8-bit data during data transfers between program memory and data RAM.",
    "6.2.3 TBLPTR - TABLE POINTER REGISTER\nThe Table Pointer (TBLPTR) addresses a byte within the  program  memory.  The  TBLPTR  is  comprised  of three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL).  These  three  registers join  to  form a  22-bit  wide  pointer.  The  low-order 21 bits allow the device to address up to 2 Mbytes of program  memory  space.  Setting  the  22nd  bit  allows access to the device ID, the user ID and the configuration bits.",
    "6.2.4 TABLE POINTER BOUNDARIES\nTBLPTR is  used  in  reads,  writes  and  erases  of  the Flash program memory.\nWhen a TBLRD is  executed,  all  22  bits  of  the  Table Pointer determine which byte is read from program or configuration memory into TABLAT.\nWhen a TBLWT is executed, the three LSbs of the Table Pointer  (TBLPTR<2:0>)  determine  which  of  the  eight program memory holding registers is written to. When the timed write to program memory (long write) begins, the 19 MSbs of the Table Pointer (TBLPTR<21:3>) will determine which program memory block of 8 bytes is written to (TBLPTR<2:0> are ignored). For more detail, see Section 6.5 'Writing to Flash Program Memory' .\nThe Table  Pointer  (TBLPTR)  register  is  used  by  the TBLRD and TBLWT instructions. These instructions can update the TBLPTR in one of four ways based on the table operation. These operations are shown in Table 6-1. These operations on the TBLPTR only affect the low-order 21 bits.",
    "6.2.4 TABLE POINTER BOUNDARIES\nWhen an erase of program memory is executed, the 16 MSbs of the Table Pointer (TBLPTR<21:6>) point to the  64-byte  block  that  will  be  erased.  The  Least Significant bits (TBLPTR<5:0>) are ignored.\nFigure 6-3 describes the relevant boundaries of TBLPTR based on Flash program memory operations.",
    "TABLE 6-1: TABLE POINTER OPERATIONS WITH TBLRD AND TBLWT INSTRUCTIONS\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "6.3 Reading the Flash Program Memory\nThe TBLRD instruction  is  used  to  retrieve  data  from program  memory  and  place  it  into  data  RAM.  Table reads from program memory are performed one byte at a time.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. Figure 6-4 shows  the  interface  between  the  internal  program memory and the TABLAT.\nTBLPTR points to a byte address in program space. Executing a TBLRD instruction places the byte pointed to into TABLAT. In addition, TBLPTR can be modified automatically for the next table read operation.",
    "EXAMPLE 6-1: READING A FLASH PROGRAM MEMORY WORD\n, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. , 2 = CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL. READ_WORD, 1 = READ_WORD. READ_WORD, 2 = READ_WORD. , 1 = TBLRD*+. , 2 = TBLRD*+. , 1 = MOVFW. , 2 = TABLAT. , 1 = MOVWF WORD_EVEN TBLRD*+. , 2 = MOVWF WORD_EVEN TBLRD*+. , 1 = MOVFW. , 2 = TABLAT. , 1 = MOVWF. , 2 = WORD_ODD",
    "6.4 Erasing Flash Program Memory\nThe minimum erase block size is 32 words or 64 bytes under  firmware  control.  Only  through  the  use  of  an external  programmer,  or  through  ICSP  control,  can larger blocks of program memory be bulk erased. Word erase in Flash memory is not supported.\nWhen  initiating  an  erase  sequence  from  the  microcontroller itself, a block of 64 bytes of program memory is erased. The Most Significant 16 bits of the TBLPTR<21:6>  point  to  the block being erased. TBLPTR<5:0> are ignored.\nThe EECON1 register commands the erase operation. The  EEPGD  bit  must  be  set  to  point  to  the  Flash program  memory.  The  CFGS  bit  must  be  clear  to access  program  Flash  and  data  EEPROM  memory. The WREN bit must be set to enable write operations. The FREE bit is set to select an erase operation. The WR  bit  is  set  as  part  of  the  required  instruction sequence  (as  shown  in  Example 6-2)  and  starts  the actual erase operation. It is not necessary to load the TABLAT register with any data as it is ignored.\nFor protection, the write initiate sequence  using EECON2 must be used.",
    "6.4.1 FLASH PROGRAM MEMORY ERASE SEQUENCE\nThe sequence of events for erasing a block of internal program memory location is:\n1. Load Table Pointer  with  address  of  row  being erased.\n2. Set the EECON1 register for the erase operation: \u00b7set EEPGD bit to point to program memory; \u00b7clear the CFGS bit to access program memory;\n\u2022set WREN bit to enable writes;\n\u2022set FREE bit to enable the erase.\n3. Disable interrupts.\n4. Write 55h to EECON2.\n5. Write AAh to EECON2.\n6. Set  the  WR  bit.  This  will  begin  the  row  erase cycle.\n7. The  CPU  will  stall  for  duration  of  the  erase (about 2 ms using internal timer).\n8. Execute a NOP .\n9. Re-enable interrupts.\nA long write is necessary for erasing the internal Flash. Instruction  execution  is  halted  while  in  a  long  write cycle. The long write will be terminated by the internal programming timer.",
    "EXAMPLE 6-2: ERASING A FLASH PROGRAM MEMORY ROW\nERASE_ROW, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. ERASE_ROW, 2 = CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL. ERASE_ROW, 3 = ; load TBLPTR with the base ; address of the memory block. ERASE_ROW, 1 = BSF BSF. ERASE_ROW, 2 = EECON1, EEPGD EECON1, WREN. ERASE_ROW, 3 = ; point to FLASH program memory ; enable write to memory. ERASE_ROW, 1 = BSF BCF. ERASE_ROW, 2 = EECON1, FREE INTCON, GIE. ERASE_ROW, 3 = ; enable Row Erase operation ; disable interrupts. ERASE_ROW, 1 = MOVLW MOVWF. ERASE_ROW, 2 = 55h EECON2. ERASE_ROW, 3 = ; write 55H. ERASE_ROW, 1 = MOVLW MOVWF BSF. ERASE_ROW, 2 =",
    "EXAMPLE 6-2: ERASING A FLASH PROGRAM MEMORY ROW\nAAh EECON2 EECON1, WR. ERASE_ROW, 3 = ; write AAH ; start erase (CPU stall). ERASE_ROW, 1 = . ERASE_ROW, 2 = INTCON,. ERASE_ROW, 3 = . ERASE_ROW, 1 = BSF. ERASE_ROW, 2 = . ERASE_ROW, 3 = ; re-enable. ERASE_ROW, 1 = . ERASE_ROW, 2 = GIE. ERASE_ROW, 3 = interrupts",
    "6.5 Writing to Flash Program Memory\nThe  programming  block  size  is  4  words  or  8  bytes. Word or byte programming is not supported.\nTable  writes  are  used  internally  to  load  the  holding registers needed to program the Flash memory. There are eight holding registers used by the table writes for programming.\nSince the Table Latch (TABLAT) is only a single byte, the TBLWT instruction must be executed eight times for each  programming  operation.  All  of  the  table  write operations will essentially be short writes, because only the holding registers are written. At the end of updating eight registers, the EECON1 register must be written to, to start the programming operation with a long write.\nThe  long  write  is  necessary  for  programming  the internal Flash. Instruction execution is halted while in a long write cycle. The long write will be terminated by the internal programming timer.",
    "6.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThe sequence of events for programming an internal program memory location should be:\n1. Read 64 bytes into RAM.\n2. Update data values in RAM as necessary.\n3. Load Table Pointer with address being erased.\n4. Do the row erase procedure (see Section 6.4.1 'Flash Program Memory Erase Sequence' ).\n5. Load  Table  Pointer  with  address  of  first  byte being written.\n6. Write the first 8 bytes into the holding registers with auto-increment.\n7. Set the EECON1 register for the write operation: \u00b7set EEPGD bit to point to program memory; \u00b7clear the CFGS bit to access program\nmemory;\n\u2022set WREN bit to enable byte writes.\n8. Disable interrupts.\n9. Write 55h to EECON2.\n10. Write AAh to EECON2.\n11. Set the WR bit. This will begin the write cycle.\n12. The CPU will stall for duration of the write (about 2 ms using internal timer).\n13. Execute a NOP .\n14. Re-enable interrupts.\n15. Repeat steps 6-14 seven times to write 64 bytes.\n16. Verify the memory (table read).",
    "6.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThis procedure will require about 18 ms to update one row of 64 bytes of memory. An example of the required code is given in Example 6-3.",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\nMOVWF, MOVLW = D'64 COUNTER. MOVWF, ; number of bytes in erase block = . MOVLW, MOVLW = BUFFER_ADDR_HIGH. MOVLW, ; number of bytes in erase block = ; point to buffer. MOVWF, MOVLW = FSR0H. MOVWF, ; number of bytes in erase block = . MOVLW, MOVLW = BUFFER_ADDR_LOW. MOVLW, ; number of bytes in erase block = . MOVWF, MOVLW = FSR0L. MOVWF, ; number of bytes in erase block = . MOVLW, MOVLW = CODE_ADDR_UPPER. MOVLW, ; number of bytes in erase block = ; Load TBLPTR with the base. MOVWF, MOVLW = TBLPTRU. MOVWF, ; number of bytes in erase block = ; address of the memory block. MOVLW, MOVLW = CODE_ADDR_HIGH.",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\nMOVLW, ; number of bytes in erase block = . MOVWF, MOVLW = TBLPTRH. MOVWF, ; number of bytes in erase block = . MOVLW, MOVLW = CODE_ADDR_LOW. MOVLW, ; number of bytes in erase block = ; 6 LSB = 0. MOVWF, MOVLW = TBLPTRL. MOVWF, ; number of bytes in erase block = . READ_BLOCK, MOVLW = READ_BLOCK. READ_BLOCK, ; number of bytes in erase block = . TBLRD*+, MOVLW = . TBLRD*+, ; number of bytes in erase block = ; read into TABLAT, and inc. MOVF, MOVLW = TABLAT, W. MOVF, ; number of bytes in erase block = ; get data. MOVWF, MOVLW = POSTINC0. MOVWF, ; number of bytes in erase block = ; store data and increment FSR0. DECFSZ,",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\nMOVLW = COUNTER. DECFSZ, ; number of bytes in erase block = ; done?. GOTO, MOVLW = READ_BLOCK. GOTO, ; number of bytes in erase block = repeat. MODIFY_WORD, MOVLW = . MODIFY_WORD, ; number of bytes in erase block = ;. MOVLW, MOVLW = . MOVLW, ; number of bytes in erase block = ; point to buffer. , MOVLW = DATA_ADDR_HIGH. , ; number of bytes in erase block = . MOVWF, MOVLW = FSR0H. MOVWF, ; number of bytes in erase block = . MOVLW, MOVLW = DATA_ADDR_LOW. MOVLW, ; number of bytes in erase block = . MOVWF, MOVLW = FSR0L. MOVWF, ; number of bytes in erase block = . MOVLW, MOVLW = NEW_DATA_LOW. MOVLW, ; number of bytes in erase block = update buffer word and",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\nincrement FSR0. MOVWF, MOVLW = POSTINC0. MOVWF, ; number of bytes in erase block = ;. MOVLW, MOVLW = NEW_DATA_HIGH. MOVLW, ; number of bytes in erase block = update buffer word. MOVWF, MOVLW = INDF0. MOVWF, ; number of bytes in erase block = ;. ERASE_BLOCK, MOVLW = ERASE_BLOCK. ERASE_BLOCK, ; number of bytes in erase block = . MOVLW, MOVLW = CODE_ADDR_UPPER. MOVLW, ; number of bytes in erase block = load TBLPTR with the base. MOVWF, MOVLW = TBLPTRU. MOVWF, ; number of bytes in erase block = ; ; address of the memory block. MOVLW, MOVLW = CODE_ADDR_HIGH. MOVLW, ; number of bytes in erase block = . MOVWF, MOVLW = TBLPTRH.",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\nMOVWF, ; number of bytes in erase block = . MOVLW, MOVLW = CODE_ADDR_LOW. MOVLW, ; number of bytes in erase block = 6 LSB =. MOVWF, MOVLW = TBLPTRL. MOVWF, ; number of bytes in erase block = ; 0. BCF, MOVLW = EECON1, CFGS. BCF, ; number of bytes in erase block = ; point to PROG/EEPROM memory. BSF, MOVLW = EECON1, EEPGD. BSF, ; number of bytes in erase block = ; point to FLASH program memory. BSF, MOVLW = EECON1, WREN. BSF, ; number of bytes in erase block = ; enable write to memory. BSF, MOVLW = EECON1, FREE. BSF, ; number of bytes in erase block = ; enable Row Erase operation. BCF, MOVLW = INTCON, GIE. BCF, ; number of bytes in erase block = ; disable interrupts.",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\nMOVLW, MOVLW = 55h. MOVLW, ; number of bytes in erase block = ; Required sequence. MOVWF, MOVLW = EECON2. MOVWF, ; number of bytes in erase block = ; write 55H. MOVWF, MOVLW = EECON2. MOVWF, ; number of bytes in erase block = ; write AAH. BSF, MOVLW = EECON1, WR. BSF, ; number of bytes in erase block = ; start erase (CPU stall). NOP, MOVLW = . NOP, ; number of bytes in erase block = . BSF, MOVLW = INTCON, GIE. BSF, ; number of bytes in erase block = ; re-enable interrupts. WRITE_BUFFER_BACK, MOVLW = WRITE_BUFFER_BACK. WRITE_BUFFER_BACK, ; number of bytes in erase block = . MOVLW, MOVLW = 8. MOVLW, ; number of bytes in erase block = ; number of write buffer groups of 8",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\nbytes. MOVWF, MOVLW = COUNTER_HI. MOVWF, ; number of bytes in erase block = . MOVLW, MOVLW = BUFFER_ADDR_HIGH. MOVLW, ; number of bytes in erase block = ; point to buffer. MOVWF, MOVLW = FSR0H. MOVWF, ; number of bytes in erase block = . MOVLW, MOVLW = BUFFER_ADDR_LOW. MOVLW, ; number of bytes in erase block = . MOVWF, MOVLW = FSR0L. MOVWF, ; number of bytes in erase block = . PROGRAM_LOOP, MOVLW = PROGRAM_LOOP. PROGRAM_LOOP, ; number of bytes in erase block = . MOVLW, MOVLW = 8. MOVLW, ; number of bytes in erase block = ; number of bytes in holding register. MOVWF, MOVLW = COUNTER. MOVWF, ; number of bytes in erase block = ",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\nWRITE_WORD_TO_HREGS, 1 = WRITE_WORD_TO_HREGS. MOVF POSTINC0, MOVWF TABLAT TBLWT+*, 1 = ; get low byte of buffer data and increment FSR0 ; present data to table latch ; short write ; to internal TBLWT holding register, increment TBLPTR. DECFSZ COUNTER GOTO WRITE_WORD_TO_HREGS, 1 = ; loop until buffers are full. PROGRAM_MEMORY, 1 = PROGRAM_MEMORY. BCF INTCON,, 1 = ; disable interrupts. MOVLW 55h MOVWF EECON2 MOVLW AAh MOVWF EECON2, 1 = ; required sequence ; write 55H. , 1 = ; write AAH ; start program (CPU stall). BSF DECFSZ GOTO, 1 = ; re-enable interrupts ; loop until done. INTCON, COUNTER_HI PROGRAM_LOOP BCF EECON1,, 1 = ; disable write to memory",
    "6.5.2 WRITE VERIFY\nDepending  on  the  application,  good  programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "6.5.3 UNEXPECTED TERMINATION OF WRITE OPERATION\nIf a write is terminated by an unplanned event, such as loss  of  power  or  an  unexpected  Reset,  the  memory location just programmed should be verified and reprogrammed  if  needed.  The  WRERR  bit  is  set  when  a write operation is interrupted by a MCLR Reset, or a WDT Time-out Reset during normal operation. In these situations, users can check the WRERR bit and rewrite the location.",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nTBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit 21. TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on: POR, BOR all = --00. TBLPTRU, Value on: POR, BOR all = 0000. TBLPTRU, Value on other Resets = --00. TBLPTRU, Value on other Resets = 0000. TBPLTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>).",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nTBPLTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Value on: POR, BOR all = 0000. TBPLTRH, Value on: POR, BOR all = 0000. TBPLTRH, Value on other Resets = 0000. TBPLTRH, Value on other Resets = 0000. TBLPTRL, Bit 7 =",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nProgram Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Value on: POR, BOR all = 0000. TBLPTRL, Value on: POR, BOR all = 0000. TBLPTRL, Value on other Resets = 0000. TBLPTRL,",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nValue on other Resets = 0000. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on: POR, BOR all = 0000. TABLAT, Value on: POR, BOR all = 0000. TABLAT, Value on other Resets = 0000. TABLAT, Value on other Resets = 0000. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INTE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INTF. INTCON, Bit 0 = RBIF. INTCON, Value on: POR, BOR",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nall = 0000. INTCON, Value on: POR, BOR all = 000x. INTCON, Value on other Resets = 0000. INTCON, Value on other Resets = 000u. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Value on: POR, BOR all = -. EECON2, Value on: POR, BOR all = -. EECON2, Value on other Resets =",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n-. EECON2, Value on other Resets = -. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on: POR, BOR all = xx-0 x000. EECON1, Value on: POR, BOR all = uu-0. EECON1, Value on other Resets = . EECON1, Value on other Resets = u000. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = -. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = -. IPR2, Value on: POR,",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nBOR all = 1--1 -11-. IPR2, Value on: POR, BOR all = 1--1. IPR2, Value on other Resets = . IPR2, Value on other Resets = -11-. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = -. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = -. PIR2, Value on: POR, BOR all = 0--0 -00-. PIR2, Value on: POR, BOR all = 0--0. PIR2, Value on other Resets = . PIR2, Value on other Resets = -00-. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = -.",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nPIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = -. PIE2, Value on: POR, BOR all = 0--0. PIE2, Value on: POR, BOR all = -00-. PIE2, Value on other Resets = 0--0. PIE2, Value on other Resets = -00-\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '.\nShaded cells are not used during Flash/EEPROM access.",
    "6.6 Flash Program Operation During Code Protection\nSee Section 19.0 'Special Features of the CPU' for details on code protection of Flash program memory.",
    "7.0 DATA EEPROM MEMORY\nThe  data  EEPROM  is  readable  and  writable  during normal operation over the entire VDD range. The data memory  is  not  directly  mapped  in  the  register  file space. Instead, it is  indirectly  addressed through  the Special Function Registers (SFR).\nThere  are  four  SFRs  used  to  read  and  write  the program and data EEPROM memory. These registers are:\n\u00b7 EECON1\n\u00b7 EECON2\n\u00b7 EEDATA\n\u00b7 EEADR\nThe EEPROM data memory allows byte read and write. When interfacing to the data memory block, EEDATA holds the 8-bit data for read/write and EEADR holds the address  of  the  EEPROM  location  being  accessed. These devices have 256 bytes of data EEPROM with an address range from 00h to FFh.",
    "7.0 DATA EEPROM MEMORY\nThe EEPROM data memory is rated for high  erase/ write cycle  endurance.  A  byte  write  automatically erases  the  location  and  writes  the  new  data  (erasebefore-write). The write time is controlled by an on-chip timer. The  write time will vary with voltage and temperature,  as  well  as  from  chip  to  chip.  Please refer to  parameter  D122  (Table 22-1  in Section 22.0 'Electrical Characteristics' ) for exact limits.",
    "7.1 EEADR\nThe address register can address 256  bytes of data EEPROM.",
    "7.2 EECON1 and EECON2 Registers\nEECON1 is the control register for memory accesses.\nEECON2 is not a physical register. Reading EECON2 will read  all ' 0 's. The  EECON2  register  is  used exclusively in the memory write and erase sequences.\nControl bit, EEPGD, determines if the access will be to program  or  data  EEPROM  memory.  When  clear, operations  will  access  the  data  EEPROM  memory. When set, program memory is accessed.\nControl bit, CFGS, determines if the access will be to the Configuration registers or to program memory/data EEPROM memory. When set, subsequent operations access Configuration registers. When CFGS is clear, the  EEPGD bit  selects  either  program  Flash  or  data EEPROM memory.\nThe WREN bit enables and disables erase and write operations. When set, erase and write operations are allowed. When clear, erase and write operations are disabled - the WR bit cannot be set while the WREN bit is  clear.  This  mechanism helps to prevent accidental writes  to  memory  due  to  errant  (unexpected)  code execution.",
    "7.2 EECON1 and EECON2 Registers\nFirmware should keep the WREN bit clear at all times, except when starting erase or write operations. Once firmware  has  set  the  WR  bit,  the  WREN  bit  may  be cleared.  Clearing  the  WREN  bit  will  not  affect  the operation in progress.\nThe  WRERR  bit  is  set  when  a  write  operation  is interrupted by a Reset. In these situations, the user can check  the  WRERR  bit  and  rewrite  the  location.  It  is necessary  to  reload  the  data  and  address  registers (EEDATA  and  EEADR),  as  these  registers have cleared as a result of the Reset.\nControl  bits,  RD  and  WR,  start  read  and  erase/write operations, respectively. These bits are set by firmware and  cleared  by  hardware  at  the  completion  of  the operation.\nThe  RD  bit  cannot  be  set  when  accessing  program memory (EEPGD = 1 ). Program memory is read using table read instructions. See Section 6.1 'Table Reads and Table Writes' regarding table reads.\nNote:\nInterrupt flag bit, EEIF in the PIR2 register, is set when write is complete. It must be cleared in software.",
    "REGISTER 7-1: EECON1: EEPROM CONTROL 1 REGISTER\nEEPGD, R/W-x = CFGS. EEPGD, U-0 = -. EEPGD, R/W-0 = FREE. EEPGD, R/W-x = WRERR (1). EEPGD, R/W-0 = WREN. EEPGD, R/S-0 = WR. EEPGD, R/S-0 = RD\nbit 7\nbit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. S = Bit can only be set, 1 = x = Bit is unknown. S = Bit can only be set, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = HC = Bit is cleared by hardware\nbit 7\nEEPGD: Flash Program or Data EEPROM Memory Select bit",
    "REGISTER 7-1: EECON1: EEPROM CONTROL 1 REGISTER\n1 = Access program Flash memory\n0 = Access data EEPROM memory\nbit 6\nCFGS: Flash Program/Data EEPROM or Configuration Select bit\n1 = Accesses Configuration, User ID and Device ID Registers\n0 = Accesses Flash Program or data EEPROM Memory",
    "bit 4 FREE: Flash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation - TBLPTR<5:0> are ignored)\n0 = Perform write only",
    "bit 3 WRERR: EEPROM Error Flag bit (1)\n1\n=\nA write operation was prematurely terminated (any Reset during self-timed programming)\n0 = The write operation completed normally",
    "bit 2\nWREN: Program/Erase Enable bit\n1 = Allows program/erase cycles\n0 = Inhibits programming/erasing of program Flash and data EEPROM",
    "bit 1\nWR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle. (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle completed",
    "bit 0 RD: Read Control bit\n1 = Initiates a memory read\n(Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1 .)\n0 = Read completed",
    "7.3 Reading the Data EEPROM Memory\nTo read a data memory location, the user must write the address  to  the  EEADR  register,  clear  the  EEPGD control bit (EECON1<7>) and then set control bit, RD (EECON1<0>). The data is available for the very next instruction  cycle;  therefore,  the  EEDATA register can be read by the next instruction. EEDATA will hold this value until another read operation, or until it is written to by the user (during a write operation).",
    "7.4 Writing to the Data EEPROM Memory\nTo write an EEPROM data location, the address must first  be  written  to  the  EEADR  register  and  the  data written  to  the  EEDATA  register.  The  sequence  in Example 7-2 must be followed to initiate the write cycle.\nThe write will not begin if this sequence is not exactly followed (write 55h to EECON2, write AAh to EECON2, then  set  WR  bit)  for  each  byte.  It  is  strongly  recommended that interrupts be disabled during this code segment.\nAdditionally, the WREN bit in EECON1 must be set to enable  writes.  This  mechanism  prevents  accidental writes to data EEPROM due to unexpected code execution (i.e., runaway programs). The WREN bit should be kept clear  at  all  times,  except  when  updating  the EEPROM. The WREN bit is not cleared by hardware.\nAfter  a  write  sequence  has  been  initiated,  EECON1, EEADR and EEDATA cannot be modified. The WR bit will be inhibited from being set unless the WREN bit is set. The WREN bit must be set on a previous instruction. Both WR and WREN cannot be set with the same instruction.",
    "7.4 Writing to the Data EEPROM Memory\nAt  the  completion  of  the  write  cycle,  the  WR  bit  is cleared in hardware and the EEPROM Interrupt Flag bit (EEIF) is set. The user may either enable this interrupt or poll this bit. EEIF must be cleared by software.",
    "7.5 Write Verify\nDepending  on  the  application,  good  programming practice  may  dictate  that  the  value  written  to  the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "7.6 Protection Against Spurious Write\nThere are conditions when the device may not want to write to the data EEPROM memory. To protect against spurious EEPROM writes, various mechanisms have been built-in. On power-up, the WREN bit is cleared. Also,  the  Power-up  Timer  (72 ms  duration)  prevents EEPROM write.\nThe write initiate sequence and the WREN bit together help  prevent  an  accidental  write  during  brown-out, power glitch or software malfunction.",
    "EXAMPLE 7-1: DATA EEPROM READ\nMOVLW, 1 = DATA_EE_ADDR;. MOVWF, 1 = EEADR ; Data Memory Address to read. BCF, 1 = EECON1, EEPGD; Point to DATA memory. BSF, 1 = EECON1, RD ; EEPROM Read. MOVF, 1 = EEDATA, W ; W = EEDATA",
    "EXAMPLE 7-2: DATA EEPROM WRITE\n, 1 = MOVLW MOVWF MOVLW MOVWF. , 2 = DATA_EE_ADDR;. , 1 = . , 2 = EEADR ; Data Memory Address to write. , 1 = . , 2 = DATA_EE_DATA;. , 1 = . , 2 = EEDATA ; Data Memory Value to write. , 1 = BCF. , 2 = EECON1, EEPGD; Point to DATA memory. , 1 = BSF. , 2 = EECON1, WREN;. , 1 = BCF. , 2 = INTCON, GIE; Disable Interrupts. , 1 = MOVLW. , 2 = 55h ;. Required Sequence, 1 = MOVWF. Required Sequence, 2 = EECON2 ;. Required Sequence, 1 = MOVLW. Required Sequence, 2 = AAh ;. Required Sequence, 1 = MOVWF. Required Sequence, 2 = EECON2 ; Write. Required Sequence, 1 = BSF. Required Sequence, 2 = EECON1, WR ; Set WR bit to begin write. Required Sequence, 1 = BSF.",
    "EXAMPLE 7-2: DATA EEPROM WRITE\nRequired Sequence, 2 = INTCON, GIE; Enable. Required Sequence, 1 = SLEEP. Required Sequence, 2 = ; Wait for interrupt to signal write complete Disable writes. Required Sequence, 1 = BCF. Required Sequence, 2 = EECON1, WREN;",
    "7.7 Operation During Code-Protect\nData EEPROM memory has its own code-protect bits in Configuration Words. External read and write operations are disabled if either of these mechanisms are enabled.\nThe microcontroller itself can both read and write to the internal data EEPROM, regardless of the state of the code-protect Configuration bit. Refer to Section 19.0 'Special Features of the CPU' for additional information.",
    "7.8 Using the Data EEPROM\nThe data EEPROM is a high endurance, byte addressable array that has been optimized for the storage of frequently changing information (e.g., program variables or other data that are updated often). Frequently changing values will typically be updated more often than specification D124. If this is not the case, an array refresh must be  performed.  For  this  reason,  variables  that  change infrequently  (such  as  constants,  IDs,  calibration,  etc.) should be stored in Flash program memory.\nA  simple  data  EEPROM  refresh  routine  is  shown  in Example 7-3.\nNote:\nIf data  EEPROM  is  only  used  to  store constants and/or data that changes rarely, an array refresh is likely not required. See specification D124.",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INTE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INTF. INTCON, Bit 0 = RBIF. INTCON, Value on: POR, BOR = 0000 000x. INTCON, Value on all other Resets = 0000 000u. EEADR, Bit 7 = EEPROM Address Register. EEADR, Bit 6 = EEPROM Address Register. EEADR, Bit 5 = EEPROM Address Register. EEADR, Bit 4 = EEPROM Address Register. EEADR, Bit 3 = EEPROM Address Register. EEADR, Bit 2 = EEPROM Address Register. EEADR, Bit 1 = EEPROM Address Register. EEADR, Bit 0 = EEPROM Address Register. EEADR, Value on: POR, BOR = 0000 0000. EEADR, Value on all",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nother Resets = 0000 0000. EEDATA, Bit 7 = EEPROM Data Register. EEDATA, Bit 6 = EEPROM Data Register. EEDATA, Bit 5 = EEPROM Data Register. EEDATA, Bit 4 = EEPROM Data Register. EEDATA, Bit 3 = EEPROM Data Register. EEDATA, Bit 2 = EEPROM Data Register. EEDATA, Bit 1 = EEPROM Data Register. EEDATA, Bit 0 = EEPROM Data Register. EEDATA, Value on: POR, BOR = 0000 0000. EEDATA, Value on all other Resets = 0000 0000. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nregister). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Value on: POR, BOR = -. EECON2, Value on all other Resets = -. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on: POR, BOR = xx-0 x000. EECON1, Value on all other Resets = uu-0 u000. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 =",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nEEIP. IPR2, Bit 3 = -. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = -. IPR2, Value on: POR, BOR = 1--1 -11-. IPR2, Value on all other Resets = 1--1 -11-. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = -. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = -. PIR2, Value on: POR, BOR = 0--0 -00-. PIR2, Value on all other Resets = 0--0 -00-. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE.",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nPIE2, Bit 3 = -. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = -. PIE2, Value on: POR, BOR = 0--0 -00-. PIE2, Value on all other Resets = 0--0 -00-\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used during Flash/EEPROM access.",
    "8.1 Introduction\nAn 8 x 8 hardware multiplier is included in the ALU of the PIC18F1220/1320 devices. By making the multiply a hardware operation, it completes in a single instruction  cycle.  This  is  an  unsigned  multiply  that  gives  a 16-bit result. The result is stored into the 16-bit product register pair (PRODH:PRODL). The multiplier does not affect any flags in the Status register.\nMaking the 8 x 8 multiplier execute in a single cycle gives the following advantages:\n\u00b7 Higher computational throughput\n\u00b7 Reduces code size requirements for multiply algorithms\nThe performance increase allows the device to be used in  applications  previously  reserved  for  Digital  Signal Processors.\nTable 8-1 shows a performance comparison between Enhanced  devices  using  the  single-cycle  hardware multiply and performing the same function without the hardware multiply.",
    "TABLE 8-1: PERFORMANCE COMPARISON\n8 x 8 unsigned, Multiply Method = Without hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 13. 8 x 8 unsigned, Cycles (Max). = 69. 8 x 8 unsigned, Time.@40 MHz = 6.9 \uf06d s. 8 x 8 unsigned, Time.@10 MHz = 27.6 \uf06d s. 8 x 8 unsigned, Time.@4MHz = 69 \uf06d s. 8 x 8 unsigned, Multiply Method = Hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 1. 8 x 8 unsigned, Cycles (Max). = 1. 8 x 8 unsigned, Time.@40 MHz = 100 ns. 8 x 8 unsigned, Time.@10 MHz = 400 ns. 8 x 8 unsigned, Time.@4MHz = 1 \uf06d s. 8 x 8 signed, Multiply Method = Without hardware multiply. 8 x 8 signed, Program Memory (Words). = 33. 8 x 8 signed, Cycles (Max). = 91. 8 x 8 signed, Time.@40 MHz = 9.1 \uf06d s. 8 x 8 signed, Time.@10 MHz = 36.4 \uf06d s. 8 x 8",
    "TABLE 8-1: PERFORMANCE COMPARISON\nsigned, Time.@4MHz = 91 \uf06d s. 8 x 8 signed, Multiply Method = Hardware multiply. 8 x 8 signed, Program Memory (Words). = 6. 8 x 8 signed, Cycles (Max). = 6. 8 x 8 signed, Time.@40 MHz = 600 ns. 8 x 8 signed, Time.@10 MHz = 2.4 \uf06d s. 8 x 8 signed, Time.@4MHz = 6 \uf06d s. 16 x 16 unsigned, Multiply Method = Without hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 21. 16 x 16 unsigned, Cycles (Max). = 242. 16 x 16 unsigned, Time.@40 MHz = 24.2 \uf06d s. 16 x 16 unsigned, Time.@10 MHz = 96.8 \uf06d s. 16 x 16 unsigned, Time.@4MHz = 242 \uf06d s. 16 x 16 unsigned, Multiply Method = Hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 28. 16 x 16 unsigned, Cycles (Max). = 28. 16 x 16 unsigned, Time.@40 MHz = 2.8 \uf06d s. 16 x 16 unsigned,",
    "TABLE 8-1: PERFORMANCE COMPARISON\nTime.@10 MHz = 11.2 \uf06d s. 16 x 16 unsigned, Time.@4MHz = 28 \uf06d s. 16 x 16 signed, Multiply Method = Without hardware multiply. 16 x 16 signed, Program Memory (Words). = 52. 16 x 16 signed, Cycles (Max). = 254. 16 x 16 signed, Time.@40 MHz = 25.4 \uf06d s. 16 x 16 signed, Time.@10 MHz = 102.6 \uf06d s. 16 x 16 signed, Time.@4MHz = 254 \uf06d s. 16 x 16 signed, Multiply Method = Hardware multiply. 16 x 16 signed, Program Memory (Words). = 35. 16 x 16 signed, Cycles (Max). = 40. 16 x 16 signed, Time.@40 MHz = 4 \uf06d s. 16 x 16 signed, Time.@10 MHz = 16 \uf06d s. 16 x 16 signed, Time.@4MHz = 40 \uf06d s",
    "8.2 Operation\nExample 8-1  shows  the  sequence  to  do  an  8  x  8 unsigned  multiply.  Only  one  instruction  is  required when one argument of the multiply is already loaded in the WREG register.",
    "EXAMPLE 8-2: 8 x 8 SIGNED MULTIPLY ROUTINE\nExample 8-2 shows the sequence to do an 8 x 8 signed multiply. To account for the sign bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "EXAMPLE 8-1: 8 x 8 UNSIGNED MULTIPLY ROUTINE\nMOVF, 1 = ARG1, W. MOVF, 2 = ;. MULWF, 1 = ARG2. MULWF, 2 = ; ARG1 * ARG2 ->. , 1 = . , 2 = ; PRODH:PRODL\nMOVF MULWF, 1 = ARG1, W ARG2. MOVF MULWF, 2 = ; ARG1 * ARG2 -> ; PRODH:PRODL. BTFSC SUBWF, 1 = ARG2, SB PRODH, F. BTFSC SUBWF, 2 = ; Test Sign Bit ; PRODH = PRODH ; - ARG1. MOVF BTFSC SUBWF, 1 = ARG2, W ARG1, SB PRODH, F. MOVF BTFSC SUBWF, 2 = ; Test Sign Bit ; PRODH = PRODH ; - ARG2",
    "EXAMPLE 8-1: 8 x 8 UNSIGNED MULTIPLY ROUTINE\nExample 8-3  shows  the  sequence  to  do  a  16  x  16 unsigned  multiply.  Equation 8-1  shows  the  algorithm that is used. The 32-bit result is stored in four registers, RES3:RES0.",
    "EQUATION 8-1:\n16 x 16 UNSIGNED MULTIPLICATION ALGORITHM",
    "RES3:RES0\n=\nARG1H:ARG1L   ARG2H:ARG2L \uf0b7\n=\n(ARG1H   ARG2H   2 16 ) + \uf0b7 \uf0b7\n(ARG1H   ARG2L   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2H   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2L) \uf0b7",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVFARG1L, W MULWFARG2L, 1 = ; ARG1L * ARG2L -> ; PRODH:PRODL. MOVFFPRODH, RES1, 1 = ;. MOVFFPRODL, RES0, 1 = ;. MOVFARG1H, W MULWFARG2H, 1 = ; ARG1H * ARG2H -> ; PRODH:PRODL. MOVFFPRODH, RES3, 1 = ;. MOVFFPRODL, RES2, 1 = ;. MOVFARG1L, W MULWFARG2H, 1 = ; ARG1L * ARG2H -> ; PRODH:PRODL. MOVFPRODL, W, 1 = ;. ADDWFRES1, F, 1 = ; Add cross. MOVFPRODH, W, 1 = ; products. ADDWFCRES2, F, 1 = ;. CLRFWREG, 1 = ;. ADDWFCRES3,F, 1 = ;. MOVFARG1H, W,",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\n1 = ;. MULWFARG2L, 1 = ; ARG1H * ARG2L -> ; PRODH:PRODL. MOVFPRODL, W, 1 = ;. ADDWFRES1, F, 1 = ; Add cross. MOVFPRODH, W, 1 = ; products. ADDWFCRES2, F CLRFWREG, 1 = ;. , 1 = ;. ADDWFCRES3, F, 1 = ;\nExample 8-4  shows  the  sequence  to  do  a  16  x  16 signed  multiply.  Equation 8-2  shows  the  algorithm used.  The  32-bit  result  is  stored  in  four  registers, RES3:RES0. To account for the sign bits of the arguments, each argument pairs' Most Significant bit (MSb) is tested and the appropriate subtractions are done.\nEQUATION 8-2:\n16 x 16 SIGNED MULTIPLICATION ALGORITHM",
    "RES3:RES0\n=\nARG1H:ARG1L   ARG2H:ARG2L \uf0b7\n=\n(ARG1H   ARG2H   2 16 ) + \uf0b7 \uf0b7\n(ARG1H   ARG2L   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2H   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2L) + \uf0b7\n(-1 \uf0b7 ARG2H<7>   ARG1H:ARG1L   2 16 ) + \uf0b7 \uf0b7\n(-1 \uf0b7 ARG1H<7>   ARG2H:ARG2L   2 16 ) \uf0b7 \uf0b7",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nMOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1L * ARG2L ->. , 1 = . , 2 = . , 3 = ;. , 4 = PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES1. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES0. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 =",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nARG1H * ARG2H ->. , 1 = . , 2 = . , 3 = ;. , 4 = PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES3. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES2. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1L * ARG2H ->. , 1 = . , 2 = . , 3 = ;. , 4 = PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= RES1,. ADDWF, 2 = F. ADDWF, 3 = ;. ADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1H * ARG2L ->. , 1 = .",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n, 2 = . , 3 = ;. , 4 = PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF MOVF, 1 = RES1,. ADDWF MOVF, 2 = F. ADDWF MOVF, 3 = ;. ADDWF MOVF, 4 = Add cross products. ADDWFC, 1 = PRODH,. ADDWFC, 2 = W. ADDWFC, 3 = ; ;. ADDWFC, 4 = . , 1 = RES2,. , 2 = F. , 3 = . , 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . BTFSS, 1 = ARG2H,. BTFSS, 2 = 7. BTFSS, 3 = ;.",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nBTFSS, 4 = ARG2H:ARG2L neg?. BRA, 1 = SIGN_ARG1. BRA, 2 = . BRA, 3 = ;. BRA, 4 = no, check ARG1. MOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . SUBWF, 1 = RES2. SUBWF, 2 = . SUBWF, 3 = ;. SUBWF, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . SUBWFB, 1 = RES3. SUBWFB, 2 = . SUBWFB, 3 = . SUBWFB, 4 = . SIGN_ARG1, 1 = . SIGN_ARG1, 2 = . SIGN_ARG1, 3 = . SIGN_ARG1, 4 = . BTFSS, 1 = ARG1H,. BTFSS, 2 = 7. BTFSS, 3 =",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n;. BTFSS, 4 = ARG1H:ARG1L neg?. BRA, 1 = CONT_CODE. BRA, 2 = . BRA, 3 = ;. BRA, 4 = no, done. MOVF, 1 = ARG2L,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . SUBWF, 1 = RES2. SUBWF, 2 = . SUBWF, 3 = ;. SUBWF, 4 = . MOVF, 1 = ARG2H,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . SUBWFB, 1 = RES3. SUBWFB, 2 = . SUBWFB, 3 = . SUBWFB, 4 = . ; CONT_CODE, 1 = . ; CONT_CODE, 2 = . ; CONT_CODE, 3 = . ; CONT_CODE, 4 = . :, 1 = . :, 2 = . :, 3 = . :, 4 = ",
    "9.0 INTERRUPTS\nThe PIC18F1220/1320 devices have multiple interrupt sources  and  an  interrupt  priority  feature  that  allows each  interrupt  source  to  be  assigned  a  high  priority level or a low priority level. The high priority interrupt vector is at 000008h and the low priority interrupt vector is at 000018h.  High  priority interrupt events will interrupt any low priority interrupts that may be in progress.\nThere  are  ten  registers  which  are  used  to  control interrupt operation. These registers are:\n\u00b7 RCON\n\u00b7 INTCON\n\u00b7 INTCON2\n\u00b7 INTCON3\n\u00b7 PIR1, PIR2\n\u00b7 PIE1, PIE2\n\u00b7 IPR1, IPR2\nIt is  recommended  that  the  Microchip  header  files supplied with MPLAB \u00ae  IDE be used for the symbolic bit names in these registers. This allows the assembler/ compiler to automatically take care of the placement of these bits within the specified register.\nIn  general,  each  interrupt  source  has  three  bits  to control its operation. The functions of these bits are:",
    "9.0 INTERRUPTS\n\u00b7 Flag bit to indicate that an interrupt event occurred\n\u00b7 Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\n\u00b7 Priority bit to select high priority or low priority (INT0 has no priority bit and is always high priority)\nThe interrupt priority feature is enabled by setting the IPEN bit (RCON<7>). When  interrupt priority is enabled,  there  are  two  bits  which  enable  interrupts globally. Setting the GIEH bit (INTCON<7>) enables all interrupts  that  have  the  priority  bit  set  (high  priority). Setting the GIEL bit (INTCON<6>) enables all interrupts that have the priority bit cleared (low priority). When  the  interrupt  flag,  enable  bit  and  appropriate Global  Interrupt  Enable  bit  are  set,  the  interrupt  will vector  immediately  to  address  000008h  or  000018h, depending on the priority bit setting. Individual interrupts can be disabled through their corresponding enable bits.",
    "9.0 INTERRUPTS\nWhen  the  IPEN  bit  is  cleared  (default  state),  the interrupt priority feature is disabled and interrupts are compatible with PIC mid-range devices. In Compatibility mode, the interrupt priority bits for each source  have  no  effect.  INTCON<6>  is  the  PEIE  bit, which enables/disables all peripheral interrupt sources. INTCON<7> is the GIE bit, which enables/disables all interrupt  sources.  All  interrupts  branch  to  address 000008h in Compatibility mode.\nWhen an interrupt is responded to, the Global Interrupt Enable bit is cleared to disable further interrupts. If the IPEN bit is cleared, this is the GIE bit. If interrupt priority levels are used, this will be either the GIEH or GIEL bit. High  priority  interrupt  sources  can  interrupt  a  low priority interrupt. Low priority interrupts are not processed while high priority interrupts are in progress.",
    "9.0 INTERRUPTS\nThe return address is pushed onto the stack and the PC  is loaded with the interrupt vector address (000008h or 000018h). Once in the Interrupt Service Routine,  the  source(s)  of  the  interrupt  can  be  determined by polling the  interrupt  flag  bits.  The  interrupt flag bits must be cleared in software before re-enabling interrupts to avoid recursive interrupts.\nThe 'return  from  interrupt'  instruction, RETFIE ,  exits the  interrupt  routine  and  sets  the  GIE  bit  (GIEH  or GIEL,  if  priority  levels  are  used),  which  re-enables interrupts.\nFor external interrupt events, such as the INT pins or the PORTB input change interrupt, the interrupt latency will be  three  to  four  instruction  cycles.  The  exact latency is the same for one or 2-cycle instructions. Individual interrupt flag bits are set, regardless of the status of their corresponding enable bit or the GIE bit.\nNote:\nDo  not  use  the MOVFF instruction to modify any of the interrupt control registers while any interrupt is enabled. Doing so may cause erratic microcontroller behavior.",
    "9.1 INTCON Registers\nThe  INTCON  registers  are  readable  and  writable registers,  which  contain  various  enable,  priority  and flag bits.\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the Global Interrupt Enable bit. User software should ensure the appropriate interrupt  flag  bits are  clear  prior  to  enabling  an  interrupt. This feature allows for software polling.",
    "REGISTER 9-1: INTCON: INTERRUPT CONTROL REGISTER\nGIE/GIEH, R/W-0/0 = PEIE/GIEL. GIE/GIEH, R/W-0/0 = TMR0IE. GIE/GIEH, R/W-0/0 = INT0IE. GIE/GIEH, R/W-0/0 = RBIE. GIE/GIEH, R/W-0/0 = TMR0IF. GIE/GIEH, R/W-0/0 = INT0IF. GIE/GIEH, R-0/0 = RBIF (1)\nbit 7\nbit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7 GIE/GIEH: Global Interrupt Enable bit\nWhen IPEN = 0 :\n1 = Enables all unmasked interrupts\n0 = Disables all interrupts",
    "When IPEN = 1 :\n1 = Enables all high priority interrupts\n0 = Disables all interrupts",
    "bit 6 PEIE/GIEL: Peripheral Interrupt Enable bit\nWhen IPEN = 0 :\n1 = Enables all unmasked peripheral interrupts\n0 = Disables all peripheral interrupts\nWhen IPEN = 1 :\n1 = Enables all low priority peripheral interrupts\n0 = Disables all low priority peripheral interrupts",
    "bit 5 TMR0IE: TMR0 Overflow Interrupt Enable bit\n1 = Enables the TMR0 overflow interrupt\n0 = Disables the TMR0 overflow interrupt",
    "bit 4 INT0IE: INT0 External Interrupt Enable bit\n1 = Enables the INT0 external interrupt\n0 = Disables the INT0 external interrupt",
    "bit 3\nRBIE: RB Port Change Interrupt Enable bit\n1 = Enables the RB port change interrupt\n0 = Disables the RB port change interrupt",
    "bit 2 TMR0IF: Timer0 Overflow Interrupt Flag bit\n1 = TMR0 register has overflowed\n0 = TMR0 register did not overflow",
    "bit 1\nINT0IF: INT0 External Interrupt Flag bit\n1 = The INT0 external interrupt occurred (must be cleared in software)\n0 = The INT0 external interrupt did not occur",
    "bit 0\nRBIF: RB Port Change Interrupt Flag bit (1)\n1 = At least one of the RB<7:4> pins changed state (must be cleared in software)\n0 = None of the RB<7:4> pins have changed state\nNote 1: A mismatch condition will continue to set this bit. Reading PORTB will end the mismatch condition and allow the bit to be cleared.",
    "REGISTER 9-2:\nINTCON2: INTERRUPT CONTROL REGISTER 2\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = U-0. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = U-0. R/W-1/1, 7 = R/W-1/1. RBPU, 1 = INTEDG0. RBPU, 2 = INTEDG1. RBPU, 3 = INTEDG2. RBPU, 4 = -. RBPU, 5 = TMR0IP. RBPU, 6 = -. RBPU, 7 = RBIP. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7 RBPU: PORTB Pull-up Enable bit\n1 = All PORTB pull-ups are disabled\n0 = PORTB pull-ups are enabled by individual port latch values\nbit 6\nINTEDG0: External Interrupt 0 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 5\nINTEDG1: External Interrupt 1 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 4\nINTEDG2: External Interrupt 2 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 3\nUnimplemented: Read as ' 0 '\nbit 2\nTMR0IP: TMR0 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nUnimplemented: Read as ' 0 '\nbit 0\nRBIP: RB Port Change Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "Note:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the Global Interrupt Enable bit. User software should ensure the appropriate interrupt flag bits are  clear  prior  to  enabling  an  interrupt. This feature allows for software polling.",
    "REGISTER 9-3: INTCON3: INTERRUPT CONTROL REGISTER 3\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = U-0. R/W-1/1, 3 = R/W-0/0. R/W-1/1, 4 = R/W-0/0. R/W-1/1, 5 = U-0. R/W-1/1, 6 = R/W-0/0. R/W-1/1, 7 = R/W-0/0. INT2IP, 1 = INT1IP. INT2IP, 2 = -. INT2IP, 3 = INT2IE. INT2IP, 4 = INT1IE. INT2IP, 5 = -. INT2IP, 6 = INT2IF. INT2IP, 7 = INT1IF\nbit 7\nbit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7\nINT2IP: INT2 External Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 6\nINT1IP: INT1 External Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 4 INT2IE: INT2 External Interrupt Enable bit\n1 = Enables the INT2 external interrupt\n0 = Disables the INT2 external interrupt",
    "bit 3 INT1IE: INT1 External Interrupt Enable bit\n1 = Enables the INT1 external interrupt\n0 = Disables the INT1 external interrupt",
    "bit 2 Unimplemented: Read as ' 0 '\nbit 1\nINT2IF: INT2 External Interrupt Flag bit\n1 = The INT2 external interrupt occurred (must be cleared in software)\n0 = The INT2 external interrupt did not occur",
    "bit 0\nINT1IF: INT1 External Interrupt Flag bit\n1 = The INT1 external interrupt occurred (must be cleared in software)\n0 = The INT1 external interrupt did not occur",
    "Note:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the Global Interrupt Enable bit. User software should ensure the appropriate interrupt flag bits are  clear  prior  to  enabling  an  interrupt. This feature allows for software polling.",
    "9.2 PIR Registers\nThe PIR registers contain the individual flag bits for the peripheral interrupts. Due to the number of peripheral interrupt  sources,  there  are  two  Peripheral  Interrupt Request (Flag) registers (PIR1, PIR2).\nNote 1: Interrupt flag bits are  set  when an interrupt  condition  occurs,  regardless  of  the state of its corresponding enable bit or the Global Interrupt Enable bit, GIE (INTCON<7>).\n2: User software should ensure the appropriate interrupt flag bits are cleared prior to enabling an interrupt and after servicing that interrupt.",
    "REGISTER 9-4: PIR1: PERIPHERAL INTERRUPT REQUEST REGISTER 1\nU-0, 1 = R/W-0/0. U-0, 2 = R-0/0. U-0, 3 = R-0/0. U-0, 4 = U-0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = ADIF. -, 2 = RCIF. -, 3 = TXIF. -, 4 = -. -, 5 = CCP1IF. -, 6 = TMR2IF. -, 7 = TMR1IF. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 9-4: PIR1: PERIPHERAL INTERRUPT REQUEST REGISTER 1\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6\nADIF: A/D Converter Interrupt Flag bit\n1 0 =The A/D conversion is not complete\n= An A/D conversion completed (must be cleared in software)\nbit 5\nRCIF: EUSART Receive Interrupt Flag bit\n1 = The EUSART receive buffer, RCREG, is full (cleared when RCREG is read)\n0 = The EUSART receive buffer is empty",
    "bit 4\nTXIF: EUSART Transmit Interrupt Flag bit\n1 = The EUSART transmit buffer, TXREG, is empty (cleared when TXREG is written)\n0 = The EUSART transmit buffer is full",
    "bit 3\nUnimplemented: Read as ' 0 '\nbit 2\nCCP1IF: CCP1 Interrupt Flag bit\nCapture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n0 = No TMR1 register capture occurred",
    "Compare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n0 = No TMR1 register compare match occurred",
    "PWM mode:\nUnused in this mode.\nbit 1\nTMR2IF: TMR2 to PR2 Match Interrupt Flag bit\n1 = TMR2 to PR2 match occurred (must be cleared in software)\n0 = No TMR2 to PR2 match occurred\nbit 0\nTMR1IF: TMR1 Overflow Interrupt Flag bit\n1 = TMR1 register overflowed (must be cleared in software)\n0 = TMR1 register did not overflow",
    "REGISTER 9-5: PIR2: PERIPHERAL INTERRUPT REQUEST REGISTER 2\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = U-0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = U-0. OSCFIF, 1 = -. OSCFIF, 2 = -. OSCFIF, 3 = EEIF. OSCFIF, 4 = -. OSCFIF, 5 = LVDIF. OSCFIF, 6 = TMR3IF. OSCFIF, 7 = -. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 9-5: PIR2: PERIPHERAL INTERRUPT REQUEST REGISTER 2\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = ",
    "bit 7 OSCFIF: Oscillator Fail Interrupt Flag bit\n1 = System oscillator failed, clock input has changed to INTOSC (must be cleared in software) 0 = System clock operating",
    "bit 6-5\nUnimplemented: Read as ' 0 '",
    "bit 4 EEIF: Data EEPROM/Flash Write Operation Interrupt Flag bit\n1 = The write operation is complete (must be cleared in software)\n0 = The write operation is not complete or has not been started",
    "bit 3 Unimplemented: Read as ' 0 '\nbit 2\nLVDIF: Low-Voltage Detect Interrupt Flag bit\n1 = A low-voltage condition occurred (must be cleared in software)\n0 = The device voltage is above the Low-Voltage Detect trip point",
    "bit 1\nTMR3IF: TMR3 Overflow Interrupt Flag bit\n1 = TMR3 register overflowed (must be cleared in software)\n0 = TMR3 register did not overflow\nbit 0 Unimplemented: Read as ' 0 '",
    "9.3 PIE Registers\nThe PIE registers contain the individual enable bits for the peripheral interrupts. Due  to the number  of peripheral interrupt sources, there are two Peripheral Interrupt Enable registers (PIE1, PIE2). When IPEN = 0 ,  the  PEIE  bit  must be  set to enable any of these peripheral interrupts.",
    "REGISTER 9-6: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nU-0, 1 = R/W-0/0. U-0, 2 = R/W-0/0. U-0, 3 = R/W-0/0. U-0, 4 = U-0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = ADIE. -, 2 = RCIE. -, 3 = TXIE. -, 4 = -. -, 5 = CCP1IE. -, 6 = TMR2IE. -, 7 = TMR1IE. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 9-6: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nR = Readable bit, W=Writable bit = x = Bit is. R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = \nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nADIE: A/D Converter Interrupt Enable bit\n1 = Enables the A/D interrupt\n0 = Disables the A/D interrupt\nbit 5 RCIE: EUSART Receive Interrupt Enable bit\n1 = Enables the EUSART receive interrupt\n0 = Disables the EUSART receive interrupt\nbit 4\nTXIE: EUSART Transmit Interrupt Enable bit\n1 = Enables the EUSART transmit interrupt",
    "REGISTER 9-6: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\n0 = Disables the EUSART transmit interrupt\nbit 3 Unimplemented: Read as ' 0 '\nbit 2\nCCP1IE: CCP1 Interrupt Enable bit\n1 = Enables the CCP1 interrupt\n0 = Disables the CCP1 interrupt\nbit 1\nTMR2IE: TMR2 to PR2 Match Interrupt Enable bit\n1 = Enables the TMR2 to PR2 match interrupt\n0 = Disables the TMR2 to PR2 match interrupt\nbit 0\nTMR1IE: TMR1 Overflow Interrupt Enable bit\n1 = Enables the TMR1 overflow interrupt\n0 = Disables the TMR1 overflow interrupt",
    "REGISTER 9-7:\nPIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = U-0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = U-0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = U-0. OSCFIE, 1 = -. OSCFIE, 2 = -. OSCFIE, 3 = EEIE. OSCFIE, 4 = -. OSCFIE, 5 = LVDIE. OSCFIE, 6 = TMR3IE. OSCFIE, 7 = -. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 9-7:\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7 OSCFIE: Oscillator Fail Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 6-5\nUnimplemented: Read as ' 0 '\nbit 4 EEIE: Data EEPROM/Flash Write Operation Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 3\nUnimplemented: Read as ' 0 '\nbit 2\nLVDIE: Low-Voltage Detect Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 1\nTMR3IE: TMR3 Overflow Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 0 Unimplemented: Read as ' 0 '",
    "9.4 IPR Registers\nThe IPR registers contain the individual priority bits for the peripheral interrupts. Due  to the number  of peripheral interrupt sources, there are two Peripheral Interrupt  Priority  registers  (IPR1,  IPR2).  Using  the priority  bits  requires  that  the  Interrupt  Priority  Enable (IPEN) bit be set.",
    "REGISTER 9-8: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nU-0, 1 = R/W-1/1. U-0, 2 = R/W-1/1. U-0, 3 = R/W-1/1. U-0, 4 = U-0. U-0, 5 = R/W-1/1. U-0, 6 = R/W-1/1. U-0, 7 = R/W-1/1. -, 1 = ADIP. -, 2 = RCIP. -, 3 = TXIP. -, 4 = -. -, 5 = CCP1IP. -, 6 = TMR2IP. -, 7 = TMR1IP. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 9-8: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit, Unimplemented bit, read as '0' = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged, Unimplemented bit, read as '0' = . '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, Unimplemented bit, read as '0' = \nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nADIP: A/D Converter Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nRCIP: EUSART Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4\nTXIP: EUSART Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3 Unimplemented: Read as ' 0 '\nbit 2\nCCP1IP: CCP1 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-8: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nbit 1\nTMR2IP: TMR2 to PR2 Match Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nTMR1IP: TMR1 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 9-9: IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nR/W-1/1, 1 = U-0. R/W-1/1, 2 = U-0. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = U-0. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = U-0. OSCFIP, 1 = -. OSCFIP, 2 = -. OSCFIP, 3 = EEIP. OSCFIP, 4 = -. OSCFIP, 5 = LVDIP. OSCFIP, 6 = TMR3IP. OSCFIP, 7 = -. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 9-9: IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nR = Readable bit, W=Writable bit = . R = Readable bit, = Unimplemented bit, read as '0' = U. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, = Unimplemented bit, read as '0' = ",
    "bit 7 OSCFIP: Oscillator Fail Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6-5\nUnimplemented: Read as ' 0 '\nbit 4\nEEIP: Data EEPROM/Flash Write Operation Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 3\nUnimplemented: Read as ' 0 '\nbit 2\nLVDIP: Low-Voltage Detect Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR3IP: TMR3 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nUnimplemented: Read as ' 0 '",
    "9.5 RCON Register\nThe RCON register contains bits used to determine the cause of the last Reset or wake-up from a low-power mode.  RCON  also  contains  the  bit that enables interrupt priorities (IPEN).",
    "REGISTER 9-10: RCON: RESET CONTROL REGISTER\nIPEN, U-0 = -. IPEN, U-0 = -. IPEN, R/W-1 = RI. IPEN, R-1 = TO. IPEN, R-1 = PD. IPEN, R/W-0 = POR. IPEN, R/W-0 = BOR. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R-1 = bit 7. bit 7, R-1 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0\nR = Readable bit, W=Writable bit = x = Bit is unknown. R = Readable bit,  = U =. u = Bit is unchanged, W=Writable bit = . u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7",
    "REGISTER 9-10: RCON: RESET CONTROL REGISTER\nIPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16CXXX Compatibility mode)\nbit 6-5\nUnimplemented: Read as ' 0 '\nbit 4\nRI:\nRESET Instruction Flag bit\nFor details of bit operation, see Register 5-3.\nbit 3\nTO: Watchdog Time-out Flag bit\nFor details of bit operation, see Register 5-3.\nbit 2\nPD: Power-down Detection Flag bit\nFor details of bit operation, see Register 5-3.\nbit 1\nPOR:\nPower-on Reset Status bit\nFor details of bit operation, see Register 5-3.\nbit 0 BOR:\nBrown-out Reset Status bit\nFor details of bit operation, see Register 5-3.",
    "9.6 INTn Pin Interrupts\nExternal  interrupts  on  the  RB0/INT0,  RB1/INT1  and RB2/INT2 pins are edge-triggered: either rising if the corresponding INTEDGx bit is set in the INTCON2 register, or falling if the INTEDGx bit is clear. When a valid edge appears on the RBx/INTx pin, the corresponding flag bit, INTxF, is set. This interrupt can be disabled by clearing the corresponding enable bit, INTxE. Flag bit, INTxF,  must  be  cleared  in  software  in  the  Interrupt Service  Routine  before  re-enabling  the  interrupt.  All external interrupts (INT0, INT1 and INT2) can wake-up the processor from low-power modes if bit INTxE was set prior to going into low-power modes. If the Global Interrupt  Enable  bit,  GIE,  is  set,  the  processor  will branch to the interrupt vector following wake-up.",
    "9.6 INTn Pin Interrupts\nInterrupt priority for INT1 and INT2 is determined by the value  contained  in  the  interrupt  priority  bits,  INT1IP (INTCON3<6>) and INT2IP (INTCON3<7>). There is no priority bit associated with INT0. It is always a high priority interrupt source.",
    "9.7 TMR0 Interrupt\nIn 8-bit mode  (which  is  the  default),  an  overflow (FFh \uf0ae 00h)  in  the  TMR0  register  will  set  flag  bit, TMR0IF. In 16-bit mode, an overflow (FFFFh \uf0ae\uf020 0000h) in the TMR0H:TMR0L  registers  will set flag bit, TMR0IF.  The  interrupt  can  be  enabled/disabled  by setting/clearing enable  bit, TMR0IE  (INTCON<5>). Interrupt priority for Timer0 is determined by the value contained in the interrupt priority bit, TMR0IP (INTCON2<2>). See Section 11.0 'Timer0 Module' for further details on the Timer0 module.",
    "9.8 PORTB Interrupt-on-Change\nAn input change on PORTB<7:4> sets flag bit, RBIF (INTCON<0>). The interrupt can be enabled/disabled by  setting/clearing  enable  bit,  RBIE  (INTCON<3>). Interrupt  priority  for  PORTB  interrupt-on-change  is determined  by  the  value  contained  in  the  interrupt priority bit, RBIP (INTCON2<0>).",
    "9.9 Context Saving During Interrupts\nDuring interrupts, the return PC address is saved on the stack. Additionally, the WREG, Status and BSR registers are saved on the fast return stack. If a fast return from interrupt is not used (see Section 5.3 'Fast Register Stack' ), the user may need to save the WREG, Status and  BSR  registers  on  entry  to  the  Interrupt  Service Routine.  Depending  on  the  user's  application,  other registers  may  also  need  to  be  saved.  Example 9-1 saves and restores the WREG,  Status  and  BSR registers during an Interrupt Service Routine.",
    "EXAMPLE 9-1: SAVING STATUS, WREG AND BSR REGISTERS IN RAM\nMOVWF MOVFF MOVFF ; ; USER, 1 = W_TEMP STATUS, STATUS_TEMP BSR, BSR_TEMP. MOVWF MOVFF MOVFF ; ; USER, 2 = ; W_TEMP is in virtual bank ; STATUS_TEMP located anywhere ; BSR_TMEP located anywhere. ;, 1 = ISR CODE. ;, 2 = . MOVFF, 1 = BSR_TEMP, BSR. MOVFF, 2 = ; Restore BSR. MOVF, 1 = W_TEMP, W. MOVF, 2 = ; Restore WREG. MOVFF, 1 = STATUS_TEMP, STATUS. MOVFF, 2 = ; Restore STATUS",
    "10.0 I/O PORTS\nDepending on the device selected and features enabled, there are up to five ports available. Some pins of  the  I/O  ports  are  multiplexed  with  an  alternate function from the peripheral features on the device. In general, when a peripheral is enabled, that pin may not be used as a general purpose I/O pin.\nEach port has three registers for its operation. These registers are:\n\u00b7 TRIS register (data direction register)\n\u00b7 PORT register (reads the levels on the pins of the device)\n\u00b7 LAT register (output latch)\nThe  Data  Latch  (LATA)  register  is  useful  for  readmodify-write operations on the value that the I/O pins are driving.\nA  simplified  model  of  a  generic  I/O  port  without  the interfaces to other peripherals is shown in Figure 10-1.",
    "10.1 PORTA, TRISA and LATA Registers\nPORTA is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISA.  Setting  a TRISA bit (= 1 ) will make the corresponding PORTA pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISA bit (= 0 ) will make the corresponding PORTA pin an output (i.e., put the contents of the output latch on the selected pin).\nReading the  PORTA register reads the  status  of  the pins, whereas writing to it will write to the port latch.\nThe  Data  Latch  register (LATA)  is also memory mapped.  Read-modify-write  operations  on  the  LATA register  read  and  write  the  latched  output  value  for PORTA.\nThe  RA4  pin  is  multiplexed  with  the  Timer0  module clock input to become the RA4/T0CKI pin.",
    "10.1 PORTA, TRISA and LATA Registers\nThe sixth pin of PORTA (MCLR/VPP/RA5) is an input only  pin.  Its  operation  is  controlled  by  the  MCLRE configuration bit in Configuration Register 3H (CONFIG3H<7>). When selected as a port pin (MCLRE = 0 ), it functions as a digital input only pin; as such, it does not have TRIS or LAT bits associated with its  operation.  Otherwise,  it  functions  as  the  device's Master Clear input. In  either  configuration,  RA5  also functions  as  the  programming  voltage  input  during programming.\nNote:, 1 = On a Power-on Reset, RA5 is enabled as a digital input only if Master Clear functionality is disabled.\nPins RA6 and RA7 are multiplexed with the main oscillator pins; they are enabled as oscillator or I/O pins by the  selection  of  the  main  oscillator  in  Configuration Register 1H (see Section 19.1 'Configuration Bits' for details). When they are not used as port pins, RA6 and RA7 and their associated TRIS and LAT bits are read as ' 0 '.",
    "10.1 PORTA, TRISA and LATA Registers\nThe  other  PORTA  pins  are  multiplexed  with  analog inputs, the analog VREF+ and VREF- inputs and the LVD input. The operation of pins RA3:RA0 as A/D converter inputs is selected by clearing/setting the control bits in the ADCON1 register (A/D Control Register 1).\nNote:\nOn  a  Power-on  Reset,  RA3:RA0  are configured as analog inputs and read as ' 0 '. RA4 is always a digital pin.\nThe RA4/T0CKI pin is a Schmitt Trigger input and an open-drain  output.  All  other  PORTA  pins  have  TTL input levels and full CMOS output drivers.\nThe  TRISA  register  controls  the  direction  of  the  RA pins, even when they are being used as analog inputs. The user must ensure the bits in the TRISA register are maintained set when using them as analog inputs.",
    "EXAMPLE 10-1: INITIALIZING PORTA\nCLRF, 1 = PORTA. CLRF, 2 = ; Initialize PORTA by ; clearing output ; data latches. CLRF, 1 = LATA. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF MOVLW, 1 = 0x7F ADCON1 0xD0. MOVLW MOVWF MOVLW, 2 = ; Configure A/D ; for digital inputs ; Value used to ; initialize data. MOVWF, 1 = TRISA. MOVWF, 2 = ; direction ; Set RA<3:0> as outputs ; RA<7:4> as inputs",
    "TABLE 10-1: PORTA FUNCTIONS\n\nLegend: TTL = TTL input, ST = Schmitt Trigger input",
    "TABLE 10-1: PORTA FUNCTIONS\nRA0/AN0, Bit# = bit 0. RA0/AN0, Buffer = ST. RA0/AN0, Function = Input/output port pin or analog input.. RA1/AN1/LVDIN, Bit# = bit 1. RA1/AN1/LVDIN, Buffer = ST. RA1/AN1/LVDIN, Function = Input/output port pin, analog input or Low-Voltage Detect input.. RA2/AN2/VREF-, Bit# = bit 2. RA2/AN2/VREF-, Buffer = ST. RA2/AN2/VREF-, Function = Input/output port pin, analog input or VREF-.. RA3/AN3/VREF+, Bit# = bit 3. RA3/AN3/VREF+, Buffer = ST. RA3/AN3/VREF+, Function = Input/output port pin, analog input or VREF+.. RA4/T0CKI, Bit# = bit 4. RA4/T0CKI, Buffer = ST. RA4/T0CKI, Function = Input/output port pin",
    "TABLE 10-1: PORTA FUNCTIONS\nor external clock input for Timer0. Output is open-drain type.. MCLR/VPP/RA5, Bit# = bit 5. MCLR/VPP/RA5, Buffer = ST. MCLR/VPP/RA5, Function = Master Clear input or programming voltage input (if MCLR is enabled); input only port pin or programming voltage input (if MCLR is disabled).. OSC2/CLKO/RA6, Bit# = bit 6. OSC2/CLKO/RA6, Buffer = ST. OSC2/CLKO/RA6, Function = OSC2, clock output or I/O pin.. OSC1/CLKI/RA7, Bit# = bit 7. OSC1/CLKI/RA7, Buffer = ST. OSC1/CLKI/RA7, Function = OSC1, clock input or I/O pin.",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nPORTA, Bit 7 = RA7 (1). PORTA, Bit 6 = RA6 (1). PORTA, Bit 5 = RA5 (2). PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = xx0x. PORTA, Value on all other Resets = 0000 uu0u. PORTA, Value on all other Resets = 0000. PORTA,",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\n= . LATA, Bit 7 = LATA7 (1). LATA, Bit 6 = LATA6 (1). LATA, Bit 5 = -. LATA, Bit 4 = LATA Data Output Register. LATA, Bit 3 = LATA Data Output Register. LATA, Bit 2 = LATA Data Output Register. LATA, Bit 1 = LATA Data Output Register. LATA, Bit 0 = LATA Data Output Register. LATA, Value on POR, BOR = xx-x. LATA, Value on all other Resets = xxxx uu-u. LATA, Value on all other Resets = uuuu. LATA,",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\n= . TRISA, Bit 7 = TRISA7 (1). TRISA, Bit 6 = TRISA6 (1). TRISA, Bit 5 = -. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = 11-1. TRISA, Value on all other Resets = 1111 11-1. TRISA, Value on all other Resets = 1111. TRISA,",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\n= . ADCON1, Bit 7 = -. ADCON1, Bit 6 = PCFG6. ADCON1, Bit 5 = PCFG5. ADCON1, Bit 4 = PCFG4. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = -000. ADCON1, Value on all other Resets = 0000 -000. ADCON1, Value on all other Resets = 0000. ADCON1,  = \nLegend:\nx = unknown, u = unchanged, - = unimplemented locations read as ' 0 '. Shaded cells are not used by PORTA.\nNote 1: RA7:RA6 and their associated latch and data direction bits are enabled as I/O pins based on oscillator configuration; otherwise, they are read as ' 0 '.\n2: RA5 is an input only if MCLR is disabled.",
    "10.2 PORTB, TRISB and LATB Registers\nPORTB is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISB.  Setting  a TRISB bit (= 1 )  will  make the corresponding PORTB pin an input (i.e., put the corresponding output driver in a High-impedance mode). Clearing a TRISB bit (= 0 ) will make the corresponding PORTB pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATB)  is also memory mapped.  Read-modify-write  operations  on  the  LATB register  read  and  write  the  latched  output  value  for PORTB.",
    "EXAMPLE 10-2: INITIALIZING PORTB\nCLRF, 1 = PORTB. CLRF, 2 = ; Initialize PORTB by ; clearing output ; data latches. CLRF, 1 = LATB. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF, 1 = 0x70. MOVLW MOVWF, 2 = ; Set RB0, RB1, RB4 as. , 1 = ADCON1. , 2 = ; digital I/O pins. MOVLW, 1 = 0xCF. MOVLW, 2 = ; Value used to ; initialize data ; direction ; Set RB<3:0> as inputs. MOVWF, 1 = TRISB. MOVWF, 2 = ; RB<5:4> as outputs ; RB<7:6> as inputs",
    "EXAMPLE 10-2: INITIALIZING PORTB\nPins  RB0-RB2  are  multiplexed  with  INT0-INT2;  pins RB0, RB1 and RB4 are multiplexed with A/D inputs; pins RB1 and RB4 are multiplexed with EUSART; and pins  RB2,  RB3,  RB6  and  RB7  are  multiplexed  with ECCP.\nEach of the PORTB pins has a weak internal pull-up. A single  control  bit  can  turn  on  all  the  pull-ups.  This  is performed by clearing bit, RBPU (INTCON2<7>). The weak pull-up is automatically turned off when the port pin  is configured  as  an  output.  The  pull-ups  are disabled on a Power-on Reset.\nNote:\nOn  a  Power-on  Reset,  RB4:RB0  are configured as analog inputs by default and read  as  ' 0 ';  RB7:RB5  are  configured  as digital inputs.",
    "EXAMPLE 10-2: INITIALIZING PORTB\nFour of the PORTB pins (RB7:RB4) have an interrupton-change feature. Only pins configured as inputs can cause  this  interrupt  to  occur  (i.e.,  any  RB7:RB4  pin configured as an output is excluded from the interrupton-change comparison). The input pins (of RB7:RB4) are  compared  with  the  old  value  latched  on  the  last read of PORTB. The 'mismatch' outputs of RB7:RB4 are OR'ed together to generate the RB Port Change Interrupt with Flag bit, RBIF (INTCON<0>).\nThis  interrupt  can  wake  the  device  from  Sleep.  The user,  in  the  Interrupt  Service  Routine,  can  clear  the interrupt in the following manner:\na) Any  read  or  write  of  PORTB  (except  with  the MOVFF instruction). This will end the mismatch condition.\nb) Clear flag bit, RBIF.\nA mismatch condition will continue to set flag bit, RBIF. Reading PORTB will end the mismatch condition and allow flag bit, RBIF, to be cleared.",
    "EXAMPLE 10-2: INITIALIZING PORTB\nThe interrupt-on-change  feature  is  recommended  for wake-up on key depression operation and operations where PORTB is only used for the interrupt-on-change feature. Polling of PORTB is not recommended while using the interrupt-on-change feature.",
    "FIGURE 10-7: BLOCK DIAGRAM OF RB0/AN4/INT0 PIN\nNote 1: I/O pins have diode protection to VDD and VSS.\n2: To  enable  weak  pull-ups,  set  the  appropriate  TRIS bit(s) and clear the RBPU bit (INTCON2<7>).",
    "FIGURE 10-10: BLOCK DIAGRAM OF RB3/CCP1/P1A PIN\n(3)\nNote 1: I/O pins have diode protection to VDD and VSS.\n2: To enable weak pull-ups, set the appropriate TRIS bit(s) and clear the RBPU bit (INTCON2<7>).\n3: ECCP1 pin output enable active for any PWM mode and Compare mode, where CCP1M<3:0> = 1000 or 1001 .\n4: ECCP1 pin input enable active for Capture mode only.",
    "FIGURE 10-11: BLOCK DIAGRAM OF RB4/AN6/RX/DT/KBI0 PIN\nNote 1: I/O pins have diode protection to VDD and VSS.\n2: To enable weak pull-ups, set the appropriate TRIS bit(s) and clear the RBPU bit (INTCON2<7>).",
    "FIGURE 10-13: BLOCK DIAGRAM OF RB6/PGC/T1OSO/T13CKI/P1C/KBI2 PIN\nNote 1: I/O pins have diode protection to VDD and VSS.\n2: To enable weak pull-ups, set the appropriate TRIS bit(s) and clear the RBPU bit (INTCON2<7>).",
    "TABLE 10-3: PORTB FUNCTIONS\n\nLegend:",
    "TABLE 10-3: PORTB FUNCTIONS\nRB0/AN4/INT0, Bit# = bit 0. RB0/AN4/INT0, Buffer = TTL (1) /ST (2). RB0/AN4/INT0, Function = Input/output port pin, analog input or external interrupt input 0.. RB1/AN5/TX/CK/INT1, Bit# = bit 1. RB1/AN5/TX/CK/INT1, Buffer = TTL (1) /ST (2). RB1/AN5/TX/CK/INT1, Function = Input/output port pin, analog input, Enhanced USART Asynchronous Transmit, Addressable USART Synchronous Clock or external interrupt input 1.. RB2/P1B/INT2, Bit# = bit 2. RB2/P1B/INT2, Buffer = TTL (1) /ST (2). RB2/P1B/INT2, Function = Input/output port pin or external interrupt input 2. Internal software programmable weak pull-up.. RB3/CCP1/P1A, Bit# = bit 3.",
    "TABLE 10-3: PORTB FUNCTIONS\nRB3/CCP1/P1A, Buffer = TTL (1) /ST (3). RB3/CCP1/P1A, Function = Input/output port pin or Capture1 input/Compare1 output/ PWM output. Internal software programmable weak pull-up.. RB4/AN6/RX/DT/KBI0, Bit# = bit 4. RB4/AN6/RX/DT/KBI0, Buffer = TTL (1) /ST (4). RB4/AN6/RX/DT/KBI0, Function = Input/output port pin (with interrupt-on-change), analog input, Enhanced USART Asynchronous Receive or Addressable USART Synchronous Data.. RB5/PGM/KBI1, Bit# = bit 5. RB5/PGM/KBI1, Buffer = TTL (1) /ST (5). RB5/PGM/KBI1, Function = Input/output port pin (with interrupt-on-change). Internal software programmable weak pull-up. Low-Voltage",
    "TABLE 10-3: PORTB FUNCTIONS\nICSP\u2122 enable pin.. RB6/PGC/T1OSO/T13CKI/ P1C/KBI2, Bit# = bit 6. RB6/PGC/T1OSO/T13CKI/ P1C/KBI2, Buffer = TTL (1) /ST (5,6). RB6/PGC/T1OSO/T13CKI/ P1C/KBI2, Function = Input/output port pin (with interrupt-on-change), Timer1/ Timer3 clock input or Timer1oscillator output. Internal software programmable weak pull-up. Serial programming clock.. RB7/PGD/T1OSI/P1D/KBI3, Bit# = bit 7. RB7/PGD/T1OSI/P1D/KBI3, Buffer = TTL (1) /ST (5). RB7/PGD/T1OSI/P1D/KBI3, Function = Input/output port pin (with interrupt-on-change) or Timer1 oscillator input. Internal software programmable weak pull-up. Serial programming",
    "TABLE 10-3: PORTB FUNCTIONS\ndata.\nTTL = TTL input, ST = Schmitt Trigger input\nNote 1:\nThis buffer is a TTL input when configured as a port input pin.\n2: This buffer is a Schmitt Trigger input when configured as the external interrupt.\n3: This buffer is a Schmitt Trigger input when configured as the CCP1 input.\n4: This buffer is a Schmitt Trigger input when used as EUSART receive input.\n5: This buffer is a Schmitt Trigger input when used in Serial Programming mode.\n6: This buffer is a TTL input when used as the T13CKI input.",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\n\nLegend: x = unknown, u = unchanged, q = value depends on condition. Shaded cells are not used by PORTB.",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nPORTB, Bit 7 = RB7. PORTB, Bit 6 = RB6. PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 = RB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTB, Value on POR, BOR = xxxq. PORTB, Value on POR, BOR = qqqq. PORTB, Value on all other Resets = uuuu. PORTB, Value on all other Resets = uuuu. LATB, Bit 7 = LATB Data Output Register. LATB, Bit 6 = LATB Data Output Register. LATB, Bit 5 = LATB Data Output Register. LATB, Bit 4 = LATB Data Output Register. LATB, Bit 3 = LATB Data Output Register. LATB, Bit 2 = LATB Data Output Register. LATB, Bit 1 = LATB Data Output Register. LATB, Bit 0 = LATB Data Output Register.",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nLATB, Value on POR, BOR = xxxx. LATB, Value on POR, BOR = xxxx. LATB, Value on all other Resets = uuuu. LATB, Value on all other Resets = uuuu. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111. TRISB, Value on POR, BOR = 1111. TRISB, Value on all other Resets = 1111. TRISB, Value on all other Resets = 1111. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE.",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nINTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111. INTCON2, Value on POR, BOR = -1-1. INTCON2, Value on all other Resets = 1111. INTCON2, Value on all other Resets =",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\n-1-1. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 11-0. INTCON3, Value on POR, BOR = 0-00. INTCON3, Value on all other Resets = 11-0. INTCON3, Value on all other Resets = 0-00. ADCON1, Bit 7 = -. ADCON1, Bit 6 = PCFG6. ADCON1, Bit 5 = PCFG5. ADCON1, Bit 4 = PCFG4. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0.",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nADCON1, Value on POR, BOR = -000. ADCON1, Value on POR, BOR = 0000. ADCON1, Value on all other Resets = -000. ADCON1, Value on all other Resets = 0000",
    "11.0 TIMER0 MODULE\nThe Timer0 module has the following features:\n\u00b7 Software selectable as an 8-bit or 16-bit timer/ counter\n\u00b7 Readable and writable\n\u00b7 Dedicated 8-bit software programmable prescaler\n\u00b7 Clock source selectable to be external or internal\n\u00b7 Interrupt-on-overflow from FFh to 00h in 8-bit mode and FFFFh to 0000h in 16-bit mode\n\u00b7 Edge select for external clock",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nR/W-1/1, 1 = R/W-1/1. R/W-1/1, 2 = R/W-1/1. R/W-1/1, 3 = R/W-1/1. R/W-1/1, 4 = R/W-1/1. R/W-1/1, 5 = R/W-1/1. R/W-1/1, 6 = R/W-1/1. R/W-1/1, 7 = R/W-1/1. TMR0ON, 1 = T08BIT. TMR0ON, 2 = T0CS. TMR0ON, 3 = T0SE. TMR0ON, 4 = PSA. TMR0ON, 5 = T0PS2. TMR0ON, 6 = T0PS1. TMR0ON, 7 = T0PS0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\n7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = \nbit 7\nTMR0ON:\nTimer0 On/Off Control bit\n1 = Enables Timer0\n0 = Stops Timer0\nbit 6\nT08BIT: Timer0 8-bit/16-bit Control bit\n1 = Timer0 is configured as an 8-bit timer/counter\n0 = Timer0 is configured as a 16-bit timer/counter\nbit 5",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nT0CS: Timer0 Clock Source Select bit\n1 = Transition on T0CKI pin\n0 = Internal instruction cycle clock (CLKO)",
    "bit 4 T0SE:\nTimer0 Source Edge Select bit\n1 = Increment on high-to-low transition on T0CKI pin\n0 = Increment on low-to-high transition on T0CKI pin\nbit 3\nPSA: Timer0 Prescaler Assignment bit\n1 = TImer0 prescaler is NOT assigned. Timer0 clock input bypasses prescaler.\n0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.\nbit 2-0\nT0PS<2:0>: Timer0 Prescaler Select bits\n111 = 1:256 Prescale value\n110 = 1:128 Prescale value\n101 = 1:64   Prescale value\n100 = 1:32   Prescale value\n011\n= 1:16   Prescale value\n010 = 1:8     Prescale value\n001\n= 1:4     Prescale value\n000\n= 1:2     Prescale value\nFigure 11-1  shows  a  simplified  block  diagram  of  the Timer0 module in 8-bit mode and Figure 11-2 shows a simplified block diagram of the Timer0 module in 16-bit mode.",
    "bit 4 T0SE:\nThe T0CON register (Register 11-1) is a readable and writable register that controls all the aspects of Timer0, including the prescale selection.",
    "11.1 Timer0 Operation\nTimer0 can operate as a timer or as a counter.\nTimer  mode  is  selected  by  clearing  the  T0CS  bit.  In Timer mode, the Timer0 module will increment every instruction cycle (without prescaler). If the TMR0 register is written, the increment is inhibited for the following two instruction cycles. The user can work around this by writing an adjusted value to the TMR0 register.\nCounter mode is selected by setting the T0CS bit. In Counter mode, Timer0 will increment either on every rising or falling edge of pin RA4/T0CKI. The incrementing  edge  is  determined  by  the  Timer0  Source  Edge Select  bit  (T0SE).  Clearing  the  T0SE  bit  selects  the rising edge.\nWhen an external clock input is used for Timer0, it must meet certain requirements. The requirements ensure the external clock can be synchronized with the internal phase clock (TOSC). Also, there is a delay in the actual incrementing of Timer0 after synchronization.",
    "11.2 Prescaler\nAn 8-bit counter is available as a prescaler for the Timer0 module. The prescaler is not readable or writable.\nThe PSA  and T0PS2:T0PS0  bits determine the prescaler assignment and prescale ratio.\nClearing bit PSA will assign the prescaler to the Timer0 module. When the prescaler is assigned to the Timer0 module,  prescale  values  of  1:2,  1:4,  ...,  1:256  are selectable.\nWhen assigned to the Timer0 module, all instructions writing to the TMR0 register (e.g., CLRF TMR0 MOVWF , TMR0 , BSF  TMR0 , x ,  ...,  etc.)  will clear  the  prescaler count.\nNote:\nWriting  to  TMR0  when  the  prescaler  is assigned to Timer0 will clear the prescaler count,  but  will  not  change  the  prescaler assignment.",
    "11.2.1 SWITCHING PRESCALER ASSIGNMENT\nThe  prescaler  assignment  is  fully  under  software control  (i.e.,  it can  be  changed  'on-the-fly'  during program execution).",
    "11.3 Timer0 Interrupt\nThe TMR0 interrupt is generated when the TMR0 register overflows from FFh to 00h in 8-bit mode, or FFFFh to 0000h in 16-bit mode. This overflow sets the TMR0IF bit. The  interrupt  can  be  masked  by  clearing  the TMR0IE bit. The TMR0IF bit must be cleared in software by the Timer0 module Interrupt Service Routine before  re-enabling  this  interrupt.  The  TMR0  interrupt cannot awaken the processor from Low-Power Sleep mode, since the timer requires clock cycles even when T0CS is set.",
    "11.4 16-Bit Mode Timer Reads and Writes\nTMR0H  is  not  the  high  byte  of  the  timer/counter  in 16-bit mode, but is actually a buffered version of the high byte of Timer0 (refer to Figure 11-2). The high byte of the Timer0 counter/timer is not directly readable nor writable.  TMR0H is  updated  with  the  contents  of  the high byte of Timer0 during a read of TMR0L. This provides the ability to read all 16 bits of Timer0, without having to verify that the read of the high and low byte were valid due to a rollover between successive reads of the high and low byte.\nA write to the high byte of Timer0 must also take place through the TMR0H Buffer register. Timer0 high byte is updated  with  the  contents  of  TMR0H  when  a  write occurs to TMR0L. This allows all 16 bits of Timer0 to be updated at once.",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0L, Bit 7 = Timer0 Module Low Byte Register. TMR0L, Bit 6 = Timer0 Module Low Byte Register. TMR0L, Bit 5 = Timer0 Module Low Byte Register. TMR0L, Bit 4 = Timer0 Module Low Byte Register. TMR0L, Bit 3 = Timer0 Module Low Byte Register. TMR0L, Bit 2 = Timer0 Module Low Byte Register. TMR0L, Bit 1 = Timer0 Module Low Byte Register. TMR0L, Bit 0 = Timer0 Module Low Byte Register. TMR0L, Value on POR, BOR = xxxx. TMR0L, Value on all other Resets = xxxx. TMR0L, Value on all other Resets = uuuu. TMR0L, Value on all other Resets = uuuu. TMR0H, Bit 7 = Timer0 Module High Byte Register. TMR0H, Bit 6 = Timer0 Module High Byte Register. TMR0H, Bit 5 = Timer0 Module High Byte Register.",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0H, Bit 4 = Timer0 Module High Byte Register. TMR0H, Bit 3 = Timer0 Module High Byte Register. TMR0H, Bit 2 = Timer0 Module High Byte Register. TMR0H, Bit 1 = Timer0 Module High Byte Register. TMR0H, Bit 0 = Timer0 Module High Byte Register. TMR0H, Value on POR, BOR = 0000. TMR0H, Value on all other Resets = 0000. TMR0H, Value on all other Resets = 0000. TMR0H, Value on all other Resets = 0000. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON,",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nValue on all other Resets = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111 1111. T0CON, Value on all other Resets = . T0CON, Value on all other Resets = 1111. T0CON, Value on all other Resets = 1111. TRISA, Bit 7 = RA7 (1). TRISA, Bit 6 = RA6 (1). TRISA, Bit 5 = -. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\n= PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = 11-1 1111. TRISA, Value on all other Resets = 11-1. TRISA, Value on all other Resets = . TRISA, Value on all other Resets = 1111\nLegend:\nx = unknown, u = unchanged, - = unimplemented locations read as ' 0 '. Shaded cells are not used by Timer0.\nNote 1: RA6 and RA7 are enabled as I/O pins, depending on the oscillator mode selected in Configuration Word 1H.",
    "12.0 TIMER1 MODULE\nThe  Timer1  module  timer/counter  has  the  following features:\n- \u00b7 16-bit timer/counter\n(two 8-bit registers: TMR1H and TMR1L)\n\u00b7 Readable and writable (both registers)\n\u00b7 Internal or external clock select\n\u00b7 Interrupt-on-overflow from FFFFh to 0000h\n\u00b7 Reset from CCP module special event trigger\n\u00b7 Status of system clock operation\nFigure 12-1 is a simplified block diagram of the Timer1 module.\nRegister 12-1 details the Timer1 Control register. This register  controls  the  operating  mode  of  the  Timer1 module and contains the Timer1 Oscillator Enable bit (T1OSCEN).  Timer1  can  be  enabled  or  disabled  by setting or clearing control bit, TMR1ON (T1CON<0>).",
    "12.0 TIMER1 MODULE\nThe Timer1 oscillator can be used as a secondary clock source in power managed modes. When the T1RUN bit is  set,  the  Timer1  oscillator  is  providing  the  system clock. If the Fail-Safe Clock Monitor is enabled and the Timer1 oscillator fails while providing the system clock, polling the T1RUN bit will indicate whether the clock is being  provided  by  the  Timer1  oscillator  or  another source.\nTimer1 can also be used to provide Real-Time Clock (RTC) functionality to applications, with only a minimal addition of external components and code overhead.",
    "REGISTER 12-1: T1CON: TIMER1 CONTROL REGISTER\nRD16, R-1/1 = T1RUN. RD16, R/W-0/0 = T1CKPS1. RD16, R/W-0/0 = T1CKPS0. RD16, R/W-0/0 = T1OSCEN. RD16, R/W-0/0 = T1SYNC. RD16, R/W-0/0 = TMR1CS. RD16, R/W-0/0 = TMR1ON. bit 7 bit 0, R-1/1 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0",
    "REGISTER 12-1: T1CON: TIMER1 CONTROL REGISTER\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7 RD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register read/write of TImer1 in one 16-bit operation\n0 = Enables register read/write of Timer1 in two 8-bit operations\nbit 6\nT1RUN: Timer1 System Clock Status bit\n1 = System clock is derived from Timer1 oscillator\n0 = System clock is derived from another source\nbit 5-4\nT1CKPS<1:0>: Timer1 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value",
    "bit 3\nT1OSCEN: Timer1 Oscillator Enable bit\n1 = Timer1 oscillator is enabled\n0 = Timer1 oscillator is shut off\nThe oscillator inverter and feedback resistor are turned off to eliminate power drain.\nbit 2\nT1SYNC: Timer1 External Clock Input Synchronization Select bit\nWhen TMR1CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR1CS = 0 :\nThis bit is ignored. Timer1 uses the internal clock when TMR1CS = 0 .",
    "bit 1\nTMR1CS: Timer1 Clock Source Select bit\n1 = External clock from pin RB6/PGC/T1OSO/T13CKI/P1C/KBI2 (on the rising edge)\n0 = Internal clock (Fosc/4)",
    "bit 0\nTMR1ON: Timer1 On bit\n1 = Enables Timer1\n0 = Stops Timer1",
    "12.1 Timer1 Operation\nTimer1 can operate in one of these modes:\n\u00b7 As a timer\n\u00b7 As a synchronous counter\n\u00b7 As an asynchronous counter\nThe operating mode is determined by the clock select bit, TMR1CS (T1CON<1>).\nWhen TMR1CS = 0 , Timer1 increments every instruction cycle. When TMR1CS = 1 , Timer1 increments on every rising edge of the external clock input, or the Timer1 oscillator, if enabled.\nWhen the Timer1 oscillator is enabled (T1OSCEN is set), the RB7/PGD/T1OSI/P1D/KBI3 and RB6/T1OSO/ T13CKI/P1C/KBI2  pins  become  inputs.  That  is,  the TRISB7:TRISB6 values are ignored and the pins read as ' 0 '.\nTimer1 also has an internal 'Reset input'. This Reset can be generated by the CCP module (see Section 15.4.4 'Special Event Trigger' ).",
    "FIGURE 12-2: TIMER1 BLOCK DIAGRAM: 16-BIT READ/WRITE MODE\nNote 1: When enable bit, T1OSCEN, is cleared, the inverter and feedback resistor are turned off. This eliminates power drain.",
    "12.2 Timer1 Oscillator\nA crystal oscillator circuit is built-in between pins T1OSI (input) and T1OSO (amplifier output). It is enabled by setting control bit, T1OSCEN (T1CON<3>). The oscillator is a low-power oscillator rated for 32 kHz crystals. It will continue to run during all power managed modes. The  circuit  for  a  typical  LP  oscillator  is  shown  in Figure 12-3. Table 12-1 shows the capacitor selection for the Timer1 oscillator.\nThe user must provide a software time delay to ensure proper start-up of the Timer1 oscillator.\nNote:\nThe  Timer1  oscillator  shares  the  T1OSI and T1OSO pins with the PGD and PGC pins used for programming and debugging.\nWhen using the Timer1 oscillator, In-Circuit Serial Programming (ICSP) may not function correctly (high voltage or low voltage), or the In-Circuit Debugger (ICD) may not communicate with the controller. As a result of using either ICSP or ICD, the Timer1 crystal may be damaged.",
    "12.2 Timer1 Oscillator\nIf  ICSP  or  ICD  operations  are  required, the  crystal  should  be  disconnected  from the  circuit (disconnect  either  lead),  or installed after programming. The oscillator loading  capacitors  may  remain  in-circuit during ICSP or ICD operation.\nFIGURE 12-3:",
    "TABLE 12-1: CAPACITOR SELECTION FOR THE TIMER OSCILLATOR\nLP, Freq = 32 kHz. LP, C1 = 22 pF (1). LP, C2 = 22 pF (1)\nNote 1: Microchip suggests this value as a starting  point  in  validating  the  oscillator circuit.  Oscillator  operation  should  then be tested to ensure expected performance under all expected conditions (VDD and temperature).\n2: Higher capacitance increases the stability of the oscillator, but also increases the start-up time.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer  for appropriate values of external components.\n4: Capacitor values are for design guidance only.",
    "12.3 Timer1 Oscillator Layout Considerations\nThe  Timer1  oscillator  circuit  draws  very  little  power during operation. Due to the low-power nature of the oscillator, it may also be sensitive to rapidly changing signals in close proximity.\nThe oscillator circuit, shown in Figure 12-3, should be located  as  close  as  possible  to  the  microcontroller. There should be no circuits passing within the oscillator circuit boundaries other than VSS or VDD.\nIf a high-speed circuit must be located near the oscillator (such as the CCP1 pin in output compare or PWM mode, or the primary oscillator using the OSC2 pin), a grounded  guard  ring  around  the  oscillator  circuit,  as shown in Figure 12-4, may be helpful when used on a single sided PCB, or in addition to a ground plane.",
    "12.4 Timer1 Interrupt\nThe TMR1 register pair (TMR1H:TMR1L) increments from  0000h  to  FFFFh  and  rolls  over  to  0000h.  The Timer1 interrupt, if enabled, is generated on overflow, which is latched in interrupt flag bit, TMR1IF (PIR1<0>). This interrupt can be enabled/disabled by setting/clearing  Timer1  Interrupt  Enable  bit,  TMR1IE (PIE1<0>).",
    "12.5 Resetting Timer1 Using a CCP Trigger Output\nIf the CCP module is configured in Compare mode to generate a 'special event trigger' (CCP1M3:CCP1M0 = 1011 ), this  signal  will  reset Timer1 and start an A/D conversion, if the A/D module is enabled (see Section 15.4.4 'Special Event Trigger' for more information).\nNote:, 1 = The special event triggers from the CCP1 module will not set interrupt flag bit, TMR1IF (PIR1<0>).\nTimer1 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If  Timer1  is  running  in  Asynchronous  Counter mode, this Reset operation may not work.\nIn  the  event  that  a  write  to  Timer1  coincides  with  a special  event  trigger  from  CCP1,  the  write  will  take precedence.\nIn this mode  of  operation,  the  CCPR1H:CCPR1L register pair effectively becomes the period register for Timer1.",
    "12.6 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured for 16-bit reads and writes (see Figure 12-2). When the RD16 control bit (T1CON<7>) is set, the address for TMR1H is mapped to a buffer register for the high byte of Timer1. A read from TMR1L will load the contents of the high byte of Timer1 into the Timer1 high byte buffer. This provides the user with the ability to accurately read all 16 bits of Timer1 without having to determine whether a read of the  high  byte,  followed  by  a  read  of  the  low  byte,  is valid, due to a rollover between reads.\nA write to the high byte of Timer1 must also take place through the TMR1H Buffer register. Timer1 high byte is updated  with  the  contents  of  TMR1H  when  a  write occurs to TMR1L. This allows a user to write all 16 bits to both the high and low bytes of Timer1 at once.",
    "12.6 Timer1 16-Bit Read/Write Mode\nThe  high  byte  of  Timer1  is  not  directly  readable  or writable in this mode. All reads and writes must take place  through  the  Timer1  High  Byte  Buffer  register. Writes  to  TMR1H  do  not  clear  the  Timer1  prescaler. The prescaler is only cleared on writes to TMR1L.",
    "12.7 Using Timer1 as a Real-Time Clock\nAdding an external LP oscillator to Timer1 (such as the one  described  in Section 12.2  'Timer1  Oscillator' , above), gives users the option to include RTC functionality to their applications. This is accomplished with an inexpensive watch crystal to provide an accurate time base and several lines of application code to calculate the time. When operating in Sleep mode and using a battery  or  supercapacitor  as  a  power  source,  it  can completely  eliminate  the  need  for  a  separate  RTC device and battery backup.\nSince the register pair is 16 bits wide, counting up to overflow the register directly from a 32.768 kHz clock would take two seconds. To force the overflow at the required one-second intervals, it is necessary to preload it; the simplest method is to set the MSb of TMR1H with a BSF instruction. Note that the TMR1L register is never  preloaded  or  altered;  doing  so  may  introduce cumulative error over many cycles.",
    "12.7 Using Timer1 as a Real-Time Clock\nFor this method to be accurate, Timer1 must operate in Asynchronous mode and the Timer1 overflow interrupt must  be  enabled  (PIE1<0>  = 1 ), as  shown  in  the routine, RTCinit . The Timer1 oscillator must also be enabled and running at all times.\nThe  application code  routine, RTCisr , shown  in Example 12-1, demonstrates a simple method  to increment a counter at one-second intervals using an Interrupt Service Routine. Incrementing the TMR1 register pair to overflow, triggers the interrupt and calls the routine, which increments the seconds counter by one; additional counters for minutes and hours are incremented as the previous counter overflow.",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nRTCinit, 1 = . RTCinit, 2 = . RTCinit, 3 = . RTCinit, 4 = . , 1 = MOVLW MOVWF CLRF. , 2 = 0x80. , 3 = ;. , 4 = Preload TMR1 register pair. , 1 = . , 2 = TMR1H. , 3 = ;. , 4 = for 1 second overflow. , 1 = MOVLW. , 2 = TMR1L b'00001111'. , 3 = ;. , 4 = Configure for external clock,. , 1 = MOVWF. , 2 = T1OSC. , 3 = ;. , 4 = Asynchronous operation, external oscillator. , 1 = CLRF. , 2 = secs. , 3 = ;. , 4 = Initialize timekeeping registers. , 1 = CLRF. , 2 = mins. , 3 = ;. , 4 = . , 1 = MOVLW. , 2 = .12. , 3 = . , 4 =",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\n. , 1 = MOVWF. , 2 = hours. , 3 = . , 4 = . , 1 = BSF RETURN. , 2 = PIE1, TMR1IE. , 3 = ;. , 4 = Enable Timer1 interrupt. RTCisr, 1 = . RTCisr, 2 = . RTCisr, 3 = . RTCisr, 4 = . , 1 = BSF. , 2 = TMR1H, 7. , 3 = ;. , 4 = Preload for 1 sec overflow. , 1 = BCF. , 2 = PIR1, TMR1IF. , 3 = ;. , 4 = Clear interrupt flag. , 1 = INCF. , 2 = secs, F. , 3 = ;. , 4 = Increment seconds. , 1 = MOVLW CPFSGT. , 2 = .59. , 3 = ;. , 4 = 60 seconds elapsed?. , 1 = RETURN. , 2 = secs. , 3 = ;. , 4 = No, done. , 1 = CLRF. , 2 =",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nsecs. , 3 = ;. , 4 = Clear seconds. , 1 = INCF. , 2 = mins, F. , 3 = ;. , 4 = Increment minutes. , 1 = MOVLW CPFSGT. , 2 = .59 mins. , 3 = ;. , 4 = 60 minutes elapsed?. , 1 = RETURN. , 2 = . , 3 = ;. , 4 = No, done. , 1 = CLRF. , 2 = mins. , 3 = ;. , 4 = clear minutes. , 1 = INCF. , 2 = hours, F. , 3 = ;. , 4 = Increment hours. , 1 = MOVLW. , 2 = .23. , 3 = ;. , 4 = 24 hours elapsed?. , 1 = CPFSGT RETURN. , 2 = hours. , 3 = ;. , 4 = No, done. , 1 = MOVLW. , 2 = .01. , 3 = ;. , 4 = Reset hours to 1. , 1 = MOVWF. , 2 = hours.",
    "EXAMPLE 12-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\n, 3 = . , 4 = . , 1 = RETURN. , 2 = . , 3 = ;. , 4 = Done",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000.",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nPIR1, Value on POR, BOR = -000. PIR1, Value on all other Resets = -000. PIR1, Value on all other Resets = -000. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Value on POR, BOR = -000. PIE1, Value on all other Resets = -000. PIE1, Value on all other Resets = -000. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 =",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nTMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111. IPR1, Value on POR, BOR = -111. IPR1, Value on all other Resets = -111. IPR1, Value on all other Resets = -111. TMR1L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register.",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nTMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on all other Resets = uuuu. TMR1L, Value on all other Resets = uuuu. TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 3 = Holding Register",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nfor the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on all other Resets = uuuu. TMR1H, Value on all other Resets = uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\n1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0000. T1CON, Value on POR, BOR = 0000. T1CON, Value on all other Resets = u0uu. T1CON, Value on all other Resets = uuuu\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer1 module.",
    "13.0 TIMER2 MODULE\nThe Timer2 module timer has the following features:\n\u00b7 8-bit timer (TMR2 register)\n\u00b7 8-bit period register (PR2)\n\u00b7 Readable and writable (both registers)\n\u00b7 Software programmable prescaler (1:1, 1:4, 1:16)\n\u00b7 Software programmable postscaler (1:1 to 1:16)\n\u00b7 Interrupt on TMR2 match with PR2\nTimer2 has a control register shown in Register 13-1. TMR2 can be shut off by clearing control bit, TMR2ON (T2CON<2>), to minimize power consumption. Figure 13-1 is a simplified block diagram of the Timer2 module. Register 13-1 shows the Timer2 Control register.  The  prescaler  and  postscaler  selection  of Timer2 are controlled by this register.",
    "13.1 Timer2 Operation\nTimer2  can  be  used  as  the  PWM  time  base  for  the PWM mode of the CCP module. The TMR2 register is readable  and  writable  and  is  cleared  on  any  device Reset. The input clock (FOSC/4) has a prescale option of 1:1, 1:4 or 1:16, selected by control bits, T2CKPS1:T2CKPS0 (T2CON<1:0>). The match output  of  TMR2  goes  through  a  4-bit  postscaler  (which gives  a  1:1  to  1:16  scaling  inclusive)  to  generate  a TMR2 interrupt (latched in flag bit, TMR2IF (PIR1<1>)).\nThe  prescaler  and  postscaler  counters  are  cleared when any of the following occurs:\n\u00b7 A write to the TMR2 register\n\u00b7 A write to the T2CON register\n\u00b7 Any device Reset (Power-on Reset, MCLR Reset, Watchdog Timer Reset or Brown-out Reset)\nTMR2 is not cleared when T2CON is written.",
    "REGISTER 13-1: T2CON: TIMER2 CONTROL REGISTER\nU-0, 1 = R/W-0/0. U-0, 2 = R/W-0/0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = TOUTPS3. -, 2 = TOUTPS2. -, 3 = TOUTPS1. -, 4 = TOUTPS0. -, 5 = TMR2ON. -, 6 = T2CKPS1. -, 7 = T2CKPS0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 13-1: T2CON: TIMER2 CONTROL REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7\nUnimplemented: Read as ' 0 '\nbit 6-3\nTOUTPS<3:0>: Timer2 Output Postscale Select bits\n0000 = 1:1 Postscale\n0001 = 1:2 Postscale\n\u2022\n\u2022\n\u2022\n1111 = 1:16 Postscale\nbit 2\nTMR2ON: Timer2 On bit\n1 = Timer2 is on\n0 = Timer2 is off\nbit 1-0\nT2CKPS<1:0>: Timer2 Clock Prescale Select bits\n00 = Prescaler is 1\n01 = Prescaler is 4\n1x = Prescaler is 16",
    "13.2 Timer2 Interrupt\nThe Timer2 module has an 8-bit period register, PR2. Timer2 increments from 00h until it matches PR2 and then resets to 00h on the next increment cycle. PR2 is a readable and writable register. The PR2 register is initialized to FFh upon Reset.",
    "13.3 Output of TMR2\nThe output of TMR2 (before the postscaler) is fed to the Synchronous Serial Port module, which optionally uses it to generate the shift clock.",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR Value on all other = 0000. INTCON, Value on POR, BOR Value on all other = 000x. INTCON, Resets = 0000. INTCON, Resets = 000u. INTCON,",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n= . PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR Value on all other = -000. PIR1, Value on POR, BOR Value on all other = -000. PIR1, Resets = -000. PIR1, Resets = -000. PIR1,",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n= . PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR Value on all other = -000. PIE1, Value on POR, BOR Value on all other = -000. PIE1, Resets = -000. PIE1, Resets = -000. PIE1,",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n= . IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR Value on all other = -111. IPR1, Value on POR, BOR Value on all other = -111. IPR1, Resets = -111. IPR1, Resets = -111. IPR1,",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n= . TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR Value on all other = 0000. TMR2, Value on POR, BOR Value on all other = 0000. TMR2, Resets = 0000. TMR2, Resets = 0000. TMR2,",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n= . T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR Value on all other = -000. T2CON, Value on POR, BOR Value on all other = 0000. T2CON, Resets = -000. T2CON, Resets = 0000. T2CON,",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n= . PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR Value on all other = 1111. PR2, Value on POR, BOR Value on all other = 1111. PR2, Resets = 1111. PR2, Resets = 1111. PR2,  = \nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer2 module.",
    "14.0 TIMER3 MODULE\nThe  Timer3  module  timer/counter  has  the  following features:\n- \u00b7 16-bit timer/counter\n(two 8-bit registers; TMR3H and TMR3L)\n\u00b7 Readable and writable (both registers)\n\u00b7 Internal or external clock select\n\u00b7 Interrupt-on-overflow from FFFFh to 0000h\n\u00b7 Reset from CCP module trigger\nFigure 14-1 is a simplified block diagram of the Timer3 module.\nRegister 14-1 shows the Timer3 Control register. This register  controls  the  operating  mode  of  the  Timer3 module and sets the CCP clock source.\nRegister 12-1 shows the Timer1 Control register. This register  controls  the  operating  mode  of  the  Timer1 module,  as  well  as  contains  the  Timer1  Oscillator Enable bit (T1OSCEN), which can be a clock source for Timer3.",
    "REGISTER 14-1: T3CON: TIMER3 CONTROL REGISTER\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. RD16, 1 = -. RD16, 2 = T3CKPS1. RD16, 3 = T3CKPS0. RD16, 4 = T3CCP1. RD16, 5 = T3SYNC. RD16, 6 = TMR3CS. RD16, 7 = TMR3ON. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit",
    "REGISTER 14-1: T3CON: TIMER3 CONTROL REGISTER\n7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7 RD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register read/write of Timer3 in one 16-bit operation 0 = Enables register read/write of Timer3 in two 8-bit operations\nbit 6\nUnimplemented : Read as ' 0 '\nbit 5-4\nT3CKPS<1:0>:\nTimer3 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value",
    "bit 3\nT3CCP1: Timer3 and Timer1 to CCP1 Enable bits\n1 = Timer3 is the clock source for compare/capture CCP module\n0 = Timer1 is the clock source for compare/capture CCP module",
    "bit 2\nT3SYNC: Timer3 External Clock Input Synchronization Control bit\n(Not usable if the system clock comes from Timer1/Timer3.)\nWhen TMR3CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR3CS = 0 :\nThis bit is ignored. Timer3 uses the internal clock when TMR3CS = 0 .",
    "bit 1\nTMR3CS: Timer3 Clock Source Select bit\n1 = External clock input from Timer1 oscillator or T13CKI\n(on the rising edge after the first falling edge)\n0 = Internal clock (FOSC/4)",
    "bit 0\nTMR3ON: Timer3 On bit\n1 = Enables Timer3\n0 = Stops Timer3",
    "14.1 Timer3 Operation\nTimer3 can operate in one of these modes:\n\u00b7 As a timer\n\u00b7 As a synchronous counter\n\u00b7 As an asynchronous counter\nThe operating mode is determined by the clock select bit, TMR3CS (T3CON<1>).\nWhen TMR3CS = 0 , Timer3 increments every instruction cycle. When TMR3CS = 1 , Timer3 increments on every rising edge of the Timer1 external clock input or the Timer1 oscillator, if enabled.\nWhen the Timer1 oscillator is enabled (T1OSCEN is set),  the  RB7/PGD/T1OSI/P1D/KBI3  and  RB6/PGC/ T1OSO/T13CKI/P1C/KBI2  pins  become  inputs.  That is, the TRISB7:TRISB6 value is ignored and the pins are read as ' 0 '.\nTimer3 also has an internal  'Reset input'. This Reset can be generated by the CCP module (see Section 15.4.4 'Special Event Trigger' ).",
    "14.2 Timer1 Oscillator\nThe Timer1 oscillator may be used as the clock source for Timer3. The Timer1 oscillator is enabled by setting the T1OSCEN (T1CON<3>) bit. The oscillator is a lowpower oscillator rated for 32 kHz crystals. See Section 12.2 'Timer1 Oscillator' for further details.",
    "14.4 Resetting Timer3 Using a CCP Trigger Output\nIf  the  CCP  module  is  configured  in  Compare  mode to generate a 'special event trigger' (CCP1M3:CCP1M0 = 1011 ), this signal will reset Timer3. See Section 15.4.4 'Special Event Trigger' for more information.",
    "Note:\nThe TMR3 register pair (TMR3H:TMR3L) increments from  0000h  to  FFFFh  and  rolls  over  to  0000h.  The TMR3 interrupt, if enabled, is generated on overflow, which is latched in interrupt flag bit, TMR3IF (PIR2<1>). This interrupt can be enabled/disabled by setting/clearing  TMR3  Interrupt  Enable  bit,  TMR3IE (PIE2<1>).\nThe special event triggers from the CCP module  will not set interrupt flag bit, TMR3IF (PIR1<0>).\nTimer3 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If  Timer3  is  running  in  Asynchronous  Counter mode, this Reset operation may not work. In the event that a write to Timer3 coincides with a special event trigger from CCP1, the write will take precedence. In this mode of operation, the CCPR1H:CCPR1L  register  pair effectively becomes the period register for Timer3.",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on all other Resets = 0000 000u. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = -. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = -. PIR2, Value on POR, BOR = 0--0 -00-. PIR2, Value on all other Resets = 0--0 -00-. PIE2, Bit 7",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\n= OSCFIE. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = -. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = -. PIE2, Value on POR, BOR = 0--0 -00-. PIE2, Value on all other Resets = 0--0 -00-. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = -. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = -. IPR2, Value on POR, BOR = 1--1 -11-. IPR2, Value on all other Resets = 1--1 -11-. TMR3L, Bit 7 = Holding Register for the Least Significant Byte",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nof the 16-bit TMR3 Register xxxx. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register xxxx. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register xxxx. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register xxxx. TMR3L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register xxxx. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register xxxx. TMR3L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register xxxx. TMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register xxxx. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on all",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nother Resets = uuuu uuuu. TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Value on POR, BOR",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\n= xxxx xxxx. TMR3H, Value on all other Resets = uuuu uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0000 0000. T1CON, Value on all other Resets = u0uu uuuu. T3CON, Bit 7 = RD16. T3CON, Bit 6 = -. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 =",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nTMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0-00 0000. T3CON, Value on all other Resets = u-uu uuuu\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer3 module.",
    "15.0 ENHANCED CAPTURE/ COMPARE/PWM (ECCP) MODULE\nThe control register for CCP1 is shown in Register 15-1.\nThe  Enhanced  CCP  module  is  implemented  as  a standard CCP module with Enhanced PWM capabilities.  These  capabilities  allow  for  two  or  four output  channels,  user-selectable  polarity,  dead-band control  and  automatic  shutdown  and  restart  and  are discussed in detail in Section 15.5 'Enhanced PWM Mode' .\nIn addition to the expanded functions of the CCP1CON register, the ECCP module has two additional registers  associated  with  Enhanced  PWM  operation and auto-shutdown features:\n\u00b7 PWM1CON\n\u00b7 ECCPAS",
    "REGISTER 15-1: CCP1CON REGISTER FOR ENHANCED CCP OPERATION\nP1M1, U-0 = P1M0. P1M1, R/W-0/0 = DC1B1. P1M1, R/W-0/0 = DC1B0. P1M1, R/W-0/0 = CCP1M3. P1M1, R/W-0/0 = CCP1M2. P1M1, R/W-0/0 = CCP1M1. P1M1, R/W-0/0 = CCP1M0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0,",
    "REGISTER 15-1: CCP1CON REGISTER FOR ENHANCED CCP OPERATION\nR/W-0/0 = bit 7 bit 0\nR = Readable bit,  = W=Writable bit. R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged,  = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7-6 P1M<1:0>: PWM Output Configuration bits\nIf CCP1M<3:2> = 00, 01, 10 :\nxx = P1A assigned as Capture/Compare input; P1B, P1C, P1D assigned as port pins",
    "If CCP1M<3:2> = 11 :\n00 = Single output; P1A modulated; P1B, P1C, P1D assigned as port pins\n01 = Full-bridge output forward; P1D modulated; P1A active; P1B, P1C inactive\n10 = Half-bridge output; P1A, P1B modulated with dead-band control; P1C, P1D assigned as port pins\n11 = Full-bridge output reverse; P1B modulated; P1C active; P1A, P1D inactive",
    "bit 5-4 DC1B<1:0>: PWM Duty Cycle Least Significant bits\nCapture mode:\nUnused.\nCompare mode:\nUnused.\nPWM mode:\nThese bits are the two LSbs of the PWM duty cycle. The eight MSbs are found in CCPR1L.",
    "bit 3-0 CCP1M<3:0>: ECCP1 Mode Select bits\n0000 = Capture/Compare/PWM off (resets ECCP module)\n0001 = Unused (reserved)\n0010 = Compare mode, toggle output on match (ECCP1IF bit is set)\n0011 = Unused (reserved)\n0100 = Capture mode, every falling edge\n0101 = Capture mode, every rising edge\n0110 = Capture mode, every 4th rising edge\n0111 = Capture mode, every 16th rising edge\n1000 = Compare mode, set output on match (ECCP1IF bit is set)\n1001 = Compare mode, clear output on match (ECCP1IF bit is set)\n1010 = Compare mode, generate software interrupt on match (ECCP1IF bit is set,\nECCP1 pin returns to port pin operation)\n= Compare mode, trigger special event (ECCP1IF bit is set; ECCP resets TMR1 or\n1011 TMR3 and starts an A/D conversion if the A/D module is enabled)\n1100 = PWM mode; P1A, P1C active-high; P1B, P1D active-high",
    "bit 3-0 CCP1M<3:0>: ECCP1 Mode Select bits\n1101 = PWM mode; P1A, P1C active-high; P1B, P1D active-low\n1110 = PWM mode; P1A, P1C active-low; P1B, P1D active-high\n1111 = PWM mode; P1A, P1C active-low; P1B, P1D active-low",
    "15.1 ECCP Outputs\nThe  Enhanced  CCP  module  may  have  up  to  four outputs,  depending  on  the  selected  operating  mode. These  outputs,  designated  P1A  through  P1D,  are multiplexed with I/O pins on PORTB. The pin assignments are summarized in Table 15-1.\nTo configure I/O pins as PWM outputs, the proper PWM mode  must  be  selected  by  setting  the  P1Mn  and CCP1Mn bits (CCP1CON<7:6> and <3:0>, respectively). The appropriate TRISB direction bits for the port pins must also be set as outputs.",
    "TABLE 15-1: PIN ASSIGNMENTS FOR VARIOUS ECCP MODES\nCompatible CCP, CCP1CON Configuration = 00xx 11xx. Compatible CCP, RB3 = CCP1. Compatible CCP, RB2 = RB2/INT2. Compatible CCP, RB6 = RB6/PGC/T1OSO/T13CKI/KBI2. Compatible CCP, RB7 = RB7/PGD/T1OSI/KBI3. Dual PWM, CCP1CON Configuration = 10xx 11xx. Dual PWM, RB3 = P1A. Dual PWM, RB2 = P1B. Dual PWM, RB6 = RB6/PGC/T1OSO/T13CKI/KBI2. Dual PWM, RB7 = RB7/PGD/T1OSI/KBI3. Quad PWM, CCP1CON Configuration = x1xx 11xx. Quad PWM, RB3 = P1A. Quad PWM, RB2 = P1B. Quad PWM, RB6 = P1C. Quad PWM, RB7 = P1D",
    "TABLE 15-1: PIN ASSIGNMENTS FOR VARIOUS ECCP MODES\nLegend: x = Don't care. Shaded cells indicate pin assignments not used by ECCP in a given mode.\nNote 1: TRIS register values must be configured appropriately.",
    "15.2 CCP Module\nCapture/Compare/PWM Register 1 (CCPR1) is comprised of two 8-bit registers: CCPR1L (low byte) and CCPR1H (high byte). The CCP1CON register controls the operation of CCP1. All are readable and writable.",
    "TABLE 15-2: CCP MODE - TIMER RESOURCE\nCapture Compare PWM, Timer Resource = Timer1 or Timer3 Timer1 or Timer3 Timer2",
    "15.3 Capture Mode\nIn Capture mode, CCPR1H:CCPR1L captures the 16-bit value of the TMR1 or TMR3 registers when an event occurs on pin RB3/CCP1/P1A. An event is defined as one of the following:\n\u00b7 every falling edge\n\u00b7 every rising edge\n\u00b7 every 4th rising edge\n\u00b7 every 16th rising edge\nThe event is selected by control bits, CCP1M3:CCP1M0 (CCP1CON<3:0>). When a capture is made, the interrupt request flag bit, CCP1IF (PIR1<2>), is set; it must be cleared in software. If another capture occurs before the value in register CCPR1 is read, the old captured value is overwritten by the new captured value.",
    "15.3.1 CCP PIN CONFIGURATION\nIn  Capture  mode,  the  RB3/CCP1/P1A pin  should  be configured as an input by setting the TRISB<3> bit.\nNote:\nIf the RB3/CCP1/P1A is configured as an output,  a  write  to  the  port  can  cause  a capture condition.",
    "15.3.2 TIMER1/TIMER3 MODE SELECTION\nThe timers that are to be used with the capture feature (either Timer1 and/or Timer3) must be running in Timer mode  or  Synchronized  Counter  mode.  In  Asynchronous  Counter  mode,  the  capture  operation  may  not work.  The  timer  to  be  used  with  the  CCP  module  is selected in the T3CON register.",
    "15.3.3 SOFTWARE INTERRUPT\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep bit, CCP1IE  (PIE1<2>),  clear  while changing  capture modes to avoid false interrupts and should clear the flag bit, CCP1IF, following any such change in operating mode.",
    "15.3.4 CCP PRESCALER\nThere  are  four  prescaler  settings,  specified  by  bits CCP1M3:CCP1M0.  Whenever  the  CCP  module  is turned off or the CCP module is not in Capture mode, the prescaler counter is cleared. This means that any Reset will clear the prescaler counter.\nrecommended method for switching between capture prescalers.  This  example  also  clears  the  prescaler counter and will not generate the 'false' interrupt.",
    "EXAMPLE 15-1: CHANGING BETWEEN CAPTURE PRESCALERS\nSwitching from one capture prescaler to another may generate an interrupt. Also, the prescaler counter will not be cleared; therefore, the first capture may be from a non-zero prescaler. Example 15-1 shows the\nCLRF\nCCP1CON\n; Turn CCP module off\nMOVLW\nNEW_CAPT_PS\n; Load WREG with the\n; new prescaler mode\n; value and CCP ON\nMOVWF\nCCP1CON\n; Load CCP1CON with\n; this value",
    "15.4.2 TIMER1/TIMER3 MODE SELECTION\nIn Compare mode, the 16-bit CCPR1 register value is constantly compared against either the TMR1 register pair  value,  or  the  TMR3  register  pair  value.  When  a match occurs, the RB3/CCP1/P1A pin:\n\u00b7 Is driven high\n\u00b7 Is driven low\n\u00b7 Toggles output (high-to-low or low-to-high)\n\u00b7 Remains unchanged (interrupt only)\nThe action on the pin is based on the value of control bits,  CCP1M3:CCP1M0.  At  the  same  time,  interrupt flag bit, CCP1IF, is set.",
    "15.4.1 CCP PIN CONFIGURATION\nThe user must configure the RB3/CCP1/P1A pin as an output by clearing the TRISB<3> bit.\nNote:, 1 = Clearing the CCP1CON register will force the RB3/CCP1/P1A compare output latch to the default low level. This is not the PORTB I/O data latch.\nTimer1 and/or Timer3 must be running in Timer mode or Synchronized Counter mode if the CCP module is using the compare feature. In Asynchronous Counter mode, the compare operation may not work.",
    "15.4.3 SOFTWARE INTERRUPT MODE\nWhen generate software interrupt is chosen, the RB3/ CCP1/P1A pin is not affected. CCP1IF is set and an interrupt is generated (if enabled).",
    "15.4.4 SPECIAL EVENT TRIGGER\nIn this mode, an internal hardware trigger is generated, which may be used to initiate an action.\nThe special  event  trigger  output  of  CCP1  resets  the TMR1 register pair. This allows the CCPR1 register to effectively be a 16-bit programmable period register for Timer1.\nThe special event trigger also sets the GO/DONE bit (ADCON0<1>). This starts a conversion of the currently selected A/D channel if the A/D is on.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nPIR1, Value on POR, BOR = -000. PIR1, Value on all other Resets = -000. PIR1, Value on all other Resets = -000. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Value on POR, BOR = -000. PIE1, Value on all other Resets = -000. PIE1, Value on all other Resets = -000. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 =",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111. IPR1, Value on POR, BOR = -111. IPR1, Value on all other Resets = -111. IPR1, Value on all other Resets = -111. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111. TRISB, Value on POR, BOR = 1111. TRISB, Value on all other Resets = 1111. TRISB, Value on all other Resets = 1111. TMR1L, Bit 7 = Holding Register for the Least Significant Byte",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nof the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\non all other Resets = uuuu. TMR1L, Value on all other Resets = uuuu. TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR1 Register. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on all other Resets = uuuu. TMR1H, Value on all other Resets = uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0000. T1CON, Value on POR, BOR = 0000. T1CON, Value on all other Resets = uuuu. T1CON, Value on all other Resets = uuuu. CCPR1L, Bit 7 =",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCapture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other Resets = uuuu. CCPR1L, Value on all other Resets = uuuu. CCPR1H, Bit 7",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other Resets = uuuu. CCPR1H, Value on all other Resets = uuuu. CCP1CON, Bit",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n7 = P1M1. CCP1CON, Bit 6 = P1M0. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on all other Resets = 0000. CCP1CON, Value on all other Resets = 0000. TMR3L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3 Register. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on all other Resets = uuuu. TMR3L, Value on all other Resets = uuuu. TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on all other Resets = uuuu.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3H, Value on all other Resets = uuuu. T3CON, Bit 7 = RD16. T3CON, Bit 6 = -. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0-00. T3CON, Value on POR, BOR = 0000. T3CON, Value on all other Resets = u-uu. T3CON, Value on all other Resets = uuuu. ADCON0, Bit 7 = VCFG1. ADCON0, Bit 6 = VCFG0. ADCON0, Bit 5 = -. ADCON0, Bit 4 = CHS2. ADCON0, Bit 3 = CHS1. ADCON0, Bit 2 =",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCHS0. ADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = 00-0. ADCON0, Value on POR, BOR = 0000. ADCON0, Value on all other Resets = 00-0. ADCON0, Value on all other Resets = 0000\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by Capture and Timer1.",
    "15.5 Enhanced PWM Mode\nThe Enhanced PWM Mode provides additional PWM output options for a broader range of control applications. The module is an upwardly compatible version of the standard CCP module and offers up to four outputs, designated P1A through P1D. Users are also able to select  the  polarity  of  the  signal  (either  active-high  or active-low). The module's output mode and polarity are configured by setting the P1M1:P1M0 and CCP1M3CCP1M0  bits  of  the  CCP1CON  register (CCP1CON<7:6> and CCP1CON<3:0>, respectively).",
    "15.5 Enhanced PWM Mode\nFigure 15-3 shows a simplified block diagram of PWM operation. All control registers are double-buffered and are loaded at the beginning of a new PWM cycle (the period boundary when Timer2 resets) in order to prevent glitches on any of the outputs. The exception is the PWM Delay register, ECCP1DEL, which is loaded at either the duty cycle boundary or the boundary period (whichever comes first). Because of the buffering, the module waits until the assigned timer resets instead of starting immediately. This means that Enhanced PWM waveforms do not  exactly  match  the  standard  PWM  waveforms,  but are instead offset by one full instruction cycle (4 TOSC).\nAs  before,  the  user  must  manually  configure  the appropriate TRIS bits for output.",
    "15.5.1 PWM PERIOD\nThe  PWM  period  is  specified  by  writing  to  the  PR2 register. The PWM period can be calculated using the equation:",
    "EQUATION 15-1: PWM PERIOD\nPWM Period   =\n[(PR2) + 1] \u2022 4 \u2022 TOSC \u2022\n(TMR2 Prescale Value)\nPWM frequency is defined as 1/[PWM period]. When TMR2 is equal to PR2, the following three events occur on the next increment cycle:\n\u00b7 TMR2 is cleared\n\u00b7 The CCP1 pin is set (if PWM duty cycle = 0%, the CCP1 pin will not be set)\n\u00b7 The PWM duty cycle is copied from CCPR1L into CCPR1H\nNote:",
    "15.5.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the CCPR1L register and to the CCP1CON<5:4> bits. Up to 10-bit resolution is available. The CCPR1L contains the eight MSbs and the CCP1CON<5:4> contains the two LSbs. This 10-bit value is represented by CCPR1L:CCP1CON<5:4>.  The  PWM  duty  cycle  is calculated by the equation:",
    "EQUATION 15-2: PWM DUTY CYCLE\nPWM Duty Cycle  =\n(CCPR1L:CCP1CON<5:4>) \u2022\nTOSC \u2022 (TMR2 Prescale Value)\nCCPR1L and CCP1CON<5:4> can be written to at any time,  but  the  duty  cycle  value  is  not  copied  into CCPR1H until a match between PR2 and TMR2 occurs (i.e., the period is complete). In PWM mode, CCPR1H is a read-only register.\nThe  CCPR1H  register  and  a  2-bit  internal  latch  are used  to  double-buffer the PWM  duty  cycle.  This double-buffering is essential for glitchless PWM operation.  When the  CCPR1H and 2-bit latch match TMR2, concatenated with an internal 2-bit Q clock or two  bits  of  the  TMR2  prescaler,  the  CCP1  pin  is cleared.  The  maximum  PWM  resolution  (bits)  for  a given PWM frequency is given by the equation:",
    "EQUATION 15-3: PWM RESOLUTION\n<!-- formula-not-decoded -->\nNote:\nIf the PWM duty cycle value is longer than the PWM period, the CCP1 pin will not be cleared.",
    "15.5.3 PWM OUTPUT CONFIGURATIONS\nThe P1M1:P1M0 bits in the CCP1CON register allow one of four configurations:\n\u00b7 Single Output\n\u00b7 Half-Bridge Output\n\u00b7 Full-Bridge Output, Forward mode\n\u00b7 Full-Bridge Output, Reverse mode\nThe Timer2 postscaler (see Section 13.0 'Timer2  Module' ) is not  used  in  the determination of the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.\nThe Single Output mode is the Standard PWM mode discussed in Section 15.5 'Enhanced PWM Mode' . The  Half-Bridge  and  Full-Bridge  Output  modes  are covered in detail in the sections that follow.\nThe general relationship of the outputs in all configurations is summarized in Figure 15-4.",
    "TABLE 15-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.77 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.25 kHz = 1. Timer Prescaler (1, 4, 16), 312.50 kHz = 1. Timer Prescaler (1, 4, 16), 416.67 kHz = 1. PR2 Value, 2.44 kHz = FFh. PR2 Value, 9.77 kHz = FFh. PR2 Value, 39.06 kHz = FFh. PR2 Value, 156.25 kHz = 3Fh. PR2 Value, 312.50 kHz = 1Fh. PR2 Value, 416.67 kHz = 17h. Maximum Resolution (bits), 2.44 kHz = 10. Maximum Resolution (bits), 9.77 kHz = 10. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits), 156.25 kHz =",
    "TABLE 15-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\n8. Maximum Resolution (bits), 312.50 kHz = 7. Maximum Resolution (bits), 416.67 kHz = 6.58",
    "FIGURE 15-4: PWM OUTPUT RELATIONSHIPS (ACTIVE-HIGH STATE)\n00, CCP1CON<7:6> = (Single Output). 00, SIGNAL = P1A Modulated. 00, 0 = Delay (1). 00,  = (1). 00, PR2+1 = . 10, CCP1CON<7:6> = (Half-Bridge). 10, SIGNAL = P1A Modulated P1B Modulated. 10, 0 = . 10,  = . 10, PR2+1 = . 01, CCP1CON<7:6> = (Full-Bridge, Forward). 01, SIGNAL = P1A Active P1B Inactive. 01, 0 = . 01,  = . 01, PR2+1 = . 11, CCP1CON<7:6> = (Full-Bridge, Reverse). 11, SIGNAL = P1C Inactive P1D Modulated P1A Inactive P1B Modulated. 11, 0 = . 11,  = . 11, PR2+1 = ",
    "FIGURE 15-5: PWM OUTPUT RELATIONSHIPS (ACTIVE-LOW STATE)\n00, CCP1CON<7:6> = (Single Output). 00, SIGNAL = P1A Modulated. 00, 0 = . 00,  = . 00, PR2+1 = . 10, CCP1CON<7:6> = (Half-Bridge). 10, SIGNAL = P1A Modulated P1B Modulated. 10, 0 = Delay (1). 10,  = Delay (1). 10, PR2+1 = . 01, CCP1CON<7:6> = (Full-Bridge, Forward). 01, SIGNAL = P1A Active. 01, 0 = . 01,  = . 01, PR2+1 = . , CCP1CON<7:6> = . , SIGNAL = P1B Inactive. , 0 = . ,  = . , PR2+1 = . , CCP1CON<7:6> = P1C Inactive. , SIGNAL = P1D Modulated. , 0 = . ,",
    "FIGURE 15-5: PWM OUTPUT RELATIONSHIPS (ACTIVE-LOW STATE)\n= . , PR2+1 = . 11, CCP1CON<7:6> = P1B. 11, SIGNAL = P1A Inactive. 11, 0 = . 11,  = . 11, PR2+1 = . , CCP1CON<7:6> = Modulated (Full-Bridge,. , SIGNAL = . , 0 = . ,  = . , PR2+1 = . , CCP1CON<7:6> = P1C Active Reverse). , SIGNAL = . , 0 = . ,  = . , PR2+1 = . , CCP1CON<7:6> = P1D Inactive. , SIGNAL = . , 0 = . ,  = . , PR2+1 = ",
    "Relationships:\n\u00b7 Period = 4 * TOSC * (PR2 + 1) * (TMR2 Prescale Value)\n\u00b7 Duty Cycle = TOSC * (CCPR1L<7:0>:CCP1CON<5:4>) * (TMR2 Prescale Value)\n\u00b7 Delay = 4 * TOSC * (PWM1CON<6:0>)\nNote\n1:\nDead-band delay is programmed using the PWM1CON register ( Section 15.5.6 'Programmable Dead-Band Delay' ).",
    "15.5.4 HALF-BRIDGE MODE\nIn the Half-Bridge Output mode, two pins are used as outputs  to  drive  push-pull  loads.  The  PWM  output signal is output on the RB3/CCP1/P1A pin, while the complementary  PWM  output  signal  is  output  on  the RB2/P1B/INT2  pin  (Figure 15-6).  This  mode  can  be used for half-bridge applications, as shown in Figure 15-7, or for full-bridge applications, where four power switches  are  being  modulated  with  two  PWM signals.\nThe TRISB<3> and TRISB<2> bits must be cleared to configure P1A and P1B as outputs.\nFIGURE 15-6: HALF-BRIDGE PWM OUTPUT (ACTIVE-HIGH)",
    "15.5.4 HALF-BRIDGE MODE\nIn  Half-Bridge  Output  mode, the programmable deadband  delay  can  be  used  to  prevent  shoot-through current in half-bridge power devices. The value of bits, PDC6:PDC0  (PWM1CON<6:0>),  sets  the  number  of instruction cycles before the output is driven active. If the value is greater than the duty cycle, the corresponding output  remains  inactive  during  the  entire  cycle.  See Section 15.5.6  'Programmable  Dead-Band  Delay' for more details of the dead-band delay operations.",
    "15.5.5 FULL-BRIDGE MODE\nIn  Full-Bridge  Output  mode,  four  pins  are  used  as outputs; however, only two outputs are active at a time. In the Forward mode, pin RB3/CCP1/P1A is continuously  active  and  pin  RB7/PGD/T1OSI/P1D/KBI3  is modulated.  In the Reverse  mode,  pin  RB6/PGC/ T1OSO/T13CKI/P1C/KBI2 is continuously active and pin RB2/P1B/INT2 is modulated. These are illustrated in Figure 15-8.\nThe TRISB<3:2> and TRISB<7:6> bits must be cleared to make the P1A, P1B, P1C and P1D pins output.",
    "FIGURE 15-8: FULL-BRIDGE PWM OUTPUT (ACTIVE-HIGH)\nP1A, Forward Mode. = . P1A, Forward Mode.Period = . P1A, Forward Mode. = . P1A, Forward Mode. = . , Forward Mode. = Duty Cycle. , Forward Mode.Period = . , Forward Mode. = . , Forward Mode. = . P1B, Forward Mode. = . P1B, Forward Mode.Period = . P1B, Forward Mode. = . P1B, Forward Mode. = . P1B, Forward Mode. = (1) Duty Cycle. P1B, Forward Mode.Period = . P1B, Forward Mode. = (1). P1B, Forward Mode. = . Reverse Mode, Forward Mode. = . Reverse Mode, Forward Mode.Period = Period. Reverse Mode, Forward Mode. = . Reverse Mode, Forward Mode. = . P1A, Forward Mode. = . P1A, Forward Mode.Period = . P1A, Forward Mode. = . P1A, Forward Mode. = . , Forward Mode. = . , Forward Mode.Period = . , Forward Mode. = (1).",
    "FIGURE 15-8: FULL-BRIDGE PWM OUTPUT (ACTIVE-HIGH)\n, Forward Mode. = . P1C, Forward Mode. = . P1C, Forward Mode.Period = . P1C, Forward Mode. = . P1C, Forward Mode. = . P1D, Forward Mode. = (1) the TMR2 register is. P1D, Forward Mode.Period = . P1D, Forward Mode. = . P1D, Forward Mode. = . 1: At this time, equal to the, Forward Mode. = . 1: At this time, equal to the, Forward Mode.Period = . 1: At this time, equal to the, Forward Mode. = . 1: At this time, equal to the, Forward Mode. = . PR2, Forward Mode. = . PR2, Forward Mode.Period = . PR2, Forward Mode. = . PR2, Forward Mode. = . register., Forward Mode. = . register., Forward Mode.Period = . register., Forward Mode. = . register., Forward Mode. = . Note, Forward Mode. = . Note, Forward Mode.Period = . Note, Forward Mode. = .",
    "FIGURE 15-8: FULL-BRIDGE PWM OUTPUT (ACTIVE-HIGH)\nNote, Forward Mode. = ",
    "15.5.5.1 Direction Change in Full-Bridge Mode\nIn  the  Full-Bridge  Output  mode,  the  P1M1  bit  in  the CCP1CON  register  allows  the  user  to  control  the Forward/Reverse direction. When the application firmware changes this direction control bit, the module will assume the new direction on the next PWM cycle.\nJust  before  the  end  of  the  current  PWM  period,  the modulated outputs (P1B and P1D) are placed in their inactive state, while the unmodulated outputs (P1A and P1C) are switched to drive in the opposite direction. This  occurs  in  a  time  interval  of  (4  TOSC  *  (Timer2 Prescale Value) before the next PWM period begins. The Timer2 prescaler will be either 1,4 or 16, depending  on  the  value  of  the  T2CKPS  bit  (T2CON<1:0>). During the interval from the switch of the unmodulated outputs  to the beginning  of  the  next  period,  the modulated  outputs  (P1B  and  P1D)  remain  inactive. This relationship is shown in Figure 15-10.",
    "15.5.5.1 Direction Change in Full-Bridge Mode\nNote that in the Full-Bridge Output mode, the ECCP module  does  not  provide  any  dead-band  delay.  In general, since only one output is modulated at all times, dead-band delay is not required. However, there is a situation where a dead-band delay might be required. This situation occurs  when  both  of  the  following conditions are true:\n1. The direction of the PWM output changes when the duty cycle of the output is at or near 100%.\n2. The turn-off time of the power switch, including the  power  device  and  driver  circuit,  is  greater than the turn-on time.",
    "15.5.5.1 Direction Change in Full-Bridge Mode\nFigure 15-11 shows an example where the PWM direction changes from forward to reverse, at a near 100% duty cycle. At time t1, the output P1A and P1D become inactive,  while  output  P1C  becomes  active.  In  this example, since the turn-off time of the power devices is longer than the turn-on time, a shoot-through current may  flow  through  power  devices  QC  and  QD  (see Figure 15-9) for the duration of 't'. The same phenomenon will occur to power devices QA and QB for PWM direction change from reverse to forward.\nIf changing PWM direction at high duty cycle is required for  an  application,  one  of  the  following  requirements must be met:\n1. Reduce PWM  for a PWM  period before changing directions.\n2. Use switch drivers that can drive the switches off faster than they can drive them on.\nOther  options  to  prevent  shoot-through  current  may exist.",
    "15.5.6 PROGRAMMABLE DEAD-BAND DELAY\nIn half-bridge applications where all power switches are modulated  at  the  PWM  frequency  at  all  times,  the power switches normally require more time to turn off than  to  turn  on.  If  both  the  upper  and  lower  power switches are switched at the same time (one turned on and the other turned off), both switches may be on for a short period of time until one switch completely turns off. During this brief interval, a very high current (shootthrough current) may flow through both power switches,  shorting  the  bridge  supply.  To  avoid  this potentially destructive shoot-through current from flowing  during  switching,  turning  on  either  of  the  power switches is normally delayed to allow the other switch to completely turn off.\nIn the Half-Bridge Output mode, a digitally programmable dead-band  delay  is  available  to  avoid  shoot-through current from destroying the bridge power switches. The delay occurs at the signal transition from the non-active state to the active state. See Figure 15-6 for an illustration.  The  lower  seven  bits  of  the  PWM1CON  register (Register 15-2) sets the delay period in terms of microcontroller instruction cycles (T CY or 4 TOSC).",
    "15.5.7 ENHANCED PWM AUTO-SHUTDOWN\nWhen  the  ECCP  is  programmed  for  any  of  the Enhanced PWM modes, the active output pins may be configured for auto-shutdown. Auto-shutdown immediately  places  the  Enhanced  PWM  output  pins  into  a defined shutdown state when  a shutdown event occurs.\nA shutdown event can be caused by the INT0, INT1 or INT2 pins (or any combination of these three sources). The  auto-shutdown  feature  can  be  disabled  by  not selecting any auto-shutdown sources. The autoshutdown sources to be used are selected using the ECCPAS2:ECCPAS0 bits (bits <6:4> of the ECCPAS register).",
    "15.5.7 ENHANCED PWM AUTO-SHUTDOWN\nWhen a shutdown occurs, the output pins are asynchronously placed in their shutdown states, specified by the PSSAC1:PSSAC0 and PSSBD1:PSSBD0 bits  (ECCPAS<3:0>).  Each  pin  pair  (P1A/P1C  and P1B/P1D) may be set to drive high, drive low or be tristated (not driving). The ECCPASE bit (ECCPAS<7>) is also set to hold the Enhanced PWM outputs in their shutdown states.\nThe ECCPASE bit is set by hardware when a shutdown event occurs. If automatic restarts are not enabled, the ECCPASE bit is cleared by firmware when the cause of the shutdown clears. If automatic restarts are enabled, the  ECCPASE  bit  is  automatically  cleared  when  the cause of the auto-shutdown has cleared.",
    "15.5.7 ENHANCED PWM AUTO-SHUTDOWN\nIf the ECCPASE bit is set when a PWM period begins, the PWM outputs remain in their shutdown state for that entire PWM period. When the ECCPASE bit is cleared, the PWM outputs will return to normal operation at the beginning of the next PWM period.\nNote:\nWriting  to  the  ECCPASE  bit  is  disabled while a shutdown condition is active.",
    "REGISTER 15-2: PWM1CON: PWM CONFIGURATION REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. PRSEN, 1 = PDC6. PRSEN, 2 = PDC5. PRSEN, 3 = PDC4. PRSEN, 4 = PDC3. PRSEN, 5 = PDC2. PRSEN, 6 = PDC1. PRSEN, 7 = PDC0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7\nPRSEN: PWM Restart Enable bit\n1 = Upon auto-shutdown, the ECCPASE bit clears automatically once the shutdown event goes away; the PWM restarts automatically\n0 = Upon auto-shutdown, ECCPASE must be cleared in software to restart the PWM\nPDC<6:0>: PWM Delay Count bits\nNumber  of  FOSC/4  (4  *  TOSC)  cycles  between  the  scheduled  time  when  a  PWM  signal should transition active and the actual time it transitions active.",
    "REGISTER 15-3: ECCPAS: ENHANCED CAPTURE/COMPARE/PWM/AUTO-SHUTDOWN CONTROL REGISTER\nECCPASE, R/W-0/0 = ECCPAS2. ECCPASE, R/W-0/0 = ECCPAS1. ECCPASE, R/W-0/0 = ECCPAS0. ECCPASE, R/W-0/0 = PSSAC1. ECCPASE, R/W-0/0 = PSSAC0. ECCPASE, R/W-0/0 = PSSBD1. ECCPASE, R/W-0/0 = PSSBD0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0. bit 7 bit 0,",
    "REGISTER 15-3: ECCPAS: ENHANCED CAPTURE/COMPARE/PWM/AUTO-SHUTDOWN CONTROL REGISTER\nR/W-0/0 = bit 7 bit 0\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = \nbit 7\nECCPASE: ECCP Auto-Shutdown Event Status bit\n0 = ECCP outputs are operating\n1 = A shutdown event has occurred; ECCP outputs are in shutdown state\nbit 6\nECCPAS2: ECCP Auto-Shutdown bit 2\n0 = INT0 pin has no effect\n1 = INT0 pin low causes shutdown\nbit 5\nECCPAS1: ECCP Auto-Shutdown bit 1\n0 = INT2 pin has no effect\n1 = INT2 pin low causes shutdown\nbit 4",
    "REGISTER 15-3: ECCPAS: ENHANCED CAPTURE/COMPARE/PWM/AUTO-SHUTDOWN CONTROL REGISTER\nECCPAS0: ECCP Auto-Shutdown bit 0\n0 = INT1 pin has no effect\n1 = INT1 pin low causes shutdown",
    "bit 3-2\nPSSACn: Pins A and C Shutdown State Control bits\n00 = Drive Pins A and C to ' 0 '\n01 = Drive Pins A and C to ' 1 '\n1x = Pins A and C tri-state",
    "bit 1-0\nPSSBDn: Pins B and D Shutdown State Control bits\n00 = Drive Pins B and D to ' 0 '\n01 = Drive Pins B and D to ' 1 '\n1x = Pins B and D tri-state",
    "15.5.7.1 Auto-Shutdown and Automatic Restart\nThe auto-shutdown feature can be configured to allow automatic restarts of the module, following a shutdown event. This is enabled by setting the PRSEN bit of the PWM1CON register (PWM1CON<7>).\nIn Shutdown mode with PRSEN = 1 (Figure 15-12), the ECCPASE bit will remain set for as long as the cause of the shutdown continues. When  the shutdown condition  clears,  the  ECCPASE  bit  is  automatically cleared. If PRSEN = 0 (Figure 15-13), once a shutdown condition occurs, the ECCPASE bit will remain set until it  is  cleared by firmware. Once ECCPASE is cleared, the Enhanced PWM will resume at the beginning of the next PWM period.\nNote:, 1 = Writing to the ECCPASE bit is disabled while a shutdown condition is active.\nIndependent of the PRSEN bit setting, the ECCPASE bit  cannot  be  cleared  as  long  as  the  cause  of  the shutdown persists.",
    "15.5.8 START-UP CONSIDERATIONS\nWhen the ECCP module is used in the PWM mode, the application hardware must use the proper external pullup and/or pull-down resistors on the PWM output pins. When the microcontroller is released from Reset, all of the  I/O  pins  are  in  the  high-impedance  state.  The external circuits must keep the power switch devices in the off state, until the microcontroller drives the I/O pins with  the  proper  signal  levels,  or  activates  the  PWM output(s).\nThe  CCP1M1:CCP1M0  bits  (CCP1CON<1:0>)  allow the user to choose whether the PWM output signals are active-high or active-low for each pair of PWM output pins (P1A/P1C  and  P1B/P1D).  The  PWM  output polarities must be selected before the PWM pins are configured as outputs. Changing the polarity configuration while the PWM pins are configured as outputs is not recommended, since it may result in damage to the application circuits.",
    "15.5.8 START-UP CONSIDERATIONS\nThe Auto-Shutdown mode can be forced by writing a ' 1 ' to the ECCPASE bit.\nThe P1A, P1B, P1C and P1D output latches may not be in the proper states when the PWM module is initialized. Enabling the PWM pins for output at the same time as the ECCP module may cause damage to the application circuit. The ECCP module must be enabled in the proper output mode and complete a full PWM cycle, before configuring the PWM pins as outputs. The completion of a full PWM cycle is indicated by the TMR2IF bit being set as the second PWM period begins.",
    "15.5.9 SETUP FOR PWM OPERATION\nThe following steps should be taken when configuring the ECCP1 module for PWM operation:",
    "15.5.9 SETUP FOR PWM OPERATION\n1. Configure  the  PWM  pins  P1A  and  P1B  (and P1C and P1D, if used) as inputs by setting the corresponding TRISB bits.\n2. Set the PWM period by loading the PR2 register.\n3. Configure  the  ECCP  module  for  the  desired PWM  mode  and  configuration  by  loading  the CCP1CON register with the appropriate values:\n\u00b7 Select one of the available output configurations and direction with the P1M1:P1M0 bits.\n\u00b7 Select the polarities of the PWM output signals with the CCP1M3:CCP1M0 bits.\n4. Set the PWM duty cycle by loading the CCPR1L register and CCP1CON<5:4> bits.\n5. For  Half-Bridge  Output  mode,  set  the  deadband  delay  by  loading  PWM1CON<6:0>  with the appropriate value.\n6. If auto-shutdown operation is required, load the ECCPAS register:\n\u00b7 Select the auto-shutdown sources using the ECCPAS<2:0> bits.",
    "15.5.9 SETUP FOR PWM OPERATION\n\u00b7 Select the shutdown states of the PWM output pins using PSSAC1:PSSAC0 and PSSBD1:PSSBD0 bits.\n\u00b7 Set the ECCPASE bit (ECCPAS<7>).\n7. If auto-restart  operation  is  required,  set  the PRSEN bit (PWM1CON<7>).\n8. Configure and start TMR2:\n\u00b7 Clear the TMR2 interrupt flag bit by clearing the TMR2IF bit (PIR1<1>).\n\u00b7 Set the TMR2 prescale value by loading the T2CKPS bits (T2CON<1:0>).\n\u00b7 Enable Timer2 by setting the TMR2ON bit (T2CON<2>).\n9. Enable  PWM outputs after  a  new  PWM  cycle has started:\n\u00b7 Wait until TMR2 overflows (TMR2IF bit is set).\n\u00b7 Enable the CCP1/P1A, P1B, P1C and/or P1D pin outputs by clearing the respective TRISB bits.",
    "15.5.9 SETUP FOR PWM OPERATION\n\u00b7 Clear the ECCPASE bit (ECCPAS<7>).",
    "15.5.10 OPERATION IN LOW-POWER MODES\nIn  the  Low-Power Sleep mode, all clock sources are disabled. Timer2 will not increment and the state of the module will not change. If the ECCP pin is driving a value,  it  will  continue  to  drive  that  value.  When  the device wakes up, it will continue from this state. If TwoSpeed Start-ups are enabled, the initial start-up frequency may not be stable if the INTOSC is being used.\nIn PRI_IDLE mode, the primary clock will continue to clock the ECCP module without change.\nIn all other low-power modes, the selected low-power mode clock will clock Timer2. Other low-power mode clocks  will  most  likely  be  different  than  the  primary clock frequency.",
    "15.5.10.1 Operation with Fail-Safe Clock Monitor\nIf the Fail-Safe Clock Monitor is enabled (CONFIG1H<6>  is  programmed),  a  clock  failure  will force the device into the Low-Power RC_RUN mode and the OSCFIF bit (PIR2<7>) will be set. The ECCP will  then  be  clocked  from  the  INTRC  clock  source, which may have a different clock frequency than the primary  clock.  By  loading  the  IRCF2:IRCF0  bits  on Resets,  the  user  can  enable  the  INTOSC  at  a  high clock speed in the event of a clock failure.\nSee the previous section for additional details.",
    "15.5.11 EFFECTS OF A RESET\nBoth  power-on  and  subsequent  Resets  will  force  all ports  to  input  mode  and  the  CCP  registers  to  their Reset states.\nThis forces the Enhanced CCP module to reset to a state compatible with the standard CCP module.",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0--1. RCON, Value on POR, BOR = 11qq. RCON, Value on all other",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\nResets = 0--q. RCON, Value on all other Resets = qquu. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000. PIR1, Value on POR, BOR = -000. PIR1, Value on all other Resets = -000. PIR1, Value on all other Resets = -000. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 =",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\nTMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Value on POR, BOR = -000. PIE1, Value on all other Resets = -000. PIE1, Value on all other Resets = -000. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111. IPR1, Value on POR, BOR = -111. IPR1, Value on all other Resets = -111. IPR1, Value on all other Resets = -111. TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register.",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\nTMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Value on all other Resets = 0000. TMR2, Value on all other Resets = 0000. PR2, Bit 7 = Timer2 Module Period Register. PR2, Bit 6 = Timer2 Module Period Register. PR2, Bit 5 = Timer2 Module Period Register. PR2, Bit 4 = Timer2 Module Period Register. PR2, Bit 3 = Timer2 Module Period Register. PR2, Bit 2 = Timer2 Module Period Register. PR2, Bit 1 = Timer2 Module Period Register. PR2, Bit 0 = Timer2 Module Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\nBOR = 1111. PR2, Value on all other Resets = 1111. PR2, Value on all other Resets = 1111. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Value on all other Resets = -000. T2CON, Value on all other Resets = 0000. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\nDirection Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111. TRISB, Value on POR, BOR = 1111. TRISB, Value on all other Resets = 1111. TRISB, Value on all other Resets = 1111. CCPR1H, Bit 7 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Enhanced Capture/Compare/PWM Register 1 High Byte.",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\nCCPR1H, Bit 0 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other Resets = uuuu. CCPR1H, Value on all other Resets = uuuu. CCPR1L, Bit 7 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Enhanced",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\nCapture/Compare/PWM Register 1 Low Byte. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other Resets = uuuu. CCPR1L, Value on all other Resets = uuuu. CCP1CON, Bit 7 = P1M1. CCP1CON, Bit 6 = P1M0. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on all other Resets = 0000. CCP1CON, Value on all other Resets =",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n0000. ECCPAS, Bit 7 = ECCPASE. ECCPAS, Bit 6 = ECCPAS2. ECCPAS, Bit 5 = ECCPAS1. ECCPAS, Bit 4 = ECCPAS0. ECCPAS, Bit 3 = PSSAC1. ECCPAS, Bit 2 = PSSAC0. ECCPAS, Bit 1 = PSSBD1. ECCPAS, Bit 0 = PSSBD0. ECCPAS, Value on POR, BOR = 0000. ECCPAS, Value on POR, BOR = 0000. ECCPAS, Value on all other Resets = 0000. ECCPAS, Value on all other Resets = 0000. PWM1CON, Bit 7 = PRSEN. PWM1CON, Bit 6 = PDC6. PWM1CON, Bit 5 = PDC5. PWM1CON, Bit 4 = PDC4. PWM1CON, Bit 3 = PDC3. PWM1CON, Bit 2 = PDC2. PWM1CON, Bit 1 =",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\nPDC1. PWM1CON, Bit 0 = PDC0. PWM1CON, Value on POR, BOR = 0000. PWM1CON, Value on POR, BOR = 0000. PWM1CON, Value on all other Resets = uuuu. PWM1CON, Value on all other Resets = uuuu. OSCCON, Bit 7 = IDLEN. OSCCON, Bit 6 = IRCF2. OSCCON, Bit 5 = IRCF1. OSCCON, Bit 4 = IRCF0. OSCCON, Bit 3 = OSTS. OSCCON, Bit 2 = IOFS. OSCCON, Bit 1 = SCS1. OSCCON, Bit 0 = SCS0. OSCCON, Value on POR, BOR = 0000. OSCCON, Value on POR, BOR = qq00. OSCCON, Value on all other Resets = 0000. OSCCON, Value on all other Resets = qq00\nLegend:",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '.\nShaded cells are not used by the ECCP module in Enhanced PWM mode.",
    "16.0 ENHANCED ADDRESSABLE UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\nThe  Enhanced  Addressable  Universal  Synchronous Asynchronous Receiver Transmitter  (EUSART)  module  can  be  configured  as  a  full-duplex  asynchronous system that can communicate with peripheral devices, such as CRT terminals and personal computers. It can also be  configured  as  a  half-duplex  synchronous system that can communicate with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs, etc.\nThe Enhanced Addressable USART module implements  additional  features,  including  automatic baud rate detection and calibration, automatic wake-up on Sync Break reception  and 12-bit  Break  character transmit. These features make it ideally suited for use in Local Interconnect Network (LIN) bus systems.\nThe  EUSART  can  be  configured  in  the  following modes:",
    "16.0 ENHANCED ADDRESSABLE UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\n\u00b7 Asynchronous (full duplex) with:\n-Auto-wake-up on character reception\n-Auto-baud calibration\n-12-bit Break character transmission\n\u00b7 Synchronous - Master (half duplex) with selectable clock polarity\n\u00b7 Synchronous - Slave (half duplex) with selectable clock polarity\nThe RB1/AN5/TX/CK/INT1 and RB4/AN6/RX/DT/KBI0 pins  must  be  configured  as  follows  for  use  with  the Universal Synchronous Asynchronous Receiver Transmitter:\n\u00b7 SPEN (RCSTA<7>) bit must be set ( = 1 ),\n\u00b7 PCFG6:PCFG5 (ADCON1<5:6>) must be set ( = 1 ),\n\u00b7 TRISB<4> bit must be set ( = 1 ) and\n\u00b7 TRISB<1> bit must be set ( = 1 ).\nNote:\nThe  EUSART  control  will  automatically reconfigure the pin from input to output as needed.",
    "16.0 ENHANCED ADDRESSABLE UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\nThe  operation  of  the  Enhanced  USART  module  is controlled through three registers:\n\u00b7 Transmit Status and Control (TXSTA)\n\u00b7 Receive Status and Control (RCSTA)\n\u00b7 Baud Rate Control (BAUDCTL)\nThese  are  detailed  in  on  the  following  pages  in Register 16-1, Register 16-2 and Register 16-3, respectively.",
    "16.1 Asynchronous Operation in Power Managed Modes\nThe  EUSART  may  operate  in  Asynchronous  mode while the peripheral clocks are being provided by the internal  oscillator  block.  This  makes  it  possible  to remove  the  crystal  or  resonator  that  is  commonly connected  as  the  primary  clock  on  the  OSC1  and OSC2 pins.\nThe factory calibrates the internal oscillator block output  (INTOSC)  for  8 MHz  (see  Table 22-6).  However, this frequency may  drift as VDD  or temperature changes  and  this  directly  affects  the  asynchronous baud  rate.  Two  methods  may  be  used  to  adjust  the baud  rate  clock,  but  both  require  a  reference  clock source of some kind.\nThe  first (preferred) method  uses  the  OSCTUNE register to adjust the INTOSC output back to 8 MHz. Adjusting the value in the OSCTUNE register allows for fine resolution changes to the system clock source (see Section 3.6  'INTOSC  Frequency  Drift' for more information).\nThe other method adjusts the value in the Baud Rate Generator  (BRG).  There  may  not  be  fine  enough resolution when adjusting the Baud Rate Generator to compensate  for  a  gradual  change  in  the  peripheral clock frequency.",
    "REGISTER 16-1: TXSTA: TRANSMIT STATUS AND CONTROL REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R-1/1. R/W-0/0, 7 = R/W-0/0. CSRC, 1 = TX9. CSRC, 2 = TXEN (1). CSRC, 3 = SYNC. CSRC, 4 = SENDB. CSRC, 5 = BRGH. CSRC, 6 = TRMT. CSRC, 7 = TX9D. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7\nCSRC: Clock Source Select bit\nAsynchronous mode:\nDon't care.\nSynchronous mode:\n1 = Master mode (clock generated internally from BRG)\n0 = Slave mode (clock from external source)",
    "bit 6\nTX9: 9-bit Transmit Enable bit\n1 = Selects 9-bit transmission\n0 = Selects 8-bit transmission\nbit 5 TXEN: Transmit Enable bit (1)\n1 = Transmit enabled\n0 = Transmit disabled",
    "bit 4\nSYNC: EUSART Mode Select bit\n1 = Synchronous mode\n0 = Asynchronous mode",
    "bit 3\nSENDB: Send Break Character bit\nAsynchronous mode:\n1 = Send Sync Break on next transmission (cleared by hardware upon completion)\n0 = Sync Break transmission completed\nSynchronous mode:\nDon't care.\nbit 2\nBRGH: High Baud Rate Select bit\nAsynchronous mode:\n1 = High speed\n0 = Low speed\nSynchronous mode:\nUnused in this mode.",
    "bit 1\nTRMT: Transmit Shift Register Status bit\n1 = TSR Idle\n0 = TSR busy",
    "bit 0\nTX9D: 9th bit of Transmit Data\nCan be address/data bit or a parity bit.\nNote 1: SREN/CREN overrides TXEN in Sync mode.",
    "REGISTER 16-2: RCSTA: RECEIVE STATUS AND CONTROL REGISTER\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R-0/0. R/W-0/0, 6 = R-0/0. R/W-0/0, 7 = R-x. SPEN, 1 = RX9. SPEN, 2 = SREN. SPEN, 3 = CREN. SPEN, 4 = ADDEN. SPEN, 5 = FERR. SPEN, 6 = OERR. SPEN, 7 = RX9D\nbit 7\nbit 0",
    "REGISTER 16-2: RCSTA: RECEIVE STATUS AND CONTROL REGISTER\nR = Readable bit u = Bit is, W=Writable bit = x = Bit is unknown. R = Readable bit u = Bit is, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "bit 7 SPEN: Serial Port Enable bit\n1 = Serial port enabled (configures RX/DT and TX/CK pins as serial port pins)\n0 = Serial port disabled (held in Reset)\nRX9: 9-bit Receive Enable bit\n- 1 = Selects 9-bit reception\n0 = Selects 8-bit reception\nSREN: Single Receive Enable bit\nAsynchronous mode:\nDon't care.",
    "Synchronous mode - Master:\n1 = Enables single receive\n0 = Disables single receive\nThis bit is cleared after reception is complete.\nSynchronous mode - Slave:\nDon't care.\nCREN: Continuous Receive Enable bit\nAsynchronous mode:\n1 = Enables receiver\n0 = Disables receiver",
    "Synchronous mode:\n1 = Enables continuous receive until enable bit, CREN, is cleared (CREN overrides SREN)\n- 0 = Disables continuous receive\nADDEN: Address Detect Enable bit\nAsynchronous mode 9-bit (RX9 = 1 ):\n1 = Enables address detection, generates RCIF interrupt and loads RCREG when RX9D is set\n0 = Disables address detection, all bytes are received and ninth bit can be used as parity bit\nAsynchronous mode 8-bit (RX9 = 0 ):\nDon't care.\nFERR: Framing Error bit\n1 = Framing error (can be updated by reading RCREG register and receiving next valid byte)\n- 0 = No framing error\nOERR: Overrun Error bit\n1 = Overrun error (can be cleared by clearing bit CREN)\n0 = No overrun error\nRX9D: 9th bit of Received Data\nThis can be address/data bit or a parity bit and must be calculated by user firmware.",
    "bit 5\nbit 4",
    "bit 3\nbit 2",
    "REGISTER 16-3: BAUDCTL: BAUD RATE CONTROL REGISTER\nU-0, 1 = R-1. U-0, 2 = U-0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = U-0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = RCIDL. -, 2 = -. -, 3 = SCKP. -, 4 = BRG16. -, 5 = -. -, 6 = WUE. -, 7 = ABDEN. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 6 RCIDL : Receive Operation Idle Status bit\n1 = Receiver is Idle\n0 = Receiver is busy",
    "bit 5\nUnimplemented: Read as ' 0 '",
    "bit 4 SCKP : Synchronous Clock Polarity Select bit\nAsynchronous mode:\nUnused in this mode.\nSynchronous mode:\n1 = Idle state for clock (CK) is a high level\n0 = Idle state for clock (CK) is a low level",
    "bit 3 BRG16: 16-bit Baud Rate Register Enable bit\n1 = 16-bit Baud Rate Generator - SPBRGH and SPBRG\n0 = 8-bit Baud Rate Generator - SPBRG only (Compatible mode), SPBRGH value ignored",
    "bit 1 WUE: Wake-up Enable bit\nAsynchronous mode:\n1 = EUSART will continue to sample the RX pin - interrupt generated on falling edge; bit cleared in hardware on following rising edge\n0 = RX pin not monitored or rising edge detected\nSynchronous mode:\nUnused in this mode.\nABDEN : Auto-Baud Detect Enable bit\nAsynchronous mode:\n1\n= Enable baud rate measurement on the next character - requires reception of a Sync byte (55h); cleared in hardware upon completion\n0 = Baud rate measurement disabled or completed\nSynchronous mode:\nUnused in this mode.",
    "16.2 EUSART Baud Rate Generator (BRG)\nThe BRG is a dedicated 8-bit or 16-bit generator, that supports  both  the  Asynchronous  and  Synchronous modes of the EUSART. By default, the BRG operates in  8-bit  mode; setting the BRG16 bit (BAUDCTL<3>) selects 16-bit mode.\nThe SPBRGH:SPBRG register pair controls the period of  a  free  running  timer.  In  Asynchronous  mode,  bits BRGH (TXSTA<2>) and BRG16 also control the baud rate.  In  Synchronous  mode,  bit  BRGH  is  ignored. Table 16-1  shows the formula for computation of the baud  rate  for  different  EUSART  modes  which  only apply in Master mode (internally generated clock).",
    "16.2 EUSART Baud Rate Generator (BRG)\nGiven  the  desired  baud  rate  and  FOSC,  the  nearest integer value for the SPBRGH:SPBRG registers can be calculated using the formulas in Table 16-1. From this, the error in baud rate can be determined. An example calculation  is  shown  in  Example 16-1.  Typical  baud rates  and  error  values  for  the  various  asynchronous modes are shown in Table 16-2. It may be advantageous to use the high baud rate (BRGH = 1 ), or  the  16-bit  BRG  to  reduce  the  baud  rate  error,  or achieve a slow baud rate for a fast oscillator frequency.\nWriting a new value to the SPBRGH:SPBRG registers causes  the  BRG timer to be reset (or cleared).  This ensures  the  BRG does not  wait  for  a  timer  overflow before outputting the new baud rate.",
    "TABLE 16-1: BAUD RATE FORMULAS\n0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[64 (n + 1)]. 0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 1. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 1. 0,",
    "TABLE 16-1: BAUD RATE FORMULAS\nBRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 0. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 1. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]\nLegend: x = Don't care, n = value of SPBRGH:SPBRG register pair",
    "EXAMPLE 16-1: CALCULATING BAUD RATE ERROR\nFor a device with FOSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, 8-bit BRG:\nDesired Baud Rate= FOSC/(64 ([SPBRGH:SPBRG] + 1))\nSolving for SPBRGH:SPBRG:\nX\n= ((FOSC/Desired Baud Rate)/64) - 1\n= ((16000000/9600)/64) - 1\n= [25.042] = 25\nCalculated Baud Rate=16000000/(64 (25 + 1))\n- = 9615\nError\n= (Calculated Baud Rate - Desired Baud Rate)/Desired Baud Rate\n= (9615 - 9600)/9600 = 0.16%",
    "16.2.1 POWER MANAGED MODE OPERATION\nThe system clock is used to generate the desired baud rate; however,  when  a  power  managed  mode  is entered, the clock source may be operating at a different frequency than in PRI_RUN mode. In Sleep mode, no  clocks  are  present  and  in  PRI_IDLE  mode,  the primary clock source continues to provide clocks to the Baud Rate Generator; however, in other power managed  modes,  the  clock  frequency  will  probably change. This may require the value in SPBRG to be adjusted.\nIf the system clock is changed during an active receive operation, a receive error or data loss may result. To avoid this problem, check the status of the RCIDL bit and make sure that the receive operation is Idle before changing the system clock.",
    "16.2.2 SAMPLING\nThe data on the RB4/AN6/RX/DT/KBI0 pin is sampled three times by a majority detect circuit to determine if a high or a low level is present at the RX pin.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nTXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR Value = 0000. TXSTA, Value on POR, BOR Value = -010. TXSTA, on all other Resets = 0000. TXSTA, on all other Resets = -010. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR Value = 0000. RCSTA, Value on POR, BOR Value = -00x. RCSTA, on all other Resets = 0000.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nRCSTA, on all other Resets = -00x. BAUDCTL, Bit 7 = -. BAUDCTL, Bit 6 = RCIDL. BAUDCTL, Bit 5 = -. BAUDCTL, Bit 4 = SCKP. BAUDCTL, Bit 3 = BRG16. BAUDCTL, Bit 2 = -. BAUDCTL, Bit 1 = WUE. BAUDCTL, Bit 0 = ABDEN. BAUDCTL, Value on POR, BOR Value = -1-1. BAUDCTL, Value on POR, BOR Value = 0-00. BAUDCTL, on all other Resets = -1-1. BAUDCTL, on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register High Byte.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nSPBRGH, Bit 2 = Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register High Byte. SPBRGH, Value on POR, BOR Value = 0000. SPBRGH, Value on POR, BOR Value = 0000. SPBRGH, on all other Resets = 0000. SPBRGH, on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register Low Byte. SPBRG, Value on POR, BOR Value = 0000. SPBRG, Value on POR,",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nBOR Value = 0000. SPBRG, on all other Resets = 0000. SPBRG, on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used by the BRG.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 1.221. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 255. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n64. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 , BRG16",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 31. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 15. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K)",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 9615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 15. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 7. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n-. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 4. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 52.083. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -9.58. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 2. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 104.167. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -9.58. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 2. 115.2, SYNC = 0 , BRGH = 0",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 78.125. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -32.18. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "SYNC = 0 , BRGH = 0 , BRG16 = 0\n0.3, FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, FOSC = 4.000 MHz.% Error = 0.16. 0.3, FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 0.3, FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, FOSC = 2.000 MHz.% Error = -0.16. 0.3, FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 0.3, FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, FOSC = 1.000 MHz.% Error = -0.16. 0.3, FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 1.2, FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, FOSC = 4.000 MHz.% Error = 0.16.",
    "SYNC = 0 , BRGH = 0 , BRG16 = 0\n1.2, FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 1.2, FOSC = 2.000 MHz.Actual Rate (K) = 1201. 1.2, FOSC = 2.000 MHz.% Error = -0.16. 1.2, FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 1.2, FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, FOSC = 1.000 MHz.% Error = -0.16. 1.2, FOSC = 1.000 MHz.SPBRG value (decimal) = 12. 2.4, FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, FOSC = 4.000 MHz.% Error = 0.16. 2.4, FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 2.4, FOSC = 2.000 MHz.Actual Rate (K) =",
    "SYNC = 0 , BRGH = 0 , BRG16 = 0\n2403. 2.4, FOSC = 2.000 MHz.% Error = -0.16. 2.4, FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 2.4, FOSC = 1.000 MHz.Actual Rate (K) = -. 2.4, FOSC = 1.000 MHz.% Error = -. 2.4, FOSC = 1.000 MHz.SPBRG value (decimal) = -. 9.6, FOSC = 4.000 MHz.Actual Rate (K) = 8.929. 9.6, FOSC = 4.000 MHz.% Error = -6.99. 9.6, FOSC = 4.000 MHz.SPBRG value (decimal) = 6. 9.6, FOSC = 2.000 MHz.Actual Rate (K) = -. 9.6, FOSC = 2.000 MHz.% Error = -. 9.6, FOSC = 2.000 MHz.SPBRG value (decimal) = -.",
    "SYNC = 0 , BRGH = 0 , BRG16 = 0\n9.6, FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, FOSC = 1.000 MHz.% Error = -. 9.6, FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, FOSC = 4.000 MHz.Actual Rate (K) = 20.833. 19.2, FOSC = 4.000 MHz.% Error = 8.51. 19.2, FOSC = 4.000 MHz.SPBRG value (decimal) = 2. 19.2, FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, FOSC = 2.000 MHz.% Error = -. 19.2, FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, FOSC = 1.000 MHz.% Error = -. 19.2, FOSC = 1.000",
    "SYNC = 0 , BRGH = 0 , BRG16 = 0\nMHz.SPBRG value (decimal) = -. 57.6, FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, FOSC = 4.000 MHz.% Error = 8.51. 57.6, FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 57.6, FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, FOSC = 2.000 MHz.% Error = -. 57.6, FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, FOSC = 1.000 MHz.% Error = -. 57.6, FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 115.2, FOSC = 4.000 MHz.% Error =",
    "SYNC = 0 , BRGH = 0 , BRG16 = 0\n-45.75. 115.2, FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 115.2, FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, FOSC = 2.000 MHz.% Error = -. 115.2, FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, FOSC = 1.000 MHz.% Error = -. 115.2, FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n10.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.766.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.%",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nError = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n40.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal)",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 10. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 55555. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 1",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n, BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -\nSYNC = 0 , BRGH = 1 , BRG16 = 0",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, FOSC = 4.000 MHz.Actual Rate (K) = -. 0.3, FOSC = 4.000 MHz.% Error = -. 0.3, FOSC = 4.000 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 2.000 MHz.Actual Rate (K) = -. 0.3, FOSC = 2.000 MHz.% Error = -. 0.3, FOSC = 2.000 MHz.SPBRG value (decimal) = -. 0.3, FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, FOSC = 1.000 MHz.% Error = -0.16. 0.3, FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, FOSC = 4.000 MHz.% Error = 0.16. 1.2,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nFOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, FOSC = 2.000 MHz.Actual Rate (K) = 1201. 1.2, FOSC = 2.000 MHz.% Error = -0.16. 1.2, FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, FOSC = 1.000 MHz.% Error = -0.16. 1.2, FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, FOSC = 4.000 MHz.% Error = 0.16. 2.4, FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, FOSC = 2.000 MHz.Actual Rate (K) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2403. 2.4, FOSC = 2.000 MHz.% Error = -0.16. 2.4, FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, FOSC = 1.000 MHz.% Error = -0.16. 2.4, FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, FOSC = 4.000 MHz.% Error = 0.16. 9.6, FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, FOSC = 2.000 MHz.% Error = -0.16. 9.6, FOSC = 2.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.SPBRG value (decimal) = 12. 9.6, FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, FOSC = 1.000 MHz.% Error = -. 9.6, FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, FOSC = 4.000 MHz.% Error = 0.16. 19.2, FOSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2, FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, FOSC = 2.000 MHz.% Error = -. 19.2, FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, FOSC = 1.000 MHz.% Error",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= -. 19.2, FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, FOSC = 4.000 MHz.% Error = 8.51. 57.6, FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, FOSC = 2.000 MHz.% Error = -. 57.6, FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, FOSC = 1.000 MHz.% Error = -. 57.6, FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, FOSC = 4.000 MHz.Actual Rate (K) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n125.000. 115.2, FOSC = 4.000 MHz.% Error = 8.51. 115.2, FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, FOSC = 2.000 MHz.% Error = -. 115.2, FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, FOSC = 1.000 MHz.% Error = -. 115.2, FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 8332. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 4165. 0.3, SYNC = 0 , BRGH = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nRate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 2082. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 1041. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200. 1.2,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -0.03. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 520. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 415. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 2.402. 2.4, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 40.000 MHz.% Error = 0.06. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.399. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 259. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 259. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 129.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nRate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 55555. 57.6,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 20.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = -\nSYNC = 0 , BRGH = 0 , BRG16 = 1",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, FOSC = 4.000 MHz.% Error = 0.04. 0.3, FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 0.3, FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, FOSC = 2.000 MHz.% Error = -0.16. 0.3, FOSC = 2.000 MHz.SPBRG value (decimal) = 415. 0.3, FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, FOSC = 1.000 MHz.% Error = -0.16. 0.3, FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, FOSC = 4.000 MHz.% Error =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.16. 1.2, FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, FOSC = 2.000 MHz.Actual Rate (K) = 1201. 1.2, FOSC = 2.000 MHz.% Error = -0.16. 1.2, FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, FOSC = 1.000 MHz.% Error = -0.16. 1.2, FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, FOSC = 4.000 MHz.% Error = 0.16. 2.4, FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, FOSC = 2.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = 2403. 2.4, FOSC = 2.000 MHz.% Error = -0.16. 2.4, FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, FOSC = 1.000 MHz.% Error = -0.16. 2.4, FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, FOSC = 4.000 MHz.% Error = 0.16. 9.6, FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, FOSC = 2.000 MHz.% Error = -0.16. 9.6, FOSC",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 2.000 MHz.SPBRG value (decimal) = 12. 9.6, FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, FOSC = 1.000 MHz.% Error = -. 9.6, FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, FOSC = 4.000 MHz.% Error = 0.16. 19.2, FOSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2, FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, FOSC = 2.000 MHz.% Error = -. 19.2, FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, FOSC = 1.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.% Error = -. 19.2, FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, FOSC = 4.000 MHz.% Error = 8.51. 57.6, FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, FOSC = 2.000 MHz.% Error = -. 57.6, FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, FOSC = 1.000 MHz.% Error = -. 57.6, FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, FOSC = 4.000 MHz.Actual Rate (K)",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 125.000. 115.2, FOSC = 4.000 MHz.% Error = 8.51. 115.2, FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, FOSC = 2.000 MHz.% Error = -. 115.2, FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, FOSC = 1.000 MHz.% Error = -. 115.2, FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 33332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.00.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 16665. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 8332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 300.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.01. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 6665. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 8332.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 4165. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 2.400.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 4165. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 2082.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.402. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.06. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 1040. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 832. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.606. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.06. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n9.596. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal)",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 259. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 19.193. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -0.03.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 520. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 259. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 19.231.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 103. 57.6,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 57.803. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.35. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 172. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 57.471. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.22. 57.6, SYNC",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 86. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 57142. 57.6, SYNC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 0.79. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 34. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 114.943. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -0.22. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 86. 115.2, SYNC = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 116.279. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.94. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 42. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 117647. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -2.12. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 16\nSYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, FOSC = 4.000 MHz.% Error = 0.01. 0.3, FOSC = 4.000 MHz.SPBRG value (decimal) = 3332. 0.3, FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, FOSC = 2.000 MHz.% Error = -0.04. 0.3, FOSC = 2.000 MHz.SPBRG value (decimal) = 1665. 0.3, FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, FOSC = 1.000 MHz.% Error = -0.04. 0.3, FOSC = 1.000 MHz.SPBRG value (decimal) = 832. 1.2, FOSC = 4.000 MHz.Actual Rate (K) = 1.200. 1.2, FOSC = 4.000 MHz.% Error =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.04. 1.2, FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 1.2, FOSC = 2.000 MHz.Actual Rate (K) = 1201. 1.2, FOSC = 2.000 MHz.% Error = -0.16. 1.2, FOSC = 2.000 MHz.SPBRG value (decimal) = 415. 1.2, FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, FOSC = 1.000 MHz.% Error = -0.16. 1.2, FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 2.4, FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, FOSC = 4.000 MHz.% Error = 0.16. 2.4, FOSC = 4.000 MHz.SPBRG value (decimal) = 415. 2.4, FOSC = 2.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = 2403. 2.4, FOSC = 2.000 MHz.% Error = -0.16. 2.4, FOSC = 2.000 MHz.SPBRG value (decimal) = 207. 2.4, FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, FOSC = 1.000 MHz.% Error = -0.16. 2.4, FOSC = 1.000 MHz.SPBRG value (decimal) = 103. 9.6, FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, FOSC = 4.000 MHz.% Error = 0.16. 9.6, FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 9.6, FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, FOSC = 2.000 MHz.% Error = -0.16. 9.6, FOSC",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 2.000 MHz.SPBRG value (decimal) = 51. 9.6, FOSC = 1.000 MHz.Actual Rate (K) = 9615. 9.6, FOSC = 1.000 MHz.% Error = -0.16. 9.6, FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 19.2, FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, FOSC = 4.000 MHz.% Error = 0.16. 19.2, FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 19.2, FOSC = 2.000 MHz.Actual Rate (K) = 19230. 19.2, FOSC = 2.000 MHz.% Error = -0.16. 19.2, FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 19.2, FOSC = 1.000 MHz.Actual Rate (K) = 19230.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, FOSC = 1.000 MHz.% Error = -0.16. 19.2, FOSC = 1.000 MHz.SPBRG value (decimal) = 12. 57.6, FOSC = 4.000 MHz.Actual Rate (K) = 58.824. 57.6, FOSC = 4.000 MHz.% Error = 2.12. 57.6, FOSC = 4.000 MHz.SPBRG value (decimal) = 16. 57.6, FOSC = 2.000 MHz.Actual Rate (K) = 55555. 57.6, FOSC = 2.000 MHz.% Error = 3.55. 57.6, FOSC = 2.000 MHz.SPBRG value (decimal) = 8. 57.6, FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, FOSC = 1.000 MHz.% Error = -. 57.6, FOSC = 1.000 MHz.SPBRG value (decimal) = -.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n115.2, FOSC = 4.000 MHz.Actual Rate (K) = 111.111. 115.2, FOSC = 4.000 MHz.% Error = -3.55. 115.2, FOSC = 4.000 MHz.SPBRG value (decimal) = 8. 115.2, FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, FOSC = 2.000 MHz.% Error = -. 115.2, FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, FOSC = 1.000 MHz.% Error = -. 115.2, FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "16.2.3 AUTO-BAUD RATE DETECT\nThe Enhanced USART module supports the automatic detection and calibration of baud rate. This feature is active only in Asynchronous mode and while the WUE bit is clear.\nThe automatic baud rate measurement  sequence (Figure 16-1) begins whenever a Start bit is received and the ABDEN bit is set. The calculation is self-averaging.\nIn the Auto-Baud Rate Detect (ABD) mode, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RX signal, the RX signal is timing the BRG. In ABD mode, the internal Baud Rate Generator is used as a counter to time the bit period of the incoming serial byte stream.",
    "16.2.3 AUTO-BAUD RATE DETECT\nOnce the ABDEN bit is set, the state machine will clear the BRG and look for a Start bit. The Auto-Baud Detect must  receive  a  byte  with  the  value  55h  (ASCII  'U', which is also the LIN bus Sync character), in order to calculate the proper bit rate. The measurement is taken over both a low and a high bit time in order to minimize any effects caused by asymmetry of the incoming signal. After a Start bit,  the SPBRG begins counting up using the preselected clock source on the first rising edge of RX. After eight bits on the RX pin, or the fifth rising edge, an accumulated value totaling the proper BRG period is left in the SPBRGH:SPBRG registers. Once the fifth edge is seen (should correspond to the Stop bit), the ABDEN bit is automatically cleared.",
    "16.2.3 AUTO-BAUD RATE DETECT\nWhile  calibrating the baud  rate  period, the BRG registers are clocked at 1/8th the preconfigured clock rate. Note that the BRG clock will be configured by the BRG16 and BRGH bits. Independent of the BRG16 bit setting, both the SPBRG and SPBRGH will be used as a 16-bit counter. This allows the user to verify that no carry occurred for 8-bit modes, by checking for 00h in the SPBRGH register. Refer to Table 16-4 for counter clock rates to the BRG.\nWhile  the  ABD  sequence  takes  place,  the  EUSART state machine is held in Idle. The RCIF interrupt is set once the fifth rising edge on RX is detected. The value in  the  RCREG  needs  to  be  read  to  clear  the  RCIF interrupt. RCREG content should be discarded.",
    "16.2.3 AUTO-BAUD RATE DETECT\n- Note 1: It  is  up  to  the  user to determine that the incoming character baud rate is within the range of the selected BRG clock source. Some combinations of oscillator frequency  and  EUSART  baud  rates  are not possible due to bit error rates. Overall system  timing  and  communication  baud rates  must  be  taken  into  consideration when using the Auto-Baud Rate Detection feature.",
    "16.2.4 RECEIVING A SYNC (AUTO-BAUD RATE DETECT)\nTo receive a Sync (Auto-Baud Rate Detect):\n1. Configure the EUSART for asynchronous receive. TXEN  should  remain  clear.  SPBRGH:SPBRG may be left as is. The controller should operate in either PRI_RUN or PRI_IDLE.\n2. Enable RXIF interrupts. Set RCIE, PEIE, GIE.\n3. Enable Auto-Baud Rate Detect. Set ABDEN.\n4. When  the  next RCIF  interrupt occurs, the received baud rate has been measured. Read RCREG  to  clear  RCIF  and  discard.  Check SPBRGH:SPBRG for a valid value. The EUSART is ready for normal communications. Return  from  the  interrupt.  Allow  the  primary clock to run (PRI_RUN or PRI_IDLE).\n5. Process  subsequent  RCIF  interrupts  normally as in asynchronous reception. Remain in PRI_RUN  or  PRI_IDLE  until  communications are complete.",
    "TABLE 16-4: BRG COUNTER CLOCK RATES\n0, BRGH = 0. 0, BRG Counter Clock = FOSC/512. 0, BRGH = 1. 0, BRG Counter Clock = FOSC/128. 1, BRGH = 0. 1, BRG Counter Clock = FOSC/128. 1, BRGH = 1. 1, BRG Counter Clock = FOSC/32\nNote: During the ABD sequence, SPBRG and SPBRGH are both used as a 16-bit counter, independent of BRG16 setting.",
    "16.3 EUSART Asynchronous Mode\nThe Asynchronous mode of operation is selected by clearing the SYNC bit (TXSTA<4>). In this mode, the EUSART uses standard Non-Return-to-Zero (NRZ) format (one Start bit, eight or nine data bits and one Stop bit). The most common data format is eight bits. An onchip dedicated 8-bit/16-bit Baud Rate Generator can be used to derive standard baud rate frequencies from the oscillator.",
    "16.3.1 EUSART ASYNCHRONOUS TRANSMITTER\nThe EUSART transmits and receives the LSb first. The EUSART's  transmitter  and  receiver  are  functionally independent, but use the same data format and baud rate. The Baud Rate Generator produces a clock, either x16 or x64 of the bit shift rate, depending on the BRGH and BRG16 bits (TXSTA<2> and BAUDCTL<3>). Parity is not supported by the hardware, but can be implemented in software and stored as the ninth data bit.\nAsynchronous  mode  is  available  in  all  low-power modes; it is available in Sleep mode only when autowake-up on Sync Break is enabled. When in PRI_IDLE mode, no changes to the Baud Rate Generator values are  required;  however,  other low-power  mode  clocks may  operate  at  another  frequency  than  the  primary clock. Therefore, the Baud Rate Generator values may need to be adjusted.\nWhen operating in Asynchronous mode, the EUSART module consists of the following important elements:",
    "16.3.1 EUSART ASYNCHRONOUS TRANSMITTER\n\u00b7 Baud Rate Generator\n\u00b7 Sampling Circuit\n\u00b7 Asynchronous Transmitter\n\u00b7 Asynchronous Receiver\n\u00b7 Auto-Wake-up on Sync Break Character\n\u00b7 12-bit Break Character Transmit\n\u00b7 Auto-Baud Rate Detection\nThe  EUSART transmitter  block  diagram  is  shown  in Figure 16-2. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The shift register obtains its data from the Read/Write Transmit Buffer register, TXREG.  The  TXREG  register  is  loaded  with  data  in software. The TSR register is not loaded until the Stop bit  has  been  transmitted  from  the  previous  load.  As soon as the Stop bit is transmitted, the TSR is loaded with new data from the TXREG register (if available).",
    "16.3.1 EUSART ASYNCHRONOUS TRANSMITTER\nOnce the TXREG register transfers the data to the TSR register  (occurs  in  one  TCY),  the  TXREG  register  is empty and flag bit, TXIF (PIR1<4>), is set. This interrupt can be enabled/disabled by setting/clearing enable bit, TXIE (PIE1<4>). Flag bit, TXIF, will be set, regardless of the state of enable bit, TXIE, and cannot be cleared in software. Flag bit, TXIF, is not cleared immediately upon loading  the  Transmit  Buffer  register,  TXREG.  TXIF becomes valid in the second instruction cycle following the load instruction. Polling TXIF immediately following a load of TXREG will return invalid results.\nWhile flag bit, TXIF, indicates the status of the TXREG register,  another  bit,  TRMT  (TXSTA<1>),  shows  the status of the TSR register. Status bit, TRMT, is a readonly bit, which is set when the TSR register is empty. No interrupt logic is tied to this bit, so the user has to poll this bit in order to determine if the TSR register is empty.",
    "16.3.1 EUSART ASYNCHRONOUS TRANSMITTER\nNote 1: The TSR register is not mapped in data memory, so it is not available to the user.\n2: Flag  bit,  TXIF,  is  set  when  enable  bit, TXEN, is set.",
    "PIC18F1220/1320\nTo set up an Asynchronous Transmission:\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit TXIE.\n5. Enable  the  transmission  by  setting  bit  TXEN, which will also set bit TXIF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Load data to the TXREG  register (starts transmission).\nIf using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.\n- 4. If  9-bit  transmission is desired, set transmit bit TX9. Can be used as address/data bit.",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000. PIR1,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nValue on POR, BOR = -000. PIR1, Value on all other Resets = -000. PIR1, Value on all other Resets = -000. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Value on POR, BOR = -000. PIE1, Value on all other Resets = -000. PIE1, Value on all other Resets = -000. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP.",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nIPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111. IPR1, Value on POR, BOR = -111. IPR1, Value on all other Resets = -111. IPR1, Value on all other Resets = -111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = -00x. TXREG, Bit 7 = EUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit Register. TXREG, Bit 5 = EUSART Transmit Register. TXREG,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nBit 4 = EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register. TXREG, Bit 0 = EUSART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other Resets = 0000. TXREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nBAUDCTL, Bit 7 = -. BAUDCTL, Bit 6 = RCIDL. BAUDCTL, Bit 5 = -. BAUDCTL, Bit 4 = SCKP. BAUDCTL, Bit 3 = BRG16. BAUDCTL, Bit 2 = -. BAUDCTL, Bit 1 = WUE. BAUDCTL, Bit 0 = ABDEN. BAUDCTL, Value on POR, BOR = -1-1. BAUDCTL, Value on POR, BOR = 0-00. BAUDCTL, Value on all other Resets = -1-1. BAUDCTL, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register High",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nByte. SPBRGH, Bit 1 = Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nall other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented locations read as ' 0 '. Shaded cells are not used for asynchronous transmission.",
    "16.3.2 EUSART ASYNCHRONOUS RECEIVER\nThe receiver block diagram is  shown in Figure 16-5. The data is received on the RB4/AN6/RX/DT/KBI0 pin and drives the data recovery block. The data recovery block is actually a high-speed shifter, operating at x16 times the baud rate, whereas the main receive serial shifter operates at the bit rate or at FOSC. This mode would typically be used in RS-232 systems.\nTo set up an Asynchronous Reception:",
    "16.3.2 EUSART ASYNCHRONOUS RECEIVER\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit RCIE.\n4. If 9-bit reception is desired, set bit RX9.\n5. Enable the reception by setting bit CREN.\n6. Flag  bit,  RCIF,  will  be  set  when  reception  is complete and an interrupt will  be  generated  if enable bit RCIE was set.\n7. Read the RCSTA register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n8. Read  the  8-bit  received  data  by  reading  the RCREG register.\n9. If any error occurred, clear the error by clearing enable bit CREN.",
    "16.3.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\nThis mode would typically be used in RS-485 systems. To  set  up  an  Asynchronous  Reception  with  Address Detect Enable:",
    "16.3.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate.  Set or clear the  BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n2. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n3. If interrupts are required, set the RCEN bit and select the desired priority level with the RCIP bit.\n4. Set the RX9 bit to enable 9-bit reception.\n5. Set the ADDEN bit to enable address detect.\n6. Enable reception by setting the CREN bit.\n7. The  RCIF  bit  will  be  set  when  reception  is complete. The interrupt will be Acknowledged if the RCIE and GIE bits are set.\n8. Read the  RCSTA  register  to  determine  if  any error occurred during reception, as well as read bit 9 of data (if applicable).\n9. Read RCREG to determine if the device is being addressed.\n10. If any error occurred, clear the CREN bit.",
    "16.3.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n11. If  the  device  has  been  addressed,  clear  the ADDEN bit  to  allow  all  received  data  into  the receive buffer and interrupt the CPU.\n10. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "FIGURE 16-5: EUSART RECEIVE BLOCK DIAGRAM\nTo set up an Asynchronous Transmission:\n1. Initialize the SPBRG register for the appropriate baud rate. If a high-speed baud rate is desired, set  bit BRGH  (see Section 16.2  'EUSART Baud Rate Generator (BRG)' ).\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit TXIE.\n5. Enable  the  transmission  by  setting  bit  TXEN, which will also set bit TXIF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Load data to the TXREG  register (starts transmission).\nIf using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.\n- 4. If  9-bit  transmission is desired, set transmit bit TX9. Can be used as address/data bit.",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000. PIR1,",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nValue on POR, BOR = -000. PIR1, Value on all other Resets = -000. PIR1, Value on all other Resets = -000. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Value on POR, BOR = -000. PIE1, Value on all other Resets = -000. PIE1, Value on all other Resets = -000. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP.",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nIPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111. IPR1, Value on POR, BOR = -111. IPR1, Value on all other Resets = -111. IPR1, Value on all other Resets = -111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000x. RCREG, Bit 7 = EUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\n= EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on all other Resets = 0000. RCREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nBAUDCTL, Bit 7 = -. BAUDCTL, Bit 6 = RCIDL. BAUDCTL, Bit 5 = -. BAUDCTL, Bit 4 = SCKP. BAUDCTL, Bit 3 = BRG16. BAUDCTL, Bit 2 = -. BAUDCTL, Bit 1 = WUE. BAUDCTL, Bit 0 = ABDEN. BAUDCTL, Value on POR, BOR = -1-1. BAUDCTL, Value on POR, BOR = 0-00. BAUDCTL, Value on all other Resets = -1-1. BAUDCTL, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register High",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nByte. SPBRGH, Bit 1 = Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nall other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented locations read as ' 0 '. Shaded cells are not used for asynchronous reception.",
    "16.3.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nDuring  Sleep  mode,  all  clocks  to  the  EUSART  are suspended. Because of this, the Baud Rate Generator is inactive and a proper byte reception cannot be performed. The auto-wake-up feature allows the controller to wake-up due to activity on the RX/DT line while the EUSART is operating in Asynchronous mode.\nThe  auto-wake-up  feature  is  enabled  by  setting  the WUE bit (BAUDCTL<1>). Once set, the typical receive sequence  on  RX/DT  is  disabled  and  the  EUSART remains in an Idle state, monitoring for a wake-up event independent of the CPU mode. A wake-up event consists of a high-to-low transition on the RX/DT line. (This coincides with the start of a Sync Break or a Wake-up Signal character for the LIN protocol.)",
    "16.3.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nFollowing a wake-up event, the module generates an RCIF  interrupt.  The  interrupt  is  generated  synchronously  to  the  Q  clocks  in  normal  operating  modes (Figure 16-7)  and  asynchronously  if  the  device  is  in Sleep  mode  (Figure 16-8).  The  interrupt  condition  is cleared by reading the RCREG register.\nThe WUE bit is automatically cleared once a low-to-high transition is observed on the RX line, following the wakeup event. At this point, the EUSART module is in Idle mode and returns to normal operation. This signals to the user that the Sync Break event is over.",
    "16.3.4.1 Special Considerations Using Auto-Wake-up\nSince  auto-wake-up  functions  by  sensing  rising  edge transitions on RX/DT, information with any state changes before the Stop bit may signal a false end-of-character and  cause  data  or  framing  errors.  To  work  properly, therefore, the initial character in the transmission must be all ' 0 's. This can be 00h (8 bytes) for standard RS-232 devices, or 000h (12 bits) for LIN bus.\nOscillator start-up time must  also  be  considered, especially in applications using oscillators with longer start-up intervals (i.e., LP, XT or HS/PLL mode). The Sync Break (or Wake-up Signal) character must be of sufficient length and be followed by a sufficient period, to allow enough time for the selected oscillator to start and provide proper initialization of the EUSART.",
    "16.3.4.2 Special Considerations Using the WUE Bit\nThe timing of WUE and RCIF events may cause some confusion when it comes to determining the validity of received data. As noted, setting the WUE bit places the EUSART in an Idle mode. The wake-up event causes a receive interrupt by setting the RCIF bit. The WUE bit is cleared after this when a rising edge is seen on RX/ DT. The interrupt condition is then cleared by reading the RCREG register. Ordinarily, the data in RCREG will be dummy data and should be discarded.\nThe fact that the WUE bit has been cleared (or is still set) and the RCIF flag is set should not be used as an indicator of the integrity of the data in RCREG. Users should  consider  implementing  a  parallel  method  in firmware to verify received data integrity.\nTo assure that no actual data is lost, check the RCIDL bit to verify that a receive operation is not in process. If a receive operation is not occurring, the WUE bit may then be set just prior to entering the Sleep mode.",
    "FIGURE 16-8: AUTO-WAKE-UP BIT (WUE) TIMINGS DURING SLEEP\nNote 1: If the wake-up event requires a long oscillator warm-up time, the WUE bit may be cleared while the primary clock is still starting. 2: The EUSART remains in Idle while the WUE bit is set.",
    "16.3.5 BREAK CHARACTER SEQUENCE\nThe  Enhanced  USART  module  has  the  capability  of sending  the  special  Break  character  sequences  that are required by the LIN bus standard. The Break character transmit consists of a Start bit, followed by twelve ' 0 '  bits and a Stop bit. The Frame Break character is sent whenever the SENDB and TXEN bits (TXSTA<3> and  TXSTA<5>)  are  set  while  the  Transmit  Shift register is loaded with data. Note that the value of data written  to  TXREG  will  be  ignored  and  all  ' 0 's  will  be transmitted.\nThe SENDB bit is automatically reset by hardware after the corresponding Stop bit is sent. This allows the user to preload the transmit FIFO with the next transmit byte following the Break  character  (typically, the Sync character in the LIN specification).\nNote that the data value written to the TXREG for the Break character is ignored. The write simply serves the purpose of initiating the proper sequence.\nThe TRMT bit indicates when the transmit operation is active or Idle, just as it does during normal transmission.  See  Figure 16-9  for  the  timing  of  the  Break character sequence.",
    "16.3.5.1 Transmitting A Break Signal\nThe  Enhanced  USART  module  has  the  capability  of sending the Break signal that is required by the LIN bus standard.  The  Break  signal  consists  of  a  Start  bit, followed by twelve ' 0 ' bits and a Stop bit. The Break signal  is  sent  whenever  the  SENDB  (TXSTA<3>)  and TXEN (TXSTA<5>) bits are set and TXREG is loaded with data. The data written to TXREG will be ignored and all ' 0 's will be transmitted.\nSENDB is automatically cleared by hardware when the Break  signal  has  been  sent.  This  allows  the  user  to preload the transmit FIFO with the next transmit byte following the Break  character  (typically, the Sync character in the LIN specification).\nThe TRMT bit indicates when the transmit operation is active or Idle, just as it does during normal transmission.\nTo send a Break Signal:",
    "16.3.5.1 Transmitting A Break Signal\n1. Configure the EUSART for asynchronous transmissions (steps 1-5). Initialize the SPBRG register for the appropriate baud rate. If a high-speed baud rate is desired, set bit BRGH (see Section 16.2 'EUSART Baud Rate Generator (BRG)' ).\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit TXIE.\n4. If  9-bit  transmission is desired, set transmit bit TX9. Can be used as address/data bit.\n5. Enable  the  transmission  by  setting  bit  TXEN, which will also set bit TXIF.\n6. Set the SENDB bit.\n7. Load a byte into TXREG. This triggers sending a Break  signal.  The  Break  signal  is  complete when TRMT is set. SENDB will also be cleared.\nSee  Figure 16-9  for  the  timing  of  the  Break  signal sequence.",
    "16.3.6 RECEIVING A BREAK CHARACTER\nThe  Enhanced  USART  module can  receive  a  Break character in two ways.\nThe first method forces configuration of the baud rate at a frequency of 9/13 the typical speed. This allows for the  Stop  bit  transition  to  be  at  the  correct  sampling location  (12  bits  for  Break  versus  Start  bit  and  eight data bits for typical data).\nThe  second  method  uses  the  auto-wake-up  feature described in Section 16.3.4 'Auto-Wake-up on Sync Break  Character' . By enabling this feature, the EUSART will sample the next two transitions on RX/DT, cause an RCIF interrupt and receive the next data byte followed by another interrupt.\nNote  that  following  a  Break  character,  the  user  will typically  want  to  enable  the  Auto-Baud  Rate  Detect feature. For both methods, the user can set the ABD bit before placing the EUSART in its Sleep mode.",
    "16.3.6.1 Transmitting a Break Sync\nThe  following  sequence  will  send  a  message  frame header made up of a Break, followed by an auto-baud Sync byte. This sequence is typical of a LIN bus master.\n1. Configure the EUSART for the desired mode.\n2. Set  the  TXEN  and  SENDB  bits  to  set  up  the Break character.\n3. Load  the  TXREG  with  a  dummy  character  to initiate transmission (the value is ignored).\n4. Write '55h' to TXREG to load the Sync character into the transmit FIFO buffer.\n5. After the Break has been sent, the SENDB bit is reset  by  hardware.  The  Sync  character  now transmits in the preconfigured mode. When the TXREG  becomes  empty,  as  indicated  by  the TXIF, the next data byte can be written to TXREG.",
    "16.3.6.2 Receiving a Break Sync\nTo receive a Break Sync:\n1. Configure the EUSART for asynchronous transmit and  receive. TXEN  should  remain clear. SPBRGH:SPBRG may be left as is.\n2. Enable auto-wake-up. Set WUE.\n3. Enable RXIF interrupts. Set RCIE, PEIE, GIE.\n4. The  controller  may  be  placed  in  any  power managed mode.\n5. An RCIF will be generated at the beginning of the Break signal. When the interrupt is received, read RCREG to clear RCIF and discard. Allow the controller to return to PRI_RUN mode.\n7. Enable Auto-Baud Rate Detect. Set ABDEN.\n8. Return  from  the  interrupt.  Allow  the  primary clock to start and stabilize (PRI_RUN or PRI_I-DLE).",
    "16.3.6.2 Receiving a Break Sync\n9. When  the  next RCIF  interrupt occurs, the received baud rate has been measured. Read RCREG  to  clear  RCIF  and  discard.  Check SPBRGH:SPBRG for a valid value. The EUSART is ready for normal communications. Return  from  the  interrupt.  Allow  the  primary clock to run (PRI_RUN or PRI_IDLE).\n6. Wait for the RX line to go high at the end of the Break signal. Wait for any of the following: WUE to clear automatically (poll), RB4/RX to go high (poll) or for RBIF to be set (poll or interrupt). If RBIF is used, check to be sure that RB4/RX is high before continuing.\n10. Process  subsequent  RCIF  interrupts  normally as  in  asynchronous  reception.  TXEN  should now be set if transmissions are needed. TXIF and TXIE may be set if transmit interrupts are desired. Remain in PRI_RUN or PRI_IDLE until communications are complete. Clear TXEN and return to step 2.",
    "16.4 EUSART Synchronous Master Mode\nThe Synchronous Master mode is entered by setting the CSRC bit (TXSTA<7>). In this mode, the data is transmitted in a half-duplex manner (i.e., transmission and reception do not occur at the same time). When transmitting  data,  the  reception  is  inhibited  and  vice versa.  Synchronous  mode  is  entered  by  setting  bit, SYNC  (TXSTA<4>).  In  addition,  enable  bit,  SPEN (RCSTA<7>), is set in order to configure the RB1/AN5/ TX/CK/INT1 and RB4/AN6/RX/DT/KBI0 I/O pins to CK (clock) and DT (data) lines, respectively.\nThe Master mode indicates that the processor transmits the master clock on the CK line. Clock polarity is selected  with  the  SCKP  bit  (BAUDCTL<5>);  setting SCKP sets the Idle state on CK as high, while clearing the bit sets the Idle state as low. This option is provided to support Microwire devices with this module.",
    "16.4.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\nOnce the TXREG register transfers the data to the TSR register (occurs in one TCYCLE), the TXREG is empty and interrupt bit, TXIF (PIR1<4>), is set. The interrupt can be enabled/disabled by setting/clearing enable bit, TXIE (PIE1<4>). Flag bit, TXIF, will be set, regardless of the state of enable bit, TXIE and cannot be cleared in software. It will reset only when new data is loaded into the TXREG register.\nWhile flag bit, TXIF, indicates the status of the TXREG register,  another  bit,  TRMT  (TXSTA<1>),  shows  the status  of  the  TSR  register.  TRMT  is  a  read-only  bit, which is set when the TSR is empty. No interrupt logic is tied to this bit, so the user has to poll this bit in order to determine if the TSR register is empty. The TSR is not mapped in data memory, so it is not available to the user.\nTo set up a Synchronous Master Transmission:",
    "16.4.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\n- 1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate.  Set or clear the  BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\nThe  EUSART transmitter  block  diagram  is  shown  in Figure 16-2. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The shift register obtains its data from the Read/Write Transmit Buffer register, TXREG.  The  TXREG  register  is  loaded  with  data  in software. The TSR register is not loaded until the last bit  has  been  transmitted  from  the  previous  load.  As soon as the last bit is transmitted, the TSR is loaded with new data from the TXREG (if available).",
    "16.4.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN and CSRC.\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable the transmission by setting bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREG register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000. PIR1,",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nValue on POR, BOR = -000. PIR1, Value on all other Resets = -000. PIR1, Value on all other Resets = -000. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Value on POR, BOR = -000. PIE1, Value on all other Resets = -000. PIE1, Value on all other Resets = -000. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP.",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nIPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111. IPR1, Value on POR, BOR = -111. IPR1, Value on all other Resets = -111. IPR1, Value on all other Resets = -111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = -00x. TXREG, Bit 7 = EUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit Register. TXREG, Bit 5 = EUSART Transmit Register. TXREG,",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nBit 4 = EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register. TXREG, Bit 0 = EUSART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other Resets = 0000. TXREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nBAUDCTL, Bit 7 = -. BAUDCTL, Bit 6 = RCIDL. BAUDCTL, Bit 5 = -. BAUDCTL, Bit 4 = SCKP. BAUDCTL, Bit 3 = BRG16. BAUDCTL, Bit 2 = -. BAUDCTL, Bit 1 = WUE. BAUDCTL, Bit 0 = ABDEN. BAUDCTL, Value on POR, BOR = -1-1. BAUDCTL, Value on POR, BOR = 0-00. BAUDCTL, Value on all other Resets = -1-1. BAUDCTL, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register High",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nByte. SPBRGH, Bit 1 = Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nall other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master transmission.",
    "16.4.2 EUSART SYNCHRONOUS MASTER RECEPTION\nOnce  Synchronous  mode  is  selected,  reception  is enabled by setting either the Single Receive Enable bit, SREN  (RCSTA<5>), or the Continuous Receive Enable bit, CREN (RCSTA<4>). Data is sampled on the RB4/AN6/RX/DT/KBI0 pin  on  the  falling  edge  of  the clock.\nIf enable  bit,  SREN,  is  set,  only  a  single  word  is received. If enable bit, CREN, is set, the reception is continuous until CREN is cleared. If both bits are set, then CREN takes precedence.\nTo set up a Synchronous Master Reception:",
    "16.4.2 EUSART SYNCHRONOUS MASTER RECEPTION\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n3. Ensure bits CREN and SREN are clear.\n4. If interrupts are desired, set enable bit RCIE.\n5. If 9-bit reception is desired, set bit RX9.\n6. If  a  single reception is required, set bit SREN. For continuous reception, set bit CREN.\n7. Interrupt flag bit, RCIF, will be set when reception is complete and an interrupt will be generated if the enable bit, RCIE, was set.\n8. Read the RCSTA register to get the ninth bit (if enabled)  and  determine  if  any  error  occurred during reception.\n9. Read  the  8-bit  received  data  by  reading  the RCREG register.\n10. If any error occurred, clear the error by clearing bit CREN.\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN and CSRC.",
    "16.4.2 EUSART SYNCHRONOUS MASTER RECEPTION\n11. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000. PIR1,",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nValue on POR, BOR = -000. PIR1, Value on all other Resets = -000. PIR1, Value on all other Resets = -000. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Value on POR, BOR = -000. PIE1, Value on all other Resets = -000. PIE1, Value on all other Resets = -000. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP.",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nIPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111. IPR1, Value on POR, BOR = -111. IPR1, Value on all other Resets = -111. IPR1, Value on all other Resets = -111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000x. RCREG, Bit 7 = EUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\n= EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on all other Resets = 0000. RCREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nBAUDCTL, Bit 7 = -. BAUDCTL, Bit 6 = RCIDL. BAUDCTL, Bit 5 = -. BAUDCTL, Bit 4 = SCKP. BAUDCTL, Bit 3 = BRG16. BAUDCTL, Bit 2 = -. BAUDCTL, Bit 1 = WUE. BAUDCTL, Bit 0 = ABDEN. BAUDCTL, Value on POR, BOR = -1-1. BAUDCTL, Value on POR, BOR = 0-00. BAUDCTL, Value on all other Resets = -1-1. BAUDCTL, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register High",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nByte. SPBRGH, Bit 1 = Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nall other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master reception.",
    "16.5 EUSART Synchronous Slave Mode\nSynchronous  Slave  mode  is  entered  by  clearing  bit, CSRC  (TXSTA<7>).  This mode  differs from the Synchronous  Master  mode  in  that  the  shift  clock  is supplied  externally  at  the  RB1/AN5/TX/CK/INT1  pin (instead of being supplied internally in Master mode). This allows the device to transfer or receive data while in any low-power mode.",
    "16.5.1 EUSART SYNCHRONOUS SLAVE TRANSMIT\nThe operation of the Synchronous Master and Slave modes are identical, except in the case of the Sleep mode.\nIf  two  words  are  written  to  the  TXREG  and  then  the SLEEP instruction is executed, the following will occur:\na) The  first  word  will  immediately  transfer  to  the TSR register and transmit.\nb) The  second  word  will  remain  in  the  TXREG register.\nc) Flag bit, TXIF, will not be set.\nd) When the first word has been shifted out of TSR, the  TXREG  register  will  transfer  the  second word to the TSR and flag bit, TXIF, will now be set.\ne) If enable bit, TXIE, is set, the interrupt will wake the  chip  from  Sleep.  If  the  global  interrupt  is enabled, the program will branch to the interrupt vector.",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n\nLegend: x = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave transmission.",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000. PIR1,",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nValue on POR, BOR = -000. PIR1, Value on all other Resets = -000. PIR1, Value on all other Resets = -000. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Value on POR, BOR = -000. PIE1, Value on all other Resets = -000. PIE1, Value on all other Resets = -000. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP.",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nIPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111. IPR1, Value on POR, BOR = -111. IPR1, Value on all other Resets = -111. IPR1, Value on all other Resets = -111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000x. TXREG, Bit 7 = EUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit Register. TXREG, Bit 5 = EUSART Transmit Register. TXREG, Bit 4",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n= EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register. TXREG, Bit 0 = EUSART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other Resets = 0000. TXREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nBAUDCTL, Bit 7 = -. BAUDCTL, Bit 6 = RCIDL. BAUDCTL, Bit 5 = -. BAUDCTL, Bit 4 = SCKP. BAUDCTL, Bit 3 = BRG16. BAUDCTL, Bit 2 = -. BAUDCTL, Bit 1 = WUE. BAUDCTL, Bit 0 = ABDEN. BAUDCTL, Value on POR, BOR = -1-1. BAUDCTL, Value on POR, BOR = 0-00. BAUDCTL, Value on all other Resets = -1-1. BAUDCTL, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register High",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nByte. SPBRGH, Bit 1 = Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nall other Resets = 0000. SPBRG, Value on all other Resets = 0000\nTo set up a Synchronous Slave Transmission:\n1. Enable  the  synchronous  slave  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. Clear bits CREN and SREN.\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable  the  transmission  by  setting  enable  bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREG register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "16.5.2 EUSART SYNCHRONOUS SLAVE RECEPTION\nThe operation of the Synchronous Master and Slave modes is identical, except in the case of Sleep, or any Idle  mode  and  bit  SREN,  which  is  a  'don't  care'  in Slave mode.\nIf  receive is enabled by setting the CREN bit prior to entering Sleep or any Idle mode, then a word may be received while in this low-power mode. Once the word is received, the RSR register will transfer the data to the RCREG register; if the RCIE enable bit is set, the interrupt  generated  will  wake  the  chip  from  low-power mode. If the global interrupt is enabled, the program will branch to the interrupt vector.\nTo set up a Synchronous Slave Reception:",
    "16.5.2 EUSART SYNCHRONOUS SLAVE RECEPTION\n1. Enable  the  synchronous  master  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. If interrupts are desired, set enable bit RCIE.\n3. If 9-bit reception is desired, set bit RX9.\n4. To enable reception, set enable bit CREN.\n5. Flag  bit,  RCIF,  will  be  set  when  reception  is complete.  An  interrupt will be  generated  if enable bit, RCIE, was set.\n6. Read the RCSTA register to get the ninth bit (if enabled)  and  determine  if  any  error  occurred during reception.\n7. Read  the  8-bit  received  data  by  reading  the RCREG register.\n8. If any error occurred, clear the error by clearing bit CREN.\n9. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000. PIR1,",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nValue on POR, BOR = -000. PIR1, Value on all other Resets = -000. PIR1, Value on all other Resets = -000. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Value on POR, BOR = -000. PIE1, Value on all other Resets = -000. PIE1, Value on all other Resets = -000. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP.",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nIPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111. IPR1, Value on POR, BOR = -111. IPR1, Value on all other Resets = -111. IPR1, Value on all other Resets = -111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000x. RCREG, Bit 7 = EUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\n= EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on all other Resets = 0000. RCREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nBAUDCTL, Bit 7 = -. BAUDCTL, Bit 6 = RCIDL. BAUDCTL, Bit 5 = -. BAUDCTL, Bit 4 = SCKP. BAUDCTL, Bit 3 = BRG16. BAUDCTL, Bit 2 = -. BAUDCTL, Bit 1 = WUE. BAUDCTL, Bit 0 = ABDEN. BAUDCTL, Value on POR, BOR = -1-1. BAUDCTL, Value on POR, BOR = 0-00. BAUDCTL, Value on all other Resets = -1-1. BAUDCTL, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register High",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nByte. SPBRGH, Bit 1 = Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nall other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend: x = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave reception.",
    "17.0 10-BIT ANALOG-TO-DIGITAL CONVERTER (A/D) MODULE\nThe  Analog-to-Digital  (A/D)  converter  module  has seven inputs for the PIC18F1220/1320 devices. This module allows conversion of an analog input signal to a corresponding 10-bit digital number.\nA new feature for the A/D converter is the addition of programmable acquisition time. This feature allows the user to select a new channel for conversion and to set the GO/DONE bit immediately. When the GO/DONE bit is  set,  the  selected  channel  is  sampled  for  the  programmed acquisition time before a conversion is actually started. This removes the firmware overhead that may  have  been  required  to  allow  for  an  acquisition (sampling) period (see Register 17-3 and Section 17.3 'Selecting and Configuring Automatic Acquisition Time' ).\nThe module has five registers:\n\u00b7 A/D Result High Register (ADRESH)\n\u00b7 A/D Result Low Register (ADRESL)\n\u00b7 A/D Control Register 0 (ADCON0)\n\u00b7 A/D Control Register 1 (ADCON1)\n\u00b7 A/D Control Register 2 (ADCON2)",
    "17.0 10-BIT ANALOG-TO-DIGITAL CONVERTER (A/D) MODULE\nThe ADCON0 register, shown in Register 17-1, controls the operation of the A/D module. The ADCON1 register, shown in Register 17-2, configures the functions of the port pins. The ADCON2 register, shown  in  Register 17-3,  configures  the  A/D  clock source, programmed acquisition time and justification.",
    "REGISTER 17-1: ADCON0: A/D CONTROL REGISTER 0\nR/W-0/0, 1 = R/W-0/0. R/W-0/0, 2 = U-0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. VCFG1, 1 = VCFG0. VCFG1, 2 = -. VCFG1, 3 = CHS2. VCFG1, 4 = CHS1. VCFG1, 5 = CHS0. VCFG1, 6 = GO/DONE. VCFG1, 7 = ADON. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 17-1: ADCON0: A/D CONTROL REGISTER 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = ",
    "bit 7-6 VCFG<1:0>: Voltage Reference Configuration bits\n00, A/D VREF+ = AVDD. 00, A/D VREF- = AVSS. 01, A/D VREF+ = External VREF+. 01, A/D VREF- = AVSS. 10, A/D VREF+ = AVDD. 10, A/D VREF- = External VREF-. 11, A/D VREF+ = External VREF+. 11, A/D VREF- = External VREF-",
    "bit 4-2 CHS<2:0>: Analog Channel Select bits\n000 = Channel 0 (AN0)\n001 = Channel 1 (AN1)\n010 = Channel 2 (AN2)\n011 = Channel 3 (AN3)\n100 = Channel 4 (AN4)\n101 = Channel 5 (AN5)\n110 = Channel 6 (AN6)\n111 = Unimplemented (1)",
    "bit 1 GO/DONE: A/D Conversion Status bit\nWhen ADON = 1 :\n1 = A/D conversion in progress\n0 = A/D Idle",
    "bit 0\nADON: A/D On bit\n1 = A/D converter module is enabled\n0 = A/D converter module is disabled\nPerforming a conversion on unimplemented channels returns full-scale results.\nNote 1: Performing a conversion on unimplemented channels returns full-scale results.",
    "REGISTER 17-2: ADCON1: A/D CONTROL REGISTER 1\nU-0, 1 = R/W-0/0. U-0, 2 = R/W-0/0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-0/0. U-0, 6 = R/W-0/0. U-0, 7 = R/W-0/0. -, 1 = PCFG6. -, 2 = PCFG5. -, 3 = PCFG4. -, 4 = PCFG3. -, 5 = PCFG2. -, 6 = PCFG1. -, 7 = PCFG0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 17-2: ADCON1: A/D CONTROL REGISTER 1\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "bit 6\nPCFG6: A/D Port Configuration bit - AN6\n1 = Pin configured as a digital port\n0 = Pin configured as an analog channel - digital input disabled and reads ' 0 '\nbit 5\nPCFG5: A/D Port Configuration bit - AN5\n1 = Pin configured as a digital port\n0 = Pin configured as an analog channel - digital input disabled and reads ' 0 '\nbit 4\nPCFG4: A/D Port Configuration bit - AN4\n1 = Pin configured as a digital port\n0 = Pin configured as an analog channel - digital input disabled and reads ' 0 '",
    "bit 3 PCFG3: A/D Port Configuration bit - AN3\n1 = Pin configured as a digital port\n0 = Pin configured as an analog channel - digital input disabled and reads ' 0 '\nbit 2\nPCFG2: A/D Port Configuration bit - AN2\n1 = Pin configured as a digital port\n0 = Pin configured as an analog channel - digital input disabled and reads ' 0 '",
    "bit 1 PCFG1: A/D Port Configuration bit - AN1\n1 = Pin configured as a digital port\n0 = Pin configured as an analog channel - digital input disabled and reads ' 0 '",
    "bit 0\nPCFG0: A/D Port Configuration bit - AN0\n1 = Pin configured as a digital port\n0 = Pin configured as an analog channel - digital input disabled and reads ' 0 '",
    "REGISTER 17-3: ADCON2: A/D CONTROL REGISTER 2\nR/W-0/0, 1 = U-0. R/W-0/0, 2 = R/W-0/0. R/W-0/0, 3 = R/W-0/0. R/W-0/0, 4 = R/W-0/0. R/W-0/0, 5 = R/W-0/0. R/W-0/0, 6 = R/W-0/0. R/W-0/0, 7 = R/W-0/0. ADFM, 1 = -. ADFM, 2 = ACQT2. ADFM, 3 = ACQT1. ADFM, 4 = ACQT0. ADFM, 5 = ADCS2. ADFM, 6 = ADCS1. ADFM, 7 = ADCS0\nbit 7\nbit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared",
    "bit 7\nADFM: A/D Result Format Select bit\n1 = Right justified\n0 = Left justified\nbit 6\nUnimplemented: Read as ' 0 '\nbit 5-3\nACQT<2:0>: A/D Acquisition Time Select bits\n000 = 0 TAD (1)\n001 = 2 TAD\n010 = 4 TAD\n011 = 6 TAD\n100 = 8 TAD\n101 = 12 TAD\n110 = 16 TAD\n111 = 20 TAD )\nbit 2-0\nADCS<2:0>: A/D Conversion Clock Select bits\n000 = FOSC/2\n001 = FOSC/8\n010 = FOSC/32\n011 = FRC (clock derived from A/D RC oscillator) (1)\n100 = FOSC/4\n101 = FOSC/16\n110\n= FOSC/64\n111 = FRC (clock derived from A/D RC oscillator) (1)\nNote 1: If the A/D FRC clock source is selected, a delay of one TCY (instruction cycle) is added before the A/D clock starts. This allows the SLEEP instruction to be executed before starting a conversion.",
    "bit 7\nThe analog reference voltage is software selectable to either the device's positive and negative supply voltage (AVDD and AVSS), or the voltage level on the RA3/AN3/ VREF+ and RA2/AN2/VREF- pins.\nThe A/D converter has a unique feature of being able to operate while the device is in Sleep mode. To operate in Sleep, the A/D conversion clock must be derived from the A/D's internal RC oscillator.\nThe output of the sample and hold is the input into the converter,  which  generates  the  result  via  successive approximation.",
    "PIC18F1220/1320\nA device Reset forces all registers to their Reset state. This forces the A/D module to be turned off and any conversion in progress is aborted.\nEach port pin associated with the A/D converter can be configured as an analog input, or as a digital I/O. The ADRESH and ADRESL registers contain the result of the A/D conversion. When the A/D conversion is complete,  the  result  is  loaded  into  the  ADRESH/ADRESL registers, the GO/DONE  bit  (ADCON0  register)  is cleared and A/D Interrupt Flag bit, ADIF, is set. The block diagram of the A/D module is shown in Figure 17-1.\nThe  value  in  the  ADRESH/ADRESL  registers  is  not modified for a Power-on Reset. The ADRESH/ADRESL registers  will  contain  unknown  data  after  a  Power-on Reset.",
    "PIC18F1220/1320\nAfter the A/D module has been configured as desired, the selected channel must be acquired before the conversion  is  started.  The  analog  input  channels  must have  their  corresponding  TRIS  bits  selected  as  an input. To determine acquisition time, see Section 17.1 'A/D Acquisition Requirements' .  After this acquisition  time  has  elapsed,  the  A/D  conversion  can  be started.  An  acquisition  time  can  be  programmed  to occur between setting the GO/DONE bit and the actual start of the conversion.\nTo do an A/D Conversion:",
    "PIC18F1220/1320\n1. Configure the A/D module:\n\u00b7 Configure analog pins, voltage reference and digital I/O (ADCON1)\n\u00b7 Select A/D input channel (ADCON0)\n\u00b7 Select A/D acquisition time (ADCON2)\n\u00b7 Select A/D conversion clock (ADCON2)\n\u00b7 Turn on A/D module (ADCON0)\n2. Configure A/D interrupt (if desired):\n\u00b7 Clear ADIF bit\n\u00b7 Set ADIE bit\n\u00b7 Set GIE bit\n3. Wait the required acquisition time (if required).\n4. Start conversion:\n\u00b7 Set GO/DONE bit (ADCON0 register)\n5. Wait for A/D conversion to complete, by either:\n\u00b7 Polling for the GO/DONE bit to be cleared OR\n\u00b7 Waiting for the A/D interrupt\n6. Read A/D Result registers (ADRESH:ADRESL); clear bit, ADIF, if required.\n7. For the next conversion, go to step 1 or step 2, as required. The A/D conversion time per bit is defined  as  TAD.  A  minimum  wait  of  2  TAD  is required before the next acquisition starts.",
    "17.1 A/D Acquisition Requirements\nFor the A/D converter to meet its specified accuracy, the charge holding capacitor (CHOLD) must be allowed to fully charge to the input channel voltage level. The analog  input  model  is  shown  in  Figure 17-2.  The source  impedance  (RS)  and  the  internal  sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (VDD). The source impedance affects the offset voltage at the analog input (due to pin leakage current). The maximum  recommended  impedance  for  analog sources is 2.5 k \uf057 .  After the analog input channel is selected (changed), the channel must be sampled for at least the minimum acquisition time before starting a conversion.\nNote:\nWhen  the conversion is started, the holding capacitor is disconnected from the input pin.\nTo calculate the minimum acquisition time, Equation 17-1  may  be  used.  This  equation  assumes that 1/2 LSb error is used (1024 steps for the A/D). The 1/2 LSb error is the maximum error allowed for the A/D to meet its specified resolution.",
    "17.1 A/D Acquisition Requirements\nExample 17-1 shows the calculation  of  the  minimum required  acquisition  time,  TACQ.  This  calculation  is based on the following application system assumptions:\nCHOLD\n= 120 pF\nRs\n=\n2.5 k \uf057\uf020\nConversion Error\n\uf0a3 1/2 LSb\nVDD\n= 5V \uf0ae RSS = 7 k \uf057\nTemperature\n= 50 C (system max.) \uf0b0\nVHOLD\n=\n0V @ time = 0",
    "17.2 A/D VREF+ and VREF- References\nIf external voltage references are used instead of the internal  AVDD  and  AVSS  sources,  the  source  impedance of the VREF+ and VREF- voltage sources must be considered.  During  acquisition,  currents  supplied  by these sources are insignificant. However, during conversion, the A/D module sinks and sources current through the reference sources.\nIn  order  to  maintain  the  A/D  accuracy,  the  voltage reference  source  impedances  should  be  kept  low  to reduce voltage changes. These voltage changes occur as reference  currents flow through  the reference source  impedance. The  maximum  recommended impedance of the VREF+ and VREFexternal reference voltage sources is 250 \uf057 .",
    "EQUATION 17-1: ACQUISITION TIME\nTACQ= Amplifier Settling Time + Holding Capacitor Charging Time + Temperature Coefficient = TAMP + TC + TCOFF",
    "EQUATION 17-2: A/D MINIMUM CHARGING TIME\nVHOLD = ( \uf044 VREF - ( \uf044 VREF/2048)) \u2022 (1 - e (-TC/CHOLD(RIC + RSS + RS)) )\nor\nTC =  -(CHOLD)(RIC + RSS + RS) ln(1/2048)",
    "EXAMPLE 17-1: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\n```\nTACQ =TAMP + TC + TCOFF TAMP =5 \uf06d s TCOFF =(Temp - 25\u00baC)(0.05 \uf06d s/\u00baC) (50\u00baC - 25\u00baC)(0.05 \uf06d s/\u00baC) 1.25 \uf06d s Temperature coefficient is only required for temperatures > 25\u00baC. Below 25\u00baC, TCOFF = 0 \uf06d s. TC = -(CHOLD)(RIC + RSS + RS) ln(1/2047) \uf06d s -(120 pF) (1 k \uf057 + 7 k \uf057 + 2.5 k \uf057 ) ln(0.0004883) \uf06d s 9.61 \uf06d s TACQ =5 \uf06d s + 1.25 \uf06d s + 9.61 \uf06d s 12.86 \uf06d s\n```",
    "17.3 Selecting and Configuring Automatic Acquisition Time\nThe  ADCON2  register  allows  the  user  to  select  an acquisition time that occurs each time the GO/DONE bit is set.\nWhen the GO/DONE bit is set, sampling is stopped and a conversion begins. The user is responsible for ensuring the required acquisition time has passed between selecting  the  desired  input  channel  and  setting  the GO/DONE bit. This occurs when the ACQT2:ACQT0 bits (ADCON2<5:3>) remain in their Reset state (' 000 ') and  is  compatible  with  devices  that  do  not  offer programmable acquisition times.\nIf desired,  the  ACQT  bits  can  be  set  to  select  a programmable  acquisition  time  for  the  A/D  module. When the GO/DONE bit is set, the A/D module continues  to  sample  the  input  for  the  selected  acquisition time, then automatically begins a conversion. Since the acquisition time is programmed, there may be no need to  wait  for  an  acquisition  time  between  selecting  a channel and setting the GO/DONE bit.",
    "17.4 Selecting the A/D Conversion Clock\nThe A/D conversion time per bit is defined as TAD. The A/D conversion requires 11 TAD per 10-bit conversion. The  source  of  the  A/D  conversion  clock  is  software selectable. There are seven possible options for TAD:\n\u00b7 2 TOSC\n\u00b7 4 TOSC\n\u00b7 8 TOSC\n\u00b7 16 TOSC\n\u00b7 32 TOSC\n\u00b7 64 TOSC\n\u00b7 Internal RC oscillator\nFor correct A/D conversions, the A/D conversion clock (TAD) must be as short as possible, but greater than the minimum TAD (approximately 2 \uf06d s, see parameter 130 for more information).\nIn either case, when the conversion is completed, the GO/DONE bit is cleared, the ADIF flag is set and the A/ D  begins  sampling  the  currently  selected  channel again. If  an  acquisition  time  is  programmed,  there  is nothing to indicate if the acquisition time has ended or if the conversion has begun.\nTable 17-1 shows the resultant TAD times derived from the  device  operating  frequencies  and  the  A/D  clock source selected.",
    "TABLE 17-1: TAD vs. DEVICE OPERATING FREQUENCIES\n2 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 000. 2 T OSC, Maximum Device Frequency.PIC18F1220/1320 = 1.25 MHz. 2 T OSC, Maximum Device Frequency.PIC18LF1220/1320 (4) = 666 kHz. 4 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 100. 4 T OSC, Maximum Device Frequency.PIC18F1220/1320 = 2.50 MHz. 4 T OSC, Maximum Device Frequency.PIC18LF1220/1320 (4) = 1.33 MHz. 8 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 001. 8 T OSC, Maximum Device Frequency.PIC18F1220/1320 = 5.00 MHz. 8 T OSC, Maximum Device Frequency.PIC18LF1220/1320 (4) = 2.66 MHz. 16 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 101. 16 T OSC, Maximum Device",
    "TABLE 17-1: TAD vs. DEVICE OPERATING FREQUENCIES\nFrequency.PIC18F1220/1320 = 10.0 MHz. 16 T OSC, Maximum Device Frequency.PIC18LF1220/1320 (4) = 5.33 MHz. 32 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 010. 32 T OSC, Maximum Device Frequency.PIC18F1220/1320 = 20.0 MHz. 32 T OSC, Maximum Device Frequency.PIC18LF1220/1320 (4) = 10.65 MHz. 64 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 110. 64 T OSC, Maximum Device Frequency.PIC18F1220/1320 = 40.0 MHz. 64 T OSC, Maximum Device Frequency.PIC18LF1220/1320 (4) = 21.33 MHz. RC (3), AD Clock Source (T AD).ADCS2:ADCS0 = x11. RC (3), Maximum Device Frequency.PIC18F1220/1320 = 1.00 MHz (1). RC (3), Maximum Device",
    "TABLE 17-1: TAD vs. DEVICE OPERATING FREQUENCIES\nFrequency.PIC18LF1220/1320 (4) = 1.00 MHz (2)\nNote\n1: The RC source has a typical TAD time of 4 \uf06d s.\n2: The RC source has a typical TAD time of 6 \uf06d s.\n3: For device frequencies above 1 MHz, the device must be in Sleep for the entire conversion or the A/D accuracy may be out of specification.\n4: Low-power devices only.",
    "17.5 Operation in Low-Power Modes\nThe selection of the automatic acquisition time and the A/D conversion clock is determined, in part, by the lowpower  mode  clock  source  and  frequency  while  in  a low-power mode.\nIf the A/D is expected to operate while the device is in a low-power mode, the ACQT2:ACQT0  and ADCS2:ADCS0 bits in ADCON2 should be updated in accordance with the low-power mode clock that will be used. After the low-power mode is entered (either of the Run modes), an A/D acquisition or conversion may be  started.  Once  an  acquisition  or  conversion  is started, the device should continue to be clocked by the same low-power mode clock source until the conversion has been completed. If desired, the device may be placed into the corresponding low-power (ANY)_IDLE mode during the conversion.\nIf  the  low-power  mode  clock  frequency  is  less  than 1 MHz, the A/D RC clock source should be selected.",
    "17.5 Operation in Low-Power Modes\nOperation in the Low-Power Sleep mode requires the A/ D RC clock to be selected. If bits, ACQT2:ACQT0, are set to ' 000 ' and a conversion is started, the conversion will be delayed one instruction cycle to allow execution of the SLEEP instruction and entry to Low-Power Sleep mode. The IDLEN and SCS bits in the OSCCON register must  have  already  been  cleared  prior  to  starting  the conversion.",
    "17.6 Configuring Analog Port Pins\nThe ADCON1, TRISA and TRISB registers all configure the A/D port pins. The port pins needed as analog inputs must have their corresponding TRIS bits set (input). If the TRIS bit is cleared (output), the digital output level (VOH or VOL) will be converted.\nThe A/D operation is independent of the state of the CHS2:CHS0 bits and the TRIS bits.\nNote 1: When reading the Port register, all pins configured as analog input channels will read as cleared (a low level). Pins configured  as  digital  inputs  will  convert  an analog input. Analog levels on a digitally configured input will be accurately converted.\n2: Analog  levels  on  any  pin  defined  as  a digital  input  may  cause  the  digital  input buffer  to  consume  current  out  of  the device's specification limits.",
    "17.7 A/D Conversions\nFigure 17-3 shows the operation of the A/D converter after the GO bit has been set and the ACQT2:ACQT0 bits are cleared. A conversion is started after the following  instruction  to  allow  entry  into  Low-Power  Sleep mode before the conversion begins.\nFigure 17-4 shows the operation of the A/D converter after the GO bit has been set and the ACQT2:ACQT0 bits are set to ' 010 ' and selecting a 4 TAD acquisition time before the conversion starts.\nClearing  the  GO/DONE  bit  during  a  conversion  will abort the current conversion. The A/D Result register pair will NOT be updated with the partially completed A/ D conversion sample. This means the ADRESH:ADRESL  registers  will  continue  to  contain the value of the last completed conversion (or the last value written to the ADRESH:ADRESL registers).\nAfter  the  A/D  conversion  is  completed  or  aborted,  a 2 TAD wait is required before the next acquisition can be started. After this wait, acquisition on the selected channel is automatically started.\nNote:\nThe GO/DONE bit should NOT be set in the same instruction that turns on the A/D.",
    "17.7 A/D Conversions\nFIGURE 17-3: A/D CONVERSION TAD CYCLES (ACQT<2:0> = 000 , TACQ = 0 )\nFIGURE 17-4: A/D CONVERSION TAD CYCLES   (ACQT<2:0> = 010 , TACQ = 4 TAD)",
    "17.8 Use of the CCP1 Trigger\nAn A/D conversion can be started by the 'special event trigger'  of  the  CCP1  module.  This  requires  that  the CCP1M3:CCP1M0  bits  (CCP1CON<3:0>)  be  programmed as ' 1011 ' and that the A/D module is enabled (ADON bit is set).  When the trigger  occurs,  the GO/ DONE bit will be set, starting the A/D acquisition and conversion and the Timer1 (or Timer3) counter will be reset  to  zero.  Timer1  (or  Timer3)  is  reset  to  automatically repeat the A/D acquisition period with minimal software overhead (moving ADRESH/ADRESL to the desired location). The appropriate analog input channel must be selected and the minimum acquisition period  is  either  timed  by  the  user,  or  an  appropriate TACQ time selected before the 'special event trigger' sets the GO/DONE bit (starts a conversion).\nIf the A/D module is not enabled (ADON is cleared), the 'special  event  trigger'  will  be  ignored  by  the  A/D module,  but  will  still  reset  the  Timer1  (or  Timer3) counter.",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 0000. INTCON, Value on all other Resets = 0000 0000. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = -. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000 -000. PIR1, Value on all other Resets = -000 -000. PIE1, Bit 7 = -. PIE1,",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nBit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = -. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000 -000. PIE1, Value on all other Resets = -000 -000. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = -. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111 -111. IPR1, Value on all other Resets = -111 -111. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = -. PIR2, Bit 5 = -.",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nPIR2, Bit 4 = EEIF. PIR2, Bit 3 = -. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = -. PIR2, Value on POR, BOR = 0--0 -00-. PIR2, Value on all other Resets = 0--0 -00-. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = -. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = -. PIE2, Value on POR, BOR = 0--0 -00-. PIE2, Value on all other Resets = 0--0 -00-. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\n3 = -. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = -. IPR2, Value on POR, BOR = 1--1 -11-. IPR2, Value on all other Resets = 1--1 -11-. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Value on POR, BOR = xxxx xxxx. ADRESH, Value on all other Resets = uuuu uuuu. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 =",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nA/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Value on POR, BOR = xxxx xxxx. ADRESL, Value on all other Resets = uuuu uuuu. ADCON0, Bit 7 = VCFG1. ADCON0, Bit 6 = VCFG0. ADCON0, Bit 5 = -. ADCON0, Bit 4 = CHS2. ADCON0, Bit 3 = CHS1. ADCON0, Bit 2 = CHS0. ADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = 00-0 0000. ADCON0, Value on all",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nother Resets = 00-0 0000. ADCON1, Bit 7 = -. ADCON1, Bit 6 = PCFG6. ADCON1, Bit 5 = PCFG5. ADCON1, Bit 4 = PCFG4. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = -000 0000. ADCON1, Value on all other Resets = -000 0000. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = -. ADCON2, Bit 5 = ACQT2. ADCON2, Bit 4 = ACQT1. ADCON2, Bit 3 = ACQT0. ADCON2, Bit 2 = ADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Value on POR, BOR = 0-00 0000. ADCON2, Value",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\non all other Resets = 0-00 0000. PORTA, Bit 7 = RA7 (3). PORTA, Bit 6 = RA6 (2). PORTA, Bit 5 = RA5 (1). PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = qq0x 0000. PORTA, Value on all other Resets = uu0u 0000. TRISA, Bit 7 = TRISA7 (3). TRISA, Bit 6 = TRISA6 (2). TRISA, Bit 5 = -. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = qq-1 1111. TRISA, Value on all other",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nResets = 11-1 1111. PORTB, Bit 7 = Read PORTB pins, Write LATB Latch. PORTB, Bit 6 = Read PORTB pins, Write LATB Latch. PORTB, Bit 5 = Read PORTB pins, Write LATB Latch. PORTB, Bit 4 = Read PORTB pins, Write LATB Latch. PORTB, Bit 3 = Read PORTB pins, Write LATB Latch. PORTB, Bit 2 = Read PORTB pins, Write LATB Latch. PORTB, Bit 1 = Read PORTB pins, Write LATB Latch. PORTB, Bit 0 = Read PORTB pins, Write LATB Latch. PORTB, Value on POR, BOR = xxxx xxxx. PORTB, Value on all other Resets = uuuu uuuu. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 =",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nPORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111 1111. TRISB, Value on all other Resets = 1111 1111. LATB, Bit 7 = PORTB Output Data Latch. LATB, Bit 6 = PORTB Output Data Latch. LATB, Bit 5 = PORTB Output Data Latch. LATB, Bit 4 = PORTB Output Data Latch. LATB, Bit 3 = PORTB Output Data Latch. LATB, Bit 2 = PORTB Output Data Latch. LATB, Bit 1 = PORTB Output Data Latch. LATB, Bit 0 = PORTB Output Data Latch. LATB, Value on POR, BOR = xxxx xxxx. LATB, Value on all other Resets = uuuu uuuu\nLegend:",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nx = unknown, u = unchanged, q = depends on CONFIG1H<3:0>, - = unimplemented, read as ' 0 '. Shaded cells are not used for A/D conversion.\nNote\n1: RA5 port bit is available only as an input pin when the MCLRE bit in the Configuration register is ' 0 '.\n2: RA6 and TRISA6 are available only when the primary oscillator mode selection offers RA6 as a port pin; otherwise, RA6 always reads ' 0 ', TRISA6 always reads ' 1 ' and writes to both are ignored (see CONFIG1H<3:0>).\n3: RA7 and TRISA7 are available only when the internal RC oscillator is configured as the primary oscillator in CONFIG1H<3:0>; otherwise, RA7 always reads ' 0 ', TRISA7 always reads ' 1 ' and writes to both are ignored.",
    "18.0 LOW-VOLTAGE DETECT\nIn  many  applications,  the  ability  to  determine  if  the device voltage (VDD) is below a specified voltage level is  a  desirable  feature.  A  window  of  operation  for  the application can be created, where the application software can do 'housekeeping tasks', before the device voltage  exits  the  valid  operating  range.  This  can  be done using the Low-Voltage Detect module.\nThis  module  is  a  software  programmable  circuitry, where  a  device  voltage  trip  point  can  be  specified. When the voltage of the device becomes lower then the specified point, an interrupt flag is set. If the interrupt is enabled, the program execution will branch to the interrupt vector address and the software can then respond to that interrupt source.\nFigure 18-1 shows a possible application voltage curve (typically for batteries). Over time, the device voltage decreases. When the device voltage equals voltage VA, the  LVD  logic  generates  an  interrupt.  This  occurs  at time  TA.  The  application  software  then  has  the  time, until the device voltage is no longer in valid operating range, to shut down the system. Voltage point VB is the minimum  valid  operating  voltage  specification.  This occurs at time TB. The difference, TB - TA, is the total time for shutdown.",
    "18.0 LOW-VOLTAGE DETECT\nThe  block  diagram  for  the  LVD  module  is  shown  in Figure 18-2  (following  page).  A  comparator  uses  an internally generated reference voltage as the set point. When  the  selected  tap  output  of  the  device  voltage crosses the set point (is lower than), the LVDIF bit is set.\nThe Low-Voltage Detect circuitry is completely under software control. This allows the circuitry to be turned off by  the software,  which  minimizes  the  current consumption for the device.\nEach  node  in  the  resistor  divider  represents  a  'trip point' voltage. The 'trip point' voltage is the minimum supply voltage level at which the device can operate before the LVD module asserts an interrupt. When the supply  voltage  is  equal  to  the  trip  point,  the  voltage tapped  off  of  the  resistor  array  is  equal  to  the  1.2V internal  reference  voltage  generated  by  the  voltage reference module. The comparator then generates an interrupt  signal  setting  the  LVDIF  bit.  This  voltage  is software programmable to any one of 16 values (see Figure 18-2). The trip point is selected by programming the LVDL3:LVDL0 bits (LVDCON<3:0>).",
    "18.0 LOW-VOLTAGE DETECT\nFIGURE 18-1: TYPICAL LOW-VOLTAGE DETECT APPLICATION\nThe LVD module has an additional feature that allows the user to supply the trip voltage to the module from an external source. This mode is enabled when bits, LVDL3:LVDL0, are set to ' 1111 '. In this state, the comparator input is multiplexed from the external input pin,\nLVDIN (Figure 18-3). This gives users flexibility, because it allows them to configure the Low-Voltage Detect  interrupt  to  occur  at  any  voltage  in  the  valid operating range.",
    "18.1 Control Register\nThe Low-Voltage Detect Control register controls the operation of the Low-Voltage Detect circuitry.",
    "REGISTER 18-1: LVDCON: LOW-VOLTAGE DETECT CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = R-0/0. U-0, 3 = R/W-0/0. U-0, 4 = R/W-0/0. U-0, 5 = R/W-1/1. U-0, 6 = R/W-0/0. U-0, 7 = R/W-1/1. -, 1 = -. -, 2 = IRVST. -, 3 = LVDEN. -, 4 = LVDL3. -, 5 = LVDL2. -, 6 = LVDL1. -, 7 = LVDL0. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 18-1: LVDCON: LOW-VOLTAGE DETECT CONTROL REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit, U = Unimplemented bit, read as '0' = . u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = ",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5\nIRVST: Internal Reference Voltage Stable Flag bit\n1 = Indicates that the Low-Voltage Detect logic will generate the interrupt flag at the specified voltage range\n0 = Indicates that the Low-Voltage Detect logic will not generate the interrupt flag at the specified voltage range and the LVD interrupt should not be enabled\nLVDEN: Low-Voltage Detect Power Enable bit\n- 1 = Enables LVD, powers up LVD circuit\n0 = Disables LVD, powers down LVD circuit\nLVDL<3:0>: Low-Voltage Detection Limit bits (1)\n1111 = External analog input is used (input comes from the LVDIN pin)\n1110 = 4.04V-5.15V\n1101 = 3.76V-4.79V\n1100 = 3.58V-4.56V\n1011 = 3.41V-4.34V\n1010 = 3.23V-4.11V\n1001 = 3.14V-4.00V\n1000 = 2.96V-3.77V\n0111 = 2.70V-3.43V\n0110 = 2.53V-3.21V",
    "bit 7-6 Unimplemented: Read as ' 0 '\n0101 = 2.43V-3.10V\n0100 = 2.25V-2.86V\n0011 = 2.16V-2.75V\n0010 = 1.99V-2.53V\n0001 = Reserved\n0000 = Reserved\nNote 1: LVDL<3:0> modes, which result in a trip point below the valid operating voltage of the device, are not tested.",
    "18.2 Operation\nDepending on the power source for the device voltage, the voltage normally decreases relatively slowly. This means  that  the  LVD  module  does  not  need  to  be constantly operating. To decrease the current requirements, the LVD circuitry only needs to be enabled for short  periods,  where  the  voltage  is  checked.  After doing the check, the LVD module may be disabled.\nEach time that the LVD module is enabled, the circuitry requires some time to stabilize. After the circuitry has stabilized, all status flags may be cleared. The module will then indicate the proper state of the system.\nThe  following  steps  are  needed  to  set  up  the  LVD module:",
    "18.2 Operation\n1. Write the value to the LVDL3:LVDL0  bits (LVDCON register),  which  selects  the  desired LVD trip point.\n2. Ensure  that  LVD  interrupts  are  disabled  (the LVDIE bit is cleared or the GIE bit is cleared).\n3. Enable the LVD module (set the LVDEN bit in the LVDCON register).\n4. Wait for the LVD module to stabilize (the IRVST bit to become set).\n5. Clear  the  LVD  interrupt  flag,  which  may  have falsely  become  set,  until  the  LVD  module  has stabilized (clear the LVDIF bit).\n6. Enable the LVD interrupt (set the LVDIE and the GIE bits).\nFigure 18-4  shows  typical  waveforms  that  the  LVD module may be used to detect.",
    "18.2.1 REFERENCE VOLTAGE SET POINT\nThe internal reference voltage of the LVD module may be  used  by  other  internal  circuitry  (the  programmable Brown-out Reset). If these circuits are disabled (lower current consumption), the reference voltage circuit requires a time to become stable before a low-voltage condition can be reliably detected. This time is invariant of system clock speed. This start-up time is specified in electrical  specification  parameter  36.  The  low-voltage interrupt flag will not be enabled until a stable reference voltage is reached. Refer to the waveform in Figure 18-4.",
    "18.2.2 CURRENT CONSUMPTION\nWhen the module is enabled, the LVD comparator and voltage divider are enabled and will consume static current. The voltage divider can be tapped from multiple places in the resistor array. Total current consumption, when  enabled,  is  specified  in  electrical  specification parameter D022B.",
    "18.3 Operation During Sleep\nWhen enabled, the LVD circuitry continues to operate during  Sleep.  If  the  device  voltage  crosses  the  trip point, the LVDIF bit will be set and the device will wakeup from Sleep. Device execution will continue from the interrupt vector address if interrupts have been globally enabled.",
    "18.4 Effects of a Reset\nA device Reset forces all registers to their Reset state. This forces the LVD module to be turned off.",
    "19.0 SPECIAL FEATURES OF THE CPU\nPIC18F1220/1320  devices  include  several  features intended to maximize system reliability, minimize cost through elimination of external components and offer code protection. These are:\n\u00b7 Oscillator Selection\n\u00b7 Resets:\n-Power-on Reset (POR)\n-Power-up Timer (PWRT)\n-Oscillator Start-up Timer (OST)\n-Brown-out Reset (BOR)\n\u00b7 Interrupts\n\u00b7 Watchdog Timer (WDT)\n\u00b7 Fail-Safe Clock Monitor\n\u00b7 Two-Speed Start-up\n\u00b7 Code Protection\n\u00b7 ID Locations\n\u00b7 In-Circuit Serial Programming\nSeveral oscillator options are available to allow the part to  fit  the  application.  The  RC  oscillator  option  saves system cost, while the LP crystal option saves power. These are discussed in detail in Section 2.0 'Oscillator Configurations' .\nA complete discussion of device Resets and interrupts is available in previous sections of this data sheet.",
    "19.0 SPECIAL FEATURES OF THE CPU\nIn  addition  to  their  Power-up  and  Oscillator  Start-up Timers provided for Resets, PIC18F1220/1320 devices have a Watchdog Timer, which is either permanently enabled via the Configuration bits, or software controlled (if configured as disabled).\nThe inclusion of an internal RC oscillator also provides the  additional  benefits  of  a  Fail-Safe  Clock  Monitor (FSCM) and Two-Speed Start-up. FSCM provides for background  monitoring  of  the  peripheral  clock  and automatic switchover in the event of its failure.  TwoSpeed Start-up  enables  code  to  be  executed  almost immediately on start-up, while the primary clock source completes its start-up delays.\nAll  of  these  features  are  enabled  and  configured  by setting the appropriate Configuration register bits.",
    "19.1 Configuration Bits\nThe Configuration bits  can  be  programmed  (read  as ' 0 '), or left unprogrammed (read as ' 1 '), to select various  device  configurations.  These  bits  are  mapped starting at program memory location 300000h.\nThe user will note that address 300000h is beyond the user program memory space. In fact, it belongs to the configuration memory space (300000h-3FFFFFh), which  can  only  be  accessed  using  table  reads  and table writes.\nProgramming the Configuration registers is done in a manner similar to programming the Flash memory. The EECON1 register WR bit starts a self-timed write to the Configuration  register.  In  normal  operation  mode,  a TBLWT instruction,  with  the  TBLPTR  pointing  to  the Configuration  register,  sets  up  the  address  and  the data for the Configuration register write. Setting the WR bit starts a long write to the Configuration register. The Configuration registers are written a byte at a time. To write or erase a configuration cell, a TBLWT instruction can write a ' 1 ' or a ' 0 ' into the cell. For additional details on Flash programming, refer to Section 6.5 'Writing to Flash Program Memory' .",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\n300001h, File Name = CONFIG1H. 300001h, Bit 7 = IESO. 300001h, Bit 6 = FSCM. 300001h, Bit 5 = -. 300001h, Bit 4 = -. 300001h, Bit 3 = FOSC3. 300001h, Bit 2 = FOSC2. 300001h, Bit 1 = FOSC1. 300001h, Bit 0 = FOSC0. 300001h, Default/ Unprogrammed Value = 11-- 1111. 300001h, Default/ Unprogrammed Value = . 300002h, File Name = CONFIG2L. 300002h, Bit 7 = -. 300002h, Bit 6 = -. 300002h, Bit 5 = -. 300002h, Bit 4 = -. 300002h, Bit 3 = BORV1. 300002h, Bit 2 = BORV0. 300002h, Bit 1 = BOR. 300002h, Bit 0 = PWRTEN. 300002h, Default/ Unprogrammed",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\nValue = ---- 1111. 300002h, Default/ Unprogrammed Value = . 300003h, File Name = CONFIG2H. 300003h, Bit 7 = -. 300003h, Bit 6 = -. 300003h, Bit 5 = -. 300003h, Bit 4 = WDTPS3. 300003h, Bit 3 = WDTPS2. 300003h, Bit 2 = WDTPS1. 300003h, Bit 1 = WDTPS0. 300003h, Bit 0 = WDT. 300003h, Default/ Unprogrammed Value = ---1 1111. 300003h, Default/ Unprogrammed Value = . 300005h, File Name = CONFIG3H. 300005h, Bit 7 = MCLRE. 300005h, Bit 6 = -. 300005h, Bit 5 = -. 300005h, Bit 4 = -. 300005h, Bit 3 = -. 300005h, Bit 2 = -. 300005h,",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\nBit 1 = -. 300005h, Bit 0 = -. 300005h, Default/ Unprogrammed Value = 1--- ----. 300005h, Default/ Unprogrammed Value = . 300006h, File Name = CONFIG4L. 300006h, Bit 7 = DEBUG. 300006h, Bit 6 = -. 300006h, Bit 5 = -. 300006h, Bit 4 = -. 300006h, Bit 3 = -. 300006h, Bit 2 = LVP. 300006h, Bit 1 = -. 300006h, Bit 0 = STVR. 300006h, Default/ Unprogrammed Value = 1--- -1-1. 300006h, Default/ Unprogrammed Value = . 300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h,",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\nBit 3 = -. 300008h, Bit 2 = -. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300008h, Default/ Unprogrammed Value = ---- --11. 300008h, Default/ Unprogrammed Value = . 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 300009h, Default/ Unprogrammed Value = 11-- ----. 300009h, Default/ Unprogrammed Value = . 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -.",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\n30000Ah, Bit 4 = -. 30000Ah, Bit 3 = -. 30000Ah, Bit 2 = -. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Ah, Default/ Unprogrammed Value = ---- --11. 30000Ah, Default/ Unprogrammed Value = . 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Bh, Default/ Unprogrammed Value = 111- ----. 30000Bh, Default/ Unprogrammed Value = . 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -.",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\n30000Ch, Bit 4 = -. 30000Ch, Bit 3 = -. 30000Ch, Bit 2 = -. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Ch, Default/ Unprogrammed Value = ---- --11. 30000Ch, Default/ Unprogrammed Value = . 30000Dh, File Name = CONFIG7H. 30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -. 30000Dh, Default/ Unprogrammed Value = -1-- ----. 30000Dh, Default/ Unprogrammed Value = . 3FFFFEh, File Name = DEVID1 (1). 3FFFFEh, Bit 7 = DEV2. 3FFFFEh, Bit 6 = DEV1.",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\n3FFFFEh, Bit 5 = DEV0. 3FFFFEh, Bit 4 = REV4. 3FFFFEh, Bit 3 = REV3. 3FFFFEh, Bit 2 = REV2. 3FFFFEh, Bit 1 = REV1. 3FFFFEh, Bit 0 = REV0. 3FFFFEh, Default/ Unprogrammed Value = xxxx. 3FFFFEh, Default/ Unprogrammed Value = . 3FFFFFh, File Name = DEVID2 (1). 3FFFFFh, Bit 7 = DEV10. 3FFFFFh, Bit 6 = DEV9. 3FFFFFh, Bit 5 = DEV8. 3FFFFFh, Bit 4 = DEV7. 3FFFFFh, Bit 3 = DEV6. 3FFFFFh, Bit 2 = DEV5. 3FFFFFh, Bit 1 = DEV4. 3FFFFFh, Bit 0 = DEV3. 3FFFFFh, Default/ Unprogrammed Value = 0000. 3FFFFFh, Default/ Unprogrammed Value = ",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\nLegend: x = unknown, u = unchanged, - = unimplemented. Shaded cells are unimplemented, read as ' 0 '.\nNote 1:\n- See Register 19-12 for DEVID1 values. DEVID registers are read-only and cannot be programmed by the user.",
    "REGISTER 19-1: CONFIG1H: CONFIGURATION REGISTER 1 HIGH (BYTE ADDRESS 300001h)\nR/P-1, 1 = R/P-1. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = R/P-1. R/P-1, 5 = R/P-1. R/P-1, 6 = R/P-1. R/P-1, 7 = R/P-1. IESO, 1 = FSCM. IESO, 2 = -. IESO, 3 = -. IESO, 4 = FOSC3. IESO, 5 = FOSC2. IESO, 6 = FOSC1. IESO, 7 = FOSC0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 19-1: CONFIG1H: CONFIGURATION REGISTER 1 HIGH (BYTE ADDRESS 300001h)\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged,  = . u = Bit is unchanged,  = . '1' = Bit is set,  = '0' = Bit is cleared. '1' = Bit is set,  = P = Programmable bit",
    "bit 7 IESO: Internal External Switchover bit\n1 = Internal External Switchover mode enabled\n0 = Internal External Switchover mode disabled",
    "bit 6\nFSCM: Fail-Safe Clock Monitor Enable bit\n1 = Fail-Safe Clock Monitor enabled\n0 = Fail-Safe Clock Monitor disabled",
    "bit 3-0 FOSC<3:0>: Oscillator Selection bits\n11xx = External RC oscillator, CLKO function on RA6\n1001 = Internal RC oscillator, CLKO function on RA6 and port function on RA7\n1000 = Internal RC oscillator, port function on RA6 and port function on RA7\n0111 = External RC oscillator, port function on RA6\n0110 = HS oscillator, PLL enabled (clock frequency = 4 x FOSC1)\n0101 = EC oscillator, port function on RA6\n0100 = EC oscillator, CLKO function on RA6\n0010 = HS oscillator\n0001 = XT oscillator\n0000 = LP oscillator",
    "REGISTER 19-2: CONFIG2L: CONFIGURATION REGISTER 2 LOW (BYTE ADDRESS 300002h)\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/P-1 = BORV1. -, R/P-1 = BORV0. -, R/P-1 = BOR (1). -, R/P-1 = PWRTEN (1). bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/P-1 = bit 7. bit 7, R/P-1 = bit 7. bit 7, R/P-1 = bit 7. bit 7, R/P-1 = bit 0",
    "REGISTER 19-2: CONFIG2L: CONFIGURATION REGISTER 2 LOW (BYTE ADDRESS 300002h)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = P = Programmable bit\nbit 7-4 Unimplemented: Read as ' 0 '\nbit 3-2 BORV<1:0>: Brown-out Reset Voltage bits\n11 = Reserved\n10 = VBOR set to 2.7V\n01 = VBOR set to 4.2V\n00 = VBOR set to 4.5V",
    "bit 1 BOR: Brown-out Reset Enable bit\n(1)\n1 = Brown-out Reset enabled\n0 = Brown-out Reset disabled\nbit 0\nPWRTEN: Power-up Timer Enable bit\n(1)\n1 = PWRT disabled\n0 = PWRT enabled\nNote 1: The Power-up Timer is decoupled from Brown-out Reset, allowing these features to be independently controlled.",
    "REGISTER 19-3: CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\n-, U-0 = -. -, U-0 = -. -, R/P-1 = WDTPS3. -, R/P-1 = WDTPS2. -, R/P-1 = WDTPS1. -, R/P-1 = WDTPS0. -, R/P-1 = WDTEN. bit 7, U-0 = . bit 7, U-0 = . bit 7, R/P-1 = . bit 7, R/P-1 = . bit 7, R/P-1 = . bit 7, R/P-1 = . bit 7, R/P-1 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nP = Programmable bit",
    "bit 7-5 Unimplemented: Read as ' 0 '\nbit 4-1\nWDTPS<3:0>: Watchdog Timer Postscale Select bits\n1111 = 1:32,768\n1110 = 1:16,384\n1101 = 1:8,192\n1100 = 1:4,096\n1011 = 1:2,048\n1010 = 1:1,024\n1001 = 1:512\n1000 = 1:256\n0111 = 1:128\n0110 = 1:64\n0101 = 1:32\n0100 = 1:16\n0011 = 1:8\n0010 = 1:4\n0001 = 1:2\n0000 = 1:1",
    "bit 0\nWDT: Watchdog Timer Enable bit\n1 = WDT enabled\n0 = WDT disabled (control is placed on the SWDTEN bit)",
    "REGISTER 19-4: CONFIG3H: CONFIGURATION REGISTER 3 HIGH (BYTE ADDRESS 300005h)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = U-0. R/P-1, 6 = U-0. R/P-1, 7 = U-0. MCLRE, 1 = -. MCLRE, 2 = -. MCLRE, 3 = -. MCLRE, 4 = -. MCLRE, 5 = -. MCLRE, 6 = -. MCLRE, 7 = -. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "Legend:\nu = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = P = Programmable bit\nbit 7 MCLRE:\nMCLR Pin Enable bit\n1 = MCLR pin enabled, RA5 input pin disabled\n0 = RA5 input pin enabled, MCLR disabled\nbit 6-0\nUnimplemented: Read as ' 0 '",
    "REGISTER 19-5: CONFIG4L: CONFIGURATION REGISTER 4 LOW (BYTE ADDRESS 300006h)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = R/P-1. R/P-1, 6 = U-0. R/P-1, 7 = R/P-1. DEBUG, 1 = -. DEBUG, 2 = -. DEBUG, 3 = -. DEBUG, 4 = -. DEBUG, 5 = LVP. DEBUG, 6 = -. DEBUG, 7 = STVR. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 19-5: CONFIG4L: CONFIGURATION REGISTER 4 LOW (BYTE ADDRESS 300006h)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = P = Programmable bit",
    "REGISTER 19-5: CONFIG4L: CONFIGURATION REGISTER 4 LOW (BYTE ADDRESS 300006h)\nbit 7, 1 = DEBUG: Background Debugger Enable bit (see note) 1 = Background debugger disabled, RB6 and RB7 configured as general 0 = Background debugger enabled, RB6 and RB7 are dedicated to In-Circuit. bit 6-3, 1 = Unimplemented: Read as ' 0 '. bit 2, 1 = LVP: Low-Voltage ICSP Enable bit 1 = Low-Voltage ICSP enabled 0 = Low-Voltage ICSP disabled. bit 1, 1 = Unimplemented: Read as ' 0 '. bit 0, 1 = STVR: Stack Full/Underflow Reset Enable bit 1 = Stack full/underflow will cause Reset 0 = Stack full/underflow will not cause Reset\nNote:\nThe Timer1 oscillator shares the T1OSI and T1OSO pins with the PGD and PGC pins used for programming and debugging.",
    "REGISTER 19-5: CONFIG4L: CONFIGURATION REGISTER 4 LOW (BYTE ADDRESS 300006h)\nWhen using the Timer1 oscillator, In-Circuit Serial Programming (ICSP) may not function correctly (high voltage or low voltage), or the In-Circuit Debugger (ICD) may not communicate with the controller. As a result of using either ICSP or ICD, the Timer1 crystal may be damaged.\nIf  ICSP or ICD operations are required, the crystal should be disconnected from the circuit (disconnect either lead) or installed after programming. The oscillator loading capacitors may remain in-circuit during ICSP or ICD operation.",
    "REGISTER 19-6: CONFIG5L: CONFIGURATION REGISTER 5 LOW (BYTE ADDRESS 300008h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = CP1. -, 7 = CP0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 19-6: CONFIG5L: CONFIGURATION REGISTER 5 LOW (BYTE ADDRESS 300008h)\nR = Readable bit,  = W=Writable x = Bit is unknown. R = Readable bit,  = U = -n/n = Value at POR and BOR/Value at all other Resets. u = Bit is unchanged '1' = Bit is,  = '0' = Bit is cleared. u = Bit is unchanged '1' = Bit is,  = C = Clearable bit\nbit 7-2 Unimplemented: Read as ' 0 '\nbit 1\nCP1: Code Protection bit (PIC18F1320)\n1 = Block 1 (001000-001FFFh) not code-protected\n0 = Block 1 (001000-001FFFh) code-protected\nbit 0\nCP0: Code Protection bit (PIC18F1320)\n1 = Block 0 (00200-000FFFh) not code-protected\n0 = Block 0 (00200-000FFFh) code-protected\nbit 1\nCP1: Code Protection bit (PIC18F1220)\n1 = Block 1 (000800-000FFFh) not code-protected",
    "REGISTER 19-6: CONFIG5L: CONFIGURATION REGISTER 5 LOW (BYTE ADDRESS 300008h)\n0 = Block 1 (000800-000FFFh) code-protected\nbit 0\nCP0: Code Protection bit (PIC18F1220)\n1 = Block 0 (000200-0007FFh) not code-protected\n0 = Block 0 (000200-0007FFh) code-protected",
    "REGISTER 19-7: CONFIG5H: CONFIGURATION REGISTER 5 HIGH (BYTE ADDRESS 300009h)\nR/C-1, 1 = R/C-1. R/C-1, 2 = U-0. R/C-1, 3 = U-0. R/C-1, 4 = U-0. R/C-1, 5 = U-0. R/C-1, 6 = U-0. R/C-1, 7 = U-0. CPD, 1 = CPB. CPD, 2 = -. CPD, 3 = -. CPD, 4 = -. CPD, 5 = -. CPD, 6 = -. CPD, 7 = -. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 19-7: CONFIG5H: CONFIGURATION REGISTER 5 HIGH (BYTE ADDRESS 300009h)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = C = Clearable bit",
    "bit 7 CPD: Data EEPROM Code Protection bit\n1 = Data EEPROM not code-protected\n0 = Data EEPROM code-protected\nbit 6\nCPB: Boot Block Code Protection bit\n1 = Boot Block (000000-0001FFh) not code-protected\n0 = Boot Block (000000-0001FFh) code-protected\nbit 5-0\nUnimplemented: Read as ' 0 '",
    "REGISTER 19-8: CONFIG6L: CONFIGURATION REGISTER 6 LOW (BYTE ADDRESS 30000Ah)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = WRT1. -, 7 = WRT0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 19-8: CONFIG6L: CONFIGURATION REGISTER 6 LOW (BYTE ADDRESS 30000Ah)\nu = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = P = Programmable bit\nbit 7-2 Unimplemented: Read as ' 0 '\nbit 1\nWRT1: Write Protection bit (PIC18F1320)\n1 = Block 1 (001000-001FFFh) not write-protected\n0 = Block 1 (001000-001FFFh) write-protected\nbit 0\nWRT0: Write Protection bit (PIC18F1320)\n1 = Block 0 (00200-000FFFh) not write-protected\n0 = Block 0 (00200-000FFFh) write-protected\nbit 1",
    "REGISTER 19-8: CONFIG6L: CONFIGURATION REGISTER 6 LOW (BYTE ADDRESS 30000Ah)\nWRT1: Write Protection bit (PIC18F1220)\n1 = Block 1 (000800-000FFFh) not write-protected\n0 = Block 1 (000800-000FFFh) write-protected\nbit 0\nWRT0: Write Protection bit (PIC18F1220)\n1 = Block 0 (000200-0007FFh) not write-protected\n0 = Block 0 (000200-0007FFh) write-protected",
    "REGISTER 19-9: CONFIG6H: CONFIGURATION REGISTER 6 HIGH (BYTE ADDRESS 30000Bh)\nWRTD, R/P-1 = WRTB. WRTD, R-1 = WRTC (1). WRTD, U-0 = -. WRTD, U-0 = -. WRTD, U-0 = -. WRTD, U-0 = -. WRTD, U-0 = -. bit 7 bit 0, R/P-1 = bit 7 bit 0. bit 7 bit 0, R-1 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0",
    "REGISTER 19-9: CONFIG6H: CONFIGURATION REGISTER 6 HIGH (BYTE ADDRESS 30000Bh)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = P = Programmable bit\nbit 7\nWRTD: Data EEPROM Write Protection bit\n1 = Data EEPROM not write-protected\n0 = Data EEPROM write-protected\nbit 6\nWRTB: Boot Block Write Protection bit\n1 = Boot Block (000000-0001FFh) not write-protected\n0 = Boot Block (000000-0001FFh) write-protected\nbit 5\nWRTC: Configuration Register Write Protection bit (1)\n1 = Configuration registers (300000-3000FFh) not write-protected",
    "REGISTER 19-9: CONFIG6H: CONFIGURATION REGISTER 6 HIGH (BYTE ADDRESS 30000Bh)\n0 = Configuration registers (300000-3000FFh) write-protected\nbit 4-0\nUnimplemented: Read as ' 0 '\nNote 1: This bit is read-only in normal execution mode; it can be written only in Program mode.",
    "REGISTER 19-10: CONFIG7L: CONFIGURATION REGISTER 7 LOW (BYTE ADDRESS 30000Ch)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = EBTR1. -, 7 = EBTR0. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 19-10: CONFIG7L: CONFIGURATION REGISTER 7 LOW (BYTE ADDRESS 30000Ch)\nu = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged, U = Unimplemented bit, read as '0' = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set, U = Unimplemented bit, read as '0' = P = Programmable bit",
    "bit 7-2 Unimplemented: Read as ' 0 '\nbit 1\nEBTR1: Table Read Protection bit (PIC18F1320)\n1 = Block 1 (001000-001FFFh) not protected from table reads executed in other blocks\n0 = Block 1 (001000-001FFFh) protected from table reads executed in other blocks\nbit 0\nEBTR0: Table Read Protection bit (PIC18F1320)\n1 = Block 0 (00200-000FFFh) not protected from table reads executed in other blocks\n0 = Block 0 (00200-000FFFh) protected from table reads executed in other blocks\nbit 1\nEBTR1: Table Read Protection bit (PIC18F1220)\n1 = Block 1 (000800-000FFFh) not protected from table reads executed in other blocks\n0 = Block 1 (000800-000FFFh) protected from table reads executed in other blocks\nbit 0\nEBTR0: Table Read Protection bit (PIC18F1220)\n1 = Block 0 (000200-0007FFh) not protected from table reads executed in other blocks",
    "bit 7-2 Unimplemented: Read as ' 0 '\n0 = Block 0 (000200-0007FFh) protected from table reads executed in other blocks",
    "REGISTER 19-11: CONFIG7H: CONFIGURATION REGISTER 7 HIGH (BYTE ADDRESS 30000Dh)\nU-0, 1 = R/P-1. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = U-0. -, 1 = EBTRB. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = -. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 19-11: CONFIG7H: CONFIGURATION REGISTER 7 HIGH (BYTE ADDRESS 30000Dh)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. u = Bit is unchanged, 1 = x = Bit is unknown. u = Bit is unchanged, 2 = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = P = Programmable bit",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6\nEBTRB: Boot Block Table Read Protection bit\n1 = Boot Block (000000-0001FFh) not protected from table reads executed in other blocks\n0 = Boot Block (000000-0001FFh) protected from table reads executed in other blocks\nbit 5-0\nUnimplemented: Read as ' 0 '",
    "REGISTER 19-12: DEVID1: DEVICE ID REGISTER 1 FOR PIC18F1220/1320 DEVICES\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV2, 1 = DEV1. DEV2, 2 = DEV0. DEV2, 3 = REV4. DEV2, 4 = REV3. DEV2, 5 = REV2. DEV2, 6 = REV1. DEV2, 7 = REV0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\nu = Bit is unchanged\nx = Bit is unknown\n-n/n = Value at POR and BOR/Value at all other Resets\n'1' = Bit is set\n'0' = Bit is cleared\nbit 7-5\nDEV<2:0>: Device ID bits\n111 = PIC18F1220\n110 = PIC18F1320\nbit 4-0\nREV<4:0>: Revision ID bits\nThese bits are used to indicate the device revision.",
    "REGISTER 19-13: DEVID2: DEVICE ID REGISTER 2 FOR PIC18F1220/1320 DEVICES\nDEV10, R = DEV9. DEV10, R = DEV8. DEV10, R = DEV7. DEV10, R = DEV6. DEV10, R = DEV5. DEV10, R = DEV4. DEV10, R = DEV3. bit 7, R = bit 7. bit 7, R = bit 7. bit 7, R = bit 7. bit 7, R = bit 7. bit 7, R = bit 7. bit 7, R = bit 7. bit 7, R = bit 0\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -n/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = ",
    "bit 7-0 DEV<10:3>: Device ID bits\nThese bits are used with the DEV<2:0> bits in the Device ID Register 1 to identify the part number.\n0000 0111 = PIC18F1220/1320 devices\nNote 1: These values for DEV<10:3> may be shared with other devices. The specific device is always identified by using the entire DEV<10:0> bit sequence.",
    "19.2 Watchdog Timer (WDT)\nFor PIC18F1220/1320 devices, the WDT is driven by the INTRC source.  When  the  WDT  is  enabled,  the  clock source is also enabled. The nominal WDT period is 4 ms and has the same stability as the INTRC oscillator.\nThe 4 ms period of the WDT is multiplied by a 16-bit postscaler. Any output of the WDT postscaler is selected by  a  multiplexer,  controlled  by  bits  in  Configuration Register  2H.  Available  periods  range  from  4  ms  to 131.072 seconds (2.18 minutes). The WDT and postscaler are cleared when any of the following events occur: execute a SLEEP or CLRWDT instruction, the IRCF bits (OSCCON<6:4>)  are  changed  or  a  clock  failure  has occurred.\nAdjustments to the internal oscillator clock period using the  OSCTUNE  register  also  affect  the  period  of  the WDT by the same factor. For example, if the INTRC period  is  increased  by  3%,  then  the  WDT  period  is increased by 3%.",
    "19.2 Watchdog Timer (WDT)\nNote 1: The CLRWDT and SLEEP instructions clear  the  WDT  and  postscaler  counts when executed.\n2: Changing  the  setting  of  the  IRCF  bits (OSCCON<6:4>)  clears  the  WDT  and postscaler counts.\n3: When a CLRWDT instruction is executed the postscaler count will be cleared.",
    "19.2.1 CONTROL REGISTER\nRegister 19-14 shows the WDTCON register. This is a readable and writable register, which contains a control bit  that  allows  software  to  override  the  WDT  enable Configuration  bit,  only  if  the  Configuration  bit  has disabled the WDT.",
    "REGISTER 19-14: WDTCON: WATCHDOG TIMER CONTROL REGISTER\n-, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, U-0 = -. -, R/W-0/0 = SWDTEN (1). bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0/0 = bit 7 bit 0",
    "REGISTER 19-14: WDTCON: WATCHDOG TIMER CONTROL REGISTER\nR = Readable bit, W=Writable bit = . R = Readable bit,  = U = Unimplemented bit, read as '0'. u = Bit is unchanged, W=Writable bit = x = Bit is unknown. u = Bit is unchanged,  = -m/n = Value at POR and BOR/Value at all other Resets. '1' = Bit is set, W=Writable bit = '0' = Bit is cleared. '1' = Bit is set,  = \nbit 7-1 Unimplemented: Read as ' 0 '\nbit 0\nSWDTEN: Software Controlled Watchdog Timer Enable bit (1)\n1 = Watchdog Timer is on\n0 = Watchdog Timer is off\nNote 1: This bit has no effect if the Configuration bit, WDTEN (CONFIG2H<0>), is enabled.",
    "TABLE 19-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nCONFIG2H, Bit 7 = -. CONFIG2H, Bit 6 = -. CONFIG2H, Bit 5 = -. CONFIG2H, Bit 4 = WDTPS3. CONFIG2H, Bit 3 = WDTPS2. CONFIG2H, Bit 2 = WDTPS2. CONFIG2H, Bit 1 = WDTPS0. CONFIG2H, Bit 0 = WDTEN. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. WDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN\nLegend:",
    "TABLE 19-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nShaded cells are not used by the Watchdog Timer.",
    "19.3 Two-Speed Start-up\nThe Two-Speed Start-up feature helps to minimize the latency period from oscillator start-up to code execution by allowing the microcontroller to use the INTRC oscillator as a clock source until the primary clock source is available.  It  is  enabled  by  setting  the  IESO  bit  in Configuration Register 1H (CONFIG1H<7>).\nTwo-Speed Start-up is available only if the primary oscillator  mode  is  LP,  XT,  HS  or  HSPLL  (crystal-based modes). Other sources do not require an OST start-up delay; for these, Two-Speed Start-up is disabled.\nWhen enabled, Resets and wake-ups from Sleep mode cause  the  device  to  configure  itself  to  run  from  the internal oscillator block as the clock source, following the time-out of the Power-up Timer after a Power-on Reset is enabled. This allows almost immediate code execution  while  the  primary  oscillator  starts  and  the OST is running. Once the OST times out, the device automatically switches to PRI_RUN mode.",
    "19.3 Two-Speed Start-up\nIn all other power managed modes, Two-Speed Start-up is not used. The device will be clocked by the currently selected  clock  source  until  the  primary  clock  source becomes  available.  The  setting  of  the  IESO  bit  is ignored.",
    "19.3.1 SPECIAL CONSIDERATIONS FOR USING TWO-SPEED START-UP\nWhile using the INTRC oscillator in Two-Speed Startup, the device still obeys the normal command sequences for entering power managed modes, including  serial SLEEP instructions  (refer  to Section 3.1.3 'Multiple Sleep Commands' ). In practice, this means that user code can change the SCS1:SCS0 bit settings and issue SLEEP commands before the OST times out. This would allow an application to briefly wake-up, perform routine 'housekeeping' tasks and return to Sleep before  the  device  starts  to  operate  from  the  primary oscillator.\nBecause  the  OSCCON  register  is  cleared  on  Reset events, the INTOSC (or postscaler) clock source is not initially available after a Reset event; the INTRC clock is used directly at its base frequency. To use a higher clock  speed  on  wake-up,  the  INTOSC  or  postscaler clock sources can be selected to provide a higher clock speed by setting bits, IFRC2:IFRC0, immediately after Reset. For wake-ups from Sleep, the INTOSC or postscaler clock sources  can  be  selected  by  setting IFRC2:IFRC0 prior to entering Sleep mode.",
    "19.3.1 SPECIAL CONSIDERATIONS FOR USING TWO-SPEED START-UP\nUser code can also check if the primary clock source is currently providing the system clocking by checking the status of the OSTS bit (OSCCON<3>). If the bit is set, the  primary  oscillator  is  providing  the  system  clock. Otherwise, the internal oscillator block is providing the clock during wake-up from Reset or Sleep mode.",
    "19.4 Fail-Safe Clock Monitor\nThe Fail-Safe Clock Monitor (FSCM) allows the microcontroller  to  continue  operation,  in  the  event  of  an external  oscillator  failure,  by  automatically  switching the  system  clock  to  the  internal  oscillator  block.  The FSCM  function  is  enabled  by  setting  the  Fail-Safe Clock Monitor Enable bit, FSCM (CONFIG1H<6>).\nWhen FSCM is enabled, the INTRC oscillator runs at all times to monitor clocks to peripherals and provide an instant backup clock in the event of a clock failure. Clock  monitoring  (shown  in  Figure 19-3)  is  accomplished by creating a sample clock signal, which is the INTRC output divided by 64. This allows ample time between FSCM sample clocks for a peripheral clock edge  to  occur.  The  peripheral  system  clock  and  the sample  clock  are  presented  as  inputs  to  the  Clock Monitor latch (CM). The CM is set on the falling edge of the system clock source, but cleared on the rising edge of the sample clock.",
    "FIGURE 19-3: FSCM BLOCK DIAGRAM\nClock failure is tested for on the falling edge of the sample clock. If a sample clock falling edge occurs while CM  is  still  set,  a  clock  failure  has  been  detected (Figure 19-4). This causes the following:\n\u00b7 the FSCM generates an oscillator fail interrupt by setting bit, OSCFIF (PIR2<7>);\n\u00b7 the system clock source is switched to the internal oscillator block (OSCCON is not updated to show the current clock source - this is the Fail-Safe condition); and\n\u00b7 the WDT is reset.\nSince the postscaler frequency from the internal oscillator  block  may  not  be  sufficiently  stable,  it  may  be desirable  to  select  another  clock  configuration  and enter an alternate power managed mode (see Section 19.3.1  'Special  Considerations  for  Using Two-Speed  Start-up' and Section 3.1.3  'Multiple Sleep  Commands' for  more  details).  This  can  be done  to  attempt  a  partial  recovery,  or  execute  a controlled shutdown.",
    "FIGURE 19-3: FSCM BLOCK DIAGRAM\nTo use a higher clock speed on wake-up, the INTOSC or postscaler clock sources can be selected to provide a  higher  clock  speed  by  setting  bits,  IFRC2:IFRC0, immediately after Reset. For wake-ups from Sleep, the INTOSC or postscaler clock sources can be selected by setting IFRC2:IFRC0 prior to entering Sleep mode.\nAdjustments to the internal oscillator block, using the OSCTUNE register, also affect the period of the FSCM by the same factor. This can usually be neglected, as the clock frequency being monitored is generally much higher than the sample clock frequency.\nThe FSCM will detect failures of the primary or secondary clock sources only. If  the internal  oscillator  block fails, no failure would be detected, nor would any action be possible.",
    "19.4.1 FSCM AND THE WATCHDOG TIMER\nBoth  the  FSCM  and  the  WDT  are  clocked  by  the INTRC  oscillator.  Since  the  WDT  operates  with  a separate divider and counter, disabling the WDT has no effect on the operation of the INTRC oscillator when the FSCM is enabled.\nAs already noted, the clock source is switched to the INTOSC  clock  when  a  clock  failure is detected. Depending on the frequency selected by the IRCF2:IRCF0 bits, this may mean a substantial change in the speed of code execution. If the WDT is enabled with a small prescale value, a decrease in clock speed allows  a  WDT  time-out  to  occur  and  a  subsequent device Reset. For this reason, Fail-Safe Clock events also reset the WDT and postscaler, allowing it to start timing from when execution speed was changed and decreasing the likelihood of an erroneous time-out.",
    "19.4.2 EXITING FAIL-SAFE OPERATION\nThe Fail-Safe condition is terminated by either a device Reset,  or  by  entering  a  power  managed  mode.  On Reset,  the  controller  starts  the  primary  clock  source specified in Configuration Register 1H  (with any required  start-up  delays  that  are  required  for  the oscillator  mode,  such  as  OST  or  PLL  timer).  The INTOSC multiplexer provides the system clock until the primary clock source becomes ready (similar to a TwoSpeed  Start-up).  The  clock  system  source  is  then switched to the primary clock (indicated by the OSTS bit in the OSCCON register becoming set). The FailSafe  Clock  Monitor  then  resumes  monitoring  the peripheral clock.\nThe  primary  clock  source  may  never  become  ready during start-up. In this case, operation is clocked by the INTOSC multiplexer. The OSCCON register will remain in  its  Reset  state  until  a  power  managed  mode  is entered.\nEntering  a  power  managed  mode  by  loading  the OSCCON register and executing a SLEEP instruction will  clear  the  Fail-Safe condition. When the Fail-Safe condition  is  cleared,  the  clock  monitor  will  resume monitoring the peripheral clock.",
    "19.4.3 FSCM INTERRUPTS IN POWER MANAGED MODES\nAs previously mentioned, entering a power managed mode  clears  the  Fail-Safe  condition.  By  entering  a power  managed  mode,  the  clock  multiplexer  selects the  clock  source  selected  by  the  OSCCON  register. Fail-Safe  monitoring  of  the  power  managed  clock source resumes in the power managed mode.\nIf  an  oscillator  failure  occurs  during  power  managed operation, the subsequent events depend on whether or  not  the  oscillator  failure  interrupt  is  enabled.  If enabled (OSCFIF = 1 ), code execution will be clocked by  the  INTOSC  multiplexer.  An  automatic  transition back to the failed clock source will not occur.\nIf the interrupt is disabled, the device will not exit the power managed mode on oscillator failure. Instead, the device will continue to operate as before, but clocked by the INTOSC multiplexer. While in Idle mode, subsequent interrupts will cause the CPU to begin executing instructions while being clocked by the INTOSC multiplexer. The device will not transition to a different clock source until the Fail-Safe condition is cleared.",
    "19.4.4 POR OR WAKE FROM SLEEP\nThe FSCM is designed to detect oscillator failure at any point  after  the  device  has  exited  Power-on  Reset (POR) or Low-Power Sleep mode. When the primary system clock is EC, RC or INTRC modes, monitoring can begin immediately following these events.\nFor  oscillator  modes  involving  a  crystal  or  resonator (HS, HSPLL, LP or XT), the situation is somewhat different. Since the oscillator may require a start-up time considerably longer than the FCSM sample clock time, a false clock failure may be detected. To prevent this, the internal oscillator block is automatically configured as  the  system  clock  and  functions  until  the  primary clock  is  stable  (the  OST  and  PLL  timers  have  timed out).  This  is  identical  to  Two-Speed  Start-up  mode. Once the primary clock is stable, the INTRC returns to its role as the FSCM source\nNote:",
    "19.4.4 POR OR WAKE FROM SLEEP\nThe same logic that prevents false oscillator failure interrupts on POR or wake from Sleep will also prevent the detection of the oscillator's  failure  to  start  at  all  following these  events.  This  can  be  avoided  by monitoring  the  OSTS  bit  and  using  a timing routine to determine if the oscillator is  taking  too  long  to  start.  Even  so,  no oscillator failure interrupt will be flagged.\nAs noted in Section 19.3.1 'Special Considerations for Using Two-Speed Start-up' , it is also possible to select another clock configuration and enter an alternate  power  managed  mode  while  waiting  for  the primary system clock to become stable. When the new powered managed mode is selected, the primary clock is disabled.",
    "19.5 Program Verification and Code Protection\nThe  overall  structure  of  the  code  protection  on  the PIC18 Flash devices differs significantly from other PIC devices.\nEach  of  the  three  blocks  has  three  protection  bits associated with them. They are:\n\u00b7 Code-Protect bit (CPn)\n\u00b7 Write-Protect bit (WRTn)\n\u00b7 External Block Table Read bit (EBTRn)\nThe user program memory is divided into three blocks. One of these is a boot block of 512 bytes. The remainder of the memory is divided into two blocks on binary boundaries.\nFigure 19-5 shows the program memory organization for 4 and 8-Kbyte devices and the specific code protection bit associated with each block. The actual locations of the bits are summarized in Table 19-3.",
    "FIGURE 19-5: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F1220/1320\nCPB, WRTB, EBTRB, MEMORY SIZE/DEVICE.Address Range = 000000h 0001FFh. CPB, WRTB, EBTRB, MEMORY SIZE/DEVICE.4 Kbytes (PIC18F1220) = Boot Block. CPB, WRTB, EBTRB, MEMORY SIZE/DEVICE.8 Kbytes (PIC18F1320) = Boot Block. CPB, WRTB, EBTRB, MEMORY SIZE/DEVICE.Address Range = 000000h 0001FFh. CPB, WRTB, EBTRB, Block Code Protection.Controlled By: = CPB, WRTB, EBTRB. CP0, WRT0, EBTR0, MEMORY SIZE/DEVICE.Address Range = 000200h 0007FFh. CP0, WRT0, EBTR0, MEMORY SIZE/DEVICE.4 Kbytes (PIC18F1220) = Block 0. CP0, WRT0, EBTR0, MEMORY SIZE/DEVICE.8 Kbytes (PIC18F1320) =",
    "FIGURE 19-5: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F1220/1320\nBlock 0. CP0, WRT0, EBTR0, MEMORY SIZE/DEVICE.Address Range = 000200h. CP0, WRT0, EBTR0, Block Code Protection.Controlled By: = CP0, WRT0, EBTR0. CP1, WRT1, EBTR1, MEMORY SIZE/DEVICE.Address Range = 000800h 000FFFh. CP1, WRT1, EBTR1, MEMORY SIZE/DEVICE.4 Kbytes (PIC18F1220) = Block 1. CP1, WRT1, EBTR1, MEMORY SIZE/DEVICE.8 Kbytes (PIC18F1320) = . CP1, WRT1, EBTR1, MEMORY SIZE/DEVICE.Address Range = 000FFFh 001000h. CP1, WRT1, EBTR1, Block Code Protection.Controlled By: = . , MEMORY SIZE/DEVICE.Address Range = 001000h. , MEMORY SIZE/DEVICE.4 Kbytes (PIC18F1220) = . , MEMORY",
    "FIGURE 19-5: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F1220/1320\nSIZE/DEVICE.8 Kbytes (PIC18F1320) = Block 1. , MEMORY SIZE/DEVICE.Address Range = . , Block Code Protection.Controlled By: = CP1, WRT1, EBTR1. (Unimplemented Memory Space), MEMORY SIZE/DEVICE.Address Range = . (Unimplemented Memory Space), MEMORY SIZE/DEVICE.4 Kbytes (PIC18F1220) = Unimplemented Read ' 0 's. (Unimplemented Memory Space), MEMORY SIZE/DEVICE.8 Kbytes (PIC18F1320) = . (Unimplemented Memory Space), MEMORY SIZE/DEVICE.Address Range = 001FFFh. (Unimplemented Memory Space), Block Code Protection.Controlled By: = . , MEMORY SIZE/DEVICE.Address Range = . , MEMORY SIZE/DEVICE.4 Kbytes (PIC18F1220) = . , MEMORY SIZE/DEVICE.8 Kbytes (PIC18F1320) = Unimplemented Read ' 0 's. , MEMORY",
    "FIGURE 19-5: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F1220/1320\nSIZE/DEVICE.Address Range = . , Block Code Protection.Controlled By: = (Unimplemented Memory Space). 1FFFFFh, MEMORY SIZE/DEVICE.Address Range = . 1FFFFFh, MEMORY SIZE/DEVICE.4 Kbytes (PIC18F1220) = . 1FFFFFh, MEMORY SIZE/DEVICE.8 Kbytes (PIC18F1320) = . 1FFFFFh, MEMORY SIZE/DEVICE.Address Range = 1FFFFFh. 1FFFFFh, Block Code Protection.Controlled By: = ",
    "TABLE 19-3: SUMMARY OF CODE PROTECTION REGISTERS\n300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = -. 300008h, Bit 2 = -. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4 = -. 30000Ah, Bit",
    "TABLE 19-3: SUMMARY OF CODE PROTECTION REGISTERS\n3 = -. 30000Ah, Bit 2 = -. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = -. 30000Ch, Bit 2 = -. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Dh, File Name = CONFIG7H. 30000Dh, Bit 7 = -. 30000Dh, Bit 6 =",
    "TABLE 19-3: SUMMARY OF CODE PROTECTION REGISTERS\nEBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -\nLegend: Shaded cells are unimplemented.",
    "19.5.1 PROGRAM MEMORY CODE PROTECTION\nThe program memory may be read to, or written from, any  location  using  the  table  read  and  table  write instructions.  The  device  ID  may  be  read  with  table reads.  The  Configuration  registers  may  be  read  and written with the table read and table write instructions.\nIn normal execution mode, the CPn bits have no direct effect.  CPn  bits  inhibit  external  reads  and  writes.  A block  of  user  memory  may  be  protected  from  table writes if the WRTn Configuration bit is ' 0 '. The EBTRn bits  control  table  reads.  For  a  block  of  user  memory with the EBTRn bit set to ' 0 ',  a  table  read instruction that executes from within that block is allowed to read. A table read instruction that executes from a location outside  of  that  block  is  not  allowed  to  read  and  will result in reading ' 0 's. Figures 19-6 through 19-8 illustrate table write and table read protection.",
    "19.5.1 PROGRAM MEMORY CODE PROTECTION\nCode protection bits may only be written to a ' 0 ' from a ' 1 ' state. It is not possible to write a ' 1 ' to a bit in the ' 0 ' state. Code protection bits are only set to ' 1 ' by a full Chip Erase  or  Block  Erase  function.  The  full Chip Erase and Block Erase functions can only be initiated via ICSP or an external programmer.",
    "19.5.1 PROGRAM MEMORY CODE PROTECTION\nFIGURE 19-6: TABLE WRITE (WRTn) DISALLOWED: PIC18F1320\n\nTBLPTR = 0002FFh PC = 0007FEh, Program Memory = TBLWT *. TBLPTR = 0002FFh PC = 0007FEh, Configuration Bit Settings = WRT0, EBTR0 = 01. PC = 0017FEh, Program Memory = 000FFFh 001000h TBLWT *. PC = 0017FEh, Configuration Bit Settings = WRT1, EBTR1 = 11. Results: All table writes disabled to Blockn whenever WRTn = 0 ., Program Memory = Results: All table writes disabled to Blockn whenever WRTn = 0 .. Results: All table writes disabled to Blockn whenever WRTn = 0 ., Configuration Bit Settings = Results: All table writes disabled to Blockn whenever WRTn = 0 .\nNote:",
    "FIGURE 19-7: EXTERNAL BLOCK TABLE READ (EBTRn) DISALLOWED: PIC18F1320\nTBLPTR = 0002FFh, Program Memory = . TBLPTR = 0002FFh, Configuration Bit Settings = WRT0, EBTR0 = 10. PC = 001FFEh, Program Memory = TBLRD *. PC = 001FFEh, Configuration Bit Settings = WRT1, EBTR1 = 11. Results: All table reads from external blocks to Blockn are disabled whenever EBTRn = 0 . TABLAT register returns a value of ' 0 '., Program Memory = Results: All table reads from external blocks to Blockn are disabled whenever EBTRn = 0 . TABLAT register returns a value of ' 0 '.. Results: All table reads from external blocks to Blockn are disabled whenever EBTRn = 0 . TABLAT register returns a value of ' 0 '., Configuration Bit Settings = Results: All table reads from external blocks to Blockn are disabled whenever EBTRn = 0 . TABLAT register returns a value of ' 0 '.\nFIGURE 19-8: EXTERNAL BLOCK TABLE READ (EBTRn) ALLOWED: PIC18F1320",
    "FIGURE 19-7: EXTERNAL BLOCK TABLE READ (EBTRn) DISALLOWED: PIC18F1320\nTBLPTR = 0002FFh PC = 0007FEh, Program Memory = TBLRD *. TBLPTR = 0002FFh PC = 0007FEh, Configuration Bit Settings = WRT0, EBTR0 = 10. Results: Table reads permitted within Blockn, even when EBTRBn TABLAT register returns the value of the data at the, Program Memory = 000FFFh 001000h 001FFFh. Results: Table reads permitted within Blockn, even when EBTRBn TABLAT register returns the value of the data at the, Configuration Bit Settings = WRT1, EBTR1 = 11 0 .",
    "19.5.2 DATA EEPROM CODE PROTECTION\nThe entire  data  EEPROM  is  protected  from  external reads and writes by two bits: CPD and WRTD. CPD inhibits  external  reads  and  writes  of  data  EEPROM. WRTD inhibits external writes to data EEPROM. The CPU can continue to read and write data EEPROM, regardless of the protection bit settings.",
    "19.5.3 CONFIGURATION REGISTER PROTECTION\nThe  Configuration  registers  can  be  write-protected. The WRTC bit controls protection of the Configuration registers. In normal execution mode, the WRTC bit is readable only. WRTC can only be written via ICSP or an external programmer.",
    "19.6 ID Locations\nEight memory locations (200000h-200007h) are designated as ID locations, where the user can store checksum or other code identification numbers. These locations are both readable and writable during normal execution through the TBLRD and TBLWT instructions, or during program/verify. The ID locations can be read when the device is code-protected.",
    "19.7 In-Circuit Serial Programming\nPIC18F1220/1320  microcontrollers  can be serially programmed while in the end application circuit. This is simply done with two lines for clock and data and three other  lines  for  power,  ground  and  the  programming voltage. This allows customers to manufacture boards with  unprogrammed  devices  and  then  program  the microcontroller just before shipping the product. This also  allows  the  most  recent  firmware  or  a  custom firmware to be programmed (see Table 19-4).\nNote: The  Timer1  oscillator  shares  the  T1OSI\nand T1OSO pins with the PGD and PGC pins used for programming and debugging.\nWhen using the Timer1 oscillator, In-Circuit Serial Programming (ICSP) may not function correctly (high voltage or low voltage), or the In-Circuit Debugger (ICD) may not communicate with the controller. As a result of using either ICSP or ICD, the Timer1 crystal may be damaged.",
    "19.7 In-Circuit Serial Programming\nIf  ICSP  or  ICD  operations  are  required, the  crystal  should  be  disconnected  from the  circuit (disconnect  either  lead),  or installed after programming. The oscillator loading  capacitors  may  remain  in-circuit during ICSP or ICD operation.",
    "TABLE 19-4: ICSP/ICD CONNECTIONS\nPGD, Pin = RB7/PGD/T1OSI/ P1D/KBI3. PGD, Notes = Shared with T1OSC-protect crystal. PGC, Pin = RB6/PGC/T1OSO/ T13CKI/P1C/KBI2. PGC, Notes = Shared with T1OSC-protect crystal. MCLR, Pin = MCLR/VPP/RA5. MCLR, Notes = . VDD, Pin = VDD. VDD, Notes = . VSS, Pin = VSS. VSS, Notes = . PGM, Pin = RB5/PGM/KBI1. PGM, Notes = Optional - pull RB5 low is LVP enabled",
    "19.8 In-Circuit Debugger\nWhen the DEBUG  bit in Configuration register, CONFIG4L,  is  programmed  to  a  ' 0 ', the  In-Circuit Debugger functionality is enabled. This function allows simple debugging functions when used with MPLAB \u00ae IDE. When the microcontroller has this feature enabled, some resources are not available for general use. Table 19-5 shows which resources are required by the background debugger.",
    "TABLE 19-5: DEBUGGER RESOURCES\nI/O pins:, 1 = RB6, RB7. Stack:, 1 = 2 levels. Program Memory:, 1 = 512 bytes. Data Memory:, 1 = 10 bytes\nTo use the In-Circuit Debugger function of the microcontroller,  the  design  must  implement  In-Circuit Serial  Programming  connections  to  MCLR/VPP,  VDD, VSS, RB7 and RB6. This will interface to the In-Circuit Debugger module available from Microchip, or one of the third party development tool companies (see the note following Section 19.7 'In-Circuit Serial Programming' for more information).",
    "19.9 Low-Voltage ICSP Programming\nThe  LVP  bit  in  Configuration  register,  CONFIG4L, enables Low-Voltage Programming (LVP). When LVP is  enabled,  the  microcontroller  can  be  programmed without  requiring  high  voltage  being  applied  to  the MCLR/VPP/RA5 pin, but the RB5/PGM/KBI1 pin is then dedicated to controlling Program mode entry and is not available as a general purpose I/O pin.\nLVP is enabled in erased devices.\nWhile programming using LVP, VDD is applied to the MCLR/VPP/RA5 pin as in normal execution mode. To enter Programming mode, VDD is applied to the PGM pin.\nNote 1: High-voltage programming is always available,  regardless  of  the  state  of  the LVP bit or the PGM pin, by applying VIHH to the MCLR pin.\n2: When Low-Voltage Programming is enabled, the RB5 pin can no longer be used as a general purpose I/O pin.\n3: When LVP is enabled, externally pull the PGM pin to VSS to allow normal program execution.",
    "19.9 Low-Voltage ICSP Programming\nIf Low-Voltage Programming mode will not be used, the LVP bit can be cleared and RB5/PGM/KBI1 becomes available as the digital I/O pin RB5. The LVP bit may be set or cleared only when using standard high-voltage programming (VIHH applied to the MCLR/VPP/RA5 pin). Once LVP has been disabled, only the standard highvoltage programming is available and must be used to program the device.\nMemory  that  is  not  code-protected  can  be  erased, using either a Block Erase, or erased row by row, then written at any specified VDD. If code-protected memory is to be erased, a Block Erase is required. If a Block Erase  is  to  be  performed  when  using  Low-Voltage Programming, the device must be supplied with VDD   of 4.5V to 5.5V.",
    "20.0 INSTRUCTION SET SUMMARY\nThe PIC18 instruction set adds many enhancements to the previous PIC instruction sets, while maintaining an easy migration from these PIC instruction sets.\nMost instructions are a single program memory word (16 bits), but there are three instructions that require two program memory locations.\nEach single-word instruction  is  a 16-bit word  divided into an opcode, which specifies the instruction type and one  or  more  operands,  which  further  specify  the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18 instruction set summary in Table 20-1 lists byte-oriented , bit-oriented , literal and control operations. Table 20-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')\nThe  file  register  designator  'f'  specifies  which  file register is to be used by the instruction.",
    "20.0 INSTRUCTION SET SUMMARY\nThe  destination  designator  'd'  specifies  where  the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result  is  placed  in  the  file  register  specified  in  the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "20.0 INSTRUCTION SET SUMMARY\n\u00b7 A program memory address (specified by 'n')\n\u00b7 The mode of the CALL or RETURN instructions (specified by 's')\n\u00b7 The mode of the table read and table write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll  instructions  are  a  single  word,  except  for  three double-word instructions. These  three instructions were  made  double-word  instructions  so  that  all  the required information is available in these 32 bits. In the second word, the 4 MSbs are ' 1 's. If this second word is executed as an instruction (by itself), it will execute as a NOP .\nAll  single-word  instructions  are  executed  in  a  single instruction cycle, unless a conditional test is true, or the program counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles, with the additional instruction cycle(s) executed as a NOP .\nThe double-word instructions execute in two instruction cycles.",
    "20.0 INSTRUCTION SET SUMMARY\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \uf06d s. If a conditional test is true, or the program counter is changed as a result of an instruction, the instruction  execution  time is  2 \uf06d s. Two-word branch instructions (if true) would take 3 \uf06d s.\nFigure 20-1 shows the general formats that the instructions can have.\nAll examples use the format ' nnh ' to represent a hexadecimal  number,  where  ' h ' signifies  a  hexadecimal digit.\nThe  Instruction  Set  Summary,  shown  in  Table 20-1, lists the instructions recognized  by  the  Microchip Assembler (MPASM TM ). Section 20.2 'Instruction Set' provides a description of each instruction.",
    "20.1 Read-Modify-Write Operations\nAny instruction that specifies a file register as part of the instruction performs a Read-Modify-Write (R-M-W) operation. The register is read, the data is modified and the result is stored according to either the instruction or the  destination  designator  'd'.  A  read  operation  is performed on a register even if the instruction writes to that register.\nFor example, a ' BCF  PORTB,1 '  instruction  will  read PORTB, clear bit 1 of the data, then write the result back to PORTB. The read operation would have the unintended result that any condition that sets the RBIF flag would be cleared. The R-M-W operation may also copy the level of an input pin to its corresponding output latch.",
    "TABLE 20-1: OPCODE FIELD DESCRIPTIONS\na, Description = RAM access bit a = 0 : RAM location in Access RAM (BSR register is ignored) a = 1 : RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7).. BSR, Description = Bank Select Register. Used to select the current RAM bank.. d, Description = Destination select bit d = 0 : store result in WREG d = 1 : store result in file register f. dest, Description = Destination either the WREG register or the specified register file location.. f, Description = 8-bit register file address (0x00 to 0xFF).. fs, Description = 12-bit register file address (0x000 to 0xFFF). This is the source address.. fd, Description = 12-bit register file address (0x000 to 0xFFF). This is the destination address.. k, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value).. label, Description = Label name.. mm, Description = The",
    "TABLE 20-1: OPCODE FIELD DESCRIPTIONS\nmode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions: No change to register (such as TBLPTR with table reads and writes) Post-Increment register (such as TBLPTR with table reads and writes) Post-Decrement register (such as TBLPTR with table reads and writes). * *+, Description = . *-, Description = . +*, Description = Pre-Increment register (such as TBLPTR with table reads and writes). n, Description = The relative address (2's complement number) for relative branch instructions, or the direct address for call/branch and return instructions.. PRODH, Description = Product of Multiply High Byte.. PRODL, Description = Product of Multiply Low Byte.. s, Description = Fast Call/Return mode select bit s = 0 : do not update into/from shadow registers s = 1 : certain registers loaded into/from shadow registers (Fast mode). u, Description = Unused or unchanged.. WREG, Description = Working register (accumulator).. x, Description = Don't care ('",
    "TABLE 20-1: OPCODE FIELD DESCRIPTIONS\n0 ' or ' 1 '). The assembler will generate code with x = 0 . It is the recommended form of use for compatibility with all Microchip software tools.. TBLPTR, Description = 21-bit Table Pointer (points to a program memory location).. TABLAT, Description = 8-bit Table Latch.. TOS, Description = Top-of-Stack.. PC, Description = Program Counter.. , Description = Program Counter High Byte.. PCH, Description = . PCLATU, Description = Program Counter Upper Byte Latch.. WDT, Description = Watchdog Timer.. , Description = Power-down bit.. PD, Description = . C, DC, Z, OV,, Description = ALU Status bits: Carry, Digit Carry, Zero, Overflow, Negative.. ( ), Description = Contents.. \uf0ae, Description = Assigned to.. < >, Description = Register bit field.. \uf0ce, Description = In the set of.. italics, Description = User defined term (font is Courier).",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\nBYTE-ORIENTED FILE REGISTER OPERATIONS,  = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Description. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Cycles. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Notes. = BYTE-ORIENTED FILE REGISTER OPERATIONS. ADDWF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. ADDWF, Description. = Add WREG and f. ADDWF, Cycles. = . ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word. = 01da. ADDWF, 16-Bit Instruction Word. = ffff. ADDWF, 16-Bit Instruction Word.LSb = ffff. ADDWF, Status.Affected = C, DC, Z, OV, N. ADDWF, Notes. = 1, 2. ADDWFC,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. ADDWFC, Description. = Add WREG and Carry bit to f 1 1. ADDWFC, Cycles. = . ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word. = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status.Affected = C, DC, Z, OV, N. ADDWFC, Notes. = 1, 2. ANDWF,  = f, d, a. ANDWF, Description. = AND WREG with f. ANDWF, Cycles. = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001. ANDWF, 16-Bit Instruction Word. = 01da. ANDWF, 16-Bit Instruction Word. = ffff. ANDWF, 16-Bit Instruction Word.LSb = ffff. ANDWF, Status.Affected = Z, N. ANDWF, Notes. = 1,2. CLRF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, a. CLRF, Description. = Clear f. CLRF, Cycles. = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word. = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status.Affected = Z. CLRF, Notes. = 2. COMF,  = f, d, a. COMF, Description. = Complement f. COMF, Cycles. = 1. COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction Word. = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status.Affected = Z, N. COMF, Notes. = 1, 2. CPFSEQ,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, a. CPFSEQ, Description. = Compare f with WREG, skip = 1. CPFSEQ, Cycles. = (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word. = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status.Affected = None. CPFSEQ, Notes. = 4. CPFSGT,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, a. CPFSGT, Description. = Compare f with WREG, skip > 1. CPFSGT, Cycles. = (2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word. = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status.Affected = None. CPFSGT, Notes. = 4. CPFSLT,  = f, a. CPFSLT, Description. = Compare f with WREG, skip < 1. CPFSLT, Cycles. = (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word. = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status.Affected = None. CPFSLT, Notes. = 1, 2. DECF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. DECF, Description. = Decrement f. DECF, Cycles. = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word. = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status.Affected = C, DC, Z, OV, N. DECF, Notes. = 1, 2, 3, 4 4. DECFSZ,  = f, d, a. DECFSZ, Description. = Decrement f, Skip if 0. DECFSZ, Cycles. = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word. = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status.Affected = None. DECFSZ, Notes. = 1, 2, 3,. DCFSNZ,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. DCFSNZ, Description. = Decrement f, Skip if Not 0. DCFSNZ, Cycles. = 1 (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word. = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ, 16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status.Affected = None. DCFSNZ, Notes. = 1, 2. INCF,  = f, d, a. INCF, Description. = Increment f. INCF, Cycles. = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word. = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb = ffff. INCF, Status.Affected = C, DC, Z, OV, N. INCF, Notes. = 1, 2, 3, 4. INCFSZ,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. INCFSZ, Description. = Increment f, Skip if 0. INCFSZ, Cycles. = 1 (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word. = 11da. INCFSZ, 16-Bit Instruction Word. = ffff. INCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status.Affected = None. INCFSZ, Notes. = 4. INFSNZ,  = f, d, a. INFSNZ, Description. = Increment f, Skip if Not 0. INFSNZ, Cycles. = 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ, 16-Bit Instruction Word. = 10da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status.Affected = None. INFSNZ, Notes. = 1, 2. IORWF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. IORWF, Description. = Inclusive OR WREG with f. IORWF, Cycles. = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word. = 00da. IORWF, 16-Bit Instruction Word. = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status.Affected = Z, N. IORWF, Notes. = 1, 2. MOVF,  = f, d, a. MOVF, Description. = Move f. MOVF, Cycles. = . MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word. = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status.Affected = Z, N. MOVF, Notes. = 1. MOVFF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f s , f d. MOVFF, Description. = Move f s (source) to 1st word f d (destination) 2nd word 1 2. MOVFF, Cycles. = . MOVFF, 16-Bit Instruction Word.MSb = 1100. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word.LSb = ffff. MOVFF, Status.Affected = None. MOVFF, Notes. = . MOVWF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, a. MOVWF, Description. = Move WREG to f. MOVWF, Cycles. = 1. MOVWF, 16-Bit Instruction Word.MSb = 1111 0110. MOVWF, 16-Bit Instruction Word. = ffff 111a. MOVWF, 16-Bit Instruction Word. = ffff ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff ffff. MOVWF, Status.Affected = None. MOVWF, Notes. = . MULWF,  = f, a. MULWF, Description. = Multiply WREG with f. MULWF, Cycles. = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word. = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status.Affected = None. MULWF, Notes. = . NEGF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, a. NEGF, Description. = Negate f. NEGF, Cycles. = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word. = 110a. NEGF, 16-Bit Instruction Word. = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status.Affected = C, DC, Z, OV, N. NEGF, Notes. = 1, 2. RLCF,  = f, d, a. RLCF, Description. = Rotate Left f through Carry. RLCF, Cycles. = 1. RLCF, 16-Bit Instruction Word.MSb = 0011. RLCF, 16-Bit Instruction Word. = 01da. RLCF, 16-Bit Instruction Word. = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status.Affected = C, Z, N. RLCF, Notes. = . RLNCF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. RLNCF, Description. = Rotate Left f (No Carry). RLNCF, Cycles. = 1. RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word. = 01da. RLNCF, 16-Bit Instruction Word. = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status.Affected = Z, N. RLNCF, Notes. = 1, 2. RRCF,  = f, d, a. RRCF, Description. = Rotate Right f through Carry. RRCF, Cycles. = 1. RRCF, 16-Bit Instruction Word.MSb = 0011. RRCF, 16-Bit Instruction Word. = 00da. RRCF, 16-Bit Instruction Word. = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status.Affected = C, Z, N. RRCF, Notes. = . RRNCF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. RRNCF, Description. = Rotate Right f (No Carry). RRNCF, Cycles. = 1. RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word. = 00da. RRNCF, 16-Bit Instruction Word. = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff. RRNCF, Status.Affected = Z, N. RRNCF, Notes. = . SETF,  = f, a. SETF, Description. = Set f. SETF, Cycles. = 1. SETF, 16-Bit Instruction Word.MSb = 0110. SETF, 16-Bit Instruction Word. = 100a. SETF, 16-Bit Instruction Word. = ffff. SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status.Affected = None. SETF, Notes. = . SUBFWB,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. SUBFWB, Description. = Subtract f from WREG with borrow. SUBFWB, Cycles. = 1. SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word. = 01da. SUBFWB, 16-Bit Instruction Word. = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff. SUBFWB, Status.Affected = C, DC, Z, OV, N. SUBFWB, Notes. = 1, 2. SUBWF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. SUBWF, Description. = Subtract WREG from f. SUBWF, Cycles. = 1. SUBWF, 16-Bit Instruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word. = 11da. SUBWF, 16-Bit Instruction Word. = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status.Affected = C, DC, Z, OV, N. SUBWF, Notes. = . SUBWFB,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. SUBWFB, Description. = Subtract WREG from f with borrow. SUBWFB, Cycles. = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction Word. = 10da. SUBWFB, 16-Bit Instruction Word. = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status.Affected = C, DC, Z, OV, N. SUBWFB, Notes. = 1, 2. SWAPF,  = f, d, a. SWAPF, Description. = Swap nibbles in f. SWAPF, Cycles. = 1. SWAPF, 16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word. = 10da. SWAPF, 16-Bit Instruction Word. = ffff. SWAPF, 16-Bit Instruction Word.LSb = ffff. SWAPF, Status.Affected = None. SWAPF, Notes. = 4. TSTFSZ,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, a. TSTFSZ, Description. = Test f, skip if 0. TSTFSZ, Cycles. = 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word.MSb = 0110. TSTFSZ, 16-Bit Instruction Word. = 011a. TSTFSZ, 16-Bit Instruction Word. = ffff. TSTFSZ, 16-Bit Instruction Word.LSb = ffff. TSTFSZ, Status.Affected = None. TSTFSZ, Notes. = 1, 2. XORWF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a. XORWF, Description. = Exclusive OR WREG with f. XORWF, Cycles. = 1. XORWF, 16-Bit Instruction Word.MSb = . XORWF, 16-Bit Instruction Word. = . XORWF, 16-Bit Instruction Word. = . XORWF, 16-Bit Instruction Word.LSb = . XORWF, Status.Affected = Z, N. XORWF, Notes. = . 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS, Description. = 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS, Cycles. = 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.LSb = 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\nBIT-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS, Notes. = 0001 10da ffff ffff BIT-ORIENTED FILE REGISTER OPERATIONS. BCF,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, b, a. BCF, Description. = Bit Clear f. BCF, Cycles. = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word. = bbba. BCF, 16-Bit Instruction Word. = ffff. BCF, 16-Bit Instruction Word.LSb = ffff. BCF, Status.Affected = None. BCF, Notes. = 1, 2. BSF,  = f, b, a. BSF, Description. = Bit Set f. BSF, Cycles. = 1. BSF, 16-Bit Instruction Word.MSb = 1000. BSF, 16-Bit Instruction Word. = bbba. BSF, 16-Bit Instruction Word. = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status.Affected = None. BSF, Notes. = 1, 2. BTFSC,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, b, a. BTFSC, Description. = Bit Test f, Skip if Clear. BTFSC, Cycles. = 1 (2 or 3). BTFSC, 16-Bit Instruction Word.MSb = 1011. BTFSC, 16-Bit Instruction Word. = bbba. BTFSC, 16-Bit Instruction Word. = ffff. BTFSC, 16-Bit Instruction Word.LSb = ffff. BTFSC, Status.Affected = None. BTFSC, Notes. = 3, 4. BTFSS,  = f, b, a Bit. BTFSS, Description. = Test f, Skip if Set. BTFSS, Cycles. = 1 (2 or 3). BTFSS, 16-Bit Instruction Word.MSb = 1010. BTFSS, 16-Bit Instruction Word. = bbba. BTFSS, 16-Bit Instruction Word. = ffff. BTFSS, 16-Bit Instruction Word.LSb = ffff. BTFSS, Status.Affected = None. BTFSS, Notes. = 3, 4. BTG,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\n= f, d, a Bit. BTG, Description. = Toggle f. BTG, Cycles. = 1. BTG, 16-Bit Instruction Word.MSb = 0111. BTG, 16-Bit Instruction Word. = bbba. BTG, 16-Bit Instruction Word. = ffff. BTG, 16-Bit Instruction Word.LSb = ffff. BTG, Status.Affected = None. BTG, Notes. = 1, 2",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP , unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nCONTROL OPERATIONS, Mnemonic,.Operands = CONTROL OPERATIONS. CONTROL OPERATIONS, Description. = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected. = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes. = CONTROL OPERATIONS. BC, Mnemonic,.Operands = n. BC, Description. = Branch if Carry 1. BC, Cycles. = (2). BC, 16-Bit Instruction Word.MSb = 1110. BC, 16-Bit Instruction Word.MSb = 0010. BC, 16-Bit Instruction Word. = nnnn. BC, 16-Bit Instruction Word.LSb = nnnn. BC, Status Affected. = None None None None. BC, Notes. = . BN, Mnemonic,.Operands = n. BN, Description. = Branch if Negative 1. BN, Cycles. =",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n(2). BN, 16-Bit Instruction Word.MSb = 1110. BN, 16-Bit Instruction Word.MSb = 0110. BN, 16-Bit Instruction Word. = nnnn. BN, 16-Bit Instruction Word.LSb = nnnn. BN, Status Affected. = . BN, Notes. = . BNC, Mnemonic,.Operands = n. BNC, Description. = Branch if Not Carry 1. BNC, Cycles. = (2). BNC, 16-Bit Instruction Word.MSb = 1110. BNC, 16-Bit Instruction Word.MSb = 0011. BNC, 16-Bit Instruction Word. = nnnn. BNC, 16-Bit Instruction Word.LSb = nnnn. BNC, Status Affected. = . BNC, Notes. = . BNN, Mnemonic,.Operands = n. BNN, Description. = Branch if Not Negative 1. BNN, Cycles. = (2). BNN, 16-Bit Instruction Word.MSb = 1110. BNN, 16-Bit Instruction",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nWord.MSb = 0111. BNN, 16-Bit Instruction Word. = nnnn. BNN, 16-Bit Instruction Word.LSb = nnnn. BNN, Status Affected. = . BNN, Notes. = . BNOV, Mnemonic,.Operands = n. BNOV, Description. = Branch if Not Overflow 1. BNOV, Cycles. = (2). BNOV, 16-Bit Instruction Word.MSb = 1110. BNOV, 16-Bit Instruction Word.MSb = 0101. BNOV, 16-Bit Instruction Word. = nnnn. BNOV, 16-Bit Instruction Word.LSb = nnnn. BNOV, Status Affected. = None. BNOV, Notes. = . BNZ, Mnemonic,.Operands = n. BNZ, Description. = Branch if Not Zero 1. BNZ, Cycles. = (2). BNZ, 16-Bit Instruction Word.MSb = 1110. BNZ, 16-Bit Instruction Word.MSb = 0001. BNZ, 16-Bit Instruction Word. =",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nnnnn. BNZ, 16-Bit Instruction Word.LSb = nnnn. BNZ, Status Affected. = None. BNZ, Notes. = . BOV, Mnemonic,.Operands = n. BOV, Description. = Branch if Overflow 1. BOV, Cycles. = (2). BOV, 16-Bit Instruction Word.MSb = 1110. BOV, 16-Bit Instruction Word.MSb = 0100. BOV, 16-Bit Instruction Word. = nnnn. BOV, 16-Bit Instruction Word.LSb = nnnn. BOV, Status Affected. = None. BOV, Notes. = . BRA, Mnemonic,.Operands = n. BRA, Description. = Branch Unconditionally 2. BRA, Cycles. = . BRA, 16-Bit Instruction Word.MSb = 1101. BRA, 16-Bit Instruction Word.MSb = 0nnn. BRA, 16-Bit Instruction Word. = nnnn. BRA, 16-Bit Instruction Word.LSb = nnnn. BRA, Status Affected. =",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNone. BRA, Notes. = . BZ, Mnemonic,.Operands = n. BZ, Description. = Branch if Zero 1. BZ, Cycles. = (2). BZ, 16-Bit Instruction Word.MSb = 1110. BZ, 16-Bit Instruction Word.MSb = 0000. BZ, 16-Bit Instruction Word. = nnnn. BZ, 16-Bit Instruction Word.LSb = nnnn. BZ, Status Affected. = None. BZ, Notes. = . CALL, Mnemonic,.Operands = n, s. CALL, Description. = Call subroutine 1st word 2nd word 2. CALL, Cycles. = . CALL, 16-Bit Instruction Word.MSb = 1110. CALL, 16-Bit Instruction Word.MSb = 110s. CALL, 16-Bit Instruction Word. = kkkk. CALL, 16-Bit Instruction Word.LSb = kkkk. CALL, Status Affected. = None. CALL, Notes. = . CLRWDT, Mnemonic,.Operands = -.",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nCLRWDT, Description. = Clear Watchdog Timer 1. CLRWDT, Cycles. = . CLRWDT, 16-Bit Instruction Word.MSb = 1111 0000. CLRWDT, 16-Bit Instruction Word.MSb = kkkk 0000. CLRWDT, 16-Bit Instruction Word. = kkkk 0000. CLRWDT, 16-Bit Instruction Word.LSb = kkkk 0100. CLRWDT, Status Affected. = TO, PD. CLRWDT, Notes. = . DAW, Mnemonic,.Operands = -. DAW, Description. = Decimal Adjust WREG 1. DAW, Cycles. = . DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word.LSb = 0111. DAW, Status Affected. = C. DAW, Notes. = . GOTO, Mnemonic,.Operands = n.",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nGOTO, Description. = Go to address 1st word 2nd word 2. GOTO, Cycles. = . GOTO, 16-Bit Instruction Word.MSb = 1110. GOTO, 16-Bit Instruction Word.MSb = 1111. GOTO, 16-Bit Instruction Word. = kkkk. GOTO, 16-Bit Instruction Word.LSb = kkkk. GOTO, Status Affected. = None. GOTO, Notes. = . NOP, Mnemonic,.Operands = -. NOP, Description. = No Operation 1. NOP, Cycles. = . NOP, 16-Bit Instruction Word.MSb = 1111 0000. NOP, 16-Bit Instruction Word.MSb = kkkk 0000. NOP, 16-Bit Instruction Word. = kkkk 0000. NOP, 16-Bit Instruction Word.LSb = kkkk 0000. NOP, Status Affected. = None. NOP, Notes. = . NOP, Mnemonic,.Operands = -. NOP, Description. = No Operation 1. NOP, Cycles.",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . NOP, 16-Bit Instruction Word.MSb = 1111. NOP, 16-Bit Instruction Word.MSb = xxxx. NOP, 16-Bit Instruction Word. = xxxx. NOP, 16-Bit Instruction Word.LSb = xxxx. NOP, Status Affected. = None. NOP, Notes. = 4. POP, Mnemonic,.Operands = -. POP, Description. = Pop top of return stack (TOS) 1. POP, Cycles. = . POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word.LSb = 0110. POP, Status Affected. = None. POP, Notes. = . PUSH, Mnemonic,.Operands = -. PUSH, Description. = Push top of return stack (TOS) 1. PUSH, Cycles. = . PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word.MSb = 0000.",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nPUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word.LSb = 0101. PUSH, Status Affected. = None. PUSH, Notes. = . RCALL, Mnemonic,.Operands = n. RCALL, Description. = Relative Call 2. RCALL, Cycles. = . RCALL, 16-Bit Instruction Word.MSb = 1101. RCALL, 16-Bit Instruction Word.MSb = 1nnn. RCALL, 16-Bit Instruction Word. = nnnn. RCALL, 16-Bit Instruction Word.LSb = nnnn. RCALL, Status Affected. = None. RCALL, Notes. = . RESET, Mnemonic,.Operands = . RESET, Description. = Software device Reset 1. RESET, Cycles. = . RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word. = 1111. RESET, 16-Bit Instruction Word.LSb = 1111. RESET, Status Affected. = All. RESET, Notes. =",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n. RETFIE, Mnemonic,.Operands = s. RETFIE, Description. = Return from interrupt enable 2. RETFIE, Cycles. = . RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word. = 0001. RETFIE, 16-Bit Instruction Word.LSb = 000s. RETFIE, Status Affected. = GIE/GIEH, PEIE/GIEL. RETFIE, Notes. = . RETLW, Mnemonic,.Operands = k. RETLW, Description. = Return with literal in WREG 2. RETLW, Cycles. = . RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected. = None. RETLW,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNotes. = . RETURN, Mnemonic,.Operands = s. RETURN, Description. = Return from Subroutine 2. RETURN, Cycles. = . RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word. = 0001. RETURN, 16-Bit Instruction Word.LSb = 001s. RETURN, Status Affected. = None. RETURN, Notes. = . SLEEP, Mnemonic,.Operands = -. SLEEP, Description. = Go into Standby mode 1. SLEEP, Cycles. = . SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word.LSb = 0011. SLEEP, Status Affected. = TO, PD. SLEEP, Notes. = ",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP , unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nLITERAL OPERATIONS, Mnemonic,.Operands = LITERAL OPERATIONS. LITERAL OPERATIONS, Description.Description = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles.Cycles = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected.Status Affected = LITERAL OPERATIONS. LITERAL OPERATIONS,  = LITERAL OPERATIONS. ADDLW, Mnemonic,.Operands = k. ADDLW, Description.Description = Add literal and WREG. ADDLW, Cycles.Cycles = 1. ADDLW, 16-Bit Instruction Word.MSb = 0000. ADDLW, 16-Bit Instruction Word.MSb = 1111. ADDLW, 16-Bit Instruction Word. = kkkk. ADDLW, 16-Bit Instruction Word.LSb = kkkk. ADDLW, Status Affected.Status Affected = C, DC, Z, OV, N. ADDLW,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . ANDLW, Mnemonic,.Operands = k. ANDLW, Description.Description = AND literal with WREG. ANDLW, Cycles.Cycles = 1. ANDLW, 16-Bit Instruction Word.MSb = 0000. ANDLW, 16-Bit Instruction Word.MSb = 1011. ANDLW, 16-Bit Instruction Word. = kkkk. ANDLW, 16-Bit Instruction Word.LSb = kkkk. ANDLW, Status Affected.Status Affected = Z, N. ANDLW,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . IORLW, Mnemonic,.Operands = k. IORLW, Description.Description = Inclusive OR literal with WREG. IORLW, Cycles.Cycles = 1. IORLW, 16-Bit Instruction Word.MSb = 0000. IORLW, 16-Bit Instruction Word.MSb = 1001. IORLW, 16-Bit Instruction Word. = kkkk. IORLW, 16-Bit Instruction Word.LSb = kkkk. IORLW, Status Affected.Status Affected = Z, N. IORLW,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . LFSR, Mnemonic,.Operands = f, k. LFSR, Description.Description = Move literal (12-bit) 2nd word to FSRx 1st word. LFSR, Cycles.Cycles = 2. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word. = 00ff. LFSR, 16-Bit Instruction Word.LSb = kkkk. LFSR, Status Affected.Status Affected = None. LFSR,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . MOVLB, Mnemonic,.Operands = k. MOVLB, Description.Description = Move literal to BSR<3:0>. MOVLB, Cycles.Cycles = 1. MOVLB, 16-Bit Instruction Word.MSb = 1111 0000. MOVLB, 16-Bit Instruction Word.MSb = 0000 0001. MOVLB, 16-Bit Instruction Word. = kkkk 0000. MOVLB, 16-Bit Instruction Word.LSb = kkkk kkkk. MOVLB, Status Affected.Status Affected = None. MOVLB,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . MOVLW, Mnemonic,.Operands = k. MOVLW, Description.Description = Move literal to WREG. MOVLW, Cycles.Cycles = 1. MOVLW, 16-Bit Instruction Word.MSb = 0000. MOVLW, 16-Bit Instruction Word.MSb = 1110. MOVLW, 16-Bit Instruction Word. = kkkk. MOVLW, 16-Bit Instruction Word.LSb = kkkk. MOVLW, Status Affected.Status Affected = None. MOVLW,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . MULLW, Mnemonic,.Operands = k. MULLW, Description.Description = Multiply literal with WREG. MULLW, Cycles.Cycles = 1. MULLW, 16-Bit Instruction Word.MSb = 0000. MULLW, 16-Bit Instruction Word.MSb = 1101. MULLW, 16-Bit Instruction Word. = kkkk. MULLW, 16-Bit Instruction Word.LSb = kkkk. MULLW, Status Affected.Status Affected = None. MULLW,  = . RETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected.Status Affected = None. RETLW,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . SUBLW, Mnemonic,.Operands = k. SUBLW, Description.Description = Subtract WREG from literal. SUBLW, Cycles.Cycles = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000. SUBLW, 16-Bit Instruction Word.MSb = 1000. SUBLW, 16-Bit Instruction Word. = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected.Status Affected = C, DC, Z, OV, N. SUBLW,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . XORLW, Mnemonic,.Operands = k. XORLW, Description.Description = Exclusive OR literal with WREG. XORLW, Cycles.Cycles = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word.MSb = 1010. XORLW, 16-Bit Instruction Word. = kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected.Status Affected = Z, N. XORLW,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Mnemonic,.Operands = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Description.Description = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Cycles.Cycles = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word. = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.LSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Status Affected.Status Affected = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. TBLRD*, Mnemonic,.Operands = TBLRD*. TBLRD*, Description.Description = Table read. TBLRD*, Cycles.Cycles = 2. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected.Status Affected = None. TBLRD*,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLRD*+, Mnemonic,.Operands = TBLRD*+. TBLRD*+, Description.Description = Table read with post-increment. TBLRD*+, Cycles.Cycles = . TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected.Status Affected = None. TBLRD*+,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLRD*-, Mnemonic,.Operands = TBLRD*-. TBLRD*-, Description.Description = Table read with post-decrement. TBLRD*-, Cycles.Cycles = . TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected.Status Affected = None. TBLRD*-,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLRD+*, Mnemonic,.Operands = TBLRD+*. TBLRD+*, Description.Description = Table read with pre-increment. TBLRD+*, Cycles.Cycles = . TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected.Status Affected = None. TBLRD+*,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT*, Mnemonic,.Operands = TBLWT*. TBLWT*, Description.Description = Table write. TBLWT*, Cycles.Cycles = 2 (5). TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status Affected.Status Affected = None. TBLWT*,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT*+, Mnemonic,.Operands = TBLWT*+. TBLWT*+, Description.Description = Table write with post-increment. TBLWT*+, Cycles.Cycles = . TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected.Status Affected = None. TBLWT*+,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT*-, Mnemonic,.Operands = TBLWT*-. TBLWT*-, Description.Description = Table write with post-decrement. TBLWT*-, Cycles.Cycles = . TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected.Status Affected = None. TBLWT*-,",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT+*, Mnemonic,.Operands = TBLWT+*. TBLWT+*, Description.Description = Table write with pre-increment. TBLWT+*, Cycles.Cycles = . TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word.LSb = 1111. TBLWT+*, Status Affected.Status Affected = None. TBLWT+*,  = ",
    "TABLE 20-1: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP , unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "20.2 Instruction Set\nSyntax:, ADD literal to W = [ label ] ADDLW. Syntax:, ADD literal to W = [ label ] ADDLW. Syntax:, ADD literal to W = k. Syntax:, ADD literal to W = . Operands:, ADD literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, ADD literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, ADD literal to W = . Operands:, ADD literal to W = . Operation:, ADD literal to W = (W) + k \uf0ae W. Operation:, ADD literal to W = (W) + k \uf0ae W. Operation:, ADD literal to W = . Operation:, ADD literal to W = . Status Affected:, ADD literal to W = N, OV, C, DC, Z. Status Affected:, ADD literal to W = N, OV, C, DC, Z. Status Affected:, ADD literal to W = . Status Affected:, ADD literal to W = . Encoding:, ADD literal to W = 0000. Encoding:, ADD literal to W = 1111. Encoding:, ADD literal to W = kkkk. Encoding:, ADD literal to W = kkkk.",
    "20.2 Instruction Set\nDescription:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Words:, ADD literal to W = 1. Words:, ADD literal to W = . Words:, ADD literal to W = . Words:, ADD literal to W = . Cycles:, ADD literal to W = 1. Cycles:, ADD literal to W = . Cycles:, ADD literal to W = . Cycles:, ADD literal to W = . Q Cycle Activity: Q1, ADD literal to W = Q2. Q Cycle Activity: Q1, ADD literal to W = Q3. Q Cycle Activity: Q1, ADD literal to W = . Q Cycle Activity: Q1, ADD literal to",
    "20.2 Instruction Set\nW = . Decode, ADD literal to W = . Decode, ADD literal to W = . Decode, ADD literal to W = . Decode, ADD literal to W = Q4. , ADD literal to W = . , ADD literal to W = Read literal 'k'. , ADD literal to W = Process Data. , ADD literal to W = Write to W",
    "Example:\nADDLW\n0x15\nBefore Instruction\nW\n=\n0x10\nAfter Instruction\nW = 0x25",
    "Example:\nSyntax:, ADD Wto f = [ label ] ADDWF. Syntax:, ADD Wto f = [ label ] ADDWF. Syntax:, ADD Wto f = f [,d [,a]]. Syntax:, ADD Wto f = f [,d [,a]]. Operands:, ADD Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, ADD Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, ADD Wto f = . Operands:, ADD Wto f = . Operation:, ADD Wto f = (W) + (f) \uf0ae dest. Operation:, ADD Wto f = (W) + (f) \uf0ae dest. Operation:, ADD Wto f = . Operation:, ADD Wto f = . Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto f = . Status Affected:, ADD Wto f = . Encoding:, ADD",
    "Example:\nWto f = 0010. Encoding:, ADD Wto f = 01da. Encoding:, ADD Wto f = ffff. Encoding:, ADD Wto f = ffff. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1",
    "Example:\n', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Words:, ADD Wto f = 1. Words:, ADD Wto f = 1. Words:, ADD Wto f = . Words:, ADD Wto f = . Cycles:, ADD Wto f = 1. Cycles:, ADD Wto f = 1. Cycles:, ADD Wto f = . Cycles:, ADD Wto f = . Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q Cycle Activity:, ADD Wto f = Q Cycle",
    "Example:\nActivity:. Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q1, ADD Wto f = Q2. Q1, ADD Wto f = Q3. Q1, ADD Wto f = Q4. Q1, ADD Wto f = Q4. Decode, ADD Wto f = Read register 'f'. Decode, ADD Wto f = Process Data. Decode, ADD Wto f = Write to destination. Decode, ADD Wto f = Write to destination. Example:, ADD Wto f = ADDWF. Example:, ADD Wto f = REG,. Example:, ADD Wto f = W. Example:, ADD Wto f = . Before Instruction, ADD Wto f = Before Instruction. Before Instruction, ADD Wto f = Before Instruction. Before Instruction, ADD Wto f = Before Instruction. Before Instruction, ADD Wto f = Before Instruction. W, ADD Wto f = = 0x17. W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . REG, ADD Wto f = = 0xC2. REG, ADD Wto f = .",
    "Example:\nREG, ADD Wto f = . REG, ADD Wto f = . After Instruction, ADD Wto f = After Instruction. After Instruction, ADD Wto f = After Instruction. After Instruction, ADD Wto f = After Instruction. After Instruction, ADD Wto f = After Instruction. W REG, ADD Wto f = = 0xD9 = 0xC2. W REG, ADD Wto f = . W REG, ADD Wto f = . W REG, ADD Wto f = ",
    "Example:\nSyntax:, ADDWFC = Syntax:. Syntax:, ADD Wand Carry bit to f = [ label ] ADDWFC. Syntax:, ADD Wand Carry bit to f = [ label ] ADDWFC. Syntax:, ADD Wand Carry bit to f = f [,d [,a]]. Operands:, ADDWFC = Operands:. Operands:, ADD Wand Carry bit to f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1] a \uf0ce\uf020 [0,1]. Operands:, ADD Wand Carry bit to f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1] a \uf0ce\uf020 [0,1]. Operands:, ADD Wand Carry bit to f = . Operation:, ADDWFC = Operation:. Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \uf0ae dest. Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \uf0ae dest. Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \uf0ae dest. Status Affected:, ADDWFC = Status Affected:. Status Affected:, ADD Wand Carry bit to f = N, OV, C,",
    "Example:\nDC, Z. Status Affected:, ADD Wand Carry bit to f = N, OV, C, DC, Z. Status Affected:, ADD Wand Carry bit to f = N, OV, C, DC, Z. Encoding:, ADDWFC = Encoding:. Encoding:, ADD Wand Carry bit to f = 0010. Encoding:, ADD Wand Carry bit to f = 00da. Encoding:, ADD Wand Carry bit to f = ffff. Description:, ADDWFC = Description:. Description:, ADD Wand Carry bit to f = Add W, the Carry flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.. Description:, ADD Wand Carry bit to f = Add W, the Carry flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the",
    "Example:\nresult is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.. Description:, ADD Wand Carry bit to f = Add W, the Carry flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.. Words:, ADDWFC = Words:. Words:, ADD Wand Carry bit to f = 1. Words:, ADD Wand Carry bit to f = 1. Words:, ADD Wand Carry bit to f = 1. Cycles:, ADDWFC = Cycles:. Cycles:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Q Cycle Activity:, ADDWFC = Q Cycle Activity:. Q Cycle",
    "Example:\nActivity:, ADD Wand Carry bit to f = Q Cycle Activity:. Q Cycle Activity:, ADD Wand Carry bit to f = Q Cycle Activity:. Q Cycle Activity:, ADD Wand Carry bit to f = Q Cycle Activity:. , ADDWFC = Q1. , ADD Wand Carry bit to f = Q2. , ADD Wand Carry bit to f = Q3. , ADD Wand Carry bit to f = Q4. , ADDWFC = Decode. , ADD Wand Carry bit to f = Read register 'f'. , ADD Wand Carry bit to f = Process Data. , ADD Wand Carry bit to f = Write destination\nADDWFC\nREG, W",
    "Before Instruction\nCarry bit\n=\n1\nREG\n=\n0x02\nW\n=\n0x4D\nAfter Instruction\nCarry bit\n=\n0\nREG\n=\n0x02\nW\n=\n0x50",
    "PIC18F1220/1320\nSyntax:, AND literal with W = [ label ] ANDLW. Syntax:, AND literal with W = [ label ] ANDLW. Syntax:, AND literal with W = k. Syntax:, AND literal with W = . Operands:, AND literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND literal with W = . Operands:, AND literal with W = . Operation:, AND literal with W = (W) .AND. k \uf0ae W. Operation:, AND literal with W = (W) .AND. k \uf0ae W. Operation:, AND literal with W = . Operation:, AND literal with W = . Status Affected:, AND literal with W = N, Z. Status Affected:, AND literal with W = N, Z. Status Affected:, AND literal with W = . Status Affected:, AND literal with W = . Encoding:, AND literal with W = 0000. Encoding:, AND literal with W = 1011. Encoding:, AND literal with W = kkkk. Encoding:, AND literal with W = kkkk. Description:, AND literal with W = The",
    "PIC18F1220/1320\ncontents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Words:, AND literal with W = 1. Words:, AND literal with W = . Words:, AND literal with W = . Words:, AND literal with W = . Cycles:, AND literal with W = 1. Cycles:, AND literal with W = . Cycles:, AND literal with W = . Cycles:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q1, AND literal with W",
    "PIC18F1220/1320\n= Q2. Q1, AND literal with W = Q3. Q1, AND literal with W = Q4. Q1, AND literal with W = Q4. Decode, AND literal with W = Read literal 'k'. Decode, AND literal with W = Process Data. Decode, AND literal with W = Write to W. Decode, AND literal with W = Write to W. Example:, AND literal with W = ANDLW. Example:, AND literal with W = 0x5F. Example:, AND literal with W = . Example:, AND literal with W = . Before Instruction, AND literal with W = Before Instruction. Before Instruction, AND literal with W = . Before Instruction, AND literal with W = . Before Instruction, AND literal with W = . W, AND literal with W = = 0xA3. W, AND literal with W = . W, AND literal with W = . W, AND literal with W = . After Instruction, AND literal with W = After Instruction. After Instruction, AND literal with W = . After Instruction, AND literal with W = . After Instruction, AND literal with W = . W, AND literal with W =",
    "PIC18F1220/1320\n= 0x03. W, AND literal with W = . W, AND literal with W = . W, AND literal with W = ",
    "AND W with f\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\n[\nlabel\n]  ANDWF      f [,d [,a]]\n0 \uf0a3 f \uf0a3 255\nd \uf0ce\uf020 [0,1]\na \uf0ce\uf020 [0,1]\n(W) .AND. (f) \uf0ae dest\nN, Z\n0001\n01da ffff\nffff\nThe contents of W are AND'ed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).\n1\n1\nQ Cycle Activity:",
    "Example:\nANDWF\nREG, W\nBefore Instruction\nW\n=\n0x17\nREG\n=\n0xC2\nAfter Instruction\nW\n=\n0x02\nREG\n=\n0xC2",
    "BC\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:",
    "Branch if Carry\n[ label ]  BC    n\n-128 \uf0a3 n \uf0a3 127\n- if Carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC\nNone\nIf the Carry bit is ' 1 ', then the program will branch.\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nQ1\nDecode\nQ2\nRead literal\nQ3\nProcess\nQ4\nNo\n'n'\nData operation",
    "Example:\nHERE\nBC\nJUMP\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Carry\n=\n1;\nPC\n=\naddress\n(JUMP)\nIf Carry\n=\n0;\nPC\n=\naddress (HERE + 2)",
    "Example:\nSyntax:, Bit Clear f = [ label ] BCF. Syntax:, Bit Clear f = [ label ] BCF. Syntax:, Bit Clear f = f,b[,a]. Syntax:, Bit Clear f = f,b[,a]. Syntax:, Bit Clear f = f,b[,a]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = . Operands:, Bit Clear f = . Operands:, Bit Clear f = . Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = . Operation:, Bit Clear f = . Operation:, Bit Clear f = . Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = . Status Affected:, Bit Clear f = . Status Affected:, Bit Clear f = . Encoding:, Bit Clear f = 1001. Encoding:, Bit Clear f =",
    "Example:\nbbba. Encoding:, Bit Clear f = ffff. Encoding:, Bit Clear f = . Encoding:, Bit Clear f = ffff. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is '",
    "Example:\n0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Words:, Bit Clear f = . Words:, Bit Clear f = . Words:, Bit Clear f = . Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = . Cycles:, Bit Clear f = . Cycles:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = Q Cycle Activity:. Q Cycle Activity:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = . Q1, Bit Clear f =",
    "Example:\nQ2. Q1, Bit Clear f = Q2. Q1, Bit Clear f = Q3. Q1, Bit Clear f = Q3. Q1, Bit Clear f = Q4. Decode, Bit Clear f = Read register 'f'. Decode, Bit Clear f = Read register 'f'. Decode, Bit Clear f = Process Data. Decode, Bit Clear f = Process Data. Decode, Bit Clear f = Write register 'f'. Example:, Bit Clear f = BCF. Example:, Bit Clear f = FLAG_REG,. Example:, Bit Clear f = FLAG_REG,. Example:, Bit Clear f = 7. Example:, Bit Clear f = . Before Instruction FLAG_REG =, Bit Clear f = Before Instruction FLAG_REG =. Before Instruction FLAG_REG =, Bit Clear f = 0xC7. Before Instruction FLAG_REG =, Bit Clear f = 0xC7. Before Instruction FLAG_REG =, Bit Clear f = . Before Instruction FLAG_REG =, Bit Clear f = ",
    "Branch if Negative\nSyntax:\n[ label ]  BN    n\nOperands:\n-128 \uf0a3 n \uf0a3 127\nOperation:\nif Negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1110\n0110\nnnnn\nnnnn\nDescription:\nIf the Negative bit is ' 1 ', then the program will branch.\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity:\nIf Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation",
    "Example:\nHERE\nBN Jump\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Negative\n=\n1;\nPC\n=\naddress (Jump)\nIf Negative\n=\n0;\nPC\n=\naddress (HERE + 2)",
    "Branch if Not Carry\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\n[\nlabel\n]  BNC    n\n-128 \uf0a3 n \uf0a3 127\nif Carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC\nNone\n1110\n0011\nnnnn nnnn\nIf the Carry bit is ' 0 ', then the program will branch.\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.\n1\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nQ1\nDecode\nQ2\nRead literal\nQ3\nProcess\nQ4\nNo\n'n'\nData operation",
    "Example:\nHERE\nBNC Jump\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Carry\n=\n0;\nPC\n=\naddress\n(Jump)\nIf Carry\n=\n1;\nPC\n=\naddress (HERE + 2)",
    "Example:\nSyntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if",
    "Example:\nNegative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 0111. Encoding:, Branch if Not Negative = nnnn. Encoding:, Branch if Not Negative = nnnn. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the",
    "Example:\nnext instruction, the new address will be PC+2+2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a 2-cycle instruction..",
    "Example:\nWords:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q1, Branch if Not Negative = Q2. Q1, Branch if Not Negative = . Q1, Branch if Not Negative = Q3. Q1,",
    "Example:\nBranch if Not Negative = . Q1, Branch if Not Negative = Q4. Decode, Branch if Not Negative = Read literal 'n'. Decode, Branch if Not Negative = Read literal 'n'. Decode, Branch if Not Negative = Process Data. Decode, Branch if Not Negative = Process Data. Decode, Branch if Not Negative = Write to PC. No operation, Branch if Not Negative = No operation. No operation, Branch if Not Negative = No operation. No operation, Branch if Not Negative = No operation. No operation, Branch if Not Negative = No operation. No operation, Branch if Not Negative = No operation. If No Jump:, Branch if Not Negative = If No Jump:. If No Jump:, Branch if Not Negative = If No Jump:. If No Jump:, Branch if Not Negative = If No Jump:. If No Jump:, Branch if Not Negative = If No Jump:. If No Jump:, Branch if Not Negative = If No Jump:. Q1, Branch if Not Negative = Q2. Q1, Branch if Not Negative = Q2. Q1, Branch if Not Negative = Q3. Q1, Branch if Not Negative = Q3.",
    "Example:\nQ1, Branch if Not Negative = Q4. Decode, Branch if Not Negative = Read literal 'n'. Decode, Branch if Not Negative = Read literal 'n'. Decode, Branch if Not Negative = Process Data. Decode, Branch if Not Negative = Process Data. Decode, Branch if Not Negative = No operation. Example: HERE, Branch if Not Negative = Example: HERE. Example: HERE, Branch if Not Negative = . Example: HERE, Branch if Not Negative = BNN. Example: HERE, Branch if Not Negative = Jump. Example: HERE, Branch if Not Negative = . Before Instruction PC, Branch if Not Negative = Before Instruction PC. Before Instruction PC, Branch if Not Negative = =. Before Instruction PC, Branch if Not Negative = address. Before Instruction PC, Branch if Not Negative = (HERE). Before Instruction PC, Branch if Not Negative = . After Instruction If Negative, Branch if Not Negative = After Instruction If Negative. After Instruction If Negative, Branch if Not Negative = = =. After Instruction If Negative, Branch if Not Negative = 0; address 1;. After Instruction If Negative, Branch if Not Negative = (Jump). After Instruction If Negative, Branch if Not Negative =",
    "Example:\n. PC If Negative = PC =, Branch if Not Negative = PC If Negative = PC =. PC If Negative = PC =, Branch if Not Negative = . PC If Negative = PC =, Branch if Not Negative = address. PC If Negative = PC =, Branch if Not Negative = (HERE. PC If Negative = PC =, Branch if Not Negative = + 2)",
    "BNOV\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "Branch if Not Overflow\n[\nlabel\n]  BNOV    n\n-128 \uf0a3 n \uf0a3 127\nif Overflow bit is ' 0 '\n(PC) + 2 + 2n \uf0ae PC\nNone\n1110\n0101\nnnnn nnnn\nIf the Overflow bit is ' 0 ', then the program will branch.\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.\n1\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation",
    "Example:\nHERE\nBNOV Jump\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Overflow\n=\n0;\nPC\n=\naddress (Jump)\nIf Overflow\n=\n1;\nPC\n=\naddress (HERE + 2)",
    "Branch if Not Zero\nSyntax:\n[ label ]  BNZ    n\nOperands:\n-128 \uf0a3 n \uf0a3 127\nOperation:\nif Zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1110\n0001\nnnnn\nnnnn\nDescription:\nIf the Zero bit is ' 0 ', then the program will branch.\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation",
    "Example:\nHERE\nBNZ Jump\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Zero\n=\n0;\nPC\n=\naddress (Jump)\nIf Zero\n=\n1;\nPC\n=\naddress (HERE + 2)",
    "Unconditional Branch\nSyntax:\n[ label ]  BRA    n\nOperands:\n-1024 \uf0a3 n \uf0a3 1023\nOperation:\n(PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1101\n0nnn\nnnnn\nnnnn\nDescription:\nAdd the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a 2- cycle instruction.\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal\n'n'\nProcess\nData\nWrite to PC\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nExample:\nHERE\nBRA Jump\nBefore Instruction\nPC\n=\naddress\n(HERE)\nAfter Instruction\nPC\n=\naddress\n(Jump)",
    "Bit Set f\nSyntax:\n[\nlabel\n]  BSF    f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b \uf0a3 7\na \uf0ce\uf020 [0,1]\nOperation:\n1 \uf0ae f<b>\nStatus Affected:\nNone\nEncoding:\n1000\nbbba\nffff\nffff\nDescription:\nBit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess\nData\nWrite\nregister 'f'\nExample:\nBSF\nFLAG_REG, 7\nBefore Instruction\nFLAG_REG\n=\n0x0A\nAfter Instruction\nFLAG_REG\n= 0x8A\nBTFSC",
    "Bit Test File, Skip if Clear\nSyntax:\n[ label ]  BTFSC   f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b \uf0a3 7\na \uf0ce\uf020 [0,1]\nOperation:\nskip if (f<b>) = 0\nStatus Affected:\nNone\nEncoding:\n1011\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\nCycles:",
    "Q Cycle Activity:\nQ1\nDecode\nQ1\nNo\n1\n1(2)\nNote:\nQ2\n3 cycles if skip and followed by a 2-word instruction.\nQ3\nQ4\nRead register 'f'\nQ2\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nNo operation\nQ4\nNo operation\nIf skip and followed by 2-word instruction:\nQ1\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nQ2\nQ3\nQ4\nExample:\nHERE\nFALSE\nTRUE\nBTFSC FLAG, 1\n:\n:\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf FLAG<1>\n=\n0;\nPC\n=\naddress (TRUE)\nIf FLAG<1>\n=\n1;\nPC\n=\naddress (FALSE)\nIf skip:",
    "Bit Test File, Skip if Set\nSyntax:\n[ label ]  BTFSS  f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b < 7\na \uf0ce\uf020 [0,1]\nOperation:\nskip if (f<b>) = 1\nStatus Affected:\nNone\nEncoding:\n1010\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. skip:, Q2 = . skip:, Q3 = . skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE\nFALSE\nTRUE",
    "Q Cycle Activity:\nBTFSS FLAG, 1\n:\n:\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf FLAG<1>\n=\n0;\nPC\n=\naddress (FALSE)\nIf FLAG<1>\n=\n1;\nPC\n=\naddress (TRUE)",
    "PIC18F1220/1320\nBTG",
    "Bit Toggle f\nSyntax:\n[ label ]  BTG  f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b < 7\na \uf0ce\uf020 [0,1]\nOperation:\n(f<b>) \uf0ae f<b>\nStatus Affected:\nNone\nEncoding:\n0111\nbbba\nffff\nffff\nDescription:\nBit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite\nregister 'f'\nExample:\nBTG\nPORTB, 4\nBefore Instruction:\nPORTB\n=\n0111 0101 [0x75]\nAfter Instruction:\nPORTB\n=\n0110 0101 [0x65]",
    "BOV\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:",
    "Branch if Overflow\n[ label ]  BOV    n\n-128 \uf0a3 n \uf0a3 127\nif Overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC\nNone\n1110\n0100\nnnnn nnnn\nIf the Overflow bit is ' 1 ', then the program will branch.\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nQ1\nDecode\nQ2\nRead literal\nQ3\nProcess\nQ4\nNo\n'n'\nData operation",
    "Example:\nHERE\nBOV\nJUMP\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Overflow\n=\n1;\nPC\n=\naddress (JUMP)\nIf Overflow\n=\n0;\nPC\n=\naddress (HERE + 2)\nBZ\nSyntax:\nOperands:\nOperation:\nStatus Affected: Encoding:\nDescription:\nWords:\nCycles:",
    "Branch if Zero\n[\nlabel\n]  BZ    n\n-128 \uf0a3 n \uf0a3 127\nif Zero bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC\nNone\n1110\n0000\nnnnn nnnn\nIf the Zero bit is ' 1 ', then the program will branch.\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.\n1\n1(2)\nQ Cycle Activity: If Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation",
    "Example:\nHERE\nBZ Jump\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Zero\n=\n1;\nPC\n=\naddress\n(Jump)\nIf Zero\n=\n0;\nPC\n=\naddress\n(HERE + 2)",
    "Subroutine Call\nSyntax:, 1 = Syntax:. Syntax:, 2 = [ label ] CALL k [,s]. Syntax:, 3 = [ label ] CALL k [,s]. Syntax:, 4 = [ label ] CALL k [,s]. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, 3 = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, 4 = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operation:, 1 = Operation:. Operation:, 2 = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (W) \uf0ae WS, (Status) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, 3 = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (W) \uf0ae WS, (Status) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, 4 = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (W) \uf0ae WS, (Status) \uf0ae STATUSS,",
    "Subroutine Call\n(BSR) \uf0ae BSRS. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding: 1st word (k<7:0>), 1 = Encoding: 1st word (k<7:0>). Encoding: 1st word (k<7:0>), 2 = 1110 1111. Encoding: 1st word (k<7:0>), 3 = 110s k 19 kkk. Encoding: 1st word (k<7:0>), 4 = k 7 kkk kkkk. Description:, 1 = Description:. Description:, 2 = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a 2-cycle instruction..",
    "Subroutine Call\nDescription:, 3 = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a 2-cycle instruction.. Description:, 4 = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a 2-cycle instruction.. Words:, 1 = Words:. Words:, 2 = 2. Words:, 3 = 2. Words:, 4 = 2. Cycles:,",
    "Subroutine Call\n1 = Cycles:. Cycles:, 2 = 2. Cycles:, 3 = 2. Cycles:, 4 = 2. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read literal 'k'<7:0>,. , 3 = Push PC to stack. , 4 = Push PC to stack. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation",
    "Subroutine Call\nBefore Instruction, HERE = Before Instruction. Before Instruction, CALL THERE, FAST = Before Instruction. PC, HERE = =. PC, CALL THERE, FAST = address (HERE). After Instruction, HERE = After Instruction. After Instruction, CALL THERE, FAST = After Instruction. PC, HERE = =. PC, CALL THERE, FAST = address (THERE). TOS, HERE = =. TOS, CALL THERE, FAST = address (HERE + 4). WS, HERE = =. WS, CALL THERE, FAST = W. BSRS, HERE = =. BSRS, CALL THERE, FAST = BSR. STATUSS, HERE = =. STATUSS, CALL THERE, FAST = Status",
    "PIC18F1220/1320\nSyntax:, Clear f = [ label ] CLRF. Syntax:, Clear f = [ label ] CLRF. Syntax:, Clear f = f [,a]. Syntax:, Clear f = f [,a]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = . Operands:, Clear f = . Operation:, Clear f = 000h \uf0ae f 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f 1 \uf0ae Z. Operation:, Clear f = . Operation:, Clear f = . Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = . Status Affected:, Clear f = . Encoding:, Clear f = 0110. Encoding:, Clear f = 101a. Encoding:, Clear f = ffff. Encoding:, Clear f = ffff. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' =",
    "PIC18F1220/1320\n1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = . Words:, Clear f = . Cycles:, Clear f = 1. Cycles:, Clear f = 1.",
    "PIC18F1220/1320\nCycles:, Clear f = . Cycles:, Clear f = . Q Cycle, Clear f = Q Cycle. Q Cycle, Clear f = Activity:. Q Cycle, Clear f = Activity:. Q Cycle, Clear f = Activity:. Q1, Clear f = Q2. Q1, Clear f = . Q1, Clear f = Q3. Q1, Clear f = Q4. Decode, Clear f = Read register 'f'. Decode, Clear f = . Decode, Clear f = Process Data. Decode, Clear f = Write. , Clear f = . , Clear f = . , Clear f = . , Clear f = register 'f'. Example:, Clear f = CLRF. Example:, Clear f = . Example:, Clear f = FLAG_REG. Example:, Clear f = . Before Instruction, Clear f = Before Instruction. Before Instruction, Clear f = . Before Instruction, Clear f = . Before Instruction, Clear f = . FLAG_REG =, Clear f = FLAG_REG =. FLAG_REG =, Clear f = . FLAG_REG =, Clear f = . FLAG_REG =, Clear f = ",
    "PIC18F1220/1320\nSyntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler,. Status",
    "PIC18F1220/1320\nAffected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Encoding:, Clear Watchdog Timer = . Encoding:, Clear Watchdog Timer = . Encoding:, Clear Watchdog Timer = . Encoding:, Clear Watchdog Timer = . Encoding:, Clear Watchdog Timer = . , Clear Watchdog Timer = 0000. , Clear Watchdog Timer = 0000. , Clear Watchdog Timer = 0000. , Clear Watchdog Timer = 0000. , Clear Watchdog Timer = 0100. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog",
    "PIC18F1220/1320\nTimer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear",
    "PIC18F1220/1320\nWatchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = Q4. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = No operation. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Before Instruction WDT Counter, Clear Watchdog Timer = Before Instruction WDT Counter. Before Instruction",
    "PIC18F1220/1320\nWDT Counter, Clear Watchdog Timer = =. Before Instruction WDT Counter, Clear Watchdog Timer = ?. Before Instruction WDT Counter, Clear Watchdog Timer = . Before Instruction WDT Counter, Clear Watchdog Timer = . After Instruction WDT Counter, Clear Watchdog Timer = After Instruction WDT Counter. After Instruction WDT Counter, Clear Watchdog Timer = = =. After Instruction WDT Counter, Clear Watchdog Timer = 0x00 0. After Instruction WDT Counter, Clear Watchdog Timer = 0x00 0. After Instruction WDT Counter, Clear Watchdog Timer = 0x00 0. WDT Postscaler TO, Clear Watchdog Timer = WDT Postscaler TO. WDT Postscaler TO, Clear Watchdog Timer = =. WDT Postscaler TO, Clear Watchdog Timer = 1. WDT Postscaler TO, Clear Watchdog Timer = 1. WDT Postscaler TO, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = PD. PD, Clear Watchdog Timer = =. PD, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = 1",
    "PIC18F1220/1320\nCOMF, 1 = COMF. COMF, 2 = Complement f. COMF, 3 = Complement f. COMF, 4 = Complement f. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] COMF. Syntax:, 3 = [ label ] COMF. Syntax:, 4 = f [,d [,a]]. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 3 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 4 = . Operation:, 1 = Operation:. Operation:, 2 = (f) \uf0ae dest. Operation:, 3 = (f) \uf0ae dest. Operation:, 4 = . Status Affected:, 1 = Status Affected:. Status Affected:, 2 = N, Z. Status Affected:, 3 = . Status Affected:, 4 = . Encoding:, 1 = Encoding:. Encoding:, 2 = 0001. Encoding:, 3 = 11da. Encoding:, 4 = ffff. Description:, 1 = Description:.",
    "PIC18F1220/1320\nDescription:, 2 = The contents of register 'f' are complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 3 = The contents of register 'f' are complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 4 = The contents of register 'f' are complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is",
    "PIC18F1220/1320\nstored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = . Words:, 4 = . Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = . Cycles:, 4 = . Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read register 'f'. , 3 = Process Data. , 4 = . Example:, 1 = Example:. Example:, 2 = COMF. Example:, 3 = REG, W. Example:, 4 = . Before Instruction, 1 = Before Instruction. Before",
    "PIC18F1220/1320\nInstruction, 2 = Before Instruction. Before Instruction, 3 = . Before Instruction, 4 = . , 1 = REG. , 2 = = 0x13. , 3 = . , 4 = . After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. After Instruction, 3 = . After Instruction, 4 = . , 1 = REG W. , 2 = = 0x13 = 0xEC. , 3 = . , 4 = ",
    "Compare f with W, skip if f = W\nSyntax:\n[ label ]   CPFSEQ    f [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce [0,1]\nOperation:\n(f) - (W),\nskip if (f) = (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n001a\nffff\nffff\nDescription:\nCompares the contents of data memory location 'f' to the contents of W by performing an unsigned subtraction.\nIf 'f' = W  then the fetched , instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Compare f with W, skip if f = W\nskip:, Q2 = skip:. skip:, Q3 Process = skip:. skip:, Q4 No = skip:. Q1, Q2 = Q2. Q1, Q3 Process = Q3. Q1, Q4 No = Q4. No operation, Q2 = No operation. No operation, Q3 Process = No operation. No operation, Q4 No = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 Process = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 No = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 Process = Q3. Q1, Q4 No = Q4. No operation, Q2 = No operation. No operation, Q3 Process = No operation. No operation, Q4 No = No operation. No operation, Q2 = No operation. No operation, Q3 Process = No operation. No operation, Q4 No = No operation.",
    "Compare f with W, skip if f = W\nExample: HERE CPFSEQ REG, Q2 = Example: HERE CPFSEQ REG. Example: HERE CPFSEQ REG, Q3 Process = Example: HERE CPFSEQ REG. Example: HERE CPFSEQ REG, Q4 No = Example: HERE CPFSEQ REG. Before Instruction, Q2 = Before Instruction. Before Instruction, Q3 Process = Before Instruction. Before Instruction, Q4 No = Before Instruction. PC Address = HERE, Q2 = PC Address = HERE. PC Address = HERE, Q3 Process = PC Address = HERE. PC Address = HERE, Q4 No = PC Address = HERE. W = ? REG = ? After Instruction, Q2 = W = ? REG = ? After Instruction. W = ? REG = ? After Instruction, Q3 Process = W = ? REG = ? After Instruction. W = ? REG = ? After Instruction, Q4 No = W = ? REG = ? After Instruction. If REG = W; PC = Address (EQUAL) If REG \uf0b9 W; PC = Address (NEQUAL), Q2 = If REG = W; PC = Address (EQUAL) If REG \uf0b9 W; PC = Address",
    "Compare f with W, skip if f = W\n(NEQUAL). If REG = W; PC = Address (EQUAL) If REG \uf0b9 W; PC = Address (NEQUAL), Q3 Process = If REG = W; PC = Address (EQUAL) If REG \uf0b9 W; PC = Address (NEQUAL). If REG = W; PC = Address (EQUAL) If REG \uf0b9 W; PC = Address (NEQUAL), Q4 No = If REG = W; PC = Address (EQUAL) If REG \uf0b9 W; PC = Address (NEQUAL)",
    "PIC18F1220/1320\nCPFSGT\nCompare f with W, skip if f > W\nSyntax:\n[ label ]   CPFSGT    f [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce [0,1]\nOperation:\n(f) - \uf020\uf028 W),\nskip if (f) > (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n010a\nffff\nffff\nDescription:\nCompares the contents of data memory location 'f' to the contents of W by performing an unsigned subtraction.\nIf the contents of 'f' are greater than the contents of WREG  then the , fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nIf skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nHERE      CPFSGT REG\nNGREATER  :\nGREATER   :\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nW\n=\n?\nAfter Instruction\nIf REG\n\uf03e\nW;\nPC\n=\nAddress\n(GREATER)\nIf REG\n\uf0a3\nW;\nPC\n=\nAddress (NGREATER)",
    "Q Cycle Activity:\nSyntax:, Compare f with W, skip if f < W = [ label ] CPFSLT. Syntax:, Compare f with W, skip if f < W = [ label ] CPFSLT. Syntax:, Compare f with W, skip if f < W = f [,a]. Syntax:, Compare f with W, skip if f < W = . Operands:, Compare f with W, skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Compare f with W, skip if f < W = (f) - \uf020\uf028 W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, skip if f < W = (f) - \uf020\uf028 W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f",
    "Q Cycle Activity:\nwith W, skip if f < W = (f) - \uf020\uf028 W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, skip if f < W = (f) - \uf020\uf028 W), skip if (f) < (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f < W = None. Status Affected:, Compare f with W, skip if f < W = None. Status Affected:, Compare f with W, skip if f < W = None. Status Affected:, Compare f with W, skip if f < W = None. Encoding:, Compare f with W, skip if f < W = 0110. Encoding:, Compare f with W, skip if f < W = 000a. Encoding:, Compare f with W, skip if f < W = ffff. Encoding:, Compare f with W, skip if f < W = ffff. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of",
    "Q Cycle Activity:\nW, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will",
    "Q Cycle Activity:\nbe selected. If 'a' is ' 1 ', the BSR will not be. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be. Words:, Compare f with W, skip if f < W = 1. Words:, Compare f with W, skip if f < W = 1. Words:, Compare f with W, skip if f < W = 1. Words:, Compare f with W, skip if f < W = 1. Cycles:, Compare f with W, skip if f < W = 1(2). Cycles:, Compare f with W, skip if f < W = 1(2). Cycles:, Compare f with W, skip if f < W = 1(2). Cycles:, Compare f",
    "Q Cycle Activity:\nwith W, skip if f < W = 1(2)\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.\nIf skip:\nQ1\nNo\nQ2\nNo\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE    CPFSLT REG\nNLESS   :\nLESS    :\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nW\n=\n?\nAfter Instruction\nIf REG\n<\nW;\nPC\n=\nAddress (LESS)\nIf REG\n\uf0b3\nW;\nPC\n=\nAddress (NLESS)",
    "DAW\nDescription:\n, 1 = [ label ] DAW. , 2 = [ label ] DAW. , 3 = [ label ] DAW. , 4 = [ label ] DAW. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = . Operation:, 2 = . Operation:, 3 = . Operation:, 4 = . , 1 = If [W<3:0> > 9] or [DC = 1 ] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0>;. , 2 = If [W<3:0> > 9] or [DC = 1 ] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0>;. , 3 = If [W<3:0> > 9] or [DC = 1 ] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae",
    "DAW\nW<3:0>;. , 4 = If [W<3:0> > 9] or [DC = 1 ] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0>;. Status Affected:, 1 = C, DC. Status Affected:, 2 = C, DC. Status Affected:, 3 = C, DC. Status Affected:, 4 = C, DC. Encoding:, 1 = 0000. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Encoding:, 4 = 0111",
    "Decimal Adjust W Register\nDAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result. The Carry bit may be set by DAW regardless of its setting prior to the DAW instruction.\nWords:\n1\nCycles:\nQ Cycle Activity:\nQ1\nDecode\n1\nQ2\nRead register W\nExample 1:\nDAW",
    "Before Instruction\nW\n=\n0xA5\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n=\n0x05\nC\n=\n1\nDC\n=\n0",
    "Example 2:\nBefore Instruction\nW\n=\n0xCE\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n=\n0x34\nC\n=\n1\nDC\n=\n0\nQ3\nProcess Data\nQ4\nWrite\nW",
    "PIC18F1220/1320\nSyntax:, Decrement f = [ label ] DECF. Syntax:, Decrement f = [ label ] DECF. Syntax:, Decrement f = f [,d [,a]]. Syntax:, Decrement f = f [,d [,a]]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = . Operands:, Decrement f = . Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = . Operation:, Decrement f = . Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = . Status Affected:, Decrement f = . Encoding:,",
    "PIC18F1220/1320\nDecrement f = 0000. Encoding:, Decrement f = 01da. Encoding:, Decrement f = ffff. Encoding:, Decrement f = ffff. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:,",
    "PIC18F1220/1320\nDecrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Decrement f = 1. Words:, Decrement f = . Words:, Decrement f = . Words:, Decrement f = . Cycles:, Decrement f = 1.",
    "PIC18F1220/1320\nCycles:, Decrement f = . Cycles:, Decrement f = . Cycles:, Decrement f = . Q Cycle Activity:, Decrement f = Q2. Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q1, Decrement f = . Q1, Decrement f = . Q1, Decrement f = Q3. Q1, Decrement f = Q4. Decode, Decrement f = . Decode, Decrement f = Read register 'f'. Decode, Decrement f = Process Data. Decode, Decrement f = Write to destination. Example: DECF CNT, Decrement f = Example: DECF CNT. Example: DECF CNT, Decrement f = Example: DECF CNT. Example: DECF CNT, Decrement f = Example: DECF CNT. Example: DECF CNT, Decrement f = Example: DECF CNT. Before Instruction CNT = 0x01 Z = 0 After",
    "PIC18F1220/1320\nInstruction, Decrement f = Before Instruction CNT = 0x01 Z = 0 After Instruction. Before Instruction CNT = 0x01 Z = 0 After Instruction, Decrement f = Before Instruction CNT = 0x01 Z = 0 After Instruction. Before Instruction CNT = 0x01 Z = 0 After Instruction, Decrement f = Before Instruction CNT = 0x01 Z = 0 After Instruction. Before Instruction CNT = 0x01 Z = 0 After Instruction, Decrement f = Before Instruction CNT = 0x01 Z = 0 After Instruction. CNT Z, Decrement f = = =. CNT Z, Decrement f = 0x00 1. CNT Z, Decrement f = . CNT Z, Decrement f = ",
    "PIC18F1220/1320\nSyntax:, Decrement f, skip if 0 = [ label ] DECFSZ. Syntax:, Decrement f, skip if 0 = [ label ] DECFSZ. Syntax:, Decrement f, skip if 0 = f [,d [,a]]. Syntax:, Decrement f, skip if 0 = f [,d [,a]]. Operands:, Decrement f, skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if 0 = . Operands:, Decrement f, skip if 0 = . Operation:, Decrement f, skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, Decrement f, skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, Decrement f, skip if 0 = . Operation:, Decrement f, skip if 0 = . Status",
    "PIC18F1220/1320\nAffected:, Decrement f, skip if 0 = None. Status Affected:, Decrement f, skip if 0 = None. Status Affected:, Decrement f, skip if 0 = . Status Affected:, Decrement f, skip if 0 = . Encoding:, Decrement f, skip if 0 = 0010. Encoding:, Decrement f, skip if 0 = 11da. Encoding:, Decrement f, skip if 0 = ffff. Encoding:, Decrement f, skip if 0 = ffff\nDescription:\nThe contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).",
    "PIC18F1220/1320\nIf the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\n1\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nIf skip:\nQ1\nNo\nQ2\nNo\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE      DECFSZ   CNT\nGOTO     LOOP\nCONTINUE\nBefore Instruction\nPC\n=\nAddress (HERE)\nAfter Instruction\nCNT\n=\nCNT - 1\nIf CNT =\n0;\nPC\n=\nAddress (CONTINUE)\nIf CNT\n\uf0b9\n0;\nPC =\nAddress (HERE + 2)\nQ4\nNo operation\nWords:\nCycles:",
    "Q Cycle Activity:\nSyntax:, DCFSNZ = Syntax:. Syntax:, Decrement f, skip if not 0 = [ label ] DCFSNZ. Syntax:, Decrement f, skip if not 0 = [ label ] DCFSNZ. Syntax:, Decrement f, skip if not 0 = [ label ] DCFSNZ. Syntax:, Decrement f, skip if not 0 = f [,d [,a]]. Syntax:, Decrement f, skip if not 0 = f [,d [,a]]. Operands:, DCFSNZ = Operands:. Operands:, Decrement f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if not 0 = . Operands:, Decrement f, skip if not 0 = . Operation:,",
    "Q Cycle Activity:\nDCFSNZ = Operation:. Operation:, Decrement f, skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, skip if not 0 = . Operation:, Decrement f, skip if not 0 = . Status Affected:, DCFSNZ = Status Affected:. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = . Status Affected:, Decrement f, skip if not 0 = . Encoding:, DCFSNZ = Encoding:. Encoding:, Decrement f, skip if not 0 = 0100. Encoding:, Decrement f, skip if not 0 = 0100. Encoding:, Decrement",
    "Q Cycle Activity:\nf, skip if not 0 = 11da. Encoding:, Decrement f, skip if not 0 = ffff. Encoding:, Decrement f, skip if not 0 = ffff. Description:, DCFSNZ = Description:. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2- cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f'",
    "Q Cycle Activity:\n(default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2- cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2- cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ',",
    "Q Cycle Activity:\nthe result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2- cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2- cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as. Words:, DCFSNZ =",
    "Q Cycle Activity:\nWords:. Words:, Decrement f, skip if not 0 = per the BSR value 1. Words:, Decrement f, skip if not 0 = per the BSR value 1. Words:, Decrement f, skip if not 0 = per the BSR value 1. Words:, Decrement f, skip if not 0 = . Words:, Decrement f, skip if not 0 = . Cycles:, DCFSNZ = Cycles:. Cycles:, Decrement f, skip if not 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, skip if not 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, skip if not 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, skip if not 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, skip if not 0 = 1(2) Note: 3 cycles if skip and followed. Q Cycle Activity:, DCFSNZ = Q Cycle Activity:. Q Cycle Activity:,",
    "Q Cycle Activity:\nDecrement f, skip if not 0 = Q Cycle Activity:. Q Cycle Activity:, Decrement f, skip if not 0 = Q Cycle Activity:. Q Cycle Activity:, Decrement f, skip if not 0 = Q Cycle Activity:. Q Cycle Activity:, Decrement f, skip if not 0 = Q Cycle Activity:. Q Cycle Activity:, Decrement f, skip if not 0 = Q Cycle Activity:. , DCFSNZ = Q1. , Decrement f, skip if not 0 = Q2. , Decrement f, skip if not 0 = Q2. , Decrement f, skip if not 0 = Q3. , Decrement f, skip if not 0 = . , Decrement f, skip if not 0 = Q4. Decode, DCFSNZ = . Decode, Decrement f, skip if not 0 = Read register 'f'. Decode, Decrement f, skip if not 0 = Read register 'f'. Decode, Decrement f, skip if not 0 = Process Data. Decode, Decrement f, skip if not 0 = Process Data. Decode,",
    "Q Cycle Activity:\nDecrement f, skip if not 0 = Write to destination. If skip:, DCFSNZ = If skip:. If skip:, Decrement f, skip if not 0 = If skip:. If skip:, Decrement f, skip if not 0 = If skip:. If skip:, Decrement f, skip if not 0 = If skip:. If skip:, Decrement f, skip if not 0 = If skip:. If skip:, Decrement f, skip if not 0 = If skip:. , DCFSNZ = Q1. , Decrement f, skip if not 0 = Q2. , Decrement f, skip if not 0 = Q2. , Decrement f, skip if not 0 = Q3. , Decrement f, skip if not 0 = Q3. , Decrement f, skip if not 0 = Q4. , DCFSNZ = No. , Decrement f, skip if not 0 = No. , Decrement f, skip if not 0 = No. , Decrement f, skip if not 0 = No. , Decrement f, skip if not 0 =",
    "Q Cycle Activity:\nNo. , Decrement f, skip if not 0 = No. , DCFSNZ = operation. , Decrement f, skip if not 0 = operation. , Decrement f, skip if not 0 = operation. , Decrement f, skip if not 0 = operation. , Decrement f, skip if not 0 = operation. , Decrement f, skip if not 0 = operation. If skip and followed by 2-word instruction:, DCFSNZ = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, skip if not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, skip if not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, skip if not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, skip if not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:,",
    "Q Cycle Activity:\nDecrement f, skip if not 0 = If skip and followed by 2-word instruction:. , DCFSNZ = Q1. , Decrement f, skip if not 0 = Q2. , Decrement f, skip if not 0 = Q2. , Decrement f, skip if not 0 = Q3. , Decrement f, skip if not 0 = Q3. , Decrement f, skip if not 0 = Q4. , DCFSNZ = No operation. , Decrement f, skip if not 0 = No operation. , Decrement f, skip if not 0 = No operation. , Decrement f, skip if not 0 = No operation. , Decrement f, skip if not 0 = No operation. , Decrement f, skip if not 0 = No operation. , DCFSNZ = No operation. , Decrement f, skip if not 0 = No operation. , Decrement f, skip if not 0 = No operation. , Decrement f, skip if not 0 = No operation. , Decrement f, skip if not 0 = No operation. , Decrement f, skip if not 0 =",
    "Q Cycle Activity:\nNo operation. Example:, DCFSNZ = Example:. Example:, Decrement f, skip if not 0 = HERE ZERO NZERO :. Example:, Decrement f, skip if not 0 = HERE ZERO NZERO :. Example:, Decrement f, skip if not 0 = DCFSNZ TEMP :. Example:, Decrement f, skip if not 0 = DCFSNZ TEMP :. Example:, Decrement f, skip if not 0 = . Before Instruction TEMP, DCFSNZ = Before Instruction TEMP. Before Instruction TEMP, Decrement f, skip if not 0 = Before Instruction TEMP. Before Instruction TEMP, Decrement f, skip if not 0 = =. Before Instruction TEMP, Decrement f, skip if not 0 = ?. Before Instruction TEMP, Decrement f, skip if not 0 = ?. Before Instruction TEMP, Decrement f, skip if not 0 = . After Instruction TEMP, DCFSNZ = After Instruction TEMP. After Instruction TEMP, Decrement f, skip if not 0 = After Instruction TEMP. After Instruction TEMP, Decrement f, skip if",
    "Q Cycle Activity:\nnot 0 = =. After Instruction TEMP, Decrement f, skip if not 0 = TEMP - 1,. After Instruction TEMP, Decrement f, skip if not 0 = TEMP - 1,. After Instruction TEMP, Decrement f, skip if not 0 = . If TEMP PC, DCFSNZ = If TEMP PC. If TEMP PC, Decrement f, skip if not 0 = If TEMP PC. If TEMP PC, Decrement f, skip if not 0 = = =. If TEMP PC, Decrement f, skip if not 0 = 0;. If TEMP PC, Decrement f, skip if not 0 = 0;. If TEMP PC, Decrement f, skip if not 0 = . TEMP, DCFSNZ = TEMP. TEMP, Decrement f, skip if not 0 = TEMP. TEMP, Decrement f, skip if not 0 = \uf0b9. TEMP, Decrement f, skip if not 0 = Address (ZERO 0;. TEMP, Decrement f, skip if not 0 = Address (ZERO 0;. TEMP, Decrement",
    "Q Cycle Activity:\nf, skip if not 0 = ). If PC, DCFSNZ = If PC. If PC, Decrement f, skip if not 0 = If PC. If PC, Decrement f, skip if not 0 = =. If PC, Decrement f, skip if not 0 = Address. If PC, Decrement f, skip if not 0 = Address. If PC, Decrement f, skip if not 0 = (NZERO)",
    "Q Cycle Activity:\nSyntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>),",
    "Q Cycle Activity:\nUnconditional Branch = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = 1111 k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = kkkk 0 kkkk 8. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within the entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within the entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within the entire",
    "Q Cycle Activity:\n2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within the entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q1, Unconditional Branch = Q2. Q1, Unconditional Branch =",
    "Q Cycle Activity:\nQ3. Q1, Unconditional Branch = . Q1, Unconditional Branch = Q4. Decode, Unconditional Branch = Read literal 'k'<7:0>,. Decode, Unconditional Branch = No operation. Decode, Unconditional Branch = Read literal 'k'<19:8>, Write to PC. Decode, Unconditional Branch = Read literal 'k'<19:8>, Write to PC. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation\nExample:\nGOTO THERE\nAfter Instruction\nPC = Address (THERE)",
    "PIC18F1220/1320\nINCF, 1 = INCF. INCF, 2 = Increment f. INCF, 3 = Increment f. INCF, 4 = Increment f. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] INCF. Syntax:, 3 = [ label ] INCF. Syntax:, 4 = f [,d [,a]]. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 3 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, 4 = . Operation:, 1 = Operation:. Operation:, 2 = (f) + 1 \uf0ae dest. Operation:, 3 = (f) + 1 \uf0ae dest. Operation:, 4 = . Status Affected:, 1 = Status Affected:. Status Affected:, 2 = C, DC, N, OV, Z. Status Affected:, 3 = C, DC, N, OV, Z. Status Affected:, 4 = . Encoding:, 1 = Encoding:. Encoding:, 2 =",
    "PIC18F1220/1320\n0010. Encoding:, 3 = 10da. Encoding:, 4 = ffff. Description:, 1 = Description:. Description:, 2 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 3 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 4 = The contents of register 'f' are",
    "PIC18F1220/1320\nincremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = . Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = . Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read register 'f'. , 3 = Process Data. , 4 = ",
    "Example:\nINCF\nCNT\nBefore Instruction\nCNT\n=\n0xFF\nZ\n=\n0\nC\n=\n?\nDC\n=\n?\nAfter Instruction\nCNT\n=\n0x00\nZ\n=\n1\nC\n=\n1\nDC\n=\n1",
    "PIC18F1220/1320\nINCFSZ\nIncrement f, skip if 0\nSyntax:\n[\nlabel\n]    INCFSZ    f [,d [,a]]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n(f) + 1 \uf0ae dest,\nskip if result = 0\nStatus Affected:\nNone\nEncoding:\n0011\n11da\nffff\nffff\nDescription:\nThe contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).\nIf the result is ' 0 ', the next instruc- tion, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruc- tion. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote: 3 cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:",
    "PIC18F1220/1320\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nIf skip:\nQ1\nNo\nQ2\nNo\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE    INCFSZ   CNT\nNZERO   :\nZERO    :\nBefore Instruction\nPC\n=\nAddress (HERE)\nAfter Instruction\nCNT\n=\nCNT + 1\nIf CNT\n=\n0;\nPC\n=\nAddress (ZERO)\nIf CNT\n\uf0b9\n0;\nPC\n=\nAddress (NZERO)\nQ4\nNo operation\nQ4\nINFSNZ\nIncrement f, skip if not 0\nSyntax:\n[\nlabel\n]    INFSNZ    f [,d [,a]]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce [0,1]\na \uf0ce [0,1]\nOperation:\n(f) + 1 \uf0ae dest,\nskip if result \uf0b9 0\nStatus Affected:\nNone\nEncoding:\n0100\n10da\nffff\nffff\nDescription:",
    "PIC18F1220/1320\nThe contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).\nIf the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2- cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode\nQ1\nNo\nQ2\nQ3\nQ4\nRead register 'f'\nQ2\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE    INFSNZ REG\nZERO\nNZERO\nBefore Instruction\nPC\n=\nAddress (HERE)\nAfter Instruction\nREG\n=\nREG + 1\nIf REG\n\uf0b9\n0;\nPC\n=\nAddress (NZERO)\nIf REG\n=\n0;\nPC\n=\nAddress (ZERO)\nWrite to destination\nQ4\nNo operation\nQ4\nIf skip:",
    "Inclusive OR literal with W\nSyntax:\n[ label ]    IORLW   k\nOperands:\n0 \uf0a3 k \uf0a3 255\nOperation:\n(W) .OR. k \uf0ae W\nStatus Affected:\nN, Z\nEncoding:\n0000\n1001\nkkkk\nkkkk\nDescription:\nThe contents of W are OR'ed with the 8-bit literal 'k'. The result is placed in W.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral 'k'\nProcess Data\nWrite to W\nExample:\nIORLW\n0x35\nBefore Instruction\nW\n=\n0x9A\nAfter Instruction\nW\n= 0xBF",
    "PIC18F1220/1320\nSyntax:, IORWF = Syntax:. Syntax:, Inclusive OR Wwith f = [ label ] IORWF. Syntax:, Inclusive OR Wwith f = [ label ] IORWF. Syntax:, Inclusive OR Wwith f = f [,d [,a]]. Operands:, IORWF = Operands:. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Inclusive OR Wwith f = . Operation:, IORWF = Operation:. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Status Affected:, IORWF = Status Affected:. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR",
    "PIC18F1220/1320\nWwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Encoding:, IORWF = Encoding:. Encoding:, Inclusive OR Wwith f = 0001. Encoding:, Inclusive OR Wwith f = 00da. Encoding:, Inclusive OR Wwith f = ffff. Description:, IORWF = Description:. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is '",
    "PIC18F1220/1320\n0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, IORWF = Words:. Words:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Cycles:, IORWF = Cycles:. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Q Cycle Activity:, IORWF = Q Cycle",
    "PIC18F1220/1320\nActivity:. Q Cycle Activity:, Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Wwith f = Q Cycle Activity:. , IORWF = Q1. , Inclusive OR Wwith f = Q2. , Inclusive OR Wwith f = Q3. , Inclusive OR Wwith f = Q3. , IORWF = Decode. , Inclusive OR Wwith f = Read register 'f'. , Inclusive OR Wwith f = Process. , Inclusive OR Wwith f = Process",
    "Example:\nIORWF RESULT, W\nBefore Instruction\nRESULT =\n0x13\nW\n=\n0x91\nAfter Instruction\nRESULT =\n0x13\nW\n=\n0x93",
    "PIC18F1220/1320\nSyntax:, Load FSR = [ label ]. Syntax:, Load FSR = LFSR. Syntax:, Load FSR = f,k. Syntax:, Load FSR = . Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operands:, Load FSR = 0 \uf0a3 f \uf0a3 2 0 \uf0a3 k \uf0a3 4095. Operation:, Load FSR = k \uf0ae FSRf. Operation:, Load FSR = k \uf0ae FSRf. Operation:, Load FSR = k \uf0ae FSRf. Operation:, Load FSR = k \uf0ae FSRf. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Encoding:, Load FSR = 1110 1111. Encoding:, Load FSR = 1110 0000. Encoding:, Load FSR = 00ff k 7 kkk. Encoding:, Load FSR = k 11 kkk",
    "PIC18F1220/1320\nkkkk. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.. Words:, Load FSR = 2. Words:, Load FSR = 2. Words:, Load FSR = 2. Words:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q Cycle Activity:, Load FSR = Q",
    "PIC18F1220/1320\nCycle Activity:. Q1, Load FSR = Q2. Q1, Load FSR = Q3. Q1, Load FSR = . Q1, Load FSR = Q4. Decode, Load FSR = Read literal 'k' MSB. Decode, Load FSR = Process Data. Decode, Load FSR = Process Data. Decode, Load FSR = Write literal 'k' MSB to FSRfH. Decode, Load FSR = Read literal 'k' LSB. Decode, Load FSR = Process Data. Decode, Load FSR = Process Data. Decode, Load FSR = Write literal 'k' to FSRfL",
    "Example:\nLFSR 2, 0x3AB\nAfter Instruction\nFSR2H\n=\n0x03\nFSR2L\n=\n0xAB",
    "Example:\nSyntax:, Move f = [ label ]. Syntax:, Move f = MOVF. Syntax:, Move f = f [,d [,a]]. Syntax:, Move f = . Operands:, Move f = 0 \uf0a3 f \uf0a3 255. Operands:, Move f = . Operands:, Move f = . Operands:, Move f = . , Move f = d \uf0ce [0,1]. , Move f = . , Move f = . , Move f = . , Move f = a \uf0ce [0,1]. , Move f = . , Move f = . , Move f = . Operation:, Move f = f \uf0ae dest. Operation:, Move f = . Operation:, Move f = . Operation:, Move f = . Status Affected:, Move f = N, Z. Status Affected:, Move f = . Status Affected:, Move f = . Status Affected:, Move f = . Encoding:, Move f = 0101. Encoding:, Move f = 00da. Encoding:, Move f = ffff. Encoding:, Move f = ffff\nDescription:",
    "Example:\nThe contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is 'f', the result is placed in W. If 'd' is 'f', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write W",
    "Example:\nBefore Instruction, MOVF = . Before Instruction, REG, = . REG, MOVF = =. REG, REG, = 0x22. W, MOVF = =. W, REG, = 0xFF. After Instruction, MOVF = . After Instruction, REG, = . REG, MOVF = =. REG, REG, = 0x22. W, MOVF = =. W, REG, = 0x22",
    "Example:\nSyntax:, Move f to f = [ label ] MOVFF f s ,f d. Syntax:, Move f to f = [ label ] MOVFF f s ,f d. Syntax:, Move f to f = [ label ] MOVFF f s ,f d. Syntax:, Move f to f = [ label ] MOVFF f s ,f d. Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operation:, Move f to f = (f s ) \uf0ae f d. Operation:, Move f to f = (f s ) \uf0ae f d. Operation:, Move f to f = (f s ) \uf0ae f d. Operation:, Move f to f = (f s ) \uf0ae f d. Status Affected:, Move f to f = None. Status Affected:, Move f to f = None. Status Affected:,",
    "Example:\nMove f to f = None. Status Affected:, Move f to f = None. Encoding: 1st word (source), Move f to f = 1100. Encoding: 1st word (source), Move f to f = ffff. Encoding: 1st word (source), Move f to f = ffff. Encoding: 1st word (source), Move f to f = ffff s. 2nd word (destin.), Move f to f = 1111. 2nd word (destin.), Move f to f = ffff. 2nd word (destin.), Move f to f = ffff. 2nd word (destin.), Move f to f = ffff d\nDescription:\nThe contents of source register 'f '",
    "Example:\ns are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W (a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port).\nThe MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.\nThe MOVFF instruction should not be used to modify interrupt settings while any interrupt is enabled (see page 70).\nWords:\n2\nCycles:\n2 (3)\nQ Cycle Activity:\nQ1\nQ2\nQ3\nDecode, 1 = Read register 'f' (src). Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f' (dest)\nExample:\nMOVFF   REG1, REG2\nBefore Instruction\nREG1\n= 0x33\nREG2\n=",
    "Example:\n0x11\nAfter Instruction\nREG1\n= 0x33,\nREG2\n=\n0x33\nQ4",
    "PIC18F1220/1320\nSyntax:, Move literal to low nibble in BSR = [ label ] MOVLB. Syntax:, Move literal to low nibble in BSR = [ label ] MOVLB. Syntax:, Move literal to low nibble in BSR = [ label ] MOVLB. Syntax:, Move literal to low nibble in BSR = k. Syntax:, Move literal to low nibble in BSR = k. Operands:, Move literal to low nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to low nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to low nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to low nibble in BSR = . Operands:, Move literal to low nibble in BSR = . Operation:, Move literal to low nibble in BSR = k \uf0ae BSR. Operation:, Move literal to low nibble in BSR = k \uf0ae BSR. Operation:, Move literal to low nibble in BSR = k \uf0ae BSR. Operation:, Move literal to low nibble in BSR = . Operation:, Move literal to low nibble",
    "PIC18F1220/1320\nin BSR = . Status Affected:, Move literal to low nibble in BSR = None. Status Affected:, Move literal to low nibble in BSR = None. Status Affected:, Move literal to low nibble in BSR = None. Status Affected:, Move literal to low nibble in BSR = . Status Affected:, Move literal to low nibble in BSR = . Encoding:, Move literal to low nibble in BSR = 0000. Encoding:, Move literal to low nibble in BSR = 0001. Encoding:, Move literal to low nibble in BSR = kkkk. Encoding:, Move literal to low nibble in BSR = kkkk. Encoding:, Move literal to low nibble in BSR = kkkk. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The",
    "PIC18F1220/1320\n8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Words:, Move literal to low nibble in BSR = 1. Words:, Move literal to low nibble in BSR = 1. Words:, Move literal to low nibble in BSR = 1. Words:, Move literal to low nibble in BSR = 1. Words:, Move literal to low nibble in BSR = 1. Cycles:, Move literal to low nibble in BSR = 1. Cycles:, Move literal to low nibble in BSR = 1. Cycles:, Move literal to low nibble in BSR = 1. Cycles:, Move literal to low nibble in BSR = 1. Cycles:, Move literal to low nibble in BSR = 1. Q Cycle Activity:, Move literal to low",
    "PIC18F1220/1320\nnibble in BSR = Q Cycle Activity:. Q Cycle Activity:, Move literal to low nibble in BSR = Q Cycle Activity:. Q Cycle Activity:, Move literal to low nibble in BSR = Q Cycle Activity:. Q Cycle Activity:, Move literal to low nibble in BSR = Q Cycle Activity:. Q Cycle Activity:, Move literal to low nibble in BSR = Q Cycle Activity:. Q1, Move literal to low nibble in BSR = Q2 Q3. Q1, Move literal to low nibble in BSR = Q2 Q3. Q1, Move literal to low nibble in BSR = Q2 Q3. Q1, Move literal to low nibble in BSR = Q4. Q1, Move literal to low nibble in BSR = Q4. Decode, Move literal to low nibble in BSR = Read literal 'k' Process Data. Decode, Move literal to low nibble in BSR = Read literal 'k' Process Data. Decode, Move literal to low nibble in BSR = Read literal 'k' Process Data. Decode, Move literal to low",
    "PIC18F1220/1320\nnibble in BSR = Write literal 'k' to BSR. Decode, Move literal to low nibble in BSR = Write literal 'k' to BSR. Example:, Move literal to low nibble in BSR = MOVLB. Example:, Move literal to low nibble in BSR = 5. Example:, Move literal to low nibble in BSR = . Example:, Move literal to low nibble in BSR = . Example:, Move literal to low nibble in BSR = . Before Instruction BSR register, Move literal to low nibble in BSR = =. Before Instruction BSR register, Move literal to low nibble in BSR = 0x02. Before Instruction BSR register, Move literal to low nibble in BSR = . Before Instruction BSR register, Move literal to low nibble in BSR = . Before Instruction BSR register, Move literal to low nibble in BSR = . After Instruction BSR register, Move literal to low nibble in BSR = =. After Instruction BSR register, Move literal to low nibble in BSR = 0x05. After Instruction BSR register, Move literal",
    "PIC18F1220/1320\nto low nibble in BSR = . After Instruction BSR register, Move literal to low nibble in BSR = . After Instruction BSR register, Move literal to low nibble in BSR = ",
    "PIC18F1220/1320\nSyntax:, Move literal to W = [ label ]. Syntax:, Move literal to W = MOVLW. Syntax:, Move literal to W = k. Syntax:, Move literal to W = . Operands:, Move literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to W = . Operands:, Move literal to W = . Operation:, Move literal to W = k \uf0ae W. Operation:, Move literal to W = . Operation:, Move literal to W = . Operation:, Move literal to W = . Status Affected:, Move literal to W = None. Status Affected:, Move literal to W = . Status Affected:, Move literal to W = . Status Affected:, Move literal to W = . Encoding:, Move literal to W = 0000. Encoding:, Move literal to W = 1110. Encoding:, Move literal to W = kkkk. Encoding:, Move literal to W = kkkk. Description:, Move literal to W = The 8-bit literal 'k' is loaded into W.. Description:, Move literal to W = The",
    "PIC18F1220/1320\n8-bit literal 'k' is loaded into W.. Description:, Move literal to W = The 8-bit literal 'k' is loaded into W.. Description:, Move literal to W = The 8-bit literal 'k' is loaded into W.. Words:, Move literal to W = 1. Words:, Move literal to W = . Words:, Move literal to W = . Words:, Move literal to W = . Cycles:, Move literal to W = 1. Cycles:, Move literal to W = . Cycles:, Move literal to W = . Cycles:, Move literal to W = . Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q Cycle Activity:, Move literal to W = . Q Cycle Activity:, Move literal to W = . Q Cycle Activity:, Move literal to W = . Q1, Move literal to W = Q2. Q1, Move literal to W = Q3. Q1, Move literal to W = . Q1, Move literal to W = Q4. Decode, Move literal to W = Read literal 'k'. Decode, Move literal to W = Process Data.",
    "PIC18F1220/1320\nDecode, Move literal to W = . Decode, Move literal to W = Write to W. Example:, Move literal to W = MOVLW. Example:, Move literal to W = 0x5A. Example:, Move literal to W = . Example:, Move literal to W = . After Instruction, Move literal to W = After Instruction. After Instruction, Move literal to W = . After Instruction, Move literal to W = . After Instruction, Move literal to W = ",
    "PIC18F1220/1320\nSyntax:, MOVWF = Syntax:. Syntax:, Move Wto f = [ label ] MOVWF f. Syntax:, Move Wto f = [ label ] MOVWF f. Syntax:, Move Wto f = [ label ] MOVWF f. Syntax:, Move Wto f = [,a]. Operands:, MOVWF = Operands:. Operands:, Move Wto f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Move Wto f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Move Wto f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Move Wto f = . Operation:, MOVWF = Operation:. Operation:, Move Wto f = (W) \uf0ae f. Operation:, Move Wto f = (W) \uf0ae f. Operation:, Move Wto f = (W) \uf0ae f. Operation:, Move Wto f = (W) \uf0ae f. Status Affected:, MOVWF = Status Affected:. Status Affected:, Move Wto f = None. Status Affected:, Move",
    "PIC18F1220/1320\nWto f = None. Status Affected:, Move Wto f = None. Status Affected:, Move Wto f = None. Encoding:, MOVWF = Encoding:. Encoding:, Move Wto f = 0110. Encoding:, Move Wto f = 111a. Encoding:, Move Wto f = ffff. Encoding:, Move Wto f = ffff. Description:, MOVWF = Description:. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR",
    "PIC18F1220/1320\nvalue (default).. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, MOVWF = Words:. Words:, Move Wto f = 1. Words:, Move Wto f = 1. Words:, Move Wto f = 1. Words:, Move Wto f = 1. Cycles:, MOVWF = Cycles:. Cycles:, Move Wto f = 1. Cycles:, Move Wto f = 1.",
    "PIC18F1220/1320\nCycles:, Move Wto f = 1. Cycles:, Move Wto f = 1. Q Cycle Activity:, MOVWF = Q Cycle Activity:. Q Cycle Activity:, Move Wto f = Q Cycle Activity:. Q Cycle Activity:, Move Wto f = Q Cycle Activity:. Q Cycle Activity:, Move Wto f = Q Cycle Activity:. Q Cycle Activity:, Move Wto f = Q Cycle Activity:. Q1, MOVWF = . Q1, Move Wto f = Q2. Q1, Move Wto f = Q3. Q1, Move Wto f = . Q1, Move Wto f = Q4. , MOVWF = Decode. , Move Wto f = Read register 'f'. , Move Wto f = Process Data. , Move Wto f = . , Move Wto f = Write register 'f'",
    "Example:\nMOVWF\nREG\nBefore Instruction\nW\n=\n0x4F\nREG\n=\n0xFF\nAfter Instruction\nW\n=\n0x4F\nREG\n=\n0x4F",
    "Example:\nSyntax:, Multiply Literal with W = [ label ] MULLW. Syntax:, Multiply Literal with W = [ label ] MULLW. Syntax:, Multiply Literal with W = k. Syntax:, Multiply Literal with W = k. Operands:, Multiply Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Multiply Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Multiply Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Multiply Literal with W = 0 \uf0a3 k \uf0a3 255. Operation:, Multiply Literal with W = (W) x k \uf0ae PRODH:PRODL. Operation:, Multiply Literal with W = (W) x k \uf0ae PRODH:PRODL. Operation:, Multiply Literal with W = (W) x k \uf0ae PRODH:PRODL. Operation:, Multiply Literal with W = (W) x k \uf0ae PRODH:PRODL. Status Affected:, Multiply Literal with W = None. Status Affected:, Multiply Literal with W = None. Status Affected:, Multiply Literal with W = None. Status Affected:, Multiply Literal with W = None. Encoding:, Multiply Literal with W = 0000. Encoding:,",
    "Example:\nMultiply Literal with W = 1101. Encoding:, Multiply Literal with W = kkkk. Encoding:, Multiply Literal with W = kkkk. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this opera- tion. A Zero result is possible but. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this opera- tion. A Zero result is possible but. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL",
    "Example:\nregister pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this opera- tion. A Zero result is possible but. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this opera- tion. A Zero result is possible but. Words:, Multiply Literal with W = 1. Words:, Multiply Literal with W = 1. Words:, Multiply Literal with W = 1. Words:, Multiply Literal with W = 1. Cycles:, Multiply Literal with W = 1. Cycles:, Multiply Literal with W = 1. Cycles:, Multiply Literal with W = 1. Cycles:, Multiply Literal with W = 1. Q Cycle Activity: Q1, Multiply Literal with W = Q2. Q Cycle Activity: Q1, Multiply Literal with W = Q3. Q",
    "Example:\nCycle Activity: Q1, Multiply Literal with W = Q3. Q Cycle Activity: Q1, Multiply Literal with W = Q4. Decode, Multiply Literal with W = Read literal 'k'. Decode, Multiply Literal with W = Process Data. Decode, Multiply Literal with W = Process Data. Decode, Multiply Literal with W = Write registers PRODH: PRODL\nMULLW   0xC4\nBefore Instruction\nW\n=\n0xE2\nPRODH\n=\n?\nPRODL\n=\n?\nAfter Instruction\nW\n=\n0xE2\nPRODH\n=\n0xAD\nPRODL\n=\n0x08",
    "PIC18F1220/1320\nMULWF, 1 = MULWF. MULWF, 2 = Multiply Wwith f. MULWF, 3 = Multiply Wwith f. MULWF, 4 = Multiply Wwith f. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ]. Syntax:, 3 = MULWF. Syntax:, 4 = f [,a]. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, 3 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, 4 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, 1 = Operation:. Operation:, 2 = (W) x (f) \uf0ae PRODH:PRODL. Operation:, 3 = (W) x (f) \uf0ae PRODH:PRODL. Operation:, 4 = (W) x (f) \uf0ae PRODH:PRODL. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 =",
    "PIC18F1220/1320\nEncoding:. Encoding:, 2 = 0000. Encoding:, 3 = 001a. Encoding:, 4 = ffff. Description:, 1 = Description:. Description:, 2 = An unsigned multiplication is carried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this opera- tion. A Zero result is possible, but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, 3 = An unsigned multiplication is carried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this opera- tion. A Zero result is possible, but",
    "PIC18F1220/1320\nnot detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, 4 = An unsigned multiplication is carried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this opera- tion. A Zero result is possible, but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q",
    "PIC18F1220/1320\nCycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read register 'f'. , 3 = Process Data. , 4 = ",
    "Example:\nMULWF   REG\nBefore Instruction\nW\n=\n0xC4\nREG\n=\n0xB5\nPRODH\n=\n?\nPRODL\n=\n?\nAfter Instruction\nW\n=\n0xC4\nREG\n=\n0xB5\nPRODH\n=\n0x8A\nPRODL\n=\n0x94",
    "PIC18F1220/1320\nSyntax:, NEGF = Syntax:. Syntax:, Negate f = [ label ]. Syntax:, Negate f = NEGF. Syntax:, Negate f = f [,a]. Operands:, NEGF = Operands:. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, NEGF = Operation:. Operation:, Negate f = (f) + 1 \uf0ae f. Operation:, Negate f = (f) + 1 \uf0ae f. Operation:, Negate f = (f) + 1 \uf0ae f. Status Affected:, NEGF = Status Affected:. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Encoding:, NEGF = Encoding:. Encoding:, Negate f = 0110.",
    "PIC18F1220/1320\nEncoding:, Negate f = 110a. Encoding:, Negate f = ffff. Description:, NEGF = Description:. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1 , then the",
    "PIC18F1220/1320\nbank will be selected as per the BSR value.. Words:, NEGF = Words:. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = 1. Cycles:, NEGF = Cycles:. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Q Cycle Activity:, NEGF = Q Cycle Activity:. Q Cycle Activity:, Negate f = . Q Cycle Activity:, Negate f = . Q Cycle Activity:, Negate f = . , NEGF = Q1. , Negate f = Q2. , Negate f = Q3. , Negate f = . , NEGF = Decode. , Negate f = Read register 'f'. , Negate f = Process Data. , Negate f = \nExample:\nNEGF REG, 1\nBefore Instruction\nREG\n=\n0011 1010 [0x3A]\nAfter Instruction\nREG\n=\n1100 0110 [0xC6]",
    "PIC18F1220/1320\nSyntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Encoding:, No Operation = 0000 1111. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Words:, No Operation = 1.",
    "PIC18F1220/1320\nWords:, No Operation = 1. Words:, No Operation = 1. Words:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Q Cycle Activity:, No Operation = Q Cycle Activity:. Q Cycle Activity:, No Operation = Q Cycle Activity:. Q Cycle Activity:, No Operation = Q Cycle Activity:. Q Cycle Activity:, No Operation = Q Cycle Activity:. Q1, No Operation = Q2. Q1, No Operation = Q3. Q1, No Operation = . Q1, No Operation = Q4. Decode, No Operation = No operation. Decode, No Operation = No operation. Decode, No Operation = . Decode, No Operation = No operation\nExample:\nNone.",
    "PIC18F1220/1320\nSyntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack",
    "PIC18F1220/1320\n= 0000. Encoding:, Pop Top of Return Stack = 0110. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to",
    "PIC18F1220/1320\nproperly manage the return stack to incorporate a software stack.. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q1, Pop Top of Return Stack = Q2. Q1, Pop Top of Return Stack = Q3. Q1, Pop Top of Return Stack = . Q1, Pop Top of Return Stack = Q4. Decode, Pop Top of Return Stack = No operation. Decode, Pop Top of Return Stack = Pop. Decode, Pop Top of Return Stack = TOS value. Decode, Pop Top of Return Stack = No operation. Example:, Pop Top of",
    "PIC18F1220/1320\nReturn Stack = POP. Example:, Pop Top of Return Stack = . Example:, Pop Top of Return Stack = . Example:, Pop Top of Return Stack = . , Pop Top of Return Stack = GOTO. , Pop Top of Return Stack = NEW. , Pop Top of Return Stack = . , Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = Before Instruction. Before Instruction, Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = =. TOS, Pop Top of Return Stack = 0x0031A2. TOS, Pop Top of Return Stack = . Stack (1 level down), Pop Top of Return Stack = Stack (1 level down). Stack (1 level down), Pop Top of Return Stack = =. Stack (1 level down), Pop Top of Return Stack = 0x014332. Stack (1 level down), Pop Top of Return Stack = . After Instruction, Pop Top of Return Stack = After Instruction. After Instruction, Pop Top of Return Stack =",
    "PIC18F1220/1320\n. After Instruction, Pop Top of Return Stack = . After Instruction, Pop Top of Return Stack = . TOS PC, Pop Top of Return Stack = . TOS PC, Pop Top of Return Stack = =. TOS PC, Pop Top of Return Stack = 0x014332 NEW. TOS PC, Pop Top of Return Stack = . , Pop Top of Return Stack = . , Pop Top of Return Stack = =. , Pop Top of Return Stack = . , Pop Top of Return Stack = ",
    "Push Top of Return Stack\nSyntax:, 1 = Syntax:. Syntax:, 2 = [ label ] PUSH. Syntax:, 3 = [ label ] PUSH. Syntax:, 4 = [ label ] PUSH. Operands:, 1 = Operands:. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = Operation:. Operation:, 2 = (PC + 2) \uf0ae TOS. Operation:, 3 = (PC + 2) \uf0ae TOS. Operation:, 4 = (PC + 2) \uf0ae TOS. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Encoding:, 4 = 0000. Description:, 1 = Description:. Description:, 2 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implement- ing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, 3",
    "Push Top of Return Stack\n= The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implement- ing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, 4 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implement- ing a software stack by modifying TOS and then pushing it onto the return stack.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Push PC + 2 onto return stack. , 3",
    "Push Top of Return Stack\n= No operation. , 4 = No operation",
    "Example:\nPUSH\nBefore Instruction\nTOS PC\n=\n0x00345A\n= 0x000124\nAfter Instruction\nPC TOS Stack (1 level down)\n=\n0x000126\n=\n0x000126\n=\n0x00345A",
    "PIC18F1220/1320\nSyntax:, Relative Call = [ label ] RCALL. Syntax:, Relative Call = [ label ] RCALL. Syntax:, Relative Call = n. Syntax:, Relative Call = . Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = . Operands:, Relative Call = . Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae. Operation:, Relative Call = PC. Operation:, Relative Call = . Status Affected:, Relative Call = None. Status Affected:, Relative Call = . Status Affected:, Relative Call = . Status Affected:, Relative Call = . Encoding:, Relative Call = 1101. Encoding:, Relative Call = 1nnn. Encoding:, Relative Call = nnnn. Encoding:, Relative Call = nnnn\nDescription:",
    "PIC18F1220/1320\nSubroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a 2-cycle instruction.\nWords:\nCycles:\n1\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'n' Push PC to stack. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE\nRCALL Jump\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nAfter Instruction\nPC\n=\nAddress\n(Jump)\nTOS =\nAddress\n(HERE + 2)",
    "PIC18F1220/1320\nSyntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Encoding:, Reset = 0000. Encoding:, Reset = 0000. Encoding:, Reset = 1111. Encoding:, Reset = 1111. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute",
    "PIC18F1220/1320\na MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q1, Reset = Q2. Q1, Reset = Q3. Q1, Reset = Q3. Q1, Reset = Q4. Decode, Reset = Start Reset. Decode, Reset = No operation. Decode, Reset = No operation. Decode, Reset = No operation. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset = RESET. After Instruction, Reset",
    "PIC18F1220/1320\n= After Instruction. After Instruction, Reset = After Instruction. After Instruction, Reset = After Instruction. After Instruction, Reset = After Instruction. Registers = Flags* =, Reset = Registers = Flags* =. Registers = Flags* =, Reset = Reset Value Reset Value. Registers = Flags* =, Reset = Reset Value Reset Value. Registers = Flags* =, Reset = Reset Value Reset Value",
    "PIC18F1220/1320\nSyntax:, Return from Interrupt = [ label ] RETFIE [s]. Syntax:, Return from Interrupt = [ label ] RETFIE [s]. Syntax:, Return from Interrupt = [ label ] RETFIE [s]. Syntax:, Return from Interrupt = [ label ] RETFIE [s]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae Status, (BSRS) \uf0ae BSR,. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae Status, (BSRS) \uf0ae BSR,. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae GIE/GIEH or",
    "PIC18F1220/1320\nPEIE/GIEL, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae Status, (BSRS) \uf0ae BSR,. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae Status, (BSRS) \uf0ae BSR,. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0001. Encoding:, Return from Interrupt = 000s. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority Global Interrupt",
    "PIC18F1220/1320\nEnable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's'",
    "PIC18F1220/1320\n= 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q1, Return",
    "PIC18F1220/1320\nfrom Interrupt = Q2. Q1, Return from Interrupt = Q3. Q1, Return from Interrupt = . Q1, Return from Interrupt = Q4. Decode, Return from Interrupt = No operation. Decode, Return from Interrupt = . Decode, Return from Interrupt = No operation. Decode, Return from Interrupt = Pop PC from stack Set GIEH or GIEL. No operation, Return from Interrupt = . No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation\nExample:\nRETFIE  1\nAfter Interrupt\nPC\n=\nTOS\nW\n=\nWS\nBSR\n=\nBSRS\nStatus\n=\nSTATUSS\nGIE/GIEH, PEIE/GIEL\n=\n1",
    "PIC18F1220/1320\nSyntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Status",
    "PIC18F1220/1320\nAffected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Encoding:, Return Literal to W = 0000. Encoding:, Return Literal to W = 1100. Encoding:, Return Literal to W = kkkk. Encoding:, Return Literal to W = kkkk. Description:, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The program counter is loaded from the top",
    "PIC18F1220/1320\nof the stack (the return address). The high address latch (PCLATH) remains unchanged.. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q1, Return Literal to W = Q2. Q1, Return Literal to W = Q3. Q1, Return Literal to W = . Q1, Return Literal to W = Q4. Decode, Return Literal to W = Read literal 'k'. Decode, Return Literal to W = Process Data. Decode, Return Literal to W = Process Data. Decode, Return Literal to W =",
    "PIC18F1220/1320\nPop PC from stack, Write to W. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation",
    "Example:\nCALL TABLE\n; W contains table\n; offset value\n; W now has\n; table value\n:",
    "TABLE\nADDWF PCL\n; W = offset\nRETLW k0\n; Begin table\nRETLW k1\n;\n:\n:\nRETLW kn\n; End of table\nBefore Instruction\nW\n=\n0x07\nAfter Instruction\nW\n=\nvalue of kn",
    "PIC18F1220/1320\nRETURN",
    "Return from Subroutine\nSyntax:\n[\nlabel\n]    RETURN   [s]\nOperands:\ns \uf0ce [0,1]\nOperation:\n(TOS) \uf0ae PC,\nif s = 1\n(WS) \uf0ae W,\n(STATUSS)\n\uf0ae\nStatus,\n(BSRS)\n\uf0ae\nBSR,\nPCLATU, PCLATH are unchanged\nStatus Affected:\nNone\nEncoding:\n0000\n0000\n0001\n001s\nDescription:\nReturn from subroutine. The stack is popped and the top of the stack is loaded into the program counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corre- sponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nNo\noperation\nProcess Data\nPop PC from stack\nNo operation\nNo operation\nNo\noperation\nNo operation\nExample:\nRETURN\nAfter Interrupt\nPC = TOS",
    "Return from Subroutine\nSyntax:, Rotate Left f through Carry = [ label ] RLCF. Syntax:, Rotate Left f through Carry = [ label ] RLCF. Syntax:, Rotate Left f through Carry = [ label ] RLCF. Syntax:, Rotate Left f through Carry = f [,d [,a]]. Syntax:, Rotate Left f through Carry = f [,d [,a]]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Rotate Left f through Carry = . Operands:, Rotate Left f through Carry = . Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:,",
    "Return from Subroutine\nRotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = . Status Affected:, Rotate Left f through Carry = . Encoding:, Rotate Left f through Carry = 0011. Encoding:, Rotate Left f through Carry = 01da. Encoding:, Rotate Left f through Carry = 01da. Encoding:, Rotate Left f through Carry = ffff. Encoding:, Rotate Left f through Carry = ffff. Description:, Rotate",
    "Return from Subroutine\nLeft f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry",
    "Return from Subroutine\nflag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is",
    "Return from Subroutine\n' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Q Cycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = . Decode, Rotate Left f",
    "Return from Subroutine\nthrough Carry = . Decode, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = . , Rotate Left f through Carry = Q2. , Rotate Left f through Carry = . , Rotate Left f through Carry = Q3. , Rotate Left f through Carry = Q3. , Rotate Left f through Carry = Q4. , Rotate Left f through Carry = Read register 'f'. , Rotate Left f through Carry = Read register 'f'. , Rotate Left f through Carry = Process Data. , Rotate Left f through Carry = Process Data. , Rotate Left f through Carry = Write to destination. Before Instruction, Rotate Left f through Carry = Before Instruction. Before Instruction, Rotate Left f through Carry = Before Instruction. Before Instruction, Rotate Left f through Carry = Before Instruction. Before Instruction, Rotate Left f through Carry = Before Instruction. Before Instruction, Rotate Left f through Carry = Before Instruction. Example:, Rotate Left f through Carry = RLCF 1110 0. Example:, Rotate Left f through Carry = 0110. Example:, Rotate Left f through Carry = . Example:, Rotate",
    "Return from Subroutine\nLeft f through Carry = W. Example:, Rotate Left f through Carry = . REG C =, Rotate Left f through Carry = =. REG C =, Rotate Left f through Carry = . REG C =, Rotate Left f through Carry = . REG C =, Rotate Left f through Carry = . REG C =, Rotate Left f through Carry = . After Instruction, Rotate Left f through Carry = After Instruction. After Instruction, Rotate Left f through Carry = After Instruction. After Instruction, Rotate Left f through Carry = After Instruction. After Instruction, Rotate Left f through Carry = After Instruction. After Instruction, Rotate Left f through Carry = After Instruction. REG, Rotate Left f through Carry = = 1110 =. REG, Rotate Left f through Carry = 0110. REG, Rotate Left f through Carry = . REG, Rotate Left f through Carry = . REG, Rotate Left f through Carry = . W C, Rotate Left f through Carry = 1100 = 1. W C, Rotate Left f through Carry = 1100. W C, Rotate Left f through Carry = . W C, Rotate Left f through Carry = . W C, Rotate Left f through Carry = ",
    "Return from Subroutine\nSyntax:, Rotate Left f (no carry) = [ label ]. Syntax:, Rotate Left f (no carry) = RLNCF. Syntax:, Rotate Left f (no carry) = f [,d [,a]]. Syntax:, Rotate Left f (no carry) = f [,d [,a]]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae dest<n + 1>,",
    "Return from Subroutine\n(f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Status Affected:, Rotate Left f (no carry) = N, Z. Status Affected:, Rotate Left f (no carry) = N, Z. Status Affected:, Rotate Left f (no carry) = N, Z. Status Affected:, Rotate Left f (no carry) = N, Z. Encoding:, Rotate Left f (no carry) = 0100. Encoding:, Rotate Left f (no carry) = 01da. Encoding:, Rotate Left f (no carry) = ffff. Encoding:, Rotate Left f (no carry) = ffff. Description:, Rotate Left f (no carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If",
    "Return from Subroutine\n'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f (no carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f (no carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If",
    "Return from Subroutine\n'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f (no carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Rotate Left f (no carry) = 1. Words:, Rotate Left f (no carry) = 1. Words:, Rotate Left f (no carry) = 1. Words:, Rotate Left f (no carry) = 1. Cycles:, Rotate Left f (no carry) = 1. Cycles:, Rotate Left f (no carry) = 1. Cycles:, Rotate Left f (no carry) =",
    "Return from Subroutine\n1. Cycles:, Rotate Left f (no carry) = 1. Q Cycle Activity:, Rotate Left f (no carry) = . Q Cycle Activity:, Rotate Left f (no carry) = . Q Cycle Activity:, Rotate Left f (no carry) = . Q Cycle Activity:, Rotate Left f (no carry) = . Q1, Rotate Left f (no carry) = Q2. Q1, Rotate Left f (no carry) = Q3. Q1, Rotate Left f (no carry) = Q3. Q1, Rotate Left f (no carry) = Q4. Decode, Rotate Left f (no carry) = Read register 'f'. Decode, Rotate Left f (no carry) = Process Data. Decode, Rotate Left f (no carry) = Process Data. Decode, Rotate Left f (no carry) = Write to destination. Example:, Rotate Left f (no carry) = RLNCF. Example:, Rotate Left f (no carry) = REG. Example:, Rotate Left f (no carry) = REG. Example:, Rotate Left f (no carry) = . Before Instruction, Rotate Left f (no carry)",
    "Return from Subroutine\n= Before Instruction. Before Instruction, Rotate Left f (no carry) = Before Instruction. Before Instruction, Rotate Left f (no carry) = Before Instruction. Before Instruction, Rotate Left f (no carry) = Before Instruction. REG, Rotate Left f (no carry) = 1010. REG, Rotate Left f (no carry) = 1011. REG, Rotate Left f (no carry) = 1011. REG, Rotate Left f (no carry) = . After Instruction REG = 0101 0111, Rotate Left f (no carry) = After Instruction REG = 0101 0111. After Instruction REG = 0101 0111, Rotate Left f (no carry) = After Instruction REG = 0101 0111. After Instruction REG = 0101 0111, Rotate Left f (no carry) = After Instruction REG = 0101 0111. After Instruction REG = 0101 0111, Rotate Left f (no carry) = After Instruction REG = 0101 0111\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\nQ2\nRead\nQ3\nProcess register 'f'\nData\nExample:\nRRCF\nREG, W\nBefore Instruction\nREG\n=\n1110 0110\nC\n=\n0\nAfter Instruction\nREG\n=\n1110 0110\nW\n=",
    "Return from Subroutine\n0111 0011\nC\n=\n0",
    "PIC18F1220/1320\nSyntax:, Rotate Right f through Carry = [ label ] RRCF. Syntax:, Rotate Right f through Carry = [ label ] RRCF. Syntax:, Rotate Right f through Carry = f [,d [,a]]. Syntax:, Rotate Right f through Carry = f [,d [,a]]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Rotate Right f through Carry = . Operands:, Rotate Right f through Carry = . Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae",
    "PIC18F1220/1320\ndest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = . Status Affected:, Rotate Right f through Carry = . Status Affected:, Rotate Right f through Carry = . Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff\nDescription:",
    "PIC18F1220/1320\nThe contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\nC\nregister f\n1\n1\nQ4\nWrite to destination",
    "PIC18F1220/1320\nSyntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n - 1>,",
    "PIC18F1220/1320\n(f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Encoding:, Rotate Right f (no carry) = 0100. Encoding:, Rotate Right f (no carry) = 00da. Encoding:, Rotate Right f (no carry) = ffff. Encoding:, Rotate Right f (no carry) = ffff\nDescription:",
    "PIC18F1220/1320\nThe contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nExample 1:\nRRNCF   REG, 1, 0\nBefore Instruction\nREG\n=\n1101 0111\nAfter Instruction\nREG\n=\n1110 1011\nExample 2:\nRRNCF   REG, W\nBefore Instruction\nW\n=\n?\nREG\n=\n1101 0111\nAfter Instruction\nW\n=\n1110 1011\nREG\n=\n1101 0111",
    "PIC18F1220/1320\nSyntax:, Set f = [ label ] SETF. Syntax:, Set f = [ label ] SETF. Syntax:, Set f = f [,a]. Syntax:, Set f = . Operands:, Set f = 0 \uf0a3 f \uf0a3 255. Operands:, Set f = 0 \uf0a3 f \uf0a3 255. Operands:, Set f = . Operands:, Set f = . , Set f = a \uf0ce\uf020 [0,1]. , Set f = a \uf0ce\uf020 [0,1]. , Set f = . , Set f = . Operation:, Set f = FFh \uf0ae f. Operation:, Set f = FFh \uf0ae f. Operation:, Set f = . Operation:, Set f = . Status Affected:, Set f = None. Status Affected:, Set f = None. Status Affected:, Set f = . Status Affected:, Set f = . Encoding:, Set f = 0110. Encoding:, Set f = 100a. Encoding:, Set f = ffff. Encoding:, Set f = ffff\nDescription:",
    "PIC18F1220/1320\nThe contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nExample:\nSETF\nREG\nBefore Instruction REG\n=\n0x5A\nAfter Instruction REG\n= 0xFF",
    "PIC18F1220/1320\nSyntax:, SLEEP = Syntax:. Syntax:, Enter Sleep mode = [ label ] SLEEP. Syntax:, Enter Sleep mode = [ label ] SLEEP. Operands:, SLEEP = Operands:. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operation:, SLEEP = Operation:. Operation:, Enter Sleep mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler, 1 \uf0ae TO, 0 \uf0ae PD. Operation:, Enter Sleep mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler, 1 \uf0ae TO, 0 \uf0ae PD. Status Affected:, SLEEP = Status Affected:. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Encoding:, SLEEP = Encoding:. Encoding:, Enter Sleep mode = 0000. Encoding:, Enter Sleep mode = 0000 0000. Description:, SLEEP = Description:. Description:, Enter Sleep mode = The Power-down Status bit (PD) is cleared. The Time-out status bit (TO) is set. The Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator",
    "PIC18F1220/1320\nstopped.. Description:, Enter Sleep mode = The Power-down Status bit (PD) is cleared. The Time-out status bit (TO) is set. The Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Words:, SLEEP = Words:. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Cycles:, SLEEP = Cycles:. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Q Cycle Activity:, SLEEP = Q1. Q Cycle Activity:, Enter Sleep mode = Q2. Q Cycle Activity:, Enter Sleep mode = Q3. , SLEEP = Decode. , Enter Sleep mode = No operation. , Enter Sleep mode = Process Data",
    "Example:\nSLEEP\nBefore Instruction\nTO\n=\n?\nPD\n=\n?\nAfter Instruction\nTO\n=\n1\n\u2020\nPD\n=\n0\n- \u2020   If WDT causes wake-up, this bit is cleared.",
    "PIC18F1220/1320\nSyntax:, Subtract f from Wwith borrow = [ label ] SUBFWB. Syntax:, Subtract f from Wwith borrow = [ label ] SUBFWB. Syntax:, Subtract f from Wwith borrow = [ label ] SUBFWB. Syntax:, Subtract f from Wwith borrow = f [,d [,a]]. Syntax:, Subtract f from Wwith borrow = f [,d [,a]]. Operands:, Subtract f from Wwith borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith borrow = . Operands:, Subtract f from Wwith borrow = . Operation:, Subtract f from Wwith borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:,",
    "PIC18F1220/1320\nSubtract f from Wwith borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith borrow = . Operation:, Subtract f from Wwith borrow = . Status Affected:, Subtract f from Wwith borrow = N, OV,. Status Affected:, Subtract f from Wwith borrow = C, DC, Z. Status Affected:, Subtract f from Wwith borrow = . Status Affected:, Subtract f from Wwith borrow = . Status Affected:, Subtract f from Wwith borrow = . Encoding:, Subtract f from Wwith borrow = 0101. Encoding:, Subtract f from Wwith borrow = 01da. Encoding:, Subtract f from Wwith borrow = ffff. Encoding:, Subtract f from Wwith borrow = ffff. Encoding:, Subtract f from Wwith borrow = ffff. Description:, Subtract f from Wwith borrow = Subtract register",
    "PIC18F1220/1320\n'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract f from Wwith borrow = Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract f from Wwith borrow = Subtract register 'f' and",
    "PIC18F1220/1320\nCarry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract f from Wwith borrow = Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract f from Wwith borrow = Subtract register 'f' and Carry flag",
    "PIC18F1220/1320\n(borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Subtract f from Wwith borrow = 1. Words:, Subtract f from Wwith borrow = 1. Words:, Subtract f from Wwith borrow = 1. Words:, Subtract f from Wwith borrow = . Words:, Subtract f from Wwith borrow = . Cycles:, Subtract f from Wwith borrow = 1. Cycles:, Subtract f from Wwith borrow = 1. Cycles:, Subtract f from Wwith borrow = 1. Cycles:, Subtract f from Wwith borrow = . Cycles:, Subtract f from Wwith borrow = . Q Cycle Activity: Q1 Decode, Subtract",
    "PIC18F1220/1320\nf from Wwith borrow = Q2 Read register 'f'. Q Cycle Activity: Q1 Decode, Subtract f from Wwith borrow = Q3. Q Cycle Activity: Q1 Decode, Subtract f from Wwith borrow = Process Data. Q Cycle Activity: Q1 Decode, Subtract f from Wwith borrow = Process Data. Q Cycle Activity: Q1 Decode, Subtract f from Wwith borrow = Q4 Write to. , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = destination. , Subtract f from Wwith borrow = SUBFWB. , Subtract f from Wwith borrow = SUBFWB. , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . Example, Subtract f from Wwith borrow = . Example, Subtract f from Wwith borrow = . Example, Subtract",
    "PIC18F1220/1320\nf from Wwith borrow = REG. Example, Subtract f from Wwith borrow = REG. Example, Subtract f from Wwith borrow = . 1:, Subtract f from Wwith borrow = 1:. 1:, Subtract f from Wwith borrow = 1:. 1:, Subtract f from Wwith borrow = . 1:, Subtract f from Wwith borrow = . 1:, Subtract f from Wwith borrow = . Before Instruction REG = 0x03, Subtract f from Wwith borrow = Before Instruction REG = 0x03. Before Instruction REG = 0x03, Subtract f from Wwith borrow = Before Instruction REG = 0x03. Before Instruction REG = 0x03, Subtract f from Wwith borrow = . Before Instruction REG = 0x03, Subtract f from Wwith borrow = . Before Instruction REG = 0x03, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = =. W C, Subtract f from Wwith borrow = 0x02. W C,",
    "PIC18F1220/1320\nSubtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = =. , Subtract f from Wwith borrow = 0x01. , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = =. REG, Subtract f from Wwith borrow = 0xFF. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = = =. W C,",
    "PIC18F1220/1320\nSubtract f from Wwith borrow = 0x02 0x00. W C, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = =. Z, Subtract f from Wwith borrow = 0x00. Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = =. N, Subtract f from Wwith borrow = ; result. N, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = negative. , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = 0x01. , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . Example 2:",
    "PIC18F1220/1320\nSUBFWB Before Instruction, Subtract f from Wwith borrow = Example 2: SUBFWB Before Instruction. Example 2: SUBFWB Before Instruction, Subtract f from Wwith borrow = Example 2: SUBFWB Before Instruction. Example 2: SUBFWB Before Instruction, Subtract f from Wwith borrow = . Example 2: SUBFWB Before Instruction, Subtract f from Wwith borrow = . Example 2: SUBFWB Before Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = =. REG, Subtract f from Wwith borrow = 2. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = =. W, Subtract f from Wwith borrow = 5. W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . C, Subtract f from Wwith",
    "PIC18F1220/1320\nborrow = =. C, Subtract f from Wwith borrow = 1. C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = = =. REG, Subtract f from Wwith borrow = 2 3. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = =. W, Subtract f from Wwith borrow = 1. W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = .",
    "PIC18F1220/1320\nC, Subtract f from Wwith borrow = =. C, Subtract f from Wwith borrow = 0. C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . Z N, Subtract f from Wwith borrow = =. Z N, Subtract f from Wwith borrow = 0. Z N, Subtract f from Wwith borrow = ; result is. Z N, Subtract f from Wwith borrow = ; result is. Z N, Subtract f from Wwith borrow = positive. Example 3: SUBFWB, Subtract f from Wwith borrow = Example 3: SUBFWB. Example 3: SUBFWB, Subtract f from Wwith borrow = Example 3: SUBFWB. Example 3: SUBFWB, Subtract f from Wwith borrow = . Example 3: SUBFWB, Subtract f from Wwith borrow = . Example 3: SUBFWB, Subtract f from Wwith borrow = . Before Instruction, Subtract f from",
    "PIC18F1220/1320\nWwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = =. REG, Subtract f from Wwith borrow = 1. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = =. W, Subtract f from Wwith borrow = 2. W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = =. C, Subtract f from Wwith borrow = 0. C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . After",
    "PIC18F1220/1320\nInstruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = =. REG, Subtract f from Wwith borrow = 0. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = =. W, Subtract f from Wwith borrow = 2 1. W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . C Z, Subtract f from Wwith borrow = = =. C Z, Subtract f from Wwith borrow = 1. C Z, Subtract f from Wwith borrow = . C Z, Subtract f from Wwith borrow = .",
    "PIC18F1220/1320\nC Z, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = =. N, Subtract f from Wwith borrow = 0. N, Subtract f from Wwith borrow = ; result is zero. N, Subtract f from Wwith borrow = ; result is zero. N, Subtract f from Wwith borrow = ",
    "PIC18F1220/1320\nSyntax: [, Subtract Wfrom literal = . Syntax: [,  = label ] SUBLW k. Syntax: [,  = . Syntax: [,  = . Syntax: [,  = . Syntax: [,  = . Operands:, Subtract Wfrom literal = . Operands:,  = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:,  = . Operands:,  = . Operands:,  = . Operands:,  = . Operation:, Subtract Wfrom literal = . Operation:,  = k - (W) \uf0ae\uf020 W. Operation:,  = . Operation:,  = . Operation:,  = . Operation:,  = . Status Affected:, Subtract Wfrom literal = . Status Affected:,  = N, OV, C, DC, Z. Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Encoding:, Subtract Wfrom literal = . Encoding:,  = 0000. Encoding:,  = 1000. Encoding:,  = kkkk. Encoding:,  = . Encoding:,",
    "PIC18F1220/1320\n= kkkk. Description:, Subtract Wfrom literal = . Description:,  = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description:,  = . Description:,  = . Description:,  = . Description:,  = . Words:, Subtract Wfrom literal = . Words:,  = 1. Words:,  = . Words:,  = . Words:,  = . Words:,  = . Cycles:, Subtract Wfrom literal = . Cycles:,  = 1. Cycles:,  = . Cycles:,  = . Cycles:,  = . Cycles:,  = . Q Cycle Activity:, Subtract Wfrom literal = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q1, Subtract Wfrom literal = . Q1,  = Q2. Q1,  = . Q1,  = Q3. Q1,  = Q4. Q1,  = . , Subtract Wfrom literal = Decode. ,",
    "PIC18F1220/1320\n= Read literal 'k'. ,  = . ,  = Process Data. ,  = Write to W. ,  = . Example 1:, Subtract Wfrom literal = . Example 1:,  = SUBLW 0x02. Example 1:,  = . Example 1:,  = . Example 1:,  = . Example 1:,  = . Before Instruction, Subtract Wfrom literal = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . , Subtract Wfrom literal = W. ,  = =. ,  = 1 ?. ,  = . ,  = . ,  = . C = After Instruction, Subtract Wfrom literal = . C = After Instruction,  = . C = After Instruction,  = . C = After Instruction,  = . C = After Instruction,  = . C = After Instruction,  = . , Subtract Wfrom literal = W. ,  = =. ,  = 1 1 ; result. ,  = . ,  = . ,  = . , Subtract Wfrom literal = C. ,  = =. ,  = 0. ,  = is positive. ,  = . ,",
    "PIC18F1220/1320\n= . Z N, Subtract Wfrom literal = . Z N,  = = =. Z N,  = 0. Z N,  = . Z N,  = . Z N,  = . Example 2:, Subtract Wfrom literal = . Example 2:,  = SUBLW 0x02. Example 2:,  = . Example 2:,  = . Example 2:,  = . Example 2:,  = . Before Instruction, Subtract Wfrom literal = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . , Subtract Wfrom literal = W C. ,  = = =. ,  = 2. ,  = . ,  = . ,  = . , Subtract Wfrom literal = . ,  = . ,  = ?. ,  = . ,  = . ,  = . After, Subtract Wfrom literal = Instruction. After,  = . After,  = 0. After,  = . After,  = . After,  = . , Subtract Wfrom literal = W C. ,  = = =. ,  = 1. ,  = result is zero. ,",
    "PIC18F1220/1320\n= . ,  = . N, Subtract Wfrom literal = Z. N,  = = =. N,  = 1 0. N,  = . N,  = . N,  = . Example 3: SUBLW 0x02, Subtract Wfrom literal = . Example 3: SUBLW 0x02,  = . Example 3: SUBLW 0x02,  = . Example 3: SUBLW 0x02,  = . Example 3: SUBLW 0x02,  = . Example 3: SUBLW 0x02,  = . Before, Subtract Wfrom literal = W. Before,  = Instruction. Before,  = 3. Before,  = . Before,  = . Before,  = . , Subtract Wfrom literal = C. ,  = = =. ,  = ?. ,  = . ,  = . ,  = . After Instruction, Subtract Wfrom literal = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . , Subtract Wfrom literal = W. ,  = = =. ,",
    "PIC18F1220/1320\n= FF ; (2's. ,  = complement). ,  = . ,  = . , Subtract Wfrom literal = C Z. ,  = =. ,  = 0 ; 0. ,  = result is negative. ,  = . ,  = . , Subtract Wfrom literal = . ,  = =. ,  = 1. ,  = . ,  = . ,  = . , Subtract Wfrom literal = N. ,  = . ,  = . ,  = . ,  = . ,  = ",
    "PIC18F1220/1320\nSyntax:, Subtract Wfrom f = [ label ] SUBWF. Syntax:, Subtract Wfrom f = [ label ] SUBWF. Syntax:, Subtract Wfrom f = [ label ] SUBWF. Syntax:, Subtract Wfrom f = [ label ] SUBWF. Syntax:, Subtract Wfrom f = f [,d [,a]]. Syntax:, Subtract Wfrom f = f [,d [,a]]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f = . Operands:, Subtract",
    "PIC18F1220/1320\nWfrom f = . Operation:, Subtract Wfrom f = (f) - (W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = (f) - (W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = (f) - (W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = (f) - (W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = . Operation:, Subtract Wfrom f = . Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = . Status Affected:, Subtract Wfrom f = . Encoding:, Subtract Wfrom f = . Encoding:,",
    "PIC18F1220/1320\nSubtract Wfrom f = 0101. Encoding:, Subtract Wfrom f = 11da. Encoding:, Subtract Wfrom f = 11da. Encoding:, Subtract Wfrom f = ffff. Encoding:, Subtract Wfrom f = ffff. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is '",
    "PIC18F1220/1320\n0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected.",
    "PIC18F1220/1320\nDescription:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract",
    "PIC18F1220/1320\nWfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Q Cycle Activity:, Subtract Wfrom f = . Q Cycle Activity:, Subtract Wfrom f = . Q Cycle Activity:, Subtract Wfrom f = . Q Cycle Activity:, Subtract Wfrom f = . Q Cycle Activity:, Subtract Wfrom f = . Q Cycle Activity:, Subtract Wfrom f = . Q1, Subtract Wfrom f = . Q1, Subtract Wfrom f = Q2. Q1, Subtract Wfrom f = .",
    "PIC18F1220/1320\nQ1, Subtract Wfrom f = Q3. Q1, Subtract Wfrom f = Q3. Q1, Subtract Wfrom f = Q4. Decode, Subtract Wfrom f = Read register 'f'. Decode, Subtract Wfrom f = Read register 'f'. Decode, Subtract Wfrom f = Read register 'f'. Decode, Subtract Wfrom f = Process Data. Decode, Subtract Wfrom f = Process Data. Decode, Subtract Wfrom f = Write to destination. Example 1:, Subtract Wfrom f = SUBWF REG. Example 1:, Subtract Wfrom f = SUBWF REG. Example 1:, Subtract Wfrom f = SUBWF REG. Example 1:, Subtract Wfrom f = SUBWF REG. Example 1:, Subtract Wfrom f = SUBWF REG. Example 1:, Subtract Wfrom f = SUBWF REG. Before Instruction, Subtract Wfrom f",
    "PIC18F1220/1320\n= Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. REG, Subtract Wfrom f = =. REG, Subtract Wfrom f = 3. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W, Subtract Wfrom f = =. W, Subtract Wfrom f = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = =. C, Subtract Wfrom f = ?. C, Subtract Wfrom f = . C,",
    "PIC18F1220/1320\nSubtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = =. After Instruction, Subtract Wfrom f = 1. After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . REG W, Subtract Wfrom f = =. REG W, Subtract Wfrom f = 2. REG W, Subtract Wfrom f = . REG W, Subtract Wfrom f = . REG W, Subtract Wfrom f = . REG W, Subtract Wfrom f = . C, Subtract Wfrom f = =. C, Subtract Wfrom f = 1. C, Subtract Wfrom f = result is positive. C, Subtract Wfrom f = result is positive. C, Subtract Wfrom f = result is positive. C,",
    "PIC18F1220/1320\nSubtract Wfrom f = result is positive. Z N, Subtract Wfrom f = =. Z N, Subtract Wfrom f = 0. Z N, Subtract Wfrom f = . Z N, Subtract Wfrom f = . Z N, Subtract Wfrom f = . Z N, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = =. Example 2:, Subtract Wfrom f = 0. Example 2:, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = . SUBWF REG, W, Subtract Wfrom f = SUBWF REG, W. SUBWF REG, W, Subtract Wfrom f = SUBWF REG, W. SUBWF REG, W, Subtract Wfrom f = SUBWF REG, W. SUBWF REG, W, Subtract Wfrom f =",
    "PIC18F1220/1320\nSUBWF REG, W. SUBWF REG, W, Subtract Wfrom f = SUBWF REG, W. SUBWF REG, W, Subtract Wfrom f = SUBWF REG, W. Before Instruction REG, Subtract Wfrom f = =. Before Instruction REG, Subtract Wfrom f = 2. Before Instruction REG, Subtract Wfrom f = . Before Instruction REG, Subtract Wfrom f = . Before Instruction REG, Subtract Wfrom f = . Before Instruction REG, Subtract Wfrom f = . W, Subtract Wfrom f = =. W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = 2. C, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract",
    "PIC18F1220/1320\nWfrom f = . C, Subtract Wfrom f = . , Subtract Wfrom f = =. , Subtract Wfrom f = ?. , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = . After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. REG, Subtract Wfrom f = =. REG, Subtract Wfrom f = 2. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W, Subtract Wfrom f = =. W, Subtract",
    "PIC18F1220/1320\nWfrom f = 0. W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = = =. C, Subtract Wfrom f = 1 1. C, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = zero. C, Subtract Wfrom f = . Z N, Subtract Wfrom f = =. Z N, Subtract Wfrom f = . Z N, Subtract Wfrom f = . Z N, Subtract Wfrom f = . Z N, Subtract Wfrom f = . Z N, Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = 0. , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = . ,",
    "PIC18F1220/1320\nSubtract Wfrom f = . Example 3:, Subtract Wfrom f = . Example 3:, Subtract Wfrom f = . Example 3:, Subtract Wfrom f = . Example 3:, Subtract Wfrom f = . Example 3:, Subtract Wfrom f = . Example 3:, Subtract Wfrom f = . SUBWF REG, Subtract Wfrom f = SUBWF REG. SUBWF REG, Subtract Wfrom f = SUBWF REG. SUBWF REG, Subtract Wfrom f = SUBWF REG. SUBWF REG, Subtract Wfrom f = SUBWF REG. SUBWF REG, Subtract Wfrom f = SUBWF REG. SUBWF REG, Subtract Wfrom f = SUBWF REG. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f =",
    "PIC18F1220/1320\nBefore Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. REG, Subtract Wfrom f = =. REG, Subtract Wfrom f = 0x01. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W C, Subtract Wfrom f = = =. W C, Subtract Wfrom f = 0x02 ?. W C, Subtract Wfrom f = . W C, Subtract Wfrom f = . W C, Subtract Wfrom f = . W C, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = = =. After Instruction, Subtract Wfrom f = 0xFFh 0x02. After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f",
    "PIC18F1220/1320\n= complement). After Instruction, Subtract Wfrom f = . REG W, Subtract Wfrom f = =. REG W, Subtract Wfrom f = 0x00. REG W, Subtract Wfrom f = . REG W, Subtract Wfrom f = . REG W, Subtract Wfrom f = . REG W, Subtract Wfrom f = . C Z, Subtract Wfrom f = =. C Z, Subtract Wfrom f = 0x00. C Z, Subtract Wfrom f = . C Z, Subtract Wfrom f = . C Z, Subtract Wfrom f = negative. C Z, Subtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = 0x01. N, Subtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = . , Subtract Wfrom f =",
    "PIC18F1220/1320\n=. , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = ",
    "PIC18F1220/1320\nSyntax:, Subtract Wfrom f with Borrow = [ label ] SUBWFB f. Syntax:, Subtract Wfrom f with Borrow = [ label ] SUBWFB f. Syntax:, Subtract Wfrom f with Borrow = [ label ] SUBWFB f. Syntax:, Subtract Wfrom f with Borrow = [,d [,a]]. Syntax:, Subtract Wfrom f with Borrow = [,d [,a]]. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce",
    "PIC18F1220/1320\n[0,1] a \uf0ce [0,1]. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status",
    "PIC18F1220/1320\nAffected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Encoding:, Subtract Wfrom f with Borrow = 0101. Encoding:, Subtract Wfrom f with Borrow = 10da. Encoding:, Subtract Wfrom f with Borrow = . Encoding:, Subtract Wfrom f with Borrow = ffff. Encoding:, Subtract Wfrom f with Borrow = ffff. Description:, Subtract Wfrom f with Borrow = Subtract Wandthe Carry flag (borrow) from register 'f' (2's comple- ment method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. Description:, Subtract Wfrom f with Borrow = Subtract Wandthe Carry flag",
    "PIC18F1220/1320\n(borrow) from register 'f' (2's comple- ment method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. Description:, Subtract Wfrom f with Borrow = Subtract Wandthe Carry flag (borrow) from register 'f' (2's comple- ment method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. Description:, Subtract Wfrom f with Borrow = Subtract Wandthe Carry flag",
    "PIC18F1220/1320\n(borrow) from register 'f' (2's comple- ment method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. Description:, Subtract Wfrom f with Borrow = Subtract Wandthe Carry flag (borrow) from register 'f' (2's comple- ment method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. Words:, Subtract Wfrom f with Borrow = 1. Words:,",
    "PIC18F1220/1320\nSubtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Q Cycle Activity:, Subtract Wfrom f with Borrow = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom f with Borrow = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom f with Borrow = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom f with Borrow = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom f with Borrow = Q Cycle Activity:. Q1, Subtract Wfrom f with Borrow = Q2.",
    "PIC18F1220/1320\nQ1, Subtract Wfrom f with Borrow = Q2. Q1, Subtract Wfrom f with Borrow = Q3. Q1, Subtract Wfrom f with Borrow = Q3. Q1, Subtract Wfrom f with Borrow = Q4. Decode, Subtract Wfrom f with Borrow = Read register 'f'. Decode, Subtract Wfrom f with Borrow = Read register 'f'. Decode, Subtract Wfrom f with Borrow = Process Data. Decode, Subtract Wfrom f with Borrow = Process Data. Decode, Subtract Wfrom f with Borrow = Write to destination. Example 1:, Subtract Wfrom f with Borrow = SUBWFB. Example 1:, Subtract Wfrom f with Borrow = SUBWFB. Example 1:, Subtract Wfrom f with Borrow = REG, 1, 0. Example 1:, Subtract Wfrom f with Borrow = REG, 1, 0. Example 1:, Subtract Wfrom f with Borrow = . Before Instruction, Subtract",
    "PIC18F1220/1320\nWfrom f with Borrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. REG, Subtract Wfrom f with Borrow = =. REG, Subtract Wfrom f with Borrow = 0x19 0x0D. REG, Subtract Wfrom f with Borrow = ( 0001 (. REG, Subtract Wfrom f with Borrow = 1001 ). REG, Subtract Wfrom f with Borrow = 1001 ). W C, Subtract Wfrom f with Borrow = = =. W C, Subtract Wfrom f with Borrow = 0x01. W C, Subtract Wfrom f with Borrow = 0000. W C, Subtract Wfrom f with Borrow = 1101 ). W C, Subtract Wfrom f with Borrow = 1101 ). After Instruction, Subtract",
    "PIC18F1220/1320\nWfrom f with Borrow = After Instruction. After Instruction, Subtract Wfrom f with Borrow = After Instruction. After Instruction, Subtract Wfrom f with Borrow = After Instruction. After Instruction, Subtract Wfrom f with Borrow = After Instruction. After Instruction, Subtract Wfrom f with Borrow = After Instruction. REG, Subtract Wfrom f with Borrow = =. REG, Subtract Wfrom f with Borrow = 0x0C. REG, Subtract Wfrom f with Borrow = ( 0000 (. REG, Subtract Wfrom f with Borrow = 1011 ). REG, Subtract Wfrom f with Borrow = 1011 ). W C, Subtract Wfrom f with Borrow = = =. W C, Subtract Wfrom f with Borrow = 0x0D. W C, Subtract Wfrom f with Borrow = 0000. W C, Subtract Wfrom f with Borrow = 1101 ). W C, Subtract Wfrom f with Borrow = 1101 ). Z, Subtract Wfrom f with",
    "PIC18F1220/1320\nBorrow = =. Z, Subtract Wfrom f with Borrow = 0x01 0x00. Z, Subtract Wfrom f with Borrow = . Z, Subtract Wfrom f with Borrow = . Z, Subtract Wfrom f with Borrow = . N, Subtract Wfrom f with Borrow = =. N, Subtract Wfrom f with Borrow = 0x00. N, Subtract Wfrom f with Borrow = ; result. N, Subtract Wfrom f with Borrow = . N, Subtract Wfrom f with Borrow = . , Subtract Wfrom f with Borrow = . , Subtract Wfrom f with Borrow = . , Subtract Wfrom f with Borrow = . , Subtract Wfrom f with Borrow = is positive. , Subtract Wfrom f with Borrow = is positive. Example 2: SUBWFB REG, 0, 0, Subtract Wfrom f with Borrow = Example 2: SUBWFB REG, 0, 0. Example 2: SUBWFB REG, 0, 0, Subtract",
    "PIC18F1220/1320\nWfrom f with Borrow = Example 2: SUBWFB REG, 0, 0. Example 2: SUBWFB REG, 0, 0, Subtract Wfrom f with Borrow = Example 2: SUBWFB REG, 0, 0. Example 2: SUBWFB REG, 0, 0, Subtract Wfrom f with Borrow = Example 2: SUBWFB REG, 0, 0. Example 2: SUBWFB REG, 0, 0, Subtract Wfrom f with Borrow = Example 2: SUBWFB REG, 0, 0. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. REG, Subtract Wfrom f with Borrow = =. REG, Subtract Wfrom f with Borrow = 0x1B. REG, Subtract Wfrom f with Borrow = ( 0001.",
    "PIC18F1220/1320\nREG, Subtract Wfrom f with Borrow = 1011 ). REG, Subtract Wfrom f with Borrow = 1011 ). W, Subtract Wfrom f with Borrow = =. W, Subtract Wfrom f with Borrow = 0x1A. W, Subtract Wfrom f with Borrow = ( 0001. W, Subtract Wfrom f with Borrow = 1010 ). W, Subtract Wfrom f with Borrow = 1010 ). C, Subtract Wfrom f with Borrow = =. C, Subtract Wfrom f with Borrow = 0x00. C, Subtract Wfrom f with Borrow = . C, Subtract Wfrom f with Borrow = . C, Subtract Wfrom f with Borrow = . After Instruction, Subtract Wfrom f with Borrow = After Instruction. After Instruction, Subtract Wfrom f with Borrow = After Instruction. After Instruction, Subtract Wfrom f with Borrow = After Instruction. After Instruction, Subtract Wfrom f with Borrow = After Instruction. After Instruction,",
    "PIC18F1220/1320\nSubtract Wfrom f with Borrow = After Instruction. REG, Subtract Wfrom f with Borrow = =. REG, Subtract Wfrom f with Borrow = 0x1B. REG, Subtract Wfrom f with Borrow = ( 0001. REG, Subtract Wfrom f with Borrow = 1011 ). REG, Subtract Wfrom f with Borrow = 1011 ). W, Subtract Wfrom f with Borrow = = =. W, Subtract Wfrom f with Borrow = 0x00. W, Subtract Wfrom f with Borrow = . W, Subtract Wfrom f with Borrow = . W, Subtract Wfrom f with Borrow = . C Z, Subtract Wfrom f with Borrow = =. C Z, Subtract Wfrom f with Borrow = 0x01 0x01. C Z, Subtract Wfrom f with Borrow = ; result. C Z, Subtract Wfrom f with Borrow = is zero. C Z, Subtract Wfrom f with Borrow = is zero. N,",
    "PIC18F1220/1320\nSubtract Wfrom f with Borrow = =. N, Subtract Wfrom f with Borrow = 0x00. N, Subtract Wfrom f with Borrow = . N, Subtract Wfrom f with Borrow = . N, Subtract Wfrom f with Borrow = . Example 3: SUBWFB REG, 1, 0, Subtract Wfrom f with Borrow = Example 3: SUBWFB REG, 1, 0. Example 3: SUBWFB REG, 1, 0, Subtract Wfrom f with Borrow = Example 3: SUBWFB REG, 1, 0. Example 3: SUBWFB REG, 1, 0, Subtract Wfrom f with Borrow = Example 3: SUBWFB REG, 1, 0. Example 3: SUBWFB REG, 1, 0, Subtract Wfrom f with Borrow = Example 3: SUBWFB REG, 1, 0. Example 3: SUBWFB REG, 1, 0, Subtract Wfrom f with Borrow = Example 3: SUBWFB REG, 1, 0. Before Instruction, Subtract Wfrom f with",
    "PIC18F1220/1320\nBorrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. Before Instruction, Subtract Wfrom f with Borrow = Before Instruction. REG, Subtract Wfrom f with Borrow = =. REG, Subtract Wfrom f with Borrow = 0x03. REG, Subtract Wfrom f with Borrow = ( 0000. REG, Subtract Wfrom f with Borrow = 0011 ). REG, Subtract Wfrom f with Borrow = 0011 ). W, Subtract Wfrom f with Borrow = =. W, Subtract Wfrom f with Borrow = 0x0E. W, Subtract Wfrom f with Borrow = ( 0000. W, Subtract Wfrom f with Borrow = 1101 ). W, Subtract Wfrom f with Borrow = 1101 ). C, Subtract Wfrom f with Borrow = =. C, Subtract",
    "PIC18F1220/1320\nWfrom f with Borrow = 0x01. C, Subtract Wfrom f with Borrow = ( 1111. C, Subtract Wfrom f with Borrow = . C, Subtract Wfrom f with Borrow = . After Instruction, Subtract Wfrom f with Borrow = After Instruction. After Instruction, Subtract Wfrom f with Borrow = After Instruction. After Instruction, Subtract Wfrom f with Borrow = After Instruction. After Instruction, Subtract Wfrom f with Borrow = After Instruction. After Instruction, Subtract Wfrom f with Borrow = After Instruction. REG, Subtract Wfrom f with Borrow = =. REG, Subtract Wfrom f with Borrow = 0xF5. REG, Subtract Wfrom f with Borrow = 0100 ) ; [2's comp]. REG, Subtract Wfrom f with Borrow = 0100 ) ; [2's comp]. REG, Subtract Wfrom f with Borrow = 0100 ) ; [2's comp]. W, Subtract Wfrom f with Borrow =",
    "PIC18F1220/1320\n=. W, Subtract Wfrom f with Borrow = 0x0E. W, Subtract Wfrom f with Borrow = ( 0000. W, Subtract Wfrom f with Borrow = 1101 ). W, Subtract Wfrom f with Borrow = 1101 ). C Z, Subtract Wfrom f with Borrow = =. C Z, Subtract Wfrom f with Borrow = 0x00. C Z, Subtract Wfrom f with Borrow = . C Z, Subtract Wfrom f with Borrow = . C Z, Subtract Wfrom f with Borrow = . N, Subtract Wfrom f with Borrow = = =. N, Subtract Wfrom f with Borrow = 0x00 0x01. N, Subtract Wfrom f with Borrow = ; result is. N, Subtract Wfrom f with Borrow = negative. N, Subtract Wfrom f with Borrow = negative",
    "PIC18F1220/1320\nSyntax:, Swap f = [ label ] SWAPF f [,d [,a]]. Syntax:, Swap f = [ label ] SWAPF f [,d [,a]]. Syntax:, Swap f = [ label ] SWAPF f [,d [,a]]. Syntax:, Swap f = [ label ] SWAPF f [,d [,a]]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] \uf0ce. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] \uf0ce. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] \uf0ce. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] \uf0ce. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae",
    "PIC18F1220/1320\ndest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Encoding:, Swap f = 0011. Encoding:, Swap f = 10da. Encoding:, Swap f = ffff. Encoding:, Swap f = ffff\nDescription:\nThe upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:",
    "PIC18F1220/1320\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "Example:\nSWAPF\nREG\nBefore Instruction\nREG\n=\n0x53\nAfter Instruction\nREG\n=\n0x35",
    "PIC18F1220/1320\nSyntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) + 1 \uf0ae",
    "PIC18F1220/1320\nTBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if",
    "PIC18F1220/1320\nTBLRD +*, (TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Status Affected: None, Table Read = Status Affected: None. Status Affected: None, Table Read = Status Affected: None. Status Affected: None, Table Read = Status Affected: None. Status Affected: None, Table Read = Status Affected: None. Encoding:, Table Read = 0000. Encoding:, Table Read = 0000. Encoding:, Table Read = 0000. Encoding:, Table Read =",
    "PIC18F1220/1320\n10nn nn = 0* = 1*+ = 2*-. Description:, Table Read = = 3+* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 :Least Significant Byte of Program Memory Word. Description:, Table Read = = 3+* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 :Least Significant Byte of Program Memory Word. Description:, Table Read = = 3+* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer",
    "PIC18F1220/1320\n(TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 :Least Significant Byte of Program Memory Word. Description:, Table Read = = 3+* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 :Least Significant Byte of Program Memory Word. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q Cycle Activity:,",
    "PIC18F1220/1320\nTable Read = Q Cycle Activity:. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q1, Table Read = No operation. Q1, Table Read = Q2. Q1, Table Read = Q3 No. Q1, Table Read = Q4 No. Decode No, Table Read = operation No (Read. Decode No, Table Read = operation Program Memory). Decode No, Table Read = No operation. Decode No, Table Read = No operation (Write TABLAT)",
    "Table Read (Continued)\nExample 1: TBLRD *+, 1 = ;. Example 1: TBLRD *+, 2 = . Before Instruction TABLAT, 1 = =. Before Instruction TABLAT, 2 = 0x55. TBLPTR, 1 = =. TBLPTR, 2 = 0x00A356. MEMORY(0x00A356), 1 = =. MEMORY(0x00A356), 2 = 0x34. After Instruction, 1 = =. After Instruction, 2 = 0x34. TABLAT TBLPTR, 1 = =. TABLAT TBLPTR, 2 = 0x00A357. Example 2: TBLRD +*, 1 = ;. Example 2: TBLRD +*, 2 = . Before Instruction, 1 = =. Before Instruction, 2 = 0xAA. TABLAT TBLPTR, 1 = =. TABLAT TBLPTR, 2 = 0x01A357. MEMORY(0x01A357) MEMORY(0x01A358), 1 = = =. MEMORY(0x01A357) MEMORY(0x01A358), 2 = 0x12",
    "Table Read (Continued)\n0x34. After Instruction, 1 = =. After Instruction, 2 = 0x34. TABLAT TBLPTR, 1 = =. TABLAT TBLPTR, 2 = 0x01A358\nTBLWT\nSyntax:\nOperands:\nOperation:\nStatus Affected: Encoding:\nDescription:",
    "Table Write\n[\nlabel\n]\nTBLWT ( *; *+; *-; +*)\nNone if TBLWT*,\n(TABLAT)\nHolding Register;\nTBLPTR - No Change;\n\uf0ae\nif TBLWT*+,\n(TABLAT)\nHolding Register;\n(TBLPTR) + 1\n\uf0ae\nif TBLWT*-,\n\uf0ae\nTBLPTR;\n(TABLAT)\nHolding Register;\n(TBLPTR) - 1\n\uf0ae\nif TBLWT+*,\n\uf0ae\nTBLPTR;\n(TBLPTR) + 1\n(TABLAT)\n\uf0ae\n\uf0ae\nTBLPTR;\nHolding Register;\nNone\n0000, 1 = 0000. 0000, 2 = 0000. 0000, 3 = 11nn. 0000, 4 = 11nn. 0000, 5 = 11nn. , 1 = . , 2 = . , 3 = nn. , 4 = =. , 5 = 0*. , 1 = . , 2 = . , 3 = . , 4 = =. , 5 = 1*+. , 1 = . , 2 = . , 3 = . , 4 = =. , 5 = 2*-. , 1 = . , 2 = . , 3 = . , 4 = =. , 5 = 3+*",
    "Table Write\nThis instruction uses the 3 LSBs of TBLPTR to determine which of the eight holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to Section 6.0 'Flash Program Memory' for additional details on programming Flash memory.) The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. The LSb of the TBLPTR selects which byte of the program memory location to access.\nTBLPTR[0] = 0 :Least Significant Byte of Program Memory Word\nTBLPTR[0] =\n1\n:Most Significant\nByte of Program\nMemory Word\nThe TBLWT instruction can modify the value of TBLPTR as follows:\n\u00b7 no change\n\u00b7 post-increment\n\u00b7 post-decrement\n\u00b7 pre-increment",
    "PIC18F1220/1320\nWords: 1, Table Write (Continued) = Words: 1. Words: 1, Table Write (Continued) = Words: 1. Words: 1, Table Write (Continued) = Words: 1. Words: 1, Table Write (Continued) = Words: 1. Cycles: 2, Table Write (Continued) = Cycles: 2. Cycles: 2, Table Write (Continued) = Cycles: 2. Cycles: 2, Table Write (Continued) = Cycles: 2. Cycles: 2, Table Write (Continued) = Cycles: 2. Q Cycle Activity:, Table Write (Continued) = Q Cycle Activity:. Q Cycle Activity:, Table Write (Continued) = Q Cycle Activity:. Q Cycle Activity:, Table Write (Continued) = Q Cycle Activity:. Q Cycle Activity:, Table Write (Continued) = Q Cycle Activity:. , Table Write (Continued) = Q1. , Table Write (Continued) = Q2. , Table Write (Continued) = Q3. , Table Write (Continued) = Q4. , Table Write (Continued) = Decode. , Table Write (Continued) = No operation. , Table Write (Continued) = No operation. , Table",
    "PIC18F1220/1320\nWrite (Continued) = No operation. , Table Write (Continued) = No operation. , Table Write (Continued) = No operation (Read TABLAT). , Table Write (Continued) = No operation. , Table Write (Continued) = No operation (Write to Holding Register). Example 1:, Table Write (Continued) = Example 1:. Example 1:, Table Write (Continued) = TBLWT *+;. Example 1:, Table Write (Continued) = TBLWT *+;. Example 1:, Table Write (Continued) = TBLWT *+;. Before Instruction, Table Write (Continued) = Before Instruction. Before Instruction, Table Write (Continued) = Before Instruction. Before Instruction, Table Write (Continued) = Before Instruction. Before Instruction, Table Write (Continued) = Before Instruction. TABLAT = 0x55 TBLPTR = 0x00A357 HOLDING REGISTER (0x00A356) = 0x55, Table Write (Continued) = TABLAT = 0x55 TBLPTR = 0x00A357 HOLDING REGISTER (0x00A356) = 0x55. TABLAT = 0x55",
    "PIC18F1220/1320\nTBLPTR = 0x00A357 HOLDING REGISTER (0x00A356) = 0x55, Table Write (Continued) = TABLAT = 0x55 TBLPTR = 0x00A357 HOLDING REGISTER (0x00A356) = 0x55. TABLAT = 0x55 TBLPTR = 0x00A357 HOLDING REGISTER (0x00A356) = 0x55, Table Write (Continued) = TABLAT = 0x55 TBLPTR = 0x00A357 HOLDING REGISTER (0x00A356) = 0x55. TABLAT = 0x55 TBLPTR = 0x00A357 HOLDING REGISTER (0x00A356) = 0x55, Table Write (Continued) = TABLAT = 0x55 TBLPTR = 0x00A357 HOLDING REGISTER (0x00A356) = 0x55. After Instructions (table write completion) Example 2: TBLWT +*; Before Instruction, Table Write (Continued) = After Instructions (table write completion) Example 2: TBLWT +*; Before Instruction. After Instructions (table write",
    "PIC18F1220/1320\ncompletion) Example 2: TBLWT +*; Before Instruction, Table Write (Continued) = After Instructions (table write completion) Example 2: TBLWT +*; Before Instruction. After Instructions (table write completion) Example 2: TBLWT +*; Before Instruction, Table Write (Continued) = After Instructions (table write completion) Example 2: TBLWT +*; Before Instruction. After Instructions (table write completion) Example 2: TBLWT +*; Before Instruction, Table Write (Continued) = After Instructions (table write completion) Example 2: TBLWT +*; Before Instruction. TABLAT = 0x34, Table Write (Continued) = TABLAT = 0x34. TABLAT = 0x34, Table Write (Continued) = TABLAT = 0x34. TABLAT = 0x34, Table Write (Continued) = TABLAT = 0x34. TABLAT = 0x34, Table Write (Continued) = TABLAT = 0x34. TBLPTR = 0x01389A HOLDING REGISTER (0x01389A) = 0xFF, Table Write (Continued) = TBLPTR = 0x01389A",
    "PIC18F1220/1320\nHOLDING REGISTER (0x01389A) = 0xFF. TBLPTR = 0x01389A HOLDING REGISTER (0x01389A) = 0xFF, Table Write (Continued) = TBLPTR = 0x01389A HOLDING REGISTER (0x01389A) = 0xFF. TBLPTR = 0x01389A HOLDING REGISTER (0x01389A) = 0xFF, Table Write (Continued) = TBLPTR = 0x01389A HOLDING REGISTER (0x01389A) = 0xFF. TBLPTR = 0x01389A HOLDING REGISTER (0x01389A) = 0xFF, Table Write (Continued) = TBLPTR = 0x01389A HOLDING REGISTER (0x01389A) = 0xFF. HOLDING REGISTER (0x01389B) = 0xFF, Table Write (Continued) = HOLDING REGISTER (0x01389B) = 0xFF. HOLDING REGISTER (0x01389B) = 0xFF, Table Write (Continued) = HOLDING REGISTER",
    "PIC18F1220/1320\n(0x01389B) = 0xFF. HOLDING REGISTER (0x01389B) = 0xFF, Table Write (Continued) = HOLDING REGISTER (0x01389B) = 0xFF. HOLDING REGISTER (0x01389B) = 0xFF, Table Write (Continued) = HOLDING REGISTER (0x01389B) = 0xFF. Instruction (table write completion), Table Write (Continued) = Instruction (table write completion). Instruction (table write completion), Table Write (Continued) = Instruction (table write completion). Instruction (table write completion), Table Write (Continued) = Instruction (table write completion). Instruction (table write completion), Table Write (Continued) = Instruction (table write completion). TABLAT = 0x34, Table Write (Continued) = TABLAT = 0x34. TABLAT = 0x34, Table Write (Continued) = TABLAT = 0x34. TABLAT = 0x34, Table Write (Continued) = TABLAT = 0x34. TABLAT = 0x34, Table Write (Continued) = TABLAT = 0x34. TBLPTR",
    "PIC18F1220/1320\n=, Table Write (Continued) = TBLPTR =. TBLPTR =, Table Write (Continued) = TBLPTR =. TBLPTR =, Table Write (Continued) = TBLPTR =. TBLPTR =, Table Write (Continued) = TBLPTR =. 0x01389B, Table Write (Continued) = 0x01389B. 0x01389B, Table Write (Continued) = 0x01389B. 0x01389B, Table Write (Continued) = 0x01389B. 0x01389B, Table Write (Continued) = 0x01389B. HOLDING REGISTER (0x01389A) = 0xFF, Table Write (Continued) = HOLDING REGISTER (0x01389A) = 0xFF. HOLDING REGISTER (0x01389A) = 0xFF, Table Write (Continued) = HOLDING REGISTER (0x01389A) = 0xFF. HOLDING REGISTER (0x01389A) = 0xFF, Table Write (Continued) = HOLDING REGISTER (0x01389A) =",
    "PIC18F1220/1320\n0xFF. HOLDING REGISTER (0x01389A) = 0xFF, Table Write (Continued) = HOLDING REGISTER (0x01389A) = 0xFF. After, Table Write (Continued) = After. After, Table Write (Continued) = After. After, Table Write (Continued) = After. After, Table Write (Continued) = After",
    "PIC18F1220/1320\nSyntax:, Test f, skip if 0 = [ label ] TSTFSZ. Syntax:, Test f, skip if 0 = [ label ] TSTFSZ. Syntax:, Test f, skip if 0 = f [,a]. Syntax:, Test f, skip if 0 = . Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None.",
    "PIC18F1220/1320\nStatus Affected:, Test f, skip if 0 = None. Encoding:, Test f, skip if 0 = 0110. Encoding:, Test f, skip if 0 = 011a. Encoding:, Test f, skip if 0 = ffff. Encoding:, Test f, skip if 0 = ffff. Description:, Test f, skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as. Description:, Test f, skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as. Description:, Test f, skip if 0 =",
    "PIC18F1220/1320\nIf 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as. Description:, Test f, skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as. Words:, Test f, skip if 0 = 1. Words:, Test f, skip if 0 = 1. Words:, Test f, skip if 0 = 1. Words:, Test f, skip if 0 = 1. Cycles:, Test f, skip if 0 = 1(2). Cycles:, Test f, skip if 0 = 1(2). Cycles:, Test f, skip if",
    "PIC18F1220/1320\n0 = 1(2). Cycles:, Test f, skip if 0 = 1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation\nIf skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nIf skip and followed by 2-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nHERE\nTSTFSZ CNT\nNZERO\n:\nZERO\n:\nBefore Instruction\nPC\n=\nAddress ( HERE )\nAfter Instruction\nIf CNT\n=\n0x00,\nPC\n=\nAddress\n(ZERO)\nIf CNT\n\uf0b9\n0x00,\nPC\n=\nAddress (NZERO)",
    "Q Cycle Activity:\nSyntax:, Exclusive OR literal with W = [ label ] XORLW. Syntax:, Exclusive OR literal with W = [ label ] XORLW. Syntax:, Exclusive OR literal with W = k. Syntax:, Exclusive OR literal with W = . Operands:, Exclusive OR literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR literal with W = . Operands:, Exclusive OR literal with W = . Operation:, Exclusive OR literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR literal with W = . Operation:, Exclusive OR literal with W = . Status Affected:, Exclusive OR literal with W = N, Z. Status Affected:, Exclusive OR literal with W = . Status Affected:, Exclusive OR literal with W = . Status Affected:, Exclusive OR literal with W = . Encoding:, Exclusive OR literal with W = 0000. Encoding:, Exclusive OR literal with W = 1010. Encoding:, Exclusive OR literal with W = kkkk. Encoding:, Exclusive OR",
    "Q Cycle Activity:\nliteral with W = kkkk. Description:, Exclusive OR literal with W = The contents of Ware XOR'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR literal with W = The contents of Ware XOR'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR literal with W = The contents of Ware XOR'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR literal with W = The contents of Ware XOR'ed with the 8-bit literal 'k'. The result is placed in W.. Words:, Exclusive OR literal with W = 1. Words:, Exclusive OR literal with W = . Words:, Exclusive OR literal with W = . Words:, Exclusive OR literal with W = . Cycles:, Exclusive OR literal with W = 1. Cycles:, Exclusive OR literal with W = . Cycles:, Exclusive OR literal with W = . Cycles:, Exclusive OR literal with W = . Q Cycle Activity: Q1, Exclusive OR literal with W = Q2. Q Cycle Activity:",
    "Q Cycle Activity:\nQ1, Exclusive OR literal with W = Q3. Q Cycle Activity: Q1, Exclusive OR literal with W = . Q Cycle Activity: Q1, Exclusive OR literal with W = Q4. Decode, Exclusive OR literal with W = Read literal 'k'. Decode, Exclusive OR literal with W = Process Data. Decode, Exclusive OR literal with W = . Decode, Exclusive OR literal with W = Write to W",
    "Example:\nXORLW\n0xAF\nBefore Instruction\nW\n=\n0xB5\nAfter Instruction\nW\n= 0x1A",
    "Example:\nSyntax:, Exclusive OR Wwith f = [ label ] XORWF. Syntax:, Exclusive OR Wwith f = [ label ] XORWF. Syntax:, Exclusive OR Wwith f = f [,d [,a]]. Syntax:, Exclusive OR Wwith f = f [,d [,a]]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = . Operands:, Exclusive OR Wwith f = . Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR",
    "Example:\nWwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Encoding:, Exclusive OR Wwith f = 0001. Encoding:, Exclusive OR Wwith f = 10da. Encoding:, Exclusive OR Wwith f = ffff. Encoding:, Exclusive OR Wwith f = ffff. Description:, Exclusive OR Wwith f = Exclusive OR the contents of W with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the. Description:, Exclusive OR Wwith f = Exclusive OR the contents of W with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is '",
    "Example:\n0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the. Description:, Exclusive OR Wwith f = Exclusive OR the contents of W with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the. Description:, Exclusive OR Wwith f = Exclusive OR the contents of W with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the. Words:, Exclusive OR Wwith f = 1.",
    "Example:\nWords:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Q Cycle Activity:, Exclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, Exclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, Exclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, Exclusive OR Wwith f = Q Cycle Activity:. Q1, Exclusive OR Wwith f = Q2. Q1, Exclusive OR Wwith f = Q3. Q1, Exclusive OR Wwith f = Q4. Q1, Exclusive OR Wwith f = Q4. Decode, Exclusive OR Wwith f = Read register 'f'. Decode, Exclusive OR Wwith f = Process Data. Decode, Exclusive OR Wwith f = Write to destination. Decode, Exclusive OR Wwith f = Write to destination. Example: XORWF REG, Exclusive OR Wwith",
    "Example:\nf = Example: XORWF REG. Example: XORWF REG, Exclusive OR Wwith f = Example: XORWF REG. Example: XORWF REG, Exclusive OR Wwith f = Example: XORWF REG. Example: XORWF REG, Exclusive OR Wwith f = Example: XORWF REG. Before REG W, Exclusive OR Wwith f = Instruction = 0xAF = 0xB5. Before REG W, Exclusive OR Wwith f = . Before REG W, Exclusive OR Wwith f = . Before REG W, Exclusive OR Wwith f = . After Instruction, Exclusive OR Wwith f = After Instruction. After Instruction, Exclusive OR Wwith f = After Instruction. After Instruction, Exclusive OR Wwith f = After Instruction. After Instruction, Exclusive OR Wwith f = After Instruction. REG W, Exclusive OR Wwith f = 0x1A. REG W, Exclusive OR Wwith f = . REG W, Exclusive OR Wwith f = . REG W, Exclusive OR Wwith f = . =, Exclusive OR Wwith f = = 0xB5. =, Exclusive OR Wwith f = . =, Exclusive OR Wwith f = .",
    "Example:\n=, Exclusive OR Wwith f = ",
    "21.0 DEVELOPMENT SUPPORT\nThe PIC \u00ae   microcontrollers  (MCU)  and  dsPIC \u00ae   digital signal controllers (DSC) are supported with a full range of software and hardware development tools:\n\u00b7 Integrated Development Environment\n-MPLAB \u00ae  X IDE Software\n\u00b7 Compilers/Assemblers/Linkers\n-MPLAB XC Compiler\n-MPASM TM  Assembler\n-MPLINK TM  Object Linker/ MPLIB TM  Object Librarian\n-MPLAB Assembler/Linker/Librarian for Various Device Families\n\u00b7 Simulators\n-MPLAB X SIM Software Simulator\n\u00b7 Emulators\n-MPLAB REAL ICE\u2122 In-Circuit Emulator\n\u00b7 In-Circuit Debuggers/Programmers\n-MPLAB ICD 3\n-PICkit\u2122 3\n\u00b7 Device Programmers\n-MPLAB PM3 Device Programmer\n\u00b7 Low-Cost Demonstration/Development Boards, Evaluation Kits and Starter Kits\n\u00b7 Third-party development tools",
    "21.1 MPLAB X Integrated Development Environment Software\nThe MPLAB X IDE is a single, unified graphical user interface  for  Microchip  and  third-party  software,  and hardware  development  tool  that  runs  on  Windows \u00ae , Linux and Mac OS \u00ae  X. Based on the NetBeans IDE, MPLAB X IDE is an entirely new IDE with a host of free software components and plug-ins for highperformance application development and debugging. Moving  between  tools  and  upgrading  from  software simulators  to  hardware  debugging  and  programming tools is simple with the seamless user interface.\nWith complete project management, visual call graphs, a configurable watch window and a feature-rich editor that  includes  code  completion  and  context  menus, MPLAB X IDE is flexible and friendly enough for new users.  With  the  ability  to  support  multiple  tools  on multiple projects with simultaneous debugging, MPLAB X  IDE  is  also  suitable  for  the  needs  of  experienced users.",
    "Feature-Rich Editor:\n\u00b7 Color syntax highlighting\n\u00b7 Smart code completion makes suggestions and provides hints as you type\n\u00b7 Automatic code formatting based on user-defined rules\n\u00b7 Live parsing\nUser-Friendly, Customizable Interface:\n\u00b7 Fully customizable interface: toolbars, toolbar buttons, windows, window placement, etc.\n\u00b7 Call graph window\nProject-Based Workspaces:\n\u00b7 Multiple projects\n\u00b7 Multiple tools\n\u00b7 Multiple configurations\n\u00b7 Simultaneous debugging sessions\nFile History and Bug Tracking:\n\u00b7 Local file history feature\n\u00b7 Built-in support for Bugzilla issue tracker",
    "21.2 MPLAB XC Compilers\nThe  MPLAB  XC  Compilers  are  complete  ANSI  C compilers for all of Microchip's 8, 16, and 32-bit MCU and DSC devices. These compilers provide powerful integration capabilities, superior code optimization and ease of use. MPLAB XC Compilers run on Windows, Linux or MAC OS X.\nFor easy source level debugging, the compilers provide debug information that is optimized to the  MPLAB X IDE.\nThe  free  MPLAB  XC  Compiler  editions  support  all devices  and  commands,  with  no  time  or  memory restrictions,  and  offer  sufficient  code  optimization  for most applications.\nMPLAB XC Compilers include an assembler, linker and utilities.  The  assembler  generates  relocatable  object files that can then be archived or linked with other relocatable object files and archives to create an executable file. MPLAB XC Compiler uses the assembler to produce its object file. Notable features of the assembler include:\n\u00b7 Support for the entire device instruction set\n\u00b7 Support for fixed-point and floating-point data\n\u00b7 Command-line interface\n\u00b7 Rich directive set\n\u00b7 Flexible macro language\n\u00b7 MPLAB X IDE compatibility",
    "21.3 MPASM Assembler\nThe  MPASM  Assembler  is  a  full-featured,  universal macro assembler for PIC10/12/16/18 MCUs.\nThe MPASM Assembler generates relocatable object files for the MPLINK Object Linker, Intel \u00ae  standard HEX files,  MAP  files  to  detail  memory  usage  and  symbol reference, absolute LST files that contain source lines and  generated  machine  code,  and  COFF  files  for debugging.\nThe MPASM Assembler features include:\n\u00b7 Integration into MPLAB X IDE projects\n\u00b7 User-defined macros to streamline assembly code\n\u00b7 Conditional assembly for multipurpose source files\n\u00b7 Directives that allow complete control over the assembly process",
    "21.4 MPLINK Object Linker/ MPLIB Object Librarian\nThe  MPLINK  Object  Linker  combines relocatable objects created by the MPASM Assembler. It can link relocatable  objects  from  precompiled  libraries,  using directives from a linker script.\nThe MPLIB Object Librarian manages the creation and modification of library files of precompiled code. When a routine from a library is called from a source file, only the modules that contain that routine will be linked in with  the  application.  This  allows  large  libraries  to  be used efficiently in many different applications.\nThe object linker/library features include:\n\u00b7 Efficient linking of single libraries instead of many smaller files\n\u00b7 Enhanced code maintainability by grouping related modules together\n\u00b7 Flexible creation of libraries with easy module listing, replacement, deletion and extraction",
    "21.5 MPLAB Assembler, Linker and Librarian for Various Device Families\nMPLAB  Assembler  produces  relocatable machine code  from  symbolic  assembly  language  for  PIC24, PIC32 and dsPIC DSC devices. MPLAB XC Compiler uses  the  assembler  to  produce  its  object  file.  The assembler generates relocatable object files that can then be archived or linked with other relocatable object files and archives to create an executable file. Notable features of the assembler include:\n\u00b7 Support for the entire device instruction set\n\u00b7 Support for fixed-point and floating-point data\n\u00b7 Command-line interface\n\u00b7 Rich directive set\n\u00b7 Flexible macro language\n\u00b7 MPLAB X IDE compatibility",
    "21.6 MPLAB X SIM Software Simulator\nThe  MPLAB  X  SIM  Software  Simulator  allows  code development in a PC-hosted environment by simulating the PIC MCUs and dsPIC DSCs on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a comprehensive stimulus controller. Registers can be logged to files for further run-time analysis. The trace buffer and logic analyzer display extend the power of the simulator to record and track program execution, actions on I/O, most peripherals and internal registers.\nThe MPLAB X SIM Software Simulator fully supports symbolic debugging using the MPLAB XC Compilers, and  the  MPASM  and  MPLAB  Assemblers.  The  software  simulator  offers  the  flexibility  to  develop  and debug code outside of the hardware laboratory environment, making it an excellent, economical software development tool.",
    "21.7 MPLAB REAL ICE In-Circuit Emulator System\nThe MPLAB REAL ICE In-Circuit Emulator System is Microchip's  next  generation  high-speed  emulator  for Microchip Flash DSC and MCU devices. It debugs and programs all 8, 16 and 32-bit MCU, and DSC devices with the easy-to-use, powerful graphical user interface of the MPLAB X IDE.\nThe emulator is connected to the design engineer's PC  using  a  high-speed  USB  2.0  interface  and  is connected  to  the  target  with either a connector compatible with in-circuit  debugger systems (RJ-11) or  with  the  new  high-speed,  noise  tolerant,  LowVoltage  Differential  Signal  (LVDS)  interconnection (CAT5).\nThe emulator is field upgradable through future firmware downloads in MPLAB X IDE. MPLAB REAL ICE offers significant advantages over competitive emulators including full-speed emulation, run-time variable watches,  trace  analysis,  complex  breakpoints,  logic probes,  a  ruggedized  probe  interface  and  long  (up  to three meters) interconnection cables.",
    "21.8 MPLAB ICD 3 In-Circuit Debugger System\nThe  MPLAB  ICD  3  In-Circuit  Debugger  System  is Microchip's most cost-effective, high-speed hardware debugger/programmer  for  Microchip  Flash  DSC  and MCU  devices.  It  debugs  and  programs  PIC  Flash microcontrollers  and  dsPIC  DSCs  with  the  powerful, yet easy-to-use graphical user interface of the MPLAB IDE.\nThe  MPLAB  ICD  3  In-Circuit  Debugger  probe  is connected to the design engineer's PC using a highspeed USB 2.0 interface and is connected to the target with a connector compatible with the MPLAB ICD 2 or MPLAB  REAL  ICE  systems  (RJ-11).  MPLAB  ICD  3 supports all MPLAB ICD 2 headers.",
    "21.9 PICkit 3 In-Circuit Debugger/ Programmer\nThe MPLAB PICkit 3 allows debugging and programming of PIC and dsPIC Flash microcontrollers at a most affordable price point using the powerful graphical user interface of the MPLAB IDE. The MPLAB PICkit 3 is connected  to  the  design  engineer's  PC  using  a  fullspeed USB interface and can be connected to the target via a Microchip debug (RJ-11) connector (compatible with MPLAB ICD 3 and MPLAB REAL ICE). The connector uses two device I/O pins and the Reset line to implement in-circuit debugging and In-Circuit Serial Programming\u2122 (ICSP\u2122).",
    "21.10 MPLAB PM3 Device Programmer\nThe MPLAB PM3 Device Programmer is a universal, CE compliant device programmer with programmable voltage verification at VDDMIN and VDDMAX for maximum  reliability.  It  features  a  large  LCD  display (128 x 64) for menus and error messages, and a modular,  detachable  socket  assembly  to  support  various package types. The ICSP cable assembly is included as a standard item. In Stand-Alone mode, the MPLAB PM3 Device Programmer can read, verify and program PIC devices without a PC connection. It can also set code  protection in this mode.  The  MPLAB  PM3 connects to the host PC via an RS-232 or USB cable. The MPLAB PM3 has high-speed communications and optimized  algorithms  for  quick  programming  of  large memory devices, and incorporates an MMC card for file storage and data applications.",
    "21.11 Demonstration/Development Boards, Evaluation Kits, and Starter Kits\nA  wide  variety  of  demonstration,  development  and evaluation  boards  for  various  PIC  MCUs  and  dsPIC DSCs  allows  quick  application  development  on  fully functional  systems.  Most  boards  include  prototyping areas for adding custom circuitry and provide application  firmware  and  source  code  for  examination  and modification.\nThe boards support a variety of features, including LEDs, temperature sensors, switches, speakers, RS-232 interfaces, LCD displays, potentiometers and additional EEPROM memory.\nThe  demonstration  and  development  boards  can  be used in teaching environments, for prototyping custom circuits and for learning about various microcontroller applications.\nIn addition to the PICDEM\u2122  and  dsPICDEM\u2122 demonstration/development  board  series  of  circuits, Microchip has a line of evaluation kits and demonstration software for analog filter design, KEELOQ \u00ae security ICs,  CAN,  IrDA \u00ae ,  PowerSmart  battery  management, SEEVAL \u00ae  evaluation  system,  Sigma-Delta  ADC, flow rate sensing, plus many more.\nAlso available are starter kits that contain everything needed to experience the specified device. This usually includes a single application and debug capability, all on one board.",
    "21.11 Demonstration/Development Boards, Evaluation Kits, and Starter Kits\nCheck the Microchip web page (www.microchip.com) for  the  complete  list  of  demonstration,  development and evaluation kits.",
    "21.12 Third-Party Development Tools\nMicrochip  also  offers  a  great  collection  of  tools  from third-party vendors. These tools are carefully selected to offer good value and unique functionality.\n\u00b7 Device Programmers and Gang Programmers from companies, such as SoftLog and CCS\n\u00b7 Software Tools from companies, such as Gimpel and Trace Systems\n\u00b7 Protocol Analyzers from companies, such as Saleae and Total Phase\n\u00b7 Demonstration Boards from companies, such as MikroElektronika, Digilent \u00ae  and Olimex\n\u00b7 Embedded Ethernet Solutions from companies, such as EZ Web Lynx, WIZnet and IPLogika \u00ae",
    "Absolute Maximum Ratings (\u2020)\nAmbient temperature under bias.............................................................................................................-40\u00b0C to +125\u00b0C",
    "Absolute Maximum Ratings (\u2020)\nStorage temperature .............................................................................................................................. -65\u00b0C to +150\u00b0C\nVoltage on any pin with respect to VSS (except VDD, MCLR and RA4)........................................... -0.3V to (VDD + 0.3V)",
    "Absolute Maximum Ratings (\u2020)\nVoltage on VDD with respect to VSS  .........................................................................................................  -0.3V to +5.5V\nVoltage on MCLR with respect to VSS (Note 2)\n......................................................................................... 0V to +13.25V",
    "Absolute Maximum Ratings (\u2020)\nVoltage on RA4 with respect to Vss ............................................................................................................... 0V to +8.5V\nTotal power dissipation (Note 1)",
    "Absolute Maximum Ratings (\u2020)\n................................................................................................................................1.0W",
    "Absolute Maximum Ratings (\u2020)\nMaximum current out of VSS pin ...........................................................................................................................300 mA",
    "Absolute Maximum Ratings (\u2020)\nMaximum current into VDD pin ..............................................................................................................................250 mA\nInput clamp current, IIK (VI < 0 or VI > VDD)\n\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e \uf0b1\n20 mA\nOutput clamp current, IOK (VO < 0 or VO > VDD)\n\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e \uf0b1\n20 mA",
    "Absolute Maximum Ratings (\u2020)\nMaximum output current sunk by any I/O pin..........................................................................................................25 mA\nMaximum output current sourced by any I/O pin.....................................................................................................25 mA",
    "Absolute Maximum Ratings (\u2020)\nMaximum current sunk by all ports........................................................................................................................200 mA \uf020\nMaximum current sourced by all ports ..................................................................................................................200 mA",
    "Absolute Maximum Ratings (\u2020)\nNote 1:\n- Power dissipation is calculated as follows:\nPdis = VDD x {IDD -\uf0e5 IOH} + \uf0e5 {(VDD - VOH) x IOH} + \uf0e5 (VOL x IOL)\n- 2: Voltage spikes below VSS at the MCLR/VPP pin, inducing currents greater than 80 mA, may cause latch-up. Thus, a series resistor of 50-100 \uf057 should be used when applying a 'low' level to the MCLR/VPP pin, rather than pulling this pin directly to VSS.\n\u2020 NOTICE: Stresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure to maximum rating conditions for extended periods may affect device reliability.\nFIGURE 22-1: PIC18F1220/1320 VOLTAGE-FREQUENCY GRAPH (INDUSTRIAL)",
    "22.1 DC Characteristics:\nSupply Voltage",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = VDD. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = Supply Voltage. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = Supply Voltage. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = Supply Voltage. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = Supply Voltage. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = Supply Voltage. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Supply Voltage. D001, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . D001, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = PIC18LF1220/1320. D001, Standard Operating",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nConditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 2.0. D001, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = -. D001, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 5.5. D001, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nstated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. D001, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = HS, XT, RC and LP Oscillator mode. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = PIC18F1220/1320. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+125\u00b0C for extended.Min. = 4.2. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 5.5. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nConditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . D002, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = VDR. D002, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = RAM Data Retention Voltage (1). D002, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 1.5. D002, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nA \uf0a3 +125\u00b0C for extended.Typ. = -. D002, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = -. D002, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. D002, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . D003, PIC18LF1220/1320",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n(Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = VPOR. D003, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = VDD Start Voltage to ensure internal Power-on Reset signal. D003, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = -. D003, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = -. D003, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n(unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 0.7. D003, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. D003, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = See Section 4.1 'Power-on Reset (POR)' for details.. D004, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = SVDD. D004, PIC18LF1220/1320",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n(Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = VDD Rise Rate to ensure internal Power-on Reset signal. D004, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 0.05. D004, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = -. D004, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n= -. D004, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V/ms. D004, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = See Section 4.1 'Power-on Reset (POR)' for details.. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = VBOR. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = Brown-out Reset Voltage. , Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = . , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = . , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = . , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+125\u00b0C for extended.Units = . , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . D005D, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . D005D, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = PIC18LF1220/1320 Industrial Low Voltage (-10 \uf0b0 C to +85 \uf0b0 C). D005D, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = PIC18LF1220/1320",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nIndustrial Low Voltage (-10 \uf0b0 C to +85 \uf0b0 C). D005D, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = PIC18LF1220/1320 Industrial Low Voltage (-10 \uf0b0 C to +85 \uf0b0 C). D005D, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = PIC18LF1220/1320 Industrial Low Voltage (-10 \uf0b0 C to +85 \uf0b0 C). D005D, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = PIC18LF1220/1320 Industrial Low Voltage (-10 \uf0b0 C to +85 \uf0b0 C). D005D, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = PIC18LF1220/1320 Industrial Low Voltage (-10 \uf0b0 C to +85 \uf0b0 C). , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 11. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\notherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Reserved. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 10. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 2.50. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = 2.72. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 2.94. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . , PIC18LF1220/1320",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n(Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 01. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 3.88. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = 4.22. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 4.56. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = (Note 2). , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 00. , Standard Operating Conditions (unless otherwise",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nstated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 4.18. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = 4.54. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 4.90. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = (Note 2). D005F, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . D005F, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = PIC18LF1220/1320 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). D005F, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+125\u00b0C for extended.Min. = PIC18LF1220/1320 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). D005F, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = PIC18LF1220/1320 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). D005F, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = PIC18LF1220/1320 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). D005F, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nindustrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = PIC18LF1220/1320 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). D005F, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = PIC18LF1220/1320 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 11. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Reserved. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 10. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 2.34. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nindustrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = 2.72. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 3.10. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n= . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 01. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 3.63. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = 4.22. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n(unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 4.81. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = (Note 2). , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic =",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nBORV1:BORV0 = 00. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 3.90. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = 4.54. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 5.18. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nindustrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = (Note 2). D005G, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . D005G, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = PIC18F1220/1320 Industrial (-10 \uf0b0 C to +85 \uf0b0 C). D005G, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = PIC18F1220/1320 Industrial (-10 \uf0b0 C to +85 \uf0b0 C). D005G, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = PIC18F1220/1320 Industrial (-10 \uf0b0 C to +85 \uf0b0 C). D005G, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = PIC18F1220/1320 Industrial (-10 \uf0b0 C to +85 \uf0b0 C). D005G, Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = PIC18F1220/1320 Industrial (-10 \uf0b0 C to +85 \uf0b0 C). D005G, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = PIC18F1220/1320 Industrial (-10 \uf0b0 C to +85 \uf0b0 C). , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 1x. , Standard Operating Conditions (unless otherwise stated)",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nOperating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nfor industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Reserved. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 01. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 3.88. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nT A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = 4.22. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 4.56. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+125\u00b0C for extended.Conditions = (Note 2). , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 00. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 4.18. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = 4.54. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nA \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 4.90. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = (Note 2). D005H, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . D005H, PIC18LF1220/1320",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n(Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = PIC18F1220/1320 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). D005H, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = PIC18F1220/1320 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). D005H, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = PIC18F1220/1320 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). D005H, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = PIC18F1220/1320 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). D005H, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = PIC18F1220/1320 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). D005H, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = PIC18F1220/1320 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). ,",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nPIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 1x. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nstated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Reserved. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 01. ,",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Reserved. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 00. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 3.90. , Standard Operating Conditions",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n(unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = 4.54. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 5.18. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = (Note 2). D005J, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . D005J, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = PIC18F1220/1320 Extended (-10 \uf0b0 C to +85 \uf0b0 C). D005J, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = PIC18F1220/1320 Extended (-10 \uf0b0 C to +85 \uf0b0 C). D005J, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\ntemperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = PIC18F1220/1320 Extended (-10 \uf0b0 C to +85 \uf0b0 C). D005J, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = PIC18F1220/1320 Extended (-10 \uf0b0 C to +85 \uf0b0 C). D005J, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = PIC18F1220/1320 Extended (-10 \uf0b0 C to +85 \uf0b0 C). D005J, Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = PIC18F1220/1320 Extended (-10 \uf0b0 C to +85 \uf0b0 C). , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 1x. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n(unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Reserved. ,",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nPIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 01. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 3.88. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = 4.22. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nstated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 4.56. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = (Note 3). , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 =",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n00. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = 4.18. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = 4.54. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = 4.90. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\ntemperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = (Note 3). D005K, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . D005K, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = PIC18F1220/1320 Extended (-40 \uf0b0 C to -10 \uf0b0 C, +85 \uf0b0 C to. D005K, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nfor industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = . D005K, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = . D005K, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = . D005K, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = . D005K, Standard Operating Conditions (unless otherwise stated) Operating",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\ntemperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +125 \uf0b0 C). , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 1x. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = N/A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Reserved. , PIC18LF1220/1320",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n(Industrial).PIC18F1220/1320 (Industrial, Extended).Symbol = . , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial, Extended).Characteristic = BORV1:BORV0 = 01 BORV1:BORV0 = 00. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min. = N/A 3.90. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ. = N/A 4.54. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\nindustrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max. = N/A 5.18. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Reserved (Note 3)\nLegend:\nShading of rows is to assist in readability of the table.\nNote",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)\n1: This is the limit to which VDD can be lowered in Sleep mode, or during a device Reset, without losing RAM data.\n2: When BOR is on and BORV<1:0> = 0x , the device will operate correctly at 40 MHz for any VDD at which the BOR allows execution (low-voltage and industrial devices only).\n3: When BOR is on and BORV<1:0> = 0x , the device will operate correctly at 25 MHz for any VDD at which the BOR allows execution (extended devices only).",
    "22.2\nDC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial)",
    "22.2\nPower-Down Current (I PD ) (1), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = Power-Down Current (I PD ) (1). Power-Down Current (I PD ) (1), Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = Power-Down Current (I PD ) (1). Power-Down Current (I PD ) (1), Standard Operating Operating temperature.Standard Operating Operating temperature.Units = Power-Down Current (I PD ) (1). Power-Down Current (I PD ) (1), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Power-Down Current (I PD ) (1). Power-Down Current (I PD ) (1), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions =",
    "22.2\nPower-Down Current (I PD ) (1). PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 0.1. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 0.5. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = -40\u00b0C. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD = 2.0V, ( Sleep mode). PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. =",
    "22.2\n0.1. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 0.5. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +25\u00b0C. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD = 2.0V, ( Sleep mode). PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 0.2. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 1.9.",
    "22.2\nPIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +85\u00b0C. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD = 2.0V, ( Sleep mode). PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 0.1. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 0.5. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise",
    "22.2\nstated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = -40\u00b0C. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 0.1. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 0.5. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +",
    "22.2\n25\u00b0C. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 0.3. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 1.9. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +85\u00b0C. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "22.2\nindustrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 0.1. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 2.0. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. All devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = -40\u00b0C. All devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 0.1. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 2.0. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. All devices, Conditions",
    "22.2\n(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +25\u00b0C. All devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 0.4. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 6.5. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. All devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +85\u00b0C. All devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions",
    "22.2\n(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . Extended devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 11.2. Extended devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 50. Extended devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. Extended devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +125\u00b0C. Extended devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . Current (I DD) (2,3), Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = . Current (I DD) (2,3), Standard Operating Operating temperature.Standard Operating Operating",
    "22.2\ntemperature.Max. = . Current (I DD) (2,3), Standard Operating Operating temperature.Standard Operating Operating temperature.Units = . Current (I DD) (2,3), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . Current (I DD) (2,3), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 8. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 40. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3",
    "22.2\n+85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = -40\u00b0C. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 9. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 40. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +25\u00b0C VDD.",
    "22.2\nPIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 11. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 40. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +85\u00b0C. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "22.2\n+125\u00b0C for extended.Conditions = . PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 25. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 68. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = -40\u00b0C. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 25. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating",
    "22.2\ntemperature.Max. = 68. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +25\u00b0C VDD. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 20. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 68. PIC18LF1220/1320, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3",
    "22.2\n+85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +85\u00b0C. PIC18LF1220/1320, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 55. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 80. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. All devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = -40\u00b0C VDD = 5.0V. All devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless",
    "22.2\notherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 55. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 80. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. All devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +25\u00b0C. All devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 50. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 80. All devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d",
    "22.2\nA. All devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +85\u00b0C. All devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . Extended devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Typ. = 50. Extended devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Max. = 80. Extended devices, Standard Operating Operating temperature.Standard Operating Operating temperature.Units = \uf06d A. Extended devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = +125\u00b0C. Extended devices, Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "22.2\nindustrial.Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = \nLegend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "22.2\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nPIC18LF1220/1320\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18F1220/1320\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nSupply, Device = Current (I DD) (2,3). Supply, Typ. = . Supply, Max. = . Supply, Units = . Supply, Conditions = . Supply, Conditions = . Supply, Conditions = . , Device = PIC18LF1220/1320. , Typ. = 140. , Max. = 220. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 145. , Max. = 220. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 155. , Max. = 220. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 215. , Max. =",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n330. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 225. , Max. = 330. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 235. , Max. = 330. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ. = 385. , Max. = 550. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 390. , Max. = 550. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . ,",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nDevice = All devices. , Typ. = 405. , Max. = 550. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = Extended devices. , Typ. = 410. , Max. = 650. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 410. , Max. = 600. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 425. , Max. = 600. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 435. , Max. = 600. , Units = \uf06d A. , Conditions",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n= +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 650. , Max. = 900. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 670. , Max. = 900. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 680. , Max. = 900. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Conditions = . , Device = All devices. , Typ. = 1.2. , Max. = 1.8. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 1.2. , Max. =",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n1.8. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 1.2. , Max. = 1.8. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = Extended devices. , Typ. = 1.2. , Max. = 1.8. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = ",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nPIC18LF1220/1320\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18F1220/1320\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nSupply, Device = Current (I DD) (2,3). Supply, Typ. = . Supply, Max. = . Supply, Units = . Supply, Conditions = . Supply, Conditions = . Supply, Conditions = . , Device = PIC18LF1220/1320. , Typ. = 4.7. , Max. = 8. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 5.0. , Max. = 8. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 5.8. , Max. = 11. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device =",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nPIC18LF1220/1320. , Typ. = 7.0. , Max. = 11. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 7.8. , Max. = 11. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 8.7. , Max. = 15. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ. = 12. , Max. = 16. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 14.",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n, Max. = 16. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 14. , Max. = 22. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = Extended devices. , Typ. = 25. , Max. = 75. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 75. , Max. = 150. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 85. , Max. = 150. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions =",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nVDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 95. , Max. = 150. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 110. , Max. = 180. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 125. , Max. = 180. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 135. , Max. = 180. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n= . , Device = All devices. , Typ. = 180. , Max. = 380. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 195. , Max. = 380. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 200. , Max. = 380. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = Extended devices. , Typ. = 350. , Max. = 435. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = ",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nPIC18LF1220/1320\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3\n+85\u00b0C for industrial\nPIC18F1220/1320\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2,3). , Typ. = . , Max. = . , Units = . , Conditions = . , Conditions = . , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 140. , Max. = 275. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 140. , Max. = 275. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 150. , Max. = 275. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 220. , Max. = 375. , Units = \uf06d A.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n, Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 220. , Max. = 375. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 220. , Max. = 375. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ. = 390. , Max. = 800. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 400. , Max. = 800. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. ,",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nTyp. = 380. , Max. = 800. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = Extended devices. , Typ. = 410. , Max. = 800. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 150. , Max. = 250. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 150. , Max. = 250. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 160. , Max. = 250. , Units = \uf06d A. , Conditions = +85\u00b0C.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n, Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 340. , Max. = 350. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 300. , Max. = 350. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 280. , Max. = 350. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Conditions = . , Device = All devices. , Typ. = 0.72. , Max. = 1.0. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 0.63. , Max. = 1.0. , Units =",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nmA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 0.58. , Max. = 1.0. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = Extended devices. , Typ. = 0.53. , Max. = 1.0. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = ",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nPIC18LF1220/1320\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18F1220/1320\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2,3). , Typ. = Supply Current (I DD) (2,3). , Max. = Supply Current (I DD) (2,3). , Units = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Device = PIC18LF1220/1320. , Typ. = 415. , Max. = 600. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 425. , Max. = 600. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device =",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nPIC18LF1220/1320. , Typ. = 435. , Max. = 600. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 0.87. , Max. = 1.0. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 0.75. , Max. = 1.0. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 0.75. , Max. = 1.0. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . ,",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nDevice = All devices. , Typ. = 1.6. , Max. = 2.0. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 1.6. , Max. = 2.0. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 1.5. , Max. = 2.0. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = Extended devices. , Typ. = 1.5. , Max. = 2.0. , Units = mA. , Conditions = +125\u00b0C. , Conditions = . , Conditions = . , Device = Extended devices. , Typ. = 6.3. , Max. = 9.0. , Units =",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nmA. , Conditions = +125\u00b0C. , Conditions = VDD = 4.2V. , Conditions = . , Device = Extended devices. , Typ. = 9.7. , Max. = 10.0. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 9.4. , Max. = 12. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 4.2V. , Conditions = . , Device = All devices. , Typ. = 9.5. , Max. = 12. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 4.2V. , Conditions = . , Device = All devices. , Typ. = 9.6. , Max. = 12. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 4.2V. , Conditions =",
    "DC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n. , Device = All devices. , Typ. = 11.9. , Max. = 15. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 12.1. , Max. = 15. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 12.2. , Max. = 15. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = ",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nPIC18LF1220/1320\n(Industrial)\nPIC18F1220/1320\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nSupply Current, Device = (I DD) (2,3). Supply Current, Typ. = . Supply Current, Max. = . Supply Current, Units = . Supply Current, Conditions = . Supply Current, Conditions = . Supply Current, Conditions = . , Device = PIC18LF1220/1320. , Typ. = 35. , Max. = 50. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 35. , Max. = 50. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 35. , Max. = 60. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. =",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n55. , Max. = 80. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 50. , Max. = 80. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 60. , Max. = 100. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ. = 105. , Max. = 150. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 110. , Max. = 150. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD =",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n5.0V. , Conditions = . , Device = All devices. , Typ. = 115. , Max. = 150. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = Extended devices. , Typ. = 125. , Max. = 300. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = . , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 135. , Max. = 180. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 140. , Max. = 180. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 140. , Max. = 180. , Units = \uf06d",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nA. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 215. , Max. = 280. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 225. , Max. = 280. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF1220/1320. , Typ. = 230. , Max. = 280. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ. = 410. , Max. = 525. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = .",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n, Device = All devices. , Typ. = 420. , Max. = 525. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ. = 430. , Max. = 525. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = Extended devices. , Typ. = 450. , Max. = 800. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = . , Conditions = . , Device = Extended devices. , Typ. = 2.2. , Max. = 3.0. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 25 MHz ( PRI_IDLE mode, EC oscillator). , Device = Extended devices. , Typ. = 2.7. , Max. = 3.5. , Units = mA.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n, Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 25 MHz ( PRI_IDLE mode, EC oscillator)\nLegend: Shading of rows is to assist in readability of the table.\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "22.2\nDC Characteristics: Power-Down and Supply Current PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nPIC18LF1220/1320\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18F1220/1320\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "22.2\n, Device = Supply Current (I DD) (2,3). , Typ. = Supply Current (I DD) (2,3). , Max. = Supply Current (I DD) (2,3). , Units = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Device = All devices. , Typ. = 3.2. , Max. = 4.1. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 4.2 V. , Conditions = FOSC = 40 MHz ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ. = 3.2. , Max. = 4.1. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 4.2 V. , Conditions = FOSC = 40 MHz ( PRI_IDLE mode, EC oscillator). , Device = All devices. ,",
    "22.2\nTyp. = 3.3. , Max. = 4.1. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 4.2 V. , Conditions = FOSC = 40 MHz ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ. = 4.0. , Max. = 5.1. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHz ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ. = 4.1. , Max. = 5.1. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHz ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ. = 4.1. , Max. = 5.1. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC",
    "22.2\n= 40 MHz ( PRI_IDLE mode, EC oscillator). , Device = PIC18LF1220/1320. , Typ. = 5.1. , Max. = 9. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_RUN mode, Timer1 as clock). , Device = PIC18LF1220/1320. , Typ. = 5.8. , Max. = 9. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_RUN mode, Timer1 as clock). , Device = PIC18LF1220/1320. , Typ. = 7.9. , Max. = 11. , Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_RUN mode, Timer1 as clock). , Device = PIC18LF1220/1320.",
    "22.2\n, Typ. = 7.9. , Max. = 12. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = . , Conditions = FOSC = 32 kHz (4) ( SEC_RUN mode, Timer1 as clock). , Device = PIC18LF1220/1320. , Typ. = 8.9. , Max. = 12. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Conditions = FOSC = 32 kHz (4) ( SEC_RUN mode, Timer1 as clock). , Device = PIC18LF1220/1320. , Typ. = 10.5. , Max. = 14. , Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = . , Conditions = FOSC = 32 kHz (4) ( SEC_RUN mode, Timer1 as clock). , Device = All devices. , Typ. = 12.5. , Max. = 20. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_RUN",
    "22.2\nmode, Timer1 as clock). , Device = All devices. , Typ. = 16.3. , Max. = 20. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_RUN mode, Timer1 as clock). , Device = All devices. , Typ. = 18.4. , Max. = 25. , Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_RUN mode, Timer1 as clock)",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nPIC18LF1220/1320\n(Industrial)\nPIC18F1220/1320\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2,3). , Typ. = Supply Current (I DD) (2,3). , Max. = Supply Current (I DD) (2,3). , Units = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Device = PIC18LF1220/1320. , Typ. = 9.2. , Max. = 15. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_IDLE mode, Timer1 as clock). , Device = PIC18LF1220/1320. , Typ. = 9.6. , Max. = 15. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD =",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n2.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_IDLE mode, Timer1 as clock). , Device = PIC18LF1220/1320. , Typ. = 12.7. , Max. = 18. , Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_IDLE mode, Timer1 as clock). , Device = PIC18LF1220/1320. , Typ. = 22. , Max. = 30. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_IDLE mode, Timer1 as clock). , Device = PIC18LF1220/1320. , Typ. = 21. , Max. = 30. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions =",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nFOSC = 32 kHz (4) ( SEC_IDLE mode, Timer1 as clock). , Device = PIC18LF1220/1320. , Typ. = 20. , Max. = 35. , Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_IDLE mode, Timer1 as clock). , Device = All devices. , Typ. = 50. , Max. = 80. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_IDLE mode, Timer1 as clock). , Device = All devices. , Typ. = 45. , Max. = 80. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_IDLE mode, Timer1 as clock). , Device =",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nAll devices. , Typ. = 45. , Max. = 80. , Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 32 kHz (4) ( SEC_IDLE mode, Timer1 as clock)",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nPIC18LF1220/1320\n(Industrial)\nPIC18F1220/1320\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nD022 ( \uf044 I WDT), Device = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Typ. = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Max. = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Units = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Conditions = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Conditions = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Conditions = Module Differential Currents ( \uf044 I",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nWDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ. = 1.5. D022 ( \uf044 I WDT), Max. = 4.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = -40\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 2.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ. = 2.2. D022 ( \uf044 I WDT), Max. = 4.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +25\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 2.0V. D022 ( \uf044 I",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nWDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ. = 3.1. D022 ( \uf044 I WDT), Max. = 5.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +85\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 2.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ. = 2.5. D022 ( \uf044 I WDT), Max. = 6.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = -40\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 3.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nWDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ. = 3.3. D022 ( \uf044 I WDT), Max. = 6.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +25\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 3.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ. = 4.7. D022 ( \uf044 I WDT), Max. = 7.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +85\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 3.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nWDT), Typ. = 3.7. D022 ( \uf044 I WDT), Max. = 10.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = -40\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 5.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ. = 4.5. D022 ( \uf044 I WDT), Max. = 10.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +25\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 5.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ. = 6.1. D022",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n( \uf044 I WDT), Max. = 13.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +85\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 5.0V. D022 ( \uf044 I WDT), Conditions = . D022A ( \uf044 I BOR), Device = Brown-out Reset. D022A ( \uf044 I BOR), Typ. = 19. D022A ( \uf044 I BOR), Max. = 35.0. D022A ( \uf044 I BOR), Units = \uf06d A. D022A ( \uf044 I BOR), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022A ( \uf044 I BOR), Conditions = VDD = 3.0V. D022A ( \uf044 I BOR), Conditions = . D022A ( \uf044 I BOR), Device = Brown-out Reset. D022A ( \uf044 I BOR), Typ. = 24. D022A ( \uf044 I",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nBOR), Max. = 45.0. D022A ( \uf044 I BOR), Units = \uf06d A. D022A ( \uf044 I BOR), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022A ( \uf044 I BOR), Conditions = VDD = 5.0V. D022A ( \uf044 I BOR), Conditions = . D022B ( \uf044 I LVD ), Device = Low-Voltage Detect. D022B ( \uf044 I LVD ), Typ. = 8.5. D022B ( \uf044 I LVD ), Max. = 25.0. D022B ( \uf044 I LVD ), Units = \uf06d A. D022B ( \uf044 I LVD ), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions = VDD = 2.0V. D022B ( \uf044 I LVD ), Conditions = . D022B ( \uf044 I LVD ), Device = Low-Voltage Detect. D022B ( \uf044 I LVD ), Typ. = 16.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nD022B ( \uf044 I LVD ), Max. = 35.0. D022B ( \uf044 I LVD ), Units = \uf06d A. D022B ( \uf044 I LVD ), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions = VDD = 3.0V. D022B ( \uf044 I LVD ), Conditions = . D022B ( \uf044 I LVD ), Device = Low-Voltage Detect. D022B ( \uf044 I LVD ), Typ. = 20. D022B ( \uf044 I LVD ), Max. = 45.0. D022B ( \uf044 I LVD ), Units = \uf06d A. D022B ( \uf044 I LVD ), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions = VDD = 5.0V. D022B ( \uf044 I LVD ), Conditions = . D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\n= 1.7. D025 ( \uf044 I OSCB), Max. = 3.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = -40 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 2.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ. = 1.8. D025 ( \uf044 I OSCB), Max. = 3.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +25 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 2.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nOSCB), Typ. = 2.1. D025 ( \uf044 I OSCB), Max. = 4.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +85 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 2.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ. = 2.2. D025 ( \uf044 I OSCB), Max. = 4.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = -40 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 3.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator.",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nD025 ( \uf044 I OSCB), Typ. = 2.6. D025 ( \uf044 I OSCB), Max. = 4.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +25 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 3.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ. = 2.8. D025 ( \uf044 I OSCB), Max. = 5.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +85 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 3.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nOscillator. D025 ( \uf044 I OSCB), Typ. = 3.0. D025 ( \uf044 I OSCB), Max. = 6.0. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = -40 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 5.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ. = 3.3. D025 ( \uf044 I OSCB), Max. = 6.0. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +25 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 5.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nOSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ. = 3.6. D025 ( \uf044 I OSCB), Max. = 7.0. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +85 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 5.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D026 ( \uf044 I AD), Device = A/D Converter. D026 ( \uf044 I AD), Typ. = 1.0. D026 ( \uf044 I AD), Max. = 3.0. D026 ( \uf044 I AD), Units = \uf06d A. D026 ( \uf044 I AD), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D026 ( \uf044 I AD), Conditions = VDD = 2.0V VDD = 3.0V. D026 ( \uf044 I AD), Conditions = A/D on, not",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nconverting. D026 ( \uf044 I AD), Device = A/D Converter. D026 ( \uf044 I AD), Typ. = 1.0. D026 ( \uf044 I AD), Max. = 4.0. D026 ( \uf044 I AD), Units = \uf06d A. D026 ( \uf044 I AD), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D026 ( \uf044 I AD), Conditions = . D026 ( \uf044 I AD), Conditions = A/D on, not converting. D026 ( \uf044 I AD), Device = A/D Converter. D026 ( \uf044 I AD), Typ. = 2.0. D026 ( \uf044 I AD), Max. = 10.0. D026 ( \uf044 I AD), Units = \uf06d A. D026 ( \uf044 I AD), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D026 ( \uf044 I AD), Conditions = VDD = 5.0V. D026 ( \uf044 I AD), Conditions = A/D on, not converting. D026 ( \uf044 I AD), Device =",
    "PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nA/D Converter. D026 ( \uf044 I AD), Typ. = 1.0. D026 ( \uf044 I AD), Max. = 8.0. D026 ( \uf044 I AD), Units = \uf06d A. D026 ( \uf044 I AD), Conditions = -40 \uf0b0 C to +125 \uf0b0 C. D026 ( \uf044 I AD), Conditions = VDD = 5.0V. D026 ( \uf044 I AD), Conditions = A/D on, not converting",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18LF1220/1320 (Industrial)\nDC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3\uf020 TA \uf0a3 +125\u00b0C for extended",
    "PIC18LF1220/1320 (Industrial)\nD030 D030A D031 D032 D032A, Symbol = VIL. D030 D030A D031 D032 D032A, Characteristic = Input Low Voltage I/O ports: with TTL buffer. D030 D030A D031 D032 D032A, Min. = VSS - VSS VSS VSS VSS. D030 D030A D031 D032 D032A, Max. = 0.15 VDD 0.8 0.2 VDD 0.2 VDD 0.3 VDD. D030 D030A D031 D032 D032A, Units = V V V V V. D030 D030A D031 D032 D032A, Conditions = VDD < 4.5V 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V. D033 D040, Symbol = VIH. D033 D040, Characteristic = OSC1 (in RC and EC mode) Input High Voltage I/O ports: with TTL buffer. D033",
    "PIC18LF1220/1320 (Industrial)\nD040, Min. = 0.25 VDD + 0.8V 2.0. D033 D040, Max. = 0.2 VDD VDD. D033 D040, Units = V V. D033 D040, Conditions = VDD < 4.5V 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V. D041 D042, Symbol = . D041 D042, Characteristic = with Schmitt Trigger buffer MCLR, OSC1 (EC mode) OSC1 (in XT, HSand LP modes). D041 D042, Min. = 0.8 VDD 0.8 VDD 1.6 VDD. D041 D042, Max. = VDD VDD. D041 D042, Units = V V V. D041 D042, Conditions = . D042A D043, Symbol = . D042A D043, Characteristic = and T1OSI OSC1 (RC mode) (1) (2,3). D042A D043, Min. =",
    "PIC18LF1220/1320 (Industrial)\n0.9 VDD. D042A D043, Max. = VDD. D042A D043, Units = V. D042A D043, Conditions = . D060, Symbol = I IL. D060, Characteristic = Input Leakage Current I/O ports. D060, Min. = -. D060, Max. = VDD \uf0b1 1. D060, Units = . D060, Conditions = VSS \uf0a3\uf020 VPIN \uf0a3\uf020 VDD,. , Symbol = . , Characteristic = . , Min. = . , Max. = . , Units = \uf06d A. , Conditions = Pin at high-impedance. D061, Symbol = . D061, Characteristic = MCLR OSC1. D061, Min. = - -. D061, Max. = \uf0b1 5. D061, Units = \uf06d A. D061, Conditions = VSS \uf0a3\uf020 VPIN \uf0a3\uf020 VDD VSS \uf0a3\uf020 VPIN \uf0a3\uf020 VDD. D063, Symbol = . D063, Characteristic = Weak Pull-up Current. D063, Min. = .",
    "PIC18LF1220/1320 (Industrial)\nD063, Max. = \uf0b1 5. D063, Units = \uf06d A. D063, Conditions = . , Symbol = I PURB. , Characteristic = PORTB weak pull-up current. , Min. = 50. , Max. = . , Units = . , Conditions = VDD = 5V, VPIN = VSS. D070, Symbol = I PU. D070, Characteristic = . D070, Min. = . D070, Max. = 400. D070, Units = \uf06d A. D070, Conditions = \nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PIC \u00ae  device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.",
    "22.3 DC Characteristics: PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nDC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3\uf020 TA \uf0a3 +125\u00b0C for extended",
    "22.3 DC Characteristics: PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nD080, Symbol = VOL. D080, Characteristic = Output Low Voltage I/O ports. D080, Min. = -. D080, Max. = 0.6. D080, Units = V. D080, Conditions = I OL = 8.5 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D083, Symbol = . D083, Characteristic = OSC2/CLKO (RC mode). D083, Min. = -. D083, Max. = 0.6. D083, Units = V. D083, Conditions = I OL = 1.6 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D090, Symbol = VOH. D090, Characteristic = Output High Voltage (3) I/O ports. D090, Min. = VDD - 0.7. D090, Max. = -. D090, Units = V.",
    "22.3 DC Characteristics: PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nD090, Conditions = I OH = -3.0 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D092, Symbol = . D092, Characteristic = OSC2/CLKO (RC mode). D092, Min. = VDD - 0.7. D092, Max. = -. D092, Units = V. D092, Conditions = I OH = -1.3 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D150, Symbol = VOD. D150, Characteristic = Open-Drain High Voltage. D150, Min. = -. D150, Max. = 8.5. D150, Units = V. D150, Conditions = RA4 pin. D100 (4), Symbol = COSC2. D100 (4), Characteristic = OSC2 pin. D100 (4), Min. = -. D100 (4),",
    "22.3 DC Characteristics: PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nMax. = 15. D100 (4), Units = pF. D100 (4), Conditions = In XT, HS and LP modes when external clock is used to drive OSC1. D101, Symbol = CIO. D101, Characteristic = All I/O pins and OSC2 (in RC mode). D101, Min. = -. D101, Max. = 50. D101, Units = pF. D101, Conditions = To meet the AC timing specifications. D102, Symbol = CB. D102, Characteristic = SCL, SDA. D102, Min. = -. D102, Max. = 400. D102, Units = pF. D102, Conditions = In I 2 C mode",
    "22.3 DC Characteristics: PIC18F1220/1320 (Industrial) PIC18LF1220/1320 (Industrial) (Continued)\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PIC \u00ae  device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.",
    "DC CHARACTERISTICS\n, Sym. = . , Characteristic = Internal Program Memory Programming Specifications (1). , Min. = . , Typ\u2020 = . , Max. = . , Units = . , Conditions = . D110, Sym. = VPP. D110, Characteristic = Voltage on MCLR/VPP pin. D110, Min. = 9.00. D110, Typ\u2020 = -. D110, Max. = 13.25. D110, Units = V. D110, Conditions = (Note 2). D112, Sym. = I PP. D112, Characteristic = Current into MCLR/VPP pin. D112, Min. = -. D112, Typ\u2020 = -. D112, Max. = 5. D112, Units = \uf06d A. D112, Conditions = . D113, Sym. = I DDP. D113, Characteristic = Supply Current during Programming. D113, Min. = -. D113, Typ\u2020 = -. D113, Max. = 10. D113, Units = mA. D113, Conditions = .",
    "DC CHARACTERISTICS\n, Sym. = . , Characteristic = Data EEPROM Memory. , Min. = . , Typ\u2020 = . , Max. = . , Units = . , Conditions = . D120, Sym. = ED. D120, Characteristic = Byte Endurance. D120, Min. = 100K. D120, Typ\u2020 = 1M. D120, Max. = -. D120, Units = E/W. D120, Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D121, Sym. = VDRW. D121, Characteristic = VDD for Read/Write. D121, Min. = VMIN. D121, Typ\u2020 = -. D121, Max. = 5.5. D121, Units = V. D121, Conditions = Using EECON to read/write VMIN = Minimum operating voltage. D122, Sym. = TDEW. D122, Characteristic = Erase/Write Cycle Time. D122, Min. = -. D122, Typ\u2020 = 4. D122, Max. = -. D122, Units =",
    "DC CHARACTERISTICS\nms. D122, Conditions = . D123, Sym. = TRETD. D123, Characteristic = Characteristic Retention. D123, Min. = 40. D123, Typ\u2020 = -. D123, Max. = -. D123, Units = Year. D123, Conditions = Provided no other specifications are violated. D124, Sym. = TREF. D124, Characteristic = Number of Total Erase/Write Cycles before Refresh (3). D124, Min. = 1M. D124, Typ\u2020 = 10M. D124, Max. = -. D124, Units = E/W. D124, Conditions = -40\u00b0C to +85\u00b0C. , Sym. = . , Characteristic = Program Flash Memory. , Min. = . , Typ\u2020 = . , Max. = . , Units = . , Conditions = . D130, Sym. = EP. D130, Characteristic = Cell Endurance. D130, Min. = 10K. D130, Typ\u2020 = 100K. D130, Max. = -.",
    "DC CHARACTERISTICS\nD130, Units = E/W. D130, Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D131, Sym. = VPR. D131, Characteristic = VDD for Read. D131, Min. = VMIN. D131, Typ\u2020 = -. D131, Max. = 5.5. D131, Units = V. D131, Conditions = VMIN = Minimum operating voltage. D132, Sym. = VIE. D132, Characteristic = VDD for Block Erase. D132, Min. = 4.5. D132, Typ\u2020 = -. D132, Max. = 5.5. D132, Units = V. D132, Conditions = Using ICSP port. D132A, Sym. = VIW. D132A, Characteristic = VDD for Externally Timed Erase or Write. D132A, Min. = 4.5. D132A, Typ\u2020 = -. D132A, Max. = 5.5. D132A, Units = V. D132A, Conditions = Using ICSP",
    "DC CHARACTERISTICS\nport. D132B, Sym. = VPEW. D132B, Characteristic = VDD for Self-Timed Write. D132B, Min. = VMIN. D132B, Typ\u2020 = -. D132B, Max. = 5.5. D132B, Units = V. D132B, Conditions = VMIN = Minimum operating voltage. D133, Sym. = TIE. D133, Characteristic = ICSP\u2122 Block Erase Cycle Time. D133, Min. = -. D133, Typ\u2020 = 4. D133, Max. = -. D133, Units = ms. D133, Conditions = VDD > 4.5V. D133A, Sym. = TIW. D133A, Characteristic = ICSP Erase or Write Cycle Time (externally timed). D133A, Min. = 1. D133A, Typ\u2020 = -. D133A, Max. = -. D133A, Units = ms. D133A, Conditions = VDD > 4.5V. D133A, Sym.",
    "DC CHARACTERISTICS\n= TIW. D133A, Characteristic = Self-Timed Write Cycle Time. D133A, Min. = -. D133A, Typ\u2020 = 2. D133A, Max. = -. D133A, Units = ms. D133A, Conditions = . D134, Sym. = TRETD. D134, Characteristic = Characteristic Retention. D134, Min. = 40. D134, Typ\u2020 = -. D134, Max. = -. D134, Units = Year. D134, Conditions = Provided no other specifications are violated\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial",
    "DC CHARACTERISTICS\n\u2020 Data in 'Typ' column is at 5.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: These specifications are for programming the on-chip program memory through the use of table write instructions.\n2: The pin may be kept in this range at times other than programming, but it is not recommended.\n3: Refer to Section 7.8 'Using the Data EEPROM' for a more detailed discussion on data EEPROM endurance.",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nPIC18LF1220/1320\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18F1220/1320\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended\n\nLegend: Shading of rows is to assist in readability of the table.",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420D, Symbol = . D420D, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420D, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420D, Min. = Industrial Low Voltage (-10\u00b0C to +85\u00b0C). D420D, Typ\u2020 = Industrial Low Voltage (-10\u00b0C to +85\u00b0C). D420D, Max. = Industrial Low Voltage (-10\u00b0C to +85\u00b0C). D420D, Units = Industrial Low Voltage (-10\u00b0C to +85\u00b0C). D420D, Conditions = Industrial Low Voltage (-10\u00b0C to +85\u00b0C). D420D, Symbol = . D420D, Characteristic = PIC18LF1220/1320. D420D, Characteristic = LVDL<3:0> = 0000. D420D, Min. = N/A. D420D, Typ\u2020 = N/A. D420D, Max. = N/A.",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420D, Units = V. D420D, Conditions = Reserved. D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 0001. D420D, Min. = N/A. D420D, Typ\u2020 = N/A. D420D, Max. = N/A. D420D, Units = V. D420D, Conditions = Reserved. D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 0010. D420D, Min. = 2.08. D420D, Typ\u2020 = 2.26. D420D, Max. = 2.44. D420D, Units = V. D420D, Conditions = . D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 0011. D420D, Min. = 2.26.",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420D, Typ\u2020 = 2.45. D420D, Max. = 2.65. D420D, Units = V. D420D, Conditions = . D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 0100. D420D, Min. = 2.35. D420D, Typ\u2020 = 2.55. D420D, Max. = 2.76. D420D, Units = V. D420D, Conditions = . D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 0101. D420D, Min. = 2.55. D420D, Typ\u2020 = 2.77. D420D, Max. = 2.99. D420D, Units = V. D420D, Conditions = . D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic =",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nLVDL<3:0> = 0110. D420D, Min. = 2.64. D420D, Typ\u2020 = 2.87. D420D, Max. = 3.10. D420D, Units = V. D420D, Conditions = . D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 0111. D420D, Min. = 2.82. D420D, Typ\u2020 = 3.07. D420D, Max. = 3.31. D420D, Units = V. D420D, Conditions = . D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 1000. D420D, Min. = 3.09. D420D, Typ\u2020 = 3.36. D420D, Max. = 3.63. D420D, Units = V. D420D, Conditions = .",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 1001. D420D, Min. = 3.29. D420D, Typ\u2020 = 3.57. D420D, Max. = 3.86. D420D, Units = V. D420D, Conditions = . D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 1010. D420D, Min. = 3.38. D420D, Typ\u2020 = 3.67. D420D, Max. = 3.96. D420D, Units = V. D420D, Conditions = . D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 1011. D420D, Min. = 3.56. D420D, Typ\u2020 = 3.87. D420D, Max. =",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS\n4.18. D420D, Units = V. D420D, Conditions = . D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 1100. D420D, Min. = 3.75. D420D, Typ\u2020 = 4.07. D420D, Max. = 4.40. D420D, Units = V. D420D, Conditions = . D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 1101. D420D, Min. = 3.93. D420D, Typ\u2020 = 4.28. D420D, Max. = 4.62. D420D, Units = V. D420D, Conditions = . D420D, Symbol = . D420D, Characteristic = . D420D, Characteristic = LVDL<3:0> = 1110. D420D, Min. = 4.23.",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420D, Typ\u2020 = 4.60. D420D, Max. = 4.96. D420D, Units = V. D420D, Conditions = \n- \u2020 Production tested at TAMB = 25\u00b0C. Specifications over temperature limits ensured by characterization.",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nPIC18LF1220/1320\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18F1220/1320\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nD420F, Symbol = . D420F, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420F, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420F, Min. = Industrial Low Voltage (-40\u00b0C to -10\u00b0C). D420F, Typ\u2020 = Industrial Low Voltage (-40\u00b0C to -10\u00b0C). D420F, Max. = Industrial Low Voltage (-40\u00b0C to -10\u00b0C). D420F, Units = Industrial Low Voltage (-40\u00b0C to -10\u00b0C). D420F, Conditions = Industrial Low Voltage (-40\u00b0C to -10\u00b0C). D420F, Symbol = . D420F, Characteristic = PIC18LF1220/1320. D420F, Characteristic = LVDL<3:0> = 0000. D420F, Min. = N/A. D420F, Typ\u2020 = N/A. D420F, Max. = N/A.",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nD420F, Units = V. D420F, Conditions = Reserved. D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 0001. D420F, Min. = N/A. D420F, Typ\u2020 = N/A. D420F, Max. = N/A. D420F, Units = V. D420F, Conditions = Reserved. D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 0010. D420F, Min. = 1.99. D420F, Typ\u2020 = 2.26. D420F, Max. = 2.53. D420F, Units = V. D420F, Conditions = . D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 0011. D420F, Min. =",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\n2.16. D420F, Typ\u2020 = 2.45. D420F, Max. = 2.75. D420F, Units = V. D420F, Conditions = . D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 0100. D420F, Min. = 2.25. D420F, Typ\u2020 = 2.55. D420F, Max. = 2.86. D420F, Units = V. D420F, Conditions = . D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 0101. D420F, Min. = 2.43. D420F, Typ\u2020 = 2.77. D420F, Max. = 3.10. D420F, Units = V. D420F, Conditions = . D420F, Symbol = . D420F, Characteristic = .",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nD420F, Characteristic = LVDL<3:0> = 0110. D420F, Min. = 2.53. D420F, Typ\u2020 = 2.87. D420F, Max. = 3.21. D420F, Units = V. D420F, Conditions = . D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 0111. D420F, Min. = 2.70. D420F, Typ\u2020 = 3.07. D420F, Max. = 3.43. D420F, Units = V. D420F, Conditions = . D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 1000. D420F, Min. = 2.96. D420F, Typ\u2020 = 3.36. D420F, Max. = 3.77. D420F, Units = V.",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nD420F, Conditions = . D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 1001. D420F, Min. = 3.14. D420F, Typ\u2020 = 3.57. D420F, Max. = 4.00. D420F, Units = V. D420F, Conditions = . D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 1010. D420F, Min. = 3.23. D420F, Typ\u2020 = 3.67. D420F, Max. = 4.11. D420F, Units = V. D420F, Conditions = . D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 1011. D420F, Min. = 3.41. D420F, Typ\u2020 =",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\n3.87. D420F, Max. = 4.34. D420F, Units = V. D420F, Conditions = . D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 1100. D420F, Min. = 3.58. D420F, Typ\u2020 = 4.07. D420F, Max. = 4.56. D420F, Units = V. D420F, Conditions = . D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> = 1101. D420F, Min. = 3.76. D420F, Typ\u2020 = 4.28. D420F, Max. = 4.79. D420F, Units = V. D420F, Conditions = . D420F, Symbol = . D420F, Characteristic = . D420F, Characteristic = LVDL<3:0> =",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\n1110. D420F, Min. = 4.04. D420F, Typ\u2020 = 4.60. D420F, Max. = 5.15. D420F, Units = V. D420F, Conditions = . , Symbol = . , Characteristic = LVD Voltage on VDD Transition High-to-Low. , Characteristic = LVD Voltage on VDD Transition High-to-Low. , Min. = Industrial (-10\u00b0C to +85\u00b0C). , Typ\u2020 = Industrial (-10\u00b0C to +85\u00b0C). , Max. = Industrial (-10\u00b0C to +85\u00b0C). , Units = Industrial (-10\u00b0C to +85\u00b0C). , Conditions = Industrial (-10\u00b0C to +85\u00b0C). D420G, Symbol = . D420G, Characteristic = PIC18F1220/1320. D420G, Characteristic = LVDL<3:0> = 1101. D420G, Min. = 3.93. D420G, Typ\u2020 =",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\n4.28. D420G, Max. = 4.62. D420G, Units = V. D420G, Conditions = . D420G, Symbol = . D420G, Characteristic = . D420G, Characteristic = LVDL<3:0> = 1110. D420G, Min. = 4.23. D420G, Typ\u2020 = 4.60. D420G, Max. = 4.96. D420G, Units = V. D420G, Conditions = . , Symbol = . , Characteristic = LVD Voltage on VDD Transition High-to-Low. , Characteristic = LVD Voltage on VDD Transition High-to-Low. , Min. = Industrial (-40\u00b0C to -10\u00b0C). , Typ\u2020 = Industrial (-40\u00b0C to -10\u00b0C). , Max. = Industrial (-40\u00b0C to -10\u00b0C). , Units = Industrial (-40\u00b0C to -10\u00b0C). , Conditions = Industrial (-40\u00b0C to -10\u00b0C).",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nD420H, Symbol = . D420H, Characteristic = PIC18F1220/1320. D420H, Characteristic = LVDL<3:0> = 1101. D420H, Min. = 3.76. D420H, Typ\u2020 = 4.28. D420H, Max. = 4.79. D420H, Units = V. D420H, Conditions = . D420H, Symbol = . D420H, Characteristic = . D420H, Characteristic = LVDL<3:0> = 1110. D420H, Min. = 4.04. D420H, Typ\u2020 = 4.60. D420H, Max. = 5.15. D420H, Units = V. D420H, Conditions = . , Symbol = . , Characteristic = LVD Voltage on VDD Transition High-to-Low. , Characteristic = LVD Voltage on VDD Transition High-to-Low. , Min. = Extended (-10\u00b0C to +85\u00b0C). , Typ\u2020",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\n= Extended (-10\u00b0C to +85\u00b0C). , Max. = Extended (-10\u00b0C to +85\u00b0C). , Units = Extended (-10\u00b0C to +85\u00b0C). , Conditions = Extended (-10\u00b0C to +85\u00b0C). D420J, Symbol = . D420J, Characteristic = PIC18F1220/1320. D420J, Characteristic = LVDL<3:0> = 1101. D420J, Min. = 3.94. D420J, Typ\u2020 = 4.28. D420J, Max. = 4.62. D420J, Units = V. D420J, Conditions = . D420J, Symbol = . D420J, Characteristic = . D420J, Characteristic = LVDL<3:0> = 1110. D420J, Min. = 4.23. D420J, Typ\u2020 = 4.60. D420J, Max. = 4.96. D420J, Units = V.",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nD420J, Conditions = . , Symbol = . , Characteristic = LVD Voltage on VDD Transition High-to-Low. , Characteristic = LVD Voltage on VDD Transition High-to-Low. , Min. = Extended (-40\u00b0C to -10\u00b0C, +85\u00b0C to +125\u00b0C). , Typ\u2020 = Extended (-40\u00b0C to -10\u00b0C, +85\u00b0C to +125\u00b0C). , Max. = Extended (-40\u00b0C to -10\u00b0C, +85\u00b0C to +125\u00b0C). , Units = Extended (-40\u00b0C to -10\u00b0C, +85\u00b0C to +125\u00b0C). , Conditions = Extended (-40\u00b0C to -10\u00b0C, +85\u00b0C to +125\u00b0C). D420K, Symbol = . D420K, Characteristic = PIC18F1220/1320. D420K, Characteristic = LVDL<3:0> = 1101. D420K, Min. = 3.77. D420K, Typ\u2020 =",
    "TABLE 22-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\n4.28. D420K, Max. = 4.79. D420K, Units = V. D420K, Conditions = . D420K, Symbol = . D420K, Characteristic = . D420K, Characteristic = LVDL<3:0> = 1110. D420K, Min. = 4.05. D420K, Typ\u2020 = 4.60. D420K, Max. = 5.15. D420K, Units = V. D420K, Conditions = \nLegend:\nShading of rows is to assist in readability of the table.\n- \u2020 Production tested at TAMB = 25\u00b0C. Specifications over temperature limits ensured by characterization.",
    "22.4.1 TIMING PARAMETER SYMBOLOGY\nThe  timing  parameter  symbols  have  been  created following one of the following formats:",
    "22.4.1 TIMING PARAMETER SYMBOLOGY\nT, 1. TppS2ppS 2. TppS = T. T, 3. T CC: ST 4. Ts = . T, (I C specifications only) (I 2 C specifications only) = . F, 1. TppS2ppS 2. TppS = Frequency. F, 3. T CC: ST 4. Ts = T. F, (I C specifications only) (I 2 C specifications only) = Time. Lowercase letters (pp) and their meanings:, 1. TppS2ppS 2. TppS = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, 3. T CC: ST 4. Ts = . Lowercase letters (pp) and their meanings:, (I C specifications only) (I 2 C specifications only) = . pp, 1. TppS2ppS 2. TppS = pp. pp, 3. T CC: ST 4. Ts = . pp, (I C specifications only) (I 2 C specifications only) = . cc, 1. TppS2ppS 2. TppS = CCP1. cc, 3. T CC: ST 4. Ts =",
    "22.4.1 TIMING PARAMETER SYMBOLOGY\nosc. cc, (I C specifications only) (I 2 C specifications only) = OSC1. ck, 1. TppS2ppS 2. TppS = CLKO. ck, 3. T CC: ST 4. Ts = rd. ck, (I C specifications only) (I 2 C specifications only) = RD. cs, 1. TppS2ppS 2. TppS = CS. cs, 3. T CC: ST 4. Ts = rw. cs, (I C specifications only) (I 2 C specifications only) = RD or WR. di, 1. TppS2ppS 2. TppS = SDI. di, 3. T CC: ST 4. Ts = sc. di, (I C specifications only) (I 2 C specifications only) = SCK. do, 1. TppS2ppS 2. TppS = SDO. do, 3. T CC: ST 4. Ts = ss. do, (I C specifications only) (I 2 C specifications only) = SS. dt, 1. TppS2ppS 2. TppS = Data in. dt, 3. T CC: ST 4. Ts =",
    "22.4.1 TIMING PARAMETER SYMBOLOGY\nt0. dt, (I C specifications only) (I 2 C specifications only) = T0CKI. io, 1. TppS2ppS 2. TppS = I/O port. io, 3. T CC: ST 4. Ts = t1. io, (I C specifications only) (I 2 C specifications only) = T13CKI. mc, 1. TppS2ppS 2. TppS = MCLR. mc, 3. T CC: ST 4. Ts = wr. mc, (I C specifications only) (I 2 C specifications only) = WR. Uppercase letters and their meanings:, 1. TppS2ppS 2. TppS = Uppercase letters and their meanings:. Uppercase letters and their meanings:, 3. T CC: ST 4. Ts = . Uppercase letters and their meanings:, (I C specifications only) (I 2 C specifications only) = . S, 1. TppS2ppS 2. TppS = S. S, 3. T CC: ST 4. Ts = . S, (I C specifications only) (I 2 C specifications only) = . F, 1. TppS2ppS",
    "22.4.1 TIMING PARAMETER SYMBOLOGY\n2. TppS = Fall. F, 3. T CC: ST 4. Ts = P. F, (I C specifications only) (I 2 C specifications only) = Period. H, 1. TppS2ppS 2. TppS = High. H, 3. T CC: ST 4. Ts = R. H, (I C specifications only) (I 2 C specifications only) = Rise. I, 1. TppS2ppS 2. TppS = Invalid (High-Impedance). I, 3. T CC: ST 4. Ts = V. I, (I C specifications only) (I 2 C specifications only) = Valid. L, 1. TppS2ppS 2. TppS = Low. L, 3. T CC: ST 4. Ts = Z. L, (I C specifications only) (I 2 C specifications only) = High-Impedance. I 2 C only, 1. TppS2ppS 2. TppS = I 2 C only. I 2 C only, 3. T CC: ST 4. Ts = . I 2 C only, (I C specifications only) (I 2 C specifications only) = .",
    "22.4.1 TIMING PARAMETER SYMBOLOGY\nAA, 1. TppS2ppS 2. TppS = output access. AA, 3. T CC: ST 4. Ts = High. AA, (I C specifications only) (I 2 C specifications only) = High. BUF, 1. TppS2ppS 2. TppS = Bus free. BUF, 3. T CC: ST 4. Ts = Low. BUF, (I C specifications only) (I 2 C specifications only) = Low. T CC: ST (I 2 C specifications only), 1. TppS2ppS 2. TppS = T CC: ST (I 2 C specifications only). T CC: ST (I 2 C specifications only), 3. T CC: ST 4. Ts = . T CC: ST (I 2 C specifications only), (I C specifications only) (I 2 C specifications only) = . CC, 1. TppS2ppS 2. TppS = CC. CC, 3. T CC: ST 4. Ts = . CC, (I C specifications only) (I 2 C specifications only) = . HD, 1. TppS2ppS 2. TppS = Hold. HD,",
    "22.4.1 TIMING PARAMETER SYMBOLOGY\n3. T CC: ST 4. Ts = SU. HD, (I C specifications only) (I 2 C specifications only) = Setup. ST, 1. TppS2ppS 2. TppS = ST. ST, 3. T CC: ST 4. Ts = ST. ST, (I C specifications only) (I 2 C specifications only) = ST. DAT, 1. TppS2ppS 2. TppS = DATA input hold. DAT, 3. T CC: ST 4. Ts = STO. DAT, (I C specifications only) (I 2 C specifications only) = Stop condition. STA, 1. TppS2ppS 2. TppS = Start condition. STA, 3. T CC: ST 4. Ts = . STA, (I C specifications only) (I 2 C specifications only) = ",
    "22.4.2 TIMING CONDITIONS\nThe temperature and voltages specified in Table 22-3 apply  to  all timing  specifications  unless  otherwise noted. Figure 22-5 specifies the load conditions for the timing specifications.",
    "TABLE 22-3: TEMPERATURE AND VOLTAGE SPECIFICATIONS - AC\nAC CHARACTERISTICS, 1 = Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3\uf020 +85\u00b0C for industrial -40\u00b0C \uf0a3\uf020 T A \uf0a3 +125\u00b0C for extended Operating voltage VDD range as described in DC spec Section 22.1 and Section 22.3 . LF parts operate for industrial temperatures only.",
    "FIGURE 22-5: LOAD CONDITIONS FOR DEVICE TIMING SPECIFICATIONS\n, Load Condition 1 = RL = 464 \uf057 CL = 50 pF",
    "TABLE 22-4: EXTERNAL CLOCK TIMING REQUIREMENTS\n1A, Symbol = FOSC. 1A, Characteristic = External CLKI Frequency (1) Oscillator Frequency (1). 1A, Min. = DC DC DC DC DC 1 DC. 1A, Max. = 40 25 4 1 25 10 33. 1A, Units = MHz MHz MHz MHz MHz MHz kHz. 1A, Conditions = EC, ECIO (LF and Industrial) EC, ECIO (Extended) RC oscillator XT oscillator HS oscillator HS + PLL oscillator LP Oscillator mode. 1, Symbol = T OSC. 1, Characteristic = External CLKI Period (1) Oscillator Period (1). 1, Min. = 25 40 250 1000 25 100 30. 1, Max. = - - - - - 1000 -. 1, Units = ns ns ns ns ns ns \uf06d s. 1, Conditions = EC, ECIO (LF and Industrial) EC, ECIO (Extended) RC oscillator XT oscillator HS oscillator HS + PLL oscillator LP oscillator. 2, Symbol = T CY. 2, Characteristic = Instruction",
    "TABLE 22-4: EXTERNAL CLOCK TIMING REQUIREMENTS\nCycle Time (1). 2, Min. = 100. 2, Max. = -. 2, Units = ns. 2, Conditions = T CY = 4/F OSC. 3, Symbol = TosL, TosH. 3, Characteristic = External Clock in (OSC1) High or Low Time. 3, Min. = 30 2.5 10. 3, Max. = - - -. 3, Units = ns \uf06d s ns. 3, Conditions = XT oscillator LP oscillator HS oscillator. 4, Symbol = TosR, TosF. 4, Characteristic = External Clock in (OSC1) Rise or Fall Time. 4, Min. = - - -. 4, Max. = 20 50 7.5. 4, Units = ns ns ns. 4, Conditions = XT oscillator LP oscillator HS oscillator",
    "TABLE 22-4: EXTERNAL CLOCK TIMING REQUIREMENTS\nNote 1: Instruction cycle period (TCY) equals four times the input oscillator time base period for all configurations except PLL. All specified values are based on characterization data for that particular oscillator type under standard operating conditions, with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min.' values with an external clock applied to the OSC1/CLKI pin. When an external clock input is used, the 'max.' cycle time limit is 'DC' (no clock) for all devices.",
    "TABLE 22-5: PLL CLOCK TIMING SPECIFICATIONS, HS/HSPLL MODE (VDD = 4.2V TO 5.5V)\nF10, Sym. = FOSC. F10, Characteristic = Oscillator Frequency Range. F10, Min. = 4. F10, Typ\u2020 = -. F10, Max. = 10. F10, Units = MHz. F10, Conditions = HS and HSPLL mode only. F11, Sym. = FSYS. F11, Characteristic = On-Chip VCO System Frequency. F11, Min. = 16. F11, Typ\u2020 = -. F11, Max. = 40. F11, Units = MHz. F11, Conditions = HSPLL mode only. F12, Sym. = TPLL. F12, Characteristic = PLL Start-up Time (Lock Time). F12, Min. = -. F12, Typ\u2020 = -. F12, Max. = 2. F12, Units = ms. F12, Conditions = HSPLL mode only. F13, Sym. = \uf044 CLK. F13, Characteristic = CLKO Stability",
    "TABLE 22-5: PLL CLOCK TIMING SPECIFICATIONS, HS/HSPLL MODE (VDD = 4.2V TO 5.5V)\n(Jitter). F13, Min. = -2. F13, Typ\u2020 = -. F13, Max. = +2. F13, Units = %. F13, Conditions = HSPLL mode only\n- \u2020 Data in 'Typ' column is at 5V, 25 C unless otherwise stated. These parameters are for design guidance \uf0b0 only and are not tested.",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n, PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = PIC18LF1220/1320. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Min..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -2. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Typ..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +/-1. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n+85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Max..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 2. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n(1) = +25\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = . , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Min..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz,",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n250 kHz, 125 kHz (1) = -5. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Typ..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Max..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 5. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nkHz, 250 kHz, 125 kHz (1) = %. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -10\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V. , PIC18LF1220/1320",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n(Industrial).PIC18F1220/1320 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = . , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Min..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -10. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Typ..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Max..INTOSC Accuracy",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n@Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 10. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -40\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\notherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = PIC18F1220/. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Min..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) =",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n-2. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Typ..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +/-1. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Max..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 2. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n(1) = %. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +25\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 4.5-5.5V. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n(Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 1320PIC18F1220/1320. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Min..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -5. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Typ..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Max..INTOSC Accuracy @Freq",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n= 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 5. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -10\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\ntemperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 4.5-5.5V. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = . , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Min..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -10. , Standard Operating Conditions (unless otherwise",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nstated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Typ..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Max..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 10. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. , Standard Operating Conditions (unless otherwise",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nstated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -40\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 4.5-5.5V. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial).Device.INTOSC Accuracy @Freq",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n= 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Min..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Typ..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nOperating temperature.Max..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nMHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = PIC18LF1220/1320. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nindustrial.Standard Operating Conditions Operating temperature.Min..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 26.562. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Typ..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Max..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 35.938. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nfor industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = kHz. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -40\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz,",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V. , PIC18LF1220/1320 (Industrial).PIC18F1220/1320 (Industrial).Device.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = PIC18F1220/ 1320PIC18F1220/1320. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Min..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 26.562. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Typ..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nkHz, 250 kHz, 125 kHz (1) = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions Operating temperature.Max..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 35.938. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = kHz. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for",
    "TABLE 22-6: INTERNAL RC ACCURACY: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nextended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -40\u00b0C to +85\u00b0C. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.(unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 4.5-5.5V\n- Legend: Shading of rows is to assist in readability of the table.\nNote\n1: Frequency calibrated at 25\u00b0C. OSCTUNE register can be used to compensate for temperature and VDD drift.\n2: INTRC frequency after calibration.\n3: Change of INTRC frequency as VDD changes.",
    "TABLE 22-7: CLKO AND I/O TIMING REQUIREMENTS\n\nNote 1: Measurements are taken in RC mode, where CLKO output is 4 x TOSC.",
    "TABLE 22-7: CLKO AND I/O TIMING REQUIREMENTS\n10, Symbol = TosH2ckL. 10, Characteristic = OSC1 \uf0ad to CLKO \uf0af. 10, Characteristic = OSC1 \uf0ad to CLKO \uf0af. 10, Min. = -. 10, Typ. = 75. 10, Max. = 200. 10, Units = ns. 10, Conditions = (Note 1). 11, Symbol = TosH2ckH. 11, Characteristic = OSC1 \uf0ad to CLKO \uf0ad. 11, Characteristic = OSC1 \uf0ad to CLKO \uf0ad. 11, Min. = -. 11, Typ. = 75. 11, Max. = 200. 11, Units = ns. 11, Conditions = (Note 1). 12, Symbol = TckR. 12, Characteristic = CLKO Rise Time. 12, Characteristic = CLKO Rise Time. 12, Min. = -. 12, Typ. = 35. 12, Max. = 100. 12, Units = ns. 12, Conditions = (Note 1). 13, Symbol = TckF. 13, Characteristic = CLKO Fall Time. 13, Characteristic = CLKO Fall Time. 13, Min. = -. 13, Typ. = 35. 13,",
    "TABLE 22-7: CLKO AND I/O TIMING REQUIREMENTS\nMax. = 100. 13, Units = ns. 13, Conditions = (Note 1). 14, Symbol = TckL2ioV. 14, Characteristic = CLKO \uf0af to Port Out Valid. 14, Characteristic = CLKO \uf0af to Port Out Valid. 14, Min. = -. 14, Typ. = -. 14, Max. = 0.5 T CY + 20. 14, Units = ns. 14, Conditions = (Note 1). 15, Symbol = TioV2ckH. 15, Characteristic = Port In Valid before CLKO \uf0ad. 15, Characteristic = Port In Valid before CLKO \uf0ad. 15, Min. = 0.25 T CY + 25. 15, Typ. = -. 15, Max. = -. 15, Units = ns. 15, Conditions = (Note 1). 16, Symbol = TckH2ioI. 16, Characteristic = Port In Hold after CLKO \uf0ad. 16, Characteristic = Port In Hold after CLKO \uf0ad. 16, Min. = 0. 16, Typ. = -. 16, Max. = -. 16, Units = ns. 16, Conditions = (Note 1). 17, Symbol",
    "TABLE 22-7: CLKO AND I/O TIMING REQUIREMENTS\n= TosH2ioV. 17, Characteristic = OSC1 \uf0ad (Q1 cycle) to Port Out Valid. 17, Characteristic = OSC1 \uf0ad (Q1 cycle) to Port Out Valid. 17, Min. = -. 17, Typ. = 50. 17, Max. = 150. 17, Units = ns. 17, Conditions = . 18, Symbol = TosH2ioI. 18, Characteristic = OSC1 \uf0ad (Q2 cycle) to Port Input Invalid (I/O in hold time). 18, Characteristic = PIC18F1X20. 18, Min. = 100. 18, Typ. = -. 18, Max. = -. 18, Units = ns. 18, Conditions = . 18A, Symbol = TosH2ioI. 18A, Characteristic = OSC1 \uf0ad (Q2 cycle) to Port Input Invalid (I/O in hold time). 18A, Characteristic = PIC18LF1X20. 18A, Min. = 200. 18A, Typ. = -. 18A, Max. = -. 18A, Units = ns. 18A, Conditions = . 19, Symbol",
    "TABLE 22-7: CLKO AND I/O TIMING REQUIREMENTS\n= TioV2osH. 19, Characteristic = Port Input Valid to OSC1 \uf0ad\uf020 (I/O in setup time). 19, Characteristic = Port Input Valid to OSC1 \uf0ad\uf020 (I/O in setup time). 19, Min. = 0. 19, Typ. = -. 19, Max. = -. 19, Units = ns. 19, Conditions = . 20, Symbol = TioR. 20, Characteristic = Port Output Rise Time. 20, Characteristic = PIC18F1X20. 20, Min. = -. 20, Typ. = 10. 20, Max. = 25. 20, Units = ns. 20, Conditions = . 20A, Symbol = TioR. 20A, Characteristic = Port Output Rise Time. 20A, Characteristic = PIC18LF1X20. 20A, Min. = -. 20A, Typ. = -. 20A, Max. = 60. 20A, Units = ns. 20A, Conditions = . 21, Symbol = TioF. 21, Characteristic = Port Output Fall Time. 21, Characteristic = PIC18F1X20. 21, Min. = -. 21,",
    "TABLE 22-7: CLKO AND I/O TIMING REQUIREMENTS\nTyp. = 10. 21, Max. = 25. 21, Units = ns. 21, Conditions = . 21A, Symbol = TioF. 21A, Characteristic = Port Output Fall Time. 21A, Characteristic = PIC18LF1X20. 21A, Min. = -. 21A, Typ. = -. 21A, Max. = 60. 21A, Units = ns. 21A, Conditions = ",
    "TABLE 22-8: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\n30, Symbol = TmcL. 30, Characteristic = MCLR Pulse Width (low). 30, Min. = 2. 30, Typ. = -. 30, Max. = -. 30, Units = \uf06d s. 30, Conditions = . 31, Symbol = TWDT. 31, Characteristic = Watchdog Timer Time-out Period (No postscaler). 31, Min. = 3.48. 31, Typ. = 4.00. 31, Max. = 4.71. 31, Units = ms. 31, Conditions = . 32, Symbol = T OST. 32, Characteristic = Oscillation Start-up Timer Period. 32, Min. = 1024 T OSC. 32, Typ. = -. 32, Max. = 1024 T OSC. 32, Units = -. 32, Conditions = T OSC = OSC1 period. 33, Symbol = TPWRT. 33, Characteristic = Power-up Timer Period. 33, Min. = -. 33, Typ. = 65.5. 33,",
    "TABLE 22-8: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\nMax. = 132. 33, Units = ms. 33, Conditions = . 34, Symbol = T IOZ. 34, Characteristic = I/O High-Impedance from MCLR Low or Watchdog Timer Reset. 34, Min. = -. 34, Typ. = 2. 34, Max. = -. 34, Units = \uf06d s. 34, Conditions = . 35, Symbol = TBOR. 35, Characteristic = Brown-out Reset Pulse Width. 35, Min. = 200. 35, Typ. = -. 35, Max. = -. 35, Units = \uf06d s. 35, Conditions = VDD \uf0a3 BVDD (see D005). 36, Symbol = TIVRST. 36, Characteristic = Time for Internal Reference Voltage to become stable. 36, Min. = -. 36, Typ. = 20. 36, Max. = 50. 36, Units = \uf06d s. 36, Conditions = . 37, Symbol = TLVD. 37, Characteristic = Low-Voltage Detect Pulse Width. 37, Min. = 200. 37, Typ. =",
    "TABLE 22-8: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\n-. 37, Max. = -. 37, Units = \uf06d s. 37, Conditions = VDD \uf0a3 VLVD",
    "TABLE 22-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n40, Symbol = Tt0H. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = No prescaler. 40, Min. = 0.5 T CY + 20. 40, Max. = -. 40, Units = ns. 40, Conditions = . 40, Symbol = Tt0H. 40, Characteristic = . 40, Characteristic = . 40, Characteristic = With prescaler. 40, Min. = 10. 40, Max. = -. 40, Units = ns. 40, Conditions = . 41, Symbol = Tt0L. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = No prescaler. 41, Min. = 0.5 T CY + 20. 41, Max. = -. 41, Units = ns. 41, Conditions = . 41, Symbol = Tt0L. 41, Characteristic = . 41, Characteristic = . 41, Characteristic = With prescaler. 41, Min. = 10. 41, Max. = -. 41, Units = ns. 41, Conditions =",
    "TABLE 22-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n. 42, Symbol = Tt0P. 42, Characteristic = T0CKI Period. 42, Characteristic = T0CKI Period. 42, Characteristic = No prescaler. 42, Min. = T CY + 10. 42, Max. = -. 42, Units = ns. 42, Conditions = . 42, Symbol = Tt0P. 42, Characteristic = . 42, Characteristic = . 42, Characteristic = With prescaler. 42, Min. = Greater of: 20 ns or T CY + 40 N. 42, Max. = -. 42, Units = ns. 42, Conditions = N = prescale value (1, 2, 4,..., 256). 45, Symbol = Tt1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Synchronous, no prescaler. 45, Characteristic = Synchronous, no prescaler. 45, Min. = 0.5 T CY + 20. 45, Max. = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T13CKI High Time. 45, Characteristic",
    "TABLE 22-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n= Synchronous, with prescaler. 45, Characteristic = PIC18F1X20. 45, Min. = 10. 45, Max. = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Synchronous, with prescaler. 45, Characteristic = PIC18LF1X20. 45, Min. = 25. 45, Max. = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18F1X20. 45, Min. = 30. 45, Max. = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18LF1X20. 45, Min. = 50. 45, Max. = -. 45, Units = ns. 45, Conditions = .",
    "TABLE 22-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n46, Symbol = Tt1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Synchronous, no prescaler. 46, Characteristic = Synchronous, no prescaler. 46, Min. = 0.5 T CY + 5. 46, Max. = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18F1X20. 46, Min. = 10. 46, Max. = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18LF1X20. 46, Min. = 25. 46, Max. = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Asynchronous. 46,",
    "TABLE 22-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nCharacteristic = PIC18F1X20. 46, Min. = 30. 46, Max. = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T13CKI Low Time. 46, Characteristic = Asynchronous. 46, Characteristic = PIC18LF1X20. 46, Min. = 50. 46, Max. = -. 46, Units = ns. 46, Conditions = . 47, Symbol = Tt1P. 47, Characteristic = T13CKI Input Period. 47, Characteristic = Synchronous. 47, Characteristic = Synchronous. 47, Min. = Greater of: 20 ns or T CY + 40 N. 47, Max. = -. 47, Units = ns. 47, Conditions = N = prescale value (1, 2, 4, 8). 47, Symbol = Tt1P. 47, Characteristic = T13CKI Input Period. 47, Characteristic = Asynchronous. 47, Characteristic = Asynchronous. 47, Min. = 60. 47, Max. = -. 47, Units = ns.",
    "TABLE 22-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n47, Conditions = . , Symbol = Ft1. , Characteristic = T13CKI Oscillator Input Frequency Range. , Characteristic = T13CKI Oscillator Input Frequency Range. , Characteristic = T13CKI Oscillator Input Frequency Range. , Min. = DC. , Max. = 50. , Units = kHz. , Conditions = . 48, Symbol = Tcke2tmrI. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Min. = 2 T OSC. 48, Max. = 7 T OSC. 48, Units = -. 48, Conditions = ",
    "TABLE 22-10: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\n50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = No prescaler. 50, Characteristic = No prescaler. 50, Min. = 0.5 T CY + 20. 50, Max. = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = With prescaler. 50, Characteristic = PIC18F1X20. 50, Min. = 10. 50, Max. = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = With prescaler. 50, Characteristic = PIC18LF1X20. 50, Min. = 20. 50, Max. = -. 50, Units = ns. 50, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = No prescaler. 51, Characteristic = No prescaler. 51, Min. = 0.5",
    "TABLE 22-10: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\nT CY + 20. 51, Max. = -. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = With prescaler. 51, Characteristic = PIC18F1X20. 51, Min. = 10. 51, Max. = -. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = With prescaler. 51, Characteristic = PIC18LF1X20. 51, Min. = 20. 51, Max. = -. 51, Units = ns. 51, Conditions = . 52, Symbol = TccP. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Min. = 3 T CY + 40 N. 52, Max. = -. 52, Units = ns. 52, Conditions = N = prescale value (1, 4 or 16). 53, Symbol = TccR.",
    "TABLE 22-10: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\n53, Characteristic = CCPx Output Fall Time. 53, Characteristic = CCPx Output Fall Time. 53, Characteristic = PIC18F1X20. 53, Min. = -. 53, Max. = 25. 53, Units = ns. 53, Conditions = . 53, Symbol = TccR. 53, Characteristic = . 53, Characteristic = . 53, Characteristic = PIC18LF1X20. 53, Min. = -. 53, Max. = 45. 53, Units = ns. 53, Conditions = . 54, Symbol = TccF. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = PIC18F1X20. 54, Min. = -. 54, Max. = 25. 54, Units = ns. 54, Conditions = . 54, Symbol = TccF. 54, Characteristic = . 54, Characteristic = . 54, Characteristic = PIC18LF1X20. 54, Min. = -. 54, Max. = 45. 54, Units = ns. 54, Conditions = ",
    "FIGURE 22-12: EUSART SYNCHRONOUS TRANSMISSION (MASTER/SLAVE) TIMING\nNote:\nRefer to Figure 22-5 for load conditions.",
    "TABLE 22-11: EUSART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n120, Symbol = TckH2dtV. 120, Characteristic = SYNC XMIT (MASTER & SLAVE) Clock High to Data Out Valid. 120, Characteristic = PIC18F1X20. 120, Min. = -. 120, Max. = 40. 120, Units = ns. 120, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18LF1X20. , Min. = -. , Max. = 100. , Units = ns. , Conditions = . 121, Symbol = Tckrf. 121, Characteristic = Clock Out Rise Time and Fall Time. 121, Characteristic = PIC18F1X20. 121, Min. = -. 121, Max. = 20. 121, Units = ns. 121, Conditions = . , Symbol = . , Characteristic = (Master mode). , Characteristic = PIC18LF1X20. , Min. = -. , Max. = 50. , Units = ns. , Conditions = . 122, Symbol = Tdtrf. 122, Characteristic = Data Out Rise Time and Fall Time. 122, Characteristic = PIC18F1X20. 122, Min. = -.",
    "TABLE 22-11: EUSART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n122, Max. = 20. 122, Units = ns. 122, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18LF1X20. , Min. = -. , Max. = 50. , Units = ns. , Conditions = \nFIGURE 22-13:\nEUSART SYNCHRONOUS RECEIVE (MASTER/SLAVE) TIMING",
    "TABLE 22-12: EUSART SYNCHRONOUS RECEIVE REQUIREMENTS\n125, Symbol = TdtV2ckl. 125, Characteristic = SYNC RCV (MASTER & SLAVE) Data Hold before CK \uf0af (DT hold time). 125, Min. = 10. 125, Max. = -. 125, Units = ns. 125, Conditions = . 126, Symbol = TckL2dtl. 126, Characteristic = Data Hold after CK \uf0af (DT hold time). 126, Min. = 15. 126, Max. = -. 126, Units = ns. 126, Conditions = ",
    "TABLE 22-13: A/D CONVERTER CHARACTERISTICS: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nA01, Symbol = NR. A01, Characteristic = Resolution. A01, Characteristic = Resolution. A01, Min. = -. A01, Typ. = -. A01, Max. = 10. A01, Units = bit. A01, Conditions = \uf044 VREF \uf0b3 3.0V. A03, Symbol = EIL. A03, Characteristic = Integral Linearity Error. A03, Characteristic = Integral Linearity Error. A03, Min. = -. A03, Typ. = -. A03, Max. = <\u00b11. A03, Units = LSb. A03, Conditions = \uf044 VREF \uf0b3 3.0V. A04, Symbol = EDL. A04, Characteristic = Differential Linearity Error. A04, Characteristic = Differential Linearity Error. A04, Min. = -. A04, Typ. = -. A04, Max. = <\u00b11. A04, Units = LSb. A04,",
    "TABLE 22-13: A/D CONVERTER CHARACTERISTICS: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nConditions = \uf044 VREF \uf0b3 3.0V. A06, Symbol = EOFF. A06, Characteristic = Offset Error. A06, Characteristic = Offset Error. A06, Min. = -. A06, Typ. = -. A06, Max. = <\u00b11. A06, Units = LSb. A06, Conditions = \uf044 VREF \uf0b3 3.0V. A07, Symbol = EGN. A07, Characteristic = Gain Error. A07, Characteristic = Gain Error. A07, Min. = -. A07, Typ. = -. A07, Max. = <\u00b11. A07, Units = LSb. A07, Conditions = \uf044 VREF \uf0b3 3.0V. A10, Symbol = -. A10, Characteristic = Monotonicity. A10, Characteristic = Monotonicity. A10, Min. = guaranteed (2). A10, Typ. = guaranteed (2). A10, Max. = guaranteed",
    "TABLE 22-13: A/D CONVERTER CHARACTERISTICS: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n(2). A10, Units = -. A10, Conditions = . A20, Symbol = \uf044 VREF. A20, Characteristic = Reference Voltage Range (V REFH - VREFL ). A20, Characteristic = Reference Voltage Range (V REFH - VREFL ). A20, Min. = 3. A20, Typ. = -. A20, Max. = AVDD - AVSS. A20, Units = V. A20, Conditions = For 10-bit resolution. A21, Symbol = VREFH. A21, Characteristic = Reference Voltage High. A21, Characteristic = Reference Voltage High. A21, Min. = AVSS + 3.0V. A21, Typ. = -. A21, Max. = AVDD + 0.3V. A21, Units = V. A21, Conditions = For 10-bit resolution. A22, Symbol = VREFL. A22, Characteristic = Reference Voltage Low. A22, Characteristic = Reference Voltage Low. A22, Min.",
    "TABLE 22-13: A/D CONVERTER CHARACTERISTICS: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n= AVSS - 0.3V. A22, Typ. = -. A22, Max. = AVDD - 3.0V. A22, Units = V. A22, Conditions = For 10-bit resolution. A25, Symbol = VAIN. A25, Characteristic = Analog Input Voltage. A25, Characteristic = Analog Input Voltage. A25, Min. = VREFL. A25, Typ. = -. A25, Max. = VREFH. A25, Units = V. A25, Conditions = . A28, Symbol = AVDD. A28, Characteristic = Analog Supply Voltage. A28, Characteristic = Analog Supply Voltage. A28, Min. = VDD - 0.3. A28, Typ. = -. A28, Max. = VDD + 0.3. A28, Units = V. A28, Conditions = . A29, Symbol = AVSS. A29, Characteristic = Analog Supply Voltage. A29, Characteristic = Analog Supply Voltage. A29, Min.",
    "TABLE 22-13: A/D CONVERTER CHARACTERISTICS: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n= VSS - 0.3. A29, Typ. = -. A29, Max. = VSS + 0.3. A29, Units = V. A29, Conditions = . A30, Symbol = ZAIN. A30, Characteristic = Recommended Impedance of Analog Voltage Source. A30, Characteristic = Recommended Impedance of Analog Voltage Source. A30, Min. = -. A30, Typ. = -. A30, Max. = 2.5. A30, Units = k \uf057. A30, Conditions = . A40, Symbol = I AD. A40, Characteristic = A/D Conversion Current (V DD). A40, Characteristic = PIC18F1X20. A40, Min. = -. A40, Typ. = 180. A40, Max. = -. A40, Units = \uf06d A. A40, Conditions = Average current consumption when A/D is on (Note 1). A40, Symbol = I AD. A40, Characteristic = A/D Conversion Current",
    "TABLE 22-13: A/D CONVERTER CHARACTERISTICS: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\n(V DD). A40, Characteristic = PIC18LF1X20. A40, Min. = -. A40, Typ. = 90. A40, Max. = -. A40, Units = \uf06d A. A40, Conditions = Average current consumption when A/D is on (Note 1). A50, Symbol = I REF. A50, Characteristic = VREF Input Current (Note 3). A50, Characteristic = VREF Input Current (Note 3). A50, Min. = - -. A50, Typ. = - -. A50, Max. = \u00b15 \u00b1150. A50, Units = \uf06d A \uf06d A. A50, Conditions = During VAIN acquisition. During A/D conversion cycle.",
    "TABLE 22-13: A/D CONVERTER CHARACTERISTICS: PIC18F1220/1320 (INDUSTRIAL) PIC18LF1220/1320 (INDUSTRIAL)\nNote 1: When A/D is off, it will not consume any current other than minor leakage current. The power-down current specification includes any such leakage from the A/D module.\n2: The A/D conversion result never decreases with an increase in the input voltage and has no missing codes.\n3: VREFH current is from RA3/AN3/VREF+ pin or AVDD, whichever is selected as the VREFH source. VREFL current is from RA2/AN2/VREF- pin or AVSS, whichever is selected as the VREFL source.",
    "FIGURE 22-14: A/D CONVERSION TIMING\nNote 1: If the A/D clock source is selected as RC, a time of TCY is added before the A/D clock starts. This allows the SLEEP instruction to be executed.\n2: This is a minimal RC delay (typically 100 ns), which also disconnects the holding capacitor from the analog input.",
    "TABLE 22-14: A/D CONVERSION REQUIREMENTS\n130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18F1X20. 130, Min. = 1.6. 130, Max. = 20 (5). 130, Units = \uf06d s. 130, Conditions = T OSC based, VREF \uf0b3 3.0V. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18LF1X20. 130, Min. = 3.0. 130, Max. = 20 (5). 130, Units = \uf06d s. 130, Conditions = T OSC based, VREF full range. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18F1X20. 130, Min. = 2.0. 130, Max. = 6.0. 130, Units = \uf06d s. 130, Conditions = A/D RC mode. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18LF1X20. 130, Min. = 3.0. 130, Max. = 9.0. 130,",
    "TABLE 22-14: A/D CONVERSION REQUIREMENTS\nUnits = \uf06d s. 130, Conditions = A/D RC mode. 131, Symbol = T CNV. 131, Characteristic = Conversion Time (not including acquisition time) (Note 1). 131, Characteristic = Conversion Time (not including acquisition time) (Note 1). 131, Min. = 11. 131, Max. = 12. 131, Units = T AD. 131, Conditions = . 132, Symbol = T ACQ. 132, Characteristic = Acquisition Time (Note 3). 132, Characteristic = Acquisition Time (Note 3). 132, Min. = 15 10. 132, Max. = - -. 132, Units = \uf06d s \uf06d s. 132, Conditions = -40 \uf0b0 C \uf0a3 Temp \uf0a3 +125 \uf0b0 C 0 \uf0b0 C \uf0a3 Temp \uf0a3 +125 \uf0b0 C. 135, Symbol = T SWC. 135, Characteristic = Switching Time from Convert \uf0ae Sample. 135, Characteristic = Switching Time from Convert \uf0ae Sample. 135, Min. = -. 135, Max. = (Note 4). 135, Units = . 135, Conditions = . 136, Symbol = T AMP. 136, Characteristic = Amplifier Settling Time (Note 2). 136, Characteristic = Amplifier Settling Time (Note 2). 136, Min. =",
    "TABLE 22-14: A/D CONVERSION REQUIREMENTS\n1. 136, Max. = -. 136, Units = \uf06d s. 136, Conditions = This may be used if the 'new' input voltage has not changed by more than 1 LSb (i.e., 5 mV@5.12V) from the last sampled voltage (as stated on CHOLD).\nNote 1: ADRES register may be read on the following TCY cycle.\n2: See Section 17.0 '10-Bit Analog-to-Digital Converter (A/D) Module' for minimum conditions when input voltage has changed more than 1 LSb.\n3: The time for the holding capacitor to acquire the 'New' input voltage, when the voltage changes full scale after the conversion (AVDD to AVSS, or AVSS to AVDD). The source impedance ( RS ) on the input channels is 50 \uf057 .\n4: On the next Q4 cycle of the device clock.\n5: The time of the A/D clock period is dependent on the device frequency and the TAD clock divider.",
    "22.5 High Temperature Operation\nThis section outlines the specifications for the following devices  operating in the high temperature  range between -40\u00b0C and 150\u00b0C. (6)\n\u00b7 PIC18F1220\n\u00b7 PIC18F1320\nWhen the value of any parameter is identical for both the 125\u00b0C  Extended  and  the  150\u00b0C  High  Temp. temperature ranges, then that value will be found in the standard  specification  tables  shown  earlier  in  this chapter, under the fields listed for the 125\u00b0C Extended temperature  range.  If  the  value  of  any  parameter  is unique to  the  150\u00b0C  High  Temp.  temperature  range, then  it  will  be  listed  here,  in  this  section  of  the  data sheet.\nIf  a  Silicon  Errata  exists  for  the  product  and  it  lists  a modification to the 125\u00b0C Extended temperature range value, one that is also shared at the 150\u00b0C High Temp. temperature range, then that modified value will apply to both temperature ranges.",
    "22.5 High Temperature Operation\nNote 1: Data contained in this section is applicable to the following devices: PIC18F1220 and PIC18F1320.\n2: Writes are not allowed for Flash program memory above 125\u00b0C.\n3: All AC timing specifications are increased by 30%.\n4: Figure 22-3; The frequency range is decreased to 20 MHz.\n5: The  temperature  range  indicator  in  the catalog part number and device marking is 'H' for -40\u00b0C to 150\u00b0C.\nExample:  PIC18F1220T-H/SO  indicates the device is shipped in a Tape and Reel configuration, in the SOIC package, and is rated for operation  from  -40\u00b0C  to 150\u00b0C.\n6: AEC-Q100 reliability  testing  for  devices intended  to  operate  at  150\u00b0C  is  1,000 hours. Any design in which the total operating  time  from  125\u00b0C  to  150\u00b0C  will  be greater than 1,000 hours is not warranted without prior written approval from Microchip Technology Inc.",
    "TABLE 22-15: ABSOLUTE MAXIMUM RATINGS\nMax. Current: VSS, Source/Sink = Sink. Max. Current: VSS, Value = 300. Max. Current: VSS, Units = mA. Max. Current: VDD, Source/Sink = Source. Max. Current: VDD, Value = 250. Max. Current: VDD, Units = mA. Max. Current: Pin, Source/Sink = Sink. Max. Current: Pin, Value = 20. Max. Current: Pin, Units = mA. Max. Current: Pin, Source/Sink = Source. Max. Current: Pin, Value = 15. Max. Current: Pin, Units = mA. Max. Port Current: All ports combined, Source/Sink = Sink. Max. Port Current: All ports combined, Value = 20. Max. Port Current: All ports combined, Units = mA. Max. Port Current: All ports combined, Source/Sink = Source. Max. Port Current: All ports combined, Value = 15. Max. Port Current: All ports combined, Units = mA. Max. Junction Temperature, Source/Sink = . Max. Junction Temperature, Value = 155. Max. Junction Temperature, Units = \u00b0C\nNote:",
    "TABLE 22-15: ABSOLUTE MAXIMUM RATINGS\nStresses above those listed under Absolute Maximum Ratings may  cause  permanent damage to the device. This is a stress rating only, and functional operation of the device at those or any other conditions above  those  indicated  in  the  operation  listings  of  this  specification  is  not  implied.  Exposure  above maximum rating conditions for extended periods may affect device reliability.",
    "TABLE 22-16: DC CHARACTERISTICS FOR IDD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\nI PD, Device Characteristics.Device Characteristics = Power Down Current. I PD, Min..Min. = -. I PD, Typ..Typ. = -. I PD, Max..Max. = 220. I PD, Units.Units = \uf06d A. I PD, Condition.VDD = 5.0. I PD, Condition.Note = Sleep mode. I DD, Device Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD, Typ..Typ. = -. I DD, Max..Max. = 250. I DD, Units.Units = \uf06d A. I DD, Condition.VDD = 5.0. I DD, Condition.Note = FOSC = 31 kHz (RC_Run mode, Internal Oscillator source). I DD, Device Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD, Typ..Typ. = -. I DD, Max..Max. = 800. I DD, Units.Units = \uf06d",
    "TABLE 22-16: DC CHARACTERISTICS FOR IDD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\nA. I DD, Condition.VDD = 5.0. I DD, Condition.Note = FOSC = 1 MHz (RC_Run mode, Internal Oscillator source). I DD, Device Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD, Typ..Typ. = -. I DD, Max..Max. = 2.0. I DD, Units.Units = mA. I DD, Condition.VDD = 5.0. I DD, Condition.Note = FOSC = 4 MHz (RC_Run mode, Internal Oscillator source). I DD, Device Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD, Typ..Typ. = -. I DD, Max..Max. = 240. I DD, Units.Units = \uf06d A. I DD, Condition.VDD = 5.0. I DD, Condition.Note = FOSC = 31 kHz (RC_Idle mode, Internal",
    "TABLE 22-16: DC CHARACTERISTICS FOR IDD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\nOscillator source). I DD, Device Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD, Typ..Typ. = -. I DD, Max..Max. = 600. I DD, Units.Units = \uf06d A. I DD, Condition.VDD = 5.0. I DD, Condition.Note = FOSC = 1 MHz (RC_Idle mode, Internal Oscillator source). I DD, Device Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD, Typ..Typ. = -. I DD, Max..Max. = 1.0. I DD, Units.Units = mA. I DD, Condition.VDD = 5.0. I DD, Condition.Note = FOSC = 4 MHz (RC_Idle mode, Internal Oscillator source). I DD, Device Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD,",
    "TABLE 22-16: DC CHARACTERISTICS FOR IDD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\nTyp..Typ. = -. I DD, Max..Max. = 1.2. I DD, Units.Units = mA. I DD, Condition.VDD = 5.0. I DD, Condition.Note = FOSC = 1 MHz (PRI_Run mode, EC Oscillator). I DD, Device Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD, Typ..Typ. = -. I DD, Max..Max. = 2.2. I DD, Units.Units = mA. I DD, Condition.VDD = 5.0. I DD, Condition.Note = FOSC = 4 MHz (PRI_Run mode, EC Oscillator). I DD, Device Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD, Typ..Typ. = -. I DD, Max..Max. = 10.0. I DD, Units.Units = mA. I DD,",
    "TABLE 22-16: DC CHARACTERISTICS FOR IDD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\nCondition.VDD = 5.0. I DD, Condition.Note = FOSC = 20 MHz (PRI_Run mode, EC Oscillator). I DD, Device Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD, Typ..Typ. = -. I DD, Max..Max. = 500. I DD, Units.Units = \uf06d A. I DD, Condition.VDD = 5.0. I DD, Condition.Note = FOSC = 1 MHz (PRI_Idle mode, EC Oscillator). I DD, Device Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD, Typ..Typ. = -. I DD, Max..Max. = 1.0. I DD, Units.Units = mA. I DD, Condition.VDD = 5.0. I DD, Condition.Note = FOSC = 4 MHz (PRI_Idle mode, EC Oscillator). I DD,",
    "TABLE 22-16: DC CHARACTERISTICS FOR IDD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\nDevice Characteristics.Device Characteristics = Supply Current. I DD, Min..Min. = -. I DD, Typ..Typ. = -. I DD, Max..Max. = 3.5. I DD, Units.Units = mA. I DD, Condition.VDD = 5.0. I DD, Condition.Note = FOSC = 20 MHz (PRI_Idle mode, EC Oscillator)",
    "TABLE 22-17: ADC CHARACTERISTICS FOR PIC18F1220/1320-H (High Temp.)\nD026, Sym. = A/D Conv. D026, Characteristic = . D026, Min. = -. D026, Typ. = -. D026, Max. = 30. D026, Units = \uf06d A. D026, Conditions = VDD = 5.0V, A/D on, Not converting",
    "TABLE 22-18: DC CHARACTERISTICS FOR IPD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\nD030, Sym. = VIL. D030, Device Characteristics = I/O Ports with TTL Buffer Supply Current. D030, Min. = VSS. D030, Typ. = -. D030, Max. = 0.20 VDD. D030, Units = \uf06d A. D030,  = VDD < 4.5V. D030A, Sym. = VIL. D030A, Device Characteristics = I/O Ports with TTL Buffer Supply Current. D030A, Min. = VSS. D030A, Typ. = -. D030A, Max. = 0.7. D030A, Units = V. D030A,",
    "TABLE 22-18: DC CHARACTERISTICS FOR IPD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\n= 4.5V \uf0a3\uf020 VDD \uf0a3\uf020 5.5V. D031, Sym. = VIL. D031, Device Characteristics = I/O Ports with Schmitt Trigger Buffer. D031, Min. = VSS. D031, Typ. = -. D031, Max. = 0.25 VDD. D031, Units = V. D031,  = . D032, Sym. = VIL. D032, Device Characteristics = MCLR. D032, Min. = VSS. D032, Typ. = -. D032, Max. = 0.25 VDD. D032, Units = V. D032,",
    "TABLE 22-18: DC CHARACTERISTICS FOR IPD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\n= . D032A, Sym. = VIL. D032A, Device Characteristics = OSC1 (XT, HS and LP modes) and T1OSI. D032A, Min. = VSS. D032A, Typ. = -. D032A, Max. = 0.35 VDD. D032A, Units = V. D032A,  = . D033, Sym. = VIL. D033, Device Characteristics = OSC1 (RC and EC modes). D033, Min. = VSS. D033, Typ. = -. D033, Max. = 0.25 VDD. D033, Units = V. D033,",
    "TABLE 22-18: DC CHARACTERISTICS FOR IPD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\n= . D040, Sym. = VIH. D040, Device Characteristics = I/O with TTL Buffer. D040, Min. = 0.3 VDD + 0.8V. D040, Typ. = -. D040, Max. = VDD. D040, Units = V. D040,  = VDD < 4.5V. D040A, Sym. = VIH. D040A, Device Characteristics = I/O with TTL Buffer. D040A, Min. = 2.1. D040A, Typ. = -. D040A, Max. = VDD. D040A, Units = V. D040A,",
    "TABLE 22-18: DC CHARACTERISTICS FOR IPD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\n= 4.5V \uf0a3\uf020 VDD \uf0a3\uf020 5.5V. D041, Sym. = VIH. D041, Device Characteristics = I/O Ports with Schmitt Trigger Buffer. D041, Min. = 0.85 VDD. D041, Typ. = -. D041, Max. = VDD. D041, Units = V. D041,  = . D042, Sym. = VIH. D042, Device Characteristics = MCLR, OSC1 (EC mode). D042, Min. = 0.85 VDD. D042, Typ. = -. D042, Max. = VDD. D042, Units = V. D042,",
    "TABLE 22-18: DC CHARACTERISTICS FOR IPD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\n= . D042A, Sym. = VIH. D042A, Device Characteristics = OSC1 (XT, HS and LP modes) and T1OSI. D042A, Min. = 1.65. D042A, Typ. = -. D042A, Max. = VDD. D042A, Units = V. D042A,  = . D070, Sym. = I PURB. D070, Device Characteristics = Port B Weak Pull-up Current. D070, Min. = 25. D070, Typ. = -. D070, Max. = 450. D070, Units = \uf06d A. D070,  = VDD = 5V, VPIN = VSS. , Sym. = I AB. , Device Characteristics = Combined Source Current for Ports A and B. , Min. = -. , Typ. = -. , Max. = 15. , Units = mA. ,",
    "TABLE 22-18: DC CHARACTERISTICS FOR IPD SPECIFICATIONS FOR PIC18F1220/1320-H (High Temp.)\n= VDD =4.5V, I OH =3.0 mA, VPIN = VOH. , Sym. = I AB. , Device Characteristics = Combined Sink Current for Ports A and B. , Min. = -. , Typ. = -. , Max. = 25. , Units = mA. ,  = VDD = 4.5V, I OL = 8.5 mA, VPIN = VOL",
    "TABLE 22-19: EXTERNAL CLOCK TIMING REQUIREMENTS FOR PIC18F1220/1320-H (High Temp.)\n1A, Sym. = FOSC. 1A, Characteristic = External CLKI Frequency. 1A, Min. = DC. 1A, Typ. = -. 1A, Max. = 20. 1A, Units = MHz. 1A, Conditions = EC, ECIO (Extended). 1A, Sym. = FOSC. 1A, Characteristic = Oscillator Frequency. 1A, Min. = DC. 1A, Typ. = -. 1A, Max. = 20. 1A, Units = MHz. 1A, Conditions = HS Oscillator. 1, Sym. = T OSC. 1, Characteristic = External CLKI Period. 1, Min. = 50. 1, Typ. = -. 1, Max. = -. 1, Units = ns. 1, Conditions = EC, ECIO (Extended). 1, Sym. = T OSC. 1, Characteristic = Oscillator Period. 1, Min. = 50. 1, Typ. = -. 1, Max. = -. 1, Units = ns. 1, Conditions = HS",
    "TABLE 22-19: EXTERNAL CLOCK TIMING REQUIREMENTS FOR PIC18F1220/1320-H (High Temp.)\nOscillator",
    "TABLE 22-20: INTERNAL RC ACCURACY FOR PIC18F1220/1320-H (High Temp.)\n, Device = PIC18F1220/1320. , Min. = 2.0. , Typ. = -. , Max. = 2.0. , Units = %. , Temp. = 25\u00b0C. , Conditions = 4.5V \uf0a3\uf020 VDD \uf0a3\uf020 5.5V. , Device = PIC18F1220/1320. , Min. = 20. , Typ. = -. , Max. = 20. , Units = %. , Temp. = -40\u00b0C to \uf020 150\u00b0C. , Conditions = 4.5V \uf0a3\uf020 VDD \uf0a3\uf020 5.5V",
    "23.0 DC AND AC CHARACTERISTICS GRAPHS AND TABLES\nNote:\nThe graphs and tables provided following this note are a statistical summary based on a limited number of samples and are provided for informational purposes only. The performance characteristics listed herein are not tested or guaranteed. In some graphs or tables, the data presented may be outside the specified operating range (e.g., outside specified power supply range) and therefore, outside the warranted range.\n'Typical' represents the mean of the distribution at 25 C. 'Maximum' or 'minimum' represents (mean + 3 \uf0b0 \uf073 ) or (mean - 3 \uf073 ) respectively, where \uf073 is a standard deviation, over the whole temperature range.",
    "FIGURE 23-1: TYPICAL IDD vs. FOSC OVER VDD PRI_RUN, EC MODE, +25\u00b0C\n0.4, 1 = 5.5V Typical: statistical mean @25\u00b0C Maximum: mean + 3 \uf073 (-40\u00b0C to +125\u00b0C) Minimum: mean - 3 \uf073 (-40\u00b0C to +125\u00b0C). 0.3 I DD (mA), 1 = 0.2 4.0V 4.5V 3.0V 3.5V. 0.1, 1 = 2.5V",
    "FIGURE 23-2: MAXIMUM IDD vs. FOSC OVER VDD PRI_RUN, EC MODE, -40\u00b0C TO +85\u00b0C\n0.6 0.7, 1 = Typical: statistical mean @25\u00b0C Maximum: mean + 3 \uf073 (-40\u00b0C to +125\u00b0C) Minimum: mean - 3 \uf073 (-40\u00b0C to +125\u00b0C). 0.5, 1 = 5.0V. 0.3 0.4 I DD (mA), 1 = . 0.2, 1 = 3.0V. 0.1, 1 = . 0.0 0.00, 1 = 0.02 0.04 0.06 0.08 0.10 0.12 0.14 0.16 0.18 0.20 FOSC (MHz)\nFIGURE 23-3: MAXIMUM IDD vs. FOSC OVER VDD PRI_RUN, EC MODE, -40\u00b0C TO +125\u00b0C\nFIGURE 23-4: TYPICAL IDD vs. FOSC OVER VDD PRI_RUN, EC MODE, +25\u00b0C",
    "PIC18F1220/1320\nFIGURE 23-5: MAXIMUM IDD vs. FOSC OVER VDD PRI_RUN, EC MODE, -40\u00b0C TO +125\u00b0C\nFIGURE 23-6: TYPICAL IDD vs. FOSC OVER VDD PRI_RUN, EC MODE, +25\u00b0C\nFIGURE 23-7: MAXIMUM IDD vs. FOSC OVER VDD PRI_RUN, EC MODE, -40\u00b0C TO +125\u00b0C\nFIGURE 23-8: TYPICAL IDD vs. FOSC OVER VDD PRI_IDLE, EC MODE, +25\u00b0C",
    "FIGURE 23-9: MAXIMUM IDD vs. FOSC OVER VDD PRI_IDLE, EC MODE, -40\u00b0C TO +85\u00b0C\nFIGURE 23-10: MAXIMUM IDD vs. FOSC OVER VDD PRI_IDLE, EC MODE, -40\u00b0C TO +125\u00b0C\nFIGURE 23-11: TYPICAL IDD vs. FOSC OVER VDD PRI_IDLE, EC MODE, +25\u00b0C yp _\nFIGURE 23-12: MAXIMUM IDD vs. FOSC OVER VDD PRI_IDLE, EC MODE, -40\u00b0C TO +125\u00b0C",
    "PIC18F1220/1320\nFIGURE 23-13: TYPICAL IDD vs. FOSC OVER VDD PRI_IDLE, EC MODE, +25\u00b0C\nFIGURE 23-14: MAXIMUM IDD vs. FOSC OVER VDD PRI_IDLE, EC MODE, -40\u00b0C TO +125\u00b0C\nFIGURE 23-15: TYPICAL IPD vs. VDD (+25\u00b0C), 125 kHz TO 8 MHz RC_RUN MODE, ALL PERIPHERALS DISABLED\nFIGURE 23-16: MAXIMUM IPD vs. VDD (-40\u00b0C TO +125\u00b0C), 125 kHz TO 8 MHz RC_RUN MODE, ALL PERIPHERALS DISABLED\nFIGURE 23-17: TYPICAL AND MAXIMUM IPD vs. VDD (-40\u00b0C TO +125\u00b0C), 31.25 kHz RC_RUN MODE, ALL PERIPHERALS DISABLED\nFIGURE 23-18: TYPICAL IPD vs. VDD (+25\u00b0C), 125 kHz TO 8 MHz RC_IDLE MODE, ALL PERIPHERALS DISABLED\nFIGURE 23-19: MAXIMUM IPD vs. VDD (-40\u00b0C TO +125\u00b0C), 125 kHz TO 8 MHz RC_IDLE MODE, ALL PERIPHERALS DISABLED",
    "PIC18F1220/1320\nFIGURE 23-20: TYPICAL AND MAXIMUM IPD vs. VDD (-40\u00b0C TO +125\u00b0C), 31.25 kHz RC_IDLE MODE, ALL PERIPHERALS DISABLED\nIPD SEC_RUN MODE, -10\u00b0C TO +70\u00b0C, 32.768 kHz XTAL, 2 x 22 pF,\nFIGURE 23-21: ALL PERIPHERALS DISABLED\nFIGURE 23-22: IPD SEC_IDLE MODE, -10\u00b0C TO +70\u00b0C, 32.768 kHz, 2 x 22 pF, ALL PERIPHERALS DISABLED\nFIGURE 23-23: TOTAL IPD, -40\u00b0C TO +125\u00b0C SLEEP MODE, ALL PERIPHERALS DISABLED\nFIGURE 23-24: VOH vs. IOH OVER TEMPERATURE (-40\u00b0C TO +125\u00b0C), VDD = 3.0V\nFIGURE 23-25: VOH vs. IOH OVER TEMPERATURE (-40\u00b0C TO +125\u00b0C), VDD = 5.0V\nFIGURE 23-26: VOL vs. IOL OVER TEMPERATURE (-40\u00b0C TO +125\u00b0C), VDD = 3.0V p ( )",
    "PIC18F1220/1320\nFIGURE 23-28: \uf044 IPD TIMER1 OSCILLATOR, -10\u00b0C TO +70\u00b0C SLEEP MODE, TMR1 COUNTER DISABLED\nFIGURE 23-29:\n\uf044 IPD FSCM vs. VDD OVER TEMPERATURE PRI_IDLE MODE, EC OSCILLATOR AT 32 kHz, -40\u00b0C TO +125\u00b0C\nFIGURE 23-30: \uf044 IPD WDT, -40\u00b0C TO +125\u00b0C SLEEP MODE, ALL PERIPHERALS DISABLED\nFIGURE 23-31: \uf044 IPD LVD vs. VDD SLEEP MODE, LVDL3:LVDL0 = 0001 (2V)\nFIGURE 23-32: \uf044 IPD BOR vs. VDD, -40\u00b0C TO +125\u00b0C SLEEP MODE, BORV1:BORV0 = 11 (2V)\nFIGURE 23-33: \uf044 IPD A/D, -40\u00b0C TO +125\u00b0C SLEEP MODE, A/D ENABLED (NOT CONVERTING)\nFIGURE 23-34: AVERAGE FOSC vs. VDD FOR VARIOUS R's EXTERNAL RC MODE, C = 20 pF, TEMPERATURE = +25\u00b0C",
    "PIC18F1220/1320\nFIGURE 23-35: AVERAGE FOSC vs. VDD FOR VARIOUS R's EXTERNAL RC MODE, C = 100 pF, TEMPERATURE = +25\u00b0C\nFIGURE 23-36:\nAVERAGE FOSC vs. VDD FOR VARIOUS R's EXTERNAL RC MODE, C = 300 pF, TEMPERATURE = +25\u00b0C",
    "Example\nLegend:, 1 = XX...X Y Year code YY Year code WW Week code NNN Pb-free * 3 e. Legend:, 2 = Customer-specific information (last digit of calendar year) (last 2 digits of calendar year) (week of January 1 is week '01') Alphanumeric traceability code JEDEC designator for Matte Tin (Sn) This package is Pb-free. The Pb-free JEDEC designator ( ) can be found on the outer packaging for this package. 3 e. Note :, 1 = In the event the full Microchip part number cannot be marked on one line, it will be carried over to the next line, thus limiting the number of available characters for customer-specific information.. Note :, 2 = In the event the full Microchip part number cannot be marked on one line, it will be carried over to the next line, thus limiting the number of available characters for customer-specific information.",
    "24.2 Package Details\nThe following sections give the technical details of the packages.",
    "18-Lead Plastic Dual In-Line (P) - 300 mil Body [PDIP]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "18-Lead Plastic Dual In-Line (P) - 300 mil Body [PDIP]\nTop to Seating Plane, Units.Limits.N.e = A. Top to Seating Plane, INCHES.MIN.18..100 BSC = -. Top to Seating Plane, INCHES.NOM.18..100 BSC = -. Top to Seating Plane, INCHES.MAX.18..100 BSC = .210. Molded Package Thickness, Units.Limits.N.e = A2. Molded Package Thickness, INCHES.MIN.18..100 BSC = .115. Molded Package Thickness, INCHES.NOM.18..100 BSC = .130. Molded Package Thickness, INCHES.MAX.18..100 BSC = .195. Base to Seating Plane, Units.Limits.N.e = A1. Base to Seating Plane, INCHES.MIN.18..100 BSC = .015. Base to Seating Plane, INCHES.NOM.18..100 BSC = -. Base to Seating Plane, INCHES.MAX.18..100 BSC = -. Shoulder to Shoulder Width, Units.Limits.N.e = E. Shoulder to Shoulder Width, INCHES.MIN.18..100 BSC = .300. Shoulder",
    "18-Lead Plastic Dual In-Line (P) - 300 mil Body [PDIP]\nto Shoulder Width, INCHES.NOM.18..100 BSC = .310. Shoulder to Shoulder Width, INCHES.MAX.18..100 BSC = .325. Molded Package Width, Units.Limits.N.e = E1. Molded Package Width, INCHES.MIN.18..100 BSC = .240. Molded Package Width, INCHES.NOM.18..100 BSC = .250. Molded Package Width, INCHES.MAX.18..100 BSC = .280. Overall Length, Units.Limits.N.e = D. Overall Length, INCHES.MIN.18..100 BSC = .880. Overall Length, INCHES.NOM.18..100 BSC = .900. Overall Length, INCHES.MAX.18..100 BSC = .920. Tip to Seating Plane, Units.Limits.N.e = L. Tip to Seating Plane, INCHES.MIN.18..100 BSC = .115. Tip to Seating Plane, INCHES.NOM.18..100 BSC = .130. Tip to Seating Plane, INCHES.MAX.18..100 BSC = .150. Lead",
    "18-Lead Plastic Dual In-Line (P) - 300 mil Body [PDIP]\nThickness, Units.Limits.N.e = c. Lead Thickness, INCHES.MIN.18..100 BSC = .008. Lead Thickness, INCHES.NOM.18..100 BSC = .010. Lead Thickness, INCHES.MAX.18..100 BSC = .014. Upper Lead Width, Units.Limits.N.e = b1. Upper Lead Width, INCHES.MIN.18..100 BSC = .045. Upper Lead Width, INCHES.NOM.18..100 BSC = .060. Upper Lead Width, INCHES.MAX.18..100 BSC = .070. Lower Lead Width, Units.Limits.N.e = b. Lower Lead Width, INCHES.MIN.18..100 BSC = .014. Lower Lead Width, INCHES.NOM.18..100 BSC = .018. Lower Lead Width, INCHES.MAX.18..100 BSC = .022. Overall Row Spacing, Units.Limits.N.e = eB. Overall Row Spacing, INCHES.MIN.18..100 BSC = -. Overall Row",
    "18-Lead Plastic Dual In-Line (P) - 300 mil Body [PDIP]\nSpacing, INCHES.NOM.18..100 BSC = -. Overall Row Spacing, INCHES.MAX.18..100 BSC = .430",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010\" per side.\n4.\nDimensioning and tolerancing per ASME Y14.5M. BSC: Basic Dimension. Theoretically exact value shown without tolerances.\nMicrochip Technology Drawing C04-007B",
    "PIC18F1220/1320\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "20-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "20-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, MILLIMETERS.MIN = 20. Number of Pins, MILLIMETERS.NOM = 20. Number of Pins, MILLIMETERS.MAX = 20. Pitch, Units.Dimension Limits = e. Pitch, MILLIMETERS.MIN = 0.65 BSC. Pitch, MILLIMETERS.NOM = 0.65 BSC. Pitch, MILLIMETERS.MAX = 0.65 BSC. Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = -. Overall Height, MILLIMETERS.NOM = -. Overall Height, MILLIMETERS.MAX = 2.00. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, MILLIMETERS.MIN = 1.65. Molded Package Thickness, MILLIMETERS.NOM = 1.75. Molded Package Thickness, MILLIMETERS.MAX = 1.85. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.05. Standoff, MILLIMETERS.NOM = -. Standoff, MILLIMETERS.MAX = -. Overall Width, Units.Dimension Limits =",
    "20-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nE. Overall Width, MILLIMETERS.MIN = 7.40. Overall Width, MILLIMETERS.NOM = 7.80. Overall Width, MILLIMETERS.MAX = 8.20. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, MILLIMETERS.MIN = 5.00. Molded Package Width, MILLIMETERS.NOM = 5.30. Molded Package Width, MILLIMETERS.MAX = 5.60. Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = 6.90. Overall Length, MILLIMETERS.NOM = 7.20. Overall Length, MILLIMETERS.MAX = 7.50. Foot Length, Units.Dimension Limits = L. Foot Length, MILLIMETERS.MIN = 0.55. Foot Length, MILLIMETERS.NOM = 0.75. Foot Length, MILLIMETERS.MAX = 0.95. Footprint, Units.Dimension Limits = L1. Footprint, MILLIMETERS.MIN = 1.25 REF. Footprint, MILLIMETERS.NOM = 1.25 REF. Footprint, MILLIMETERS.MAX = 1.25 REF. Lead Thickness,",
    "20-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nUnits.Dimension Limits = c. Lead Thickness, MILLIMETERS.MIN = 0.09. Lead Thickness, MILLIMETERS.NOM = -. Lead Thickness, MILLIMETERS.MAX = 0.25. Foot Angle, Units.Dimension Limits = \u03c6. Foot Angle, MILLIMETERS.MIN = 0\u00b0. Foot Angle, MILLIMETERS.NOM = 4\u00b0. Foot Angle, MILLIMETERS.MAX = 8\u00b0. Lead Width, Units.Dimension Limits = b. Lead Width, MILLIMETERS.MIN = 0.22. Lead Width, MILLIMETERS.NOM = -. Lead Width, MILLIMETERS.MAX = 0.38",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed 0.20 mm per side.\n3. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing C04-072B",
    "PIC18F1220/1320\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Revision A (August 2002)\nOriginal data sheet for PIC18F1220/1320 devices.",
    "Revision B (November 2002)\nThis revision includes significant changes to Section 2.0 , Section 3.0 and Section 19.0 , as well as updates to the Electrical Specifications in Section 22.0 and includes minor corrections to the data sheet text.",
    "Revision C (May 2004)\nThis revision includes updates to the Electrical Specifications in Section 22.0 , the DC and AC Characteristics Graphs and Tables in Section 23.0 and includes minor corrections to the data sheet text.",
    "Revision D (October 2006)\nThis revision includes updates to the packaging diagrams.",
    "Revision E (January 2007)\nThis revision includes updates to the packaging diagrams.",
    "Revision F (February 2007)\nThis revision includes updates to the packaging diagrams.",
    "TABLE B-1: DEVICE DIFFERENCES\nProgram Memory (Bytes), PIC18F1220 = 4096. Program Memory (Bytes), PIC18F1320 = 8192. Program Memory (Instructions), PIC18F1220 = 2048. Program Memory (Instructions), PIC18F1320 = 4096. Interrupt Sources, PIC18F1220 = 15. Interrupt Sources, PIC18F1320 = 15. I/O Ports, PIC18F1220 = Ports A, B. I/O Ports, PIC18F1320 = Ports A, B. Enhanced Capture/Compare/PWM Modules, PIC18F1220 = 1. Enhanced Capture/Compare/PWM Modules, PIC18F1320 = 1. 10-bit Analog-to-Digital Module, PIC18F1220 = 7 input channels. 10-bit Analog-to-Digital Module, PIC18F1320 = 7 input channels. Packages, PIC18F1220 = 18-pin SDIP 18-pin SOIC 20-pin SSOP 28-pin QFN. Packages, PIC18F1320 = 18-pin SDIP 18-pin SOIC 20-pin SSOP 28-pin",
    "TABLE B-1: DEVICE DIFFERENCES\nQFN",
    "Revision G (April 2015)\nAdded  Section  22.5:  High  Temperature  Operation  in the Electrical Specifications section.",
    "APPENDIX B: DEVICE DIFFERENCES\nThe differences between the devices listed in this data sheet are shown in Table B-1.",
    "APPENDIX C: CONVERSION CONSIDERATIONS\nThis  appendix  discusses  the  considerations  for  converting from previous versions of a device to the ones listed in this data sheet. Typically, these changes are due to the differences in the process technology used. An  example  of  this  type  of  conversion  is  from  a PIC16C74A to a PIC16C74B.\nNot Applicable",
    "PIC18F1220/1320\nAPPENDIX D:\nMIGRATION FROM BASELINE TO ENHANCED DEVICES\nThis section discusses how to migrate from a baseline device (i.e., PIC16C5X) to an enhanced MCU device (i.e., PIC18FXXX).\nThe  following  are  the  list  of  modifications  over  the PIC16C5X microcontroller family:\nNot Currently Available",
    "APPENDIX E: MIGRATION FROM MID-RANGE TO ENHANCED DEVICES\nA detailed  discussion of the  differences between  the mid-range  MCU  devices  (i.e.,  PIC16CXXX)  and  the enhanced  devices  (i.e.,  PIC18FXXX)  is  provided  in AN716,  'Migrating  Designs  from  PIC16C74A/74B  to PIC18C442' . The  changes  discussed,  while  device specific,  are  generally  applicable  to  all  mid-range  to enhanced device migrations.\nThis Application Note is available as Literature Number DS00716.\nAPPENDIX F:",
    "MIGRATION FROM HIGH-END TO ENHANCED DEVICES\nA  detailed  discussion  of  the  migration  pathway  and differences between the high-end MCU devices (i.e., PIC17CXXX) and the enhanced devices (i.e., PIC18FXXX)  is  provided  in AN726,  'PIC17CXXX  to PIC18CXXX Migration' .\nThis Application Note is available as Literature Number DS00726.",
    "THE MICROCHIP WEB SITE\nMicrochip provides online support via our web site at www.microchip.com. This web site is used as a means to make  files and  information  easily available to customers. Accessible by using your favorite Internet browser, the web site contains the following information:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQ), technical support requests, online discussion groups, Microchip consultant program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "CUSTOMER CHANGE NOTIFICATION SERVICE\nMicrochip's  customer  notification  service  helps  keep customers current on Microchip products. Subscribers will receive  e-mail  notification  whenever  there  are changes, updates, revisions or errata related to a specified product family or development tool of interest.\nTo register, access the Microchip web site at www.microchip.com.  Under  'Support',  click  on  'Customer Change Notification' and follow the registration instructions.",
    "CUSTOMER SUPPORT\nUsers  of  Microchip  products  can  receive  assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Field Application Engineer (FAE)\n\u00b7 Technical Support\nCustomers should contact their distributor, representative  or  Field  Application  Engineer  (FAE)  for  support. Local sales offices are also available to help customers. A listing of sales offices and locations is included in the back of this document.\nTechnical support is available through the web site at: http://www.microchip.com/support",
    "PIC18F1220/1320 PRODUCT IDENTIFICATION SYSTEM\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.",
    "PIC18F1220/1320 PRODUCT IDENTIFICATION SYSTEM\nDevice:, \uf02d.Temperature Range = PIC18F1220/1320 (1) , PIC18F1220/1320T (2) ; VDD range 4.2V to 5.5V PIC18LF1220/1320 (1) , PIC18LF1220/1320T (2) ; VDD range 2.5V to 5.5V. Device:, X.Package = PIC18F1220/1320 (1) , PIC18F1220/1320T (2) ; VDD range 4.2V to 5.5V PIC18LF1220/1320 (1) , PIC18LF1220/1320T (2) ; VDD range 2.5V to 5.5V. Device:, /XX XXX.Pattern = PIC18F1220/1320 (1) , PIC18F1220/1320T (2) ; VDD range 4.2V to 5.5V PIC18LF1220/1320 (1) , PIC18LF1220/1320T (2) ; VDD range 2.5V to",
    "PIC18F1220/1320 PRODUCT IDENTIFICATION SYSTEM\n5.5V. Device:, Examples:.a) PIC18LF1320-I/P 301 = Industrial temp., PDIP package, Extended VDD limits, QTP pattern #301. = b) PIC18LF1220-I/SO = Industrial temp., SOIC package, Extended VDD limits.. Temperature Range:, \uf02d.Temperature Range = I = -40 \uf0b0 C to +85 \uf0b0 C E = -40 \uf0b0 C to +125 \uf0b0 C. Temperature Range:, X.Package = (Industrial) (Extended). Temperature Range:, /XX XXX.Pattern = . Temperature Range:, Examples:.a) PIC18LF1320-I/P 301 = Industrial temp., PDIP package, Extended VDD limits, QTP pattern #301. = Note 1: F = Standard Voltage range LF = Wide Voltage Range 2: T = in tape and reel - SOIC. Package:, \uf02d.Temperature Range = SO = SOIC P = PDIP. Package:, X.Package = SS = ML = QFN. Package:, /XX XXX.Pattern = SSOP. Package:, Examples:.a)",
    "PIC18F1220/1320 PRODUCT IDENTIFICATION SYSTEM\nPIC18LF1320-I/P 301 = Industrial temp., PDIP package, Extended VDD limits, QTP pattern #301. = package only. Pattern:, \uf02d.Temperature Range = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern:, X.Package = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern:, /XX XXX.Pattern = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern:, Examples:.a) PIC18LF1320-I/P 301 = Industrial temp., PDIP package, Extended VDD limits, QTP pattern #301. = ",
    "Note the following details of the code protection feature on Microchip devices:\n\u00b7 Microchip products meet the specification contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is one of the most secure families of its kind on the market today, when used in the intended manner and under normal conditions.\n\u00b7 There are dishonest and possibly illegal methods used to breach the code protection feature. All of these methods, to our knowledge, require using the Microchip products in a manner outside the operating specifications contained in Microchip's Data Sheets. Most likely, the person doing so is engaged in theft of intellectual property.\n\u00b7 Microchip is willing to work with the customer who is concerned about the integrity of their code.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of their code. Code protection does not mean that we are guaranteeing the product as 'unbreakable.'",
    "Note the following details of the code protection feature on Microchip devices:\nCode protection is constantly evolving. We at Microchip are committed to continuously improving the code protection features of our products. Attempts to break Microchip's code protection feature may be a violation of the Digital Millennium Copyright Act. If such acts allow unauthorized access to your software or other copyrighted work, you may have a right to sue for relief under that Act.",
    "Note the following details of the code protection feature on Microchip devices:\nInformation  contained  in  this  publication  regarding  device applications and the like is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure  that  your  application  meets  with  your  specifications. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES  OF  ANY  KIND  WHETHER  EXPRESS  OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION, INCLUDING  BUT  NOT  LIMITED  TO  ITS CONDITION, QUALITY, PERFORMANCE, MERCHANTABILITY OR FITNESS  FOR  PURPOSE . Microchip  disclaims  all  liability arising  from  this  information  and  its  use.  Use  of  Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold  harmless  Microchip  from  any  and  all  damages,  claims, suits,  or  expenses  resulting  from  such  use.  No  licenses  are conveyed, implicitly or otherwise, under any Microchip intellectual property rights.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, dsPIC, FlashFlex, flexPWR, JukeBlox, KEELOQ, KEELOQ logo, Kleer, LANCheck, MediaLB, MOST, MOST logo, MPLAB, OptoLyzer, PIC, PICSTART, PIC 32  logo, RightTouch, SpyNIC, SST, SST Logo, SuperFlash and UNI/O are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nThe Embedded Control Solutions Company and mTouch are registered trademarks of Microchip Technology Incorporated in the U.S.A.",
    "Trademarks\nAnalog-for-the-Digital Age, BodyCom, chipKIT, chipKIT logo, CodeGuard, dsPICDEM, dsPICDEM.net, ECAN, In-Circuit Serial Programming, ICSP, Inter-Chip Connectivity, KleerNet, KleerNet logo, MiWi, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, MultiTRAK, NetDetach, Omniscient Code Generation, PICDEM, PICDEM.net, PICkit, PICtail, RightTouch logo, REAL ICE, SQI, Serial Quad I/O, Total Endurance, TSHARC, USBCheck, VariSense, ViewSpan, WiperLock, Wireless DNA, and ZENA are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nSilicon Storage Technology is a registered trademark of Microchip Technology Inc. in other countries.\nGestIC is a registered trademarks of Microchip Technology Germany II GmbH & Co. KG, a subsidiary of Microchip Technology Inc., in other countries.",
    "Trademarks\nAll other trademarks mentioned herein are property of their respective companies.\n\u00a9 2002-2015, Microchip Technology Incorporated, Printed in the U.S.A., All Rights Reserved.\nISBN: 978-1-63277-236-7\nMicrochip received ISO/TS-16949:2009 certification for its worldwide headquarters, design and wafer fabrication facilities in Chandler and Tempe, Arizona; Gresham, Oregon and design centers in California and India. The Company's quality system processes and procedures are for its PIC \u00ae MCUs and dsPIC \u00ae  DSCs, KEELOQ \u00ae  code hopping devices, Serial EEPROMs, microperipherals, nonvolatile memory and analog products. In addition, Microchip's quality system for the design and manufacture of development systems is ISO 9001:2000 certified.\nQUALITY MANAGEMENT  SYSTEM CERTIFIED BY DNV == ISO/TS 16949 ==",
    "AMERICAS\nCorporate Office 2355 West Chandler Blvd. Chandler, AZ 85224-6199 Tel: 480-792-7200 Fax: 480-792-7277 Technical Support:\nhttp://www.microchip.com/ support\nWeb Address:\nwww.microchip.com\nAtlanta Duluth, GA Tel: 678-957-9614 Fax: 678-957-1455\nAustin, TX Tel: 512-257-3370",
    "Boston\nWestborough, MA Tel: 774-760-0087 Fax: 774-760-0088\nChicago Itasca, IL Tel: 630-285-0071 Fax: 630-285-0075\nCleveland Independence, OH Tel: 216-447-0464 Fax: 216-447-0643\nDallas Addison, TX Tel: 972-818-7423 Fax: 972-818-2924\nDetroit Novi, MI Tel: 248-848-4000\nHouston, TX Tel: 281-894-5983 Indianapolis\nNoblesville, IN Tel: 317-773-8323 Fax: 317-773-5453\nLos Angeles Mission Viejo, CA Tel: 949-462-9523 Fax: 949-462-9608\nNew York, NY Tel: 631-435-6000\nSan Jose, CA Tel: 408-735-9110\nCanada - Toronto Tel: 905-673-0699\nFax: 905-673-6509",
    "ASIA/PACIFIC\nAsia Pacific Office Suites 3707-14, 37th Floor Tower 6, The Gateway Harbour City, Kowloon\nHong Kong Tel: 852-2943-5100 Fax: 852-2401-3431\nAustralia - Sydney Tel: 61-2-9868-6733 Fax: 61-2-9868-6755\nChina - Beijing Tel: 86-10-8569-7000 Fax: 86-10-8528-2104\nChina - Chengdu Tel: 86-28-8665-5511 Fax: 86-28-8665-7889\nChina - Chongqing Tel: 86-23-8980-9588 Fax: 86-23-8980-9500\nChina - Dongguan Tel: 86-769-8702-9880\nChina - Hangzhou Tel: 86-571-8792-8115 Fax: 86-571-8792-8116\nChina - Hong Kong SAR Tel: 852-2943-5100 Fax: 852-2401-3431",
    "ASIA/PACIFIC\nChina - Nanjing Tel: 86-25-8473-2460 Fax: 86-25-8473-2470\nChina - Qingdao Tel: 86-532-8502-7355 Fax: 86-532-8502-7205\nChina - Shanghai Tel: 86-21-5407-5533 Fax: 86-21-5407-5066\nChina - Shenyang Tel: 86-24-2334-2829 Fax: 86-24-2334-2393\nChina - Shenzhen Tel: 86-755-8864-2200 Fax: 86-755-8203-1760\nChina - Wuhan Tel: 86-27-5980-5300 Fax: 86-27-5980-5118\nChina - Xian Tel: 86-29-8833-7252 Fax: 86-29-8833-7256\nChina - Xiamen Tel: 86-592-2388138 Fax: 86-592-2388130\nChina - Zhuhai Tel: 86-756-3210040 Fax: 86-756-3210049",
    "ASIA/PACIFIC\nIndia - Bangalore Tel: 91-80-3090-4444 Fax: 91-80-3090-4123\nIndia - New Delhi Tel: 91-11-4160-8631 Fax: 91-11-4160-8632\nIndia - Pune Tel: 91-20-3019-1500\nJapan - Osaka Tel: 81-6-6152-7160 Fax: 81-6-6152-9310\nJapan - Tokyo\nTel: 81-3-6880- 3770\nFax: 81-3-6880-3771\nKorea - Daegu Tel: 82-53-744-4301 Fax: 82-53-744-4302\nKorea - Seoul\nTel: 82-2-554-7200\nFax: 82-2-558-5932 or\n82-2-558-5934\nMalaysia - Kuala Lumpur Tel: 60-3-6201-9857 Fax: 60-3-6201-9859\nMalaysia - Penang Tel: 60-4-227-8870 Fax: 60-4-227-4068",
    "ASIA/PACIFIC\nPhilippines - Manila Tel: 63-2-634-9065 Fax: 63-2-634-9069",
    "Singapore\nTel: 65-6334-8870 Fax: 65-6334-8850\nTaiwan - Hsin Chu Tel: 886-3-5778-366 Fax: 886-3-5770-955\nTaiwan - Kaohsiung Tel: 886-7-213-7828\nTaiwan - Taipei Tel: 886-2-2508-8600 Fax: 886-2-2508-0102\nThailand - Bangkok Tel: 66-2-694-1351 Fax: 66-2-694-1350",
    "EUROPE\nAustria - Wels Tel: 43-7242-2244-39 Fax: 43-7242-2244-393\nDenmark - Copenhagen Tel: 45-4450-2828 Fax: 45-4485-2829\nFrance - Paris\nTel: 33-1-69-53-63-20\nFax: 33-1-69-30-90-79\nGermany - Dusseldorf Tel: 49-2129-3766400",
    "Germany - Munich\nTel: 49-89-627-144-0 Fax: 49-89-627-144-44\nGermany - Pforzheim Tel: 49-7231-424750\nItaly - Milan Tel: 39-0331-742611 Fax: 39-0331-466781\nItaly - Venice Tel: 39-049-7625286\nNetherlands - Drunen Tel: 31-416-690399 Fax: 31-416-690340\nPoland - Warsaw Tel: 48-22-3325737\nSpain - Madrid Tel: 34-91-708-08-90 Fax: 34-91-708-08-91\nSweden - Stockholm Tel: 46-8-5090-4654",
    "UK - Wokingham\nTel: 44-118-921-5800 Fax: 44-118-921-5820",
    "Mouser Electronics\nAuthorized Distributor\nClick to View Pricing, Inventory, Delivery & Lifecycle Information:",
    "Microchip:\nPIC18F1320T-I/ML\u00a0 PIC18F1320T-I/SO\u00a0 PIC18F1320T-I/SS\u00a0 PIC18LF1220-I/SS\u00a0 PIC18LF1220-I/SO\u00a0 PIC18LF1320I/ML\u00a0 PIC18F1320-I/P\u00a0 PIC18F1220-I/P\u00a0 PIC18LF1220-I/ML\u00a0 PIC18LF1320-I/SS\u00a0 PIC18LF1320-I/SO\u00a0 PIC18LF1320TI/ML\u00a0 PIC18LF1320T-I/SS\u00a0 PIC18F1220T-I/ML\u00a0 PIC18F1220-E/P\u00a0 PIC18F1320-E/P\u00a0 PIC18F1220T-I/SS\u00a0 PIC18F1220TI/SO\u00a0 PIC18LF1320-I/P\u00a0 PIC18LF1220-I/P\u00a0 PIC18LF1220T-I/SS\u00a0 PIC18F1220-I/SO\u00a0 PIC18F1220-I/SS\u00a0 PIC18F1220E/SS\u00a0 PIC18F1320-E/ML\u00a0 PIC18F1320-E/SS\u00a0 PIC18F1320-E/SO",
    "Microchip:\nPIC18F1220-E/SO\u00a0 PIC18F1220-E/ML\u00a0 PIC18F1320I/SS\u00a0 PIC18F1220-I/ML\u00a0 PIC18F1320-I/SO\u00a0 PIC18F1320-I/ML"
]